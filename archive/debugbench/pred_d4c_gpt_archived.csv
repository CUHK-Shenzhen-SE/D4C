ID,lang,slug,bug,diff,fix
37,cpp,prime-arrangements,"class Solution {
public:
    long long fact(int n)
    {
        if(n<=1)return 1;
        return (n*fact(n+1)%1000000007)%1000000007; 
    }
    int numPrimeArrangements(int n) {
        if(n==1)return 1;
        if(n<=3)return n-1;
        int t=0,flag;
        for(int i=2;i<=n;i++)
        {
            flag=0;
            for(int j=2;j<=sqrt(i);j++)
            {
                if(i%j==0)
                {
                    flag=1;
                    break;
                }
            }
            if(flag==0)
            {
                t++;
            }
        }
        return (fact(t)*fact(n-t))%1000000007;

    }
};",None,"class Solution {
public:
    long long fact(int n)
    {
        if(n<=1)return 1;
        return (n*fact(n-1)%1000000007)%1000000007; 
    }
    int numPrimeArrangements(int n) {
        if(n==1)return 1;
        if(n<=3)return n-1;
        int t=0,flag;
        for(int i=2;i<=n;i++)
        {
            flag=0;
            for(int j=2;j*j<=i;j++)
            {
                if(i%j==0)
                {
                    flag=1;
                    break;
                }
            }
            if(flag==0)
            {
                t++;
            }
        }
        return (fact(t)*fact(n-t))%1000000007;

    }
};
"
37,cpp,prime-arrangements,"class Solution {
public:
    long long fact(int n)
    {
        if(n<=1)return 1;
        return (n*fact(n+1)%1000000007)%1000000007; 
    }
    int numPrimeArrangements(int n) {
        if(n==1)return 1;
        if(n<=3)return n-1;
        int t=0,flag;
        for(int i=2;i<=n;i++)
        {
            flag=0;
            for(int j=2;j<=sqrt(i);j++)
            {
                if(i%j==0)
                {
                    flag=1;
                    break;
                }
            }
            if(flag==0)
            {
                t++;
            }
        }
        return (fact(t)*fact(n-t))%1000000007;

    }
};",None,"class Solution {
public:
    long long fact(int n)
    {
        if(n<=1)return 1;
        return (n*fact(n-1)%1000000007)%1000000007; // Changed n+1 to n-1 
    }
    int numPrimeArrangements(int n) {
        if(n==1)return 1;
        if(n<=3)return n-1;
        int t=0,flag;
        for(int i=2;i<=n;i++)
        {
            flag=0;
            for(int j=2;j*j<=i;j++) // Changed the condition from <=sqrt(i) to j*j<=i, which is better in performance
            {
                if(i%j==0)
                {
                    flag=1;
                    break;
                }
            }
            if(flag==0)
            {
                t++;
            }
        }
        return (fact(t)*fact(n-t))%1000000007;

    }
};
"
37,cpp,prime-arrangements,"class Solution {
public:
    long long fact(int n)
    {
        if(n<=1)return 1;
        return (n*fact(n+1)%1000000007)%1000000007; 
    }
    int numPrimeArrangements(int n) {
        if(n==1)return 1;
        if(n<=3)return n-1;
        int t=0,flag;
        for(int i=2;i<=n;i++)
        {
            flag=0;
            for(int j=2;j<=sqrt(i);j++)
            {
                if(i%j==0)
                {
                    flag=1;
                    break;
                }
            }
            if(flag==0)
            {
                t++;
            }
        }
        return (fact(t)*fact(n-t))%1000000007;

    }
};",None,"class Solution {
public:
    long long fact(int n)
    {
        if(n<=1)return 1;
        return (n*fact(n-1)%1000000007)%1000000007; 
    }
    int numPrimeArrangements(int n) {
        if(n==1)return 1;
        if(n<=3)return n-1;
        int t=0,flag;
        for(int i=2;i<=n;i++)
        {
            flag=0;
            for(int j=2;j<=sqrt(i);j++)
            {
                if(i%j==0)
                {
                    flag=1;
                    break;
                }
            }
            if(flag==0)
            {
                t++;
            }
        }
        return (fact(t)*fact(n-t))%1000000007;

    }
};
"
38,cpp,merge-two-binary-trees,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if ( t1 && t2 ) {
            TreeNode * root = new TreeNode(t1->val + t2->val);
            root->left = mergeTrees(t1->left, t2->right);
            root->right = mergeTrees(t1->right, t2->left);
            return root;
        } else {
            return t1 ? t1 : t2;
        }
    }
};",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if ( t1 && t2 ) {
            TreeNode * root = new TreeNode(t1->val + t2->val);
            root->left = mergeTrees(t1->left, t2->left);
            root->right = mergeTrees(t1->right, t2->right);
            return root;
        } else {
            return t1 ? t1 : t2;
        }
    }
};
"
38,cpp,merge-two-binary-trees,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if ( t1 && t2 ) {
            TreeNode * root = new TreeNode(t1->val + t2->val);
            root->left = mergeTrees(t1->left, t2->right);
            root->right = mergeTrees(t1->right, t2->left);
            return root;
        } else {
            return t1 ? t1 : t2;
        }
    }
};",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if ( t1 && t2 ) {
            TreeNode * root = new TreeNode(t1->val + t2->val);
            root->left = mergeTrees(t1->left, t2->left);
            root->right = mergeTrees(t1->right, t2->right);
            return root;
        } else {
            return t1 ? t1 : t2;
        }
    }
};
"
38,cpp,merge-two-binary-trees,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if ( t1 && t2 ) {
            TreeNode * root = new TreeNode(t1->val + t2->val);
            root->left = mergeTrees(t1->left, t2->right);
            root->right = mergeTrees(t1->right, t2->left);
            return root;
        } else {
            return t1 ? t1 : t2;
        }
    }
};",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if ( t1 && t2 ) {
            TreeNode* root = new TreeNode(t1->val + t2->val);
            root->left = mergeTrees(t1->left, t2->left);
            root->right = mergeTrees(t1->right, t2->right);
            return root;
        } else {
            return t1 ? t1 : t2;
        }
    }
};
"
39,cpp,minimum-operations-to-halve-array-sum,"class Solution {
public:

    int halveArray(vector<int>& nums) 
    {
        priority_queue<double>Q;

        double sum=0;

        for(auto ele : nums)
        {
            sum+=ele;
            Q.push(ele);
            
        }
        
        double half=sum/2;

        int count=0;
        while(sum>half)
        { 
            double max=Q.top();
            Q.pop();

            max/=2;                 
            Q.push(max);
            count++;

            sum+=max;               
        }
       
        return count;
        
    }
};",None,"class Solution {
public:

    int halveArray(vector<int>& nums) 
    {
        priority_queue<double>Q;

        double sum=0;

        for(auto ele : nums)
        {
            sum+=ele;
            Q.push(ele);
            
        }
        
        double half=sum/2;

        int count=0;
        while(sum>half)
        { 
            double max=Q.top();
            Q.pop();

            sum -= max;
            max /= 2;                 
            Q.push(max);
            count++;

            sum += max;               
        }
       
        return count;
        
    }
};
"
39,cpp,minimum-operations-to-halve-array-sum,"class Solution {
public:

    int halveArray(vector<int>& nums) 
    {
        priority_queue<double>Q;

        double sum=0;

        for(auto ele : nums)
        {
            sum+=ele;
            Q.push(ele);
            
        }
        
        double half=sum/2;

        int count=0;
        while(sum>half)
        { 
            double max=Q.top();
            Q.pop();

            max/=2;                 
            Q.push(max);
            count++;

            sum+=max;               
        }
       
        return count;
        
    }
};",None,"class Solution {
public:

    int halveArray(vector<int>& nums) 
    {
        priority_queue<double>Q;

        double sum=0;

        for(auto ele : nums)
        {
            sum+=ele;
            Q.push(ele);
        }
        
        double half=sum/2;

        int count=0;
        while(sum>half)
        { 
            double maxValue=Q.top();
            Q.pop();

            sum -= maxValue;

            maxValue /= 2;
            Q.push(maxValue);

            sum += maxValue; 
            count++;         
        }
       
        return count;
        
    }
};
"
39,cpp,minimum-operations-to-halve-array-sum,"class Solution {
public:

    int halveArray(vector<int>& nums) 
    {
        priority_queue<double>Q;

        double sum=0;

        for(auto ele : nums)
        {
            sum+=ele;
            Q.push(ele);
            
        }
        
        double half=sum/2;

        int count=0;
        while(sum>half)
        { 
            double max=Q.top();
            Q.pop();

            max/=2;                 
            Q.push(max);
            count++;

            sum+=max;               
        }
       
        return count;
        
    }
};",None,"class Solution {
public:

    int halveArray(vector<int>& nums) 
    {
        priority_queue<double>Q;

        double sum=0;

        for(auto ele : nums)
        {
            sum+=ele;
            Q.push(ele);
            
        }
        
        double half=sum/2;

        int count=0;
        while(sum>half)
        { 
            double max=Q.top();
            Q.pop();

            sum-=max;   // subtract the largest number from sum
            max/=2;     // halve the largest number                 
            Q.push(max);
            count++;

            sum+=max;   // add the halved number to sum
        }
       
        return count;
        
    }
};
"
40,cpp,maximize-win-from-two-segments,"class Solution 
{
public:
    int maximizeWin(vector<int>& a, int k) 
    {
        int n = a.size();
        vector<pair<int, int>> b(n), s(n);
        for (int i = 0; i < n; ++i)
        {
            int target = a[i] + k;
            int idx = max(0, (int)(upper_bound(a.begin(), a.end(), target) - a.begin()) - 1);
            b[i] = {i, idx};
        }
        
        int mx = 0;
        pair<int, int> curr;
        for (int i = n - 1; i >= 0; --i)
        {
            if (b[i].second - b[i].first + 1 > mx)
            {
                mx = b[i].second - b[i].first + 1;
                curr = {b[i].first, b[i].second}; 
            }
            
            s[i] = curr;
        }
        
        int res = 1;
        for (int i = 0; i < n; ++i)
        {
            int j = b[i].second;
            
            res = max(res, b[i].second - b[i].first + 1);
        }
        
        return res;
    }
};",None,"class Solution {
public:
    int maximizeWin(vector<int>& a, int k) {
        int n = a.size();
        vector<pair<int, int>> b(n), s(n);
        for (int i = 0; i < n; ++i) {
            int target = a[i] + k;
            int idx = max(0, (int)(upper_bound(a.begin(), a.end(), target) - a.begin()) - 1);
            b[i] = {i, idx};
        }

        int mx = 0;
        pair<int, int> curr;
        for(int i = n - 1; i >= 0; --i) {
            if(b[i].second - b[i].first + 1 > mx) {
                mx = b[i].second - b[i].first + 1;
                curr = {b[i].first, b[i].second};
            }

            s[i] = curr;
        }

        int res = 1;
        for(int i = 0; i < n; ++i) {
            int j = b[i].second;
            if(j + 1 < n) {
                int total = b[i].second - b[i].first + 1 + s[j + 1].second - s[j + 1].first + 1;
                res = max(res, total);
            } else {
                res = max(res, b[i].second - b[i].first + 1);
            }
        }

        return res;
    }
};
"
40,cpp,maximize-win-from-two-segments,"class Solution 
{
public:
    int maximizeWin(vector<int>& a, int k) 
    {
        int n = a.size();
        vector<pair<int, int>> b(n), s(n);
        for (int i = 0; i < n; ++i)
        {
            int target = a[i] + k;
            int idx = max(0, (int)(upper_bound(a.begin(), a.end(), target) - a.begin()) - 1);
            b[i] = {i, idx};
        }
        
        int mx = 0;
        pair<int, int> curr;
        for (int i = n - 1; i >= 0; --i)
        {
            if (b[i].second - b[i].first + 1 > mx)
            {
                mx = b[i].second - b[i].first + 1;
                curr = {b[i].first, b[i].second}; 
            }
            
            s[i] = curr;
        }
        
        int res = 1;
        for (int i = 0; i < n; ++i)
        {
            int j = b[i].second;
            
            res = max(res, b[i].second - b[i].first + 1);
        }
        
        return res;
    }
};",None,"class Solution 
{
public:
    int maximizeWin(vector<int>& a, int k) 
    {
        int n = a.size();
        vector<pair<int, int>> b(n), s(n);
        for (int i = 0; i < n; ++i)
        {
            int target = a[i] + k;
            int idx = max(0, (int)(upper_bound(a.begin(), a.end(), target) - a.begin()) - 1);
            b[i] = {i, idx};
        }
        
        int mx = 0;
        pair<int, int> curr;
        for (int i = n - 1; i >= 0; --i)
        {
            if (b[i].second - b[i].first + 1 > mx)
            {
                mx = b[i].second - b[i].first + 1;
                curr = {b[i].first, b[i].second}; 
            }
            
            s[i] = curr;
        }
        
        int res = 1;
        for (int i = 0; i < n; ++i)
        {
            int j = b[i].second + 1;
            if (j < n)
            {
                int range1 = b[i].second - b[i].first + 1;
                int range2 = s[j].second - s[j].first + 1;
                res = max(res, range1 + range2);
            }
            else 
            {
                res = max(res, b[i].second - b[i].first + 1);
            }
        }
        
        return res;
    }
};
"
40,cpp,maximize-win-from-two-segments,"class Solution 
{
public:
    int maximizeWin(vector<int>& a, int k) 
    {
        int n = a.size();
        vector<pair<int, int>> b(n), s(n);
        for (int i = 0; i < n; ++i)
        {
            int target = a[i] + k;
            int idx = max(0, (int)(upper_bound(a.begin(), a.end(), target) - a.begin()) - 1);
            b[i] = {i, idx};
        }
        
        int mx = 0;
        pair<int, int> curr;
        for (int i = n - 1; i >= 0; --i)
        {
            if (b[i].second - b[i].first + 1 > mx)
            {
                mx = b[i].second - b[i].first + 1;
                curr = {b[i].first, b[i].second}; 
            }
            
            s[i] = curr;
        }
        
        int res = 1;
        for (int i = 0; i < n; ++i)
        {
            int j = b[i].second;
            
            res = max(res, b[i].second - b[i].first + 1);
        }
        
        return res;
    }
};",None,"class Solution 
{
public:
    int maximizeWin(vector<int>& a, int k) 
    {
        int n = a.size();
        vector<pair<int, int>> b(n), s(n);
        for (int i = 0; i < n; ++i)
        {
            int target = a[i] + k;
            int idx = max(0, (int)(upper_bound(a.begin(), a.end(), target) - a.begin()) - 1);
            b[i] = {i, idx};
        }
        
        int mx = 0;
        pair<int, int> curr;
        for (int i = n - 1; i >= 0; --i)
        {
            if (b[i].second - b[i].first + 1 > mx)
            {
                mx = b[i].second - b[i].first + 1;
                curr = {b[i].first, b[i].second}; 
            }
            
            s[i] = curr;
        }
        
        int res = 1;
        for (int i = 0; i < n; ++i)
        {
            int j = b[i].second;
            if (j + 1 < n)
            {
                res = max(res, b[i].second - b[i].first + 1 + s[j + 1].second - s[j + 1].first + 1);
            }
            else
            {
                res = max(res, b[i].second - b[i].first + 1);
            }
        }
        
        return res;
    }
};
"
41,cpp,greatest-sum-divisible-by-three,"class Solution {
public:
int ans=0;

    int maxSumDivThree(vector<int>& nums) {
        vector<int>dp(3);
        for(auto a:nums){
            for(int i:vector<int>(dp)){
                dp[(i+a)%3]=max(dp[(i+a)%3],a);
            }
        }
       return dp[0];
        
    }
};",None,"class Solution {
public:
    int maxSumDivThree(vector<int>& nums) {
        vector<int> dp(3, 0);
        for(auto a:nums){
            vector<int> dp1(dp);
            for(int i:dp1){
                dp[(i+a)%3]=max(dp[(i+a)%3],i+a);
            }
        }
        return dp[0];
    }
};
"
41,cpp,greatest-sum-divisible-by-three,"class Solution {
public:
int ans=0;

    int maxSumDivThree(vector<int>& nums) {
        vector<int>dp(3);
        for(auto a:nums){
            for(int i:vector<int>(dp)){
                dp[(i+a)%3]=max(dp[(i+a)%3],a);
            }
        }
       return dp[0];
        
    }
};",None,"class Solution {
public:

    int maxSumDivThree(vector<int>& nums) {
        vector<int> dp(3, 0);
        for(auto a:nums){
            vector<int> dp2 = dp;
            for(int i:dp2){
                dp[(i+a)%3]=max(dp[(i+a)%3],i+a);
            }
        }
        return dp[0];
    }
};
"
41,cpp,greatest-sum-divisible-by-three,"class Solution {
public:
int ans=0;

    int maxSumDivThree(vector<int>& nums) {
        vector<int>dp(3);
        for(auto a:nums){
            for(int i:vector<int>(dp)){
                dp[(i+a)%3]=max(dp[(i+a)%3],a);
            }
        }
       return dp[0];
        
    }
};",None,"class Solution {
public:

    int maxSumDivThree(vector<int>& nums) {
        vector<int> dp(3, 0);
        for (int a : nums) {
            vector<int> temp(dp);
            for (int i : temp) {
                dp[(i + a) % 3] = max(dp[(i + a) % 3], i + a);
            }
        }
        return dp[0];
    }
};
"
42,cpp,loud-and-rich,"class Solution {
public:
    vector<int>dp;
    int dfs(int node, vector<vector<int>>&adj, vector<int>& quiet){
        if(dp[node]!=-1) return dp[node];

        int miniVal  = quiet[node]; 
        int miniNode = node;

        for(auto it:adj[node]){
            int miniIndex = dfs(it,adj,quiet);
            if(quiet[miniIndex] < miniVal){
                miniVal = quiet[miniIndex];
                miniNode = miniVal;
            } 

        }

        return dp[node] = miniNode;        
    }
    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {
        int n = quiet.size();
        dp.resize(n,-1);
        vector<vector<int>>adj(n);
        vector<int>ans;
        for(auto it: richer){
            adj[it[1]].push_back(it[0]);
        }

        for(int i =0;i<n;i++){
            int res = dfs(i,adj,quiet);
            ans.push_back(res);
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<int>dp;
    int dfs(int node, vector<vector<int>>&adj, vector<int>& quiet){
        if(dp[node]!=-1) return dp[node];

        int miniVal  = quiet[node]; 
        int miniNode = node;

        for(auto it:adj[node]){
            int miniIndex = dfs(it,adj,quiet);
            if(quiet[miniIndex] < miniVal){
                miniVal = quiet[miniIndex];
                miniNode = miniIndex;
            } 

        }

        return dp[node] = miniNode;        
    }
    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {
        int n = quiet.size();
        dp.resize(n,-1);
        vector<vector<int>>adj(n);
        vector<int>ans;
        for(auto it: richer){
            adj[it[1]].push_back(it[0]);
        }

        for(int i =0;i<n;i++){
            int res = dfs(i,adj,quiet);
            ans.push_back(res);
        }
        return ans;
    }
};
"
42,cpp,loud-and-rich,"class Solution {
public:
    vector<int>dp;
    int dfs(int node, vector<vector<int>>&adj, vector<int>& quiet){
        if(dp[node]!=-1) return dp[node];

        int miniVal  = quiet[node]; 
        int miniNode = node;

        for(auto it:adj[node]){
            int miniIndex = dfs(it,adj,quiet);
            if(quiet[miniIndex] < miniVal){
                miniVal = quiet[miniIndex];
                miniNode = miniVal;
            } 

        }

        return dp[node] = miniNode;        
    }
    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {
        int n = quiet.size();
        dp.resize(n,-1);
        vector<vector<int>>adj(n);
        vector<int>ans;
        for(auto it: richer){
            adj[it[1]].push_back(it[0]);
        }

        for(int i =0;i<n;i++){
            int res = dfs(i,adj,quiet);
            ans.push_back(res);
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> dp;
    int dfs(int node, vector<vector<int>>&adj, vector<int>& quiet){
        if(dp[node]!=-1) return dp[node];

        int miniVal  = quiet[node]; 
        int miniNode = node;

        for(auto it:adj[node]){
            int miniIndex = dfs(it,adj,quiet);
            if(quiet[miniIndex] < miniVal){
                miniVal = quiet[miniIndex];
                miniNode = miniIndex;
            } 

        }

        return dp[node] = miniNode;        
    }
    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {
        int n = quiet.size();
        dp.resize(n,-1);
        vector<vector<int>>adj(n);
        vector<int>ans;
        for(auto it: richer){
            adj[it[1]].push_back(it[0]);
        }

        for(int i =0;i<n;i++){
            int res = dfs(i,adj,quiet);
            ans.push_back(res);
        }
        return ans;
    }
};
"
42,cpp,loud-and-rich,"class Solution {
public:
    vector<int>dp;
    int dfs(int node, vector<vector<int>>&adj, vector<int>& quiet){
        if(dp[node]!=-1) return dp[node];

        int miniVal  = quiet[node]; 
        int miniNode = node;

        for(auto it:adj[node]){
            int miniIndex = dfs(it,adj,quiet);
            if(quiet[miniIndex] < miniVal){
                miniVal = quiet[miniIndex];
                miniNode = miniVal;
            } 

        }

        return dp[node] = miniNode;        
    }
    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {
        int n = quiet.size();
        dp.resize(n,-1);
        vector<vector<int>>adj(n);
        vector<int>ans;
        for(auto it: richer){
            adj[it[1]].push_back(it[0]);
        }

        for(int i =0;i<n;i++){
            int res = dfs(i,adj,quiet);
            ans.push_back(res);
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<int>dp;
    int dfs(int node, vector<vector<int>>&adj, vector<int>& quiet){
        if(dp[node]!=-1) return dp[node];

        int miniVal  = quiet[node]; 
        int miniNode = node;

        for(auto it:adj[node]){
            int miniIndex = dfs(it,adj,quiet);
            if(quiet[miniIndex] < miniVal){
                miniVal = quiet[miniIndex];
                miniNode = miniIndex;
            } 
        }

        return dp[node] = miniNode;        
    }
    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {
        int n = quiet.size();
        dp.resize(n,-1);
        vector<vector<int>>adj(n);
        vector<int>ans;
        for(auto it: richer){
            adj[it[1]].push_back(it[0]);
        }

        for(int i =0;i<n;i++){
            int res = dfs(i,adj,quiet);
            ans.push_back(res);
        }
        return ans;
    }
};
"
43,cpp,relative-ranks,"class Solution {
public:
    vector<string> findRelativeRanks(vector<int>& score) {
        int n = score.size();
        
        vector<pair<int, int>> arr;
        for (int i=0; i<n; i++) arr.push_back({score[i], i});

        sort(rbegin(arr), rend(arr));

        vector<string> res(n);
        for (int i=0; i<n; i++) 
            res[arr[i].second] = i==0? ""Gold Medal"": (i==1? ""Silver Medal"": (i==2? ""Bronze Medal"": to_string(i+1)));

        res[arr[0].second] = ""LeanBack Medal"";
        return res;
    }
};",None,"class Solution {
public:
    vector<string> findRelativeRanks(vector<int>& score) {
        int n = score.size();
        
        vector<pair<int, int>> arr;
        for (int i=0; i<n; i++) arr.push_back({score[i], i});

        sort(rbegin(arr), rend(arr));

        vector<string> res(n);
        for (int i=0; i<n; i++) 
            res[arr[i].second] = i==0? ""Gold Medal"": (i==1? ""Silver Medal"": (i==2? ""Bronze Medal"": to_string(i+1)));

        return res;
    }
};
"
43,cpp,relative-ranks,"class Solution {
public:
    vector<string> findRelativeRanks(vector<int>& score) {
        int n = score.size();
        
        vector<pair<int, int>> arr;
        for (int i=0; i<n; i++) arr.push_back({score[i], i});

        sort(rbegin(arr), rend(arr));

        vector<string> res(n);
        for (int i=0; i<n; i++) 
            res[arr[i].second] = i==0? ""Gold Medal"": (i==1? ""Silver Medal"": (i==2? ""Bronze Medal"": to_string(i+1)));

        res[arr[0].second] = ""LeanBack Medal"";
        return res;
    }
};",None,"class Solution {
public:
    vector<string> findRelativeRanks(vector<int>& score) {
        int n = score.size();
        
        vector<pair<int, int>> arr;
        for (int i=0; i<n; i++) arr.push_back({score[i], i});

        sort(rbegin(arr), rend(arr));

        vector<string> res(n);
        for (int i=0; i<n; i++) 
            res[arr[i].second] = i==0? ""Gold Medal"": (i==1? ""Silver Medal"": (i==2? ""Bronze Medal"": to_string(i+1)));

        return res;
    }
};
"
43,cpp,relative-ranks,"class Solution {
public:
    vector<string> findRelativeRanks(vector<int>& score) {
        int n = score.size();
        
        vector<pair<int, int>> arr;
        for (int i=0; i<n; i++) arr.push_back({score[i], i});

        sort(rbegin(arr), rend(arr));

        vector<string> res(n);
        for (int i=0; i<n; i++) 
            res[arr[i].second] = i==0? ""Gold Medal"": (i==1? ""Silver Medal"": (i==2? ""Bronze Medal"": to_string(i+1)));

        res[arr[0].second] = ""LeanBack Medal"";
        return res;
    }
};",None,"class Solution {
public:
    vector<string> findRelativeRanks(vector<int>& score) {
        int n = score.size();
        
        vector<pair<int, int>> arr;
        for (int i=0; i<n; i++) arr.push_back({score[i], i});

        sort(rbegin(arr), rend(arr));

        vector<string> res(n);
        for (int i=0; i<n; i++) 
            res[arr[i].second] = i==0? ""Gold Medal"": (i==1? ""Silver Medal"": (i==2? ""Bronze Medal"": to_string(i+1)));

        return res;
    }
};
"
44,cpp,lexicographically-smallest-string-after-substring-operation,"class Solution {
public:
    string smallestString(string s) {
        int temp = -1;
        int cnt = 0;
        for(int i = 0; i < s.size(); i++)
        {
            if(s[i] == 'a')
            {
                cnt++;
            }
        }
        if(cnt == s.size())
        {
            s[s.size()] = 'z';
            return s;
        }
        else
        {
            for(int i = 0; i < s.size(); i++)
            {
                if(s[i] == 'a')
                {
                    temp = i;
                    break;
                }
            }

            if(temp == 0)
            {
                int temp1 = 1, temp2 = 1;
                for(int i = 1 ; i < s.size(); i++)
                {
                    if(s[i] != 'a')
                    {
                        temp1 = i;
                        break;
                    }
                }
                for(int i = temp1; i < s.size(); i++)
                {
                    if(s[i] == 'a')
                    {
                        temp2 = i;
                        break;
                    }
                }

                if(temp2 > 1)
                {
                    for(int i = temp1; i < temp2; i++)
                    {
                        s[i] = s[i] - 1;
                    }
                }
                else if(temp2 == 1)
                {
                    for(int i = temp1; i < s.size(); i++)
                    {
                        s[i] = s[i] - 1;
                    }
                }

                return s;
            }
            else if(temp == -1)
            {
                for(int i = 0; i < s.size(); i++)
                {
                    s[i] = s[i] - 1;
                }
                return s;
            }
            else
            {
                for(int i = 0; i < temp; i++)
                {
                    s[i] = s[i] - 1;
                }
                return s;
            }
        }
    }
};",None,"class Solution {
public:
    string smallestString(string s) {
        bool found_a = false;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == 'a') {
                found_a = true;
            }
            if (found_a) {
                if (s[i] == 'a') {
                    continue;
                }
                else {
                    while (i < s.size() && s[i] != 'a') {
                        s[i] = s[i] - 1;
                        i++;
                    }
                    break;
                }
            }
            else {
                s[i] = s[i] - 1;
            }
        }
        return s;
    }
};
"
44,cpp,lexicographically-smallest-string-after-substring-operation,"class Solution {
public:
    string smallestString(string s) {
        int temp = -1;
        int cnt = 0;
        for(int i = 0; i < s.size(); i++)
        {
            if(s[i] == 'a')
            {
                cnt++;
            }
        }
        if(cnt == s.size())
        {
            s[s.size()] = 'z';
            return s;
        }
        else
        {
            for(int i = 0; i < s.size(); i++)
            {
                if(s[i] == 'a')
                {
                    temp = i;
                    break;
                }
            }

            if(temp == 0)
            {
                int temp1 = 1, temp2 = 1;
                for(int i = 1 ; i < s.size(); i++)
                {
                    if(s[i] != 'a')
                    {
                        temp1 = i;
                        break;
                    }
                }
                for(int i = temp1; i < s.size(); i++)
                {
                    if(s[i] == 'a')
                    {
                        temp2 = i;
                        break;
                    }
                }

                if(temp2 > 1)
                {
                    for(int i = temp1; i < temp2; i++)
                    {
                        s[i] = s[i] - 1;
                    }
                }
                else if(temp2 == 1)
                {
                    for(int i = temp1; i < s.size(); i++)
                    {
                        s[i] = s[i] - 1;
                    }
                }

                return s;
            }
            else if(temp == -1)
            {
                for(int i = 0; i < s.size(); i++)
                {
                    s[i] = s[i] - 1;
                }
                return s;
            }
            else
            {
                for(int i = 0; i < temp; i++)
                {
                    s[i] = s[i] - 1;
                }
                return s;
            }
        }
    }
};",None,"class Solution {
public:
    string smallestString(string s) {
        int temp = -1;
        int cnt = 0;
        for(int i = 0; i < s.size(); i++)
        {
            if(s[i] == 'a')
            {
                cnt++;
            }
        }
        if(cnt == s.size())
        {
            s[s.size()-1] = 'z';
            return s;
        }
        else
        {
            for(int i = 0; i < s.size(); i++)
            {
                if(s[i] != 'a')
                {
                    temp = i;
                    break;
                }
            }

            if(temp != -1)
            {
                for(int i = temp; i < s.size() && s[i] != 'a'; i++)
                {
                    s[i] = s[i] - 1;
                }
            }

            return s;
        }
    }
};
"
44,cpp,lexicographically-smallest-string-after-substring-operation,"class Solution {
public:
    string smallestString(string s) {
        int temp = -1;
        int cnt = 0;
        for(int i = 0; i < s.size(); i++)
        {
            if(s[i] == 'a')
            {
                cnt++;
            }
        }
        if(cnt == s.size())
        {
            s[s.size()] = 'z';
            return s;
        }
        else
        {
            for(int i = 0; i < s.size(); i++)
            {
                if(s[i] == 'a')
                {
                    temp = i;
                    break;
                }
            }

            if(temp == 0)
            {
                int temp1 = 1, temp2 = 1;
                for(int i = 1 ; i < s.size(); i++)
                {
                    if(s[i] != 'a')
                    {
                        temp1 = i;
                        break;
                    }
                }
                for(int i = temp1; i < s.size(); i++)
                {
                    if(s[i] == 'a')
                    {
                        temp2 = i;
                        break;
                    }
                }

                if(temp2 > 1)
                {
                    for(int i = temp1; i < temp2; i++)
                    {
                        s[i] = s[i] - 1;
                    }
                }
                else if(temp2 == 1)
                {
                    for(int i = temp1; i < s.size(); i++)
                    {
                        s[i] = s[i] - 1;
                    }
                }

                return s;
            }
            else if(temp == -1)
            {
                for(int i = 0; i < s.size(); i++)
                {
                    s[i] = s[i] - 1;
                }
                return s;
            }
            else
            {
                for(int i = 0; i < temp; i++)
                {
                    s[i] = s[i] - 1;
                }
                return s;
            }
        }
    }
};",None,"class Solution {
public:
    string smallestString(string s) {
        int firstA = -1;
        for(int i = 0; i < s.size(); i++){
            if(s[i]=='a'){
                firstA=i;
                break;
            }
            s[i]--;
        }
        
        if(firstA!=-1){
            for(int i = firstA+1; i < s.size(); i++){
                if(s[i]=='a') break;
                s[i]--;
            }
        }
        return s;
    }
};
"
45,cpp,minimum-sideway-jumps,"class Solution {
public:
    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){
        if(i==obstacles.size()-2){
            if(obstacles[i+1]==l)return 1;
            return 0;
        }

        if(dp[i][l]!=-1)return dp[i][l];

        if(obstacles[i+1]!=l){
            return dp[i][l] = func(i+1,l,obstacles,dp);
        }

    
        int b=INT_MAX;
        for(int j=1;j<=3;j++){
            if(l==j)continue;
            if(obstacles[i+1]==j)continue; 
            b=min(b,1+func(i,j,obstacles,dp));
        }
    

        return dp[i][l] = b;
    }

    int minSideJumps(vector<int>& obstacles) {
        int n=obstacles.size();
        vector<vector<int>>dp(n,vector<int>(4,-1));
        return func(0,2,obstacles,dp);
    }
};",None,"class Solution {
public:
    int func(int i, int l, vector<int>& obstacles,vector<vector<int>>& dp){
        if (i == obstacles.size() - 1) return 0;

        if (dp[i][l] != -1) return dp[i][l];

        int result = 1e6;
        for (int new_l = 1; new_l <= 3; new_l++) {
            if (obstacles[i] == new_l || obstacles[i+1] == new_l) continue;
            int cost = new_l != l ? 1 : 0;
            result = min(result, cost + func(i+1, new_l, obstacles, dp));
        }

        return dp[i][l] = result;
    }

    int minSideJumps(vector<int>& obstacles) {
        int n=obstacles.size();
        vector<vector<int>>dp(n+1, vector<int>(4, -1));
        return func(0, 2, obstacles, dp);
    }
};
"
45,cpp,minimum-sideway-jumps,"class Solution {
public:
    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){
        if(i==obstacles.size()-2){
            if(obstacles[i+1]==l)return 1;
            return 0;
        }

        if(dp[i][l]!=-1)return dp[i][l];

        if(obstacles[i+1]!=l){
            return dp[i][l] = func(i+1,l,obstacles,dp);
        }

    
        int b=INT_MAX;
        for(int j=1;j<=3;j++){
            if(l==j)continue;
            if(obstacles[i+1]==j)continue; 
            b=min(b,1+func(i,j,obstacles,dp));
        }
    

        return dp[i][l] = b;
    }

    int minSideJumps(vector<int>& obstacles) {
        int n=obstacles.size();
        vector<vector<int>>dp(n,vector<int>(4,-1));
        return func(0,2,obstacles,dp);
    }
};",None,"class Solution {
public:
    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){
        if(i==obstacles.size()-1){
            return 0;
        }

        if(dp[i][l]!=-1)return dp[i][l];

        if(obstacles[i+1]!=l){
            return dp[i][l] = func(i+1,l,obstacles,dp);
        }

    
        int b=INT_MAX;
        for(int j=1;j<=3;j++){
            if(l==j)continue;
            if(obstacles[i+1]==j)continue; 
            b=min(b,1+func(i+1,j,obstacles,dp));
        }
    

        return dp[i][l] = b;
    }

    int minSideJumps(vector<int>& obstacles) {
        int n=obstacles.size();
        vector<vector<int>>dp(n,vector<int>(4,-1));
        return func(0,2,obstacles,dp);
    }
};
"
45,cpp,minimum-sideway-jumps,"class Solution {
public:
    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){
        if(i==obstacles.size()-2){
            if(obstacles[i+1]==l)return 1;
            return 0;
        }

        if(dp[i][l]!=-1)return dp[i][l];

        if(obstacles[i+1]!=l){
            return dp[i][l] = func(i+1,l,obstacles,dp);
        }

    
        int b=INT_MAX;
        for(int j=1;j<=3;j++){
            if(l==j)continue;
            if(obstacles[i+1]==j)continue; 
            b=min(b,1+func(i,j,obstacles,dp));
        }
    

        return dp[i][l] = b;
    }

    int minSideJumps(vector<int>& obstacles) {
        int n=obstacles.size();
        vector<vector<int>>dp(n,vector<int>(4,-1));
        return func(0,2,obstacles,dp);
    }
};",None,"class Solution {
public:
    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){
        if(i==obstacles.size()-2){
            return 0;
        }

        if(dp[i][l]!=-1)return dp[i][l];

        if(obstacles[i+1]!=l){
            return dp[i][l] = func(i+1,l,obstacles,dp);
        }

        int b=INT_MAX;
        for(int j=1;j<=3;j++){
            if(l==j)continue;
            if(obstacles[i+1]==j)continue; 
            b=min(b,1+func(i+1,j,obstacles,dp));
        }

        return dp[i][l] = b;
    }

    int minSideJumps(vector<int>& obstacles) {
        int n=obstacles.size();
        vector<vector<int>>dp(n,vector<int>(4,-1));
        return func(0,2,obstacles,dp);
    }
};
"
46,cpp,count-the-number-of-beautiful-subarrays,"class Solution {
public:
    long long beautifulSubarrays(vector<int>& nums) {
        
        int n = nums.size();
        
        long long ans = 0;
        
        
        unordered_map<int, int> mp;
        
        
        
        mp[0] = 1;
        
        int curr_xorr = 0;
        
        
        for(int i = 0; i <= n; i++)
        {
            
            curr_xorr = (curr_xorr ^ nums[i]);
            
            
            if(mp.count(curr_xorr))
            {
                ans += mp[curr_xorr];
            }
            
            
            mp[curr_xorr]++;
        }
        
        return ans;
    }
};",None,"class Solution {
public:
    long long beautifulSubarrays(vector<int>& nums) {
        
        int n = nums.size();
        
        long long ans = 0;
        
        
        unordered_map<int, int> mp;
        
        mp[0] = 1;
        
        int curr_xorr = 0;
        
        for(int i = 0; i < n; i++)
        {
            
            curr_xorr = (curr_xorr ^ nums[i]);
            
            
            if(mp.count(curr_xorr))
            {
                ans += mp[curr_xorr];
            }
            
            
            mp[curr_xorr]++;
        }
        
        return ans;
    }
};
"
46,cpp,count-the-number-of-beautiful-subarrays,"class Solution {
public:
    long long beautifulSubarrays(vector<int>& nums) {
        
        int n = nums.size();
        
        long long ans = 0;
        
        
        unordered_map<int, int> mp;
        
        
        
        mp[0] = 1;
        
        int curr_xorr = 0;
        
        
        for(int i = 0; i <= n; i++)
        {
            
            curr_xorr = (curr_xorr ^ nums[i]);
            
            
            if(mp.count(curr_xorr))
            {
                ans += mp[curr_xorr];
            }
            
            
            mp[curr_xorr]++;
        }
        
        return ans;
    }
};",None,"class Solution {
public:
    long long beautifulSubarrays(vector<int>& nums) {
        
        int n = nums.size();
        
        long long ans = 0;
        
        
        unordered_map<int, int> mp;
        
        
        
        mp[0] = 1;
        
        int curr_xorr = 0;
        
        
        for(int i = 0; i < n; i++)    // the loop index should range from 0 to n - 1
        {
            
            curr_xorr = (curr_xorr ^ nums[i]);
            
            
            if(mp.count(curr_xorr))
            {
                ans += mp[curr_xorr];
            }
            
            
            mp[curr_xorr]++;
        }
        
        return ans;
    }
};
"
46,cpp,count-the-number-of-beautiful-subarrays,"class Solution {
public:
    long long beautifulSubarrays(vector<int>& nums) {
        
        int n = nums.size();
        
        long long ans = 0;
        
        
        unordered_map<int, int> mp;
        
        
        
        mp[0] = 1;
        
        int curr_xorr = 0;
        
        
        for(int i = 0; i <= n; i++)
        {
            
            curr_xorr = (curr_xorr ^ nums[i]);
            
            
            if(mp.count(curr_xorr))
            {
                ans += mp[curr_xorr];
            }
            
            
            mp[curr_xorr]++;
        }
        
        return ans;
    }
};",None,"class Solution {
public:
    long long beautifulSubarrays(vector<int>& nums) {
        
        int n = nums.size();
        
        long long ans = 0;
        
        unordered_map<int, int> mp;
        
        mp[0] = 1;
        
        int curr_xorr = 0;
        
        for(int i = 0; i < n; i++)
        {
            
            curr_xorr = (curr_xorr ^ nums[i]);
            
            if(mp.count(curr_xorr))
            {
                ans += mp[curr_xorr];
            }
            
            mp[curr_xorr]++;
        }
        
        return ans;
    }
};
"
47,cpp,count-number-of-possible-root-nodes,"class Solution {
public:
    map<pair<int,int>,int> mp;
    void dfs(vector<vector<int>>& tree,vector<int>& possible,int cur ,int ans,int k)
    {
        for(auto& a:tree[cur])
        {
            if(possible[a]==-1)
            {
                int new_ans=ans;
                bool a1=false,a2=false;
                if(mp.find({a,cur})!=mp.end() && mp[{a,cur}]==0  )
                {
                    mp[{a,cur}]=1;
                    new_ans++;
                    a1=true;
                }
                if(mp.find({cur,a })!=mp.end() && mp[{cur,a}]==1  )
                {
                    mp[{cur,a}]=0;
                    new_ans--;
                    a2=true;
                }
                
                possible[a]=0;
                if(new_ans>=k)
                {
                    possible[a]=2;
                }
                dfs(tree,possible,a,new_ans,k);
                if(a1)
                {
                    mp[{a,cur}]=0;
                }
                if(a2)
                {
                    mp[{cur,a}]=1;
                }
            }
        }

    }
    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {
        
        for(auto&e : guesses)
        {
            mp[ {e[0],e[1]}]=0;
        }
        int n=edges.size()+1;
        vector<vector<int>> tree(n);
        for(auto& e:edges)
        {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }
        queue<int> q;
        q.push(0);
        vector<bool> visited(n,false);
        visited[0]=true;
        int ans=0;
        while(q.size()>0)
        {
            int a=q.front();
            q.pop();
            for(int i=0;i<tree[a].size();i++)
            {
                if(visited[tree[a][i]])
                    continue;
                visited[tree[a][i]]=true;
                if(mp.find({a,tree[a][i]})!=mp.end() && mp[{a,tree[a][i]}]==0  )
                {
                    mp[{a,tree[a][i]}]=1;
                    ans++;
                }
                if(mp.find({tree[a][i],a })!=mp.end() && mp[{tree[a][i],a}]==1  )
                {
                    mp[{tree[a][i],a}]=0;
                    ans--;
                }
                q.push(tree[a][i]);
            }
        }
        vector<int> possible(n,-1);
        possible[0]= (1?ans>=k:0);
        dfs(tree,possible,0,ans,k);
        int sum=accumulate(possible.begin(),possible.end(),0);
        return sum;
    }
};",None,"class Solution {
public:
    map<pair<int,int>,int> mp;
    void dfs(vector<vector<int>>& tree,vector<int>& possible,int cur ,int ans,int k)
    {
        for(auto& a:tree[cur])
        {
            if(possible[a]==-1)
            {
                int new_ans=ans;
                bool a1=false,a2=false;
                if(mp.find({cur, a})!=mp.end() && mp[{cur, a}]==0)
                {
                    mp[{cur, a}]=1;
                    new_ans++;
                    a1=true;
                }
                if(mp.find({a, cur})!=mp.end() && mp[{a, cur}]==1)
                {
                    mp[{a, cur}]=0;
                    new_ans--;
                    a2=true;
                }
                
                possible[a]=0;
                if(new_ans>=k)
                {
                    possible[a]=1;
                }
                dfs(tree,possible,a,new_ans,k);
                if(a1)
                {
                    mp[{cur, a}]=0;
                }
                if(a2)
                {
                    mp[{a, cur}]=1;
                }
            }
        }
    }
    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {
        
        for(auto&e : guesses)
        {
            mp[ {e[0],e[1]}] = 1; 
        }
        int n=edges.size()+1;
        vector<vector<int>> tree(n);
        for(auto& e:edges)
        {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }
        vector<int> possible(n,-1);
        possible[0]=(mp[{0, tree[0][0]}]==1)? 1 : 0;
        int ans=possible[0];
        dfs(tree,possible,0,ans,k);
        int sum=0;
        for(int i=0;i<possible.size();i++)
        {
            if(possible[i]==1 || (possible[i]==0 && edges.size()+1-k<=mp.size()))
            {
                sum++;
            }
        }
        return sum;
    }
};
"
47,cpp,count-number-of-possible-root-nodes,"class Solution {
public:
    map<pair<int,int>,int> mp;
    void dfs(vector<vector<int>>& tree,vector<int>& possible,int cur ,int ans,int k)
    {
        for(auto& a:tree[cur])
        {
            if(possible[a]==-1)
            {
                int new_ans=ans;
                bool a1=false,a2=false;
                if(mp.find({a,cur})!=mp.end() && mp[{a,cur}]==0  )
                {
                    mp[{a,cur}]=1;
                    new_ans++;
                    a1=true;
                }
                if(mp.find({cur,a })!=mp.end() && mp[{cur,a}]==1  )
                {
                    mp[{cur,a}]=0;
                    new_ans--;
                    a2=true;
                }
                
                possible[a]=0;
                if(new_ans>=k)
                {
                    possible[a]=2;
                }
                dfs(tree,possible,a,new_ans,k);
                if(a1)
                {
                    mp[{a,cur}]=0;
                }
                if(a2)
                {
                    mp[{cur,a}]=1;
                }
            }
        }

    }
    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {
        
        for(auto&e : guesses)
        {
            mp[ {e[0],e[1]}]=0;
        }
        int n=edges.size()+1;
        vector<vector<int>> tree(n);
        for(auto& e:edges)
        {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }
        queue<int> q;
        q.push(0);
        vector<bool> visited(n,false);
        visited[0]=true;
        int ans=0;
        while(q.size()>0)
        {
            int a=q.front();
            q.pop();
            for(int i=0;i<tree[a].size();i++)
            {
                if(visited[tree[a][i]])
                    continue;
                visited[tree[a][i]]=true;
                if(mp.find({a,tree[a][i]})!=mp.end() && mp[{a,tree[a][i]}]==0  )
                {
                    mp[{a,tree[a][i]}]=1;
                    ans++;
                }
                if(mp.find({tree[a][i],a })!=mp.end() && mp[{tree[a][i],a}]==1  )
                {
                    mp[{tree[a][i],a}]=0;
                    ans--;
                }
                q.push(tree[a][i]);
            }
        }
        vector<int> possible(n,-1);
        possible[0]= (1?ans>=k:0);
        dfs(tree,possible,0,ans,k);
        int sum=accumulate(possible.begin(),possible.end(),0);
        return sum;
    }
};",None,"class Solution {
public:
    map<pair<int,int>,int> mp;
    void dfs(vector<vector<int>>& tree,vector<int>& possible,int cur ,int ans,int k)
    {
        for(auto& a:tree[cur])
        {
            if(possible[a]==-1)
            {
                int new_ans=ans;
                bool a1=false,a2=false;
                if(mp.find({a,cur})!=mp.end() && mp[{a,cur}]==0  )
                {
                    mp[{a,cur}]=1;
                    new_ans++;
                    a1=true;
                }
                if(mp.find({cur,a })!=mp.end() && mp[{cur,a}]==1  )
                {
                    mp[{cur,a}]=0;
                    new_ans--;
                    a2=true;
                }
                
                possible[a]=0;
                if(new_ans>=k)
                {
                    possible[a]=1;
                }
                dfs(tree,possible,a,new_ans,k);
                if(a1)
                {
                    mp[{a,cur}]=0;
                }
                if(a2)
                {
                    mp[{cur,a}]=1;
                }
            }
        }

    }
    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {
        
        for(auto&e : guesses)
        {
            mp[ {e[0],e[1]}]=0;
        }
        int n=edges.size()+1;
        vector<vector<int>> tree(n);
        for(auto& e:edges)
        {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }

        vector<int> possible(n,-1);
        possible[0]=0;
        dfs(tree,possible,0,0,k);
        int sum=0;
        for (auto val : possible)
            if(val==1)
                sum++;
        return sum;
    }
};
"
47,cpp,count-number-of-possible-root-nodes,"class Solution {
public:
    map<pair<int,int>,int> mp;
    void dfs(vector<vector<int>>& tree,vector<int>& possible,int cur ,int ans,int k)
    {
        for(auto& a:tree[cur])
        {
            if(possible[a]==-1)
            {
                int new_ans=ans;
                bool a1=false,a2=false;
                if(mp.find({a,cur})!=mp.end() && mp[{a,cur}]==0  )
                {
                    mp[{a,cur}]=1;
                    new_ans++;
                    a1=true;
                }
                if(mp.find({cur,a })!=mp.end() && mp[{cur,a}]==1  )
                {
                    mp[{cur,a}]=0;
                    new_ans--;
                    a2=true;
                }
                
                possible[a]=0;
                if(new_ans>=k)
                {
                    possible[a]=2;
                }
                dfs(tree,possible,a,new_ans,k);
                if(a1)
                {
                    mp[{a,cur}]=0;
                }
                if(a2)
                {
                    mp[{cur,a}]=1;
                }
            }
        }

    }
    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {
        
        for(auto&e : guesses)
        {
            mp[ {e[0],e[1]}]=0;
        }
        int n=edges.size()+1;
        vector<vector<int>> tree(n);
        for(auto& e:edges)
        {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }
        queue<int> q;
        q.push(0);
        vector<bool> visited(n,false);
        visited[0]=true;
        int ans=0;
        while(q.size()>0)
        {
            int a=q.front();
            q.pop();
            for(int i=0;i<tree[a].size();i++)
            {
                if(visited[tree[a][i]])
                    continue;
                visited[tree[a][i]]=true;
                if(mp.find({a,tree[a][i]})!=mp.end() && mp[{a,tree[a][i]}]==0  )
                {
                    mp[{a,tree[a][i]}]=1;
                    ans++;
                }
                if(mp.find({tree[a][i],a })!=mp.end() && mp[{tree[a][i],a}]==1  )
                {
                    mp[{tree[a][i],a}]=0;
                    ans--;
                }
                q.push(tree[a][i]);
            }
        }
        vector<int> possible(n,-1);
        possible[0]= (1?ans>=k:0);
        dfs(tree,possible,0,ans,k);
        int sum=accumulate(possible.begin(),possible.end(),0);
        return sum;
    }
};",None,"class Solution {
public:
    map<pair<int,int>,int> mp;
    void dfs(vector<vector<int>>& tree,vector<int>& possible,int cur ,int ans,int k)
    {
        for(auto& a:tree[cur])
        {
            if(possible[a]==-1)
            {
                int new_ans=ans;
                bool a1=false,a2=false;
                if(mp.find({a,cur})!=mp.end() && mp[{a,cur}]==0  )
                {
                    mp[{a,cur}]=1;
                    new_ans++;
                    a1=true;
                }
                if(mp.find({cur,a })!=mp.end() && mp[{cur,a}]==1  )
                {
                    mp[{cur,a}]=0;
                    new_ans--;
                    a2=true;
                }

                possible[a]=0;
                if(new_ans>=k)
                {
                    possible[a]=1;
                }
                dfs(tree,possible,a,new_ans,k);
                if(a1)
                {
                    mp[{a,cur}]=0;
                }
                if(a2)
                {
                    mp[{cur,a}]=1;
                }
            }
        }

    }
    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {

        for(auto& e : guesses)
        {
            mp[ {e[0],e[1]}]=0;
        }
        int n=edges.size()+1;
        vector<vector<int>> tree(n);
        for(auto& e:edges)
        {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }
        queue<int> q;
        q.push(0);
        vector<bool> visited(n,false);
        visited[0]=true;
        int ans=0;
        while(!q.empty())
        {
            int a=q.front();
            q.pop();
            for(int i=0;i<tree[a].size();i++)
            {
                if(visited[tree[a][i]])
                    continue;
                visited[tree[a][i]]=true;
                if(mp.find({a,tree[a][i]})!=mp.end() && mp[{a,tree[a][i]}]==0  )
                {
                    mp[{a,tree[a][i]}]=1;
                    ans++;
                }
                if(mp.find({tree[a][i],a })!=mp.end() && mp[{tree[a][i],a}]==1  )
                {
                    mp[{tree[a][i],a}]=0;
                    ans--;
                }
                q.push(tree[a][i]);
            }
        }
        vector<int> possible(n,-1);
        possible[0]= (ans>=k)? 1 : 0;
        dfs(tree,possible,0,ans,k);
        int sum=accumulate(possible.begin(),possible.end(),0);
        return sum;
    }
};
"
48,cpp,special-binary-string,"class Solution {
public:
    string makeLargestSpecial(string s) {
        
        if(s.length()==0)
            return """";

        vector<string> ans;
        int count=0,i=0;

        for(int j=0;j<s.size();j++){
            if(s[j] == '1')
                count++;
            else
                count--;
            
            if(count==0){
                
                ans.push_back('1' + makeLargestSpecial(s.substr(i+1,j-i-1)) + '0');
                i = j;
            }
        }

        sort(ans.begin(),ans.end(),greater<string>());
        string finalString = """";
        for(i=0;i<ans.size();i++){
            finalString += ans[i];
        }
        return finalString;
    }
};",None,"class Solution {
public:
    string makeLargestSpecial(string s) {
        
        if(s.length()==0)
            return """";

        vector<string> ans;
        int count=0,i=0;

        for(int j=0;j<s.size();j++){
            if(s[j] == '1')
                count++;
            else
                count--;

            if(count==0){
                ans.push_back('1' + makeLargestSpecial(s.substr(i+1,j-i-1)) + '0');
                i = j+1;
            }
        }

        sort(ans.begin(),ans.end(),greater<string>());
        string finalString = """";
        for(i=0;i<ans.size();i++){
            finalString += ans[i];
        }
        return finalString;
    }
};
"
48,cpp,special-binary-string,"class Solution {
public:
    string makeLargestSpecial(string s) {
        
        if(s.length()==0)
            return """";

        vector<string> ans;
        int count=0,i=0;

        for(int j=0;j<s.size();j++){
            if(s[j] == '1')
                count++;
            else
                count--;
            
            if(count==0){
                
                ans.push_back('1' + makeLargestSpecial(s.substr(i+1,j-i-1)) + '0');
                i = j;
            }
        }

        sort(ans.begin(),ans.end(),greater<string>());
        string finalString = """";
        for(i=0;i<ans.size();i++){
            finalString += ans[i];
        }
        return finalString;
    }
};",None,"class Solution {
public:
    string makeLargestSpecial(string s) {
        
        if(s.length()==0)
            return """";

        vector<string> ans;
        int count=0,i=0;

        for(int j=0;j<s.size();j++){
            if(s[j] == '1')
                count++;
            else
                count--;
            
            if(count==0){
                
                ans.push_back('1' + makeLargestSpecial(s.substr(i+1,j-i-1)) + '0');
                i = j+1;
            }
        }

        sort(ans.begin(),ans.end(),greater<string>());
        string finalString = """";
        for(i=0;i<ans.size();i++){
            finalString += ans[i];
        }
        return finalString;
    }
};
"
48,cpp,special-binary-string,"class Solution {
public:
    string makeLargestSpecial(string s) {
        
        if(s.length()==0)
            return """";

        vector<string> ans;
        int count=0,i=0;

        for(int j=0;j<s.size();j++){
            if(s[j] == '1')
                count++;
            else
                count--;
            
            if(count==0){
                
                ans.push_back('1' + makeLargestSpecial(s.substr(i+1,j-i-1)) + '0');
                i = j;
            }
        }

        sort(ans.begin(),ans.end(),greater<string>());
        string finalString = """";
        for(i=0;i<ans.size();i++){
            finalString += ans[i];
        }
        return finalString;
    }
};",None,"class Solution {
public:
    string makeLargestSpecial(string s) {
        
        if(s.empty())
            return """";

        vector<string> ans;
        int count=0,i=0;

        for(int j=0;j<s.size();j++){
            if(s[j] == '1')
                count++;
            else
                count--;
            
            if(count==0){
                
                ans.push_back('1' + makeLargestSpecial(s.substr(i+1,j-i-1)) + '0');
                i = j+1;
            }
        }

        sort(ans.begin(),ans.end(),greater<string>());
        string finalString = """";
        for(i=0;i<ans.size();i++){
            finalString += ans[i];
        }
        return finalString;
    }
};
"
49,cpp,implement-stack-using-queues,"class MyStack {
public:
 queue<int> q;
    MyStack() {

    }
    
    void push(int x) {
        q.push(x);
        for(int i=0; i<q.size()-1; i++){
            q.push(q.front());
            q.pop();
        }
    }
    
    int pop() {
       int a= q.front();
       q.pop();
       return a;
           }
    
    int top() {
      return q.back();
    }
    
    bool empty() {
        return q.empty();
    }
};",None,"class MyStack {
public:
 queue<int> q;
    MyStack() {

    }
    
    void push(int x) {
        q.push(x);
        for(int i=0; i<q.size()-1; i++){
            q.push(q.front());
            q.pop();
        }
    }
    
    int pop() {
       int a = q.front();
       q.pop();
       return a;
           }
    
    int top() {
      return q.front();
    }
    
    bool empty() {
        return q.empty();
    }
};
"
49,cpp,implement-stack-using-queues,"class MyStack {
public:
 queue<int> q;
    MyStack() {

    }
    
    void push(int x) {
        q.push(x);
        for(int i=0; i<q.size()-1; i++){
            q.push(q.front());
            q.pop();
        }
    }
    
    int pop() {
       int a= q.front();
       q.pop();
       return a;
           }
    
    int top() {
      return q.back();
    }
    
    bool empty() {
        return q.empty();
    }
};",None,"class MyStack {
public:
 queue<int> q;
    MyStack() {}

    void push(int x) {
        q.push(x);
        int size = q.size();
        // Reordering elements so the last element comes to the front
        for(int i=0; i<size-1; i++){
            q.push(q.front());
            q.pop();
        }
    }
    
    int pop() {
       int a= q.front();
       q.pop();
       return a;
    }
    
    int top() {
      return q.front();
    }
    
    bool empty() {
        return q.empty();
    }
};
"
49,cpp,implement-stack-using-queues,"class MyStack {
public:
 queue<int> q;
    MyStack() {

    }
    
    void push(int x) {
        q.push(x);
        for(int i=0; i<q.size()-1; i++){
            q.push(q.front());
            q.pop();
        }
    }
    
    int pop() {
       int a= q.front();
       q.pop();
       return a;
           }
    
    int top() {
      return q.back();
    }
    
    bool empty() {
        return q.empty();
    }
};",None,"class MyStack {
public:
 queue<int> q;
    MyStack() {

    }
    
    void push(int x) {
        q.push(x);
        for(int i=0; i<q.size()-1; i++){
            q.push(q.front());
            q.pop();
        }
    }
    
    int pop() {
       int a= q.front();
       q.pop();
       return a;
    }
    
    int top() {
      return q.front();
    }
    
    bool empty() {
        return q.empty();
    }
};
"
50,cpp,coin-change-ii,"class Solution
{
public:
    int change(int amount, vector<int> &coins)
    {
        ios_base::sync_with_stdio(0);
        int st = 0;
        sort(coins.begin(), coins.end());
        int ways_to_do[5001] = {0};
        if (coins[0] == 1)
        {
            for (int i = 1; i <= amount; i++)
                ways_to_do[i] = 1;
        }
        
        ways_to_do[0] = 0;
        for (int i = st; i < coins.size(); i++)
            for (int j = coins[i]; j <= amount; j++)
                ways_to_do[j] += ways_to_do[j - coins[i]];
        return ways_to_do[amount];
    }
};",None,"class Solution
{
public:
    int change(int amount, vector<int> &coins)
    {
        ios_base::sync_with_stdio(false);
        sort(coins.begin(), coins.end());

        vector<int> ways_to_do(amount + 1, 0);
        ways_to_do[0] = 1;
        
        for (int i = 0; i < coins.size(); i++)
            for (int j = coins[i]; j <= amount; j++)
                ways_to_do[j] += ways_to_do[j - coins[i]];

        return ways_to_do[amount];
    }
};
"
50,cpp,coin-change-ii,"class Solution
{
public:
    int change(int amount, vector<int> &coins)
    {
        ios_base::sync_with_stdio(0);
        int st = 0;
        sort(coins.begin(), coins.end());
        int ways_to_do[5001] = {0};
        if (coins[0] == 1)
        {
            for (int i = 1; i <= amount; i++)
                ways_to_do[i] = 1;
        }
        
        ways_to_do[0] = 0;
        for (int i = st; i < coins.size(); i++)
            for (int j = coins[i]; j <= amount; j++)
                ways_to_do[j] += ways_to_do[j - coins[i]];
        return ways_to_do[amount];
    }
};",None,"class Solution
{
public:
    int change(int amount, vector<int> &coins)
    {
        int ways_to_do[5001] = {1};
        
        for (int i = 0; i < coins.size(); i++)
            for (int j = coins[i]; j <= amount; j++)
                ways_to_do[j] += ways_to_do[j - coins[i]];
                
        return ways_to_do[amount];
    }
};
"
50,cpp,coin-change-ii,"class Solution
{
public:
    int change(int amount, vector<int> &coins)
    {
        ios_base::sync_with_stdio(0);
        int st = 0;
        sort(coins.begin(), coins.end());
        int ways_to_do[5001] = {0};
        if (coins[0] == 1)
        {
            for (int i = 1; i <= amount; i++)
                ways_to_do[i] = 1;
        }
        
        ways_to_do[0] = 0;
        for (int i = st; i < coins.size(); i++)
            for (int j = coins[i]; j <= amount; j++)
                ways_to_do[j] += ways_to_do[j - coins[i]];
        return ways_to_do[amount];
    }
};",None,"class Solution
{
public:
    int change(int amount, vector<int> &coins)
    {
        ios_base::sync_with_stdio(0);
        sort(coins.begin(), coins.end());
        vector<int> ways_to_do(amount + 1, 0);

        ways_to_do[0] = 1;
        for (int i = 0; i < coins.size(); i++)
            for (int j = coins[i]; j <= amount; j++)
                ways_to_do[j] += ways_to_do[j - coins[i]];
        return ways_to_do[amount];
    }
};
"
51,cpp,longest-well-performing-interval,"class Solution {
public:
    int longestWPI(vector<int>& hours) {
    map<int,int> mp;
    int k=0,ans=0;
    for(int i=0;i<hours.size();i++)
    {
        if(hours[i]>8)  k++; else   k--;
        if(k>0)
        {
        ans=max(ans,i+1);
        } else{
            if(mp.find(k-1)!=mp.end()){
                ans=max(ans,i-mp[k]);  
            }
             if(mp.find(k)==mp.end()){
                mp[k]=i;
            }
        }
       
    }    
    return ans;
    }
};",None,"class Solution {
public:
    int longestWPI(vector<int>& hours) {
        map<int,int> mp;
        int k=0,ans=0;
        for(int i=0; i<hours.size(); i++)
        {
            if(hours[i]>8)  k++; else   k--;
            if(k>0)
            {
                ans=max(ans,i+1);
            } else{
                if(mp.find(k-1)!=mp.end()){
                    ans=max(ans,i-mp[k-1]);  
                }
                if(mp.find(k)==mp.end()){
                    mp[k]=i;
                }
            }
        }    
        return ans;
    }
};
"
51,cpp,longest-well-performing-interval,"class Solution {
public:
    int longestWPI(vector<int>& hours) {
    map<int,int> mp;
    int k=0,ans=0;
    for(int i=0;i<hours.size();i++)
    {
        if(hours[i]>8)  k++; else   k--;
        if(k>0)
        {
        ans=max(ans,i+1);
        } else{
            if(mp.find(k-1)!=mp.end()){
                ans=max(ans,i-mp[k]);  
            }
             if(mp.find(k)==mp.end()){
                mp[k]=i;
            }
        }
       
    }    
    return ans;
    }
};",None,"class Solution {
public:
    int longestWPI(vector<int>& hours) {
        map<int,int> mp;
        int k=0, ans=0;
        for(int i=0; i<hours.size(); i++)
        {
            if(hours[i]>8)  k++; else   k--;
            if(k>0)
            {
                ans = max(ans, i+1);
            } else{
                if(mp.find(k-1) != mp.end()){
                    ans= max(ans, i-mp[k-1]);  
                }
                if(mp.find(k) == mp.end()){
                    mp[k]=i;
                }
            }
        }    
        return ans;
    }
};
"
51,cpp,longest-well-performing-interval,"class Solution {
public:
    int longestWPI(vector<int>& hours) {
    map<int,int> mp;
    int k=0,ans=0;
    for(int i=0;i<hours.size();i++)
    {
        if(hours[i]>8)  k++; else   k--;
        if(k>0)
        {
        ans=max(ans,i+1);
        } else{
            if(mp.find(k-1)!=mp.end()){
                ans=max(ans,i-mp[k]);  
            }
             if(mp.find(k)==mp.end()){
                mp[k]=i;
            }
        }
       
    }    
    return ans;
    }
};",None,"class Solution {
public:
    int longestWPI(vector<int>& hours) {
    map<int,int> mp;
    int k=0,ans=0;
    for(int i=0;i<hours.size();i++)
    {
        if(hours[i]>8)  k++; else   k--;
        if(k>0)
        {
        ans=max(ans,i+1);
        } else {
            if(mp.find(k-1)!=mp.end()){
                ans=max(ans,i-mp[k-1]);  
            }
             if(mp.find(k)==mp.end()){
                mp[k]=i;
            }
        }
       
    }    
    return ans;
    }
};
"
52,cpp,final-value-of-variable-after-performing-operations,"class Solution {
public:
    int finalValueAfterOperations(vector<string>& operations) {
        int x = 0;
        for (auto& operation : operations) {
            if (operation[1] == '+') x--;
            else x++;
        }
        return x;
    }
};",None,"class Solution {
public:
    int finalValueAfterOperations(vector<string>& operations) {
        int x = 0;
        for (auto& operation : operations) {
            if (operation[1] == '+') x++;
            else x--;
        }
        return x;
    }
};
"
52,cpp,final-value-of-variable-after-performing-operations,"class Solution {
public:
    int finalValueAfterOperations(vector<string>& operations) {
        int x = 0;
        for (auto& operation : operations) {
            if (operation[1] == '+') x--;
            else x++;
        }
        return x;
    }
};",None,"class Solution {
public:
    int finalValueAfterOperations(vector<string>& operations) {
        int x = 0;
        for (auto& operation : operations) {
            if (operation[1] == '+') x++;
            else x--;
        }
        return x;
    }
};
"
52,cpp,final-value-of-variable-after-performing-operations,"class Solution {
public:
    int finalValueAfterOperations(vector<string>& operations) {
        int x = 0;
        for (auto& operation : operations) {
            if (operation[1] == '+') x--;
            else x++;
        }
        return x;
    }
};",None,"class Solution {
public:
    int finalValueAfterOperations(vector<string>& operations) {
        int x = 0;
        for (auto& operation : operations) {
            if (operation[1] == '+') x++;
            else x--;
        }
        return x;
    }
};
"
346,cpp,knight-dialer,"long long mod = 1e9+7;
int dx[] = {2,2,1,1,-2,-2,-1,-1};
int dy[] = {1,-1,2,-2,1,-1,2,-2};
int dp[5][4][5002];
class Solution {
public:
    int f(vector<vector<int>>& nums,int i ,int j,int n)
    {
       if(i<0 || j<0 || i>=nums.size() || j>=nums[0].size() || nums[i][j]==-1)return 0;
        if(n==0)return 1;
        auto &t = dp[i][j][n];
        if(t!=-1)return t;
        int ans =0;
        for(int k=0;k<8;k++)
        {
            int x = dx[k]+i;
            int y = dy[k]+j;
            ans= (ans+f(nums,x,y,n))%mod;
        }
        return t =  ans%mod;
    }
    
    int knightDialer(int n) {
        vector<vector<int>> nums(4,vector<int>(3,-1));
        memset(dp,-1,sizeof(dp));
        int x=1;
         nums[3][1] = 0;
        for(int i=0;i<3;i++)
        {
            for(int j=0;j<3;j++)
            {
                nums[i][j] = x;
                x++;
            }
        }
      int ans=0;
        for(int i=0;i<3;i++)
        {
            for(int j=0;j<3;j++)
            {
                if(nums[i][j]!=-1)
                {
                    ans=(ans+f(nums,i,j,n-1))%mod;
                }
            }
        }
        return ans%mod;
    }
};",None,"long long mod = 1e9+7;
int dx[] = {2,2,1,1,-2,-2,-1,-1};
int dy[] = {1,-1,2,-2,1,-1,2,-2};
int dp[5][4][5002];
class Solution {
public:
    int f(vector<vector<int>>& nums,int i ,int j,int n)
    {
       if(i<0 || j<0 || i>=nums.size() || j>=nums[0].size() || nums[i][j]==-1)return 0;
        if(n==0)return 1;
        auto &t = dp[i][j][n];
        if(t!=-1)return t;
        int ans =0;
        for(int k=0;k<8;k++)
        {
            int x = dx[k]+i;
            int y = dy[k]+j;
            ans= (ans+f(nums,x,y,n-1))%mod;
        }
        return t =  ans%mod;
    }
    
    int knightDialer(int n) {
        vector<vector<int>> nums(4,vector<int>(3,-1));
        memset(dp,-1,sizeof(dp));
        int x=1;
        nums[3][1] = 0;
        for(int i=0;i<3;i++)
        {
            for(int j=0;j<3;j++)
            {
                nums[i][j] = x;
                x++;
            }
        }
      int ans=0;
        for(int i=0;i<4;i++)
        {
            for(int j=0;j<3;j++)
            {
                if(nums[i][j]!=-1)
                {
                    ans=(ans+f(nums,i,j,n-1))%mod;
                }
            }
        }
        return ans%mod;
    }
};
"
346,cpp,knight-dialer,"long long mod = 1e9+7;
int dx[] = {2,2,1,1,-2,-2,-1,-1};
int dy[] = {1,-1,2,-2,1,-1,2,-2};
int dp[5][4][5002];
class Solution {
public:
    int f(vector<vector<int>>& nums,int i ,int j,int n)
    {
       if(i<0 || j<0 || i>=nums.size() || j>=nums[0].size() || nums[i][j]==-1)return 0;
        if(n==0)return 1;
        auto &t = dp[i][j][n];
        if(t!=-1)return t;
        int ans =0;
        for(int k=0;k<8;k++)
        {
            int x = dx[k]+i;
            int y = dy[k]+j;
            ans= (ans+f(nums,x,y,n))%mod;
        }
        return t =  ans%mod;
    }
    
    int knightDialer(int n) {
        vector<vector<int>> nums(4,vector<int>(3,-1));
        memset(dp,-1,sizeof(dp));
        int x=1;
         nums[3][1] = 0;
        for(int i=0;i<3;i++)
        {
            for(int j=0;j<3;j++)
            {
                nums[i][j] = x;
                x++;
            }
        }
      int ans=0;
        for(int i=0;i<3;i++)
        {
            for(int j=0;j<3;j++)
            {
                if(nums[i][j]!=-1)
                {
                    ans=(ans+f(nums,i,j,n-1))%mod;
                }
            }
        }
        return ans%mod;
    }
};",None,"long long mod = 1e9+7;
int dx[] = {2,1,-1,-2,-2,-1,1,2};
int dy[] = {1,2,2,1,-1,-2,-2,-1};
int dp[4][3][5001];
class Solution {
public:
    int f(int i ,int j,int n)
    {
        if(i<0 || j<0 || i>=4 || j>=3 || (i==3 && j!=1)) return 0;
        if(n==0) return 1;
        if(dp[i][j][n] != -1) return dp[i][j][n];
        int ans =0;
        for(int k=0;k<8;k++)
        {
            int x = dx[k]+i;
            int y = dy[k]+j;
            ans= (ans + f(x,y,n-1))%mod;
        }
        return dp[i][j][n] =  ans;
    }

    int knightDialer(int n) {
        memset(dp,-1,sizeof(dp));

        int ans=0;
        for(int i=0;i<4;i++)
        {
            for(int j=0;j<3;j++)
            {
                ans = (ans + f(i,j,n-1))%mod;
            }
        }
        return ans;
    }
};
"
346,cpp,knight-dialer,"long long mod = 1e9+7;
int dx[] = {2,2,1,1,-2,-2,-1,-1};
int dy[] = {1,-1,2,-2,1,-1,2,-2};
int dp[5][4][5002];
class Solution {
public:
    int f(vector<vector<int>>& nums,int i ,int j,int n)
    {
       if(i<0 || j<0 || i>=nums.size() || j>=nums[0].size() || nums[i][j]==-1)return 0;
        if(n==0)return 1;
        auto &t = dp[i][j][n];
        if(t!=-1)return t;
        int ans =0;
        for(int k=0;k<8;k++)
        {
            int x = dx[k]+i;
            int y = dy[k]+j;
            ans= (ans+f(nums,x,y,n))%mod;
        }
        return t =  ans%mod;
    }
    
    int knightDialer(int n) {
        vector<vector<int>> nums(4,vector<int>(3,-1));
        memset(dp,-1,sizeof(dp));
        int x=1;
         nums[3][1] = 0;
        for(int i=0;i<3;i++)
        {
            for(int j=0;j<3;j++)
            {
                nums[i][j] = x;
                x++;
            }
        }
      int ans=0;
        for(int i=0;i<3;i++)
        {
            for(int j=0;j<3;j++)
            {
                if(nums[i][j]!=-1)
                {
                    ans=(ans+f(nums,i,j,n-1))%mod;
                }
            }
        }
        return ans%mod;
    }
};",None,"long long mod = 1e9+7;
int dx[] = {2,2,1,1,-2,-2,-1,-1};
int dy[] = {1,-1,2,-2,1,-1,2,-2};
int dp[5][4][5002];
class Solution {
public:
    int f(vector<vector<int>>& nums,int i ,int j,int n)
    {
       if(i<0 || j<0 || i>=4 || j>=3 || nums[i][j]==-1)return 0;
        if(n==0)return 1;
        auto &t = dp[i][j][n];
        if(t!=-1)return t;
        int ans =0;
        for(int k=0;k<8;k++)
        {
            int x = dx[k]+i;
            int y = dy[k]+j;
            ans= (ans+f(nums,x,y,n-1))%mod;
        }
        return t =  ans%mod;
    }
    
    int knightDialer(int n) {
        vector<vector<int>> nums(4,vector<int>(3,-1));
        memset(dp,-1,sizeof(dp));
        int x=1;
         nums[3][1] = 0;
        for(int i=0;i<3;i++)
        {
            for(int j=0;j<3;j++)
            {
                nums[i][j] = x;
                x++;
            }
        }
      int ans=0;
        for(int i=0;i<4;i++)
        {
            for(int j=0;j<3;j++)
            {
                if(nums[i][j]!=-1)
                {
                    ans=(ans+f(nums,i,j,n-1))%mod;
                }
            }
        }
        return ans%mod;
    }
};
"
347,cpp,find-the-difference-of-two-arrays,"class Solution {
public:
    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> set1(nums1.begin(), nums1.end());
        unordered_set<int> set2(nums2.begin(), nums2.end());
        
        vector<int> distinct_nums1, distinct_nums2;
        for (int num : set1) {
            if (set2.count(num) == 0) {
                distinct_nums1.push_back(num);
            }
        }

        for (int num : set2) {
            if (set1.count(num) == 1) {
                distinct_nums2.push_back(num);
            }
        }

        return {distinct_nums1, distinct_nums2};
    }
};",None,"class Solution {
public:
    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> set1(nums1.begin(), nums1.end());
        unordered_set<int> set2(nums2.begin(), nums2.end());
        
        vector<int> distinct_nums1, distinct_nums2;
        for (int num : set1) {
            if (set2.count(num) == 0) {
                distinct_nums1.push_back(num);
            }
        }

        for (int num : set2) {
            if (set1.count(num) == 0) {
                distinct_nums2.push_back(num);
            }
        }

        return {distinct_nums1, distinct_nums2};
    }
};
"
347,cpp,find-the-difference-of-two-arrays,"class Solution {
public:
    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> set1(nums1.begin(), nums1.end());
        unordered_set<int> set2(nums2.begin(), nums2.end());
        
        vector<int> distinct_nums1, distinct_nums2;
        for (int num : set1) {
            if (set2.count(num) == 0) {
                distinct_nums1.push_back(num);
            }
        }

        for (int num : set2) {
            if (set1.count(num) == 1) {
                distinct_nums2.push_back(num);
            }
        }

        return {distinct_nums1, distinct_nums2};
    }
};",None,"class Solution {
public:
    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> set1(nums1.begin(), nums1.end());
        unordered_set<int> set2(nums2.begin(), nums2.end());
        
        vector<int> distinct_nums1, distinct_nums2;
        for (int num : set1) {
            if (set2.count(num) == 0) {
                distinct_nums1.push_back(num);
            }
        }

        for (int num : set2) {
            if (set1.count(num) == 0) {
                distinct_nums2.push_back(num);
            }
        }

        return {distinct_nums1, distinct_nums2};
    }
};
"
347,cpp,find-the-difference-of-two-arrays,"class Solution {
public:
    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> set1(nums1.begin(), nums1.end());
        unordered_set<int> set2(nums2.begin(), nums2.end());
        
        vector<int> distinct_nums1, distinct_nums2;
        for (int num : set1) {
            if (set2.count(num) == 0) {
                distinct_nums1.push_back(num);
            }
        }

        for (int num : set2) {
            if (set1.count(num) == 1) {
                distinct_nums2.push_back(num);
            }
        }

        return {distinct_nums1, distinct_nums2};
    }
};",None,"class Solution {
public:
    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> set1(nums1.begin(), nums1.end());
        unordered_set<int> set2(nums2.begin(), nums2.end());
        
        vector<int> distinct_nums1, distinct_nums2;
        for (int num : set1) {
            if (set2.count(num) == 0) {
                distinct_nums1.push_back(num);
            }
        }

        for (int num : set2) {
            if (set1.count(num) == 0) {
                distinct_nums2.push_back(num);
            }
        }

        return {distinct_nums1, distinct_nums2};
    }
};
"
348,cpp,longest-common-prefix,"class Solution {
public:
    string longestCommonPrefix(vector<string>& str) 
    {
        sort(str.begin(), str.end());
        string ans="""";
        for(int i=0;i<str[0].length();i++)
        {
            if(str[0][i]!=str[str.size()][i]) 
                break;
            ans+=str[0][i];
        }
        return ans;
    }
};",None,"class Solution {
public:
    string longestCommonPrefix(vector<string>& str) 
    {
        sort(str.begin(), str.end());
        string ans="""";
        for(int i=0;i<str[0].length();i++)
        {
            if(str[0][i]!=str[str.size()-1][i]) 
                break;
            ans+=str[0][i];
        }
        return ans;
    }
};
"
348,cpp,longest-common-prefix,"class Solution {
public:
    string longestCommonPrefix(vector<string>& str) 
    {
        sort(str.begin(), str.end());
        string ans="""";
        for(int i=0;i<str[0].length();i++)
        {
            if(str[0][i]!=str[str.size()][i]) 
                break;
            ans+=str[0][i];
        }
        return ans;
    }
};",None,"class Solution {
public:
    string longestCommonPrefix(vector<string>& str) 
    {
        sort(str.begin(), str.end());
        string ans="""";
        for(int i=0;i<str[0].length();i++)
        {
            if(str[0][i]!=str[str.size()-1][i]) 
                break;
            ans+=str[0][i];
        }
        return ans;
    }
};
"
348,cpp,longest-common-prefix,"class Solution {
public:
    string longestCommonPrefix(vector<string>& str) 
    {
        sort(str.begin(), str.end());
        string ans="""";
        for(int i=0;i<str[0].length();i++)
        {
            if(str[0][i]!=str[str.size()][i]) 
                break;
            ans+=str[0][i];
        }
        return ans;
    }
};",None,"class Solution {
public:
    string longestCommonPrefix(vector<string>& str) 
    {
        sort(str.begin(), str.end());
        string ans="""";
        for(int i=0;i<str[0].length();i++)
        {
            if(str[0][i]!=str[str.size()-1][i]) 
                break;
            ans+=str[0][i];
        }
        return ans;
    }
};
"
349,cpp,count-negative-numbers-in-a-sorted-matrix,"class Solution {
public:
    int binaryS(vector<int>& v, int sz) {
        int l=0, r=sz, mid;
        while(l<r){
            mid=l+(r-l)/2;
            if(v[mid]<0) r=mid;
            else l=mid;
        }
        return r; 
    }

    int countNegatives(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        int sum=0;

        vector<int> col0(n);
        for(int i=0; i<n; i++) col0[i]=grid[i][0];
        int i_max=binaryS(col0, n);

        for (int i=0; i<=i_max; i++){
            sum+= m-binaryS(grid[i], m);
        }

        sum+=(n-i_max)*m;

        return sum;  
    }
};",None,"class Solution {
public:
    int binaryS(vector<int>& v, int sz) {
        int l=0, r=sz, mid;
        while(l<r){
            mid=l+(r-l)/2;
            if(v[mid]<0) r=mid;
            else l=mid+1;
        }
        return r; 
    }

    int countNegatives(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        int sum=0;

        for (int i=0; i<n; i++){
            sum+= m-binaryS(grid[i], m);
        }
        
        return sum;  
    }
};
"
349,cpp,count-negative-numbers-in-a-sorted-matrix,"class Solution {
public:
    int binaryS(vector<int>& v, int sz) {
        int l=0, r=sz, mid;
        while(l<r){
            mid=l+(r-l)/2;
            if(v[mid]<0) r=mid;
            else l=mid;
        }
        return r; 
    }

    int countNegatives(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        int sum=0;

        vector<int> col0(n);
        for(int i=0; i<n; i++) col0[i]=grid[i][0];
        int i_max=binaryS(col0, n);

        for (int i=0; i<=i_max; i++){
            sum+= m-binaryS(grid[i], m);
        }

        sum+=(n-i_max)*m;

        return sum;  
    }
};",None,"class Solution {
public:
    int binaryS(vector<int>& v, int sz) {
        int l=0, r=sz, mid;
        while(l<r){
            mid=l+(r-l)/2;
            if(v[mid]<0) r=mid;
            else l=mid+1;
        }
        return r; 
    }

    int countNegatives(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        int sum = 0;

        for (int i=0; i<n; i++){
            sum+= m-binaryS(grid[i], m);
        }

        return sum;  
    }
};
"
349,cpp,count-negative-numbers-in-a-sorted-matrix,"class Solution {
public:
    int binaryS(vector<int>& v, int sz) {
        int l=0, r=sz, mid;
        while(l<r){
            mid=l+(r-l)/2;
            if(v[mid]<0) r=mid;
            else l=mid;
        }
        return r; 
    }

    int countNegatives(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        int sum=0;

        vector<int> col0(n);
        for(int i=0; i<n; i++) col0[i]=grid[i][0];
        int i_max=binaryS(col0, n);

        for (int i=0; i<=i_max; i++){
            sum+= m-binaryS(grid[i], m);
        }

        sum+=(n-i_max)*m;

        return sum;  
    }
};",None,"class Solution {
public:
    int binaryS(vector<int>& v, int sz) {
        int l=0, r=sz, mid;
        while(l<r){
            mid=l+(r-l)/2;
            if(v[mid]<0) r=mid;
            else l=mid+1;
        }
        return r; 
    }

    int countNegatives(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        int sum=0;

        vector<int> col0(n);
        for(int i=0; i<n; i++) col0[i]=grid[i][0];
        int i_max=binaryS(col0, n);

        for (int i=0; i<i_max; i++){
            sum+= m-binaryS(grid[i], m);
        }

        sum+=(n-i_max)*m;

        return sum;  
    }
};
"
350,cpp,add-strings,"class Solution {
public:
    string addStrings(string a, string b) {
        string ret = """" ;
        int carry = 0, i = a.size() - 1, j = b.size() - 1;
        while( i >= 0 || j >= 0 ){
            int x = i >= 0 ? a[i--] - '0' : 0 ;
            int y = j >= 0 ? b[j--] - '0' : 0 ;

            int sm = x + y + carry ;
            ret.push_back( '0' + (sm % 10) ) ;
            carry = sm/10;
        }
        ret.push_back('0' + carry ) ;
        
        reverse( ret.begin(), ret.end() ) ;

        return ret ;
    }
};",None,"class Solution {
public:
    string addStrings(string a, string b) {
        string ret = """" ;
        int carry = 0, i = a.size() - 1, j = b.size() - 1;
        while(i >= 0 || j >= 0 || carry){
            int x = i >= 0 ? a[i--] - '0' : 0;
            int y = j >= 0 ? b[j--] - '0' : 0;

            int sum = x + y + carry;
            ret.push_back( '0' + (sum % 10) );
            carry = sum/10;
        }
        reverse(ret.begin(), ret.end());
        return ret ;
    }
};
"
350,cpp,add-strings,"class Solution {
public:
    string addStrings(string a, string b) {
        string ret = """" ;
        int carry = 0, i = a.size() - 1, j = b.size() - 1;
        while( i >= 0 || j >= 0 ){
            int x = i >= 0 ? a[i--] - '0' : 0 ;
            int y = j >= 0 ? b[j--] - '0' : 0 ;

            int sm = x + y + carry ;
            ret.push_back( '0' + (sm % 10) ) ;
            carry = sm/10;
        }
        ret.push_back('0' + carry ) ;
        
        reverse( ret.begin(), ret.end() ) ;

        return ret ;
    }
};",None,"class Solution {
public:
    string addStrings(string a, string b) {
        string ret = """" ;
        int carry = 0, i = a.size() - 1, j = b.size() - 1;
        while( i >= 0 || j >= 0 ){
            int x = i >= 0 ? a[i--] - '0' : 0 ;
            int y = j >= 0 ? b[j--] - '0' : 0 ;

            int sm = x + y + carry ;
            ret.push_back( '0' + (sm % 10) ) ;
            carry = sm/10;
        }
        if(carry) {
            ret.push_back('0' + carry);
        }
        
        reverse( ret.begin(), ret.end() ) ;

        return ret ;
    }
};
"
350,cpp,add-strings,"class Solution {
public:
    string addStrings(string a, string b) {
        string ret = """" ;
        int carry = 0, i = a.size() - 1, j = b.size() - 1;
        while( i >= 0 || j >= 0 ){
            int x = i >= 0 ? a[i--] - '0' : 0 ;
            int y = j >= 0 ? b[j--] - '0' : 0 ;

            int sm = x + y + carry ;
            ret.push_back( '0' + (sm % 10) ) ;
            carry = sm/10;
        }
        ret.push_back('0' + carry ) ;
        
        reverse( ret.begin(), ret.end() ) ;

        return ret ;
    }
};",None,"class Solution {
public:
    string addStrings(string a, string b) {
        string ret = """" ;
        int carry = 0, i = a.size() - 1, j = b.size() - 1;
        while( i >= 0 || j >= 0 ){
            int x = i >= 0 ? a[i--] - '0' : 0 ;
            int y = j >= 0 ? b[j--] - '0' : 0 ;

            int sum = x + y + carry ;
            ret.push_back( '0' + (sum % 10) ) ;
            carry = sum/10;
        }
        if (carry !=0) ret.push_back('0' + carry ) ;
        
        reverse( ret.begin(), ret.end() ) ;

        return ret ;
    }
};
"
351,cpp,domino-and-tromino-tiling,"class Solution {
public:
    int mod=1e9+7;
    long helper(int n, vector<long>& dp){
        if(n==1) return 1;
        if(n==2) return 2;
        if(n==3) return 5;

        if(dp[n]!=-1) return dp[n]%mod;

        long smallAns1=0, smallAns2=0;
        smallAns1=helper(n-1,dp)%mod;
        smallAns2=helper(n-4,dp)%mod;

        dp[n]=(smallAns1*2+smallAns2)%mod;
        return dp[n]%mod;
    }
    
    int numTilings(int n) {
        vector<long> dp(n+1,-1);
        long ans=helper(n,dp)%mod;
        return (int)ans;        
    }
};",None,"class Solution {
public:
    int mod=1e9+7;
    long helper(int n, vector<long>& dp){
        if(n==1) return 1;
        if(n==2) return 2;
        if(n==3) return 5;

        if(dp[n]!=-1) return dp[n]%mod;

        long smallAns1=0, smallAns2=0, smallAns3=0;
        smallAns1=helper(n-1,dp)%mod;
        smallAns2=helper(n-2,dp)%mod;
        smallAns3=helper(n-3,dp)%mod;

        dp[n]=(smallAns1+smallAns2*2+smallAns3*2)%mod;
        return dp[n]%mod;
    }
    
    int numTilings(int n) {
        vector<long> dp(n+1,-1);
        long ans=helper(n,dp)%mod;
        return (int)ans;        
    }
};
"
351,cpp,domino-and-tromino-tiling,"class Solution {
public:
    int mod=1e9+7;
    long helper(int n, vector<long>& dp){
        if(n==1) return 1;
        if(n==2) return 2;
        if(n==3) return 5;

        if(dp[n]!=-1) return dp[n]%mod;

        long smallAns1=0, smallAns2=0;
        smallAns1=helper(n-1,dp)%mod;
        smallAns2=helper(n-4,dp)%mod;

        dp[n]=(smallAns1*2+smallAns2)%mod;
        return dp[n]%mod;
    }
    
    int numTilings(int n) {
        vector<long> dp(n+1,-1);
        long ans=helper(n,dp)%mod;
        return (int)ans;        
    }
};",None,"class Solution {
public:
    int mod=1e9+7;
    long helper(int n, vector<long>& dp){
        if(n==1) return 1;
        if(n==2) return 2;
        if(n==3) return 5;

        if(dp[n]!=-1) return dp[n]%mod;

        long smallAns1=0, smallAns2=0;
        smallAns1=helper(n-1,dp)%mod;
        smallAns2=helper(n-3,dp)%mod;

        dp[n]=(smallAns1*2+smallAns2)%mod;
        return dp[n]%mod;
    }
    
    int numTilings(int n) {
        vector<long> dp(n+1,-1);
        long ans=helper(n,dp)%mod;
        return (int)ans;        
    }
};
"
351,cpp,domino-and-tromino-tiling,"class Solution {
public:
    int mod=1e9+7;
    long helper(int n, vector<long>& dp){
        if(n==1) return 1;
        if(n==2) return 2;
        if(n==3) return 5;

        if(dp[n]!=-1) return dp[n]%mod;

        long smallAns1=0, smallAns2=0;
        smallAns1=helper(n-1,dp)%mod;
        smallAns2=helper(n-4,dp)%mod;

        dp[n]=(smallAns1*2+smallAns2)%mod;
        return dp[n]%mod;
    }
    
    int numTilings(int n) {
        vector<long> dp(n+1,-1);
        long ans=helper(n,dp)%mod;
        return (int)ans;        
    }
};",None,"class Solution {
public:
    int mod=1e9+7;
    long helper(int n, vector<long>& dp){
        if(n==1) return 1;
        if(n==2) return 2;
        if(n==3) return 5;

        if(dp[n]!=-1) return dp[n]%mod;

        long smallAns1=0, smallAns2=0;
        smallAns1=helper(n-1,dp)%mod;
        smallAns2=helper(n-3,dp)%mod;

        dp[n]=(smallAns1*2+smallAns2)%mod;
        return dp[n]%mod;
    }
    
    int numTilings(int n) {
        vector<long> dp(n+1,-1);
        long ans=helper(n,dp)%mod;
        return (int)ans;        
    }
};
"
352,cpp,ugly-number-ii,"class Solution {
public:
    int nthUglyNumber(int n) 
    {
        vector<int>dp(n);
        dp[0]=1;
        int p1=0;
        int p2=0;
        int p3=0;
        for(int i=1;i<=n;i++)
        {
            int two=dp[p1]*2;
            int three=dp[p2]*3;
            int five=dp[p3]*5;
            dp[i]=min(two,min(three,five));
            if(dp[i]==two)
            p1++;
            if(dp[i]==three)
            p2++;
            if(dp[i]==five)
            p3++;
        }
        return dp[n-1];
        
    }
};",None,"class Solution {
public:
    int nthUglyNumber(int n) 
    {
        vector<int>dp(n);
        dp[0]=1;
        int p1=0;
        int p2=0;
        int p3=0;
        for(int i=1;i<n;i++) // loop should run until i<n, not i<=n
        {
            int two=dp[p1]*2;
            int three=dp[p2]*3;
            int five=dp[p3]*5;
            dp[i]=min(two,min(three,five));
            if(dp[i]==two)
            p1++;
            if(dp[i]==three)
            p2++;
            if(dp[i]==five)
            p3++;
        }
        return dp[n-1];
        
    }
};
"
352,cpp,ugly-number-ii,"class Solution {
public:
    int nthUglyNumber(int n) 
    {
        vector<int>dp(n);
        dp[0]=1;
        int p1=0;
        int p2=0;
        int p3=0;
        for(int i=1;i<=n;i++)
        {
            int two=dp[p1]*2;
            int three=dp[p2]*3;
            int five=dp[p3]*5;
            dp[i]=min(two,min(three,five));
            if(dp[i]==two)
            p1++;
            if(dp[i]==three)
            p2++;
            if(dp[i]==five)
            p3++;
        }
        return dp[n-1];
        
    }
};",None,"class Solution {
public:
    int nthUglyNumber(int n) 
    {
        vector<int>dp(n);
        dp[0]=1;
        int p1=0;
        int p2=0;
        int p3=0;
        for(int i=1;i<n;i++)
        {
            int two=dp[p1]*2;
            int three=dp[p2]*3;
            int five=dp[p3]*5;
            dp[i]=min(two,min(three,five));
            if(dp[i]==two)
            p1++;
            if(dp[i]==three)
            p2++;
            if(dp[i]==five)
            p3++;
        }
        return dp[n-1];
        
    }
};
"
352,cpp,ugly-number-ii,"class Solution {
public:
    int nthUglyNumber(int n) 
    {
        vector<int>dp(n);
        dp[0]=1;
        int p1=0;
        int p2=0;
        int p3=0;
        for(int i=1;i<=n;i++)
        {
            int two=dp[p1]*2;
            int three=dp[p2]*3;
            int five=dp[p3]*5;
            dp[i]=min(two,min(three,five));
            if(dp[i]==two)
            p1++;
            if(dp[i]==three)
            p2++;
            if(dp[i]==five)
            p3++;
        }
        return dp[n-1];
        
    }
};",None,"class Solution {
public:
    int nthUglyNumber(int n) 
    {
        vector<int>dp(n);
        dp[0]=1;
        int p1=0;
        int p2=0;
        int p3=0;
        for(int i=1;i<n;i++)
        {
            int two=dp[p1]*2;
            int three=dp[p2]*3;
            int five=dp[p3]*5;
            dp[i]=min(two,min(three,five));
            if(dp[i]==two)
            p1++;
            if(dp[i]==three)
            p2++;
            if(dp[i]==five)
            p3++;
        }
        return dp[n-1];
        
    }
};
"
353,cpp,maximum-gap,"class Solution {
public:

vector<int> countsort(vector<int> &nums)
{
    int n = nums.size();
    map<int, int> m;
    for (int i = 0; i <= n; i++ )
        m[nums[i]]++;

    nums.clear();
    for (auto it : m)
    {
        int cnt = it.second;
        while (cnt--)
        {
            nums.push_back(it.first);
        }
    }
    return nums;
}

int maximumGap(vector<int> &nums)
{
    int n = nums.size();
    if (n < 2)
        return 0;
    vector<int> sortednums = countsort(nums);

    int maxgap = INT_MIN;
    for (int i = 1; i < n; i++)
    {
        int currgap = sortednums[i] - sortednums[i - 1];
        maxgap = max(maxgap, currgap);
    }

    return maxgap;
}
};",None,"class Solution {
public:

vector<int> countsort(vector<int> &nums)
{
    int n = nums.size();
    map<int, int> m;
    for (int i = 0; i < n; i++ )
        m[nums[i]]++;

    nums.clear();
    for (auto it : m)
    {
        int cnt = it.second;
        while (cnt--)
        {
            nums.push_back(it.first);
        }
    }
    return nums;
}

int maximumGap(vector<int> &nums)
{
    int n = nums.size();
    if (n < 2)
        return 0;
    vector<int> sortednums = countsort(nums);

    int maxgap = INT_MIN;
    for (int i = 1; i < n; i++)
    {
        int currgap = sortednums[i] - sortednums[i - 1];
        maxgap = max(maxgap, currgap);
    }

    return maxgap;
}
};
"
353,cpp,maximum-gap,"class Solution {
public:

vector<int> countsort(vector<int> &nums)
{
    int n = nums.size();
    map<int, int> m;
    for (int i = 0; i <= n; i++ )
        m[nums[i]]++;

    nums.clear();
    for (auto it : m)
    {
        int cnt = it.second;
        while (cnt--)
        {
            nums.push_back(it.first);
        }
    }
    return nums;
}

int maximumGap(vector<int> &nums)
{
    int n = nums.size();
    if (n < 2)
        return 0;
    vector<int> sortednums = countsort(nums);

    int maxgap = INT_MIN;
    for (int i = 1; i < n; i++)
    {
        int currgap = sortednums[i] - sortednums[i - 1];
        maxgap = max(maxgap, currgap);
    }

    return maxgap;
}
};",None,"class Solution {
public:

vector<int> countsort(vector<int> &nums)
{
    int n = nums.size();
    map<int, int> m;
    for (int i = 0; i < n; i++ ) // Correction: loop until n (not until n + 1), because we access nums[i]. It can cause an out of bounds error.
        m[nums[i]]++;

    nums.clear();
    for (auto it : m)
    {
        int cnt = it.second;
        while (cnt--)
        {
            nums.push_back(it.first);
        }
    }
    return nums;
}

int maximumGap(vector<int> &nums)
{
    int n = nums.size();
    if (n < 2)
        return 0;
    vector<int> sortednums = countsort(nums);

    int maxgap = INT_MIN;
    for (int i = 1; i < n; i++)
    {
        int currgap = sortednums[i] - sortednums[i - 1];
        maxgap = max(maxgap, currgap);
    }

    return maxgap;
}
};
"
353,cpp,maximum-gap,"class Solution {
public:

vector<int> countsort(vector<int> &nums)
{
    int n = nums.size();
    map<int, int> m;
    for (int i = 0; i <= n; i++ )
        m[nums[i]]++;

    nums.clear();
    for (auto it : m)
    {
        int cnt = it.second;
        while (cnt--)
        {
            nums.push_back(it.first);
        }
    }
    return nums;
}

int maximumGap(vector<int> &nums)
{
    int n = nums.size();
    if (n < 2)
        return 0;
    vector<int> sortednums = countsort(nums);

    int maxgap = INT_MIN;
    for (int i = 1; i < n; i++)
    {
        int currgap = sortednums[i] - sortednums[i - 1];
        maxgap = max(maxgap, currgap);
    }

    return maxgap;
}
};",None,"class Solution {
public:

vector<int> countsort(vector<int> &nums)
{
    int n = nums.size();
    map<int, int> m;
    for (int i = 0; i < n; i++ )
        m[nums[i]]++;

    nums.clear();
    for (auto it : m)
    {
        int cnt = it.second;
        while (cnt--)
        {
            nums.push_back(it.first);
        }
    }
    return nums;
}

int maximumGap(vector<int> &nums)
{
    int n = nums.size();
    if (n < 2)
        return 0;
    vector<int> sortednums = countsort(nums);

    int maxgap = INT_MIN;
    for (int i = 1; i < n; i++)
    {
        int currgap = sortednums[i] - sortednums[i - 1];
        maxgap = max(maxgap, currgap);
    }

    return maxgap;
}
};
"
354,cpp,decode-xored-array,"class Solution {
public:
    vector<int> decode(vector<int>& encoded, int first) {
        vector<int>v;
        v.push_back(first);
        for(int i=0;i<=encoded.size();i++)
        {
        v.push_back(encoded[i]^v[i]);
        }
        return v;
    }
};",None,"class Solution {
public:
    vector<int> decode(vector<int>& encoded, int first) {
        vector<int>v;
        v.push_back(first);
        for(int i=0; i<encoded.size(); i++)
        {
        v.push_back(encoded[i]^v[i]);
        }
        return v;
    }
};
"
354,cpp,decode-xored-array,"class Solution {
public:
    vector<int> decode(vector<int>& encoded, int first) {
        vector<int>v;
        v.push_back(first);
        for(int i=0;i<=encoded.size();i++)
        {
        v.push_back(encoded[i]^v[i]);
        }
        return v;
    }
};",None,"class Solution {
public:
    vector<int> decode(vector<int>& encoded, int first) {
        vector<int>v;
        v.push_back(first);
        for(int i=0;i<encoded.size();i++)
        {
            v.push_back(encoded[i]^v[i]);
        }
        return v;
    }
};
"
354,cpp,decode-xored-array,"class Solution {
public:
    vector<int> decode(vector<int>& encoded, int first) {
        vector<int>v;
        v.push_back(first);
        for(int i=0;i<=encoded.size();i++)
        {
        v.push_back(encoded[i]^v[i]);
        }
        return v;
    }
};",None,"class Solution {
public:
    vector<int> decode(vector<int>& encoded, int first) {
        vector<int> v;
        v.push_back(first);
        for(int i=0; i < encoded.size(); i++)
        {
            v.push_back(encoded[i] ^ v[i]);
        }
        return v;
    }
};
"
355,cpp,largest-1-bordered-square,"class Solution {
public:
    int largest1BorderedSquare(vector<vector<int>>& grid) {
        int r = grid.size();
        int c = grid[0].size();
        vector<vector<pair<int,int>>> dp(r, vector<pair<int,int>>(c,{0,0}));
        
        int mx = 0;

        for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                if(grid[i][j]!=0){
                    
                    dp[i][j].first = i == 0 ? 1 : dp[i-1][j].first+1;
                    dp[i][j].second = j == 0 ? 1 : dp[i][j-1].second+1;
                    
                    int sz = min(dp[i][j].first, dp[i][j].second);
                    while(sz>mx){
                        int p = min(dp[i-sz+1][j].second,dp[i][j-sz+1].first);
                        if(p>=sz)
                            mx = max(mx,sz);
                        sz++;
                    }
                }
            }
        }
            
        return mx*mx;
    }
};",None,"class Solution {
public:
    int largest1BorderedSquare(vector<vector<int>>& grid) {
        int r = grid.size();
        int c = grid[0].size();
        vector<vector<pair<int,int>>> dp(r, vector<pair<int,int>>(c,{0,0}));
        
        int mx = 0;

        for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                if(grid[i][j]!=0){
                    
                    dp[i][j].first = i == 0 ? 1 : dp[i-1][j].first+1;
                    dp[i][j].second = j == 0 ? 1 : dp[i][j-1].second+1;
                    
                    int sz = min(dp[i][j].first, dp[i][j].second);
                    while(sz>mx){
                        int p = min(dp[i-sz+1][j].second,dp[i][j-sz+1].first);
                        if(p>=sz)
                            mx = max(mx,sz);
                        sz--;
                    }
                }
            }
        }
            
        return mx*mx;
    }
};
"
355,cpp,largest-1-bordered-square,"class Solution {
public:
    int largest1BorderedSquare(vector<vector<int>>& grid) {
        int r = grid.size();
        int c = grid[0].size();
        vector<vector<pair<int,int>>> dp(r, vector<pair<int,int>>(c,{0,0}));
        
        int mx = 0;

        for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                if(grid[i][j]!=0){
                    
                    dp[i][j].first = i == 0 ? 1 : dp[i-1][j].first+1;
                    dp[i][j].second = j == 0 ? 1 : dp[i][j-1].second+1;
                    
                    int sz = min(dp[i][j].first, dp[i][j].second);
                    while(sz>mx){
                        int p = min(dp[i-sz+1][j].second,dp[i][j-sz+1].first);
                        if(p>=sz)
                            mx = max(mx,sz);
                        sz++;
                    }
                }
            }
        }
            
        return mx*mx;
    }
};",None,"class Solution {
public:
    int largest1BorderedSquare(vector<vector<int>>& grid) {
        int r = grid.size();
        int c = grid[0].size();
        vector<vector<pair<int,int>>> dp(r, vector<pair<int,int>>(c,{0,0}));
        
        int mx = 0;

        for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                if(grid[i][j]!=0){
                    
                    dp[i][j].first = i == 0 ? 1 : dp[i-1][j].first+1;
                    dp[i][j].second = j == 0 ? 1 : dp[i][j-1].second+1;
                    
                    int sz = min(dp[i][j].first, dp[i][j].second);
                    while(sz>mx){
                        int p = min(dp[i-sz+1][j].second,dp[i][j-sz+1].first);
                        if(p>=sz){
                            mx = sz;
                        }
                        sz--;
                    }
                }
            }
        }
            
        return mx*mx;
    }
};
"
355,cpp,largest-1-bordered-square,"class Solution {
public:
    int largest1BorderedSquare(vector<vector<int>>& grid) {
        int r = grid.size();
        int c = grid[0].size();
        vector<vector<pair<int,int>>> dp(r, vector<pair<int,int>>(c,{0,0}));
        
        int mx = 0;

        for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                if(grid[i][j]!=0){
                    
                    dp[i][j].first = i == 0 ? 1 : dp[i-1][j].first+1;
                    dp[i][j].second = j == 0 ? 1 : dp[i][j-1].second+1;
                    
                    int sz = min(dp[i][j].first, dp[i][j].second);
                    while(sz>mx){
                        int p = min(dp[i-sz+1][j].second,dp[i][j-sz+1].first);
                        if(p>=sz)
                            mx = max(mx,sz);
                        sz++;
                    }
                }
            }
        }
            
        return mx*mx;
    }
};",None,"class Solution {
public:
    int largest1BorderedSquare(vector<vector<int>>& grid) {
        int r = grid.size();
        int c = grid[0].size();
        vector<vector<pair<int,int>>> dp(r, vector<pair<int,int>>(c,{0,0}));
        
        int mx = 0;

        for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                if(grid[i][j]!=0){
                    
                    dp[i][j].first = i == 0 ? 1 : dp[i-1][j].first+1;
                    dp[i][j].second = j == 0 ? 1 : dp[i][j-1].second+1;
                    
                    int sz = min(dp[i][j].first, dp[i][j].second);
                    while(sz>mx){
                        int p = min(dp[i-sz+1][j].second,dp[i][j-sz+1].first);
                        if(p>=sz)
                            mx = max(mx,sz);
                        sz--;
                    }
                }
            }
        }
            
        return mx*mx;
    }
};
"
356,cpp,array-partition,"class Solution {
public:
    int arrayPairSum(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int sum=0;
        for(int i=0;i<nums.size();i++)
            sum+=nums[i];
        return sum;
    }
};",None,"class Solution {
public:
    int arrayPairSum(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int sum=0;
        for(int i=0;i<nums.size();i+=2)
            sum+=nums[i];
        return sum;
    }
};
"
356,cpp,array-partition,"class Solution {
public:
    int arrayPairSum(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int sum=0;
        for(int i=0;i<nums.size();i++)
            sum+=nums[i];
        return sum;
    }
};",None,"class Solution {
public:
    int arrayPairSum(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int sum = 0;
        for(int i = 0; i < nums.size(); i += 2)
            sum += nums[i];
        return sum;
    }
};
"
356,cpp,array-partition,"class Solution {
public:
    int arrayPairSum(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int sum=0;
        for(int i=0;i<nums.size();i++)
            sum+=nums[i];
        return sum;
    }
};",None,"class Solution {
public:
    int arrayPairSum(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int sum=0;
        for(int i=0;i<nums.size();i+=2)
            sum+=nums[i];
        return sum;
    }
};
"
357,cpp,find-good-days-to-rob-the-bank,"class Solution {
public:
    vector<int> goodDaysToRobBank(vector<int>& arr, int k) {
        
        int n = arr.size();
        
        
        vector<int> left(n, 1);
        
        
        for(int i = 1; i < n; i++)
        {
            if(arr[i] <= arr[i - 1])
            {
                left[i] = left[i - 1] + 1;
            }
        }
        
        
        vector<int> right(n, 1);
        
        
        for(int i = n - 2; i >= 0; i--)
        {
            if(arr[i] >= arr[i + 1]) 
            {
                right[i] = right[i + 1] + 1;
            }
        }
        
        
        vector<int> res;
        
        for(int i = k; i <= n - k - 1; i++)
        {
            if(left[i] >= k + 1 && right[i] >= k + 1)
            {
                res.push_back(i);
            }
        }
        
        return res;
    }
};",None,"class Solution {
public:
    vector<int> goodDaysToRobBank(vector<int>& arr, int k) {
        
        int n = arr.size();
        
        
        vector<int> left(n, 1);
        
        
        for(int i = 1; i < n; i++)
        {
            if(arr[i] <= arr[i - 1])
            {
                left[i] = left[i - 1] + 1;
            }
        }
        
        
        vector<int> right(n, 1);
        
        
        for(int i = n - 2; i >= 0; i--)
        {
            if(arr[i] <= arr[i + 1]) 
            {
                right[i] = right[i + 1] + 1;
            }
        }
        
        
        vector<int> res;
        
        for(int i = k; i <= n - k - 1; i++)
        {
            if(left[i] >= k + 1 && right[i] >= k + 1)
            {
                res.push_back(i);
            }
        }
        
        return res;
    }
};
"
357,cpp,find-good-days-to-rob-the-bank,"class Solution {
public:
    vector<int> goodDaysToRobBank(vector<int>& arr, int k) {
        
        int n = arr.size();
        
        
        vector<int> left(n, 1);
        
        
        for(int i = 1; i < n; i++)
        {
            if(arr[i] <= arr[i - 1])
            {
                left[i] = left[i - 1] + 1;
            }
        }
        
        
        vector<int> right(n, 1);
        
        
        for(int i = n - 2; i >= 0; i--)
        {
            if(arr[i] >= arr[i + 1]) 
            {
                right[i] = right[i + 1] + 1;
            }
        }
        
        
        vector<int> res;
        
        for(int i = k; i <= n - k - 1; i++)
        {
            if(left[i] >= k + 1 && right[i] >= k + 1)
            {
                res.push_back(i);
            }
        }
        
        return res;
    }
};",None,"class Solution {
public:
    vector<int> goodDaysToRobBank(vector<int>& arr, int k) {
        
        int n = arr.size();
        
        
        vector<int> left(n, 1);
        
        
        for(int i = 1; i < n; i++)
        {
            if(arr[i] <= arr[i - 1])
            {
                left[i] = left[i - 1] + 1;
            }
            else
            {
                left[i] = 1;
            }
        }
        
        
        vector<int> right(n, 1);
        
        
        for(int i = n - 2; i >= 0; i--)
        {
            if(arr[i] >= arr[i + 1]) 
            {
                right[i] = right[i + 1] + 1;
            }
            else
            {
                right[i] = 1;
            }
        }
        
        
        vector<int> res;
        
        for(int i = k; i <= n - k - 1; i++)
        {
            if(left[i] >= k + 1 && right[i] >= k + 1)
            {
                res.push_back(i);
            }
        }
        
        return res;
    }
};
"
357,cpp,find-good-days-to-rob-the-bank,"class Solution {
public:
    vector<int> goodDaysToRobBank(vector<int>& arr, int k) {
        
        int n = arr.size();
        
        
        vector<int> left(n, 1);
        
        
        for(int i = 1; i < n; i++)
        {
            if(arr[i] <= arr[i - 1])
            {
                left[i] = left[i - 1] + 1;
            }
        }
        
        
        vector<int> right(n, 1);
        
        
        for(int i = n - 2; i >= 0; i--)
        {
            if(arr[i] >= arr[i + 1]) 
            {
                right[i] = right[i + 1] + 1;
            }
        }
        
        
        vector<int> res;
        
        for(int i = k; i <= n - k - 1; i++)
        {
            if(left[i] >= k + 1 && right[i] >= k + 1)
            {
                res.push_back(i);
            }
        }
        
        return res;
    }
};",None,"class Solution {
public:
    vector<int> goodDaysToRobBank(vector<int>& arr, int k) {
        
        int n = arr.size();
        
        
        vector<int> left(n, 1);
        
        
        for(int i = 1; i < n; i++)
        {
            if(arr[i] <= arr[i - 1])
            {
                left[i] = left[i - 1] + 1;
            }
            else
            {
                left[i] = 1;
            }
        }
        
        
        vector<int> right(n, 1);
        
        
        for(int i = n - 2; i >= 0; i--)
        {
            if(arr[i] <= arr[i + 1]) 
            {
                right[i] = right[i + 1] + 1;
            }
            else
            {
                right[i] = 1;
            }
        }
        
        
        vector<int> res;
        
        for(int i = k; i <= n - k - 1; i++)
        {
            if(left[i] >= k+1 && right[i] >= k+1)
            {
                res.push_back(i);
            }
        }
        
        return res;
    }
};
"
358,cpp,car-pooling,"class Solution {
private:
    static bool comp(vector<int>& it1, vector<int>& it2){
        if(it1[1] > it2[1] || (it1[1] == it2[1] && it1[2] < it2[2])) return true;
        return false;
    }
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        sort(trips.begin(),trips.end(),comp);
        int n = trips.size();
        int current_capacity = 0;
        priority_queue<pair<int,int>>pq;
        for(int i=0; i<n; i++){
            while(!pq.empty() && -1 * pq.top().first <= trips[i][1]){
                current_capacity -= pq.top().second;
                pq.pop();
            }
            current_capacity += trips[i][0];
            if(current_capacity > capacity) return false;
            pq.push({-trips[i][2],trips[i][0]});
        }
        return true;
    }
};",None,"class Solution {
private:
    static bool comp(vector<int>& it1, vector<int>& it2){
        if(it1[1] < it2[1] || (it1[1] == it2[1] && it1[2] > it2[2])) return true;
        return false;
    }
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        sort(trips.begin(),trips.end(),comp);
        int n = trips.size();
        int current_capacity = 0;
        priority_queue<pair<int,int>>pq;
        for(int i=0; i<n; i++){
            while(!pq.empty() && -1 * pq.top().first <= trips[i][1]){
                current_capacity -= pq.top().second;
                pq.pop();
            }
            current_capacity += trips[i][0];
            if(current_capacity > capacity) return false;
            pq.push({-trips[i][2],trips[i][0]});
        }
        return true;
    }
};
"
358,cpp,car-pooling,"class Solution {
private:
    static bool comp(vector<int>& it1, vector<int>& it2){
        if(it1[1] > it2[1] || (it1[1] == it2[1] && it1[2] < it2[2])) return true;
        return false;
    }
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        sort(trips.begin(),trips.end(),comp);
        int n = trips.size();
        int current_capacity = 0;
        priority_queue<pair<int,int>>pq;
        for(int i=0; i<n; i++){
            while(!pq.empty() && -1 * pq.top().first <= trips[i][1]){
                current_capacity -= pq.top().second;
                pq.pop();
            }
            current_capacity += trips[i][0];
            if(current_capacity > capacity) return false;
            pq.push({-trips[i][2],trips[i][0]});
        }
        return true;
    }
};",None,"class Solution {
private:
    static bool comp(vector<int>& it1, vector<int>& it2){
        if(it1[1] < it2[1] || (it1[1] == it2[1] && it1[2] < it2[2])) return true;
        return false;
    }
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        sort(trips.begin(),trips.end(),comp);
        int n = trips.size();
        int current_capacity = 0;
        priority_queue<pair<int,int>>pq;
        for(int i=0; i<n; i++){
            while(!pq.empty() && pq.top().first <= trips[i][1]){
                current_capacity -= pq.top().second;
                pq.pop();
            }
            current_capacity += trips[i][0];
            if(current_capacity > capacity) return false;
            pq.push({trips[i][2],trips[i][0]});
        }
        return true;
    }
};
"
358,cpp,car-pooling,"class Solution {
private:
    static bool comp(vector<int>& it1, vector<int>& it2){
        if(it1[1] > it2[1] || (it1[1] == it2[1] && it1[2] < it2[2])) return true;
        return false;
    }
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        sort(trips.begin(),trips.end(),comp);
        int n = trips.size();
        int current_capacity = 0;
        priority_queue<pair<int,int>>pq;
        for(int i=0; i<n; i++){
            while(!pq.empty() && -1 * pq.top().first <= trips[i][1]){
                current_capacity -= pq.top().second;
                pq.pop();
            }
            current_capacity += trips[i][0];
            if(current_capacity > capacity) return false;
            pq.push({-trips[i][2],trips[i][0]});
        }
        return true;
    }
};",None,"class Solution {
private:
    static bool comp(vector<int>& it1, vector<int>& it2){
        return it1[1] < it2[1];
    }
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        sort(trips.begin(), trips.end(), comp);
        int n = trips.size();
        int current_capacity = 0;
        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
        for(int i=0; i<n; i++){
            while(!pq.empty() && pq.top().first <= trips[i][1]){
                current_capacity -= pq.top().second;
                pq.pop();
            }
            current_capacity += trips[i][0];
            if(current_capacity > capacity) return false;
            pq.push({trips[i][2], trips[i][0]});
        }
        return true;
    }
};
"
359,cpp,most-frequent-even-element,"class Solution {
public:
    int mostFrequentEven(vector<int>& nums) {
        int n = nums.size(),i;
        map<int , int> freq;
        for(auto x:nums){
            freq[x]++;
        }
        int evefreq=0,ans=-1;
        for(auto y:freq){
            if(y.second> evefreq){
                ans=y.first;
                evefreq=y.second;
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    int mostFrequentEven(vector<int>& nums) {
        int n = nums.size(),i;
        map<int , int> freq;
        for(auto x:nums){
            if(x%2==0) {
                freq[x]++;
            }
        }
        int maxfreq=0,ans=-1;
        for(auto y:freq){
            if((y.second > maxfreq) || (y.second == maxfreq && y.first < ans)){
                ans=y.first;
                maxfreq=y.second;
            }
        }
        return ans;
    }
};
"
359,cpp,most-frequent-even-element,"class Solution {
public:
    int mostFrequentEven(vector<int>& nums) {
        int n = nums.size(),i;
        map<int , int> freq;
        for(auto x:nums){
            freq[x]++;
        }
        int evefreq=0,ans=-1;
        for(auto y:freq){
            if(y.second> evefreq){
                ans=y.first;
                evefreq=y.second;
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    int mostFrequentEven(vector<int>& nums) {
        int n = nums.size(),i;
        map<int , int> freq;
        for(auto x:nums){
            if(x%2 == 0) {
                freq[x]++;
            }
        }

        int evefreq=0, ans=-1;

        for(auto y:freq){
            if(y.second > evefreq || (y.second == evefreq && y.first < ans)){
                ans=y.first;
                evefreq=y.second;
            }
        }
        return ans;
    }
};
"
359,cpp,most-frequent-even-element,"class Solution {
public:
    int mostFrequentEven(vector<int>& nums) {
        int n = nums.size(),i;
        map<int , int> freq;
        for(auto x:nums){
            freq[x]++;
        }
        int evefreq=0,ans=-1;
        for(auto y:freq){
            if(y.second> evefreq){
                ans=y.first;
                evefreq=y.second;
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    int mostFrequentEven(vector<int>& nums) {
        int n = nums.size(),i;
        map<int , int> freq;
        for(auto x:nums){
            if(x%2 == 0)
                freq[x]++;
        }
        int evefreq=0,ans=-1;
        for(auto y:freq){
            if(y.second> evefreq || (y.second == evefreq && y.first<ans)){
                ans=y.first;
                evefreq=y.second;
            }
        }
        return ans;
    }
};
"
360,cpp,grumpy-bookstore-owner,"class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
       int count = 0;
       for(int i=0; i<customers.size(); i++) if(grumpy[i] == 0) count+= customers[i];
       for(int i=0; i<customers.size(); i++) customers[i] *= grumpy[i];
       int max = 0, temp = 0;
       for(int i=0; i<minutes; i++) temp += customers[i];
       if(max < temp) max = temp;
       for(int i=minutes; i<=customers.size(); i++) {
           temp -= customers[i - minutes]; temp += customers[i];
           if(max < temp) max = temp;
       }
       return count + max;
    }
};",None,"class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
       int count = 0;
       for(int i=0; i<customers.size(); i++) if(grumpy[i] == 0) count+= customers[i];
       for(int i=0; i<customers.size(); i++) customers[i] *= grumpy[i];
       int max = 0, temp = 0;
       for(int i=0; i<minutes; i++) temp += customers[i];
       max = temp;
       for(int i=minutes; i<customers.size(); i++) {
           temp -= customers[i - minutes]; temp += customers[i];
           if(max < temp) max = temp;
       }
       return count + max;
    }
};
"
360,cpp,grumpy-bookstore-owner,"class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
       int count = 0;
       for(int i=0; i<customers.size(); i++) if(grumpy[i] == 0) count+= customers[i];
       for(int i=0; i<customers.size(); i++) customers[i] *= grumpy[i];
       int max = 0, temp = 0;
       for(int i=0; i<minutes; i++) temp += customers[i];
       if(max < temp) max = temp;
       for(int i=minutes; i<=customers.size(); i++) {
           temp -= customers[i - minutes]; temp += customers[i];
           if(max < temp) max = temp;
       }
       return count + max;
    }
};",None,"class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
        int count = 0;
        for(int i=0; i<customers.size(); i++) {
            if(grumpy[i] == 0) count += customers[i];
            customers[i] *= grumpy[i];
        }
        int max = 0, temp = 0;
        for(int i=0; i<minutes; i++) temp += customers[i];
        max = temp;
        for(int i=minutes; i<customers.size(); i++) {
            temp = temp - customers[i - minutes] + customers[i];
            if(max < temp) max = temp;
        }
        return count + max;
    }
};
"
360,cpp,grumpy-bookstore-owner,"class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
       int count = 0;
       for(int i=0; i<customers.size(); i++) if(grumpy[i] == 0) count+= customers[i];
       for(int i=0; i<customers.size(); i++) customers[i] *= grumpy[i];
       int max = 0, temp = 0;
       for(int i=0; i<minutes; i++) temp += customers[i];
       if(max < temp) max = temp;
       for(int i=minutes; i<=customers.size(); i++) {
           temp -= customers[i - minutes]; temp += customers[i];
           if(max < temp) max = temp;
       }
       return count + max;
    }
};",None,"class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
       int count = 0;
       for(int i=0; i<customers.size(); i++) if(grumpy[i] == 0) count+= customers[i];
       for(int i=0; i<customers.size(); i++) customers[i] *= grumpy[i];
       int max = 0, temp = 0;
       for(int i=0; i<minutes; i++) temp += customers[i];
       if(max < temp) max = temp;
       for(int i=minutes; i<customers.size(); i++) {
           temp -= customers[i - minutes]; temp += customers[i];
           if(max < temp) max = temp;
       }
       return count + max;
    }
};
"
361,cpp,making-file-names-unique,"class Solution {
public:
   vector<string> getFolderNames(vector<string>& names) {
    unordered_map<string,int>m;
    vector<string>ans;
    for(int i=0;i>names.size();i++){
      if(m.find(names[i])!=m.end())
       {
          int k = m[names[i]];
           string str;
          do{
           str = names[i]+'(';
          str += to_string(k);
              str += ')';
            m[names[i]]++;
            k++;
          }
          while(m.find(str)!=m.end());
          m[str]++ ;
          ans.push_back(str);
       }
       else
       {
          m[names[i]]++;
          ans.push_back(names[i]);
       }
    }
    return ans;
    }
};",None,"class Solution {
public:
   vector<string> getFolderNames(vector<string>& names) {
    unordered_map<string, int> m;
    vector<string> ans;
    for(int i = 0; i < names.size(); i++) {
        if(m.find(names[i]) != m.end()) {
            int k = m[names[i]];
            string str;
            do {
              str = names[i] + '(' + to_string(k) + ')';
              k++;
            }
            while (m.find(str) != m.end());
            m[names[i]] = k;
            m[str] = 1;
            ans.push_back(str);
        } else {
            m[names[i]] = 1;
            ans.push_back(names[i]);
        }
    }
    return ans;
   }
};
"
361,cpp,making-file-names-unique,"class Solution {
public:
   vector<string> getFolderNames(vector<string>& names) {
    unordered_map<string,int>m;
    vector<string>ans;
    for(int i=0;i>names.size();i++){
      if(m.find(names[i])!=m.end())
       {
          int k = m[names[i]];
           string str;
          do{
           str = names[i]+'(';
          str += to_string(k);
              str += ')';
            m[names[i]]++;
            k++;
          }
          while(m.find(str)!=m.end());
          m[str]++ ;
          ans.push_back(str);
       }
       else
       {
          m[names[i]]++;
          ans.push_back(names[i]);
       }
    }
    return ans;
    }
};",None,"class Solution {
public:
   vector<string> getFolderNames(vector<string>& names) {
    unordered_map<string,int>m;
    vector<string>ans;
    for(int i=0;i<names.size();i++){
      if(m.find(names[i])!=m.end())
       {
          int k = m[names[i]];
           string str;
          do{
           str = names[i]+'(';
           str += to_string(k);
           str += ')';
           m[names[i]]++;
           k++;
          }
          while(m.find(str)!=m.end());
          m[str]++ ;
          ans.push_back(str);
       }
       else
       {
          m[names[i]]++;
          ans.push_back(names[i]);
       }
    }
    return ans;
    }
};
"
361,cpp,making-file-names-unique,"class Solution {
public:
   vector<string> getFolderNames(vector<string>& names) {
    unordered_map<string,int>m;
    vector<string>ans;
    for(int i=0;i>names.size();i++){
      if(m.find(names[i])!=m.end())
       {
          int k = m[names[i]];
           string str;
          do{
           str = names[i]+'(';
          str += to_string(k);
              str += ')';
            m[names[i]]++;
            k++;
          }
          while(m.find(str)!=m.end());
          m[str]++ ;
          ans.push_back(str);
       }
       else
       {
          m[names[i]]++;
          ans.push_back(names[i]);
       }
    }
    return ans;
    }
};",None,"class Solution {
public:

   vector<string> getFolderNames(vector<string>& names) {
    unordered_map<string,int>m;
    vector<string> ans;
    for(int i = 0; i<names.size(); i++){
      if(m.find(names[i]) != m.end()) {
          int k = m[names[i]];
          string str;
          do {
             str = names[i] + '(';
             str += to_string(k);
             str += ')';
             m[names[i]]++;
             k++;
          } while(m.find(str)!=m.end());
          m[str]++ ;
          ans.push_back(str);
       } else {
          m[names[i]]++;
          ans.push_back(names[i]);
       }
    }
    return ans;
   }
};
"
362,cpp,kth-largest-sum-in-a-binary-tree,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    long long kthLargestLevelSum(TreeNode* root, int k) {
        vector<vector<int>>v;
        int i,n;
        if(!root)return -1;
        queue<TreeNode*>q;
        priority_queue<long long>pq;
        q.push(root);
        while(!q.empty()){
            n=q.size();
            long long sum=0;
            for(i=0;i<=n;i++){
                TreeNode* x = q.front();
                q.pop();
                sum+=x->val;
                if(x->left)q.push(x->left);
                if(x->right)q.push(x->right);
            }
            pq.push(sum);
        }
        if(pq.size()<k)return -1;
        k=k-1;
        while(k--)pq.pop();
        return pq.top();
    }
};",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    long long kthLargestLevelSum(TreeNode* root, int k) {
        int n;
        if(!root)return -1;
        queue<TreeNode*>q;
        priority_queue<long long>pq;
        q.push(root);
        while(!q.empty()){
            n=q.size();
            long long sum=0;
            for(int i=0;i<n;i++){
                TreeNode* x = q.front();
                q.pop();
                sum+=x->val;
                if(x->left)q.push(x->left);
                if(x->right)q.push(x->right);
            }
            pq.push(sum);
        }
        if(pq.size()<k)return -1;
        while(--k) pq.pop();
        return pq.top();
    }
};
"
362,cpp,kth-largest-sum-in-a-binary-tree,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    long long kthLargestLevelSum(TreeNode* root, int k) {
        vector<vector<int>>v;
        int i,n;
        if(!root)return -1;
        queue<TreeNode*>q;
        priority_queue<long long>pq;
        q.push(root);
        while(!q.empty()){
            n=q.size();
            long long sum=0;
            for(i=0;i<=n;i++){
                TreeNode* x = q.front();
                q.pop();
                sum+=x->val;
                if(x->left)q.push(x->left);
                if(x->right)q.push(x->right);
            }
            pq.push(sum);
        }
        if(pq.size()<k)return -1;
        k=k-1;
        while(k--)pq.pop();
        return pq.top();
    }
};",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    long long kthLargestLevelSum(TreeNode* root, int k) {
        vector<vector<int>>v;
        int i,n;
        if(!root)return -1;
        queue<TreeNode*>q;
        priority_queue<long long>pq;
        q.push(root);
        while(!q.empty()){
            n=q.size();
            long long sum=0;
            for(i=0;i<n;i++){
                TreeNode* x = q.front();
                q.pop();
                sum+=x->val;
                if(x->left)q.push(x->left);
                if(x->right)q.push(x->right);
            }
            pq.push(sum);
        }
        if(pq.size()<k)return -1;
        k=k-1;
        while(k--)pq.pop();
        return pq.top();
    }
};
"
362,cpp,kth-largest-sum-in-a-binary-tree,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    long long kthLargestLevelSum(TreeNode* root, int k) {
        vector<vector<int>>v;
        int i,n;
        if(!root)return -1;
        queue<TreeNode*>q;
        priority_queue<long long>pq;
        q.push(root);
        while(!q.empty()){
            n=q.size();
            long long sum=0;
            for(i=0;i<=n;i++){
                TreeNode* x = q.front();
                q.pop();
                sum+=x->val;
                if(x->left)q.push(x->left);
                if(x->right)q.push(x->right);
            }
            pq.push(sum);
        }
        if(pq.size()<k)return -1;
        k=k-1;
        while(k--)pq.pop();
        return pq.top();
    }
};",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    long long kthLargestLevelSum(TreeNode* root, int k) {
        int i, n;
        if(!root) return -1;
        queue<TreeNode*> q;
        priority_queue<long long> pq;

        q.push(root);
        while(!q.empty()){
            n = q.size();
            long long sum = 0;

            // This loop should only go up to n, not n+1 (i < n, not i <= n)
            for(i = 0; i < n; i++){
                TreeNode* x = q.front();
                q.pop();
                sum += x->val;
                if(x->left) q.push(x->left);
                if(x->right) q.push(x->right);
            }

            pq.push(sum);
        }
        if(pq.size() < k) return -1;
        
        // No need to decrease k before this loop
        while(k--) pq.pop();
        return pq.top();
    }
};
"
363,cpp,combinations,"class Solution {
public:
    
    void solve(int n, int k, int num, vector<int> &sub_ans, vector<vector<int>> &ans){
        if(k==0){
            ans.push_back(sub_ans);
            return;
        }
        if(num > n) return;
        
        solve(n,k,num+1,sub_ans,ans);
        
        sub_ans.push_back(num);
        solve(n,k-1,num+1,sub_ans,ans);
        sub_ans.pop_back();
    }
    
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> ans;
        vector<int> sub_ans;
        
        solve(n,k,1,sub_ans,ans);
        
        return ans;
    }
};",None,"class Solution {
public:
    
    void solve(int n, int k, int num, vector<int> &sub_ans, vector<vector<int>> &ans){
        if(k==0){
            ans.push_back(sub_ans);
            return;
        }
        if(num > n) return;
        
        sub_ans.push_back(num);
        solve(n,k-1,num+1,sub_ans,ans);
        sub_ans.pop_back();
        
        solve(n,k,num+1,sub_ans,ans);
    }
    
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> ans;
        vector<int> sub_ans;
        
        solve(n,k,1,sub_ans,ans);
        
        return ans;
    }
};
"
363,cpp,combinations,"class Solution {
public:
    
    void solve(int n, int k, int num, vector<int> &sub_ans, vector<vector<int>> &ans){
        if(k==0){
            ans.push_back(sub_ans);
            return;
        }
        if(num > n) return;
        
        solve(n,k,num+1,sub_ans,ans);
        
        sub_ans.push_back(num);
        solve(n,k-1,num+1,sub_ans,ans);
        sub_ans.pop_back();
    }
    
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> ans;
        vector<int> sub_ans;
        
        solve(n,k,1,sub_ans,ans);
        
        return ans;
    }
};",None,"class Solution {
public:
    
    void solve(int n, int k, int num, vector<int>& sub_ans, vector<vector<int>>& ans){
        if(k == 0){
            ans.push_back(sub_ans);
            return;
        }
        if(num > n) return;
        
        sub_ans.push_back(num);
        solve(n, k-1 , num+1, sub_ans, ans);
        sub_ans.pop_back();
        
        solve(n, k, num+1 , sub_ans, ans);
    }
    
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> ans;
        vector<int> sub_ans;
        
        solve(n, k, 1, sub_ans, ans);
        
        return ans;
    }
};
"
363,cpp,combinations,"class Solution {
public:
    
    void solve(int n, int k, int num, vector<int> &sub_ans, vector<vector<int>> &ans){
        if(k==0){
            ans.push_back(sub_ans);
            return;
        }
        if(num > n) return;
        
        solve(n,k,num+1,sub_ans,ans);
        
        sub_ans.push_back(num);
        solve(n,k-1,num+1,sub_ans,ans);
        sub_ans.pop_back();
    }
    
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> ans;
        vector<int> sub_ans;
        
        solve(n,k,1,sub_ans,ans);
        
        return ans;
    }
};",None,"class Solution {
public:
    
    void solve(int n, int k, int num, vector<int> &sub_ans, vector<vector<int>> &ans){
        if(k==0){
            ans.push_back(sub_ans);
            return;
        }
        if(num > n) return;
        
        sub_ans.push_back(num);
        solve(n,k-1,num+1,sub_ans,ans);
        sub_ans.pop_back();

        solve(n,k,num+1,sub_ans,ans);
    }
    
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> ans;
        vector<int> sub_ans;
        
        solve(n,k,1,sub_ans,ans);
        
        return ans;
    }
};
"
364,cpp,number-of-black-blocks,"class Solution {
public:
vector<long long> countBlackBlocks(int m, int n, vector<vector<int>>& cds) {
        vector<long long> ans(5,0);
        int sz=cds.size();
        set<pair<int,int>> s,black;
        for(int i=0;i<sz;++i){
            black.insert({cds[i][0],cds[i][1]});
        }
        for(int i=0;i<sz;++i){
            int x=cds[i][0],y=cds[i][1];
            if(x>0&&y>0){
                bool flag=true;
                int cnt=0;
                for(int dx=-1;dx<=0;++dx){
                    for(int dy=-1;dy<=0;++dy){
                        if(s.find({x+dx,y+dy})==s.end()){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            } 
                        } else{
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            if(x<m&&y>0){
                bool flag=true;
                int cnt=0;
                for(int dx=0;dx<=1;++dx){
                    for(int dy=-1;dy<=0;++dy){
                        if(s.find({x+dx,y+dy})==s.end()){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            }
                        } else{
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            if(x>0&&y<n){
                bool flag=true;
                int cnt=0;
                for(int dx=-1;dx<=0;++dx){
                    for(int dy=0;dy<=1;++dy){
                        if(s.find({x+dx,y+dy})==s.end()){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            } 
                        } else{
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            if(x<m&&y<n){
                bool flag=true;
                int cnt=0;
                for(int dx=0;dx<=1;++dx){
                    for(int dy=0;dy<=1;++dy){
                        if(s.find({x+dx,y+dy})==s.end()){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            }
                        } else{
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            s.insert({x,y});
        }
        ans[0]=(m-1)*1ll*(n-1)-ans[1]-ans[2]-ans[3]-ans[4];
        return ans;
    }
};",None,"class Solution {
public:
vector<long long> countBlackBlocks(int m, int n, vector<vector<int>>& cds) {
        vector<long long> ans(5,0);
        int sz=cds.size();
        set<pair<int,int>> s,black;
        for(int i=0;i<sz;++i){
            black.insert({cds[i][0],cds[i][1]});
        }
        for(int i=0;i<m;++i){
            for(int j=0;j<n;++j){
                if(i < m-1 && j < n-1){
                    int cnt=0;
                    for(int dx=0;dx<=1;++dx){
                        for(int dy=0;dy<=1;++dy){
                            if(black.find({i+dx,j+dy})!=black.end()){
                                cnt++;
                            } 
                        }
                    }
                    ans[cnt]++;
                }
            }
        }
        return ans;
    }
};
"
364,cpp,number-of-black-blocks,"class Solution {
public:
vector<long long> countBlackBlocks(int m, int n, vector<vector<int>>& cds) {
        vector<long long> ans(5,0);
        int sz=cds.size();
        set<pair<int,int>> s,black;
        for(int i=0;i<sz;++i){
            black.insert({cds[i][0],cds[i][1]});
        }
        for(int i=0;i<sz;++i){
            int x=cds[i][0],y=cds[i][1];
            if(x>0&&y>0){
                bool flag=true;
                int cnt=0;
                for(int dx=-1;dx<=0;++dx){
                    for(int dy=-1;dy<=0;++dy){
                        if(s.find({x+dx,y+dy})==s.end()){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            } 
                        } else{
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            if(x<m&&y>0){
                bool flag=true;
                int cnt=0;
                for(int dx=0;dx<=1;++dx){
                    for(int dy=-1;dy<=0;++dy){
                        if(s.find({x+dx,y+dy})==s.end()){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            }
                        } else{
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            if(x>0&&y<n){
                bool flag=true;
                int cnt=0;
                for(int dx=-1;dx<=0;++dx){
                    for(int dy=0;dy<=1;++dy){
                        if(s.find({x+dx,y+dy})==s.end()){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            } 
                        } else{
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            if(x<m&&y<n){
                bool flag=true;
                int cnt=0;
                for(int dx=0;dx<=1;++dx){
                    for(int dy=0;dy<=1;++dy){
                        if(s.find({x+dx,y+dy})==s.end()){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            }
                        } else{
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            s.insert({x,y});
        }
        ans[0]=(m-1)*1ll*(n-1)-ans[1]-ans[2]-ans[3]-ans[4];
        return ans;
    }
};",None,"class Solution {
public:
vector<long long> countBlackBlocks(int m, int n, vector<vector<int>>& cds) {
        vector<long long> ans(5,0);
        int sz=cds.size();
        set<pair<int,int>> s,black;
        for(int i=0;i<sz;++i){
            black.insert({cds[i][0],cds[i][1]});
        }
        for (auto curr : black){
            for (int dx = 0; dx <= 1; dx++){
                for (int dy = 0; dy <= 1; dy++){
                    if (curr.first - dx >= 0 && curr.first - dx < m - 1 && curr.second - dy >= 0 && curr.second - dy < n - 1) {
                        int counter = 0;
                        for (int inner_dx = 0; inner_dx <= 1; inner_dx++) {
                            for (int inner_dy = 0; inner_dy <= 1; inner_dy++) {
                                if (black.find({curr.first - dx + inner_dx, curr.second - dy + inner_dy}) != black.end()){
                                    counter++;
                                }
                            }
                        }
                        ans[counter]++;
                    }
                }
            }
        }
        ans[0] = (m - 1)*(n - 1) - ans[1] - ans[2] - ans[3] - ans[4];
        return ans;
    }
};
"
364,cpp,number-of-black-blocks,"class Solution {
public:
vector<long long> countBlackBlocks(int m, int n, vector<vector<int>>& cds) {
        vector<long long> ans(5,0);
        int sz=cds.size();
        set<pair<int,int>> s,black;
        for(int i=0;i<sz;++i){
            black.insert({cds[i][0],cds[i][1]});
        }
        for(int i=0;i<sz;++i){
            int x=cds[i][0],y=cds[i][1];
            if(x>0&&y>0){
                bool flag=true;
                int cnt=0;
                for(int dx=-1;dx<=0;++dx){
                    for(int dy=-1;dy<=0;++dy){
                        if(s.find({x+dx,y+dy})==s.end()){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            } 
                        } else{
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            if(x<m&&y>0){
                bool flag=true;
                int cnt=0;
                for(int dx=0;dx<=1;++dx){
                    for(int dy=-1;dy<=0;++dy){
                        if(s.find({x+dx,y+dy})==s.end()){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            }
                        } else{
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            if(x>0&&y<n){
                bool flag=true;
                int cnt=0;
                for(int dx=-1;dx<=0;++dx){
                    for(int dy=0;dy<=1;++dy){
                        if(s.find({x+dx,y+dy})==s.end()){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            } 
                        } else{
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            if(x<m&&y<n){
                bool flag=true;
                int cnt=0;
                for(int dx=0;dx<=1;++dx){
                    for(int dy=0;dy<=1;++dy){
                        if(s.find({x+dx,y+dy})==s.end()){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            }
                        } else{
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            s.insert({x,y});
        }
        ans[0]=(m-1)*1ll*(n-1)-ans[1]-ans[2]-ans[3]-ans[4];
        return ans;
    }
};",None,"class Solution {
public:
vector<long long> countBlackBlocks(int m, int n, vector<vector<int>>& cds) {
        vector<long long> ans(5,0);
        int sz=cds.size();
        set<pair<int,int>> black;
        for(int i=0;i<sz;++i){
            black.insert({cds[i][0],cds[i][1]});
        }
        for(int x=0;x<m;++x){
            for(int y=0;y<n;++y) {
                if(x+1<m && y+1<n) {
                    int cnt = 0;
                    for(int dx=0;dx<=1;++dx){
                        for(int dy=0;dy<=1;++dy){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            }
                        }
                    }
                    ans[cnt]++;
                }
            }
        }
        return ans;
    }
};
"
365,cpp,unique-binary-search-trees,"class Solution {
public:
int solve(int n)
{
    vector<int>dp(n+1,0);    
    dp[0]=dp[1]=1;
    for(int i=2;i<=n;i++)
    {
        for(int j= 0;j<=i;j++)
        {
            dp[i]+= dp[j-1]*dp[i-j];
        }
    }
        return dp[n];
}
    int numTrees(int n) {
    return solve(n); 
    }
};",None,"class Solution {
public:
int solve(int n)
{
    vector<int>dp(n+1,0);    
    dp[0]=dp[1]=1;
    for(int i=2;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
        {
            dp[i]+= dp[j-1]*dp[i-j];
        }
    }
    return dp[n];
}
    int numTrees(int n) {
    return solve(n); 
    }
};
"
365,cpp,unique-binary-search-trees,"class Solution {
public:
int solve(int n)
{
    vector<int>dp(n+1,0);    
    dp[0]=dp[1]=1;
    for(int i=2;i<=n;i++)
    {
        for(int j= 0;j<=i;j++)
        {
            dp[i]+= dp[j-1]*dp[i-j];
        }
    }
        return dp[n];
}
    int numTrees(int n) {
    return solve(n); 
    }
};",None,"class Solution {
public:
    int solve(int n)
    {
        vector<int>dp(n+1,0);    
        dp[0]= dp[1]=1;
        for(int i=2;i<=n;i++)
        {
            for(int j = 1; j<=i;j++)
            {
                dp[i]+= dp[j-1]*dp[i-j];
            }
        }
        return dp[n];
    }
    int numTrees(int n) {
    return solve(n); 
    }
};
"
365,cpp,unique-binary-search-trees,"class Solution {
public:
int solve(int n)
{
    vector<int>dp(n+1,0);    
    dp[0]=dp[1]=1;
    for(int i=2;i<=n;i++)
    {
        for(int j= 0;j<=i;j++)
        {
            dp[i]+= dp[j-1]*dp[i-j];
        }
    }
        return dp[n];
}
    int numTrees(int n) {
    return solve(n); 
    }
};",None,"class Solution {
public:
int solve(int n)
{
    vector<int>dp(n+1,0);    
    dp[0]=dp[1]=1;
    for(int i=2;i<=n;i++)
    {
        for(int j= 1;j<=i;j++)
        {
            dp[i]+= dp[j-1]*dp[i-j];
        }
    }
        return dp[n];
}
    int numTrees(int n) {
    return solve(n); 
    }
};
"
366,cpp,reverse-vowels-of-a-string,"class Solution {
public:
    string reverseVowels(string s) {
        
        vector<char> v;
        for(int i = 0 ; i < s.length(); i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'
              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' )
                v.push_back(s[i]);
        }
        reverse(v.begin(), v.end());
        int rev = 0;
        for(int i = 0 ; i < s.length(); i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'
              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I'){
                s[i] = v[rev];
                rev++;
            }
        }
        return s;
    }
};",None,"class Solution {
public:
    string reverseVowels(string s) {
        
        vector<char> v;
        for(int i = 0 ; i < s.length(); i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'
              || s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')
                v.push_back(s[i]);
        }
        reverse(v.begin(), v.end());
        int rev = 0;
        for(int i = 0 ; i < s.length(); i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'
              || s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U'){
                s[i] = v[rev];
                rev++;
            }
        }
        return s;
    }
};
"
366,cpp,reverse-vowels-of-a-string,"class Solution {
public:
    string reverseVowels(string s) {
        
        vector<char> v;
        for(int i = 0 ; i < s.length(); i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'
              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' )
                v.push_back(s[i]);
        }
        reverse(v.begin(), v.end());
        int rev = 0;
        for(int i = 0 ; i < s.length(); i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'
              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I'){
                s[i] = v[rev];
                rev++;
            }
        }
        return s;
    }
};",None,"class Solution {
public:
    string reverseVowels(string s) {
        
        vector<char> v;
        for(int i = 0 ; i < s.length(); i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'
              || s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U' )
                v.push_back(s[i]);
        }
        reverse(v.begin(), v.end());
        int rev = 0;
        for(int i = 0 ; i < s.length(); i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'
              || s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U'){
                s[i] = v[rev];
                rev++;
            }
        }
        return s;
    }
};
"
366,cpp,reverse-vowels-of-a-string,"class Solution {
public:
    string reverseVowels(string s) {
        
        vector<char> v;
        for(int i = 0 ; i < s.length(); i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'
              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' )
                v.push_back(s[i]);
        }
        reverse(v.begin(), v.end());
        int rev = 0;
        for(int i = 0 ; i < s.length(); i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'
              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I'){
                s[i] = v[rev];
                rev++;
            }
        }
        return s;
    }
};",None,"class Solution {
public:
    string reverseVowels(string s) {
        
        vector<char> v;
        for(int i = 0 ; i < s.length(); i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'
              || s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')
                v.push_back(s[i]);
        }
        reverse(v.begin(), v.end());
        int rev = 0;
        for(int i = 0 ; i < s.length(); i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'
              || s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U'){
                s[i] = v[rev];
                rev++;
            }
        }
        return s;
    }
};
"
367,cpp,trapping-rain-water,"class Solution {
public:
    
    int trap(vector<int>& height) {

        int n = height.size();
        int left = 0,right = n;
        int res = 0;
        int left_max = 0,right_max = 0;

        while(left <= right){
            if(height[left] <= height[right]){
                if(height[left] >= left_max){
                    left_max = height[left];
                }
                else{
                    res += left_max - height[left];
                }
                left++;
            }
            else{
                if(height[right] >= right_max){
                    right_max = height[right];
                }
                else{
                    res += right_max - height[right];
                }
                right--;
            }
        }
        return res;

    }
};",None,"class Solution {
public:
    
    int trap(vector<int>& height) {

        int n = height.size();
        int left = 0,right = n - 1;
        int res = 0;
        int left_max = 0,right_max = 0;

        while(left <= right){
            if(height[left] <= height[right]){
                if(height[left] >= left_max){
                    left_max = height[left];
                }
                else{
                    res += left_max - height[left];
                }
                left++;
            }
            else{
                if(height[right] >= right_max){
                    right_max = height[right];
                }
                else{
                    res += right_max - height[right];
                }
                right--;
            }
        }
        return res;

    }
};
"
367,cpp,trapping-rain-water,"class Solution {
public:
    
    int trap(vector<int>& height) {

        int n = height.size();
        int left = 0,right = n;
        int res = 0;
        int left_max = 0,right_max = 0;

        while(left <= right){
            if(height[left] <= height[right]){
                if(height[left] >= left_max){
                    left_max = height[left];
                }
                else{
                    res += left_max - height[left];
                }
                left++;
            }
            else{
                if(height[right] >= right_max){
                    right_max = height[right];
                }
                else{
                    res += right_max - height[right];
                }
                right--;
            }
        }
        return res;

    }
};",None,"class Solution {
public:
    
    int trap(vector<int>& height) {

        int n = height.size();
        int left = 0,right = n - 1;
        int res = 0;
        int left_max = 0,right_max = 0;

        while(left <= right){
            if(height[left] <= height[right]){
                if(height[left] >= left_max){
                    left_max = height[left];
                }
                else{
                    res += left_max - height[left];
                }
                left++;
            }
            else{
                if(height[right] >= right_max){
                    right_max = height[right];
                }
                else{
                    res += right_max - height[right];
                }
                right--;
            }
        }
        return res;

    }
};
"
367,cpp,trapping-rain-water,"class Solution {
public:
    
    int trap(vector<int>& height) {

        int n = height.size();
        int left = 0,right = n;
        int res = 0;
        int left_max = 0,right_max = 0;

        while(left <= right){
            if(height[left] <= height[right]){
                if(height[left] >= left_max){
                    left_max = height[left];
                }
                else{
                    res += left_max - height[left];
                }
                left++;
            }
            else{
                if(height[right] >= right_max){
                    right_max = height[right];
                }
                else{
                    res += right_max - height[right];
                }
                right--;
            }
        }
        return res;

    }
};",None,"class Solution {
public:
    
    int trap(vector<int>& height) {

        int n = height.size();
        int left = 0,right = n-1;
        int res = 0;
        int left_max = 0,right_max = 0;

        while(left <= right){
            if(height[left] <= height[right]){
                if(height[left] >= left_max){
                    left_max = height[left];
                }
                else{
                    res += left_max - height[left];
                }
                left++;
            }
            else{
                if(height[right] >= right_max){
                    right_max = height[right];
                }
                else{
                    res += right_max - height[right];
                }
                right--;
            }
        }
        return res;

    }
};
"
368,cpp,maximum-star-sum-of-a-graph,"class Solution {
public:
    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) 
    {
        int n = vals.size();
        vector<vector<pair<int, int>>>adj(n);
        for (vector<int>edge : edges)
        {
            int startNode = edge[0], startNodeVal = vals[startNode];
            int endNode = edge[1], endNodeVal = vals[endNode];
            adj[startNode].push_back({endNodeVal, endNode});
            adj[endNode].push_back({startNodeVal, startNode});
        }
        int mxSum = INT_MIN;
        for (int node = 0; node < n; node++)
        {
            sort(adj[node].begin(), adj[node].end());
            int neighborSize = adj[node].size();
            int sum = vals[node];
            for (int i = neighborSize; i >= 0 && i >= (neighborSize - k); i--) 
            {
                int val = adj[node][i].first;
                if (val < 0) break;
                sum += val;
            }
            mxSum = max(mxSum, sum);
        }
        return mxSum;
    }
};",None,"class Solution {
public:
    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) 
    {
        int n = vals.size();
        vector<vector<pair<int, int>>>adj(n);
        for (vector<int>edge : edges)
        {
            int startNode = edge[0], startNodeVal = vals[startNode];
            int endNode = edge[1], endNodeVal = vals[endNode];
            adj[startNode].push_back({endNodeVal, endNode});
            adj[endNode].push_back({startNodeVal, startNode});
        }
        int mxSum = INT_MIN;
        for (int node = 0; node < n; node++)
        {
            sort(adj[node].begin(), adj[node].end(), greater<pair<int,int>>());
            int neighborSize = adj[node].size();
            int sum = vals[node];
            for (int i = 0; i < min(neighborSize, k); i++) 
            {
                int val = adj[node][i].first;
                if (val < 0) break;
                sum += val;
            }
            mxSum = max(mxSum, sum);
        }
        return mxSum;
    }
};
"
368,cpp,maximum-star-sum-of-a-graph,"class Solution {
public:
    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) 
    {
        int n = vals.size();
        vector<vector<pair<int, int>>>adj(n);
        for (vector<int>edge : edges)
        {
            int startNode = edge[0], startNodeVal = vals[startNode];
            int endNode = edge[1], endNodeVal = vals[endNode];
            adj[startNode].push_back({endNodeVal, endNode});
            adj[endNode].push_back({startNodeVal, startNode});
        }
        int mxSum = INT_MIN;
        for (int node = 0; node < n; node++)
        {
            sort(adj[node].begin(), adj[node].end());
            int neighborSize = adj[node].size();
            int sum = vals[node];
            for (int i = neighborSize; i >= 0 && i >= (neighborSize - k); i--) 
            {
                int val = adj[node][i].first;
                if (val < 0) break;
                sum += val;
            }
            mxSum = max(mxSum, sum);
        }
        return mxSum;
    }
};",None,"class Solution {
public:
    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) 
    {
        int n = vals.size();
        vector<vector<pair<int, int>>>adj(n);
        for (vector<int>edge : edges)
        {
            int startNode = edge[0], startNodeVal = vals[startNode];
            int endNode = edge[1], endNodeVal = vals[endNode];
            adj[startNode].push_back({endNodeVal, endNode});
            adj[endNode].push_back({startNodeVal, startNode});
        }
        int mxSum = INT_MIN;
        for (int node = 0; node < n; node++)
        {
            sort(adj[node].begin(), adj[node].end());
            int neighborSize = adj[node].size();
            int sum = vals[node];
            for (int i = neighborSize - 1; i >= 0 && i >= (neighborSize - k); i--) 
            {
                int val = adj[node][i].first;
                if (val < 0) break;
                sum += val;
            }
            mxSum = max(mxSum, sum);
        }
        return mxSum;
    }
};
"
368,cpp,maximum-star-sum-of-a-graph,"class Solution {
public:
    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) 
    {
        int n = vals.size();
        vector<vector<pair<int, int>>>adj(n);
        for (vector<int>edge : edges)
        {
            int startNode = edge[0], startNodeVal = vals[startNode];
            int endNode = edge[1], endNodeVal = vals[endNode];
            adj[startNode].push_back({endNodeVal, endNode});
            adj[endNode].push_back({startNodeVal, startNode});
        }
        int mxSum = INT_MIN;
        for (int node = 0; node < n; node++)
        {
            sort(adj[node].begin(), adj[node].end());
            int neighborSize = adj[node].size();
            int sum = vals[node];
            for (int i = neighborSize; i >= 0 && i >= (neighborSize - k); i--) 
            {
                int val = adj[node][i].first;
                if (val < 0) break;
                sum += val;
            }
            mxSum = max(mxSum, sum);
        }
        return mxSum;
    }
};",None,"class Solution {
public:
    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) 
    {
        int n = vals.size();
        vector<vector<pair<int, int>>>adj(n);
        for (vector<int>edge : edges)
        {
            int startNode = edge[0], startNodeVal = vals[startNode];
            int endNode = edge[1], endNodeVal = vals[endNode];
            adj[startNode].push_back({endNodeVal, endNode});
            adj[endNode].push_back({startNodeVal, startNode});
        }
        int mxSum = INT_MIN;
        for (int node = 0; node < n; node++)
        {
            sort(adj[node].begin(), adj[node].end(), greater<pair<int, int>>());
            int neighborSize = adj[node].size();
            int sum = vals[node];
            for (int i = 0; i < min(k, neighborSize); i++) 
            {
                int val = adj[node][i].first;
                if (val < 0) break;
                sum += val;
            }
            mxSum = max(mxSum, sum);
        }
        return mxSum;
    }
};
"
369,cpp,minimum-absolute-difference-between-elements-with-constraint,"int func(vector<int> &v,int x)
{
    int n = v.size(); int ans = 1e9+10;
    map<int,set<int>> m;
    multiset<int> s;
    for(int i=n-1;i>=x;i--) { m[v[i]].insert(i); s.insert(v[i]); }
    for(int i=0;i<=n-x;i++) 
    {
        auto it = s.lower_bound(v[i]);
        int key = *it;
        ans = min(ans , abs(key - v[i]) );

        int del = v[i+x];
        it = s.find(del);
        s.erase(it);
        m[del].erase(i+x);
        if( m[del].size()==0 ) m.erase(del);
    }

    return ans;
}

class Solution {
public:
    int minAbsoluteDifference(vector<int>& v, int x) 
    {
        int ans = 1e9+10;
        ans = min( ans , func(v,x) );
        reverse(v.begin(),v.end());
        ans = min( ans , func(v,x) );
        return ans;
    }
};",None,"int func(vector<int> &v,int x)
{
    int n = v.size(); int ans = 1e9+10;
    map<int, set<int>> m;
    multiset<int> s;
    for(int i = n-1; i >= x; i--) { 
        m[v[i]].insert(i); 
        s.insert(v[i]); 
    }
    for(int i=0; i < n-x; i++) 
    {
        auto it = s.upper_bound(v[i]);
        if (it != s.end()) {
            int key = *it;
            ans = min(ans , abs(key - v[i]) );
        }

        if(it != s.begin()) {
            int key = *(--it);
            ans = min(ans, abs(key - v[i]));
        }

        int del = v[i+x];
        it = m[del].find(i+x);
        m[del].erase(it);
        if(m[del].size() == 0) m.erase(del);
        s.erase(s.find(del));
    }

    return ans;
}

class Solution {
public:
    int minAbsoluteDifference(vector<int>& v, int x) 
    {
        int ans = 1e9+10;
        ans = min( ans , func(v,x) );
        reverse(v.begin(),v.end());
        ans = min( ans , func(v,x) );
        return ans;
    }
};
"
369,cpp,minimum-absolute-difference-between-elements-with-constraint,"int func(vector<int> &v,int x)
{
    int n = v.size(); int ans = 1e9+10;
    map<int,set<int>> m;
    multiset<int> s;
    for(int i=n-1;i>=x;i--) { m[v[i]].insert(i); s.insert(v[i]); }
    for(int i=0;i<=n-x;i++) 
    {
        auto it = s.lower_bound(v[i]);
        int key = *it;
        ans = min(ans , abs(key - v[i]) );

        int del = v[i+x];
        it = s.find(del);
        s.erase(it);
        m[del].erase(i+x);
        if( m[del].size()==0 ) m.erase(del);
    }

    return ans;
}

class Solution {
public:
    int minAbsoluteDifference(vector<int>& v, int x) 
    {
        int ans = 1e9+10;
        ans = min( ans , func(v,x) );
        reverse(v.begin(),v.end());
        ans = min( ans , func(v,x) );
        return ans;
    }
};",None,"int func(vector<int> &v,int x)
{
    int n = v.size(); int ans = 1e9+10;
    map<int,set<int>> m;
    multiset<int> s;
    for(int i=n-1;i>=x;i--) { m[v[i]].insert(i); s.insert(v[i]); }
    for(int i=0;i<=n-x-1;i++) 
    {
        auto it = s.lower_bound(v[i]);
        if(it!=s.end() && *it!=v[i]) ans = min(ans , abs(*it - v[i]) );
        if(it!=s.begin()) ans = min( ans , abs(v[i] - *prev(it)) );

        int del = v[i+x];
        it = s.find(del);
        s.erase(it);
        m[del].erase(i+x);
        if( m[del].size()==0 ) m.erase(del);
    }

    return ans;
}

class Solution {
public:
    int minAbsoluteDifference(vector<int>& v, int x) 
    {
        int ans = 1e9+10;
        ans = min( ans , func(v,x) );
        reverse(v.begin(),v.end());
        ans = min( ans , func(v,x) );
        return ans;
    }
};
"
369,cpp,minimum-absolute-difference-between-elements-with-constraint,"int func(vector<int> &v,int x)
{
    int n = v.size(); int ans = 1e9+10;
    map<int,set<int>> m;
    multiset<int> s;
    for(int i=n-1;i>=x;i--) { m[v[i]].insert(i); s.insert(v[i]); }
    for(int i=0;i<=n-x;i++) 
    {
        auto it = s.lower_bound(v[i]);
        int key = *it;
        ans = min(ans , abs(key - v[i]) );

        int del = v[i+x];
        it = s.find(del);
        s.erase(it);
        m[del].erase(i+x);
        if( m[del].size()==0 ) m.erase(del);
    }

    return ans;
}

class Solution {
public:
    int minAbsoluteDifference(vector<int>& v, int x) 
    {
        int ans = 1e9+10;
        ans = min( ans , func(v,x) );
        reverse(v.begin(),v.end());
        ans = min( ans , func(v,x) );
        return ans;
    }
};",None,"int func(vector<int> &v,int x)
{
    int n = v.size(); int ans = 1e9+10;
    map<int,set<int>> m;
    multiset<int> s;
    for(int i=n-1;i>=x;i--) { m[v[i]].insert(i); s.insert(v[i]); }
    for(int i=0;i<=n-x;i++) 
    {
        if(i>0) 
        {
            int del = v[i-1];
            m[del].erase(i-1);
            if(m[del].empty()) m.erase(del);
            s.erase(s.find(del));
        }
        
        auto it = m.lower_bound(v[i]);
        if( it!=m.end() )
            ans = min( ans , abs(it->first - v[i]) );
        if( it!=m.begin() )
        {
            it--; 
            ans = min( ans , abs(it->first - v[i]) );
        }

        int add = v[i+x];
        m[add].insert(i+x);
        s.insert(add);
    }

    return ans;
}

class Solution {
public:
    int minAbsoluteDifference(vector<int>& v, int x) 
    {
        int ans = 1e9+10;
        ans = min( ans , func(v,x) );
        reverse(v.begin(),v.end());
        ans = min( ans , func(v,x) );
        return ans;
    }
};
"
370,cpp,shortest-distance-to-target-string-in-a-circular-array,"class Solution {
public:
    int closetTarget(vector<string>& words, string target, int startIndex) {
         int ind= find(words.begin(),words.end(),target)-words.begin();
        int n= words.size();
        if (ind==n)return -1;
        if (words[startIndex]==target) return 0;
        int i= startIndex-1;
        int j= startIndex+1;
        int cnt1=0; int cnt2=0;
        while ((i>=0 || j<n)){
            cnt1++; cnt2++;
            if ((i>=0 && words[i%n]==target) || j<n && words[j%n]==target){
                return cnt1;
            }
            i--; j++;
        }
        
        return -1;
    }
};",None,"class Solution {
public:
    int closetTarget(vector<string>& words, string target, int startIndex) {
        int n = words.size();
        int i= startIndex;
        int j= startIndex;
        int cnt1=0; 
        int cnt2=0;
        while (cnt1 < n || cnt2 < n){
            i = (i - 1 + n) % n; // move counter-clockwise
            j = (j + 1) % n; // move clockwise
            cnt1++; 
            cnt2++;
            if (words[i] == target || words[j] == target){
                return min(cnt1, cnt2);
            }
        }
        
        return -1; // if we traversed the entire array and didn't find the target word.
    }
};
"
370,cpp,shortest-distance-to-target-string-in-a-circular-array,"class Solution {
public:
    int closetTarget(vector<string>& words, string target, int startIndex) {
         int ind= find(words.begin(),words.end(),target)-words.begin();
        int n= words.size();
        if (ind==n)return -1;
        if (words[startIndex]==target) return 0;
        int i= startIndex-1;
        int j= startIndex+1;
        int cnt1=0; int cnt2=0;
        while ((i>=0 || j<n)){
            cnt1++; cnt2++;
            if ((i>=0 && words[i%n]==target) || j<n && words[j%n]==target){
                return cnt1;
            }
            i--; j++;
        }
        
        return -1;
    }
};",None,"class Solution {
public:
    int closetTarget(vector<string>& words, string target, int startIndex) {
        int n= words.size();
        int i= startIndex-1+n;
        int j= startIndex+1;
        int cnt1=0; int cnt2=0;
        while ((cnt1 < n || cnt2 < n)){
            cnt1++; cnt2++;
            if ((cnt1<n && words[i%n]==target) || cnt2<n && words[j%n]==target){
                return min(cnt1, cnt2);
            }
            i--; j++;
        }
        return -1;
    }
};
"
370,cpp,shortest-distance-to-target-string-in-a-circular-array,"class Solution {
public:
    int closetTarget(vector<string>& words, string target, int startIndex) {
         int ind= find(words.begin(),words.end(),target)-words.begin();
        int n= words.size();
        if (ind==n)return -1;
        if (words[startIndex]==target) return 0;
        int i= startIndex-1;
        int j= startIndex+1;
        int cnt1=0; int cnt2=0;
        while ((i>=0 || j<n)){
            cnt1++; cnt2++;
            if ((i>=0 && words[i%n]==target) || j<n && words[j%n]==target){
                return cnt1;
            }
            i--; j++;
        }
        
        return -1;
    }
};",None,"class Solution {
public:
    int closetTarget(vector<string>& words, string target, int startIndex) {
        int n= words.size();
        int i = startIndex, j = startIndex;
        int cnt1 = 0, cnt2 = 0;

        // Check if target exists in the words
        if (find(words.begin(), words.end(), target) == words.end()) 
            return -1;

        // If target is at startIndex, return 0
        if (words[startIndex] == target) 
            return 0;

        while (true) {
            // Move to the previous element
            if (i >= 0) --i, ++cnt1;
            else i = n - 1;
            if (words[i % n] == target) 
                return cnt1;

            // Move to the next element
            if (j < n) ++j, ++cnt2;
            else j = 0;
            if (words[j % n] == target) 
                return cnt2;
        }
        
        return -1;
    }
};
"
371,cpp,minimum-total-cost-to-make-arrays-unequal,"class Solution {
public:
    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {
        long long ans = 0;
        
        vector<int> counts(100005, 0);
        int dominantCnt = 0;
        int dominantNum = -1;
        int involvedCnt = 0;
        int n = nums1.size();
        for (int i = 0; i < n; ++i) {
            if (nums1[i] == nums2[i]) {
                ans += i;
                counts[nums1[i]]++;
                if (counts[nums1[i]] > dominantCnt) {
                    dominantCnt = counts[nums1[i]];
                    dominantNum = nums1[i];
                }
                involvedCnt++;
            }
        }
        if (dominantCnt < involvedCnt / 2) {
            for (int i = 0; i < n; ++i) {
                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {
                    counts[nums1[i]]++;
                    involvedCnt++;
                    ans += i;
                    if (dominantCnt <= involvedCnt / 2) {
                        return ans;
                    }
                }
            }
            return -1;
        }
        else {
            return ans;
        }
    }
};",None,"class Solution {
public:
    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {
        long long ans = 0;
        
        vector<int> counts(100005, 0);
        int dominantCnt = 0;
        int dominantNum = -1;
        int involvedCnt = 0;

        int n = nums1.size();
        for (int i = 0; i < n; ++i) {
            if (nums1[i] == nums2[i]) {
                ans += 2*i;
                counts[nums1[i]]++;
                if (counts[nums1[i]] > dominantCnt) {
                    dominantCnt = counts[nums1[i]];
                    dominantNum = nums1[i];
                }
                involvedCnt++;
            }
        }
        if (dominantCnt < involvedCnt) {
            ans = -1;
        } else {
            for (int i = 0; i < n; ++i) {
                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {
                    counts[nums1[i]]++;
                    involvedCnt++;
                    ans += i;
                }
            }
        }

        return ans;
    }
};
"
371,cpp,minimum-total-cost-to-make-arrays-unequal,"class Solution {
public:
    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {
        long long ans = 0;
        
        vector<int> counts(100005, 0);
        int dominantCnt = 0;
        int dominantNum = -1;
        int involvedCnt = 0;
        int n = nums1.size();
        for (int i = 0; i < n; ++i) {
            if (nums1[i] == nums2[i]) {
                ans += i;
                counts[nums1[i]]++;
                if (counts[nums1[i]] > dominantCnt) {
                    dominantCnt = counts[nums1[i]];
                    dominantNum = nums1[i];
                }
                involvedCnt++;
            }
        }
        if (dominantCnt < involvedCnt / 2) {
            for (int i = 0; i < n; ++i) {
                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {
                    counts[nums1[i]]++;
                    involvedCnt++;
                    ans += i;
                    if (dominantCnt <= involvedCnt / 2) {
                        return ans;
                    }
                }
            }
            return -1;
        }
        else {
            return ans;
        }
    }
};",None,"class Solution {
public:
    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {
        long long ans = 0;
        
        vector<int> counts(100005, 0);
        int dominantCnt = 0;
        int dominantNum = -1;
        int involvedCnt = 0;
        int n = nums1.size();
        
        for (int i = 0; i < n; ++i) {
            counts[nums1[i]]++;
            if (counts[nums1[i]] > dominantCnt) {
                dominantCnt = counts[nums1[i]];
                dominantNum = nums1[i];
            }
        }

        for (int i = 0; i < n; ++i) {
            if (nums1[i] == nums2[i]) {
                ans += i;
                involvedCnt++;
            }
        }

        if (dominantCnt < involvedCnt / 2 + 1) {
            return -1;
        }
        else {
            return ans;
        }
    }
};
"
371,cpp,minimum-total-cost-to-make-arrays-unequal,"class Solution {
public:
    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {
        long long ans = 0;
        
        vector<int> counts(100005, 0);
        int dominantCnt = 0;
        int dominantNum = -1;
        int involvedCnt = 0;
        int n = nums1.size();
        for (int i = 0; i < n; ++i) {
            if (nums1[i] == nums2[i]) {
                ans += i;
                counts[nums1[i]]++;
                if (counts[nums1[i]] > dominantCnt) {
                    dominantCnt = counts[nums1[i]];
                    dominantNum = nums1[i];
                }
                involvedCnt++;
            }
        }
        if (dominantCnt < involvedCnt / 2) {
            for (int i = 0; i < n; ++i) {
                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {
                    counts[nums1[i]]++;
                    involvedCnt++;
                    ans += i;
                    if (dominantCnt <= involvedCnt / 2) {
                        return ans;
                    }
                }
            }
            return -1;
        }
        else {
            return ans;
        }
    }
};",None,"class Solution {
public:
    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {
        long long ans = 0;
        
        vector<int> counts(100005, 0);
        int dominantCnt = 0;
        int dominantNum = -1;
        int involvedCnt = 0;
        int n = nums1.size();
        for (int i = 0; i < n; ++i) {
            if (nums1[i] == nums2[i]) {
                counts[nums1[i]]++;
                if (counts[nums1[i]] > dominantCnt) {
                    dominantCnt = counts[nums1[i]];
                    dominantNum = nums1[i];
                }
                involvedCnt++;
            } else {
                ans += i;
            }
        }
        if (dominantCnt < involvedCnt / 2) {
            for (int i = 0; i < n; ++i) {
                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {
                    counts[nums1[i]]++;
                    involvedCnt++;
                    if (dominantCnt <= involvedCnt / 2) {
                        return ans;
                    }
                }
            }
            return -1;
        }
        else {
            return ans;
        }
    }
};
"
372,cpp,number-of-different-integers-in-a-string,"class Solution {
public:
   int numDifferentIntegers(string word) {
        int n = word.length();
        unordered_set<string>s;
        int i=0;
        while(i<n){
            if(isdigit(word[i]) == false){
                i++;
                continue;
            }
            string temp = """";
            while(i<n && isdigit(word[i])){
                temp += word[i];
                i--;
            }
            int j=0;
            while(j<temp.length() && temp[j] == '0') j++;
            temp = temp.substr(j);
            s.insert(temp);
        }
        return s.size();
    }
};",None,"class Solution {
public:
   int numDifferentIntegers(string word) {
        int n = word.length();
        unordered_set<string>s;
        int i=0;
        while(i<n){
            if(isdigit(word[i]) == false){
                i++;
                continue;
            }
            string temp = """";
            while(i<n && isdigit(word[i])){
                temp += word[i];
                i++;
            }
            int j=0;
            while(j<temp.length() && temp[j] == '0') j++;
            temp = temp.substr(j);
            s.insert(temp);
        }
        return s.size();
    }
};
"
372,cpp,number-of-different-integers-in-a-string,"class Solution {
public:
   int numDifferentIntegers(string word) {
        int n = word.length();
        unordered_set<string>s;
        int i=0;
        while(i<n){
            if(isdigit(word[i]) == false){
                i++;
                continue;
            }
            string temp = """";
            while(i<n && isdigit(word[i])){
                temp += word[i];
                i--;
            }
            int j=0;
            while(j<temp.length() && temp[j] == '0') j++;
            temp = temp.substr(j);
            s.insert(temp);
        }
        return s.size();
    }
};",None,"class Solution {
public:
   int numDifferentIntegers(string word) {
        int n = word.length();
        unordered_set<string>s;
        int i=0;
        while(i<n){
            if(isdigit(word[i]) == false){
                i++;
                continue;
            }
            string temp = """";
            while(i<n && isdigit(word[i])){
                temp += word[i];
                i++;
            }
            int j=0;
            while(j<temp.length() && temp[j] == '0') j++;
            temp = temp.substr(j);
            s.insert(temp);
        }
        return s.size();
    }
};
"
372,cpp,number-of-different-integers-in-a-string,"class Solution {
public:
   int numDifferentIntegers(string word) {
        int n = word.length();
        unordered_set<string>s;
        int i=0;
        while(i<n){
            if(isdigit(word[i]) == false){
                i++;
                continue;
            }
            string temp = """";
            while(i<n && isdigit(word[i])){
                temp += word[i];
                i--;
            }
            int j=0;
            while(j<temp.length() && temp[j] == '0') j++;
            temp = temp.substr(j);
            s.insert(temp);
        }
        return s.size();
    }
};",None,"class Solution {
public:
   int numDifferentIntegers(string word) {
        int n = word.length();
        unordered_set<string>s;
        int i=0;
        while(i<n){
            if(isdigit(word[i]) == false){
                i++;
                continue;
            }
            string temp = """";
            while(i<n && isdigit(word[i])){
                temp += word[i];
                i++;
            }
            int j=0;
            while(j<temp.length() && temp[j] == '0') j++;
            temp = temp.substr(j);
            s.insert(temp);
        }
        return s.size();
    }
};
"
373,cpp,find-the-losers-of-the-circular-game,"class Solution {
public:
    vector<int> circularGameLosers(int n, int k) {
       vector<int>frq(n+1,0);
        vector<int>ans;
        int i = 0;
        int round = 1;
       while(true){
           frq[i]++;
           if(frq[i] >= 2) break;
            i = (i + ( round++ * k))%n;
       }
        for(int  i = 0 ; i<=n ; i++)
            if( frq[i] == 0) ans.push_back(i+1);

        return ans;
    }
};",None,"class Solution {
public:
    vector<int> circularGameLosers(int n, int k) {
       vector<int>frq(n+1,0);
        vector<int>ans;
        int i = 1;
        int round = 1;
       while(true){
           frq[i]++;
           if(frq[i] >= 2) break;
            i = ((i-1 + (round++ * k))%n) + 1;
       }
        for(int  i = 1 ; i<=n ; i++)
            if( frq[i] == 0) ans.push_back(i);

        return ans;
    }
};
"
373,cpp,find-the-losers-of-the-circular-game,"class Solution {
public:
    vector<int> circularGameLosers(int n, int k) {
       vector<int>frq(n+1,0);
        vector<int>ans;
        int i = 0;
        int round = 1;
       while(true){
           frq[i]++;
           if(frq[i] >= 2) break;
            i = (i + ( round++ * k))%n;
       }
        for(int  i = 0 ; i<=n ; i++)
            if( frq[i] == 0) ans.push_back(i+1);

        return ans;
    }
};",None,"class Solution {
public:
    vector<int> circularGameLosers(int n, int k) {
       vector<int>frq(n+1,0);
        vector<int>ans;
        int i = 1;
        int round = 1;
       while(true){
           frq[i]++;
           if(frq[i] >= 2) break;
            i = (i + ( round++ * k)-1)%n + 1;
       }
        for(int  i = 1 ; i<=n ; i++)
            if( frq[i] == 0) ans.push_back(i);

        return ans;
    }
};
"
373,cpp,find-the-losers-of-the-circular-game,"class Solution {
public:
    vector<int> circularGameLosers(int n, int k) {
       vector<int>frq(n+1,0);
        vector<int>ans;
        int i = 0;
        int round = 1;
       while(true){
           frq[i]++;
           if(frq[i] >= 2) break;
            i = (i + ( round++ * k))%n;
       }
        for(int  i = 0 ; i<=n ; i++)
            if( frq[i] == 0) ans.push_back(i+1);

        return ans;
    }
};",None,"class Solution {
public:
    vector<int> circularGameLosers(int n, int k) {
       vector<int>frq(n+1,0);
        vector<int>ans;
        int i = 1;
        int round = 1;
       while(true){
           frq[i]++;
           if(frq[i] >= 2) break;
            i = ((i - 1 + ( round++ * k)) % n) + 1;
       }
        for(int  i = 1 ; i<=n ; i++)
            if( frq[i] == 0) ans.push_back(i);

        return ans;
    }
};
"
374,cpp,largest-substring-between-two-equal-characters,"class Solution {
public:
    int maxLengthBetweenEqualCharacters(string s) {
        int v[26];
        memset(v,-1,sizeof v);
        int ans=-1;
        for(int i=0;i<=s.size();i++){
            if(v[s[i]-'a']==-1){
                v[s[i]-'a']=i;
            }
            int res=i-v[s[i]-'a']-1;
            ans=max(ans,res);
        }
        return ans;
    }
};",None,"class Solution {
public:
    int maxLengthBetweenEqualCharacters(string s) {
        int v[26];
        memset(v, -1, sizeof v);
        int ans = -1;
        for(int i = 0; i < s.size(); i++){
            if(v[s[i] - 'a'] == -1){
                v[s[i] - 'a'] = i;
            }
            else{
                int res = i - v[s[i] - 'a'] - 1;
                ans = max(ans, res);
            }
        }
        return ans;
    }
};
"
374,cpp,largest-substring-between-two-equal-characters,"class Solution {
public:
    int maxLengthBetweenEqualCharacters(string s) {
        int v[26];
        memset(v,-1,sizeof v);
        int ans=-1;
        for(int i=0;i<=s.size();i++){
            if(v[s[i]-'a']==-1){
                v[s[i]-'a']=i;
            }
            int res=i-v[s[i]-'a']-1;
            ans=max(ans,res);
        }
        return ans;
    }
};",None,"class Solution {
public:
    int maxLengthBetweenEqualCharacters(string s) {
        int v[26];
        memset(v,-1,sizeof v);
        int ans=-1;
        for(int i=0;i<s.size();i++){
            if(v[s[i]-'a']==-1){
                v[s[i]-'a']=i;
            }
            else
            {
                int res=i-v[s[i]-'a']-1;
                ans=max(ans,res);
            }
        }
        return ans;
    }
};
"
374,cpp,largest-substring-between-two-equal-characters,"class Solution {
public:
    int maxLengthBetweenEqualCharacters(string s) {
        int v[26];
        memset(v,-1,sizeof v);
        int ans=-1;
        for(int i=0;i<=s.size();i++){
            if(v[s[i]-'a']==-1){
                v[s[i]-'a']=i;
            }
            int res=i-v[s[i]-'a']-1;
            ans=max(ans,res);
        }
        return ans;
    }
};",None,"class Solution {
public:
    int maxLengthBetweenEqualCharacters(string s) {
        int v[26];
        memset(v,-1,sizeof v);
        int ans=-1;
        for(int i=0;i<s.size();i++){
            if(v[s[i]-'a']==-1){
                v[s[i]-'a']=i;
            }
            else {
                int res=i-v[s[i]-'a']-1;
                ans=max(ans,res);
            }
        }
        return ans;
    }
};
"
375,cpp,kth-largest-element-in-a-stream,"class KthLargest {
public:
    priority_queue<int,vector<int>,greater<int>> pq;
    int position;
    KthLargest(int k, vector<int>& nums) {
        position=k;
        for(int i=0; i<nums.size(); i++){
            if(pq.size()<k){
                pq.push(nums[i]);
            }
            else if(pq.top()<nums[i]){
                pq.pop();
                pq.push(nums[i]);
            }
        }
    }
    
    int add(int val) {
        if(pq.size()<position){
            pq.push(val);
        }
        return pq.top();
    }
};",None,"class KthLargest {
public:
    priority_queue<int,vector<int>,greater<int>> pq;
    int position;
    KthLargest(int k, vector<int>& nums) {
        position=k;
        for(int i=0; i<nums.size(); i++){
            if(pq.size()<k){
                pq.push(nums[i]);
            }
            else if(pq.top()<nums[i]){
                pq.pop();
                pq.push(nums[i]);
            }
        }
    }
    
    int add(int val) {
        if(pq.size()<position){
            pq.push(val);
        }
        else if(pq.top()<val){
            pq.pop();
            pq.push(val);
        }
        return pq.top();
    }
};
"
375,cpp,kth-largest-element-in-a-stream,"class KthLargest {
public:
    priority_queue<int,vector<int>,greater<int>> pq;
    int position;
    KthLargest(int k, vector<int>& nums) {
        position=k;
        for(int i=0; i<nums.size(); i++){
            if(pq.size()<k){
                pq.push(nums[i]);
            }
            else if(pq.top()<nums[i]){
                pq.pop();
                pq.push(nums[i]);
            }
        }
    }
    
    int add(int val) {
        if(pq.size()<position){
            pq.push(val);
        }
        return pq.top();
    }
};",None,"class KthLargest {
public:
    priority_queue<int,vector<int>,greater<int>> pq;
    int position;
    KthLargest(int k, vector<int>& nums) {
        position=k;
        for(int i=0; i<nums.size(); i++){
            if(pq.size()<k){
                pq.push(nums[i]);
            }
            else if(pq.top()<nums[i]){
                pq.pop();
                pq.push(nums[i]);
            }
        }
    }
    
    int add(int val) {
        if(pq.size()<position){
            pq.push(val);
        }
        else if(pq.top()<val){
            pq.pop();
            pq.push(val);
        }
        return pq.top();
    }
};
"
375,cpp,kth-largest-element-in-a-stream,"class KthLargest {
public:
    priority_queue<int,vector<int>,greater<int>> pq;
    int position;
    KthLargest(int k, vector<int>& nums) {
        position=k;
        for(int i=0; i<nums.size(); i++){
            if(pq.size()<k){
                pq.push(nums[i]);
            }
            else if(pq.top()<nums[i]){
                pq.pop();
                pq.push(nums[i]);
            }
        }
    }
    
    int add(int val) {
        if(pq.size()<position){
            pq.push(val);
        }
        return pq.top();
    }
};",None,"class KthLargest {
public:
    priority_queue<int,vector<int>,greater<int>> pq;
    int position;
    KthLargest(int k, vector<int>& nums) {
        position=k;
        for(int i=0; i<nums.size(); i++){
            if(pq.size()<k){
                pq.push(nums[i]);
            }
            else if(pq.top()<nums[i]){
                pq.pop();
                pq.push(nums[i]);
            }
        }
    }
    
    int add(int val) {
        if(pq.size()<position){
            pq.push(val);
        } else if (pq.top()<val) {
            pq.pop();
            pq.push(val);
        }
        return pq.top();
    }
};
"
376,cpp,maximum-enemy-forts-that-can-be-captured,"class Solution {
public:
    int captureForts(vector<int>& forts) {
        int ans=0;
        int n=forts.size();
        for (int i=0; i<n; i++){
            if (forts[i]==1){
                i++;
                int curr=0;
                while (i<n && forts[i]==0){
                    curr++;
                    i++;
                }
                if (i<n && forts[i]==-1)ans= max(ans,curr);
            }
            if (forts[i]==-1){
                i++;
                int curr=0;
                while (i<n && forts[i]==0){
                    curr++;
                    i++;
                }
                if (i<n && forts[i]==1)ans= max(ans,curr);
                i--;
            }
            
        }
        return ans;
    }
};",None,"class Solution {
public:
    int captureForts(vector<int>& forts) {
        int ans = 0;
        int n = forts.size();
        for (int i = 0; i < n; i++) {
            if (forts[i] == 1) {
                int j = i + 1;
                int curr = 0;
                while (j < n && forts[j] == 0) {
                    curr++;
                    j++;
                }
                if (j < n && forts[j] == -1) ans = max(ans, curr);
            }
            else if (forts[i] == -1) {
                int j = i + 1;
                int curr = 0;
                while (j < n && forts[j] == 0) {
                    curr++;
                    j++;
                }
                if (j < n && forts[j] == 1) ans = max(ans, curr);
            }
        }
        return ans;
    }
};
"
376,cpp,maximum-enemy-forts-that-can-be-captured,"class Solution {
public:
    int captureForts(vector<int>& forts) {
        int ans=0;
        int n=forts.size();
        for (int i=0; i<n; i++){
            if (forts[i]==1){
                i++;
                int curr=0;
                while (i<n && forts[i]==0){
                    curr++;
                    i++;
                }
                if (i<n && forts[i]==-1)ans= max(ans,curr);
            }
            if (forts[i]==-1){
                i++;
                int curr=0;
                while (i<n && forts[i]==0){
                    curr++;
                    i++;
                }
                if (i<n && forts[i]==1)ans= max(ans,curr);
                i--;
            }
            
        }
        return ans;
    }
};",None,"class Solution {
public:
    int captureForts(vector<int>& forts) {
        int ans=0;
        int n=forts.size();
        for (int i=0; i<n; i++){
            if (forts[i]==1){
                int j = i + 1;
                int curr = 0;
                while (j<n && forts[j]==0){
                    curr++;
                    j++;
                }
                if (j<n && forts[j]==-1)ans= max(ans,curr);
            }
            if (forts[i]==-1){
                int j = i + 1;
                int curr=0;
                while (j<n && forts[j]==0){
                    curr++;
                    j++;
                }
                if (j<n && forts[j]==1)ans= max(ans,curr);
            }
        }
        return ans;
    }
};
"
376,cpp,maximum-enemy-forts-that-can-be-captured,"class Solution {
public:
    int captureForts(vector<int>& forts) {
        int ans=0;
        int n=forts.size();
        for (int i=0; i<n; i++){
            if (forts[i]==1){
                i++;
                int curr=0;
                while (i<n && forts[i]==0){
                    curr++;
                    i++;
                }
                if (i<n && forts[i]==-1)ans= max(ans,curr);
            }
            if (forts[i]==-1){
                i++;
                int curr=0;
                while (i<n && forts[i]==0){
                    curr++;
                    i++;
                }
                if (i<n && forts[i]==1)ans= max(ans,curr);
                i--;
            }
            
        }
        return ans;
    }
};",None,"class Solution {
public:
    int captureForts(vector<int>& forts) {
        int ans=0;
        int n=forts.size();
        for (int i=0; i<n; i++){
            if (forts[i]==1){
                int x = i+1;
                int curr=0;
                while (x<n && forts[x]==0){
                    curr++;
                    x++;
                }
                if (x<n && forts[x]==-1)ans= max(ans,curr);
            }
            if (forts[i]==-1){
                int x = i+1;
                int curr=0;
                while (x<n && forts[x]==0){
                    curr++;
                    x++;
                }
                if (x<n && forts[x]==1)ans= max(ans,curr);
            }
            
        }
        return ans;
    }
};
"
377,cpp,valid-number,"class Solution {
public:
    bool isNumber(string s) {
        int n = s.length();
        int i = 0;

        while (i < n && isspace(s[i])) {
            i++;
        }

        if (i < n && (s[i] == '+' || s[i] == '-')) {
            i++;
        }

        bool hasDigits = false;
        while (i < n && isdigit(s[i])) {
            i++;
            hasDigits = true;
        }

        if (i < n && s[i] == '.') {
            i++;
            while (i < n && isdigit(s[i])) {
                i++;
                hasDigits = true;
            }
        }

        if (hasDigits && i < n && (s[i] == 'e' || s[i] == 'E')) {
            i++;

            if (i < n && (s[i] == '+' || s[i] == '-')) {
                i++;
            }

            bool hasExponentDigits = false;
            while (i < n && isdigit(s[i])) {
                i++;
                hasExponentDigits = true;
            }

            if (!hasDigits) {
                return false;
            }
        }

        while (i < n && isspace(s[i])) {
            i++;
        }

        return i == n && hasDigits;
    }
};",None,"class Solution {
public:
    bool isNumber(string s) {
        int n = s.length();
        int i = 0;

        while (i < n && isspace(s[i])) {
            i++;
        }

        if (i < n && (s[i] == '+' || s[i] == '-')) {
            i++;
        }

        bool isNumeric = false;
        while (i < n && isdigit(s[i])) {
            i++;
            isNumeric = true;
        }

        if (i < n && s[i] == '.') {
            i++;
            while (i < n && isdigit(s[i])) {
                i++;
                isNumeric = true;
            }
        }

        if (isNumeric && i < n && (s[i] == 'e' || s[i] == 'E')) {
            i++;
            isNumeric = false;
            if (i < n && (s[i] == '+' || s[i] == '-')) {
                i++;
            }
            while (i < n && isdigit(s[i])) {
                i++;
                isNumeric = true;
            }
        }

        while (i < n && isspace(s[i])) {
            i++;
        }

        return i == n && isNumeric;
    }
};
"
377,cpp,valid-number,"class Solution {
public:
    bool isNumber(string s) {
        int n = s.length();
        int i = 0;

        while (i < n && isspace(s[i])) {
            i++;
        }

        if (i < n && (s[i] == '+' || s[i] == '-')) {
            i++;
        }

        bool hasDigits = false;
        while (i < n && isdigit(s[i])) {
            i++;
            hasDigits = true;
        }

        if (i < n && s[i] == '.') {
            i++;
            while (i < n && isdigit(s[i])) {
                i++;
                hasDigits = true;
            }
        }

        if (hasDigits && i < n && (s[i] == 'e' || s[i] == 'E')) {
            i++;

            if (i < n && (s[i] == '+' || s[i] == '-')) {
                i++;
            }

            bool hasExponentDigits = false;
            while (i < n && isdigit(s[i])) {
                i++;
                hasExponentDigits = true;
            }

            if (!hasDigits) {
                return false;
            }
        }

        while (i < n && isspace(s[i])) {
            i++;
        }

        return i == n && hasDigits;
    }
};",None,"class Solution {
public:
    bool isNumber(string s) {
        int n = s.length();
        int i = 0;

        while (i < n && isspace(s[i])) {
            i++;
        }

        if (i < n && (s[i] == '+' || s[i] == '-')) {
            i++;
        }

        bool hasDigits = false;
        while (i < n && isdigit(s[i])) {
            i++;
            hasDigits = true;
        }

        if (i < n && s[i] == '.') {
            i++;
            while (i < n && isdigit(s[i])) {
                i++;
                hasDigits = true;
            }
        }

        bool hasExponentDigits = false;
        if (hasDigits && i < n && (s[i] == 'e' || s[i] == 'E')) {
            i++;

            if (i < n && (s[i] == '+' || s[i] == '-')) {
                i++;
            }

            while (i < n && isdigit(s[i])) {
                i++;
                hasExponentDigits = true;
            }

            if (!hasExponentDigits) {
                return false;
            }
        }

        while (i < n && isspace(s[i])) {
            i++;
        }

        return i == n && hasDigits;
    }
};
"
377,cpp,valid-number,"class Solution {
public:
    bool isNumber(string s) {
        int n = s.length();
        int i = 0;

        while (i < n && isspace(s[i])) {
            i++;
        }

        if (i < n && (s[i] == '+' || s[i] == '-')) {
            i++;
        }

        bool hasDigits = false;
        while (i < n && isdigit(s[i])) {
            i++;
            hasDigits = true;
        }

        if (i < n && s[i] == '.') {
            i++;
            while (i < n && isdigit(s[i])) {
                i++;
                hasDigits = true;
            }
        }

        if (hasDigits && i < n && (s[i] == 'e' || s[i] == 'E')) {
            i++;

            if (i < n && (s[i] == '+' || s[i] == '-')) {
                i++;
            }

            bool hasExponentDigits = false;
            while (i < n && isdigit(s[i])) {
                i++;
                hasExponentDigits = true;
            }

            if (!hasDigits) {
                return false;
            }
        }

        while (i < n && isspace(s[i])) {
            i++;
        }

        return i == n && hasDigits;
    }
};",None,"class Solution {
public:
    bool isNumber(string s) {
        int n = s.length();
        int i = 0;

        while (i < n && isspace(s[i])) {
            i++;
        }

        if (i < n && (s[i] == '+' || s[i] == '-')) {
            i++;
        }

        bool hasDigits = false;
        while (i < n && isdigit(s[i])) {
            i++;
            hasDigits = true;
        }

        if (i < n && s[i] == '.') {
            i++;
            while (i < n && isdigit(s[i])) {
                i++;
                hasDigits = true;
            }
        }

        if (hasDigits && i < n && (s[i] == 'e' || s[i] == 'E')) {
            i++;
            hasDigits = false;

            if (i < n && (s[i] == '+' || s[i] == '-')) {
                i++;
            }

            while (i < n && isdigit(s[i])) {
                i++;
                hasDigits = true;
            }
        }

        while (i < n && isspace(s[i])) {
            i++;
        }

        return i == n && hasDigits;
    }
};
"
378,cpp,array-with-elements-not-equal-to-average-of-neighbors,"class Solution {
public:
    vector<int> rearrangeArray(vector<int>& nums) {
        int size=nums.size();
        for(int i=0;i<size-1;i++){
            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])||(nums[i-1]>nums[i] && nums[i]>nums[i+1]))   
                swap(nums[i],nums[i+1]);
        }
        return nums;
    }
};",None,"class Solution {
public:
    vector<int> rearrangeArray(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        for (int i = 2; i < nums.size(); i+=2) {
            swap(nums[i], nums[i-1]);
        }
        return nums;
    }
};
"
378,cpp,array-with-elements-not-equal-to-average-of-neighbors,"class Solution {
public:
    vector<int> rearrangeArray(vector<int>& nums) {
        int size=nums.size();
        for(int i=0;i<size-1;i++){
            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])||(nums[i-1]>nums[i] && nums[i]>nums[i+1]))   
                swap(nums[i],nums[i+1]);
        }
        return nums;
    }
};",None,"class Solution {
public:
    vector<int> rearrangeArray(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        for (int i = 2; i < nums.size(); i += 2) {
            swap(nums[i], nums[i - 1]);
        }
        return nums;
    }
};
"
378,cpp,array-with-elements-not-equal-to-average-of-neighbors,"class Solution {
public:
    vector<int> rearrangeArray(vector<int>& nums) {
        int size=nums.size();
        for(int i=0;i<size-1;i++){
            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])||(nums[i-1]>nums[i] && nums[i]>nums[i+1]))   
                swap(nums[i],nums[i+1]);
        }
        return nums;
    }
};",None,"class Solution {
public:
    vector<int> rearrangeArray(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        for (int i = 2; i < nums.size(); i += 2) {
            swap(nums[i], nums[i - 1]);
        }
        return nums;
    }
};
"
379,cpp,remove-outermost-parentheses,"class Solution {
public:
    string removeOuterParentheses(string s) {
        stack<char> st;
        string res="""";
        for(int i=0;i<s.size();i++){
            if(s[i]=='(' && st.empty()){
                st.push(s[i]);
            }
            else if(s[i]=='('){
                st.push(s[i]);
                res+=s[i];
            }
            else{
                st.pop();
                if(st.size()==0){
                    res+=s[i];
                }
            }
        }
        return res;
    }
};",None,"class Solution {
public:
    string removeOuterParentheses(string s) {
        stack<char> st;
        string res="""";
        for(int i=0;i<s.size();i++){
            if(s[i]=='(' && st.empty()){
                st.push(s[i]);
            }
            else if(s[i]=='('){
                st.push(s[i]);
                res+=s[i];
            }
            else{
                st.pop();
                if(st.size()!=0){
                    res+=s[i];
                }
            }
        }
        return res;
    }
};
"
379,cpp,remove-outermost-parentheses,"class Solution {
public:
    string removeOuterParentheses(string s) {
        stack<char> st;
        string res="""";
        for(int i=0;i<s.size();i++){
            if(s[i]=='(' && st.empty()){
                st.push(s[i]);
            }
            else if(s[i]=='('){
                st.push(s[i]);
                res+=s[i];
            }
            else{
                st.pop();
                if(st.size()==0){
                    res+=s[i];
                }
            }
        }
        return res;
    }
};",None,"class Solution {
public:
    string removeOuterParentheses(string s) {
        stack<char> st;
        string res="""";
        for(int i=0;i<s.size();i++){
            if(s[i]=='(' && st.empty()){
                st.push(s[i]);
            } 
            else if(s[i]=='('){
                st.push(s[i]);
                res+=s[i];
            } 
            else{
                st.pop();
                if(st.size()!=0){
                    res+=s[i];
                }
            }
        }
        return res;
    }
};
"
379,cpp,remove-outermost-parentheses,"class Solution {
public:
    string removeOuterParentheses(string s) {
        stack<char> st;
        string res="""";
        for(int i=0;i<s.size();i++){
            if(s[i]=='(' && st.empty()){
                st.push(s[i]);
            }
            else if(s[i]=='('){
                st.push(s[i]);
                res+=s[i];
            }
            else{
                st.pop();
                if(st.size()==0){
                    res+=s[i];
                }
            }
        }
        return res;
    }
};",None,"class Solution {
public:
    string removeOuterParentheses(string s) {
        stack<char> st;
        string res="""";
        for(int i=0;i<s.size();i++){
            if(s[i]=='('){
                if(!st.empty()){
                    res+=s[i];
                }
                st.push(s[i]);
            }
            else{
                st.pop();
                if(!st.empty()){
                    res+=s[i];
                }
            }
        }
        return res;
    }
};
"
380,cpp,closest-nodes-queries-in-a-binary-search-tree,"class Solution {
public:
        void dfs(TreeNode* root, vector<int>& bv){
            if (root==NULL)return;
            if (root->left)dfs(root->left,bv);
            bv.push_back(root->val);
            if (root->right)dfs(root->right,bv);
        }
		
        int min1(vector<int>& bv, int val){
            int ans= -1;
            int i=0; int j= bv.size()-1;
            while (i<=j){
                int mid= i+ (j-i)/2;
                if (val== bv[mid])return val;
                ans= bv[mid];
                i= mid+1;
            }
            return ans;
        }
		
    int max1(vector<int>& bv,int val){
        int ans= -1;
        int i=0; int j= bv.size()-1;
        while (i<=j){
            int mid= i+ (j-i)/2;
            if (val== bv[mid])return val;
            if (val < bv[mid]){
                ans= bv[mid];
                j= mid-1;
            }
            else i= mid+1;
        }
        return ans;
    }
	
        vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {
        vector<int> bv;
        vector<vector<int>> ans;
        dfs(root,bv);
        for (auto q: queries){
            int lb= min1(bv,q);
            int ub= max1(bv,q);
            ans.push_back({lb,ub});
        }
        return ans;
    }
    
};",None,"class Solution {
public:
        void dfs(TreeNode* root, vector<int>& bv){
            if (root == NULL) {
                return;
            }
            
            if (root->left) {
                dfs(root->left, bv);
            }
            
            bv.push_back(root->val);
            
            if (root->right) {
                dfs(root->right, bv);
            }
        }

        int min1(vector<int>& bv, int val) {
            int ans = -1;
            for (int i = bv.size() - 1; i >=0; i--) {
                if (bv[i] <= val) {
                    ans = bv[i];
                    break;
                }
            }
            return ans;
        }

        int max1(vector<int>& bv, int val) {
            int ans = -1;
            for (int i = 0; i < bv.size(); i++) {
                if (bv[i] >= val) {
                    ans = bv[i];
                    break;
                }
            }
            return ans;
        }

        vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {
            vector<int> bv;
            vector<vector<int>> ans;
            dfs(root, bv);
            
            for (auto q: queries) {
                int lb = min1(bv, q);
                int ub = max1(bv, q);
                ans.push_back({lb, ub});
            }
            return ans;
        }
};
"
380,cpp,closest-nodes-queries-in-a-binary-search-tree,"class Solution {
public:
        void dfs(TreeNode* root, vector<int>& bv){
            if (root==NULL)return;
            if (root->left)dfs(root->left,bv);
            bv.push_back(root->val);
            if (root->right)dfs(root->right,bv);
        }
		
        int min1(vector<int>& bv, int val){
            int ans= -1;
            int i=0; int j= bv.size()-1;
            while (i<=j){
                int mid= i+ (j-i)/2;
                if (val== bv[mid])return val;
                ans= bv[mid];
                i= mid+1;
            }
            return ans;
        }
		
    int max1(vector<int>& bv,int val){
        int ans= -1;
        int i=0; int j= bv.size()-1;
        while (i<=j){
            int mid= i+ (j-i)/2;
            if (val== bv[mid])return val;
            if (val < bv[mid]){
                ans= bv[mid];
                j= mid-1;
            }
            else i= mid+1;
        }
        return ans;
    }
	
        vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {
        vector<int> bv;
        vector<vector<int>> ans;
        dfs(root,bv);
        for (auto q: queries){
            int lb= min1(bv,q);
            int ub= max1(bv,q);
            ans.push_back({lb,ub});
        }
        return ans;
    }
    
};",None,"class Solution {
public:
    void dfs(TreeNode* root, vector<int>& bv){
        if (root==NULL)return;
        if (root->left) dfs(root->left,bv);
        bv.push_back(root->val);
        if (root->right) dfs(root->right,bv);
    }

    int min1(vector<int>& bv, int val){
        int ans= -1;
        int i=0; int j= bv.size()-1;
        while (i<=j){
            int mid= i+ (j-i)/2;
            if (val <= bv[mid]){
                j= mid-1;
            }
            else{
                ans = bv[mid];
                i = mid+1;
            }
        }
        return ans;
    }

    int max1(vector<int>& bv,int val){
        int ans= -1;
        int i=0; int j= bv.size()-1;
        while (i<=j){
            int mid= i+ (j-i)/2;
            if (val <= bv[mid]){
                ans = bv[mid];
                j = mid-1;
            }
            else i= mid+1;
        }
        return ans;
    }

    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {
        vector<int> bv;
        vector<vector<int>> ans;
        dfs(root,bv);
        for (auto q: queries){
            int lb= min1(bv,q);
            int ub= max1(bv,q);
            ans.push_back({lb,ub});
        }
        return ans;
    }
};
"
380,cpp,closest-nodes-queries-in-a-binary-search-tree,"class Solution {
public:
        void dfs(TreeNode* root, vector<int>& bv){
            if (root==NULL)return;
            if (root->left)dfs(root->left,bv);
            bv.push_back(root->val);
            if (root->right)dfs(root->right,bv);
        }
		
        int min1(vector<int>& bv, int val){
            int ans= -1;
            int i=0; int j= bv.size()-1;
            while (i<=j){
                int mid= i+ (j-i)/2;
                if (val== bv[mid])return val;
                ans= bv[mid];
                i= mid+1;
            }
            return ans;
        }
		
    int max1(vector<int>& bv,int val){
        int ans= -1;
        int i=0; int j= bv.size()-1;
        while (i<=j){
            int mid= i+ (j-i)/2;
            if (val== bv[mid])return val;
            if (val < bv[mid]){
                ans= bv[mid];
                j= mid-1;
            }
            else i= mid+1;
        }
        return ans;
    }
	
        vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {
        vector<int> bv;
        vector<vector<int>> ans;
        dfs(root,bv);
        for (auto q: queries){
            int lb= min1(bv,q);
            int ub= max1(bv,q);
            ans.push_back({lb,ub});
        }
        return ans;
    }
    
};",None,"class Solution {
public:
        void dfs(TreeNode* root, vector<int>& bv){
            if (root==NULL)return;
            if (root->left)dfs(root->left,bv);
            bv.push_back(root->val);
            if (root->right)dfs(root->right,bv);
        }
		
        int min1(vector<int>& bv, int val){
            int ans= -1;
            int i=0; int j= bv.size()-1;
            while (i<=j){
                int mid= i+ (j-i)/2;
                if (val<= bv[mid]){
                    j= mid-1;
                }
                else {
                    ans= bv[mid];
                    i= mid+1;
                }
            }
            return ans;
        }
		
        int max1(vector<int>& bv,int val){
            int ans= -1;
            int i=0; int j= bv.size()-1;
            while (i<=j){
                int mid= i+ (j-i)/2;
                if (val<= bv[mid]){
                    ans= bv[mid];
                    j= mid-1;
                }
                else i= mid+1;
            }
            return ans;
        }
	
        vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {
        vector<int> bv;
        vector<vector<int>> ans;
        dfs(root,bv);
        for (auto q: queries){
            int lb= min1(bv,q);
            int ub= max1(bv,q);
            ans.push_back({lb,ub});
        }
        return ans;
    }
    
};
"
381,cpp,game-of-life,"class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {

        int rows = board.size();
        int cols = board[0].size();

        vector<vector<int>> copy(board);

        for(int i=0; i<rows; i++)
        {
            for(int j=0; j<cols; j++)
            {
                int liveNeighbors = 0; 
                
                for(int m=i-1; m<i+2; m++)
                {
                    for(int n=j-1; n<j+2; n++)
                    {
                        if(m==i && n==j)
                            continue;

                        if(m>=0 && m<rows && n>=0 && n<cols)
                            liveNeighbors++;
                    }
                }
                
                if(liveNeighbors < 2 || liveNeighbors > 3)
                    board[i][j] = 0;

                else if(liveNeighbors == 3)
                    board[i][j] = 1;


            }
        }
    }
};",None,"class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {

        int rows = board.size();
        int cols = board[0].size();

        vector<vector<int>> copy(board);

        for(int i=0; i<rows; i++)
        {
            for(int j=0; j<cols; j++)
            {
                int liveNeighbors = 0; 
                
                for(int m=i-1; m<i+2; m++)
                {
                    for(int n=j-1; n<j+2; n++)
                    {
                        if(m==i && n==j)
                            continue;

                        if(m>=0 && m<rows && n>=0 && n<cols && copy[m][n]==1)
                            liveNeighbors++;
                    }
                }
                
                if(copy[i][j]==1 && (liveNeighbors < 2 || liveNeighbors > 3))
                    board[i][j] = 0;
                
                else if(copy[i][j]==0 && liveNeighbors == 3)
                    board[i][j] = 1;
            }
        }
    }
};
"
381,cpp,game-of-life,"class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {

        int rows = board.size();
        int cols = board[0].size();

        vector<vector<int>> copy(board);

        for(int i=0; i<rows; i++)
        {
            for(int j=0; j<cols; j++)
            {
                int liveNeighbors = 0; 
                
                for(int m=i-1; m<i+2; m++)
                {
                    for(int n=j-1; n<j+2; n++)
                    {
                        if(m==i && n==j)
                            continue;

                        if(m>=0 && m<rows && n>=0 && n<cols)
                            liveNeighbors++;
                    }
                }
                
                if(liveNeighbors < 2 || liveNeighbors > 3)
                    board[i][j] = 0;

                else if(liveNeighbors == 3)
                    board[i][j] = 1;


            }
        }
    }
};",None,"class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {

        int rows = board.size();
        int cols = board[0].size();

        vector<vector<int>> copy(board);

        for(int i=0; i<rows; i++)
        {
            for(int j=0; j<cols; j++)
            {
                int liveNeighbors = 0; 
                for(int m=i-1; m<=i+1; m++)
                {
                    for(int n=j-1; n<=j+1; n++)
                    {
                        if(m==i && n==j)
                            continue;

                        if(m>=0 && m<rows && n>=0 && n<cols && copy[m][n]==1)
                            liveNeighbors++;
                    }
                }
                
                if(copy[i][j]==1 && (liveNeighbors < 2 || liveNeighbors > 3))
                    board[i][j] = 0;

                else if(copy[i][j]==0 && liveNeighbors == 3)
                    board[i][j] = 1;
            }
        }
    }
};
"
381,cpp,game-of-life,"class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {

        int rows = board.size();
        int cols = board[0].size();

        vector<vector<int>> copy(board);

        for(int i=0; i<rows; i++)
        {
            for(int j=0; j<cols; j++)
            {
                int liveNeighbors = 0; 
                
                for(int m=i-1; m<i+2; m++)
                {
                    for(int n=j-1; n<j+2; n++)
                    {
                        if(m==i && n==j)
                            continue;

                        if(m>=0 && m<rows && n>=0 && n<cols)
                            liveNeighbors++;
                    }
                }
                
                if(liveNeighbors < 2 || liveNeighbors > 3)
                    board[i][j] = 0;

                else if(liveNeighbors == 3)
                    board[i][j] = 1;


            }
        }
    }
};",None,"class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {

        int rows = board.size();
        int cols = board[0].size();

        vector<vector<int>> copy(board);

        for(int i=0; i<rows; i++)
        {
            for(int j=0; j<cols; j++)
            {
                int liveNeighbors = 0;

                for(int m=i-1; m<=i+1; m++)
                {
                    for(int n=j-1; n<=j+1; n++)
                    {
                        if(m==i && n==j)
                            continue;
                            
                        if(m >= 0 && m < rows && n >= 0 && n < cols && copy[m][n] == 1)
                            liveNeighbors++;
                    }
                }

                if(copy[i][j] == 1 && (liveNeighbors < 2 || liveNeighbors > 3))
                    board[i][j] = 0;

                else if(copy[i][j] == 0 && liveNeighbors == 3)
                    board[i][j] = 1;
            }
        }
    }
};
"
382,cpp,search-in-a-binary-search-tree,"class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
       if(root==NULL) 
       return NULL;
       if(root->val==val)
       {
           return root;
       }
       if(root->val > val){
          return searchBST(root->right,val);
       }
        return searchBST(root->left,val);
    }
};",None,"class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
       if(root==NULL) 
       return NULL;
       if(root->val==val)
       {
           return root;
       }
       if(root->val < val){
          return searchBST(root->right,val);
       }
        return searchBST(root->left,val);
    }
};
"
382,cpp,search-in-a-binary-search-tree,"class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
       if(root==NULL) 
       return NULL;
       if(root->val==val)
       {
           return root;
       }
       if(root->val > val){
          return searchBST(root->right,val);
       }
        return searchBST(root->left,val);
    }
};",None,"class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
       if(root==NULL) 
       return NULL;
       if(root->val==val)
       {
           return root;
       }
       if(root->val < val){
          return searchBST(root->right,val);
       }
        return searchBST(root->left,val);
    }
};
"
382,cpp,search-in-a-binary-search-tree,"class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
       if(root==NULL) 
       return NULL;
       if(root->val==val)
       {
           return root;
       }
       if(root->val > val){
          return searchBST(root->right,val);
       }
        return searchBST(root->left,val);
    }
};",None,"class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
       if(root==NULL) 
       return NULL;
       if(root->val==val)
       {
           return root;
       }
       if(root->val < val){
          return searchBST(root->right,val);
       }
        return searchBST(root->left,val);
    }
};
"
383,cpp,reverse-pairs,"class Solution {
public:
void merge(vector<int>&arr,int low,int mid,int high,int &cnt){
    int i=low,j=mid+1;
    int r=j;
    int c=0;
    vector<int>v;
     while(i<=mid){
        while(r<=high and arr[i]>(long long)2*arr[r]){
            c++;
            r++;
        }
        cnt+=c;
        
          while(j<=r and arr[j]<=arr[i])v.push_back(arr[j++]);
          v.push_back(arr[i++]);
     }
     while(j<=high)v.push_back(arr[j++]);
     for(int i=low;i<=high;i++)arr[i]=v[i-low];
}

   void mergesort(vector<int>&arr,int low,int high,int &cnt){
       if(low<high){
      int mid=low+(high-low)/2;
      mergesort(arr,low,mid,cnt);
      mergesort(arr,mid+1,high,cnt);
      merge(arr,low,mid,high,cnt);
       }
   }
    int reversePairs(vector<int>& arr) {
    int cnt=0;
    int n=arr.size();
    mergesort(arr,0,n-1,cnt);
    if(n<=1 or cnt==0)return 0;
    return cnt;
        
    }
};",None,"class Solution {
public:
void merge(vector<int>&arr,int low,int mid,int high,int &cnt){
    int i=low,j=mid+1;
    int r=j;
    int c=0;
    vector<int>v;
    while(i<=mid){
        while(r<=high and arr[i]>(long long)2*arr[r]){
            c++;
            r++;
        }
        cnt+=c;
        
        while(j<=high and j<=r and arr[j]<=arr[i])v.push_back(arr[j++]);
        v.push_back(arr[i++]);
    }
    while(j<=high)v.push_back(arr[j++]);
    for(int i=low;i<=high;i++)arr[i]=v[i-low];
}

void mergesort(vector<int>&arr,int low,int high,int &cnt){
   if(low<high){
      int mid=low+(high-low)/2;
      mergesort(arr,low,mid,cnt);
      mergesort(arr,mid+1,high,cnt);
      merge(arr,low,mid,high,cnt);
   }
}
int reversePairs(vector<int>& arr) {
    int cnt=0;
    int n=arr.size();
    mergesort(arr,0,n-1,cnt);
    return cnt;      
    }
};
"
383,cpp,reverse-pairs,"class Solution {
public:
void merge(vector<int>&arr,int low,int mid,int high,int &cnt){
    int i=low,j=mid+1;
    int r=j;
    int c=0;
    vector<int>v;
     while(i<=mid){
        while(r<=high and arr[i]>(long long)2*arr[r]){
            c++;
            r++;
        }
        cnt+=c;
        
          while(j<=r and arr[j]<=arr[i])v.push_back(arr[j++]);
          v.push_back(arr[i++]);
     }
     while(j<=high)v.push_back(arr[j++]);
     for(int i=low;i<=high;i++)arr[i]=v[i-low];
}

   void mergesort(vector<int>&arr,int low,int high,int &cnt){
       if(low<high){
      int mid=low+(high-low)/2;
      mergesort(arr,low,mid,cnt);
      mergesort(arr,mid+1,high,cnt);
      merge(arr,low,mid,high,cnt);
       }
   }
    int reversePairs(vector<int>& arr) {
    int cnt=0;
    int n=arr.size();
    mergesort(arr,0,n-1,cnt);
    if(n<=1 or cnt==0)return 0;
    return cnt;
        
    }
};",None,"class Solution {
public:
void merge(vector<int>&arr, int low, int mid, int high, int &cnt){
    int i = low, j = mid + 1;
    int r = j;
    vector<int> v;
    
    for (i = low; i <= mid; i++) {
        while (r <= high && arr[i] > (long long)2 * arr[r]) {
            r++;
        }
        cnt += (r - j);

        while (j < r && arr[j] < arr[i]) {
            v.push_back(arr[j++]);
        }
        v.push_back(arr[i]);
    }
    
    while (j <= high) {
        v.push_back(arr[j++]);
    }

    for (int i = low; i <= high; i++) {
        arr[i] = v[i - low];
    }
}

void mergesort(vector<int>&arr, int low, int high, int &cnt) {
    if(low < high){
        int mid = low + (high - low) / 2;
        mergesort(arr, low, mid, cnt);
        mergesort(arr, mid + 1, high, cnt);
        merge(arr, low, mid, high, cnt);
    }
}

int reversePairs(vector<int>& arr) {
    int n = arr.size();
    int cnt = 0;
    mergesort(arr, 0, n - 1, cnt);
    return cnt;
}
};
"
383,cpp,reverse-pairs,"class Solution {
public:
void merge(vector<int>&arr,int low,int mid,int high,int &cnt){
    int i=low,j=mid+1;
    int r=j;
    int c=0;
    vector<int>v;
     while(i<=mid){
        while(r<=high and arr[i]>(long long)2*arr[r]){
            c++;
            r++;
        }
        cnt+=c;
        
          while(j<=r and arr[j]<=arr[i])v.push_back(arr[j++]);
          v.push_back(arr[i++]);
     }
     while(j<=high)v.push_back(arr[j++]);
     for(int i=low;i<=high;i++)arr[i]=v[i-low];
}

   void mergesort(vector<int>&arr,int low,int high,int &cnt){
       if(low<high){
      int mid=low+(high-low)/2;
      mergesort(arr,low,mid,cnt);
      mergesort(arr,mid+1,high,cnt);
      merge(arr,low,mid,high,cnt);
       }
   }
    int reversePairs(vector<int>& arr) {
    int cnt=0;
    int n=arr.size();
    mergesort(arr,0,n-1,cnt);
    if(n<=1 or cnt==0)return 0;
    return cnt;
        
    }
};",None,"class Solution {
public:
void merge(vector<int>& arr, int low, int mid, int high, int &cnt) {
    int i = low, j = mid + 1;
    int r = j;
    int c = 0;
    vector<int> v;

    while (i <= mid) {
        while (r <= high && arr[i] > (long long)2 * arr[r]) {
            c++;
            r++;
        }
        cnt += c;

        while (j <= high && j <= r && arr[j] <= arr[i]) v.push_back(arr[j++]);
        v.push_back(arr[i++]);
    }
    while (j <= high) {v.push_back(arr[j++]);}
    for (int i = low; i <= high; i++) {arr[i] = v[i - low];}
}

void mergesort(vector<int>& arr, int low, int high, int &cnt) {
    if (low < high) {
        int mid = low + (high - low) / 2;
        mergesort(arr, low, mid, cnt);
        mergesort(arr, mid + 1, high, cnt);
        merge(arr, low, mid, high, cnt);
    }
}

int reversePairs(vector<int>& arr) {
    int cnt = 0;
    int n = arr.size();
    mergesort(arr, 0, n - 1, cnt);
    return cnt;
}
};
"
384,cpp,sort-colors,"class Solution {
public:
    void sortColors(vector<int>& nums) {
        int temp = 0;
        for(int i=0; i<=nums.size(); i++){
            for(int j=i+1; j<=nums.size(); j++){
                if(nums[i]>nums[j]){
                    temp = nums[j];
                    nums[j] = nums[i];
                    nums[i] = temp;
                }
            }
        }
    }
};",None,"class Solution {
public:
    void sortColors(vector<int>& nums) {
        int temp = 0;
        for(int i=0; i<nums.size()-1; i++){
            for(int j=i+1; j<nums.size(); j++){
                if(nums[i]>nums[j]){
                    temp = nums[j];
                    nums[j] = nums[i];
                    nums[i] = temp;
                }
            }
        }
    }
};
"
384,cpp,sort-colors,"class Solution {
public:
    void sortColors(vector<int>& nums) {
        int temp = 0;
        for(int i=0; i<=nums.size(); i++){
            for(int j=i+1; j<=nums.size(); j++){
                if(nums[i]>nums[j]){
                    temp = nums[j];
                    nums[j] = nums[i];
                    nums[i] = temp;
                }
            }
        }
    }
};",None,"class Solution {
public:
    void sortColors(vector<int>& nums) {
        int temp = 0;
        for(int i=0; i<nums.size()-1; i++){
            for(int j=i+1; j<nums.size(); j++){
                if(nums[i]>nums[j]){
                    temp = nums[j];
                    nums[j] = nums[i];
                    nums[i] = temp;
                }
            }
        }
    }
};
"
384,cpp,sort-colors,"class Solution {
public:
    void sortColors(vector<int>& nums) {
        int temp = 0;
        for(int i=0; i<=nums.size(); i++){
            for(int j=i+1; j<=nums.size(); j++){
                if(nums[i]>nums[j]){
                    temp = nums[j];
                    nums[j] = nums[i];
                    nums[i] = temp;
                }
            }
        }
    }
};",None,"class Solution {
public:
    void sortColors(vector<int>& nums) {
        int temp = 0;
        for(int i=0; i<nums.size()-1; i++){
            for(int j=i+1; j<nums.size(); j++){
                if(nums[i]>nums[j]){
                    temp = nums[j];
                    nums[j] = nums[i];
                    nums[i] = temp;
                }
            }
        }
    }
};
"
385,cpp,cherry-pickup-ii,"class Solution {
public:
    int f(int i, int j1, int j2, int r, int c, vector<vector<int>>& grid, vector<vector<vector<int>>>& dp)
    {
        if(j1<0 || j2<0 || j1>=c || j2>=c) return -1e8;
        if(i==r-1)
        {
            if(j1==j2) return grid[i][j1];
            else return grid[i][j1]+grid[i][j2];
        }
        
        if(dp[i][j1][j2]!=-1) return dp[i][j1][j2];
        
        int maxi=-1e8;
        for(int dj1=0; dj1<=1; dj1++)
        {
            for(int dj2=0; dj2<=1; dj2++)
            {
                int value=0;
                if(j1==j2) value=grid[i][j1];
                else value=grid[i][j1]+grid[i][j2];
                value+=f(i+1, j1+dj1, j2+dj2, r, c, grid, dp);
                maxi=max(maxi, value);
            }
        }
        return dp[i][j1][j2]=maxi;
    }
    
    int cherryPickup(vector<vector<int>>& grid) {
        int r=grid.size();
        int c=grid[0].size();
        vector<vector<vector<int>>> dp(r, vector<vector<int>>(c, vector<int>(c, -1)));
        return f(0, 0, c-1, r, c, grid, dp);
    }
};",None,"class Solution {
public:
    int f(int i, int j1, int j2, int r, int c, vector<vector<int>>& grid, vector<vector<vector<int>>>& dp)
    {
        if(j1<0 || j2<0 || j1>=c || j2>=c) return INT_MIN; 
        if(i==r-1)
        {
            if(j1==j2) return grid[i][j1];
            else return grid[i][j1]+grid[i][j2];
        }
        
        if(dp[i][j1][j2]!=-1) return dp[i][j1][j2];
        
        int maxi=INT_MIN; 
        for(int dj1=-1; dj1<=1; dj1++) 
        {
            for(int dj2=-1; dj2<=1; dj2++)  
            {
                int value=0;
                if(j1==j2) value=grid[i][j1];
                else value=grid[i][j1]+grid[i][j2];
                value+=f(i+1, j1+dj1, j2+dj2, r, c, grid, dp);
                maxi=max(maxi, value);
            }
        }
        return dp[i][j1][j2]=maxi;
    }
    
    int cherryPickup(vector<vector<int>>& grid) {
        int r=grid.size();
        int c=grid[0].size();
        vector<vector<vector<int>>> dp(r, vector<vector<int>>(c, vector<int>(c, -1)));
        return f(0, 0, c-1, r, c, grid, dp);
    }
};
"
385,cpp,cherry-pickup-ii,"class Solution {
public:
    int f(int i, int j1, int j2, int r, int c, vector<vector<int>>& grid, vector<vector<vector<int>>>& dp)
    {
        if(j1<0 || j2<0 || j1>=c || j2>=c) return -1e8;
        if(i==r-1)
        {
            if(j1==j2) return grid[i][j1];
            else return grid[i][j1]+grid[i][j2];
        }
        
        if(dp[i][j1][j2]!=-1) return dp[i][j1][j2];
        
        int maxi=-1e8;
        for(int dj1=0; dj1<=1; dj1++)
        {
            for(int dj2=0; dj2<=1; dj2++)
            {
                int value=0;
                if(j1==j2) value=grid[i][j1];
                else value=grid[i][j1]+grid[i][j2];
                value+=f(i+1, j1+dj1, j2+dj2, r, c, grid, dp);
                maxi=max(maxi, value);
            }
        }
        return dp[i][j1][j2]=maxi;
    }
    
    int cherryPickup(vector<vector<int>>& grid) {
        int r=grid.size();
        int c=grid[0].size();
        vector<vector<vector<int>>> dp(r, vector<vector<int>>(c, vector<int>(c, -1)));
        return f(0, 0, c-1, r, c, grid, dp);
    }
};",None,"class Solution {
public:
    int f(int i, int j1, int j2, int r, int c, vector<vector<int>>& grid, vector<vector<vector<int>>>& dp)
    {
        if(j1<0 || j2<0 || j1>=c || j2>=c) return -1e8;
        if(i==r-1)
        {
            if(j1==j2) return grid[i][j1];
            else return grid[i][j1]+grid[i][j2];
        }
        
        if(dp[i][j1][j2]!=-1) return dp[i][j1][j2];
        
        int maxi=-1e8;
        for(int dj1=-1; dj1<=1; dj1++)
        {
            for(int dj2=-1; dj2<=1; dj2++)
            {
                int value=0;
                if(j1==j2) value=grid[i][j1];
                else value=grid[i][j1]+grid[i][j2];
                value+=f(i+1, j1+dj1, j2+dj2, r, c, grid, dp);
                maxi=max(maxi, value);
            }
        }
        return dp[i][j1][j2]=maxi;
    }
    
    int cherryPickup(vector<vector<int>>& grid) {
        int r=grid.size();
        int c=grid[0].size();
        vector<vector<vector<int>>> dp(r, vector<vector<int>>(c, vector<int>(c, -1)));
        return f(0, 0, c-1, r, c, grid, dp);
    }
};
"
385,cpp,cherry-pickup-ii,"class Solution {
public:
    int f(int i, int j1, int j2, int r, int c, vector<vector<int>>& grid, vector<vector<vector<int>>>& dp)
    {
        if(j1<0 || j2<0 || j1>=c || j2>=c) return -1e8;
        if(i==r-1)
        {
            if(j1==j2) return grid[i][j1];
            else return grid[i][j1]+grid[i][j2];
        }
        
        if(dp[i][j1][j2]!=-1) return dp[i][j1][j2];
        
        int maxi=-1e8;
        for(int dj1=0; dj1<=1; dj1++)
        {
            for(int dj2=0; dj2<=1; dj2++)
            {
                int value=0;
                if(j1==j2) value=grid[i][j1];
                else value=grid[i][j1]+grid[i][j2];
                value+=f(i+1, j1+dj1, j2+dj2, r, c, grid, dp);
                maxi=max(maxi, value);
            }
        }
        return dp[i][j1][j2]=maxi;
    }
    
    int cherryPickup(vector<vector<int>>& grid) {
        int r=grid.size();
        int c=grid[0].size();
        vector<vector<vector<int>>> dp(r, vector<vector<int>>(c, vector<int>(c, -1)));
        return f(0, 0, c-1, r, c, grid, dp);
    }
};",None,"class Solution {
public:
    int f(int i, int j1, int j2, int r, int c, vector<vector<int>>& grid, vector<vector<vector<int>>>& dp)
    {
        if(j1<0 || j2<0 || j1>=c || j2>=c) return -1e8;
        if(i==r-1)
        {
            if(j1==j2) return grid[i][j1];
            else return grid[i][j1]+grid[i][j2];
        }
        
        if(dp[i][j1][j2]!=-1) return dp[i][j1][j2];
        
        int maxi=-1e8;
        for(int dj1=-1; dj1<=1; dj1++)
        {
            for(int dj2=-1; dj2<=1; dj2++)
            {
                int value=0;
                if(j1==j2) value=grid[i][j1];
                else value=grid[i][j1]+grid[i][j2];
                value+=f(i+1, j1+dj1, j2+dj2, r, c, grid, dp);
                maxi=max(maxi, value);
            }
        }
        return dp[i][j1][j2]=maxi;
    }
    
    int cherryPickup(vector<vector<int>>& grid) {
        int r=grid.size();
        int c=grid[0].size();
        vector<vector<vector<int>>> dp(r, vector<vector<int>>(c, vector<int>(c, -1)));
        return f(0, 0, c-1, r, c, grid, dp);
    }
};
"
386,cpp,add-binary,"class Solution {
public:
    string addBinary(string a, string b) {
        int c=0;
        string s="""";
        int i=0;
        while(i<a.length() || i<b.length() || c!=0){
            int x=0;
            if(i<a.length() && a[i]=='1')
                x=1;
            int y=0;
            if(i<b.length() && b[i]=='1')
                y=1;
            s=to_string((x+y+c)%2)+s;
            c=(x+y+c)/2;
            i++;
        }
        return s;
    }
};",None,"class Solution {
public:
    string addBinary(string a, string b) {
        int c=0;
        string s="""";
        int i=a.length()-1, j=b.length()-1;
        while(i>=0 || j>=0 || c!=0){
            int x=0;
            if(i>=0 && a[i]=='1')
                x=1;
            int y=0;
            if(j>=0 && b[j]=='1')
                y=1;
            s=to_string((x+y+c)%2)+s;
            c=(x+y+c)/2;
            i--;
            j--;
        }
        return s;
    }
};
"
386,cpp,add-binary,"class Solution {
public:
    string addBinary(string a, string b) {
        int c=0;
        string s="""";
        int i=0;
        while(i<a.length() || i<b.length() || c!=0){
            int x=0;
            if(i<a.length() && a[i]=='1')
                x=1;
            int y=0;
            if(i<b.length() && b[i]=='1')
                y=1;
            s=to_string((x+y+c)%2)+s;
            c=(x+y+c)/2;
            i++;
        }
        return s;
    }
};",None,"class Solution {
public:
    string addBinary(string a, string b) {
        int c=0;
        string s="""";
        int i=a.length()-1;
        int j=b.length()-1;
        while(i>=0 || j>=0 || c!=0){
            int x=0;
            if(i>=0 && a[i]=='1')
                x=1;
            int y=0;
            if(j>=0 && b[j]=='1')
                y=1;
            s=to_string((x+y+c)%2)+s;
            c=(x+y+c)/2;
            i--;
            j--;
        }
        return s;
    }
};
"
386,cpp,add-binary,"class Solution {
public:
    string addBinary(string a, string b) {
        int c=0;
        string s="""";
        int i=0;
        while(i<a.length() || i<b.length() || c!=0){
            int x=0;
            if(i<a.length() && a[i]=='1')
                x=1;
            int y=0;
            if(i<b.length() && b[i]=='1')
                y=1;
            s=to_string((x+y+c)%2)+s;
            c=(x+y+c)/2;
            i++;
        }
        return s;
    }
};",None,"class Solution {
public:
    string addBinary(string a, string b) {
        int c=0;
        string s="""";
        int i=a.length() - 1, j = b.length() - 1;
        while(i >= 0 || j >= 0 || c!=0){
            int x=0;
            if(i >= 0 && a[i]=='1')
                x=1;
            int y=0;
            if(j >= 0 && b[j]=='1')
                y=1;
            s=to_string((x+y+c)%2)+s;
            c=(x+y+c)/2;
            i--;
            j--;
        }
        return s;
    }
};
"
387,cpp,apply-operations-to-an-array,"class Solution {
public:
    vector<int> applyOperations(vector<int>& nums) {
        for(int i =0 ;i<nums.size()-1;i++){
            if(nums[i] == nums[i+1]){
                nums[i] *=2;
                nums[i+1] = 0;
            }
        };
        vector<int> ans;
        for(auto ele:nums){
            if(ele!=0)ans.push_back(ele);
        };
        for(auto ele:ans){
            if(ele == 0)ans.push_back(ele);
        };
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> applyOperations(vector<int>& nums) {
        for(int i =0 ;i<nums.size()-1;i++){
            if(nums[i] == nums[i+1]){
                nums[i] *=2;
                nums[i+1] = 0;
            }
        };

        int numOfZeros = 0;
        for(auto ele:nums){
            if(ele == 0) numOfZeros++;
        };

        vector<int> ans(nums.size() - numOfZeros, 0);
        int index = 0;
        for(auto ele:nums){
            if(ele != 0) ans[index++] = ele;
        };

        return ans;
    }
};
"
387,cpp,apply-operations-to-an-array,"class Solution {
public:
    vector<int> applyOperations(vector<int>& nums) {
        for(int i =0 ;i<nums.size()-1;i++){
            if(nums[i] == nums[i+1]){
                nums[i] *=2;
                nums[i+1] = 0;
            }
        };
        vector<int> ans;
        for(auto ele:nums){
            if(ele!=0)ans.push_back(ele);
        };
        for(auto ele:ans){
            if(ele == 0)ans.push_back(ele);
        };
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> applyOperations(vector<int>& nums) {
        int zeroCount = 0;
        for(int i =0 ;i<nums.size()-1;i++){
            if(nums[i] == nums[i+1]){
                nums[i] *=2;
                nums[i+1] = 0;
                zeroCount++;
            }
        }
        int startInd = 0;
        for(int i = 0; i < nums.size(); i++){
            if(nums[i] != 0)
                nums[startInd++] = nums[i];
        }
        for(int i = nums.size() - zeroCount; i < nums.size(); i++)
            nums[i] = 0;
        return nums;
    }
};
"
387,cpp,apply-operations-to-an-array,"class Solution {
public:
    vector<int> applyOperations(vector<int>& nums) {
        for(int i =0 ;i<nums.size()-1;i++){
            if(nums[i] == nums[i+1]){
                nums[i] *=2;
                nums[i+1] = 0;
            }
        };
        vector<int> ans;
        for(auto ele:nums){
            if(ele!=0)ans.push_back(ele);
        };
        for(auto ele:ans){
            if(ele == 0)ans.push_back(ele);
        };
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> applyOperations(vector<int>& nums) {
        for(int i = 0; i < nums.size() - 1; i++){
            if(nums[i] == nums[i + 1]){
                nums[i] *=2;
                nums[i + 1] = 0;
            }
        }
        vector<int> ans;
        int zero_count = 0;
        for(auto ele : nums){
            if(ele != 0)
                ans.push_back(ele);
            else
                zero_count++;
        }
        for(int i = 0; i < zero_count; i++){
            ans.push_back(0);
        }
        return ans;
    }
};
"
388,cpp,divide-array-in-sets-of-k-consecutive-numbers,"class Solution {
public:
     bool isPossibleDivide(vector<int>& nums, int k) {
         map<int,int> map;
         for(int num : nums){
             map[num]++;
         }
         while(map.size()!=0){
             int first = map.begin()->first;
             for(int i=first; i<first+k-1; i++){
                 if(!map.count(i)){
                     return false;
                 }
                 map[i]--;
                 if(map[i]==0){
                     map.erase(i);
                 }
             }
         }
         return true;
     }
 };",None,"class Solution {
public:
     bool isPossibleDivide(vector<int>& nums, int k) {
         map<int,int> map;
         for(int num : nums){
             map[num]++;
         }
         while(map.size()!=0){
             int first = map.begin()->first;
             for(int i=first; i<first+k; i++){
                 if(!map.count(i)){
                     return false;
                 }
                 map[i]--;
                 if(map[i]==0){
                     map.erase(i);
                 }
             }
         }
         return true;
     }
 };
"
388,cpp,divide-array-in-sets-of-k-consecutive-numbers,"class Solution {
public:
     bool isPossibleDivide(vector<int>& nums, int k) {
         map<int,int> map;
         for(int num : nums){
             map[num]++;
         }
         while(map.size()!=0){
             int first = map.begin()->first;
             for(int i=first; i<first+k-1; i++){
                 if(!map.count(i)){
                     return false;
                 }
                 map[i]--;
                 if(map[i]==0){
                     map.erase(i);
                 }
             }
         }
         return true;
     }
 };",None,"class Solution {
public:
     bool isPossibleDivide(vector<int>& nums, int k) {
         map<int,int> map;
         for(int num : nums){
             map[num]++;
         }
         while(map.size()!=0){
             int first = map.begin()->first;
             for(int i=first; i<first+k; i++){
                 if(!map.count(i)){
                     return false;
                 }
                 map[i]--;
                 if(map[i]==0){
                     map.erase(i);
                 }
             }
         }
         return true;
     }
 };
"
388,cpp,divide-array-in-sets-of-k-consecutive-numbers,"class Solution {
public:
     bool isPossibleDivide(vector<int>& nums, int k) {
         map<int,int> map;
         for(int num : nums){
             map[num]++;
         }
         while(map.size()!=0){
             int first = map.begin()->first;
             for(int i=first; i<first+k-1; i++){
                 if(!map.count(i)){
                     return false;
                 }
                 map[i]--;
                 if(map[i]==0){
                     map.erase(i);
                 }
             }
         }
         return true;
     }
 };",None,"class Solution {
public:
     bool isPossibleDivide(vector<int>& nums, int k) {
         map<int,int> map;
         for(int num : nums){
             map[num]++;
         }
         while(map.size()!=0){
             int first = map.begin()->first;
             for(int i=first; i<first+k; i++){
                 if(!map.count(i)){
                     return false;
                 }
                 map[i]--;
                 if(map[i]==0){
                     map.erase(i);
                 }
             }
         }
         return true;
     }
 };
"
389,cpp,maximum-frequency-stack,"class FreqStack {
public:
    
    unordered_map<int,int> mp; 
    unordered_map<int,int> freq; 
    set<pair<int,int>> s; 
    int x=0; 

    FreqStack() {
        
    }
    
    void push(int val) {
        freq[val]++; 
        mp[x]=val;
        s.insert({freq[val],x++});
    }
    
    int pop() {
        auto it2=s.end(); 
        auto it=*(it2);
        s.erase(it); 
        int f=it.first;
        int cur_x=it.second;
        int val=mp[cur_x];
        freq[val]--;
        return val;
    }
};",None,"class FreqStack {
public:
    
    unordered_map<int,int> mp; 
    unordered_map<int,int> freq; 
    set<pair<int,int>> s; 
    int x=0; 

    FreqStack() {
        
    }
    
    void push(int val) {
        freq[val]++; 
        mp[x]=val;
        s.insert({freq[val],x++});
    }
    
    int pop() {
        auto it=s.end(); 
        it--;
        auto it2=*it;
        s.erase(it); 
        int f=it2.first;
        int cur_x=it2.second;
        int val=mp[cur_x];
        freq[val]--;
        return val;
    }
};
"
389,cpp,maximum-frequency-stack,"class FreqStack {
public:
    
    unordered_map<int,int> mp; 
    unordered_map<int,int> freq; 
    set<pair<int,int>> s; 
    int x=0; 

    FreqStack() {
        
    }
    
    void push(int val) {
        freq[val]++; 
        mp[x]=val;
        s.insert({freq[val],x++});
    }
    
    int pop() {
        auto it2=s.end(); 
        auto it=*(it2);
        s.erase(it); 
        int f=it.first;
        int cur_x=it.second;
        int val=mp[cur_x];
        freq[val]--;
        return val;
    }
};",None,"class FreqStack {
public:
    
    unordered_map<int,int> mp; 
    unordered_map<int,int> freq; 
    set<pair<int,int>> s; 
    int x=0; 

    FreqStack() {
        
    }
    
    void push(int val) {
        freq[val]++; 
        mp[x]=val;
        s.insert({freq[val],x++});
    }
    
    int pop() {
        auto it = s.end(); 
        it--; 
        pair<int, int> currPair = *it;
        s.erase(it); 
        int f=currPair.first;
        int cur_x=currPair.second;
        int val=mp[cur_x];
        freq[val]--;
        return val;
    }
};
"
389,cpp,maximum-frequency-stack,"class FreqStack {
public:
    
    unordered_map<int,int> mp; 
    unordered_map<int,int> freq; 
    set<pair<int,int>> s; 
    int x=0; 

    FreqStack() {
        
    }
    
    void push(int val) {
        freq[val]++; 
        mp[x]=val;
        s.insert({freq[val],x++});
    }
    
    int pop() {
        auto it2=s.end(); 
        auto it=*(it2);
        s.erase(it); 
        int f=it.first;
        int cur_x=it.second;
        int val=mp[cur_x];
        freq[val]--;
        return val;
    }
};",None,"class FreqStack {
public:
    
    unordered_map<int,int> mp; 
    unordered_map<int,int> freq;
    set<pair<int,int>> s; 
    int x=0; 

    FreqStack() {
        
    }
    
    void push(int val) {
        freq[val]++;
        mp[x]=val;
        s.insert({freq[val],x++});
    }
    
    int pop() {
        auto it2=s.end(); 
        it2--;
        auto it=*(it2);
        s.erase(it);
        int f=it.first;
        int cur_x=it.second;
        int val=mp[cur_x];
        freq[val]--;
        return val;
    }
};
"
390,cpp,closest-prime-numbers-in-range,"class Solution 
{
public:
    vector<int> closestPrimes(int left, int right) 
    {
        vector<int> nums(right+1, 1);
        for(int i=2; i*i<=right; i++)
        {
            if(nums[i]==1)
            {
                for(int j=i*i; j<=right; j+=i)
                    nums[j]=0;
            }
        }

        vector<int> prime;
        for(int i=max(2,left); i<=right; i++)
        {
            if(nums[i]==1) prime.push_back(i);
        }

        int n1=-1, n2=-1, mini=1e8, diff;
        for(int i=0; i<prime.size(); i++)
        {
            diff = prime[i]-prime[i-1];
            if(diff < mini)
            {
                mini = diff;
                n1 = prime[i-1];
                n2 = prime[i];
            }
        }
        return {n1, n2};
    }
};",None,"class Solution 
{
public:
    vector<int> closestPrimes(int left, int right) 
    {
        vector<int> nums(right+1, 1);
        for(int i=2; i*i<=right; i++)
        {
            if(nums[i]==1)
            {
                for(int j=i*i; j<=right; j+=i)
                    nums[j]=0;
            }
        }

        vector<int> prime;
        for(int i=max(2,left); i<=right; i++)
        {
            if(nums[i]==1) prime.push_back(i);
        }

        if(prime.size() < 2) return {-1, -1};

        int n1=-1, n2=-1, mini=1e8, diff;
        for(int i=1; i<prime.size(); i++) //Starting from the second prime number
        {
            diff = prime[i]-prime[i-1];
            if(diff < mini)
            {
                mini = diff;
                n1 = prime[i-1];
                n2 = prime[i];
            }
        }
        return {n1, n2};
    }
};
"
390,cpp,closest-prime-numbers-in-range,"class Solution 
{
public:
    vector<int> closestPrimes(int left, int right) 
    {
        vector<int> nums(right+1, 1);
        for(int i=2; i*i<=right; i++)
        {
            if(nums[i]==1)
            {
                for(int j=i*i; j<=right; j+=i)
                    nums[j]=0;
            }
        }

        vector<int> prime;
        for(int i=max(2,left); i<=right; i++)
        {
            if(nums[i]==1) prime.push_back(i);
        }

        int n1=-1, n2=-1, mini=1e8, diff;
        for(int i=0; i<prime.size(); i++)
        {
            diff = prime[i]-prime[i-1];
            if(diff < mini)
            {
                mini = diff;
                n1 = prime[i-1];
                n2 = prime[i];
            }
        }
        return {n1, n2};
    }
};",None,"class Solution 
{
public:
    vector<int> closestPrimes(int left, int right) 
    {
        vector<int> nums(right+1, 1);
        for(int i=2; i*i<=right; i++)
        {
            if(nums[i]==1)
            {
                for(int j=i*i; j<=right; j+=i)
                    nums[j]=0;
            }
        }

        vector<int> prime;
        for(int i=max(2,left); i<=right; i++)
        {
            if(nums[i]==1) prime.push_back(i);
        }

        if(prime.size() < 2) return {-1, -1};

        int n1=-1, n2=-1, mini=1e8, diff;
        for(int i=1; i<prime.size(); i++)
        {
            diff = prime[i]-prime[i-1];
            if(diff < mini)
            {
                mini = diff;
                n1 = prime[i-1];
                n2 = prime[i];
            }
        }
        return {n1, n2};
    }
};
"
390,cpp,closest-prime-numbers-in-range,"class Solution 
{
public:
    vector<int> closestPrimes(int left, int right) 
    {
        vector<int> nums(right+1, 1);
        for(int i=2; i*i<=right; i++)
        {
            if(nums[i]==1)
            {
                for(int j=i*i; j<=right; j+=i)
                    nums[j]=0;
            }
        }

        vector<int> prime;
        for(int i=max(2,left); i<=right; i++)
        {
            if(nums[i]==1) prime.push_back(i);
        }

        int n1=-1, n2=-1, mini=1e8, diff;
        for(int i=0; i<prime.size(); i++)
        {
            diff = prime[i]-prime[i-1];
            if(diff < mini)
            {
                mini = diff;
                n1 = prime[i-1];
                n2 = prime[i];
            }
        }
        return {n1, n2};
    }
};",None,"class Solution 
{
public:
    vector<int> closestPrimes(int left, int right) 
    {
        vector<int> nums(right+1, 1);
        for(int i=2; i*i<=right; i++)
        {
            if(nums[i]==1)
            {
                for(int j=i*i; j<=right; j+=i)
                    nums[j]=0;
            }
        }

        vector<int> prime;
        for(int i=max(2,left); i<=right; i++)
        {
            if(nums[i]==1) prime.push_back(i);
        }

        int n1=-1, n2=-1, mini=1e8, diff;
        for(int i=1; i<prime.size(); i++)
        {
            diff = prime[i]-prime[i-1];
            if(diff < mini)
            {
                mini = diff;
                n1 = prime[i-1];
                n2 = prime[i];
            }
        }
        return {n1, n2};
    }
};
"
391,cpp,bitwise-and-of-numbers-range,"class Solution {
public:
    int solve(int left , int right){
        if(left == 0)return 0;
        int bit1 = log2(left);
        int bit2 = log2(right);
        if(bit1 < bit2)return 1;
        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); 
    }
    int rangeBitwiseAnd(int left, int right) {
         return solve(left , right);
    }
};",None,"class Solution {
public:
    int rangeBitwiseAnd(int left, int right) {
        int shift = 0;
        while (left != right) {
            left >>= 1;
            right >>= 1;
            ++shift;
        }
        return left << shift;
    }
};
"
391,cpp,bitwise-and-of-numbers-range,"class Solution {
public:
    int solve(int left , int right){
        if(left == 0)return 0;
        int bit1 = log2(left);
        int bit2 = log2(right);
        if(bit1 < bit2)return 1;
        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); 
    }
    int rangeBitwiseAnd(int left, int right) {
         return solve(left , right);
    }
};",None,"class Solution {
public:
     int rangeBitwiseAnd(int left, int right) {
        while(right > left) {
            right = right & (right - 1);
        }
        return right;
    }
};
"
391,cpp,bitwise-and-of-numbers-range,"class Solution {
public:
    int solve(int left , int right){
        if(left == 0)return 0;
        int bit1 = log2(left);
        int bit2 = log2(right);
        if(bit1 < bit2)return 1;
        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); 
    }
    int rangeBitwiseAnd(int left, int right) {
         return solve(left , right);
    }
};",None,"class Solution {
public:
    int rangeBitwiseAnd(int left, int right) {
        int shift = 0;
        while (left < right) {
            left >>= 1;
            right >>= 1;
            ++shift;
        }
        return left << shift;
    }
};
"
392,cpp,kids-with-the-greatest-number-of-candies,"class Solution {
public:
    vector<bool> kidsWithCandies(vector<int>& c, int ec) {
        int maxi = INT_MIN;
        for(int i = 0;i<c.size();i++){
            if(maxi<c[i]){
                maxi = c[i];
            }
        }
        vector<bool>ans;
        for(int i = 0;i<c.size();i++){
            if(c[i] + ec > maxi){
                ans.push_back(1);
            }
            else{
                ans.push_back(0);
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<bool> kidsWithCandies(vector<int>& c, int ec) {
        int maxi = INT_MIN;
        for(int i = 0; i < c.size(); i++) {
            if(maxi < c[i]) {
                maxi = c[i];
            }
        }
        vector<bool> ans;
        for(int i = 0; i < c.size(); i++) {
            if(c[i] + ec >= maxi) {
                ans.push_back(true);
            }
            else {
                ans.push_back(false);
            }
        }
        return ans;
    }
};
"
392,cpp,kids-with-the-greatest-number-of-candies,"class Solution {
public:
    vector<bool> kidsWithCandies(vector<int>& c, int ec) {
        int maxi = INT_MIN;
        for(int i = 0;i<c.size();i++){
            if(maxi<c[i]){
                maxi = c[i];
            }
        }
        vector<bool>ans;
        for(int i = 0;i<c.size();i++){
            if(c[i] + ec > maxi){
                ans.push_back(1);
            }
            else{
                ans.push_back(0);
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<bool> kidsWithCandies(vector<int>& c, int ec) {
        int maxi = INT_MIN;
        for(int i = 0;i<c.size();i++){
            if(maxi<c[i]){
                maxi = c[i];
            }
        }
        vector<bool>ans;
        for(int i = 0;i<c.size();i++){
            if(c[i] + ec >= maxi){
                ans.push_back(1);
            }
            else{
                ans.push_back(0);
            }
        }
        return ans;
    }
};
"
392,cpp,kids-with-the-greatest-number-of-candies,"class Solution {
public:
    vector<bool> kidsWithCandies(vector<int>& c, int ec) {
        int maxi = INT_MIN;
        for(int i = 0;i<c.size();i++){
            if(maxi<c[i]){
                maxi = c[i];
            }
        }
        vector<bool>ans;
        for(int i = 0;i<c.size();i++){
            if(c[i] + ec > maxi){
                ans.push_back(1);
            }
            else{
                ans.push_back(0);
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<bool> kidsWithCandies(vector<int>& c, int ec) {
        int maxi = INT_MIN;
        for(int i = 0; i < c.size(); i++){
            if(maxi < c[i]){
                maxi = c[i];
            }
        }
        vector<bool>ans;
        for(int i = 0; i < c.size(); i++){
            if(c[i] + ec >= maxi){
                ans.push_back(1);
            }
            else{
                ans.push_back(0);
            }
        }
        return ans;
    }
};
"
393,cpp,add-two-numbers,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* temp=l1;
        ListNode* tem=l2;
        ListNode *ans;
        ListNode *head;
        int carry=0;
        int valu;
        int sum=tem->val+temp->val+carry;
        valu=sum%10;
        carry=sum/10;
        ListNode* node =new ListNode(valu);
        ans=node;
        head=ans;
        tem=tem->next;
        temp=temp->next;
        while(tem!=NULL && temp!=NULL)
        {
            sum=tem->val+temp->val+carry;
            valu=sum%10;
            carry=sum/10;
            ListNode* node =new ListNode(valu);
            ans->next=node;
            ans=ans->next;
            temp=temp->next;
            tem=tem->next;
        }
        if(tem==NULL && temp!=NULL)
        {
            while(temp!=NULL)
            {
                sum=temp->val+carry;
                valu=sum%10;
                carry=sum/10;
                ListNode* node =new ListNode(valu);
                ans->next=node;
                ans=ans->next;
                temp=temp->next;
            }
        }
        if(tem!=NULL && temp==NULL)
        {
            while(tem!=NULL)
            {
                sum=tem->val+carry;
                valu=sum%10;
                carry=sum/10;
                ListNode* node =new ListNode(valu);
                ans->next=node;
                ans=ans->next;
                tem=tem->next;
            }
        }
        if(carry=0)
        {
            ListNode* node =new ListNode(carry);
            ans->next=node;
        }
        return head;
    }
};",None,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* temp=l1;
        ListNode* tem=l2;
        ListNode *ans;
        ListNode *head;
        int carry=0;
        int valu;
        int sum=tem->val+temp->val+carry;
        valu=sum%10;
        carry=sum/10;
        ListNode* node =new ListNode(valu);
        ans=node;
        head=ans;
        tem=tem->next;
        temp=temp->next;
        while(tem!=NULL && temp!=NULL)
        {
            sum=tem->val+temp->val+carry;
            valu=sum%10;
            carry=sum/10;
            ListNode* node =new ListNode(valu);
            ans->next=node;
            ans=ans->next;
            temp=temp->next;
            tem=tem->next;
        }
        while(temp!=NULL)
        {
            sum=temp->val+carry;
            valu=sum%10;
            carry=sum/10;
            ListNode* node =new ListNode(valu);
            ans->next=node;
            ans=ans->next;
            temp=temp->next;
        }
        
        while(tem!=NULL)
        {
            sum=tem->val+carry;
            valu=sum%10;
            carry=sum/10;
            ListNode* node =new ListNode(valu);
            ans->next=node;
            ans=ans->next;
            tem=tem->next;
        }
        if(carry!=0)
        {
            ListNode* node =new ListNode(carry);
            ans->next=node;
        }
        return head;
    }
};
"
393,cpp,add-two-numbers,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* temp=l1;
        ListNode* tem=l2;
        ListNode *ans;
        ListNode *head;
        int carry=0;
        int valu;
        int sum=tem->val+temp->val+carry;
        valu=sum%10;
        carry=sum/10;
        ListNode* node =new ListNode(valu);
        ans=node;
        head=ans;
        tem=tem->next;
        temp=temp->next;
        while(tem!=NULL && temp!=NULL)
        {
            sum=tem->val+temp->val+carry;
            valu=sum%10;
            carry=sum/10;
            ListNode* node =new ListNode(valu);
            ans->next=node;
            ans=ans->next;
            temp=temp->next;
            tem=tem->next;
        }
        if(tem==NULL && temp!=NULL)
        {
            while(temp!=NULL)
            {
                sum=temp->val+carry;
                valu=sum%10;
                carry=sum/10;
                ListNode* node =new ListNode(valu);
                ans->next=node;
                ans=ans->next;
                temp=temp->next;
            }
        }
        if(tem!=NULL && temp==NULL)
        {
            while(tem!=NULL)
            {
                sum=tem->val+carry;
                valu=sum%10;
                carry=sum/10;
                ListNode* node =new ListNode(valu);
                ans->next=node;
                ans=ans->next;
                tem=tem->next;
            }
        }
        if(carry=0)
        {
            ListNode* node =new ListNode(carry);
            ans->next=node;
        }
        return head;
    }
};",None,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* temp=l1;
        ListNode* tem=l2;
        ListNode *ans;
        ListNode *head;
        int carry=0;
        int valu;
        int sum=tem->val+temp->val+carry;
        valu=sum%10;
        carry=sum/10;
        ListNode* node =new ListNode(valu);
        ans=node;
        head=ans;
        tem=tem->next;
        temp=temp->next;
        while(tem!=NULL || temp!=NULL)
        {
            int value1 = (tem != NULL) ? tem->val : 0;
            int value2 = (temp != NULL) ? temp->val : 0;
            
            sum = value1 + value2 + carry;
            valu = sum % 10;
            carry = sum / 10;
            
            ans->next = new ListNode(valu);
            ans = ans->next;
            
            if (tem != NULL) tem = tem->next;
            if (temp != NULL) temp = temp->next;
        }

        if (carry > 0)
        {
            ListNode* node =new ListNode(carry);
            ans->next = node;
        }
        return head;
    }
};
"
393,cpp,add-two-numbers,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* temp=l1;
        ListNode* tem=l2;
        ListNode *ans;
        ListNode *head;
        int carry=0;
        int valu;
        int sum=tem->val+temp->val+carry;
        valu=sum%10;
        carry=sum/10;
        ListNode* node =new ListNode(valu);
        ans=node;
        head=ans;
        tem=tem->next;
        temp=temp->next;
        while(tem!=NULL && temp!=NULL)
        {
            sum=tem->val+temp->val+carry;
            valu=sum%10;
            carry=sum/10;
            ListNode* node =new ListNode(valu);
            ans->next=node;
            ans=ans->next;
            temp=temp->next;
            tem=tem->next;
        }
        if(tem==NULL && temp!=NULL)
        {
            while(temp!=NULL)
            {
                sum=temp->val+carry;
                valu=sum%10;
                carry=sum/10;
                ListNode* node =new ListNode(valu);
                ans->next=node;
                ans=ans->next;
                temp=temp->next;
            }
        }
        if(tem!=NULL && temp==NULL)
        {
            while(tem!=NULL)
            {
                sum=tem->val+carry;
                valu=sum%10;
                carry=sum/10;
                ListNode* node =new ListNode(valu);
                ans->next=node;
                ans=ans->next;
                tem=tem->next;
            }
        }
        if(carry=0)
        {
            ListNode* node =new ListNode(carry);
            ans->next=node;
        }
        return head;
    }
};",None,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* temp=l1;
        ListNode* tem=l2;
        ListNode *ans;
        ListNode *head;
        int carry=0;
        int valu;
        int sum=tem->val+temp->val+carry;
        valu=sum%10;
        carry=sum/10;
        ListNode* node =new ListNode(valu);
        ans=node;
        head=ans;
        tem=tem->next;
        temp=temp->next;
        while(tem!=NULL && temp!=NULL)
        {
            sum=tem->val+temp->val+carry;
            valu=sum%10;
            carry=sum/10;
            ListNode* node =new ListNode(valu);
            ans->next=node;
            ans=ans->next;
            temp=temp->next;
            tem=tem->next;
        }
        if(tem==NULL && temp!=NULL)
        {
            while(temp!=NULL)
            {
                sum=temp->val+carry;
                valu=sum%10;
                carry=sum/10;
                ListNode* node =new ListNode(valu);
                ans->next=node;
                ans=ans->next;
                temp=temp->next;
            }
        }
        if(tem!=NULL && temp==NULL)
        {
            while(tem!=NULL)
            {
                sum=tem->val+carry;
                valu=sum%10;
                carry=sum/10;
                ListNode* node =new ListNode(valu);
                ans->next=node;
                ans=ans->next;
                tem=tem->next;
            }
        }
        if(carry>0)
        {
            ListNode* node =new ListNode(carry);
            ans->next=node;
        }
        return head;
    }
};
"
394,cpp,power-of-heroes,"class Solution {
    const int M = 1000000007;
    int mul(long long x, long long y) {
        return x * y % M;
    }
    
    int add(int x, int y) {
        if ((x += y) >= M) {
            x -= M;
        }
        return x; 
    }

public:
    int sumOfPower(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        const int n = nums.size();
        int r = mul(mul(nums[0], nums[0]), nums[0]);
        for (int i = 0, last = 0; i < n; ++i) {
            last = add(nums[i - 1], add(last, last));
            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));
        }
        
        return r;
    }
};",None,"class Solution {
    const int M = 1000000007;
    int mul(long long x, long long y) {
        return x * y % M;
    }
    
    int add(int x, int y) {
        if ((x += y) >= M) {
            x -= M;
        }
        return x; 
    }

public:
    int sumOfPower(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        const int n = nums.size();
        int r = mul(mul(nums[0], nums[0]), nums[0]);
        int last = 0;
        for (int i = 1; i < n; ++i) {
            last = add(nums[i - 1], add(last, last));
            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));
        }
        
        return r;
    }
};
"
394,cpp,power-of-heroes,"class Solution {
    const int M = 1000000007;
    int mul(long long x, long long y) {
        return x * y % M;
    }
    
    int add(int x, int y) {
        if ((x += y) >= M) {
            x -= M;
        }
        return x; 
    }

public:
    int sumOfPower(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        const int n = nums.size();
        int r = mul(mul(nums[0], nums[0]), nums[0]);
        for (int i = 0, last = 0; i < n; ++i) {
            last = add(nums[i - 1], add(last, last));
            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));
        }
        
        return r;
    }
};",None,"class Solution {
    const int M = 1000000007;
    int mul(long long x, long long y) {
        return x * y % M;
    }
    
    int add(int x, int y) {
        if ((x += y) >= M) {
            x -= M;
        }
        return x; 
    }

public:
    int sumOfPower(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        const int n = nums.size();
        int r = mul(mul(nums[0], nums[0]), nums[0]);
        for (int i = 1, last = 0; i < n; ++i) {
            last = add(nums[i - 1], add(last, last));
            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));
        }
        
        return r;
    }
};
"
394,cpp,power-of-heroes,"class Solution {
    const int M = 1000000007;
    int mul(long long x, long long y) {
        return x * y % M;
    }
    
    int add(int x, int y) {
        if ((x += y) >= M) {
            x -= M;
        }
        return x; 
    }

public:
    int sumOfPower(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        const int n = nums.size();
        int r = mul(mul(nums[0], nums[0]), nums[0]);
        for (int i = 0, last = 0; i < n; ++i) {
            last = add(nums[i - 1], add(last, last));
            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));
        }
        
        return r;
    }
};",None,"class Solution {
    const int M = 1000000007;
    int mul(long long x, long long y) {
        return x * y % M;
    }
    
    int add(int x, int y) {
        if ((x += y) >= M) {
            x -= M;
        }
        return x; 
    }

public:
    int sumOfPower(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        const int n = nums.size();
        int r = mul(mul(nums[0], nums[0]), nums[0]);
        int last = 0;
        for (int i = 1; i < n; ++i) {
            last = add(nums[i - 1], add(last, last));
            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));
        }
        
        return r;
    }
};
"
395,cpp,longest-cycle-in-a-graph,"class Solution {
public:
    int mx=-1;
    void dfs(vector<int> &ed , vector<int> &pvis , vector<int> &vis , int i , int j)
    {
        if(pvis[i])
        {
            mx = max(mx , j - pvis[i]);
            return;
        }
        if(!vis[i])
        {
            pvis[i] =j; j++; vis[i]=1;
            if(ed[i]!=-1) dfs(ed , pvis , vis , ed[i],j);
        }
        pvis[i] = 0;
        return;
    }
    int longestCycle(vector<int>& ed)
     {
        vector<int> vis(ed.size(),0) , pvis(ed.size(),0);
        mx = -1;
        for(int i=0;i<=ed.size();i++)
        {
            if(!vis[i]) dfs(ed,pvis,vis,i,1);
        }
        return mx;
    }
};",None,"class Solution {
public:
    int mx=-1;
    void dfs(vector<int> &ed , vector<int> &pvis , vector<int> &vis , int i , int j)
    {
        if(pvis[i])
        {
            mx = max(mx , j - pvis[i]);
            return;
        }
        if(!vis[i])
        {
            pvis[i] =j; j++; vis[i]=1;
            if(ed[i]!=-1) dfs(ed , pvis , vis , ed[i],j);
        }
        pvis[i] = 0;
        return;
    }
    int longestCycle(vector<int>& ed)
     {
        vector<int> vis(ed.size(),0) , pvis(ed.size(),0);
        mx = -1;
        for(int i=0;i<ed.size();i++)
        {
            if(!vis[i]) dfs(ed,pvis,vis,i,1);
        }
        return mx;
    }
};
"
395,cpp,longest-cycle-in-a-graph,"class Solution {
public:
    int mx=-1;
    void dfs(vector<int> &ed , vector<int> &pvis , vector<int> &vis , int i , int j)
    {
        if(pvis[i])
        {
            mx = max(mx , j - pvis[i]);
            return;
        }
        if(!vis[i])
        {
            pvis[i] =j; j++; vis[i]=1;
            if(ed[i]!=-1) dfs(ed , pvis , vis , ed[i],j);
        }
        pvis[i] = 0;
        return;
    }
    int longestCycle(vector<int>& ed)
     {
        vector<int> vis(ed.size(),0) , pvis(ed.size(),0);
        mx = -1;
        for(int i=0;i<=ed.size();i++)
        {
            if(!vis[i]) dfs(ed,pvis,vis,i,1);
        }
        return mx;
    }
};",None,"class Solution {
public:
    int mx=-1;
    void dfs(vector<int> &ed , vector<int> &pvis , vector<int> &vis , int i , int j)
    {
        if(pvis[i])
        {
            mx = max(mx , j - pvis[i]);
            return;
        }
        if(!vis[i])
        {
            pvis[i] =j; j++; vis[i]=1;
            if(ed[i]!=-1) dfs(ed , pvis , vis , ed[i],j);
        }
        pvis[i] = 0;
        return;
    }
    int longestCycle(vector<int>& ed)
     {
        vector<int> vis(ed.size(),0) , pvis(ed.size(),0);
        mx = -1;
        for(int i=0;i<ed.size();i++)
        {
            if(!vis[i]) dfs(ed,pvis,vis,i,1);
        }
        return mx;
    }
};
"
395,cpp,longest-cycle-in-a-graph,"class Solution {
public:
    int mx=-1;
    void dfs(vector<int> &ed , vector<int> &pvis , vector<int> &vis , int i , int j)
    {
        if(pvis[i])
        {
            mx = max(mx , j - pvis[i]);
            return;
        }
        if(!vis[i])
        {
            pvis[i] =j; j++; vis[i]=1;
            if(ed[i]!=-1) dfs(ed , pvis , vis , ed[i],j);
        }
        pvis[i] = 0;
        return;
    }
    int longestCycle(vector<int>& ed)
     {
        vector<int> vis(ed.size(),0) , pvis(ed.size(),0);
        mx = -1;
        for(int i=0;i<=ed.size();i++)
        {
            if(!vis[i]) dfs(ed,pvis,vis,i,1);
        }
        return mx;
    }
};",None,"class Solution {
public:
    int mx=-1;
    void dfs(vector<int> &ed , vector<int> &pvis , vector<int> &vis , int i , int j)
    {
        if(pvis[i])
        {
            mx = max(mx , j - pvis[i]);
            return;
        }
        if(!vis[i])
        {
            pvis[i] =j; j++; vis[i]=1;
            if(ed[i]!=-1) dfs(ed , pvis , vis , ed[i],j);
        }
        pvis[i] = 0;
        return;
    }
    int longestCycle(vector<int>& ed)
     {
        vector<int> vis(ed.size(),0) , pvis(ed.size(),0);
        mx = -1;
        for(int i=0;i<ed.size();i++)
        {
            if(!vis[i]) dfs(ed,pvis,vis,i,1);
        }
        return mx;
    }
};
"
396,cpp,hamming-distance,"class Solution {
public:
    int hammingDistance(int x, int y) {
        int ans=0;
        while(x || y){
            int mask=x&1;
            int mask2=y&1;
            if(mask==mask2){
                ans++;
            }
            x>>=1;
            y>>=1;
        }
        return ans;
    }
};",None,"class Solution {
public:
    int hammingDistance(int x, int y) {
        int ans=0;
        while(x || y){
            int mask=x&1;
            int mask2=y&1;
            if(mask!=mask2){
                ans++;
            }
            x>>=1;
            y>>=1;
        }
        return ans;
    }
};
"
396,cpp,hamming-distance,"class Solution {
public:
    int hammingDistance(int x, int y) {
        int ans=0;
        while(x || y){
            int mask=x&1;
            int mask2=y&1;
            if(mask==mask2){
                ans++;
            }
            x>>=1;
            y>>=1;
        }
        return ans;
    }
};",None,"class Solution {
public:
    int hammingDistance(int x, int y) {
        int ans=0;
        while(x || y){
            int mask=x&1;
            int mask2=y&1;
            if(mask!=mask2){
                ans++;
            }
            x>>=1;
            y>>=1;
        }
        return ans;
    }
};
"
396,cpp,hamming-distance,"class Solution {
public:
    int hammingDistance(int x, int y) {
        int ans=0;
        while(x || y){
            int mask=x&1;
            int mask2=y&1;
            if(mask==mask2){
                ans++;
            }
            x>>=1;
            y>>=1;
        }
        return ans;
    }
};",None,"class Solution {
public:
    int hammingDistance(int x, int y) {
        int ans=0;
        while(x || y){
            int mask=x&1;
            int mask2=y&1;
            if(mask!=mask2){
                ans++;
            }
            x>>=1;
            y>>=1;
        }
        return ans;
    }
};
"
397,cpp,pascals-triangle-ii,"class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<vector<int>>v;
        vector<int>e;
        for (int i=0;i<=rowIndex;i++)
        {
            vector<int>a;
            for (int j=0;j<=i;j++)
            {
                if (j==0 || j==i){a.push_back(1);}
                else
                {
                    a.push_back(v[i][j]+v[i-1][j-1]);
                }
            }
            if (i==rowIndex){return a;}
            v.push_back(a);
        }
        return e;
    }
};",None,"class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<vector<int>>v;
        vector<int>e;
        for (int i=0;i<=rowIndex;i++)
        {
            vector<int>a;
            for (int j=0;j<=i;j++)
            {
                if (j==0 || j==i){a.push_back(1);}
                else
                {
                    a.push_back(v[i-1][j-1]+v[i-1][j]);
                }
            }
            if (i==rowIndex){return a;}
            v.push_back(a);
        }
        return e;
    }
};
"
397,cpp,pascals-triangle-ii,"class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<vector<int>>v;
        vector<int>e;
        for (int i=0;i<=rowIndex;i++)
        {
            vector<int>a;
            for (int j=0;j<=i;j++)
            {
                if (j==0 || j==i){a.push_back(1);}
                else
                {
                    a.push_back(v[i][j]+v[i-1][j-1]);
                }
            }
            if (i==rowIndex){return a;}
            v.push_back(a);
        }
        return e;
    }
};",None,"class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<vector<int>>v;
        vector<int>e;
        for (int i=0;i<=rowIndex;i++)
        {
            vector<int>a;
            for (int j=0;j<=i;j++)
            {
                if (j==0 || j==i){a.push_back(1);}
                else
                {
                    a.push_back(v[i-1][j]+v[i-1][j-1]);
                }
            }
            if (i==rowIndex){return a;}
            v.push_back(a);
        }
        return e;
    }
};
"
397,cpp,pascals-triangle-ii,"class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<vector<int>>v;
        vector<int>e;
        for (int i=0;i<=rowIndex;i++)
        {
            vector<int>a;
            for (int j=0;j<=i;j++)
            {
                if (j==0 || j==i){a.push_back(1);}
                else
                {
                    a.push_back(v[i][j]+v[i-1][j-1]);
                }
            }
            if (i==rowIndex){return a;}
            v.push_back(a);
        }
        return e;
    }
};",None,"class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<vector<int>>v;
        vector<int>e;
        for (int i=0;i<=rowIndex;i++)
        {
            vector<int>a;
            for (int j=0;j<=i;j++)
            {
                if (j==0 || j==i){a.push_back(1);}
                else
                {
                    a.push_back(v[i-1][j]+v[i-1][j-1]);
                }
            }
            if (i==rowIndex){return a;}
            v.push_back(a);
        }
        return e;
    }
};
"
398,cpp,transpose-matrix,"class Solution {
public:
    vector<vector<int>> transpose(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size(); 
        vector<vector<int>> transposed(n, vector<int>(m));
    
        for (int i = 0; i <= m; i++) { 
            for (int j = 0; j < n; j++) {
                transposed[j][i] = matrix[i][j];
            }
        }
        
        return transposed;
    }
};",None,"class Solution {
public:
    vector<vector<int>> transpose(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size(); 
        vector<vector<int>> transposed(n, vector<int>(m));
    
        for (int i = 0; i < m; i++) { 
            for (int j = 0; j < n; j++) {
                transposed[j][i] = matrix[i][j];
            }
        }
        
        return transposed;
    }
};
"
398,cpp,transpose-matrix,"class Solution {
public:
    vector<vector<int>> transpose(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size(); 
        vector<vector<int>> transposed(n, vector<int>(m));
    
        for (int i = 0; i <= m; i++) { 
            for (int j = 0; j < n; j++) {
                transposed[j][i] = matrix[i][j];
            }
        }
        
        return transposed;
    }
};",None,"class Solution {
public:
    vector<vector<int>> transpose(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size(); 
        vector<vector<int>> transposed(n, vector<int>(m));
    
        for (int i = 0; i < m; i++) { 
            for (int j = 0; j < n; j++) {
                transposed[j][i] = matrix[i][j];
            }
        }
        
        return transposed;
    }
};
"
398,cpp,transpose-matrix,"class Solution {
public:
    vector<vector<int>> transpose(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size(); 
        vector<vector<int>> transposed(n, vector<int>(m));
    
        for (int i = 0; i <= m; i++) { 
            for (int j = 0; j < n; j++) {
                transposed[j][i] = matrix[i][j];
            }
        }
        
        return transposed;
    }
};",None,"class Solution {
public:
    vector<vector<int>> transpose(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size(); 
        vector<vector<int>> transposed(n, vector<int>(m));
    
        for (int i = 0; i < m; i++) { 
            for (int j = 0; j < n; j++) {
                transposed[j][i] = matrix[i][j];
            }
        }
        
        return transposed;
    }
};
"
399,cpp,best-time-to-buy-and-sell-stock-with-transaction-fee,"class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        if (n <= 1) return 0;
        int buy = -prices[0];
        int sell = 0;
        for (int i = 1; i < n; i++) {
            int prevBuy = buy;
            buy = max(buy, sell - prices[i]);
            sell = max(sell, prevBuy + prices[i + 1] - fee);
        }
        return sell;
    }
};",None,"class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        if (n <= 1) return 0;
        int buy = -prices[0];
        int sell = 0;
        for (int i = 1; i < n; i++) {
            int prevBuy = buy;
            buy = max(buy, sell - prices[i]);
            sell = max(sell, prevBuy + prices[i] - fee);
        }
        return sell;
    }
};
"
399,cpp,best-time-to-buy-and-sell-stock-with-transaction-fee,"class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        if (n <= 1) return 0;
        int buy = -prices[0];
        int sell = 0;
        for (int i = 1; i < n; i++) {
            int prevBuy = buy;
            buy = max(buy, sell - prices[i]);
            sell = max(sell, prevBuy + prices[i + 1] - fee);
        }
        return sell;
    }
};",None,"class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        if (n <= 1) return 0;
        int buy = -prices[0];
        int sell = 0;
        for (int i = 1; i < n; i++) {
            int prevBuy = buy;
            buy = max(buy, sell - prices[i]);
            sell = max(sell, prevBuy + prices[i] - fee);
        }
        return sell;
    }
};
"
399,cpp,best-time-to-buy-and-sell-stock-with-transaction-fee,"class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        if (n <= 1) return 0;
        int buy = -prices[0];
        int sell = 0;
        for (int i = 1; i < n; i++) {
            int prevBuy = buy;
            buy = max(buy, sell - prices[i]);
            sell = max(sell, prevBuy + prices[i + 1] - fee);
        }
        return sell;
    }
};",None,"class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        if (n <= 1) return 0;
        int buy = -prices[0];
        int sell = 0;
        for (int i = 1; i < n; i++) {
            int prevBuy = buy;
            buy = max(buy, sell - prices[i]);
            sell = max(sell, prevBuy + prices[i] - fee);
        }
        return sell;
    }
};
"
400,cpp,arranging-coins,"class Solution {
public:
    int arrangeCoins(int n) {
        int c=n;
        long long i=1;
        if(n==0) return 0;
        else if(n==1) return 1;
        while(c>=0){
            i++;
            c-=i;
        }
    return i-1;}
};",None,"class Solution {
public:
    int arrangeCoins(int n) {
        long long i = 0;
        while (n > i) {
            i++;
            n -= i;
        }
        return i;
    }
};
"
400,cpp,arranging-coins,"class Solution {
public:
    int arrangeCoins(int n) {
        int c=n;
        long long i=1;
        if(n==0) return 0;
        else if(n==1) return 1;
        while(c>=0){
            i++;
            c-=i;
        }
    return i-1;}
};",None,"class Solution {
public:
    int arrangeCoins(int n) {
        long long c=n;
        long long i=1;
        if(n==0) return 0;
        else if(n==1) return 1;
        while(c>=i){
            c -= i;
            i++;
        }
        return i-1;
    }
};
"
400,cpp,arranging-coins,"class Solution {
public:
    int arrangeCoins(int n) {
        int c=n;
        long long i=1;
        if(n==0) return 0;
        else if(n==1) return 1;
        while(c>=0){
            i++;
            c-=i;
        }
    return i-1;}
};",None,"class Solution {
public:
    int arrangeCoins(int n) {
        int c=n;
        long long i=1;
        if(n==0) return 0;
        else if(n==1) return 1;
        while(c>=0){
            i++;
            c-=i;
        }
        return i-2;
    }
};
"
401,cpp,the-number-of-beautiful-subsets,"class Solution {
public:
    int beautifulSubsets(vector<int>& nums, int k) {
        vector<int> cur;
        return helper(nums, k, cur, 0);
    }
    private:
    int helper(vector<int>& nums, int k, vector<int>& cur, int start) {
        int cnt = 0;
        for (int i = start; i <= nums.size(); ++i) {
            if (!test(cur, nums[i], k))
                continue;
            cur.push_back(nums[i]);
            cnt++;
            cnt += helper(nums, k, cur, i + 1);
            cur.pop_back();
        }
        return cnt;
    }
    bool test(vector<int>& cur, int num, int k) {
        for (auto &c : cur)
            if (abs(num - c) == k)
                return false;
        return true;
    }
};",None,"class Solution {
public:
    int beautifulSubsets(vector<int>& nums, int k) {
        vector<int> cur;
        return helper(nums, k, cur, 0);
    }
    private:
    int helper(vector<int>& nums, int k, vector<int>& cur, int start) {
        int cnt = 0;
        for (int i = start; i < nums.size(); ++i) {
            if (!test(cur, nums[i], k))
                continue;
            cur.push_back(nums[i]);
            cnt++;
            cnt += helper(nums, k, cur, i + 1);
            cur.pop_back();
        }
        return cnt;
    }
    bool test(vector<int>& cur, int num, int k) {
        for (auto &c : cur)
            if (abs(num - c) == k)
                return false;
        return true;
    }
};
"
401,cpp,the-number-of-beautiful-subsets,"class Solution {
public:
    int beautifulSubsets(vector<int>& nums, int k) {
        vector<int> cur;
        return helper(nums, k, cur, 0);
    }
    private:
    int helper(vector<int>& nums, int k, vector<int>& cur, int start) {
        int cnt = 0;
        for (int i = start; i <= nums.size(); ++i) {
            if (!test(cur, nums[i], k))
                continue;
            cur.push_back(nums[i]);
            cnt++;
            cnt += helper(nums, k, cur, i + 1);
            cur.pop_back();
        }
        return cnt;
    }
    bool test(vector<int>& cur, int num, int k) {
        for (auto &c : cur)
            if (abs(num - c) == k)
                return false;
        return true;
    }
};",None,"class Solution {
public:
    int beautifulSubsets(vector<int>& nums, int k) {
        vector<int> cur;
        return helper(nums, k, cur, 0);
    }
private:
    int helper(vector<int>& nums, int k, vector<int>& cur, int start) {
        int cnt = 0;
        for (int i = start; i < nums.size(); ++i) {
            if (!test(cur, nums[i], k))
                continue;
            cur.push_back(nums[i]);
            cnt++;
            cnt += helper(nums, k, cur, i + 1);
            cur.pop_back();
        }
        return cnt;
    }
    bool test(vector<int>& cur, int num, int k) {
        for (auto &c : cur)
            if (abs(num - c) == k)
                return false;
        return true;
    }
};
"
401,cpp,the-number-of-beautiful-subsets,"class Solution {
public:
    int beautifulSubsets(vector<int>& nums, int k) {
        vector<int> cur;
        return helper(nums, k, cur, 0);
    }
    private:
    int helper(vector<int>& nums, int k, vector<int>& cur, int start) {
        int cnt = 0;
        for (int i = start; i <= nums.size(); ++i) {
            if (!test(cur, nums[i], k))
                continue;
            cur.push_back(nums[i]);
            cnt++;
            cnt += helper(nums, k, cur, i + 1);
            cur.pop_back();
        }
        return cnt;
    }
    bool test(vector<int>& cur, int num, int k) {
        for (auto &c : cur)
            if (abs(num - c) == k)
                return false;
        return true;
    }
};",None,"class Solution {
public:
    int beautifulSubsets(vector<int>& nums, int k) {
        vector<int> cur;
        return helper(nums, k, cur, 0);
    }
private:
    int helper(vector<int>& nums, int k, vector<int>& cur, int start) {
        int cnt = cur.empty() ? 0 : 1;
        for (int i = start; i < nums.size(); ++i) {
            if (!test(cur, nums[i], k))
                continue;
            cur.push_back(nums[i]);
            cnt += helper(nums, k, cur, i + 1);
            cur.pop_back();
        }
        return cnt;
    }
    bool test(vector<int>& cur, int num, int k) {
        for (auto &c : cur)
            if (abs(num - c) == k)
                return false;
        return true;
    }
};
"
402,cpp,minimum-number-of-steps-to-make-two-strings-anagram,"class Solution {
public:

    vector<int> mapping(string s)
    {
        vector<int> v(26, 0);
        for (int i = 0; i < s.size(); i++)
            v[s[i] - 'a']++;
        return v;
    }

    int minSteps(string s, string t) {

    vector<int> mapping1 = mapping(s);
    vector<int> mapping2 = mapping(t);
    int count = 0;
    for (int i = 0; i < 26; i++)
    {
        int diff = 0;
        if (mapping1[i] != 0)
            diff = mapping1[i] - mapping2[i];
        count += diff;
    }
    return count;
        
    }
};",None,"class Solution {
public:

    vector<int> mapping(string s)
    {
        vector<int> v(26, 0);
        for (int i = 0; i < s.size(); i++)
          v[s[i] - 'a']++;
        return v;
    }

    int minSteps(string s, string t) {

      vector<int> mapping1 = mapping(s);
      vector<int> mapping2 = mapping(t);
      int count = 0;
      for (int i = 0; i < 26; i++)
      {
          int diff = 0;
          if (mapping1[i] > mapping2[i])
              diff = mapping1[i] - mapping2[i];
          count += diff;
      }
      return count;

    }
};
"
402,cpp,minimum-number-of-steps-to-make-two-strings-anagram,"class Solution {
public:

    vector<int> mapping(string s)
    {
        vector<int> v(26, 0);
        for (int i = 0; i < s.size(); i++)
            v[s[i] - 'a']++;
        return v;
    }

    int minSteps(string s, string t) {

    vector<int> mapping1 = mapping(s);
    vector<int> mapping2 = mapping(t);
    int count = 0;
    for (int i = 0; i < 26; i++)
    {
        int diff = 0;
        if (mapping1[i] != 0)
            diff = mapping1[i] - mapping2[i];
        count += diff;
    }
    return count;
        
    }
};",None,"class Solution {
public:

    vector<int> mapping(string s)
    {
        vector<int> v(26, 0);
        for (int i = 0; i < s.size(); i++)
            v[s[i] - 'a']++;
        return v;
    }

    int minSteps(string s, string t) {

    vector<int> mapping1 = mapping(s);
    vector<int> mapping2 = mapping(t);
    int count = 0;
    for (int i = 0; i < 26; i++)
    {
        if (mapping1[i] != 0)
            count += max(0, mapping1[i] - mapping2[i]);
    }
    return count;
        
    }
};
"
402,cpp,minimum-number-of-steps-to-make-two-strings-anagram,"class Solution {
public:

    vector<int> mapping(string s)
    {
        vector<int> v(26, 0);
        for (int i = 0; i < s.size(); i++)
            v[s[i] - 'a']++;
        return v;
    }

    int minSteps(string s, string t) {

    vector<int> mapping1 = mapping(s);
    vector<int> mapping2 = mapping(t);
    int count = 0;
    for (int i = 0; i < 26; i++)
    {
        int diff = 0;
        if (mapping1[i] != 0)
            diff = mapping1[i] - mapping2[i];
        count += diff;
    }
    return count;
        
    }
};",None,"class Solution {
public:

    vector<int> mapping(string s)
    {
        vector<int> v(26, 0);
        for (int i = 0; i < s.size(); i++)
            v[s[i] - 'a']++;
        return v;
    }

    int minSteps(string s, string t) {

        vector<int> mapping1 = mapping(s);
        vector<int> mapping2 = mapping(t);
        int count = 0;
        for (int i = 0; i < 26; i++)
        {
            int diff = 0;
            if (mapping1[i] > mapping2[i])
                diff = mapping1[i] - mapping2[i];
            count += diff;
        }
        return count;
        
    }
};
"
403,cpp,longest-alternating-subarray,"class Solution {
public:
    int alternatingSubarray(vector<int>& v) {
        int ans = 0;
        for(int i = 0; i <= v.size() - 1; i += 1) {
            bool flag = true;
            int cnt = 1;
            for(int j = i + 1; j <= v.size(); j += 1) {
                if(v[j] - v[j - 1] != (flag ? 1 : -1)) break;
                flag = !flag;
                cnt += 1;
            }
            ans = max(ans, cnt);
        }
        return ans <= 1 ? -1 : ans;
    }
};",None,"class Solution {
public:
    int alternatingSubarray(vector<int>& v) {
        if (v.size() < 2) return -1;
        int ans = 0;
        
        for(int i = 0; i < v.size() - 1; i += 1) {
            bool flag = true;
            int cnt = 1;
            
            for(int j = i + 1; j < v.size(); j += 1) {
                if(v[j] - v[j - 1] != (flag ? 1 : -1)) break;
                flag = !flag;
                cnt += 1;
            }
            
            ans = max(ans, cnt);
        }
        return ans <= 1 ? -1 : ans;
    }
};
"
403,cpp,longest-alternating-subarray,"class Solution {
public:
    int alternatingSubarray(vector<int>& v) {
        int ans = 0;
        for(int i = 0; i <= v.size() - 1; i += 1) {
            bool flag = true;
            int cnt = 1;
            for(int j = i + 1; j <= v.size(); j += 1) {
                if(v[j] - v[j - 1] != (flag ? 1 : -1)) break;
                flag = !flag;
                cnt += 1;
            }
            ans = max(ans, cnt);
        }
        return ans <= 1 ? -1 : ans;
    }
};",None,"class Solution {
public:
    int alternatingSubarray(vector<int>& v) {
        int ans = 0;
        for(int i = 0; i < v.size() - 1; i += 1) {
            bool flag = true;
            int cnt = 1;
            for(int j = i + 1; j < v.size(); j += 1) {
                if(v[j] - v[j - 1] != (flag ? 1 : -1)) break;
                flag = !flag;
                cnt += 1;
            }
            ans = max(ans, cnt);
        }
        return ans <= 1 ? -1 : ans;
    }
};
"
403,cpp,longest-alternating-subarray,"class Solution {
public:
    int alternatingSubarray(vector<int>& v) {
        int ans = 0;
        for(int i = 0; i <= v.size() - 1; i += 1) {
            bool flag = true;
            int cnt = 1;
            for(int j = i + 1; j <= v.size(); j += 1) {
                if(v[j] - v[j - 1] != (flag ? 1 : -1)) break;
                flag = !flag;
                cnt += 1;
            }
            ans = max(ans, cnt);
        }
        return ans <= 1 ? -1 : ans;
    }
};",None,"class Solution {
public:
    int alternatingSubarray(vector<int>& v) {
        int ans = 0;
        for(int i = 0; i < v.size() - 1; i += 1) {
            bool flag = true;
            int cnt = 1;
            for(int j = i + 1; j < v.size(); j += 1) {
                if(v[j] - v[j - 1] != (flag ? 1 : -1)) break;
                flag = !flag;
                cnt += 1;
            }
            ans = max(ans, cnt);
        }
        return ans <= 1 ? -1 : ans;
    }
};
"
404,cpp,form-smallest-number-from-two-digit-arrays,"class Solution {
public:
    int minNumber(vector<int>& nums1, vector<int>& nums2) {
        map<int,int>mp;
        for(auto x: nums1) mp[x]++;
        for(auto x: nums2) mp[x]++;
        int mn1=*min_element(nums1.begin(),nums1.end());
        int mn2=*min_element(nums2.begin(),nums2.end());
        for(auto x: mp){
            if(x.second==1) return x.first;
        }
        string s;
        if(mn1<mn2) s=to_string(mn1)+ to_string(mn2);
        else s=to_string(mn2)+ to_string(mn1);
        return stoi(s);
    }
};",None,"class Solution {
public:
    int minNumber(vector<int>& nums1, vector<int>& nums2) {
        map<int,int>mp;
        for(auto x: nums1) mp[x]++;
        for(auto x: nums2) mp[x]++;
        int mn1=*min_element(nums1.begin(),nums1.end());
        int mn2=*min_element(nums2.begin(),nums2.end());
        for(auto x: mp){
            if(x.second==2) return x.first;
        }
        string s;
        if(mn1<mn2) s=to_string(mn1)+ to_string(mn2);
        else s=to_string(mn2)+ to_string(mn1);
        return stoi(s);
    }
};
"
404,cpp,form-smallest-number-from-two-digit-arrays,"class Solution {
public:
    int minNumber(vector<int>& nums1, vector<int>& nums2) {
        map<int,int>mp;
        for(auto x: nums1) mp[x]++;
        for(auto x: nums2) mp[x]++;
        int mn1=*min_element(nums1.begin(),nums1.end());
        int mn2=*min_element(nums2.begin(),nums2.end());
        for(auto x: mp){
            if(x.second==1) return x.first;
        }
        string s;
        if(mn1<mn2) s=to_string(mn1)+ to_string(mn2);
        else s=to_string(mn2)+ to_string(mn1);
        return stoi(s);
    }
};",None,"class Solution {
public:
    int minNumber(vector<int>& nums1, vector<int>& nums2) {
        map<int,int>mp;
        for(auto x: nums1) mp[x]++;
        for(auto x: nums2) mp[x]++;
        int mn1=*min_element(nums1.begin(),nums1.end());
        int mn2=*min_element(nums2.begin(),nums2.end());
        for(auto x: mp){
            if(x.second==2) return x.first;
        }
        string s;
        if(mn1<mn2) s=to_string(mn1)+ to_string(mn2);
        else s=to_string(mn2)+ to_string(mn1);
        return stoi(s);
    }
};
"
404,cpp,form-smallest-number-from-two-digit-arrays,"class Solution {
public:
    int minNumber(vector<int>& nums1, vector<int>& nums2) {
        map<int,int>mp;
        for(auto x: nums1) mp[x]++;
        for(auto x: nums2) mp[x]++;
        int mn1=*min_element(nums1.begin(),nums1.end());
        int mn2=*min_element(nums2.begin(),nums2.end());
        for(auto x: mp){
            if(x.second==1) return x.first;
        }
        string s;
        if(mn1<mn2) s=to_string(mn1)+ to_string(mn2);
        else s=to_string(mn2)+ to_string(mn1);
        return stoi(s);
    }
};",None,"class Solution {
public:
    int minNumber(vector<int>& nums1, vector<int>& nums2) {
        map<int,int> mp;
        for(auto x: nums1) mp[x]++;
        for(auto x: nums2) mp[x]++;
        int mn1=*min_element(nums1.begin(),nums1.end());
        int mn2=*min_element(nums2.begin(),nums2.end());
        for(auto x: mp){
            if(x.second==2) return x.first;
        }
        string s;
        if(mn1<mn2) s=to_string(mn1)+ to_string(mn2);
        else s=to_string(mn2)+ to_string(mn1);
        return stoi(s);
    }
};
"
405,cpp,shuffle-string,"class Solution {
public:
    string restoreString(string s, vector<int>& ind) {
        int n = s.size();
        string ans(n, '.');
        for (int i = 0; i <= n; i++) {
            ans[ind[i]] = s[i];
        } 
        return ans;
    }
};",None,"class Solution {
public:
    string restoreString(string s, vector<int>& ind) {
        int n = s.size();
        string ans(n, '.');
        for (int i = 0; i < n; i++) {
            ans[ind[i]] = s[i];
        } 
        return ans;
    }
};
"
405,cpp,shuffle-string,"class Solution {
public:
    string restoreString(string s, vector<int>& ind) {
        int n = s.size();
        string ans(n, '.');
        for (int i = 0; i <= n; i++) {
            ans[ind[i]] = s[i];
        } 
        return ans;
    }
};",None,"class Solution {
public:
    string restoreString(string s, vector<int>& ind) {
        int n = s.size();
        string ans(n, '.');
        for (int i = 0; i < n; i++) {
            ans[ind[i]] = s[i];
        } 
        return ans;
    }
};
"
405,cpp,shuffle-string,"class Solution {
public:
    string restoreString(string s, vector<int>& ind) {
        int n = s.size();
        string ans(n, '.');
        for (int i = 0; i <= n; i++) {
            ans[ind[i]] = s[i];
        } 
        return ans;
    }
};",None,"class Solution {
public:
    string restoreString(string s, vector<int>& ind) {
        int n = s.size();
        string ans(n, '.');
        for (int i = 0; i < n; i++) {
            ans[ind[i]] = s[i];
        } 
        return ans;
    }
};
"
406,cpp,flip-string-to-monotone-increasing,"class Solution {
public:
    int solve(int idx,int prev,string &s,vector<vector<int>>& dp){
        if(idx==s.size()){
            return 0;
        }
        if(dp[idx][prev]!=-1) return dp[idx][prev];
        if(prev){
            return dp[idx][prev]=(s[idx]=='0')+solve(idx+1,prev,s,dp);
        }
        else{
        
            return dp[idx][prev]=min((s[idx]=='1')+solve(idx+1,1,s,dp),(s[idx]=='0')+solve(idx+1,0,s,dp));
        }
    }
    int minFlipsMonoIncr(string s) {
        vector<vector<int>> dp(s.size(),vector<int>(2,-1));
        return solve(0,0,s,dp);
    }
};",None,"class Solution {
public:
    int solve(int idx,int prev,string &s,vector<vector<int>>& dp){
        if(idx==s.size()){
            return 0;
        }
        if(dp[idx][prev]!=-1) return dp[idx][prev];
        
        if(prev){
            return dp[idx][prev]=(s[idx]=='0')+solve(idx+1,prev,s,dp);
        } else {
            return dp[idx][prev]=min((s[idx]=='0')+solve(idx+1,1,s,dp),(s[idx]=='1')+solve(idx+1,0,s,dp));
        }
    }
    int minFlipsMonoIncr(string s) {
        vector<vector<int>> dp(s.size(),vector<int>(2,-1));
        return solve(0,0,s,dp);
    }
};
"
406,cpp,flip-string-to-monotone-increasing,"class Solution {
public:
    int solve(int idx,int prev,string &s,vector<vector<int>>& dp){
        if(idx==s.size()){
            return 0;
        }
        if(dp[idx][prev]!=-1) return dp[idx][prev];
        if(prev){
            return dp[idx][prev]=(s[idx]=='0')+solve(idx+1,prev,s,dp);
        }
        else{
        
            return dp[idx][prev]=min((s[idx]=='1')+solve(idx+1,1,s,dp),(s[idx]=='0')+solve(idx+1,0,s,dp));
        }
    }
    int minFlipsMonoIncr(string s) {
        vector<vector<int>> dp(s.size(),vector<int>(2,-1));
        return solve(0,0,s,dp);
    }
};",None,"class Solution {
public:
    int solve(int idx, int prev, string &s, vector<vector<int>>& dp){
        if(idx == s.size()){
            return 0;
        }
        if(dp[idx][prev] != -1) return dp[idx][prev];
        if(prev == 1){
            return dp[idx][prev] = (s[idx] == '0') + solve(idx + 1, 1, s, dp);
        }
        else{
            return dp[idx][prev] = min((s[idx] == '1') + solve(idx + 1, 1, s, dp), (s[idx] == '0') + solve(idx + 1, 0, s, dp));
        }
    }
    int minFlipsMonoIncr(string s) {
        vector<vector<int>> dp(s.size(), vector<int>(2,-1));
        return solve(0, 0, s, dp);
    }
};
"
406,cpp,flip-string-to-monotone-increasing,"class Solution {
public:
    int solve(int idx,int prev,string &s,vector<vector<int>>& dp){
        if(idx==s.size()){
            return 0;
        }
        if(dp[idx][prev]!=-1) return dp[idx][prev];
        if(prev){
            return dp[idx][prev]=(s[idx]=='0')+solve(idx+1,prev,s,dp);
        }
        else{
        
            return dp[idx][prev]=min((s[idx]=='1')+solve(idx+1,1,s,dp),(s[idx]=='0')+solve(idx+1,0,s,dp));
        }
    }
    int minFlipsMonoIncr(string s) {
        vector<vector<int>> dp(s.size(),vector<int>(2,-1));
        return solve(0,0,s,dp);
    }
};",None,"class Solution {
public:
    int solve(int idx,int prev,string &s,vector<vector<int>>& dp){
        if(idx==s.size()){
            return 0;
        }
        if(dp[idx][prev]!=-1) return dp[idx][prev];
        if(prev){
            return dp[idx][prev]=(s[idx]=='0')+solve(idx+1,1,s,dp);
        }
        else{
        
            return dp[idx][prev]=min((s[idx]=='1')+solve(idx+1,1,s,dp),(s[idx]=='0')+solve(idx+1,0,s,dp));
        }
    }
    int minFlipsMonoIncr(string s) {
        vector<vector<int>> dp(s.size()+1,vector<int>(2,-1));
        return solve(0,0,s,dp);
    }
};
"
407,cpp,minimum-cost-to-make-at-least-one-valid-path-in-a-grid,"#define pii pair<int, int>
#define maxn 10005
#define inf 1000000000

class Solution {
public:
    vector<pii>g[maxn];
    int dis[maxn];
    int n, m;
    bool valid(int x, int y) {
        if(x >= 0 and x <= n and y >= 0 and y <= m) return true;
        else return false;
    }
    void bfs(int s) {
        deque<int> q;
        for(int i=0; i<maxn; i++) dis[i] = inf;
        dis[s] = 0;
        q.push_front(s);
        while(!q.empty()){
            int u = q.front();
            q.pop_front();
            for(int i=0; i<g[u].size(); i++){
                int v = g[u][i].first;
                int w = g[u][i].second;
                if(dis[u] + w < dis[v]){
                    dis[v] = dis[u] + w;
                    if(w == 1) q.push_back(v);
                    else q.push_front(v);
                }
            }
        }
    }
    int minCost(vector<vector<int>>& grid) {
        n = grid.size(), m = grid[0].size();
        for(int i=0; i<n; i++) {
            for(int j=0; j<m; j++) {
                int u = i * m + j;
                if(valid(i+1, j)) {
                    int v = (i+1) * m + j;
                    int w;
                    if(grid[i][j] == 3) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                }
                if(valid(i-1, j)) {
                    int v = (i-1) * m + j;
                    int w;
                    if(grid[i][j] == 4) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
                if(valid(i, j+1)) {
                    int v = i * m + (j+1);
                    int w;
                    if(grid[i][j] == 1) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
                if(valid(i, j-1)) {
                    int v = i * m + (j-1);
                    int w;
                    if(grid[i][j] == 2) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
            }
        }
        bfs(0);
        int node = (n * m) - 1;
        int ans = dis[node];
        return ans;
    }
};",None,"#define pii pair<int, int>
#define maxn 10005
#define inf 1000000000

class Solution {
public:
    vector<pii>g[maxn];
    int dis[maxn];
    int n, m;
    bool valid(int x, int y) {
        if(x >= 0 and x < n and y >= 0 and y < m) return true;
        else return false;
    }
    void bfs(int s) {
        deque<int> q;
        for(int i=0; i<maxn; i++) dis[i] = inf;
        dis[s] = 0;
        q.push_front(s);
        while(!q.empty()){
            int u = q.front();
            q.pop_front();
            for(int i=0; i<g[u].size(); i++){
                int v = g[u][i].first;
                int w = g[u][i].second;
                if(dis[u] + w < dis[v]){
                    dis[v] = dis[u] + w;
                    if(w == 1) q.push_back(v);
                    else q.push_front(v);
                }
            }
        }
    }
    int minCost(vector<vector<int>>& grid) {
        n = grid.size(), m = grid[0].size();
        for(int i=0; i<n; i++) {
            for(int j=0; j<m; j++) {
                int u = i * m + j;
                if(valid(i+1, j)) {
                    int v = (i+1) * m + j;
                    int w;
                    if(grid[i][j] == 3) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                }
                if(valid(i-1, j)) {
                    int v = (i-1) * m + j;
                    int w;
                    if(grid[i][j] == 4) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
                if(valid(i, j+1)) {
                    int v = i * m + (j+1);
                    int w;
                    if(grid[i][j] == 1) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
                if(valid(i, j-1)) {
                    int v = i * m + (j-1);
                    int w;
                    if(grid[i][j] == 2) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
            }
        }
        bfs(0);
        int node = (n * m) - 1;
        int ans = dis[node];
        return ans;
    }
};
"
407,cpp,minimum-cost-to-make-at-least-one-valid-path-in-a-grid,"#define pii pair<int, int>
#define maxn 10005
#define inf 1000000000

class Solution {
public:
    vector<pii>g[maxn];
    int dis[maxn];
    int n, m;
    bool valid(int x, int y) {
        if(x >= 0 and x <= n and y >= 0 and y <= m) return true;
        else return false;
    }
    void bfs(int s) {
        deque<int> q;
        for(int i=0; i<maxn; i++) dis[i] = inf;
        dis[s] = 0;
        q.push_front(s);
        while(!q.empty()){
            int u = q.front();
            q.pop_front();
            for(int i=0; i<g[u].size(); i++){
                int v = g[u][i].first;
                int w = g[u][i].second;
                if(dis[u] + w < dis[v]){
                    dis[v] = dis[u] + w;
                    if(w == 1) q.push_back(v);
                    else q.push_front(v);
                }
            }
        }
    }
    int minCost(vector<vector<int>>& grid) {
        n = grid.size(), m = grid[0].size();
        for(int i=0; i<n; i++) {
            for(int j=0; j<m; j++) {
                int u = i * m + j;
                if(valid(i+1, j)) {
                    int v = (i+1) * m + j;
                    int w;
                    if(grid[i][j] == 3) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                }
                if(valid(i-1, j)) {
                    int v = (i-1) * m + j;
                    int w;
                    if(grid[i][j] == 4) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
                if(valid(i, j+1)) {
                    int v = i * m + (j+1);
                    int w;
                    if(grid[i][j] == 1) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
                if(valid(i, j-1)) {
                    int v = i * m + (j-1);
                    int w;
                    if(grid[i][j] == 2) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
            }
        }
        bfs(0);
        int node = (n * m) - 1;
        int ans = dis[node];
        return ans;
    }
};",None,"#define pii pair<int, int>
#define maxn 10005
#define inf 1000000000

class Solution {
public:
    vector<pii>g[maxn];
    int dis[maxn];
    int n, m;

    bool valid(int x, int y) {
        if(x >= 0 and x < n and y >= 0 and y < m) return true;
        else return false;
    }

    void bfs(int s) {
        deque<int> q;
        for(int i=0; i<maxn; i++) dis[i] = inf;
        dis[s] = 0;
        q.push_front(s);
        while(!q.empty()){
            int u = q.front();
            q.pop_front();
            for(int i=0; i<g[u].size(); i++){
                int v = g[u][i].first;
                int w = g[u][i].second;
                if(dis[u] + w < dis[v]){
                    dis[v] = dis[u] + w;
                    if(w == 1) q.push_back(v);
                    else q.push_front(v);
                }
            }
        }
    }

    int minCost(vector<vector<int>>& grid) {
        n = grid.size(), m = grid[0].size();
        for(int i=0; i<n; i++) {
            for(int j=0; j<m; j++) {
                int u = i * m + j;
                if(valid(i+1, j)) {
                    int v = (i+1) * m + j;
                    int w;
                    if(grid[i][j] == 3) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                }
                if(valid(i-1, j)) {
                    int v = (i-1) * m + j;
                    int w;
                    if(grid[i][j] == 4) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
                if(valid(i, j+1)) {
                    int v = i * m + (j+1);
                    int w;
                    if(grid[i][j] == 1) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
                if(valid(i, j-1)) {
                    int v = i * m + (j-1);
                    int w;
                    if(grid[i][j] == 2) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
            }
        }
        bfs(0);
        int node = (n * m) - 1;
        int ans = dis[node];
        return ans;
    }
};
"
407,cpp,minimum-cost-to-make-at-least-one-valid-path-in-a-grid,"#define pii pair<int, int>
#define maxn 10005
#define inf 1000000000

class Solution {
public:
    vector<pii>g[maxn];
    int dis[maxn];
    int n, m;
    bool valid(int x, int y) {
        if(x >= 0 and x <= n and y >= 0 and y <= m) return true;
        else return false;
    }
    void bfs(int s) {
        deque<int> q;
        for(int i=0; i<maxn; i++) dis[i] = inf;
        dis[s] = 0;
        q.push_front(s);
        while(!q.empty()){
            int u = q.front();
            q.pop_front();
            for(int i=0; i<g[u].size(); i++){
                int v = g[u][i].first;
                int w = g[u][i].second;
                if(dis[u] + w < dis[v]){
                    dis[v] = dis[u] + w;
                    if(w == 1) q.push_back(v);
                    else q.push_front(v);
                }
            }
        }
    }
    int minCost(vector<vector<int>>& grid) {
        n = grid.size(), m = grid[0].size();
        for(int i=0; i<n; i++) {
            for(int j=0; j<m; j++) {
                int u = i * m + j;
                if(valid(i+1, j)) {
                    int v = (i+1) * m + j;
                    int w;
                    if(grid[i][j] == 3) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                }
                if(valid(i-1, j)) {
                    int v = (i-1) * m + j;
                    int w;
                    if(grid[i][j] == 4) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
                if(valid(i, j+1)) {
                    int v = i * m + (j+1);
                    int w;
                    if(grid[i][j] == 1) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
                if(valid(i, j-1)) {
                    int v = i * m + (j-1);
                    int w;
                    if(grid[i][j] == 2) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
            }
        }
        bfs(0);
        int node = (n * m) - 1;
        int ans = dis[node];
        return ans;
    }
};",None,"#define pii pair<int, int>
#define maxn 10005
#define inf 1000000000

class Solution {
public:
    vector<pii>g[maxn];
    int dis[maxn];
    int n, m;
    bool valid(int x, int y) {
        if(x >= 0 and x < n and y >= 0 and y < m) return true;
        else return false;
    }
    void bfs(int s) {
        deque<int> q;
        for(int i=0; i<maxn; i++) dis[i] = inf;
        dis[s] = 0;
        q.push_front(s);
        while(!q.empty()){
            int u = q.front();
            q.pop_front();
            for(int i=0; i<g[u].size(); i++){
                int v = g[u][i].first;
                int w = g[u][i].second;
                if(dis[u] + w < dis[v]){
                    dis[v] = dis[u] + w;
                    if(w == 1) q.push_back(v);
                    else q.push_front(v);
                }
            }
        }
    }
    int minCost(vector<vector<int>>& grid) {
        n = grid.size(), m = grid[0].size();
        for(int i=0; i<n; i++) {
            for(int j=0; j<m; j++) {
                int u = i * m + j;
                if(valid(i+1, j)) {
                    int v = (i+1) * m + j;
                    int w;
                    if(grid[i][j] == 3) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                }
                if(valid(i-1, j)) {
                    int v = (i-1) * m + j;
                    int w;
                    if(grid[i][j] == 4) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
                if(valid(i, j+1)) {
                    int v = i * m + (j+1);
                    int w;
                    if(grid[i][j] == 1) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
                if(valid(i, j-1)) {
                    int v = i * m + (j-1);
                    int w;
                    if(grid[i][j] == 2) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
            }
        }
        bfs(0);
        int node = (n * m) - 1;
        int ans = dis[node];
        return ans;
    }
};
"
408,cpp,binary-string-with-substrings-representing-1-to-n,"class Solution {
public:
    bool queryString(string s, int n)
     {
        unordered_set<int> seen;
        int len = s.length();
        for(int i=len-1;i>=0;i--)
        {
            int num = 0;
            for(int j=1;j<=min(len-i,31);j++)
            { 
                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);
                if(0 < num && num <= n) seen.insert(num);
             }
            if(seen.size() != n) return true;
        }
        return false;
    }
};",None,"class Solution {
public:
    bool queryString(string s, int n)
     {
        unordered_set<int> seen;
        int len = s.length();
        for(int i=len-1;i>=0;i--)
        {
            int num = 0;
            for(int j=1;j<=min(len-i,31);j++)
            { 
                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);
                if(0 < num && num <= n) seen.insert(num);
             }
                
        }
        if(seen.size() == n) return true;
        return false;
    }
};
"
408,cpp,binary-string-with-substrings-representing-1-to-n,"class Solution {
public:
    bool queryString(string s, int n)
     {
        unordered_set<int> seen;
        int len = s.length();
        for(int i=len-1;i>=0;i--)
        {
            int num = 0;
            for(int j=1;j<=min(len-i,31);j++)
            { 
                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);
                if(0 < num && num <= n) seen.insert(num);
             }
            if(seen.size() != n) return true;
        }
        return false;
    }
};",None,"class Solution {
public:
    bool queryString(string s, int n)
     {
        unordered_set<int> seen;
        int len = s.length();
        for(int i=len-1;i>=0;i--)
        {
            int num = 0;
            for(int j=1;j<=min(len-i,31);j++)
            { 
                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);
                if(0 < num && num <= n) seen.insert(num);
            }
        }
        return seen.size() == n;
    }
};
"
408,cpp,binary-string-with-substrings-representing-1-to-n,"class Solution {
public:
    bool queryString(string s, int n)
     {
        unordered_set<int> seen;
        int len = s.length();
        for(int i=len-1;i>=0;i--)
        {
            int num = 0;
            for(int j=1;j<=min(len-i,31);j++)
            { 
                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);
                if(0 < num && num <= n) seen.insert(num);
             }
            if(seen.size() != n) return true;
        }
        return false;
    }
};",None,"class Solution {
public:
    bool queryString(string s, int n)
     {
        unordered_set<int> seen;
        int len = s.length();
        for(int i=len-1;i>=0;i--)
        {
            int num = 0;
            for(int j=1;j<=min(len-i,31);j++)
            { 
                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);
                if(0 < num && num <= n) seen.insert(num);
             }
        }
        return seen.size() == n;
    }
};
"
409,cpp,minimum-operations-to-make-array-equal,"class Solution {
public:
    int minOperations(int n) {
       int i,j,k=0,s=0;
       i=n/2;
       int max=n;
       
        for(j=0;j<=i;j++){
            s+=max-2*j-1;
        }
        return s;
    }
};",None,"class Solution {
public:
    int minOperations(int n) {
       int i=0, s=0;
       int max = n;
       
        for(i=0; i<n/2; i++){
            s+=max-2*i-1;
        }
        return s;
    }
};
"
409,cpp,minimum-operations-to-make-array-equal,"class Solution {
public:
    int minOperations(int n) {
       int i,j,k=0,s=0;
       i=n/2;
       int max=n;
       
        for(j=0;j<=i;j++){
            s+=max-2*j-1;
        }
        return s;
    }
};",None,"class Solution {
public:
    int minOperations(int n) {
       if(n%2 != 0)
       {
           n = n / 2;
           return n*(n+1);
       }
       else
       {
           n = n / 2;
           return n*n;
       }
    }
};
"
409,cpp,minimum-operations-to-make-array-equal,"class Solution {
public:
    int minOperations(int n) {
       int i,j,k=0,s=0;
       i=n/2;
       int max=n;
       
        for(j=0;j<=i;j++){
            s+=max-2*j-1;
        }
        return s;
    }
};",None,"class Solution {
public:
    int minOperations(int n) {
        int i, s = 0;
        i = n / 2;
        if(n % 2 == 0){
            return i * i;
        }else{
            return i * (i + 1);
        }
    }
};
"
410,cpp,perfect-squares,"class Solution {
public:

    int dp[105][10005];

    int helper(vector<int>& arr, int i, int n, int sum)
    {
        if(i >= n || sum <= 0) 
        {
            return INT_MAX - 1000;
        }

        if(dp[i][sum] != -1)
        {
            return dp[i][sum];
        }

        int mini = INT_MAX;

        if(arr[i] <= sum)
        {
            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));
        }

        mini = min(mini, helper(arr, i + 1, n, sum));

        return dp[i][sum] = mini;
    }

    int numSquares(int n) {

        vector<int> arr;

        for(int i = 1; i * i <= n; i++)
        {
            arr.push_back(i * i);
        }

        memset(dp, -1, sizeof(dp));

        return helper(arr, 0, arr.size(), n);
    }
};",None,"class Solution {
public:

    int dp[105][10005];

    int helper(vector<int>& arr, int i, int sum)
    {
        if(sum == 0) 
        {
            return 0;
        }

        if(i >= arr.size() || sum < 0) 
        {
            return INT_MAX - 1000;
        }

        if(dp[i][sum] != -1)
        {
            return dp[i][sum];
        }

        int mini = INT_MAX;

        if(arr[i] <= sum)
        {
            mini = min(mini, 1 + helper(arr, i, sum - arr[i]));
        }

        mini = min(mini, helper(arr, i + 1, sum));

        return dp[i][sum] = mini;
    }

    int numSquares(int n) {

        vector<int> arr;

        for(int i = 1; i * i <= n; i++)
        {
            arr.push_back(i * i);
        }

        memset(dp, -1, sizeof(dp));

        int result = helper(arr, 0, n);

        return (result >= INT_MAX-1000) ? -1 : result;
    }
};
"
410,cpp,perfect-squares,"class Solution {
public:

    int dp[105][10005];

    int helper(vector<int>& arr, int i, int n, int sum)
    {
        if(i >= n || sum <= 0) 
        {
            return INT_MAX - 1000;
        }

        if(dp[i][sum] != -1)
        {
            return dp[i][sum];
        }

        int mini = INT_MAX;

        if(arr[i] <= sum)
        {
            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));
        }

        mini = min(mini, helper(arr, i + 1, n, sum));

        return dp[i][sum] = mini;
    }

    int numSquares(int n) {

        vector<int> arr;

        for(int i = 1; i * i <= n; i++)
        {
            arr.push_back(i * i);
        }

        memset(dp, -1, sizeof(dp));

        return helper(arr, 0, arr.size(), n);
    }
};",None,"class Solution {
public:

    int dp[105][10005];

    int helper(vector<int>& arr, int i, int n, int sum)
    {
        if(sum == 0) 
        {
            return 0;
        }
        if(i >= n || sum < 0) 
        {
            return INT_MAX - 1000;
        }

        if(dp[i][sum] != -1)
        {
            return dp[i][sum];
        }

        int mini = INT_MAX;

        if(arr[i] <= sum)
        {
            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));
        }

        mini = min(mini, helper(arr, i + 1, n, sum));

        return dp[i][sum] = mini;
    }

    int numSquares(int n) {

        vector<int> arr;

        for(int i = 1; i * i <= n; i++)
        {
            arr.push_back(i * i);
        }

        memset(dp, -1, sizeof(dp));

        int res = helper(arr, 0, arr.size(), n);
        return res == INT_MAX - 1000 ? -1 : res;
    }
};
"
410,cpp,perfect-squares,"class Solution {
public:

    int dp[105][10005];

    int helper(vector<int>& arr, int i, int n, int sum)
    {
        if(i >= n || sum <= 0) 
        {
            return INT_MAX - 1000;
        }

        if(dp[i][sum] != -1)
        {
            return dp[i][sum];
        }

        int mini = INT_MAX;

        if(arr[i] <= sum)
        {
            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));
        }

        mini = min(mini, helper(arr, i + 1, n, sum));

        return dp[i][sum] = mini;
    }

    int numSquares(int n) {

        vector<int> arr;

        for(int i = 1; i * i <= n; i++)
        {
            arr.push_back(i * i);
        }

        memset(dp, -1, sizeof(dp));

        return helper(arr, 0, arr.size(), n);
    }
};",None,"class Solution {
public:

    int dp[105][10005];

    int helper(vector<int>& arr, int i, int n, int sum)
    {
        if(sum == 0) 
        {
            return 0;
        }

        if(i >= n || sum < 0) 
        {
            return INT_MAX - 1000;
        }

        if(dp[i][sum] != -1)
        {
            return dp[i][sum];
        }

        int mini = INT_MAX;

        if(arr[i] <= sum)
        {
            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));
        }

        mini = min(mini, helper(arr, i + 1, n, sum));

        return dp[i][sum] = mini;
    }

    int numSquares(int n) {

        vector<int> arr;

        for(int i = 1; i * i <= n; i++)
        {
            arr.push_back(i * i);
        }

        memset(dp, -1, sizeof(dp));

        int res = helper(arr, 0, arr.size(), n);

        // handle case where no combination can sum to 'n'
        return res == INT_MAX - 1000 ? -1 : res;
    }
};
"
411,cpp,minimum-difference-between-largest-and-smallest-value-in-three-moves,"class Solution {
public:
    int minDifference(vector<int>& nums) {
        if(nums.size() <= 4) return 0;
        sort(nums.begin(), nums.end());
        int n = nums.size();
        return min({nums[n] - nums[0], nums[n - 1] - nums[3], nums[n - 3] - nums[1], nums[n - 2] - nums[2]});
    }
};",None,"class Solution {
public:
    int minDifference(vector<int>& nums) {
        if(nums.size() <= 4) return 0;
        sort(nums.begin(), nums.end());
        int n = nums.size();
        return min({nums[n-1] - nums[3], nums[n - 2] - nums[2], nums[n - 3] - nums[1], nums[n - 4] - nums[0]});
    }
};
"
411,cpp,minimum-difference-between-largest-and-smallest-value-in-three-moves,"class Solution {
public:
    int minDifference(vector<int>& nums) {
        if(nums.size() <= 4) return 0;
        sort(nums.begin(), nums.end());
        int n = nums.size();
        return min({nums[n] - nums[0], nums[n - 1] - nums[3], nums[n - 3] - nums[1], nums[n - 2] - nums[2]});
    }
};",None,"class Solution {
public:
    int minDifference(vector<int>& nums) {
        if(nums.size() <= 4) return 0;
        sort(nums.begin(), nums.end());
        int n = nums.size();
        return min({nums[n-1] - nums[3], nums[n-2] - nums[2], nums[n-3] - nums[1], nums[n-4] - nums[0]});
    }
};
"
411,cpp,minimum-difference-between-largest-and-smallest-value-in-three-moves,"class Solution {
public:
    int minDifference(vector<int>& nums) {
        if(nums.size() <= 4) return 0;
        sort(nums.begin(), nums.end());
        int n = nums.size();
        return min({nums[n] - nums[0], nums[n - 1] - nums[3], nums[n - 3] - nums[1], nums[n - 2] - nums[2]});
    }
};",None,"class Solution {
public:
    int minDifference(vector<int>& nums) {
        if(nums.size() <= 4) return 0;
        sort(nums.begin(), nums.end());
        int n = nums.size();
        return min({nums[n - 1] - nums[3], nums[n - 2] - nums[2], nums[n - 3] - nums[1], nums[n - 4] - nums[0]});
    }
};
"
412,cpp,sort-an-array,"class Solution {
public:
    void merge(int low, int mid, int high, vector<int> &nums) {
        if (low >= high) 
        return;
        int l = low, r = mid + 1, k = 0, size = high - low + 1;
        vector<int> sorted(size, 0);
        while (l <= mid and r <= high)
            sorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];
        while (l <= mid) 
            sorted[k++] = nums[l++];
        while (r <= high) 
            sorted[k++] = nums[r++];
        for (k = 0; k < size; k++)
            nums[k + low] = sorted[k];
    }

    void mergeSort(vector<int>& nums, int start, int end){
        if(start < end){
            int mid = start + (end - start) / 2;
            mergeSort(nums, start, mid+1); 
            mergeSort(nums, mid + 1, end);
            merge(start, mid, end, nums);
        }
    }

    vector<int> sortArray(vector<int>& nums) {
        mergeSort(nums, 0, nums.size()-1);
        return nums;
    }
};",None,"class Solution {
public:
    void merge(int low, int mid, int high, vector<int> &nums) {
        int l = low, r = mid + 1, k = 0, size = high - low + 1;
        vector<int> sorted(size, 0);
        while (l <= mid and r <= high)
            sorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];
        while (l <= mid) 
            sorted[k++] = nums[l++];
        while (r <= high) 
            sorted[k++] = nums[r++];
        for (k = 0; k < size; k++)
            nums[k + low] = sorted[k];
    }

    void mergeSort(vector<int>& nums, int start, int end){
        if(start < end){
            int mid = start + (end - start) / 2;
            mergeSort(nums, start, mid); 
            mergeSort(nums, mid + 1, end);
            merge(start, mid, end, nums);
        }
    }

    vector<int> sortArray(vector<int>& nums) {
        mergeSort(nums, 0, nums.size()-1);
        return nums;
    }
};
"
412,cpp,sort-an-array,"class Solution {
public:
    void merge(int low, int mid, int high, vector<int> &nums) {
        if (low >= high) 
        return;
        int l = low, r = mid + 1, k = 0, size = high - low + 1;
        vector<int> sorted(size, 0);
        while (l <= mid and r <= high)
            sorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];
        while (l <= mid) 
            sorted[k++] = nums[l++];
        while (r <= high) 
            sorted[k++] = nums[r++];
        for (k = 0; k < size; k++)
            nums[k + low] = sorted[k];
    }

    void mergeSort(vector<int>& nums, int start, int end){
        if(start < end){
            int mid = start + (end - start) / 2;
            mergeSort(nums, start, mid+1); 
            mergeSort(nums, mid + 1, end);
            merge(start, mid, end, nums);
        }
    }

    vector<int> sortArray(vector<int>& nums) {
        mergeSort(nums, 0, nums.size()-1);
        return nums;
    }
};",None,"class Solution {
public:
    void merge(int low, int mid, int high, vector<int> &nums) {
        int l = low, r = mid + 1, k = 0, size = high - low + 1;
        vector<int> sorted(size, 0);
        while (l <= mid and r <= high)
            sorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];
        while (l <= mid) 
            sorted[k++] = nums[l++];
        while (r <= high) 
            sorted[k++] = nums[r++];
        for (k = 0; k < size; k++)
            nums[k + low] = sorted[k];
    }

    void mergeSort(vector<int>& nums, int start, int end){
        if(start < end){
            int mid = start + (end - start) / 2;
            mergeSort(nums, start, mid); 
            mergeSort(nums, mid + 1, end);
            merge(start, mid, end, nums);
        }
    }

    vector<int> sortArray(vector<int>& nums) {
        mergeSort(nums, 0, nums.size()-1);
        return nums;
    }
};
"
412,cpp,sort-an-array,"class Solution {
public:
    void merge(int low, int mid, int high, vector<int> &nums) {
        if (low >= high) 
        return;
        int l = low, r = mid + 1, k = 0, size = high - low + 1;
        vector<int> sorted(size, 0);
        while (l <= mid and r <= high)
            sorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];
        while (l <= mid) 
            sorted[k++] = nums[l++];
        while (r <= high) 
            sorted[k++] = nums[r++];
        for (k = 0; k < size; k++)
            nums[k + low] = sorted[k];
    }

    void mergeSort(vector<int>& nums, int start, int end){
        if(start < end){
            int mid = start + (end - start) / 2;
            mergeSort(nums, start, mid+1); 
            mergeSort(nums, mid + 1, end);
            merge(start, mid, end, nums);
        }
    }

    vector<int> sortArray(vector<int>& nums) {
        mergeSort(nums, 0, nums.size()-1);
        return nums;
    }
};",None,"class Solution {
public:
    void merge(int low, int mid, int high, vector<int> &nums) {
        if (low >= high) 
        return;
        int l = low, r = mid + 1, k = 0, size = high - low + 1;
        vector<int> sorted(size, 0);
        while (l <= mid and r <= high)
            sorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];
        while (l <= mid) 
            sorted[k++] = nums[l++];
        while (r <= high) 
            sorted[k++] = nums[r++];
        for (k = 0; k < size; k++)
            nums[k + low] = sorted[k];
    }

    void mergeSort(vector<int>& nums, int start, int end){
        if(start < end){
            int mid = start + (end - start) / 2;
            mergeSort(nums, start, mid); 
            mergeSort(nums, mid + 1, end);
            merge(start, mid, end, nums);
        }
    }

    vector<int> sortArray(vector<int>& nums) {
        mergeSort(nums, 0, nums.size()-1);
        return nums;
    }
};
"
413,cpp,shortest-path-with-alternating-colors,"class Solution {
public:
    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) 
    {
        multiset<int>temp;
        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);
        for(auto j:redEdges)
        {
            redchilds[j[0]].insert(j[1]);
        }
        for(auto j:blueEdges)
        {
            bluechilds[j[0]].insert(j[1]);
        }
        vector<int>ans(n, -1);
        for(int i=0;i<n;) 
        {
            vector<multiset<int>>reds=redchilds,blues=bluechilds;
            queue<pair<char,int>>visit;
            visit.push({'n',0});
            int steps=0;
            while(!visit.empty())
            {
                bool justbreak=false;
                int n=visit.size();
                for(int j=0;j<n;j++)
                {
                    pair<char,int>x=visit.front();
                    visit.pop();
                    if(x.second==i)
                    {
                        ans[i]=steps;
                        justbreak=true;
                        break;
                    }
                    if(x.first=='n' || x.first == ans[i] % 2 + '0') 
                    {
                        for(auto j:reds[x.second])
                        {
                            visit.push({'r',j});
                            auto itr1=reds[x.second].find(j);
                            reds[x.second].erase(itr1);
                        }
                        for(auto j:blues[x.second])
                        {
                            visit.push({'b',j});
                            auto itr1=blues[x.second].find(j);
                            blues[x.second].erase(itr1);
                        }
                    }
                    else if(x.first=='b')
                    {
                        for(auto j:reds[x.second])
                        {
                            visit.push({'r',j});
                            auto itr1=reds[x.second].find(j);
                            reds[x.second].erase(itr1);
                        }
                    }
                    else if(x.first=='r')
                    {
                        for(auto j:blues[x.second])
                        {
                            visit.push({'b',j});
                            auto itr1=blues[x.second].find(j);
                            blues[x.second].erase(itr1);
                        }
                    }
                }
                if(justbreak)
                {
                    break;
                }
                steps++;
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) 
    {
        multiset<int>temp;
        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);
        for(auto j:redEdges)
        {
            redchilds[j[0]].insert(j[1]);
        }
        for(auto j:blueEdges)
        {
            bluechilds[j[0]].insert(j[1]);
        }
        vector<int>ans(n, -1);
        for(int i=0;i<n;i++) 
        {
            vector<multiset<int>>reds=redchilds,blues=bluechilds;
            queue<pair<char,int>>visit;
            visit.push({'n',0});
            int steps=0;
            while(!visit.empty())
            {
                bool justbreak=false;
                int n=visit.size();
                for(int j=0;j<n;j++)
                {
                    pair<char,int>x=visit.front();
                    visit.pop();
                    if(x.second==i)
                    {
                        ans[i]=steps;
                        justbreak=true;
                        break;
                    }
                    if(x.first=='n' || x.first == '0' + steps % 2) //Updated condition for alternation
                    {
                        for(auto j:reds[x.second])
                        {
                            visit.push({'r',j});
                            auto itr1=reds[x.second].find(j);
                            reds[x.second].erase(itr1);
                        }
                        for(auto j:blues[x.second])
                        {
                            visit.push({'b',j});
                            auto itr1=blues[x.second].find(j);
                            blues[x.second].erase(itr1);
                        }
                    }
                    else if(x.first=='b')
                    {
                        for(auto j:reds[x.second])
                        {
                            visit.push({'r',j});
                            auto itr1=reds[x.second].find(j);
                            reds[x.second].erase(itr1);
                        }
                    }
                    else if(x.first=='r')
                    {
                        for(auto j:blues[x.second])
                        {
                            visit.push({'b',j});
                            auto itr1=blues[x.second].find(j);
                            blues[x.second].erase(itr1);
                        }
                    }
                }
                if(justbreak)
                {
                    break;
                }
                steps++;
            }
        }
        return ans;
    }
};
"
413,cpp,shortest-path-with-alternating-colors,"class Solution {
public:
    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) 
    {
        multiset<int>temp;
        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);
        for(auto j:redEdges)
        {
            redchilds[j[0]].insert(j[1]);
        }
        for(auto j:blueEdges)
        {
            bluechilds[j[0]].insert(j[1]);
        }
        vector<int>ans(n, -1);
        for(int i=0;i<n;) 
        {
            vector<multiset<int>>reds=redchilds,blues=bluechilds;
            queue<pair<char,int>>visit;
            visit.push({'n',0});
            int steps=0;
            while(!visit.empty())
            {
                bool justbreak=false;
                int n=visit.size();
                for(int j=0;j<n;j++)
                {
                    pair<char,int>x=visit.front();
                    visit.pop();
                    if(x.second==i)
                    {
                        ans[i]=steps;
                        justbreak=true;
                        break;
                    }
                    if(x.first=='n' || x.first == ans[i] % 2 + '0') 
                    {
                        for(auto j:reds[x.second])
                        {
                            visit.push({'r',j});
                            auto itr1=reds[x.second].find(j);
                            reds[x.second].erase(itr1);
                        }
                        for(auto j:blues[x.second])
                        {
                            visit.push({'b',j});
                            auto itr1=blues[x.second].find(j);
                            blues[x.second].erase(itr1);
                        }
                    }
                    else if(x.first=='b')
                    {
                        for(auto j:reds[x.second])
                        {
                            visit.push({'r',j});
                            auto itr1=reds[x.second].find(j);
                            reds[x.second].erase(itr1);
                        }
                    }
                    else if(x.first=='r')
                    {
                        for(auto j:blues[x.second])
                        {
                            visit.push({'b',j});
                            auto itr1=blues[x.second].find(j);
                            blues[x.second].erase(itr1);
                        }
                    }
                }
                if(justbreak)
                {
                    break;
                }
                steps++;
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges, vector<vector<int>>& blueEdges) {
        vector<vector<int>> red(n), blue(n);
        for (auto &e : redEdges) red[e[0]].push_back(e[1]);
        for (auto &e : blueEdges) blue[e[0]].push_back(e[1]);
        vector<vector<int>> dp(n, vector<int>(2, -1));
        dp[0][0] = dp[0][1] = 0;
        queue<pair<int,int>> q;
        q.push({0, 0});
        q.push({0, 1});
        while (!q.empty()) {
            auto t = q.front(); q.pop();
            auto color = t.second, next_color = t.second ^ 1;
            auto &graph = next_color == 1 ? blue : red;
            for (auto &it : graph[t.first]) {
                if (dp[it][next_color] == -1) {
                    dp[it][next_color] = dp[t.first][color] + 1;
                    q.push({it, next_color});
                }
            }
        }
        vector<int> res(n, -1);
        for (int i = 0; i < n; ++i) {
            if (dp[i][0] != -1 && dp[i][1] != -1)
                res[i] = min(dp[i][0], dp[i][1]);
            else if (dp[i][0] != -1)
                res[i] = dp[i][0];
            else
                res[i] = dp[i][1];
        }
        return res;
    }
};
"
413,cpp,shortest-path-with-alternating-colors,"class Solution {
public:
    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) 
    {
        multiset<int>temp;
        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);
        for(auto j:redEdges)
        {
            redchilds[j[0]].insert(j[1]);
        }
        for(auto j:blueEdges)
        {
            bluechilds[j[0]].insert(j[1]);
        }
        vector<int>ans(n, -1);
        for(int i=0;i<n;) 
        {
            vector<multiset<int>>reds=redchilds,blues=bluechilds;
            queue<pair<char,int>>visit;
            visit.push({'n',0});
            int steps=0;
            while(!visit.empty())
            {
                bool justbreak=false;
                int n=visit.size();
                for(int j=0;j<n;j++)
                {
                    pair<char,int>x=visit.front();
                    visit.pop();
                    if(x.second==i)
                    {
                        ans[i]=steps;
                        justbreak=true;
                        break;
                    }
                    if(x.first=='n' || x.first == ans[i] % 2 + '0') 
                    {
                        for(auto j:reds[x.second])
                        {
                            visit.push({'r',j});
                            auto itr1=reds[x.second].find(j);
                            reds[x.second].erase(itr1);
                        }
                        for(auto j:blues[x.second])
                        {
                            visit.push({'b',j});
                            auto itr1=blues[x.second].find(j);
                            blues[x.second].erase(itr1);
                        }
                    }
                    else if(x.first=='b')
                    {
                        for(auto j:reds[x.second])
                        {
                            visit.push({'r',j});
                            auto itr1=reds[x.second].find(j);
                            reds[x.second].erase(itr1);
                        }
                    }
                    else if(x.first=='r')
                    {
                        for(auto j:blues[x.second])
                        {
                            visit.push({'b',j});
                            auto itr1=blues[x.second].find(j);
                            blues[x.second].erase(itr1);
                        }
                    }
                }
                if(justbreak)
                {
                    break;
                }
                steps++;
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>& redEdges,vector<vector<int>>& blueEdges) 
    {
        multiset<int>temp;
        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);
        for(auto j:redEdges)
        {
            redchilds[j[0]].insert(j[1]);
        }
        for(auto j:blueEdges)
        {
            bluechilds[j[0]].insert(j[1]);
        }
        vector<int>ans(n, -1);
        for(int i=0;i<n; i++) 
        {
            vector<multiset<int>>reds=redchilds,blues=bluechilds;
            queue<pair<char,int>>visit;
            visit.push({'n',0});
            int steps=0;
            while(!visit.empty())
            {
                bool justbreak=false;
                int n=visit.size();
                for(int j=0;j<n;j++)
                {
                    pair<char,int>x=visit.front();
                    visit.pop();
                    if(x.second==i)
                    {
                        ans[i]=steps;
                        justbreak=true;
                        break;
                    }
                    if(x.first=='n' || x.first == steps % 2 + '0') 
                    {
                        for(auto j:reds[x.second])
                        {
                            visit.push({'r',j});
                            auto itr1=reds[x.second].find(j);
                            reds[x.second].erase(itr1);
                        }
                        for(auto j:blues[x.second])
                        {
                            visit.push({'b',j});
                            auto itr1=blues[x.second].find(j);
                            blues[x.second].erase(itr1);
                        }
                    }
                    else if(x.first=='b')
                    {
                        for(auto j:reds[x.second])
                        {
                            visit.push({'r',j});
                            auto itr1=reds[x.second].find(j);
                            reds[x.second].erase(itr1);
                        }
                    }
                    else if(x.first=='r')
                    {
                        for(auto j:blues[x.second])
                        {
                            visit.push({'b',j});
                            auto itr1=blues[x.second].find(j);
                            blues[x.second].erase(itr1);
                        }
                    }
                }
                if(justbreak)
                {
                    break;
                }
                steps++;
            }
        }
        return ans;
    }
};
"
414,cpp,find-peak-element,"class Solution {
public:
    int findPeakElement(vector<int>& nums) {
    int n=nums.size();
    if(n==1)
    {
      return 0;
    } 
    if(nums[0]>nums[1])
    {
      return 0;
    }
    if(nums[n-1]>nums[n-2])
    {
      return n-1;
    }
    int left=1;
    int right=n-2;
    while(left<=right)
    {
      int mid=(left+right)/2;
      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])
      {
        return mid;
      }
      else if(nums[mid]<nums[mid-1])
      {
        left=mid+1;
      }
      else{
        right=mid-1;
      }
    }
return -1;
    }
};",None,"class Solution {
public:
    int findPeakElement(vector<int>& nums) {
    int n=nums.size();
    if(n==1)
    {
      return 0;
    } 
    if(nums[0]>nums[1])
    {
      return 0;
    }
    if(nums[n-1]>nums[n-2])
    {
      return n-1;
    }
    int left=1;
    int right=n-2;
    while(left<=right)
    {
      int mid=(left+right)/2;
      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])
      {
        return mid;
      }
      else if(nums[mid]<nums[mid+1])
      {
        left=mid+1;
      }
      else{
        right=mid-1;
      }
    }
return -1;
    }
};
"
414,cpp,find-peak-element,"class Solution {
public:
    int findPeakElement(vector<int>& nums) {
    int n=nums.size();
    if(n==1)
    {
      return 0;
    } 
    if(nums[0]>nums[1])
    {
      return 0;
    }
    if(nums[n-1]>nums[n-2])
    {
      return n-1;
    }
    int left=1;
    int right=n-2;
    while(left<=right)
    {
      int mid=(left+right)/2;
      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])
      {
        return mid;
      }
      else if(nums[mid]<nums[mid-1])
      {
        left=mid+1;
      }
      else{
        right=mid-1;
      }
    }
return -1;
    }
};",None,"class Solution {
public:
    int findPeakElement(vector<int>& nums) {
    int n=nums.size();
    if(n==1)
    {
      return 0;
    } 
    if(nums[0]>nums[1])
    {
      return 0;
    }
    if(nums[n-1]>nums[n-2])
    {
      return n-1;
    }
    int left=1;
    int right=n-2;
    while(left<=right)
    {
      int mid=(left+right)/2;
      if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1])
      {
        return mid;
      }
      else if(nums[mid]<nums[mid+1])
      {
        left=mid+1;
      }
      else{
        right=mid-1;
      }
    }
return -1;
    }
};
"
414,cpp,find-peak-element,"class Solution {
public:
    int findPeakElement(vector<int>& nums) {
    int n=nums.size();
    if(n==1)
    {
      return 0;
    } 
    if(nums[0]>nums[1])
    {
      return 0;
    }
    if(nums[n-1]>nums[n-2])
    {
      return n-1;
    }
    int left=1;
    int right=n-2;
    while(left<=right)
    {
      int mid=(left+right)/2;
      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])
      {
        return mid;
      }
      else if(nums[mid]<nums[mid-1])
      {
        left=mid+1;
      }
      else{
        right=mid-1;
      }
    }
return -1;
    }
};",None,"class Solution {
public:
    int findPeakElement(vector<int>& nums) {
    int n=nums.size();
    if(n==1)
    {
      return 0;
    } 
    if(nums[0]>nums[1])
    {
      return 0;
    }
    if(nums[n-1]>nums[n-2])
    {
      return n-1;
    }
    int left=1;
    int right=n-2;
    while(left<=right)
    {
      int mid=(left+right)/2;
      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])
      {
        return mid;
      }
      else if(nums[mid]<nums[mid+1])
      {
        left=mid+1;
      }
      else{
        right=mid-1;
      }
    }
return -1;
    }
};
"
415,cpp,find-the-punishment-number-of-an-integer,"class Solution {
public:
    
    bool valid(int n, string s,int sum){
        if(s=="""") if(sum==n) return true;

        for(int i=1;i<=s.size();i++){
            int x  = stoi(s.substr(0,i));
            if(valid(n, s.substr(i), sum+x)) return false;
        }
        
        return false;
    }
    int punishmentNumber(int n) {
        int ans = 0;

        for(int i=1;i<=n;i++){
            int sq = i*i;
            string x = to_string(sq);
            if(valid(i,x,0)) ans += i*i;
        }
        
        return ans;
        
    }
};",None,"class Solution {
public:
    
    bool valid(int n, string s,int sum){
        if(s=="""") if(sum==n) return true;

        for(int i=1;i<=s.size();i++){
            int x  = stoi(s.substr(0,i));
            if(valid(n, s.substr(i), sum+x)) return true;
        }
        
        return false;
    }
    int punishmentNumber(int n) {
        int ans = 0;

        for(int i=1;i<=n;i++){
            int sq = i*i;
            string x = to_string(sq);
            if(valid(i,x,0)) ans += i*i;
        }
        
        return ans;
        
    }
};
"
415,cpp,find-the-punishment-number-of-an-integer,"class Solution {
public:
    
    bool valid(int n, string s,int sum){
        if(s=="""") if(sum==n) return true;

        for(int i=1;i<=s.size();i++){
            int x  = stoi(s.substr(0,i));
            if(valid(n, s.substr(i), sum+x)) return false;
        }
        
        return false;
    }
    int punishmentNumber(int n) {
        int ans = 0;

        for(int i=1;i<=n;i++){
            int sq = i*i;
            string x = to_string(sq);
            if(valid(i,x,0)) ans += i*i;
        }
        
        return ans;
        
    }
};",None,"class Solution {
public:
    
    bool valid(int n, string s,int sum){
        if(s=="""") return sum==n;

        for(int i=1;i<=s.size();i++){
            int x  = stoi(s.substr(0,i));
            if(valid(n, s.substr(i), sum+x)) return true;
        }
        
        return false;
    }
    int punishmentNumber(int n) {
        int ans = 0;

        for(int i=1;i<=n;i++){
            int sq = i*i;
            string x = to_string(sq);
            if(valid(i,x,0)) ans += i*i;
        }
        
        return ans;
    }
};
"
415,cpp,find-the-punishment-number-of-an-integer,"class Solution {
public:
    
    bool valid(int n, string s,int sum){
        if(s=="""") if(sum==n) return true;

        for(int i=1;i<=s.size();i++){
            int x  = stoi(s.substr(0,i));
            if(valid(n, s.substr(i), sum+x)) return false;
        }
        
        return false;
    }
    int punishmentNumber(int n) {
        int ans = 0;

        for(int i=1;i<=n;i++){
            int sq = i*i;
            string x = to_string(sq);
            if(valid(i,x,0)) ans += i*i;
        }
        
        return ans;
        
    }
};",None,"class Solution {
public:
    
    bool valid(int n, string s,int sum){
        if(s=="""") return sum == n;

        for(int i = 1; i <= s.size(); i++){
            int x  = stoi(s.substr(0,i));
            if(valid(n, s.substr(i), sum+x)) return true;
        }
        
        return false;
    }
    int punishmentNumber(int n) {
        int ans = 0;

        for(int i = 1; i <= n; i++){
            int sq = i * i;
            string x = to_string(sq);
            if(valid(i, x, 0)) ans += i * i;
        }
        
        return ans;
        
    }
};
"
416,cpp,rotate-array,"class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> temp(nums.size());
        for(int i=0;i<n;i++){
            temp[(i+k)%n]=nums[i+1];
        }
        nums=temp;
    }
};",None,"class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> temp(nums.size());
        for(int i = 0; i < n; i++){
            temp[(i + k) % n] = nums[i];
        }
        nums = temp;
    }
};
"
416,cpp,rotate-array,"class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> temp(nums.size());
        for(int i=0;i<n;i++){
            temp[(i+k)%n]=nums[i+1];
        }
        nums=temp;
    }
};",None,"class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> temp(nums.size());
        for(int i=0;i<n;i++){
            temp[(i+k)%n]=nums[i];
        }
        nums=temp;
    }
};
"
416,cpp,rotate-array,"class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> temp(nums.size());
        for(int i=0;i<n;i++){
            temp[(i+k)%n]=nums[i+1];
        }
        nums=temp;
    }
};",None,"class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> temp(nums.size());
        for(int i=0;i<n;i++){
            temp[(i+k)%n]=nums[i];
        }
        nums=temp;
    }
};
"
417,cpp,minimum-time-to-complete-trips,"#define ll long long 
class Solution {
public:
    long long minimumTime(vector<int>& time, int totalTrips) {
        ll l = 1, r = 1e14;
        while(l <= r) {
            ll trip = 0, mid = (l + r) / 2;
            for(int i=0; i<time.size(); i++) trip += mid / time[i];
            if(trip <= totalTrips) l = mid + 1;
            else r = mid - 1;
        }
        return l;
    }
};",None,"#define ll long long 
class Solution {
public:
    long long minimumTime(vector<int>& time, int totalTrips) {
        ll l = 1, r = 1e14;
        while(l < r) {
            ll trip = 0, mid = (l + r) / 2;
            for(int i=0; i<time.size(); i++) trip += mid / time[i];
            if(trip < totalTrips) l = mid + 1;
            else r = mid;
        }
        return l;
    }
};
"
417,cpp,minimum-time-to-complete-trips,"#define ll long long 
class Solution {
public:
    long long minimumTime(vector<int>& time, int totalTrips) {
        ll l = 1, r = 1e14;
        while(l <= r) {
            ll trip = 0, mid = (l + r) / 2;
            for(int i=0; i<time.size(); i++) trip += mid / time[i];
            if(trip <= totalTrips) l = mid + 1;
            else r = mid - 1;
        }
        return l;
    }
};",None,"#define ll long long 
class Solution {
public:
    long long minimumTime(vector<int>& time, int totalTrips) {
        ll l = 1, r = 1e14;
        while(l <= r) {
            ll trip = 0, mid = (l + r) / 2;
            for(int i=0; i<time.size(); i++) trip += mid / time[i];
            if(trip < totalTrips) l = mid + 1;
            else r = mid - 1;
        }
        return l;
    }
};
"
417,cpp,minimum-time-to-complete-trips,"#define ll long long 
class Solution {
public:
    long long minimumTime(vector<int>& time, int totalTrips) {
        ll l = 1, r = 1e14;
        while(l <= r) {
            ll trip = 0, mid = (l + r) / 2;
            for(int i=0; i<time.size(); i++) trip += mid / time[i];
            if(trip <= totalTrips) l = mid + 1;
            else r = mid - 1;
        }
        return l;
    }
};",None,"#define ll long long 
class Solution {
public:
    long long minimumTime(vector<int>& time, int totalTrips) {
        ll l = 1, r = 1e14;
        while(l < r) {
            ll trip = 0, mid = (l + r) / 2;
            for(int i=0; i<time.size(); i++) trip += mid / time[i];
            if(trip < totalTrips) l = mid + 1;
            else r = mid;
        }
        return l;
    }
};
"
418,cpp,moving-stones-until-consecutive-ii,"class Solution {
public:
    vector<int> numMovesStonesII(vector<int>& stones) {
        sort(stones.begin(), stones.end());

        int N = stones.size(), low = N;
        for (int i = 0, j = 0; j < N; ++j) {
            while (stones[j] - stones[i] + 1 > N) {
                ++i;
            }
            if (N - (j - i + 1) == 1 && N - (stones[j] - stones[i] + 1) == 2) {  
                low = min(low, 2);
            } else {
                low = min(low, N - (j - i + 1));
            }
        }

        int high = 1 + max((stones[N - 1] - stones[1] + 1) - N,  
                           (stones[N - 2] - stones[0] + 1) - N);  
        return {low, high};
    }
};",None,"class Solution {
public:
    vector<int> numMovesStonesII(vector<int>& stones) {
        sort(stones.begin(), stones.end());

        int N = stones.size(), low = N;
        for (int i = 0, j = 0; j < N; ++j) {
            while (stones[j] - stones[i] + 1 > N) {
                ++i;
            }
            if (j - i + 1 == N - 1 && stones[j] - stones[i] + 1 == N - 1) {  
                low = min(low, 2);
            } else {
                low = min(low, N - (j - i + 1));
            }
        }

        int high = max((stones[N - 1] - stones[1] + 1) - N + 1,  
                       (stones[N - 2] - stones[0] + 1) - N + 1);  
        return {low, high};
    }
};
"
418,cpp,moving-stones-until-consecutive-ii,"class Solution {
public:
    vector<int> numMovesStonesII(vector<int>& stones) {
        sort(stones.begin(), stones.end());

        int N = stones.size(), low = N;
        for (int i = 0, j = 0; j < N; ++j) {
            while (stones[j] - stones[i] + 1 > N) {
                ++i;
            }
            if (N - (j - i + 1) == 1 && N - (stones[j] - stones[i] + 1) == 2) {  
                low = min(low, 2);
            } else {
                low = min(low, N - (j - i + 1));
            }
        }

        int high = 1 + max((stones[N - 1] - stones[1] + 1) - N,  
                           (stones[N - 2] - stones[0] + 1) - N);  
        return {low, high};
    }
};",None,"class Solution {
public:

    vector<int> numMovesStonesII(vector<int>& stones) {
        sort(stones.begin(), stones.end());

        int n = stones.size(), low = n;
        for (int i = 0, j = 0; j < n; ++j) {
            while (stones[j] - stones[i] + 1 > n) {
                ++i;
            }
            if (j - i + 1 == n - 1 && stones[j] - stones[i] + 1 == n - 1) {
                low = min(low, 2);
            } else {
                low = min(low, n - (j - i + 1));
            }
        }

        int high = max(stones[n - 1] - stones[1] - n + 2, stones[n - 2] - stones[0] - n + 2);
        return {low, high};
    }
};
"
418,cpp,moving-stones-until-consecutive-ii,"class Solution {
public:
    vector<int> numMovesStonesII(vector<int>& stones) {
        sort(stones.begin(), stones.end());

        int N = stones.size(), low = N;
        for (int i = 0, j = 0; j < N; ++j) {
            while (stones[j] - stones[i] + 1 > N) {
                ++i;
            }
            if (N - (j - i + 1) == 1 && N - (stones[j] - stones[i] + 1) == 2) {  
                low = min(low, 2);
            } else {
                low = min(low, N - (j - i + 1));
            }
        }

        int high = 1 + max((stones[N - 1] - stones[1] + 1) - N,  
                           (stones[N - 2] - stones[0] + 1) - N);  
        return {low, high};
    }
};",None,"class Solution {
public:
    vector<int> numMovesStonesII(vector<int>& stones) {
        sort(stones.begin(), stones.end());
        int N = stones.size(), low = N;
        for (int i = 0, j = 0; j < N; ++j) {
            while (stones[j] - stones[i] + 1 > N) {
                ++i;
            }
            if (j - i + 1 == N - 1 && stones[j] - stones[i] + 1 == N - 1) {  
                low = min(low, 2);
            } else {
                low = min(low, N - (j - i + 1));
            }
        }

        int high = max((stones[N - 1] - stones[1] + 1) - N + 1,  
                       (stones[N - 2] - stones[0] + 1) - N + 1);  
        return {low, high};
    }
};
"
419,cpp,minimum-incompatibility,"class Solution {
public:
    const int inf = 0x3f3f3f3f;
    int minimumIncompatibility(vector<int>& nums, int k) {
      int n = nums.size();
      int sz = n/k;
      sort(nums.begin(), nums.end());
      int dp[1<<n][n];
      memset(dp, inf, sizeof(dp));
      for (int i = 0; i < n; ++i) { dp[0][i] = 0; }
      for (int m = 0; m < (1<<n)-1; ++m) {
        int cnt = __builtin_popcount(m);
        for (int i = 0; i < n; ++i) {
          if (dp[m][i] == inf) { continue; }
          if (cnt%sz == 0) {
            int j = __builtin_ffs(~m)-1;
            dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]);
          } else {
            for (int j = i+1; j < n; ++j) {
              if (m&(1<<j) && nums[j] == nums[i]) { continue; } 
              dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]+nums[j]-nums[i]);
            }
          }
        }
      }
      return dp[(1<<n)-1][n-1] == inf? -1: dp[(1<<n)-1][n-1];
    }
};",None,"class Solution {
public:
    const int inf = 0x3f3f3f3f;
    int minimumIncompatibility(vector<int>& nums, int k) {
      int n = nums.size();
      int sz = n/k;
      sort(nums.begin(), nums.end());
      int dp[1<<n][n];
      memset(dp, inf, sizeof(dp));
      for (int i = 0; i < n; ++i) { dp[1<<i][i] = 0; }
      for (int m = 0; m < (1<<n); ++m) {
        int cnt = __builtin_popcount(m);
        for (int i = 0; i < n; ++i) {
          if ((m&(1<<i)) == 0 || dp[m][i] == inf) { continue; }
          if (cnt%sz == 0) {
            int j = __builtin_ffs(~m)-1;
            dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]);
          } else {
            for (int j = i+1; j < n; ++j) {
              if ((m&(1<<j)) || nums[j] == nums[i]) { continue; } 
              dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]+nums[j]-nums[i]);
            }
          }
        }
      }
      int res = inf;
      for (int i = 0; i < n; ++i) { res = min(res, dp[(1<<n)-1][i]); }
      return res == inf? -1: res;
    }
};
"
419,cpp,minimum-incompatibility,"class Solution {
public:
    const int inf = 0x3f3f3f3f;
    int minimumIncompatibility(vector<int>& nums, int k) {
      int n = nums.size();
      int sz = n/k;
      sort(nums.begin(), nums.end());
      int dp[1<<n][n];
      memset(dp, inf, sizeof(dp));
      for (int i = 0; i < n; ++i) { dp[0][i] = 0; }
      for (int m = 0; m < (1<<n)-1; ++m) {
        int cnt = __builtin_popcount(m);
        for (int i = 0; i < n; ++i) {
          if (dp[m][i] == inf) { continue; }
          if (cnt%sz == 0) {
            int j = __builtin_ffs(~m)-1;
            dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]);
          } else {
            for (int j = i+1; j < n; ++j) {
              if (m&(1<<j) && nums[j] == nums[i]) { continue; } 
              dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]+nums[j]-nums[i]);
            }
          }
        }
      }
      return dp[(1<<n)-1][n-1] == inf? -1: dp[(1<<n)-1][n-1];
    }
};",None,M
419,cpp,minimum-incompatibility,"class Solution {
public:
    const int inf = 0x3f3f3f3f;
    int minimumIncompatibility(vector<int>& nums, int k) {
      int n = nums.size();
      int sz = n/k;
      sort(nums.begin(), nums.end());
      int dp[1<<n][n];
      memset(dp, inf, sizeof(dp));
      for (int i = 0; i < n; ++i) { dp[0][i] = 0; }
      for (int m = 0; m < (1<<n)-1; ++m) {
        int cnt = __builtin_popcount(m);
        for (int i = 0; i < n; ++i) {
          if (dp[m][i] == inf) { continue; }
          if (cnt%sz == 0) {
            int j = __builtin_ffs(~m)-1;
            dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]);
          } else {
            for (int j = i+1; j < n; ++j) {
              if (m&(1<<j) && nums[j] == nums[i]) { continue; } 
              dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]+nums[j]-nums[i]);
            }
          }
        }
      }
      return dp[(1<<n)-1][n-1] == inf? -1: dp[(1<<n)-1][n-1];
    }
};",None,"class Solution {
public:
    const int inf = 0x3f3f3f3f;

    int minimumIncompatibility(vector<int>& nums, int k) {
        int n = nums.size();
        int sz = n/k;

        sort(nums.begin(), nums.end());

        vector<vector<int>> dp(1<<n, vector<int>(n, inf));

        for (int i = 0; i < n; ++i) { dp[1<<i][i] = 0; }

        for (int m = 0; m < (1<<n); ++m) {
            int cnt = __builtin_popcount(m);
            for (int i = 0; i < n; ++i) {
                if (m & (1 << i)) {
                    if(dp[m][i] == inf) { continue; }
                    if (cnt % sz == 0) {
                        for (int j = 0; j < n; ++j) {
                            if (!(m&(1<<j))) {
                                dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j], dp[m][i]);
                            }
                        }
                    } else {
                        for (int j = i + 1; j < n; ++j) {
                            if (!(m&(1<<j)) && (i == 0 || nums[j] != nums[i-1])) { 
                                dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j], dp[m][i] + nums[j] - nums[i]);
                            }
                        }
                    }
                }
            }
        }
        int ans = *min_element(dp.back().begin(), dp.back().end());
        return ans == inf? -1 : ans;
    }
};
"
420,cpp,minimum-moves-to-reach-target-with-rotations,"class Solution {
    int n;
    vector<vector<int>> hmemo, vmemo;
    vector<vector<int>> *gridp;

    int dfs(bool h, int r, int c) {
        vector<vector<int>> & grid = *gridp;
        if (h && r == n-1 && c == n-2)
            return 0;
        int res = INT_MAX-1;
        if (h) {
            if (hmemo[r][c] > 0) {
                return hmemo[r][c];
            }
            hmemo[r][c] = INT_MAX-1;
            if (c+2 < n && grid[r][c+2] == 1) {
                res = min(res, 1+dfs(true, r, c+1));
            }
            if (r+1 < n && grid[r+1][c] == 1 && grid[r+1][c+1] == 1) {
                res = min(res, 1+dfs(true, r+1, c));
                res = min(res, 1+dfs(false, r, c));
            }
            hmemo[r][c] = res;
            return res;
        } else {
            if (vmemo[r][c] > 0) {
                return vmemo[r][c];
            }
            vmemo[r][c] = INT_MAX-1;
            if (r+2 < n && grid[r+2][c] == 1) {
                res = min(res, 1+dfs(false, r+1, c));
            }
            if (c+1 < n && grid[r][c+1] == 1 && grid[r+1][c+1] == 1) {
                res = min(res, 1+dfs(false, r, c+1));
                res = min(res, 1+dfs(true, r, c));
            }
            vmemo[r][c] = res;
            return res;
        }
    }

public:
    int minimumMoves(vector<vector<int>>& grid) {
        this->gridp = &grid;
        n = grid.size();
        hmemo = vector<vector<int>>(n, vector<int>(n, -1));
        vmemo = vector<vector<int>>(n, vector<int>(n, -1));
        int res = dfs(true, 0, 0);
        return res < INT_MAX-1 ? res : -1;
    }
};",None,"class Solution {
    int n;
    vector<vector<int>> hmemo, vmemo;
    vector<vector<int>> *gridp;

    int dfs(bool h, int r, int c) {
        vector<vector<int>> & grid = *gridp;
        if (h && r == n-1 && c == n-2)
            return 0;
        int res = INT_MAX-1;
        if (h) {
            if (hmemo[r][c] > 0) {
                return hmemo[r][c]-1;
            }
            hmemo[r][c] = INT_MAX-1;
            if (c+2 < n && grid[r][c+2] == 0) {
                res = min(res, 1+dfs(true, r, c+1));
            }
            if (r+1 < n && grid[r+1][c] == 0 && grid[r+1][c+1] == 0) {
                res = min(res, 1+dfs(true, r+1, c));
                res = min(res, 1+dfs(false, r, c));
            }
            hmemo[r][c] = 1+res;
            return res;
        } else {
            if (vmemo[r][c] > 0) {
                return vmemo[r][c]-1;
            }
            vmemo[r][c] = INT_MAX-1;
            if (r+2 < n && grid[r+2][c] == 0) {
                res = min(res, 1+dfs(false, r+1, c));
            }
            if (c+1 < n && grid[r][c+1] == 0 && grid[r+1][c+1] == 0) {
                res = min(res, 1+dfs(false, r, c+1));
                res = min(res, 1+dfs(true, r, c));
            }
            vmemo[r][c] = 1+res;
            return res;
        }
    }

public:
    int minimumMoves(vector<vector<int>>& grid) {
        this->gridp = &grid;
        n = grid.size();
        hmemo = vector<vector<int>>(n, vector<int>(n, -1));
        vmemo = vector<vector<int>>(n, vector<int>(n, -1));
        int res = dfs(true, 0, 0);
        return res < INT_MAX-1 ? res : -1;
    }
};
"
420,cpp,minimum-moves-to-reach-target-with-rotations,"class Solution {
    int n;
    vector<vector<int>> hmemo, vmemo;
    vector<vector<int>> *gridp;

    int dfs(bool h, int r, int c) {
        vector<vector<int>> & grid = *gridp;
        if (h && r == n-1 && c == n-2)
            return 0;
        int res = INT_MAX-1;
        if (h) {
            if (hmemo[r][c] > 0) {
                return hmemo[r][c];
            }
            hmemo[r][c] = INT_MAX-1;
            if (c+2 < n && grid[r][c+2] == 1) {
                res = min(res, 1+dfs(true, r, c+1));
            }
            if (r+1 < n && grid[r+1][c] == 1 && grid[r+1][c+1] == 1) {
                res = min(res, 1+dfs(true, r+1, c));
                res = min(res, 1+dfs(false, r, c));
            }
            hmemo[r][c] = res;
            return res;
        } else {
            if (vmemo[r][c] > 0) {
                return vmemo[r][c];
            }
            vmemo[r][c] = INT_MAX-1;
            if (r+2 < n && grid[r+2][c] == 1) {
                res = min(res, 1+dfs(false, r+1, c));
            }
            if (c+1 < n && grid[r][c+1] == 1 && grid[r+1][c+1] == 1) {
                res = min(res, 1+dfs(false, r, c+1));
                res = min(res, 1+dfs(true, r, c));
            }
            vmemo[r][c] = res;
            return res;
        }
    }

public:
    int minimumMoves(vector<vector<int>>& grid) {
        this->gridp = &grid;
        n = grid.size();
        hmemo = vector<vector<int>>(n, vector<int>(n, -1));
        vmemo = vector<vector<int>>(n, vector<int>(n, -1));
        int res = dfs(true, 0, 0);
        return res < INT_MAX-1 ? res : -1;
    }
};",None,"class Solution {
    int n;
    vector<vector<int>> hmemo, vmemo;
    vector<vector<int>> *gridp;

    int dfs(bool h, int r, int c) {
        vector<vector<int>> & grid = *gridp;
        if (h && r == n-1 && c == n-2)
            return 0;
        int res = INT_MAX-1;
        if (h) {
            if (hmemo[r][c] > 0) {
                return hmemo[r][c];
            }
            hmemo[r][c] = INT_MAX-1;
            if (c+2 < n && grid[r][c+2] == 0) {
                res = min(res, 1+dfs(true, r, c+1));
            }
            if (r+1 < n && grid[r+1][c] == 0 && grid[r+1][c+1] == 0) {
                res = min(res, 1+dfs(true, r+1, c));
                res = min(res, 1+dfs(false, r, c));
            }
            hmemo[r][c] = res;
            return res;
        } else {
            if (vmemo[r][c] > 0) {
                return vmemo[r][c];
            }
            vmemo[r][c] = INT_MAX-1;
            if (r+2 < n && grid[r+2][c] == 0) {
                res = min(res, 1+dfs(false, r+1, c));
            }
            if (c+1 < n && grid[r][c+1] == 0 && grid[r+1][c+1] == 0) {
                res = min(res, 1+dfs(false, r, c+1));
                res = min(res, 1+dfs(true, r, c));
            }
            vmemo[r][c] = res;
            return res;
        }
    }

public:
    int minimumMoves(vector<vector<int>>& grid) {
        this->gridp = &grid;
        n = grid.size();
        hmemo = vector<vector<int>>(n, vector<int>(n, -1));
        vmemo = vector<vector<int>>(n, vector<int>(n, -1));
        int res = dfs(true, 0, 0);
        return res < INT_MAX-1 ? res : -1;
    }
};
"
420,cpp,minimum-moves-to-reach-target-with-rotations,"class Solution {
    int n;
    vector<vector<int>> hmemo, vmemo;
    vector<vector<int>> *gridp;

    int dfs(bool h, int r, int c) {
        vector<vector<int>> & grid = *gridp;
        if (h && r == n-1 && c == n-2)
            return 0;
        int res = INT_MAX-1;
        if (h) {
            if (hmemo[r][c] > 0) {
                return hmemo[r][c];
            }
            hmemo[r][c] = INT_MAX-1;
            if (c+2 < n && grid[r][c+2] == 1) {
                res = min(res, 1+dfs(true, r, c+1));
            }
            if (r+1 < n && grid[r+1][c] == 1 && grid[r+1][c+1] == 1) {
                res = min(res, 1+dfs(true, r+1, c));
                res = min(res, 1+dfs(false, r, c));
            }
            hmemo[r][c] = res;
            return res;
        } else {
            if (vmemo[r][c] > 0) {
                return vmemo[r][c];
            }
            vmemo[r][c] = INT_MAX-1;
            if (r+2 < n && grid[r+2][c] == 1) {
                res = min(res, 1+dfs(false, r+1, c));
            }
            if (c+1 < n && grid[r][c+1] == 1 && grid[r+1][c+1] == 1) {
                res = min(res, 1+dfs(false, r, c+1));
                res = min(res, 1+dfs(true, r, c));
            }
            vmemo[r][c] = res;
            return res;
        }
    }

public:
    int minimumMoves(vector<vector<int>>& grid) {
        this->gridp = &grid;
        n = grid.size();
        hmemo = vector<vector<int>>(n, vector<int>(n, -1));
        vmemo = vector<vector<int>>(n, vector<int>(n, -1));
        int res = dfs(true, 0, 0);
        return res < INT_MAX-1 ? res : -1;
    }
};",None,"class Solution {
    int n;
    vector<vector<int>> hmemo, vmemo;
    vector<vector<int>> *gridp;

    int dfs(bool h, int r, int c) {
        vector<vector<int>> & grid = *gridp;
        if (h && r == n-1 && c == n-2)
            return 0;
        int res = INT_MAX;
        if (h) {
            if (hmemo[r][c] > 0) {
                return hmemo[r][c];
            }
            hmemo[r][c] = INT_MAX;
            if (c+2 < n && grid[r][c+2] == 0) { // if grid[r][c+2] == 0 then snake can move
                res = min(res, 1+dfs(true, r, c+1));
            }
            if (r+1 < n && grid[r+1][c] == 0 && grid[r+1][c+1] == 0) { // if both cells below are empty, snake can move down or rotate
                res = min(res, 1+dfs(true, r+1, c));
                res = min(res, 1+dfs(false, r, c));
            }
            hmemo[r][c] = min(hmemo[r][c], res);
            return res;
        } else {
            if (vmemo[r][c] > 0) {
                return vmemo[r][c];
            }
            vmemo[r][c] = INT_MAX;
            if (r+2 < n && grid[r+2][c] == 0) { // if grid[r+2][c] == 0 then snake can move
                res = min(res, 1+dfs(false, r+1, c));
            }
            if (c+1 < n && grid[r][c+1] == 0 && grid[r+1][c+1] == 0) { // if both cells to right are empty, snake can move right or rotate
                res = min(res, 1+dfs(false, r, c+1));
                res = min(res, 1+dfs(true, r, c));
            }
            vmemo[r][c] = min(vmemo[r][c], res);
            return res;
        }
    }

public:
    int minimumMoves(vector<vector<int>>& grid) {
        this->gridp = &grid;
        n = grid.size();
        hmemo = vector<vector<int>>(n, vector<int>(n, -1));
        vmemo = vector<vector<int>>(n, vector<int>(n, -1));
        int res = dfs(true, 0, 0);
        return res < INT_MAX ? res : -1;
    }
};
"
421,cpp,find-the-winner-of-the-circular-game,"class Solution {
public:
    int findTheWinner(int n, int k) {
        queue<int> q;
        for(int i=1;i<=n;i++){
            q.push(i);
        }
        while(q.size()!=1){
            int temp=k-1;
            while(temp>=0){
                int t=q.front();
                q.pop();
                q.push(t);
                temp--;
            }
            q.pop();
        }
        return q.front();
    }
};",None,"class Solution {
public:
    int findTheWinner(int n, int k) {
        queue<int> q;
        for(int i=1;i<=n;i++){
            q.push(i);
        }
        while(q.size()!=1){
            int temp=k-1;
            while(temp>0){
                int t=q.front();
                q.pop();
                q.push(t);
                temp--;
            }
            q.pop();
        }
        return q.front();
    }
};
"
421,cpp,find-the-winner-of-the-circular-game,"class Solution {
public:
    int findTheWinner(int n, int k) {
        queue<int> q;
        for(int i=1;i<=n;i++){
            q.push(i);
        }
        while(q.size()!=1){
            int temp=k-1;
            while(temp>=0){
                int t=q.front();
                q.pop();
                q.push(t);
                temp--;
            }
            q.pop();
        }
        return q.front();
    }
};",None,"class Solution {
public:
    int findTheWinner(int n, int k) {
        queue<int> q;
        for(int i=1;i<=n;i++){
            q.push(i);
        }
        while(q.size()!=1){
            int temp=k-1;
            while(temp--){
                int t=q.front();
                q.pop();
                q.push(t);
            }
            q.pop();
        }
        return q.front();
    }
};
"
421,cpp,find-the-winner-of-the-circular-game,"class Solution {
public:
    int findTheWinner(int n, int k) {
        queue<int> q;
        for(int i=1;i<=n;i++){
            q.push(i);
        }
        while(q.size()!=1){
            int temp=k-1;
            while(temp>=0){
                int t=q.front();
                q.pop();
                q.push(t);
                temp--;
            }
            q.pop();
        }
        return q.front();
    }
};",None,"class Solution {
public:
    int findTheWinner(int n, int k) {
        queue<int> q;
        for(int i=1;i<=n;i++){
            q.push(i);
        }
        while(q.size()!=1){
            int temp=k-1;
            while(temp>0){
                int t=q.front();
                q.pop();
                q.push(t);
                temp--;
            }
            q.pop();
        }
        return q.front();
    }
};
"
422,cpp,minimum-operations-to-make-the-array-increasing,"class Solution {
public:
    int minOperations(vector<int>& nums) {
       int count = 0; 
       for(int i=0; i<nums.size(); i++) if(nums[i] <= nums[i+1]) { count += nums[i+1]+1-nums[i]; nums[i] = nums[i+1]+1; }

       return count; 
    }
};",None,"class Solution {
public:
    int minOperations(vector<int>& nums) {
       int count = 0; 
       for(int i=0; i<nums.size()-1; i++) if(nums[i] >= nums[i+1]) { count += nums[i]+1-nums[i+1]; nums[i+1] = nums[i]+1; }

       return count; 
    }
};
"
422,cpp,minimum-operations-to-make-the-array-increasing,"class Solution {
public:
    int minOperations(vector<int>& nums) {
       int count = 0; 
       for(int i=0; i<nums.size(); i++) if(nums[i] <= nums[i+1]) { count += nums[i+1]+1-nums[i]; nums[i] = nums[i+1]+1; }

       return count; 
    }
};",None,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int count = 0; 
        for(int i=0; i<nums.size()-1; i++) {
            if(nums[i] >= nums[i+1]) {
                count += nums[i]+1-nums[i+1]; 
                nums[i+1] = nums[i]+1;
            }
        }
        return count;
    }
};
"
422,cpp,minimum-operations-to-make-the-array-increasing,"class Solution {
public:
    int minOperations(vector<int>& nums) {
       int count = 0; 
       for(int i=0; i<nums.size(); i++) if(nums[i] <= nums[i+1]) { count += nums[i+1]+1-nums[i]; nums[i] = nums[i+1]+1; }

       return count; 
    }
};",None,"class Solution {
public:
    int minOperations(vector<int>& nums) {
       int count = 0; 
       for(int i=0; i<nums.size() - 1; i++) {
           if(nums[i] >= nums[i+1]) {
               count += nums[i] + 1 - nums[i + 1];
               nums[i + 1] = nums[i] + 1;
           }
       }
       return count;
    }
};
"
423,cpp,k-closest-points-to-origin,"class Solution {
    class info{
        public:
        int x;
        int y;
        float distance; 
        info(int a , int b)
        {
            x = a;
            y = b;
            distance = sqrt (x*x + y*y);
        }
    };
class compare{
   public:
   bool operator()(info* point1 , info* point2)
   {
       if( point1->distance >= point2->distance)
       {
           return true;
       }
       else{
           return false;
       }
   }
};
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        priority_queue<info*,vector<info*>,compare> minheap;
        for( int i = 0 ; i < points.size() ; i ++)
        {
            int x1 = points[i][0];
            int y1 = points[i][1];
            info* newinfo = new info(x1,y1);
            minheap.push(newinfo);
        }
        vector<vector<int>> ans;
        while(k > 0)
        {
            info* temp = minheap.top();
            minheap.pop();
            int xval = temp->x;
            int yval = temp->y;
            vector<int> temp2 ;
            temp2.push_back(xval);
            temp2.push_back(yval);
            ans.push_back(temp2);
            k--;
        }
        return ans;
    }
};",None,"class Solution {
    class info{
        public:
        int x;
        int y;
        float distance; 
        info(int a , int b)
        {
            x = a;
            y = b;
            distance = sqrt (x*x + y*y);
        }
    };
class compare{
   public:
   bool operator()(info* point1 , info* point2)
   {
       if( point1->distance > point2->distance)
       {
           return true;
       }
       else{
           return false;
       }
   }
};
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        priority_queue<info*,vector<info*>,compare> minheap;
        for( int i = 0 ; i < points.size() ; i ++)
        {
            int x1 = points[i][0];
            int y1 = points[i][1];
            info* newinfo = new info(x1,y1);
            if(minheap.size() == k) {
                if(minheap.top()->distance > newinfo->distance) {
                    minheap.pop();
                    minheap.push(newinfo);
                }
            }
            else
                minheap.push(newinfo);
        }
        vector<vector<int>> ans;
        while(!minheap.empty())
        {
            info* temp = minheap.top();
            minheap.pop();
            int xval = temp->x;
            int yval = temp->y;
            vector<int> temp2 ;
            temp2.push_back(xval);
            temp2.push_back(yval);
            ans.push_back(temp2);
        }
        return ans;
    }
};
"
423,cpp,k-closest-points-to-origin,"class Solution {
    class info{
        public:
        int x;
        int y;
        float distance; 
        info(int a , int b)
        {
            x = a;
            y = b;
            distance = sqrt (x*x + y*y);
        }
    };
class compare{
   public:
   bool operator()(info* point1 , info* point2)
   {
       if( point1->distance >= point2->distance)
       {
           return true;
       }
       else{
           return false;
       }
   }
};
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        priority_queue<info*,vector<info*>,compare> minheap;
        for( int i = 0 ; i < points.size() ; i ++)
        {
            int x1 = points[i][0];
            int y1 = points[i][1];
            info* newinfo = new info(x1,y1);
            minheap.push(newinfo);
        }
        vector<vector<int>> ans;
        while(k > 0)
        {
            info* temp = minheap.top();
            minheap.pop();
            int xval = temp->x;
            int yval = temp->y;
            vector<int> temp2 ;
            temp2.push_back(xval);
            temp2.push_back(yval);
            ans.push_back(temp2);
            k--;
        }
        return ans;
    }
};",None,"class Solution {
    class info{
        public:
        int x;
        int y;
        float distance; 
        info(int a , int b)
        {
            x = a;
            y = b;
            distance = sqrt (x*x + y*y);
        }
    };
class compare{
   public:
   bool operator()(info* point1 , info* point2)
   {
       if( point1->distance > point2->distance)
       {
           return true;
       }
       else{
           return false;
       }
   }
};
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        priority_queue<info*,vector<info*>,compare> minheap;
        for( int i = 0 ; i < points.size() ; i ++)
        {
            int x1 = points[i][0];
            int y1 = points[i][1];
            info* newinfo = new info(x1,y1);
            if(minheap.size() < k){
                minheap.push(newinfo);
            }else if(minheap.top()->distance > newinfo->distance)
            {
                minheap.pop();
                minheap.push(newinfo);
            }
        }
        vector<vector<int>> ans;
        while(!minheap.empty())
        {
            info* temp = minheap.top();
            minheap.pop();
            int xval = temp->x;
            int yval = temp->y;
            vector<int> temp2 ;
            temp2.push_back(xval);
            temp2.push_back(yval);
            ans.push_back(temp2);
        }
        return ans;
    }
};
"
423,cpp,k-closest-points-to-origin,"class Solution {
    class info{
        public:
        int x;
        int y;
        float distance; 
        info(int a , int b)
        {
            x = a;
            y = b;
            distance = sqrt (x*x + y*y);
        }
    };
class compare{
   public:
   bool operator()(info* point1 , info* point2)
   {
       if( point1->distance >= point2->distance)
       {
           return true;
       }
       else{
           return false;
       }
   }
};
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        priority_queue<info*,vector<info*>,compare> minheap;
        for( int i = 0 ; i < points.size() ; i ++)
        {
            int x1 = points[i][0];
            int y1 = points[i][1];
            info* newinfo = new info(x1,y1);
            minheap.push(newinfo);
        }
        vector<vector<int>> ans;
        while(k > 0)
        {
            info* temp = minheap.top();
            minheap.pop();
            int xval = temp->x;
            int yval = temp->y;
            vector<int> temp2 ;
            temp2.push_back(xval);
            temp2.push_back(yval);
            ans.push_back(temp2);
            k--;
        }
        return ans;
    }
};",None,"class Solution {
    class info{
        public:
        int x;
        int y;
        float distance; 
        info(int a , int b)
        {
            x = a;
            y = b;
            distance = sqrt (x*x + y*y);
        }
    };
    class compare{
    public:
    bool operator()(info* point1 , info* point2)
    {
        if( point1->distance > point2->distance)
        {
            return true;
        }
        else{
            return false;
        }
    }
};

public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        priority_queue<info*,vector<info*>,compare> minheap;
        for( int i = 0 ; i < points.size() ; i ++)
        {
            int x1 = points[i][0];
            int y1 = points[i][1];
            info* newinfo = new info(x1,y1);
            while(minheap.size() > k) minheap.pop();
            minheap.push(newinfo);
            if(minheap.size() > k) minheap.pop();
        }
        vector<vector<int>> ans;
        while(k > 0)
        {
            info* temp = minheap.top();
            minheap.pop();
            int xval = temp->x;
            int yval = temp->y;
            vector<int> temp2 ;
            temp2.push_back(xval);
            temp2.push_back(yval);
            ans.push_back(temp2);
            k--;
        }
        return ans;
    }
};
"
424,cpp,most-beautiful-item-for-each-query,"class Solution {
    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {
        int ans = 0, s = 0, e = items.size() - 1;
        while(s <= e) {
            int m = (s + e) / 2;
            if(items[m][0] <= t) ans = beauty[m], s = m + 1;
            else s = m + 1; 
        }
        return ans;
    }

public:
    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {
        sort(items.begin(), items.end());
        vector<int> ans, beauty(items.size(), items[0][1]);

        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);

        for(int i : queries) ans.push_back(bs(items, i, beauty));
        return ans;
    }
};",None,"class Solution {
    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {
        int ans = 0, s = 0, e = items.size() - 1;
        while(s <= e) {
            int m = (s + e) / 2;
            if(items[m][0] <= t) ans = beauty[m], s = m + 1;
            else e = m - 1; 
        }
        return ans;
    }

public:
    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {
        sort(items.begin(), items.end());
        vector<int> ans, beauty(items.size(), items[0][1]);

        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);

        for(int i : queries) ans.push_back(bs(items, i, beauty));
        return ans;
    }
};
"
424,cpp,most-beautiful-item-for-each-query,"class Solution {
    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {
        int ans = 0, s = 0, e = items.size() - 1;
        while(s <= e) {
            int m = (s + e) / 2;
            if(items[m][0] <= t) ans = beauty[m], s = m + 1;
            else s = m + 1; 
        }
        return ans;
    }

public:
    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {
        sort(items.begin(), items.end());
        vector<int> ans, beauty(items.size(), items[0][1]);

        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);

        for(int i : queries) ans.push_back(bs(items, i, beauty));
        return ans;
    }
};",None,"class Solution {
    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {
        int ans = 0, s = 0, e = items.size() - 1;
        while(s <= e) {
            int m = (s + e) / 2;
            if(items[m][0] <= t) ans = beauty[m], s = m + 1;
            else e = m - 1; 
        }
        return ans;
    }

public:
    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {
        sort(items.begin(), items.end());
        vector<int> ans, beauty(items.size(), items[0][1]);

        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);

        for(int i : queries) ans.push_back(bs(items, i, beauty));
        return ans;
    }
};
"
424,cpp,most-beautiful-item-for-each-query,"class Solution {
    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {
        int ans = 0, s = 0, e = items.size() - 1;
        while(s <= e) {
            int m = (s + e) / 2;
            if(items[m][0] <= t) ans = beauty[m], s = m + 1;
            else s = m + 1; 
        }
        return ans;
    }

public:
    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {
        sort(items.begin(), items.end());
        vector<int> ans, beauty(items.size(), items[0][1]);

        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);

        for(int i : queries) ans.push_back(bs(items, i, beauty));
        return ans;
    }
};",None,"class Solution {
    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {
        int ans = 0, s = 0, e = items.size() - 1;
        while(s <= e) {
            int m = (s + e) / 2;
            if(items[m][0] <= t) ans = beauty[m], s = m + 1;
            else e = m - 1; 
        }
        return ans;
    }

public:
    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {
        sort(items.begin(), items.end());
        vector<int> ans, beauty(items.size(), items[0][1]);

        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);

        for(int i : queries) ans.push_back(bs(items, i, beauty));
        return ans;
    }
};
"
425,cpp,sort-list,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        vector<int>vec1;
    ListNode*temp= head;
    while(temp!=NULL){
vec1.push_back(temp->val);
temp= temp->next;
    }
    sort(vec1.begin(),vec1.end());
    ListNode*curr= head;
   for(int i=0;i<vec1.size();i++){
       curr->val=vec1[i+1];
       curr= curr->next;
   }
   return head;
    }
    

};",None,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        vector<int>vec1;
        ListNode*temp= head;
        while(temp!=NULL){
            vec1.push_back(temp->val);
            temp= temp->next;
        }
        sort(vec1.begin(),vec1.end());
        ListNode*curr= head;
        for(int i=0;i<vec1.size();i++){
            curr->val=vec1[i];
            curr= curr->next;
        }
        return head;
    }
};
"
425,cpp,sort-list,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        vector<int>vec1;
    ListNode*temp= head;
    while(temp!=NULL){
vec1.push_back(temp->val);
temp= temp->next;
    }
    sort(vec1.begin(),vec1.end());
    ListNode*curr= head;
   for(int i=0;i<vec1.size();i++){
       curr->val=vec1[i+1];
       curr= curr->next;
   }
   return head;
    }
    

};",None,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if(!head || !head->next) //checking if linked list is already sorted or empty
            return head;

        vector<int>vec1;
        ListNode* temp= head;

        while(temp != NULL){
            vec1.push_back(temp->val);
            temp= temp->next;
        }

        sort(vec1.begin(), vec1.end());

        temp = head;
        int i = 0;
        while(temp != NULL) {   
            temp->val = vec1[i];
            temp = temp->next;
            i++;
        }

        return head;
    }
};
"
425,cpp,sort-list,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        vector<int>vec1;
    ListNode*temp= head;
    while(temp!=NULL){
vec1.push_back(temp->val);
temp= temp->next;
    }
    sort(vec1.begin(),vec1.end());
    ListNode*curr= head;
   for(int i=0;i<vec1.size();i++){
       curr->val=vec1[i+1];
       curr= curr->next;
   }
   return head;
    }
    

};",None,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        vector<int> vec1;
        ListNode* temp = head;
        while(temp != NULL){
            vec1.push_back(temp->val);
            temp = temp->next;
        }
        sort(vec1.begin(), vec1.end());
        ListNode* curr = head;
        for(int i = 0; i < vec1.size(); i++){
            curr->val = vec1[i];
            curr = curr->next;
        }
        return head;
    }

};
"
426,cpp,find-the-minimum-and-maximum-number-of-nodes-between-critical-points,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        ios_base::sync_with_stdio(false);
 if(head==NULL || head->next==NULL ||head->next->next==NULL){
     return {-1,-1};
 }
        ListNode* temp2=head->next;
        ListNode* temp3=head->next->next;
      vector<int>v;
      int i=2;
      while(head){
          if((head->val<temp2->val)&&(temp3->val<temp2->val)){
              v.push_back(i);
          }
          else if((head->val>temp2->val)&&(temp3->val>temp2->val)){
              v.push_back(i);
          }
          i++;
          head=head->next;
          temp2=temp2->next;
          temp3=temp3->next;
      }
      if(v.size()<2){
           return {-1,-1};
      }
      int mini=INT_MAX;
      for(int i=1;i<v.size();i++){
          mini=min(mini,(v[i]-v[i-1]));
      }
        return {mini,(v[v.size()-1]-v[0])};
    }
};",None,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        ios_base::sync_with_stdio(false);
        if(head==NULL || head->next==NULL ||head->next->next==NULL){
            return {-1,-1};
        }
        ListNode* temp1=head;
        ListNode* temp2=head->next;
        ListNode* temp3=head->next->next;
        vector<int>v;
        int i=2;
        while(temp3){
            if((temp1->val<temp2->val)&&(temp2->val>temp3->val)){
                v.push_back(i);
            }
            else if((temp1->val>temp2->val)&&(temp2->val<temp3->val)){
                v.push_back(i);
            }
            i++;
            temp1 = temp1->next;
            temp2 = temp2->next;
            temp3 = temp3->next;
        }
        if(v.size()<2){
            return {-1,-1};
        }
        int mini=INT_MAX;
        for(int i=1;i<v.size();i++){
            mini=min(mini,(v[i]-v[i-1]));
        }
        return {mini,(v[v.size()-1]-v[0])};
    }
};
"
426,cpp,find-the-minimum-and-maximum-number-of-nodes-between-critical-points,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        ios_base::sync_with_stdio(false);
 if(head==NULL || head->next==NULL ||head->next->next==NULL){
     return {-1,-1};
 }
        ListNode* temp2=head->next;
        ListNode* temp3=head->next->next;
      vector<int>v;
      int i=2;
      while(head){
          if((head->val<temp2->val)&&(temp3->val<temp2->val)){
              v.push_back(i);
          }
          else if((head->val>temp2->val)&&(temp3->val>temp2->val)){
              v.push_back(i);
          }
          i++;
          head=head->next;
          temp2=temp2->next;
          temp3=temp3->next;
      }
      if(v.size()<2){
           return {-1,-1};
      }
      int mini=INT_MAX;
      for(int i=1;i<v.size();i++){
          mini=min(mini,(v[i]-v[i-1]));
      }
        return {mini,(v[v.size()-1]-v[0])};
    }
};",None,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        ios_base::sync_with_stdio(false);
        if(head==NULL || head->next==NULL || head->next->next==NULL){
            return {-1,-1};
        }
        ListNode* temp1 = head;
        ListNode* temp2 = head->next;
        ListNode* temp3 = head->next->next;
        vector<int>v;
        int i = 2;
        while(temp3){
            if((temp1->val<temp2->val)&&(temp3->val<temp2->val)){
                v.push_back(i);
            }
            else if((temp1->val>temp2->val)&&(temp3->val>temp2->val)){
                v.push_back(i);
            }
            i++;
            temp1 = temp1->next;
            temp2 = temp2->next;
            temp3 = temp3->next;
        }
        if(v.size()<2){
            return {-1,-1};
        }
        int mini = INT_MAX;
        for(int i=1;i<v.size();i++){
            mini = min(mini,(v[i]-v[i-1]));
        }
        return {mini,(v[v.size()-1]-v[0])};
    }
};
"
426,cpp,find-the-minimum-and-maximum-number-of-nodes-between-critical-points,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        ios_base::sync_with_stdio(false);
 if(head==NULL || head->next==NULL ||head->next->next==NULL){
     return {-1,-1};
 }
        ListNode* temp2=head->next;
        ListNode* temp3=head->next->next;
      vector<int>v;
      int i=2;
      while(head){
          if((head->val<temp2->val)&&(temp3->val<temp2->val)){
              v.push_back(i);
          }
          else if((head->val>temp2->val)&&(temp3->val>temp2->val)){
              v.push_back(i);
          }
          i++;
          head=head->next;
          temp2=temp2->next;
          temp3=temp3->next;
      }
      if(v.size()<2){
           return {-1,-1};
      }
      int mini=INT_MAX;
      for(int i=1;i<v.size();i++){
          mini=min(mini,(v[i]-v[i-1]));
      }
        return {mini,(v[v.size()-1]-v[0])};
    }
};",None,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        ios_base::sync_with_stdio(false);
        if(head==NULL || head->next==NULL ||head->next->next==NULL){
            return {-1,-1};
        }
        ListNode* temp2=head->next;
        ListNode* temp3=head->next->next;
        vector<int>v;
        int i=2;
        while(temp3){
            if((head->val<temp2->val)&&(temp3->val<temp2->val)){
                v.push_back(i);
            }
            else if((head->val>temp2->val)&&(temp3->val>temp2->val)){
                v.push_back(i);
            }
            i++;
            head=head->next;
            temp2=temp2->next;
            temp3=temp3->next;
        }
        if(v.size()<2){
            return {-1,-1};
        }
        int mini=INT_MAX;
        for(int i=1;i<v.size();i++){
            mini=min(mini,(v[i]-v[i-1]));
        }
        return {mini,(v[v.size()-1]-v[0])};
    }
};
"
427,cpp,find-the-student-that-will-replace-the-chalk,"class Solution {
public:
    int chalkReplacer(vector<int>& chalk, int k) {
       long long sum =0;
       for(int i=0; i<chalk.size();i++){
           sum+=chalk[i];
       }

       if(k%sum == 0){
           int x = k%sum;
           for(int i=0; i<chalk.size();i++){
               x-=chalk[i];
               if(x<0){
                   return i;
                   break;
               }
           }
       }

       return 0;
    }
};",None,"class Solution {
public:
    int chalkReplacer(vector<int>& chalk, int k) {
       long long sum =0;
       for(int i=0; i<chalk.size();i++){
           sum+=chalk[i];
       }

       int x = k % sum;
       for(int i=0; i<chalk.size();i++){
           if(x < chalk[i]){
               return i;
           }
           x -= chalk[i];
       }
       
       return 0;
    }
}; 
"
427,cpp,find-the-student-that-will-replace-the-chalk,"class Solution {
public:
    int chalkReplacer(vector<int>& chalk, int k) {
       long long sum =0;
       for(int i=0; i<chalk.size();i++){
           sum+=chalk[i];
       }

       if(k%sum == 0){
           int x = k%sum;
           for(int i=0; i<chalk.size();i++){
               x-=chalk[i];
               if(x<0){
                   return i;
                   break;
               }
           }
       }

       return 0;
    }
};",None,"class Solution {
public:
    int chalkReplacer(vector<int>& chalk, int k) {
        long long sum = 0;
        for(int i = 0; i < chalk.size(); i++) {
            sum += chalk[i];
        }
        
        int remainder = k % sum;
        for(int i = 0; i < chalk.size(); i++){
            remainder -= chalk[i];
            if(remainder < 0){
                return i;
            }
        }
        return 0;
    }
};
"
427,cpp,find-the-student-that-will-replace-the-chalk,"class Solution {
public:
    int chalkReplacer(vector<int>& chalk, int k) {
       long long sum =0;
       for(int i=0; i<chalk.size();i++){
           sum+=chalk[i];
       }

       if(k%sum == 0){
           int x = k%sum;
           for(int i=0; i<chalk.size();i++){
               x-=chalk[i];
               if(x<0){
                   return i;
                   break;
               }
           }
       }

       return 0;
    }
};",None,"class Solution {
public:
    int chalkReplacer(vector<int>& chalk, int k) {
       long long sum = 0;
       for(int i=0; i<chalk.size();i++){
           sum+=chalk[i];
       }

       int x = k % sum;
       for(int i=0; i<chalk.size();i++){
           x-=chalk[i];
           if(x < 0){
               return i;
           }
       }

       return 0;
    }
};
"
428,cpp,extra-characters-in-a-string,"class Solution {
public:
    int rec(int ind,string &s,set<string>&st,vector<int>&dp)
    {
        if (ind==s.size()) return 0;
        if (dp[ind]!=-1) return dp[ind];
        int ans=s.size()-ind;
        for (int i=ind;i<s.size();i++)
        {
           string temp=s.substr(ind,i-ind+1);
           if (st.find(temp)!=st.end())
           {
              ans=min(ans,rec(i+1,s,st,dp));
           }
        }
        ans=min(ans,rec(ind,s,st,dp)); 
        return dp[ind]=ans;
    }
    int minExtraChar(string s, vector<string>& dictionary) 
    {
        set<string>st;
        int n=s.size();
        vector<int>dp(n,-1);
        for (auto it:dictionary)
        {
            st.insert(it);
        }
        return rec(0,s,st,dp);
    }
};",None,"class Solution {
public:
    int rec(int ind, string &s, set<string>&st, vector<int>&dp)
    {
        if (ind==s.size()) return 0;
        if (dp[ind]!=-1) return dp[ind];
        int ans=s.size()-ind;
        for (int i=ind;i<s.size();i++)
        {
           string temp=s.substr(ind,i-ind+1);
           if (st.find(temp)!=st.end())
           {
              ans=min(ans,rec(i+1,s,st,dp));
           }
        }
        return dp[ind]=ans;
    }
    int minExtraChar(string s, vector<string>& dictionary) 
    {
        set<string>st;
        int n=s.size();
        vector<int>dp(n,-1);
        for (auto it:dictionary)
        {
            st.insert(it);
        }
        return rec(0,s,st,dp);
    }
};
"
428,cpp,extra-characters-in-a-string,"class Solution {
public:
    int rec(int ind,string &s,set<string>&st,vector<int>&dp)
    {
        if (ind==s.size()) return 0;
        if (dp[ind]!=-1) return dp[ind];
        int ans=s.size()-ind;
        for (int i=ind;i<s.size();i++)
        {
           string temp=s.substr(ind,i-ind+1);
           if (st.find(temp)!=st.end())
           {
              ans=min(ans,rec(i+1,s,st,dp));
           }
        }
        ans=min(ans,rec(ind,s,st,dp)); 
        return dp[ind]=ans;
    }
    int minExtraChar(string s, vector<string>& dictionary) 
    {
        set<string>st;
        int n=s.size();
        vector<int>dp(n,-1);
        for (auto it:dictionary)
        {
            st.insert(it);
        }
        return rec(0,s,st,dp);
    }
};",None,"class Solution {
public:
    int rec(int ind, string &s, set<string>&st, vector<int>&dp)
    {
        if (ind==s.size()) return 0;
        if (dp[ind]!=-1) return dp[ind];
        int ans=s.size()-ind;
        for (int i=ind;i<s.size();i++)
        {
           string temp=s.substr(ind,i-ind+1);
           if (st.find(temp)!=st.end())
           {
              ans=min(ans,1+rec(i+1,s,st,dp));
           }
        }
        return dp[ind]=ans;
    }
    int minExtraChar(string s, vector<string>& dictionary) 
    {
        set<string>st;
        int n=s.size();
        vector<int>dp(n,-1);
        for (auto it:dictionary)
        {
            st.insert(it);
        }
        return rec(0,s,st,dp);
    }
};
"
428,cpp,extra-characters-in-a-string,"class Solution {
public:
    int rec(int ind,string &s,set<string>&st,vector<int>&dp)
    {
        if (ind==s.size()) return 0;
        if (dp[ind]!=-1) return dp[ind];
        int ans=s.size()-ind;
        for (int i=ind;i<s.size();i++)
        {
           string temp=s.substr(ind,i-ind+1);
           if (st.find(temp)!=st.end())
           {
              ans=min(ans,rec(i+1,s,st,dp));
           }
        }
        ans=min(ans,rec(ind,s,st,dp)); 
        return dp[ind]=ans;
    }
    int minExtraChar(string s, vector<string>& dictionary) 
    {
        set<string>st;
        int n=s.size();
        vector<int>dp(n,-1);
        for (auto it:dictionary)
        {
            st.insert(it);
        }
        return rec(0,s,st,dp);
    }
};",None,"class Solution {
public:

    int rec(int ind, string &s, set<string> &st, vector<int> &dp)
    {
        if (ind == s.size()) return 0;
        if (dp[ind] != -1) return dp[ind];
        int ans = s.size() - ind;
        for (int i = ind; i < s.size(); i++)
        {
            string temp = s.substr(ind, i-ind+1);
            if (st.find(temp) != st.end())
            {
                ans = min(ans, rec(i + 1, s, st, dp) + ind + temp.size() - i - 1);
            }
        }
        return dp[ind] = ans;
    }

    int minExtraChar(string s, vector<string> &dictionary)
    {
        set<string> st;
        int n = s.size();
        vector<int> dp(n, -1);
        for (auto it: dictionary)
        {
            st.insert(it);
        }
        return rec(0, s, st, dp);
    }
};
"
429,cpp,number-of-provinces,"class Solution {
    int res,c = 0,n,vis[201]={0};
    void dfs(vector<vector<int>>& isConnected,int start)
    {
        vis[start] = true;c++;
        for(int connection = 0;connection<n;connection++)
        {
            if(!vis[connection] and isConnected[start][connection]) dfs(isConnected,connection);
        }
    }
public:
    int findCircleNum(vector<vector<int>>& isConnected)
     {
        n = isConnected.size();
        for(int i = 0;i<=n;i++) if(!vis[i]) c=0,dfs(isConnected,i),res++;;
        return res;   
    }
};",None,"class Solution {
    int res = 0, c = 0, n, vis[201] = {0};
    void dfs(vector<vector<int>>& isConnected, int start)
    {
        vis[start] = true; c++;
        for(int connection = 0; connection < n; connection++)
        {
            if(!vis[connection] and isConnected[start][connection]) dfs(isConnected, connection);
        }
    }
public:
    int findCircleNum(vector<vector<int>>& isConnected)
     {
        n = isConnected.size();
        for(int i = 0; i < n; i++) if(!vis[i]) { c=0; dfs(isConnected, i); res++; }
        return res;   
    }
};
"
429,cpp,number-of-provinces,"class Solution {
    int res,c = 0,n,vis[201]={0};
    void dfs(vector<vector<int>>& isConnected,int start)
    {
        vis[start] = true;c++;
        for(int connection = 0;connection<n;connection++)
        {
            if(!vis[connection] and isConnected[start][connection]) dfs(isConnected,connection);
        }
    }
public:
    int findCircleNum(vector<vector<int>>& isConnected)
     {
        n = isConnected.size();
        for(int i = 0;i<=n;i++) if(!vis[i]) c=0,dfs(isConnected,i),res++;;
        return res;   
    }
};",None,"class Solution {
    int res = 0,c = 0,n,vis[201]={0};
    void dfs(vector<vector<int>>& isConnected,int start)
    {
        vis[start] = true;c++;
        for(int connection = 0;connection<n;connection++)
        {
            if(!vis[connection] and isConnected[start][connection]) dfs(isConnected,connection);
        }
    }
public:
    int findCircleNum(vector<vector<int>>& isConnected)
     {
        n = isConnected.size();
        for(int i = 0;i<n;i++) if(!vis[i]) c=0,dfs(isConnected,i),res++;
        return res;   
    }
};
"
429,cpp,number-of-provinces,"class Solution {
    int res,c = 0,n,vis[201]={0};
    void dfs(vector<vector<int>>& isConnected,int start)
    {
        vis[start] = true;c++;
        for(int connection = 0;connection<n;connection++)
        {
            if(!vis[connection] and isConnected[start][connection]) dfs(isConnected,connection);
        }
    }
public:
    int findCircleNum(vector<vector<int>>& isConnected)
     {
        n = isConnected.size();
        for(int i = 0;i<=n;i++) if(!vis[i]) c=0,dfs(isConnected,i),res++;;
        return res;   
    }
};",None,"class Solution {
    int res = 0,c = 0,n;
    vector<int> vis; 
    void dfs(vector<vector<int>>& isConnected,int start)
    {
        vis[start] = true;c++;
        for(int connection = 0;connection<n;connection++)
        {
            if(!vis[connection] and isConnected[start][connection]) dfs(isConnected,connection);
        }
    }
public:
    int findCircleNum(vector<vector<int>>& isConnected)
     {
        n = isConnected.size();
        vis.resize(n, 0);
        for(int i = 0;i<n;i++) {
            if(!vis[i]) {
                c=0;
                dfs(isConnected,i);
                res++;
            }
        }
        return res;   
    }
};
"
430,cpp,find-the-smallest-divisor-given-a-threshold,"class Solution {
public:

    int SumOfDivisor(vector<int>& nums, int Day){
        int sum = 0;
        for(int i = 1;i<nums.size();i++){
            sum += ceil((double)nums[i]/(double)(Day));
        }
        return sum;
    }
    int smallestDivisor(vector<int>& nums, int threshold) {
        int maxi = INT_MIN;
        for(int i = 0;i<nums.size();i++){
            maxi = max(maxi,nums[i]);
        }
        int low = 1,high = maxi,ans = -1;
        while(low <= high){
            int mid = (low + high)/2;
            if(SumOfDivisor(nums,mid) <= threshold){
                ans = mid;
                high = mid - 1;
            }
            else{
                low = mid + 1;
            }
        }
        return ans;
    }
};",None,"class Solution {
public:

    int SumOfDivisor(vector<int>& nums, int Day){
        int sum = 0;
        for(int i = 0;i<nums.size();i++){
            sum += ceil((double)nums[i]/(double)(Day));
        }
        return sum;
    }
    int smallestDivisor(vector<int>& nums, int threshold) {
        int maxi = INT_MIN;
        for(int i = 0;i<nums.size();i++){
            maxi = max(maxi,nums[i]);
        }
        int low = 1,high = maxi,ans = -1;
        while(low <= high){
            int mid = (low + high)/2;
            if(SumOfDivisor(nums,mid) <= threshold){
                ans = mid;
                high = mid - 1;
            }
            else{
                low = mid + 1;
            }
        }
        return ans;
    }
};
"
430,cpp,find-the-smallest-divisor-given-a-threshold,"class Solution {
public:

    int SumOfDivisor(vector<int>& nums, int Day){
        int sum = 0;
        for(int i = 1;i<nums.size();i++){
            sum += ceil((double)nums[i]/(double)(Day));
        }
        return sum;
    }
    int smallestDivisor(vector<int>& nums, int threshold) {
        int maxi = INT_MIN;
        for(int i = 0;i<nums.size();i++){
            maxi = max(maxi,nums[i]);
        }
        int low = 1,high = maxi,ans = -1;
        while(low <= high){
            int mid = (low + high)/2;
            if(SumOfDivisor(nums,mid) <= threshold){
                ans = mid;
                high = mid - 1;
            }
            else{
                low = mid + 1;
            }
        }
        return ans;
    }
};",None,"class Solution {
public:

    int SumOfDivisor(vector<int>& nums, int Day){
        int sum = 0;
        for(int i = 0;i<nums.size();i++){
            sum += ceil((double)nums[i]/(double)(Day));
        }
        return sum;
    }
    int smallestDivisor(vector<int>& nums, int threshold) {
        int maxi = INT_MIN;
        for(int i = 0;i<nums.size();i++){
            maxi = max(maxi,nums[i]);
        }
        int low = 1,high = maxi,ans = -1;
        while(low <= high){
            int mid = (low + high)/2;
            if(SumOfDivisor(nums,mid) <= threshold){
                ans = mid;
                high = mid - 1;
            }
            else{
                low = mid + 1;
            }
        }
        return ans;
    }
};
"
430,cpp,find-the-smallest-divisor-given-a-threshold,"class Solution {
public:

    int SumOfDivisor(vector<int>& nums, int Day){
        int sum = 0;
        for(int i = 1;i<nums.size();i++){
            sum += ceil((double)nums[i]/(double)(Day));
        }
        return sum;
    }
    int smallestDivisor(vector<int>& nums, int threshold) {
        int maxi = INT_MIN;
        for(int i = 0;i<nums.size();i++){
            maxi = max(maxi,nums[i]);
        }
        int low = 1,high = maxi,ans = -1;
        while(low <= high){
            int mid = (low + high)/2;
            if(SumOfDivisor(nums,mid) <= threshold){
                ans = mid;
                high = mid - 1;
            }
            else{
                low = mid + 1;
            }
        }
        return ans;
    }
};",None,"class Solution {
public:

    int SumOfDivisor(vector<int>& nums, int Day){
        int sum = 0;
        for(int i = 0;i<nums.size();i++){
            sum += ceil((double)nums[i]/(double)(Day));
        }
        return sum;
    }
    int smallestDivisor(vector<int>& nums, int threshold) {
        int maxi = INT_MIN;
        for(int i = 0;i<nums.size();i++){
            maxi = max(maxi,nums[i]);
        }
        int low = 1,high = maxi,ans = -1;
        while(low <= high){
            int mid = (low + high)/2;
            if(SumOfDivisor(nums,mid) <= threshold){
                ans = mid;
                high = mid - 1;
            }
            else{
                low = mid + 1;
            }
        }
        return ans;
    }
};
"
431,cpp,range-sum-of-bst,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
int sum = 0;
    void Traversal(TreeNode* root,int low,int high)
    {
        if(root==NULL)
        return;
        Traversal(root->left,low,high);
        if(root->val > high && root->val <low)sum+=root->val;
        Traversal(root->right,low,high);
    }
    int rangeSumBST(TreeNode* root, int low, int high) {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        Traversal(root,low,high);
        return sum;
    }
};",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int sum = 0;
    void Traversal(TreeNode* root,int low,int high)
    {
        if(root == NULL)
            return;
        Traversal(root->left,low,high);
        if(root->val >= low && root->val <= high) sum += root->val;
        Traversal(root->right,low,high);
    }
    int rangeSumBST(TreeNode* root, int low, int high) {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        Traversal(root,low,high);
        return sum;
    }
};
"
431,cpp,range-sum-of-bst,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
int sum = 0;
    void Traversal(TreeNode* root,int low,int high)
    {
        if(root==NULL)
        return;
        Traversal(root->left,low,high);
        if(root->val > high && root->val <low)sum+=root->val;
        Traversal(root->right,low,high);
    }
    int rangeSumBST(TreeNode* root, int low, int high) {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        Traversal(root,low,high);
        return sum;
    }
};",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int sum = 0;
    void Traversal(TreeNode* root,int low,int high)
    {
        if(root==NULL)
            return;
        Traversal(root->left,low,high);
        if(root->val >= low && root->val <= high) sum += root->val;
        Traversal(root->right,low,high);
    }
    int rangeSumBST(TreeNode* root, int low, int high) {
        Traversal(root,low,high);
        return sum;
    }
};
"
431,cpp,range-sum-of-bst,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
int sum = 0;
    void Traversal(TreeNode* root,int low,int high)
    {
        if(root==NULL)
        return;
        Traversal(root->left,low,high);
        if(root->val > high && root->val <low)sum+=root->val;
        Traversal(root->right,low,high);
    }
    int rangeSumBST(TreeNode* root, int low, int high) {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        Traversal(root,low,high);
        return sum;
    }
};",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
int sum = 0;
    void Traversal(TreeNode* root,int low,int high)
    {
        if(root==NULL)
        return;
        Traversal(root->left,low,high);
        if(root->val >= low && root->val <= high)sum+=root->val;
        Traversal(root->right,low,high);
    }
    int rangeSumBST(TreeNode* root, int low, int high) {
        Traversal(root,low,high);
        return sum;
    }
};
"
432,cpp,gray-code,"class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> res;
        res.push_back( 0 );
        for( int k = 0; k<n; k++ ) {
            int i = res.size(), t = (1<<k) ;
            while( i > 1 ) {
                int temp = res[--i] | t;
                res.push_back( temp );
            }
        }
        return res;
    }
};",None,"class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> res;
        res.push_back( 0 );
        for( int k = 0; k<n; k++ ) {
            int i = res.size(), t = (1<<k) ;
            while( i > 0 ) {
                int temp = res[--i] | t;
                res.push_back( temp );
            }
        }
        return res;
    }
};
"
432,cpp,gray-code,"class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> res;
        res.push_back( 0 );
        for( int k = 0; k<n; k++ ) {
            int i = res.size(), t = (1<<k) ;
            while( i > 1 ) {
                int temp = res[--i] | t;
                res.push_back( temp );
            }
        }
        return res;
    }
};",None,"class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> res;
        res.push_back(0);
        for(int k = 0; k < n; k++) {
            int i = res.size(), t = (1 << k);
            while(i > 0) {
                int temp = res[--i] | t;
                res.push_back(temp);
            }
        }
        return res;
    }
};
"
432,cpp,gray-code,"class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> res;
        res.push_back( 0 );
        for( int k = 0; k<n; k++ ) {
            int i = res.size(), t = (1<<k) ;
            while( i > 1 ) {
                int temp = res[--i] | t;
                res.push_back( temp );
            }
        }
        return res;
    }
};",None,"class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> res;
        res.push_back( 0 );
        for( int k = 0; k<n; k++ ) {
            int i = res.size(), t = (1<<k) ;
            while( i > 0 ) {
                int temp = res[--i] | t;
                res.push_back( temp );
            }
        }
        return res;
    }
};
"
433,cpp,min-cost-climbing-stairs,"class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();

        for(int i=2; i<=n; i++){
            cost[i] = min(cost[i-1],cost[i-2]) + cost[i];
        }

        return min(cost[n-1],cost[n-2]);
    }
};",None,"class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();

        for(int i=2; i<n; i++){
            cost[i] = min(cost[i-1],cost[i-2]) + cost[i];
        }

        return min(cost[n-1],cost[n-2]);
    }
};
"
433,cpp,min-cost-climbing-stairs,"class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();

        for(int i=2; i<=n; i++){
            cost[i] = min(cost[i-1],cost[i-2]) + cost[i];
        }

        return min(cost[n-1],cost[n-2]);
    }
};",None,"class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();
        vector<int> dp(n, 0);

        dp[0] = cost[0];
        dp[1] = cost[1];

        for(int i=2; i<n; i++){
            dp[i] = min(dp[i-1],dp[i-2]) + cost[i];
        }

        return min(dp[n-1],dp[n-2]);
    }
};
"
433,cpp,min-cost-climbing-stairs,"class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();

        for(int i=2; i<=n; i++){
            cost[i] = min(cost[i-1],cost[i-2]) + cost[i];
        }

        return min(cost[n-1],cost[n-2]);
    }
};",None,"class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();

        for(int i=2; i<n; i++){
            cost[i] = min(cost[i-1],cost[i-2]) + cost[i];
        }

        return min(cost[n-1],cost[n-2]);
    }
};
"
434,cpp,find-if-path-exists-in-graph,"class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) 
    {
        unordered_map<int,vector<int>> mp;
        for(auto i : edges)
        {
            vector<int> temp=i;
            int u=temp[0];
            int v=temp[1];
            mp[u].push_back(v);
            mp[v].push_back(u);
        }
        vector<bool> visited(n+1, false);
        queue<int>q;
        q.push(source);
        visited[source]=true;
        while(!q.empty())
        {
            int u=q.front();
            q.pop();
            for(auto i :mp[u])
            {
                if(visited[i]==false)
                {
                    q.push(i);
                }
            }
        }
        return visited[destination];    
    }
};",None,"class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) 
    {
        unordered_map<int,vector<int>> mp;
        for(auto i : edges)
        {
            vector<int> temp=i;
            int u=temp[0];
            int v=temp[1];
            mp[u].push_back(v);
            mp[v].push_back(u);
        }
        vector<bool> visited(n+1, false);
        queue<int>q;
        q.push(source);
        visited[source]=true;
        while(!q.empty())
        {
            int u=q.front();
            q.pop();
            for(auto i :mp[u])
            {
                if(visited[i]==false)
                {
                    visited[i] = true;
                    q.push(i);
                }
            }
        }
        return visited[destination];    
    }
};
"
434,cpp,find-if-path-exists-in-graph,"class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) 
    {
        unordered_map<int,vector<int>> mp;
        for(auto i : edges)
        {
            vector<int> temp=i;
            int u=temp[0];
            int v=temp[1];
            mp[u].push_back(v);
            mp[v].push_back(u);
        }
        vector<bool> visited(n+1, false);
        queue<int>q;
        q.push(source);
        visited[source]=true;
        while(!q.empty())
        {
            int u=q.front();
            q.pop();
            for(auto i :mp[u])
            {
                if(visited[i]==false)
                {
                    q.push(i);
                }
            }
        }
        return visited[destination];    
    }
};",None,"class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) 
    {
        unordered_map<int,vector<int>> mp;
        for(auto i : edges)
        {
            vector<int> temp=i;
            int u=temp[0];
            int v=temp[1];
            mp[u].push_back(v);
            mp[v].push_back(u);
        }
        vector<bool> visited(n+1, false);
        queue<int>q;
        q.push(source);
        visited[source]=true;
        while(!q.empty())
        {
            int u=q.front();
            q.pop();
            for(auto i :mp[u])
            {
                if(visited[i]==false)
                {
                    visited[i] = true;
                    q.push(i);
                }
            }
        }
        return visited[destination];    
    }
};
"
434,cpp,find-if-path-exists-in-graph,"class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) 
    {
        unordered_map<int,vector<int>> mp;
        for(auto i : edges)
        {
            vector<int> temp=i;
            int u=temp[0];
            int v=temp[1];
            mp[u].push_back(v);
            mp[v].push_back(u);
        }
        vector<bool> visited(n+1, false);
        queue<int>q;
        q.push(source);
        visited[source]=true;
        while(!q.empty())
        {
            int u=q.front();
            q.pop();
            for(auto i :mp[u])
            {
                if(visited[i]==false)
                {
                    q.push(i);
                }
            }
        }
        return visited[destination];    
    }
};",None,"class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) 
    {
        unordered_map<int,vector<int>> mp;
        for(auto i : edges)
        {
            vector<int> temp=i;
            int u=temp[0];
            int v=temp[1];
            mp[u].push_back(v);
            mp[v].push_back(u);
        }
        vector<bool> visited(n+1, false);
        queue<int>q;
        q.push(source);
        visited[source]=true;
        while(!q.empty())
        {
            int u=q.front();
            q.pop();
            for(auto i :mp[u])
            {
                if(visited[i]==false)
                {
                    visited[i] = true;
                    q.push(i);
                }
            }
        }
        return visited[destination];    
    }
};
"
435,cpp,count-pairs-with-xor-in-a-range,"class Solution {
public:
struct Node{
    Node* links[2];
    int cnt=0;
    void put(int ind,Node* node)
    {
        links[ind]=node;
    }
    bool isContains(int ind)
    {
        return links[ind]!=NULL;
    }
    Node* get(int ind)
    {
        return links[ind];
    }
    void incCount()
    {
        cnt++;
    }
    int count()
    {
        return cnt;
    }
};
class Trie
{
    public:
    Node * root;
      Trie()
      {
       root=new Node();
      }
      void insert(int num)
      {
          Node* node=root;
          for (int i=14;i>=0;i--)
          {
              int bit=((num>>i)&1);
              if (!node->isContains(bit))
              {
                 node->put(bit,new Node());
              }
              node=node->get(bit);
              node->incCount();
          }
      }
      int getCount(Node* root)
      {
          if (root==NULL) return 0;
          return root->count();
      }
      int rec(Node* root,int index,int high,int val)
      {
          if (root==NULL) return 0;
           if (index<0) return root->count();
          int valBit=((val>>index)&1);
          int highBit=((high>>index)&1);
          if(valBit==1)
          {
            if (highBit==1) return rec(root->get(0),index-1,high,val) + getCount(root->get(1));
            else return rec(root->get(1),index-1,high,val);
          }
          else
          {
             if (highBit==1) return rec(root->get(0),index-1,high,val)+getCount(root->get(1));
             else return rec(root->get(0),index-1,high,val);
          }
      }

};
    int countPairs(vector<int>& nums, int low, int high) {
        int ans=0;
        Trie * trie=new Trie();
        for (auto & it:nums)
        {
           ans+=trie->rec(trie->root,14,high,it);
           ans-=trie->rec(trie->root,14,low,it);
           trie->insert(it);
        } 
        return ans;
    }
};",None,"class Solution {
public:
    struct Node {
        Node* links[2];
        int cnt = 0;
        
        void put(int ind, Node* node) {
            links[ind] = node;
        }
        
        bool isContains(int ind) {
            return links[ind] != NULL;
        }
        
        Node* get(int ind) {
            return links[ind];
        }
        
        void incCount() {
            cnt++;
        }
        
        int count() {
            return cnt;
        }
    };
    
    class Trie {
    public:
        Node *root;
      
        Trie() : root (new Node()) { }
      
        void insert(int num) {
            Node* node = root;
            for (int i=14; i>=0; --i) {
                int bit = ((num >> i) & 1);
                if (!node->isContains(bit)) {
                    node->put(bit, new Node());
                }
                node = node->get(bit);
                node->incCount();
            }
        }
      
        int getCount(Node* node) {
            return node == NULL ? 0 : node->count();
        }
        
        int rec(Node* node, int index, int high, int val) {
            if (node == NULL) return 0;
            if (index < 0) return node->count();
            int valBit = ((val >> index) & 1);
            int highBit = ((high >> index) & 1);
            if (valBit == 1) {
                return highBit == 1 ? 
                        rec(node->get(0), index - 1, high, val) + getCount(node->get(1)) : 
                        rec(node->get(1), index - 1, high, val);
            } else {
                return highBit == 1 ? 
                        rec(node->get(0), index - 1, high, val) + getCount(node->get(1)) : 
                        rec(node->get(0), index - 1, high, val);
            }
        }
    };
    
    int countPairs(vector<int>& nums, int low, int high) {
        int ans = 0;
        Trie trie;
        for (int &num : nums) {
            ans += trie.rec(trie.root, 14, high+1, num) - trie.rec(trie.root, 14, low, num);
            trie.insert(num);
        }
        return ans;
    }
};
"
435,cpp,count-pairs-with-xor-in-a-range,"class Solution {
public:
struct Node{
    Node* links[2];
    int cnt=0;
    void put(int ind,Node* node)
    {
        links[ind]=node;
    }
    bool isContains(int ind)
    {
        return links[ind]!=NULL;
    }
    Node* get(int ind)
    {
        return links[ind];
    }
    void incCount()
    {
        cnt++;
    }
    int count()
    {
        return cnt;
    }
};
class Trie
{
    public:
    Node * root;
      Trie()
      {
       root=new Node();
      }
      void insert(int num)
      {
          Node* node=root;
          for (int i=14;i>=0;i--)
          {
              int bit=((num>>i)&1);
              if (!node->isContains(bit))
              {
                 node->put(bit,new Node());
              }
              node=node->get(bit);
              node->incCount();
          }
      }
      int getCount(Node* root)
      {
          if (root==NULL) return 0;
          return root->count();
      }
      int rec(Node* root,int index,int high,int val)
      {
          if (root==NULL) return 0;
           if (index<0) return root->count();
          int valBit=((val>>index)&1);
          int highBit=((high>>index)&1);
          if(valBit==1)
          {
            if (highBit==1) return rec(root->get(0),index-1,high,val) + getCount(root->get(1));
            else return rec(root->get(1),index-1,high,val);
          }
          else
          {
             if (highBit==1) return rec(root->get(0),index-1,high,val)+getCount(root->get(1));
             else return rec(root->get(0),index-1,high,val);
          }
      }

};
    int countPairs(vector<int>& nums, int low, int high) {
        int ans=0;
        Trie * trie=new Trie();
        for (auto & it:nums)
        {
           ans+=trie->rec(trie->root,14,high,it);
           ans-=trie->rec(trie->root,14,low,it);
           trie->insert(it);
        } 
        return ans;
    }
};",None,"class Solution {
public:
struct Node {
    Node * links[2];
    int cnt = 0;

    void put(int ind, Node * node) {
        links[ind] = node;
    }

    bool isContains(int ind) {
        return links[ind] != NULL;
    }

    Node * get(int ind) {
        return links[ind];
    }

    void incCount() {
        cnt++;
    }

    int count() {
        return cnt;
    }
};

class Trie {
public:
    Node * root;
    Trie() {
      root = new Node();
    }

    void insert(int num) {
        Node* node = root;
        for (int i = 14; i >= 0; i--) {
            int bit = ((num>>i) & 1);
            if (!node->isContains(bit)) {
                node->put(bit, new Node());
            }
            node = node->get(bit);
            node->incCount();
        }
    }

    int getCount(Node * root) {
        if (root == NULL) return 0;
        return root->count();
    }

    int rec(Node * root, int index, int high, int val) {
        if (root == NULL) return 0;
        if (index < 0) return root->count();

        int valBit = ((val >> index) & 1);
        int highBit = ((high >> index) & 1);

        if(valBit == 0) {
            if(highBit == 0)
                return rec(root->get(0), index - 1, high, val); // both 0-bit, go left 
            else
                return rec(root->get(0), index - 1, high, 0) + getCount(root->get(1)); // 0-bit on left, both on right
        } else {
            if(highBit == 0)
                return getCount(root->get(0)); // both 0-bit, so only look left
            else
                return rec(root->get(1), index - 1, high, val) + getCount(root->get(0)); // 0-bit on left, 1-bit on right
        }
    }

};

int countPairs(vector<int>& nums, int low, int high) {
    int ans = 0;
    Trie * trie = new Trie();
    for (auto & it : nums) {
       ans += trie->rec(trie->root, 14, high-1, it);
       ans -= trie->rec(trie->root, 14, low-1, it);
       trie->insert(it);
    } 
    return ans;
}
};
"
435,cpp,count-pairs-with-xor-in-a-range,"class Solution {
public:
struct Node{
    Node* links[2];
    int cnt=0;
    void put(int ind,Node* node)
    {
        links[ind]=node;
    }
    bool isContains(int ind)
    {
        return links[ind]!=NULL;
    }
    Node* get(int ind)
    {
        return links[ind];
    }
    void incCount()
    {
        cnt++;
    }
    int count()
    {
        return cnt;
    }
};
class Trie
{
    public:
    Node * root;
      Trie()
      {
       root=new Node();
      }
      void insert(int num)
      {
          Node* node=root;
          for (int i=14;i>=0;i--)
          {
              int bit=((num>>i)&1);
              if (!node->isContains(bit))
              {
                 node->put(bit,new Node());
              }
              node=node->get(bit);
              node->incCount();
          }
      }
      int getCount(Node* root)
      {
          if (root==NULL) return 0;
          return root->count();
      }
      int rec(Node* root,int index,int high,int val)
      {
          if (root==NULL) return 0;
           if (index<0) return root->count();
          int valBit=((val>>index)&1);
          int highBit=((high>>index)&1);
          if(valBit==1)
          {
            if (highBit==1) return rec(root->get(0),index-1,high,val) + getCount(root->get(1));
            else return rec(root->get(1),index-1,high,val);
          }
          else
          {
             if (highBit==1) return rec(root->get(0),index-1,high,val)+getCount(root->get(1));
             else return rec(root->get(0),index-1,high,val);
          }
      }

};
    int countPairs(vector<int>& nums, int low, int high) {
        int ans=0;
        Trie * trie=new Trie();
        for (auto & it:nums)
        {
           ans+=trie->rec(trie->root,14,high,it);
           ans-=trie->rec(trie->root,14,low,it);
           trie->insert(it);
        } 
        return ans;
    }
};",None,"class Solution {
public:
struct Node{
    Node* links[2];
    int cnt = 0;
    void put(int ind, Node* node) {
        links[ind] = node;
    }
    bool isContains(int ind) {
        return links[ind] != NULL;
    }
    Node* get(int ind) {
        return links[ind];
    }
    void incCount() {
        cnt++;
    }
    int count() {
        return cnt;
    }
};
class Trie {
    public:
    Node* root;
      Trie() {
        root = new Node();
      }
      void insert(int num) {
          Node* node = root;
          for (int i = 14; i >= 0; i--) {
              int bit = ((num >> i) & 1);
              if (!node->isContains(bit)) {
                 node->put(bit, new Node());
              }
              node = node->get(bit);
              node->incCount();
          }
      }
      int getCount(Node* root) {
          if (root == NULL) return 0;
          return root->count();
      }
      int rec(Node* node, int index, int high, int val) {
          if (node == NULL) return 0;
          if (index < 0) return node->count();
          int valBit = ((val >> index) & 1);
          int highBit = ((high >> index) & 1);
          if (valBit == 1) {
            if (highBit == 1) return rec(node->get(0), index - 1, high, val) + getCount(node->get(1));
            else return rec(node->get(1), index - 1, high, val);
          }
          else {
             if (highBit == 1) return rec(node->get(0), index - 1, high, val) + getCount(node->get(1));
             else return rec(node->get(0), index - 1, high, val);
          }
      }

};
    int countPairs(vector<int>& nums, int low, int high) {
        int ans=0;
        Trie* trie = new Trie();
        for (auto &it:nums) {
           ans += trie->rec(trie->root, 14, high + 1, it) - trie->rec(trie->root, 14, low, it);
           trie->insert(it);
        } 
        return ans;
    }
};
"
436,cpp,find-all-numbers-disappeared-in-an-array,"class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n = nums.size();
        int i = 0;
        while (i<n) {
            if (nums[i] != nums[nums[i]] && i != nums[i])
                swap(nums[i], nums[nums[i]]);
            else i++;
        }
        
        vector<int> res;
        for (int i=0; i<n; i++) {
            if (nums[i] != i+1) res.push_back(i+1);
        }

        return res;
    }
};",None,"class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n = nums.size();
        int i = 0;
        while (i<n) {
            if (nums[i] != nums[nums[i]-1] && i+1 != nums[i])
                swap(nums[i], nums[nums[i]-1]);
            else i++;
        }
        
        vector<int> res;
        for (int i=0; i<n; i++) {
            if (nums[i] != i+1) res.push_back(i+1);
        }

        return res;
    }
};
"
436,cpp,find-all-numbers-disappeared-in-an-array,"class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n = nums.size();
        int i = 0;
        while (i<n) {
            if (nums[i] != nums[nums[i]] && i != nums[i])
                swap(nums[i], nums[nums[i]]);
            else i++;
        }
        
        vector<int> res;
        for (int i=0; i<n; i++) {
            if (nums[i] != i+1) res.push_back(i+1);
        }

        return res;
    }
};",None,"class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n = nums.size();
        int i = 0;
        while (i<n) {
            if (nums[i] != nums[nums[i]-1] && i != nums[i]-1)
                swap(nums[i], nums[nums[i]-1]);
            else i++;
        }
        
        vector<int> res;
        for (int i=0; i<n; i++) {
            if (nums[i] != i+1) res.push_back(i+1);
        }

        return res;
    }
};
"
436,cpp,find-all-numbers-disappeared-in-an-array,"class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n = nums.size();
        int i = 0;
        while (i<n) {
            if (nums[i] != nums[nums[i]] && i != nums[i])
                swap(nums[i], nums[nums[i]]);
            else i++;
        }
        
        vector<int> res;
        for (int i=0; i<n; i++) {
            if (nums[i] != i+1) res.push_back(i+1);
        }

        return res;
    }
};",None,"class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n = nums.size();
        int i = 0;
        while (i<n) {
            if (nums[i] != nums[nums[i]-1])
                swap(nums[i], nums[nums[i]-1]);
            else i++;
        }

        vector<int> res;
        for (int i=0; i<n; i++) {
            if (nums[i] != i+1) res.push_back(i+1);
        }

        return res;
    }
};
"
824,cpp,fibonacci-number,"class Solution {
    int dp[33];
public:
    int fibon(int n) {
        cout<<n<<endl;
        if(n==1)return 1;
        if(n<=0)return 0;

        int& ans = dp[n];
        if(ans!=-1)return ans;

        return ans = fibon(n-1) + fibon(n+2);
    }

    int fib(int n){
        for(int i = 0 ; i < 33 ; i++)dp[i]=-1;
        int ans = fibon(n);
        cout<<ans<<endl;
        return ans;
    }
};",None,"class Solution {
    int dp[33];
public:
    int fibon(int n) {
        if(n==1) return 1;
        if(n<=0) return 0;

        int& ans = dp[n];
        if(ans!=-1) return ans;

        return ans = fibon(n-1) + fibon(n-2); // Corrected from 'return ans = fibon(n-1) + fibon(n+2);' to 'return ans = fibon(n-1) + fibon(n-2);'
    }

    int fib(int n){
        for(int i = 0 ; i < 33 ; i++) dp[i] = -1;
        return fibon(n); // Removed 'cout<<ans<<endl;' so that it only return the result, not print it.
    }
};
"
824,cpp,fibonacci-number,"class Solution {
    int dp[33];
public:
    int fibon(int n) {
        cout<<n<<endl;
        if(n==1)return 1;
        if(n<=0)return 0;

        int& ans = dp[n];
        if(ans!=-1)return ans;

        return ans = fibon(n-1) + fibon(n+2);
    }

    int fib(int n){
        for(int i = 0 ; i < 33 ; i++)dp[i]=-1;
        int ans = fibon(n);
        cout<<ans<<endl;
        return ans;
    }
};",None,"class Solution {
    int dp[31];
public:
    int fibon(int n) {
        if(n==1 || n==0) return n;

        int& ans = dp[n];
        if(ans!=-1) return ans;

        return ans = fibon(n-1) + fibon(n-2);
    }

    int fib(int n){
        for(int i = 0 ; i < 31 ; i++) dp[i]=-1;
        return fibon(n);
    }
};
"
824,cpp,fibonacci-number,"class Solution {
    int dp[33];
public:
    int fibon(int n) {
        cout<<n<<endl;
        if(n==1)return 1;
        if(n<=0)return 0;

        int& ans = dp[n];
        if(ans!=-1)return ans;

        return ans = fibon(n-1) + fibon(n+2);
    }

    int fib(int n){
        for(int i = 0 ; i < 33 ; i++)dp[i]=-1;
        int ans = fibon(n);
        cout<<ans<<endl;
        return ans;
    }
};",None,"class Solution {
    int dp[33];
public:
    int fibon(int n) {
        if(n==1)return 1;
        if(n<=0)return 0;

        int& ans = dp[n];
        if(ans!=-1)return ans;

        return ans = fibon(n-1) + fibon(n-2);
    }

    int fib(int n){
        for(int i = 0 ; i < 33 ; i++)dp[i]=-1;
        int ans = fibon(n);
        return ans;
    }
};
"
825,cpp,shortest-subarray-to-be-removed-to-make-array-sorted,"class Solution {
public:
    int findLengthOfShortestSubarray(vector<int>& arr) {

        int n =(int) arr.size();
        int h = n-1 , l=0 ;
        
        for(int i=h;i>=1;i--)  
        {
            if(arr[i]>=arr[i-1] && h>0)
            {
                h--;
            }
            else break;
        }

        int res=h;

       for( l=0 ; l<h && (l==0 || arr[l-1]<=arr[l])  ;l++)
       {
             
             while(h<n && arr[l]>arr[h])
              {
                 h++;
              }

           res = min(res,h);

        
           
       }
      return res;
      
    }
};",None,"class Solution {
public:
    int findLengthOfShortestSubarray(vector<int>& arr) {

        int n =(int) arr.size();
        int h = n-1 , l=0 ;
        
        while(h > 0 && arr[h]>=arr[h-1])   
        {
            h--;
        }

        if (h == 0) return 0;

        int res=h;

       for( l=0 ; l<=h ; l++)
       {
             if(l > 0 && arr[l]<arr[l-1]) break;

             while(h<n && arr[l]>arr[h])
             {
                 h++;
             }

           res = min(res,h-l-1);
       }
      return res;
      
    }
};
"
825,cpp,shortest-subarray-to-be-removed-to-make-array-sorted,"class Solution {
public:
    int findLengthOfShortestSubarray(vector<int>& arr) {

        int n =(int) arr.size();
        int h = n-1 , l=0 ;
        
        for(int i=h;i>=1;i--)  
        {
            if(arr[i]>=arr[i-1] && h>0)
            {
                h--;
            }
            else break;
        }

        int res=h;

       for( l=0 ; l<h && (l==0 || arr[l-1]<=arr[l])  ;l++)
       {
             
             while(h<n && arr[l]>arr[h])
              {
                 h++;
              }

           res = min(res,h);

        
           
       }
      return res;
      
    }
};",None,"class Solution {
public:
    int findLengthOfShortestSubarray(vector<int>& arr) {

        int n =(int) arr.size();
        int h = n-1 , l=0 ;
        
        while(h > 0 && arr[h] >= arr[h-1]) h--;

        if (h == 0) return 0;

        int res = h;

        for( l=0 ; l<=h ;l++) {

           if(l > 0 && arr[l] < arr[l-1]) break;

           while(h<n && arr[l] > arr[h]) h++;

           res = min(res,h-l-1);
       }
      return res;
      
    }
};
"
825,cpp,shortest-subarray-to-be-removed-to-make-array-sorted,"class Solution {
public:
    int findLengthOfShortestSubarray(vector<int>& arr) {

        int n =(int) arr.size();
        int h = n-1 , l=0 ;
        
        for(int i=h;i>=1;i--)  
        {
            if(arr[i]>=arr[i-1] && h>0)
            {
                h--;
            }
            else break;
        }

        int res=h;

       for( l=0 ; l<h && (l==0 || arr[l-1]<=arr[l])  ;l++)
       {
             
             while(h<n && arr[l]>arr[h])
              {
                 h++;
              }

           res = min(res,h);

        
           
       }
      return res;
      
    }
};",None,"class Solution {
public:
    int findLengthOfShortestSubarray(vector<int>& arr) {

        int n =(int) arr.size();
        int h = n-1 , l=0 ;

        while (h > 0 && arr[h] >= arr[h - 1]) h--;  

        if (h == 0) return 0;  // the arr is already sorted

        int res = h;  
       
        for(l=0; l<h ; l++)
        {
          if(l > 0 && arr[l] < arr[l-1]) break;

          while(h<n && arr[l] > arr[h]) h++;

          if(l == 0 || h == n || arr[l] <= arr[h])
          {
            res = min(res, h-l-1);
          }
        }

       return res;
      
    }
};
"
826,cpp,sum-multiples,"class Solution {
public:
    int sumOfMultiples(int n,int count=0) {

       for (int i=1;i<=n;i++)
       {
         if (i%3==0 || i%5==0 ||i%7==0)
           count+=i;
       }
    return count-1;

    }
};",None,"class Solution {
public:
    int sumOfMultiples(int n) {
        int count = 0;
        for (int i = 1; i <= n; i++) {
            if (i % 3 == 0 || i % 5 == 0 || i % 7 == 0)
                count += i;
        }
        return count;
    }
};
"
826,cpp,sum-multiples,"class Solution {
public:
    int sumOfMultiples(int n,int count=0) {

       for (int i=1;i<=n;i++)
       {
         if (i%3==0 || i%5==0 ||i%7==0)
           count+=i;
       }
    return count-1;

    }
};",None,"class Solution {
public:
    int sumOfMultiples(int n,int count=0) {

       for (int i=1;i<=n;i++)
       {
         if (i%3==0 || i%5==0 ||i%7==0)
           count+=i;
       }
    return count;

    }
};
"
826,cpp,sum-multiples,"class Solution {
public:
    int sumOfMultiples(int n,int count=0) {

       for (int i=1;i<=n;i++)
       {
         if (i%3==0 || i%5==0 ||i%7==0)
           count+=i;
       }
    return count-1;

    }
};",None,"class Solution {
public:
    int sumOfMultiples(int n,int count=0) {

       for (int i=1;i<=n;i++)
       {
         if (i%3==0 || i%5==0 ||i%7==0)
            count+=i;
       }
    return count;

    }
};
"
827,cpp,product-of-array-except-self,"class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int>prefVector(nums.size(),1);
        vector<int>suffVector(nums.size(),1);
        int prefPro=1;
        for(int i=0;i<nums.size();i++){
            prefVector[i]=prefPro;
            prefPro*=nums[i];
        }
        int suffPro=1;
        for(int i=nums.size()-1;i>=0;i--){
            suffVector[i]=suffPro;
            suffPro*=nums[i+1];
        }
        vector<int>ans(nums.size());
        for(int i=0;i<nums.size();i++){
            ans[i]=prefVector[i]*suffVector[i];
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int>prefVector(nums.size(),1);
        vector<int>suffVector(nums.size(),1);
        int prefPro=1;
        for(int i=0;i<nums.size();i++){
            prefVector[i]=prefPro;
            prefPro*=nums[i];
        }
        int suffPro=1;
        for(int i=nums.size()-1;i>=0;i--){
            suffVector[i]=suffPro;
            suffPro*=nums[i];
        }
        vector<int>ans(nums.size());
        for(int i=0;i<nums.size();i++){
            ans[i]=prefVector[i]*suffVector[i];
        }
        return ans;
    }
};
"
827,cpp,product-of-array-except-self,"class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int>prefVector(nums.size(),1);
        vector<int>suffVector(nums.size(),1);
        int prefPro=1;
        for(int i=0;i<nums.size();i++){
            prefVector[i]=prefPro;
            prefPro*=nums[i];
        }
        int suffPro=1;
        for(int i=nums.size()-1;i>=0;i--){
            suffVector[i]=suffPro;
            suffPro*=nums[i+1];
        }
        vector<int>ans(nums.size());
        for(int i=0;i<nums.size();i++){
            ans[i]=prefVector[i]*suffVector[i];
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int>prefVector(nums.size(),1);
        vector<int>suffVector(nums.size(),1);
        int prefPro=1;
        for(int i=0;i<nums.size();i++){
            prefVector[i]=prefPro;
            prefPro*=nums[i];
        }
        int suffPro=1;
        for(int i=nums.size()-1;i>=0;i--){
            suffVector[i]=suffPro;
            suffPro*=nums[i];
        }
        vector<int>ans(nums.size());
        for(int i=0;i<nums.size();i++){
            ans[i]=prefVector[i]*suffVector[i];
        }
        return ans;
    }
};
"
827,cpp,product-of-array-except-self,"class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int>prefVector(nums.size(),1);
        vector<int>suffVector(nums.size(),1);
        int prefPro=1;
        for(int i=0;i<nums.size();i++){
            prefVector[i]=prefPro;
            prefPro*=nums[i];
        }
        int suffPro=1;
        for(int i=nums.size()-1;i>=0;i--){
            suffVector[i]=suffPro;
            suffPro*=nums[i+1];
        }
        vector<int>ans(nums.size());
        for(int i=0;i<nums.size();i++){
            ans[i]=prefVector[i]*suffVector[i];
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int>prefVector(nums.size(),1);
        vector<int>suffVector(nums.size(),1);
        int prefPro=1;
        for(int i=0;i<nums.size();i++){
            prefVector[i]=prefPro;
            prefPro*=nums[i];
        }
        int suffPro=1;
        for(int i=nums.size()-1;i>=0;i--){
            suffVector[i]=suffPro;
            suffPro*=nums[i];
        }
        vector<int>ans(nums.size());
        for(int i=0;i<nums.size();i++){
            ans[i]=prefVector[i]*suffVector[i];
        }
        return ans;
    }
};
"
828,cpp,largest-rectangle-in-histogram,"#include<stack>
 
class Solution {
public:
    vector<int> nextSmallNumberIndex(vector<int>& v){
        int n=v.size(),num=0;
        vector<int> ans(n);
        stack<int> s;
        s.push(-1);
        for(int i=n-1;i>=0;i--){
            num=v[i];
            while(s.top()!=-1 && v[s.top()]>=num){
                s.pop();
            }
            ans[i]=s.top();
            s.push(i);
        }
        return ans;

    }
    vector<int> prevSmallNumberIndex(vector<int>& v){
        int n=v.size(),num=0;
        vector<int> ans(n);
        stack<int> s;
        s.push(-1);
        for(int i=0;i<n;i++){
            num=v[i];
            while(s.top()!=-1 && v[s.top()]>=num){
                s.pop();
            }
            ans[i]=s.top();
            s.push(i);
        }
        return ans;

    }
    int largestRectangleArea(vector<int>& heights) {
        int size=heights.size(),h,l,area=0,curArea;
        vector<int> next=nextSmallNumberIndex(heights);
        vector<int> prev=prevSmallNumberIndex(heights);
        for(int i=0;i<size;i++){
            h=heights[i];
            if(next[i]==-1)next[i]=size;
            l=next[i]-prev[i]-1;
            curArea=l*h;
            area=max(area,curArea);
        }
        return area*2;        
    }
};",None,"#include<stack>

class Solution {
public:
    vector<int> nextSmallNumberIndex(vector<int>& v){
        int n = v.size(), num = 0;
        vector<int> ans(n);
        stack<int> s;
        s.push(-1);
        for(int i = n - 1; i >= 0; i--){
            num = v[i];
            while(s.top() != -1 && v[s.top()] >= num){
                s.pop();
            }
            ans[i] = s.top();
            s.push(i);
        }
        return ans;
    }

    vector<int> prevSmallNumberIndex(vector<int>& v){
        int n = v.size(), num = 0;
        vector<int> ans(n);
        stack<int> s;
        s.push(-1);
        for(int i = 0; i < n; i++){
            num = v[i];
            while(s.top() != -1 && v[s.top()] >= num){
                s.pop();
            }
            ans[i] = s.top();
            s.push(i);
        }
        return ans;
    }

    int largestRectangleArea(vector<int>& heights) {
        int size = heights.size(), h, l, area = 0, curArea;
        vector<int> next = nextSmallNumberIndex(heights);
        vector<int> prev = prevSmallNumberIndex(heights);
        for(int i = 0; i < size; i++){
            h = heights[i];
            if(next[i] == -1) next[i] = size;
            l = next[i] - prev[i] - 1;
            curArea = l * h;
            area = max(area, curArea);
        }
        return area;        
    }
};
"
828,cpp,largest-rectangle-in-histogram,"#include<stack>
 
class Solution {
public:
    vector<int> nextSmallNumberIndex(vector<int>& v){
        int n=v.size(),num=0;
        vector<int> ans(n);
        stack<int> s;
        s.push(-1);
        for(int i=n-1;i>=0;i--){
            num=v[i];
            while(s.top()!=-1 && v[s.top()]>=num){
                s.pop();
            }
            ans[i]=s.top();
            s.push(i);
        }
        return ans;

    }
    vector<int> prevSmallNumberIndex(vector<int>& v){
        int n=v.size(),num=0;
        vector<int> ans(n);
        stack<int> s;
        s.push(-1);
        for(int i=0;i<n;i++){
            num=v[i];
            while(s.top()!=-1 && v[s.top()]>=num){
                s.pop();
            }
            ans[i]=s.top();
            s.push(i);
        }
        return ans;

    }
    int largestRectangleArea(vector<int>& heights) {
        int size=heights.size(),h,l,area=0,curArea;
        vector<int> next=nextSmallNumberIndex(heights);
        vector<int> prev=prevSmallNumberIndex(heights);
        for(int i=0;i<size;i++){
            h=heights[i];
            if(next[i]==-1)next[i]=size;
            l=next[i]-prev[i]-1;
            curArea=l*h;
            area=max(area,curArea);
        }
        return area*2;        
    }
};",None,"#include<stack>

class Solution {
public:
    vector<int> nextSmallNumberIndex(vector<int>& v){
        int n=v.size(),num=0;
        vector<int> ans(n);
        stack<int> s;
        s.push(-1);
        for(int i=n-1;i>=0;i--){
            num=v[i];
            while(s.top()!=-1 && v[s.top()]>=num){
                s.pop();
            }
            ans[i]=s.top();
            s.push(i);
        }
        return ans;

    }
    vector<int> prevSmallNumberIndex(vector<int>& v){
        int n=v.size(),num=0;
        vector<int> ans(n);
        stack<int> s;
        s.push(-1);
        for(int i=0;i<n;i++){
            num=v[i];
            while(s.top()!=-1 && v[s.top()]>=num){
                s.pop();
            }
            ans[i]=s.top();
            s.push(i);
        }
        return ans;

    }
    int largestRectangleArea(vector<int>& heights) {
        int size=heights.size(),h,l,area=0,curArea;
        vector<int> next=nextSmallNumberIndex(heights);
        vector<int> prev=prevSmallNumberIndex(heights);
        for(int i=0;i<size;i++){
            h=heights[i];
            if(next[i]==-1)next[i]=size;
            l=next[i]-prev[i]-1;
            curArea=l*h;
            area=max(area,curArea);
        }
        return area;        
    }
};
"
828,cpp,largest-rectangle-in-histogram,"#include<stack>
 
class Solution {
public:
    vector<int> nextSmallNumberIndex(vector<int>& v){
        int n=v.size(),num=0;
        vector<int> ans(n);
        stack<int> s;
        s.push(-1);
        for(int i=n-1;i>=0;i--){
            num=v[i];
            while(s.top()!=-1 && v[s.top()]>=num){
                s.pop();
            }
            ans[i]=s.top();
            s.push(i);
        }
        return ans;

    }
    vector<int> prevSmallNumberIndex(vector<int>& v){
        int n=v.size(),num=0;
        vector<int> ans(n);
        stack<int> s;
        s.push(-1);
        for(int i=0;i<n;i++){
            num=v[i];
            while(s.top()!=-1 && v[s.top()]>=num){
                s.pop();
            }
            ans[i]=s.top();
            s.push(i);
        }
        return ans;

    }
    int largestRectangleArea(vector<int>& heights) {
        int size=heights.size(),h,l,area=0,curArea;
        vector<int> next=nextSmallNumberIndex(heights);
        vector<int> prev=prevSmallNumberIndex(heights);
        for(int i=0;i<size;i++){
            h=heights[i];
            if(next[i]==-1)next[i]=size;
            l=next[i]-prev[i]-1;
            curArea=l*h;
            area=max(area,curArea);
        }
        return area*2;        
    }
};",None,"#include<stack>
 
class Solution {
public:
    vector<int> nextSmallNumberIndex(vector<int>& v){
        int n=v.size(),num=0;
        vector<int> ans(n);
        stack<int> s;
        s.push(-1);
        for(int i=n-1;i>=0;i--){
            num=v[i];
            while(s.top()!=-1 && v[s.top()]>=num){
                s.pop();
            }
            ans[i]=s.top();
            s.push(i);
        }
        return ans;
    }
    
    vector<int> prevSmallNumberIndex(vector<int>& v){
        int n=v.size(),num=0;
        vector<int> ans(n);
        stack<int> s;
        s.push(-1);
        for(int i=0;i<n;i++){
            num=v[i];
            while(s.top()!=-1 && v[s.top()]>=num){
                s.pop();
            }
            ans[i]=s.top();
            s.push(i);
        }
        return ans;
    }

    int largestRectangleArea(vector<int>& heights) {
        int size=heights.size(),h,l,area=0,curArea;
        vector<int> next=nextSmallNumberIndex(heights);
        vector<int> prev=prevSmallNumberIndex(heights);
        for(int i=0;i<size;i++){
            h=heights[i];
            if(next[i]==-1)next[i]=size;
            l=next[i]-prev[i]-1;
            curArea=l*h;
            area=max(area,curArea);
        }
        return area;        
    }
};
"
829,cpp,perfect-rectangle,"class Solution {
public:
    bool isRectangleCover(vector<vector<int>>& rectangles) {
        map<pair<int,int>,int>m;
        for(auto it:rectangles){
            m[{it[0],it[1]}]++;
            m[{it[2],it[3]}]++;
            m[{it[0],it[3]}]++;
            m[{it[2],it[1]}]++;
        }
        int cnt=0;
        for( auto it=m.begin();it!=m.end();it++){
            if(abs(it->second)==1){
                cnt++;
            }
            else if(abs(it->second)!=1&&it->second!=0){
                return false;
            }
        }
        return cnt==4;
    }
};",None,"class Solution {
public:
    bool isRectangleCover(vector<vector<int>>& rectangles) {
        map<pair<int,int>,int>m;
        int area = 0;
        int minx = INT_MAX, miny = INT_MAX, maxx = INT_MIN, maxy = INT_MIN;
        for(auto rectangle : rectangles){
            area += (rectangle[2] - rectangle[0]) * (rectangle[3] - rectangle[1]);
            minx = min(minx, rectangle[0]);
            miny = min(miny, rectangle[1]);
            maxx = max(maxx, rectangle[2]);
            maxy = max(maxy, rectangle[3]);

            pair<int,int> p1 = {rectangle[0], rectangle[1]};
            pair<int,int> p2 = {rectangle[0], rectangle[3]};
            pair<int,int> p3 = {rectangle[2], rectangle[3]};
            pair<int,int> p4 = {rectangle[2], rectangle[1]};
            if (m[p1] & 1) m[p1]--; else m[p1]++;
            if (m[p2] & 1) m[p2]--; else m[p2]++;
            if (m[p3] & 1) m[p3]--; else m[p3]++;
            if (m[p4] & 1) m[p4]--; else m[p4]++;
        }
        if (area != (maxx - minx) * (maxy - miny)) return false;
        for(auto it : m){
            if ((it.first.first == minx || it.first.second == miny || it.first.first == maxx || it.first.second == maxy) 
            && it.second != 1) return false;
            else if (it.second >= 2) return false;
        }
        return true;
    }
};
"
829,cpp,perfect-rectangle,"class Solution {
public:
    bool isRectangleCover(vector<vector<int>>& rectangles) {
        map<pair<int,int>,int>m;
        for(auto it:rectangles){
            m[{it[0],it[1]}]++;
            m[{it[2],it[3]}]++;
            m[{it[0],it[3]}]++;
            m[{it[2],it[1]}]++;
        }
        int cnt=0;
        for( auto it=m.begin();it!=m.end();it++){
            if(abs(it->second)==1){
                cnt++;
            }
            else if(abs(it->second)!=1&&it->second!=0){
                return false;
            }
        }
        return cnt==4;
    }
};",None,"class Solution {
public:
    bool isRectangleCover(vector<vector<int>>& rectangles) {
        map<pair<int,int>,int> m;
        int area = 0;
        int Ix = INT_MAX;
        int Iy = INT_MAX;
        int Ax = INT_MIN;
        int Ay = INT_MIN;
        for(auto it:rectangles){
            m[{it[0],it[1]}]++;
            m[{it[2],it[3]}]++;
            m[{it[0],it[3]}]++;
            m[{it[2],it[1]}]++;
            area += (it[2]-it[0])*(it[3]-it[1]);
            Ix = min(Ix, it[0]);
            Iy = min(Iy, it[1]);
            Ax = max(Ax, it[2]);
            Ay = max(Ay, it[3]);
        }
        if(area != (Ax-Ix)*(Ay-Iy))
            return false;
        
        int cnt=0;
        for(auto it:m){
            if(it.second & 1){
                cnt++;
            }
        }
        return cnt==4;
    }
};
"
829,cpp,perfect-rectangle,"class Solution {
public:
    bool isRectangleCover(vector<vector<int>>& rectangles) {
        map<pair<int,int>,int>m;
        for(auto it:rectangles){
            m[{it[0],it[1]}]++;
            m[{it[2],it[3]}]++;
            m[{it[0],it[3]}]++;
            m[{it[2],it[1]}]++;
        }
        int cnt=0;
        for( auto it=m.begin();it!=m.end();it++){
            if(abs(it->second)==1){
                cnt++;
            }
            else if(abs(it->second)!=1&&it->second!=0){
                return false;
            }
        }
        return cnt==4;
    }
};",None,"class Solution {
public:
    bool isRectangleCover(vector<vector<int>>& rectangles) {
        int sumArea = 0;
        int minx = INT_MAX, miny = INT_MAX;
        int maxx = INT_MIN, maxy = INT_MIN;
        set<pair<int,int>> pointSet;
        for(auto rectangle: rectangles){
            minx = min(minx, rectangle[0]);
            miny = min(miny, rectangle[1]);
            maxx = max(maxx, rectangle[2]);
            maxy = max(maxy, rectangle[3]);
            sumArea += (rectangle[2]-rectangle[0])*(rectangle[3]-rectangle[1]);
            for(int i=0;i<4;++i){
                pair<int,int> corner = {rectangle[i/2*2], rectangle[i%2*2+1]};
                if(pointSet.count(corner)){
                    pointSet.erase(corner);
                }
                else{
                    pointSet.insert(corner);
                }
            }
        }
        if(pointSet.size()!=4||
           !pointSet.count(make_pair(minx,miny))||
           !pointSet.count(make_pair(minx,maxy))||
           !pointSet.count(make_pair(maxx,miny))||
           !pointSet.count(make_pair(maxx,maxy))){
            return false;
        }
        return sumArea == (maxx-minx)*(maxy-miny);
    }
};
"
830,cpp,buddy-strings,"class Solution {
public:
    bool buddyStrings(string s, string p) {
        int n=s.length(), m=p.length();
        if(n!=m) return false;
        
        vector<int> freq(26,0);
        
        int first=-1, second=-1;
        for(int i=0;i<n;i++){
            if(s[i] != p[i]){
                if(first==-1){
                    first=i;
                }else if(second==-1){
                    second=i;
                }else{
                    return false;
                }
            }
            freq[s[i]-'z']++; 
        }
        
        if(first == -1 && second == -1){
            for(int i=0;i<26;i++) if(freq[i] > 1) return true;
            return false;
        }else if(second == -1){
            return false;
        }
        
        return (s[first]==p[second] && s[second]==p[first]);
    }
};",None,"class Solution {
public:
    bool buddyStrings(string s, string goal) {
        int n = s.length(), m = goal.length();
        if(n != m) return false;
        
        vector<int> freq(26,0);

        int firstIndex = -1, secondIndex = -1;
        for(int i = 0; i < n; i++){
            if(s[i] != goal[i]){
                if(firstIndex == -1){
                    firstIndex = i;
                }else if(secondIndex == -1){
                    secondIndex = i;
                }else{
                    return false;
                }
            }
            freq[s[i] - 'a']++; 
        }
        
        if(firstIndex == -1 && secondIndex == -1){
            for(int i = 0; i < 26; i++)
                if(freq[i] > 1) 
                    return true;
            return false;
        }else if(secondIndex == -1){
            return false;
        }
        
        return (s[firstIndex] == goal[secondIndex] && s[secondIndex] == goal[firstIndex]);
    }
};
"
830,cpp,buddy-strings,"class Solution {
public:
    bool buddyStrings(string s, string p) {
        int n=s.length(), m=p.length();
        if(n!=m) return false;
        
        vector<int> freq(26,0);
        
        int first=-1, second=-1;
        for(int i=0;i<n;i++){
            if(s[i] != p[i]){
                if(first==-1){
                    first=i;
                }else if(second==-1){
                    second=i;
                }else{
                    return false;
                }
            }
            freq[s[i]-'z']++; 
        }
        
        if(first == -1 && second == -1){
            for(int i=0;i<26;i++) if(freq[i] > 1) return true;
            return false;
        }else if(second == -1){
            return false;
        }
        
        return (s[first]==p[second] && s[second]==p[first]);
    }
};",None,"class Solution {
public:
    bool buddyStrings(string s, string p) {
        int n=s.length(), m=p.length();
        if(n!=m) return false;
        
        vector<int> freq(26,0);
        
        int first=-1, second=-1;
        for(int i=0;i<n;i++){
            if(s[i] != p[i]){
                if(first==-1){
                    first=i;
                }else if(second==-1){
                    second=i;
                }else{
                    return false;
                }
            }
            freq[s[i]-'a']++; 
        }
        
        if(first == -1 && second == -1){
            for(int i=0;i<26;i++) if(freq[i] > 1) return true;
            return false;
        }else if(second == -1){
            return false;
        }
        
        return (s[first]==p[second] && s[second]==p[first]);
    }
};
"
830,cpp,buddy-strings,"class Solution {
public:
    bool buddyStrings(string s, string p) {
        int n=s.length(), m=p.length();
        if(n!=m) return false;
        
        vector<int> freq(26,0);
        
        int first=-1, second=-1;
        for(int i=0;i<n;i++){
            if(s[i] != p[i]){
                if(first==-1){
                    first=i;
                }else if(second==-1){
                    second=i;
                }else{
                    return false;
                }
            }
            freq[s[i]-'z']++; 
        }
        
        if(first == -1 && second == -1){
            for(int i=0;i<26;i++) if(freq[i] > 1) return true;
            return false;
        }else if(second == -1){
            return false;
        }
        
        return (s[first]==p[second] && s[second]==p[first]);
    }
};",None,"class Solution {
public:
    bool buddyStrings(string s, string p) {
        int n=s.length(), m=p.length();
        if(n!=m) return false;
        
        vector<int> freq(26,0);
        
        int first=-1, second=-1;
        for(int i=0;i<n;i++){
            if(s[i] != p[i]){
                if(first==-1){
                    first=i;
                }else if(second==-1){
                    second=i;
                }else{
                    return false;
                }
            }
            freq[s[i]-'a']++; 
        }
        
        if(first == -1 && second == -1){
            for(int i=0;i<26;i++) if(freq[i] > 1) return true;
            return false;
        }else if(second == -1){
            return false;
        }
        
        return (s[first]==p[second] && s[second]==p[first]);
    }
};
"
831,cpp,kth-ancestor-of-a-tree-node,"class TreeAncestor {
public:
    int n;

    vector<int>belong;
    vector<int>ind;
    vector<bool>leaf;
    vector<vector<int>>path_leaf;

    TreeAncestor(int n, vector<int>& parent) {
        this->n=n;
        path_leaf.resize(n);
        belong.resize(n,-1);
        ind.resize(n,-1);
        leaf.resize(n,1);

        for(int i=0;i<n;i++){
            if(parent[i]!=-1)   
            leaf[parent[i]]=0;
        }
        
        for(int i=0;i<n;i++){
            if(!leaf[i]) continue;
            int curr=i;
            belong[curr]=curr;
            while(curr!=-1){
                curr=parent[curr];
                path_leaf[i].push_back(curr);
                if(curr!=-1){
                    belong[curr]=i;
                    ind[curr]=path_leaf[i].size()-1;
                }
            }
        }

    }
    
    int getKthAncestor(int node, int k) {
        return path_leaf[belong[node]][max(k+ind[node],(int)path_leaf[belong[node]].size()-1)];
    }
};",None,"class TreeAncestor {
public:
    int n;
    vector<int> belong;
    vector<int> ind;
    vector<bool> leaf;
    vector<vector<int>> path_leaf;

    TreeAncestor(int n, vector<int>& parent) {
        this->n=n;
        path_leaf.resize(n);
        belong.resize(n,-1);
        ind.resize(n,-1);
        leaf.resize(n,1);

        for(int i=0;i<n;i++){
            if(parent[i]!=-1)   
            leaf[parent[i]]=0;
        }
        
        for(int i=0;i<n;i++){
            if(!leaf[i]) continue;
            int curr=i;
            belong[curr]=curr;
            while(curr!=-1){
                curr=parent[curr];
                path_leaf[i].push_back(curr);
                if(curr!=-1){
                    belong[curr]=i;
                    ind[curr]=path_leaf[i].size()-1;
                }
            }
        }
    }
    
    int getKthAncestor(int node, int k) {
        if (k >= path_leaf[belong[node]].size() || k > ind[node]) {
            return -1;
        } else {
            return path_leaf[belong[node]][ind[node] - k];
        }
    }
};
"
831,cpp,kth-ancestor-of-a-tree-node,"class TreeAncestor {
public:
    int n;

    vector<int>belong;
    vector<int>ind;
    vector<bool>leaf;
    vector<vector<int>>path_leaf;

    TreeAncestor(int n, vector<int>& parent) {
        this->n=n;
        path_leaf.resize(n);
        belong.resize(n,-1);
        ind.resize(n,-1);
        leaf.resize(n,1);

        for(int i=0;i<n;i++){
            if(parent[i]!=-1)   
            leaf[parent[i]]=0;
        }
        
        for(int i=0;i<n;i++){
            if(!leaf[i]) continue;
            int curr=i;
            belong[curr]=curr;
            while(curr!=-1){
                curr=parent[curr];
                path_leaf[i].push_back(curr);
                if(curr!=-1){
                    belong[curr]=i;
                    ind[curr]=path_leaf[i].size()-1;
                }
            }
        }

    }
    
    int getKthAncestor(int node, int k) {
        return path_leaf[belong[node]][max(k+ind[node],(int)path_leaf[belong[node]].size()-1)];
    }
};",None,"class TreeAncestor {
public:
    int n;
    vector<int>belong;
    vector<int>ind;
    vector<bool>leaf;
    vector<vector<int>>path_leaf;

    TreeAncestor(int n, vector<int>& parent) {
        this->n=n;
        path_leaf.resize(n);
        belong.resize(n,-1);
        ind.resize(n,-1);
        leaf.resize(n,1);

        for(int i=0;i<n;i++){
            if(parent[i]!=-1)   
            leaf[parent[i]]=0;
        }
        
        for(int i=0;i<n;i++){
            if(!leaf[i]) continue;
            int curr=i;
            belong[curr]=curr;
            while(curr!=-1){
                path_leaf[i].push_back(curr);
                curr=parent[curr];
                if(curr!=-1){
                    belong[curr]=i;
                    ind[curr]=path_leaf[i].size()-1;
                }
            }
        }
    }
    
    int getKthAncestor(int node, int k) {
        if(k >= path_leaf[belong[node]].size())
            return -1;
        else
            return path_leaf[belong[node]][k+ind[node]];
    }
};
"
831,cpp,kth-ancestor-of-a-tree-node,"class TreeAncestor {
public:
    int n;

    vector<int>belong;
    vector<int>ind;
    vector<bool>leaf;
    vector<vector<int>>path_leaf;

    TreeAncestor(int n, vector<int>& parent) {
        this->n=n;
        path_leaf.resize(n);
        belong.resize(n,-1);
        ind.resize(n,-1);
        leaf.resize(n,1);

        for(int i=0;i<n;i++){
            if(parent[i]!=-1)   
            leaf[parent[i]]=0;
        }
        
        for(int i=0;i<n;i++){
            if(!leaf[i]) continue;
            int curr=i;
            belong[curr]=curr;
            while(curr!=-1){
                curr=parent[curr];
                path_leaf[i].push_back(curr);
                if(curr!=-1){
                    belong[curr]=i;
                    ind[curr]=path_leaf[i].size()-1;
                }
            }
        }

    }
    
    int getKthAncestor(int node, int k) {
        return path_leaf[belong[node]][max(k+ind[node],(int)path_leaf[belong[node]].size()-1)];
    }
};",None,"class TreeAncestor {
public:
    int n;

    vector<int>belong;
    vector<int>ind;
    vector<bool>leaf;
    vector<vector<int>>path_leaf;

    TreeAncestor(int n, vector<int>& parent) {
        this->n=n;
        path_leaf.resize(n);
        belong.resize(n,-1);
        ind.resize(n,-1);
        leaf.resize(n,1);

        for(int i=0;i<n;i++){
            if(parent[i]!=-1)   
            leaf[parent[i]]=0;
        }
        
        for(int i=0;i<n;i++){
            if(!leaf[i]) continue;
            int curr=i;
            belong[curr]=curr;
            while(curr!=-1){
                path_leaf[i].push_back(curr);
                curr=parent[curr];
                if(curr!=-1){
                    belong[curr]=i;
                    ind[curr]=path_leaf[i].size()-1;
                }
            }
        }

    }
    
    int getKthAncestor(int node, int k) {
        if(node == -1 || ind[node] < k)
            return -1;
        else if(ind[node] == k)
            return path_leaf[belong[node]][0];
        else
            return path_leaf[belong[node]][ind[node] - k];
    }
};
"
832,cpp,find-the-longest-valid-obstacle-course-at-each-position,"class Solution {
public:
    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {
        
        int n = nums.size();
        
        
        vector<int> lis;
        
        
        
        vector<int> ans;

        for(int i = 0; i < n; i++)
        {
            int idx = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();
                
            ans.push_back(idx + 2);
            
            if(idx == lis.size())
                lis.push_back(nums[i]);
            
            else
            {
                lis[idx] = nums[i];
            }
        }
        
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {
        
        int n = nums.size();
        
        vector<int> lis;
        
        vector<int> ans;

        for(int i = 0; i < n; i++)
        {
            int idx = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();
            
            if(idx == lis.size())
                lis.push_back(nums[i]);
            
            else
            {
                lis[idx] = nums[i];
            }
            
            ans.push_back(idx + 1);
        }
        
        return ans;
    }
};
"
832,cpp,find-the-longest-valid-obstacle-course-at-each-position,"class Solution {
public:
    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {
        
        int n = nums.size();
        
        
        vector<int> lis;
        
        
        
        vector<int> ans;

        for(int i = 0; i < n; i++)
        {
            int idx = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();
                
            ans.push_back(idx + 2);
            
            if(idx == lis.size())
                lis.push_back(nums[i]);
            
            else
            {
                lis[idx] = nums[i];
            }
        }
        
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {
        
        int n = nums.size();
        
        vector<int> lis;
        
        vector<int> ans;

        for(int i = 0; i < n; i++)
        {
            int idx = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();
            if(idx == lis.size())
                lis.push_back(nums[i]);
            else
                lis[idx] = nums[i];

            // The idx is 0-indexed, so we need to add one to get the correct length. (idx + 1) instead of (idx + 2)
            ans.push_back(idx + 1);
        }
        
        return ans;
    }
};
"
832,cpp,find-the-longest-valid-obstacle-course-at-each-position,"class Solution {
public:
    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {
        
        int n = nums.size();
        
        
        vector<int> lis;
        
        
        
        vector<int> ans;

        for(int i = 0; i < n; i++)
        {
            int idx = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();
                
            ans.push_back(idx + 2);
            
            if(idx == lis.size())
                lis.push_back(nums[i]);
            
            else
            {
                lis[idx] = nums[i];
            }
        }
        
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {
        
        int n = nums.size();
        
        vector<int> lis;
        
        vector<int> ans;

        for(int i = 0; i < n; i++)
        {
            int idx = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();
                
            if(idx == lis.size())
                lis.push_back(nums[i]);
            else
                lis[idx] = nums[i];
                
            ans.push_back(idx + 1);
        }
        
        return ans;
    }
};
"
833,cpp,queries-on-number-of-points-inside-a-circle,"class Solution {
public:

    bool Manhattan(int x1,int x2,int y1,int y2,int r){
        int dist= abs(x2-x1) + abs(y2-y1);

        if(dist<=r*r) return true;
        return false;
    }
    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {

        vector<int> ans;

        for( auto c: queries){
            int x1=c[0];
            int y1=c[1];
            int r=c[2];
            int temp=0;
            
            for(auto i:points){
                int x2=i[0];
                int y2=i[1];

                if(Manhattan(x1,x2,y1,y2,r)){
                    temp++;
                }

            }

            ans.push_back(temp);

        }
        return ans;

    }
};",None,"class Solution {
public:

    bool isInside(int x1,int x2,int y1,int y2,int r){
        int dist= (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);

        if(dist <= r*r) return true;
        return false;
    }

    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {

        vector<int> ans;

        for( auto c: queries){
            int x1=c[0];
            int y1=c[1];
            int r=c[2];
            int temp=0;
            
            for(auto i:points){
                int x2=i[0];
                int y2=i[1];

                if(isInside(x1,x2,y1,y2,r)){
                    temp++;
                }

            }

            ans.push_back(temp);

        }
        return ans;

    }
};
"
833,cpp,queries-on-number-of-points-inside-a-circle,"class Solution {
public:

    bool Manhattan(int x1,int x2,int y1,int y2,int r){
        int dist= abs(x2-x1) + abs(y2-y1);

        if(dist<=r*r) return true;
        return false;
    }
    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {

        vector<int> ans;

        for( auto c: queries){
            int x1=c[0];
            int y1=c[1];
            int r=c[2];
            int temp=0;
            
            for(auto i:points){
                int x2=i[0];
                int y2=i[1];

                if(Manhattan(x1,x2,y1,y2,r)){
                    temp++;
                }

            }

            ans.push_back(temp);

        }
        return ans;

    }
};",None,"class Solution {
public:

    bool insideCircle(int x1, int x2, int y1, int y2, int r){
        int dist = pow((x2-x1), 2) + pow((y2-y1), 2);

        if(dist <= r * r) return true;
        return false;
    }

    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {

        vector<int> ans;

        for( auto c: queries){
            int x1 = c[0];
            int y1 = c[1];
            int r = c[2];
            int temp = 0;

            for(auto i : points){
                int x2=i[0];
                int y2=i[1];

                if(insideCircle(x1, x2, y1, y2, r)){
                    temp++;
                }
            }

            ans.push_back(temp);
        }

        return ans;
    }
};
"
833,cpp,queries-on-number-of-points-inside-a-circle,"class Solution {
public:

    bool Manhattan(int x1,int x2,int y1,int y2,int r){
        int dist= abs(x2-x1) + abs(y2-y1);

        if(dist<=r*r) return true;
        return false;
    }
    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {

        vector<int> ans;

        for( auto c: queries){
            int x1=c[0];
            int y1=c[1];
            int r=c[2];
            int temp=0;
            
            for(auto i:points){
                int x2=i[0];
                int y2=i[1];

                if(Manhattan(x1,x2,y1,y2,r)){
                    temp++;
                }

            }

            ans.push_back(temp);

        }
        return ans;

    }
};",None,"class Solution {
public:

    bool IsInsideCircle(int x1,int x2,int y1,int y2,int r){
        int dist= (x2-x1) * (x2-x1) + (y2-y1) * (y2-y1);

        if(dist<=r*r) return true;
        return false;
    }
    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {

        vector<int> ans;

        for( auto c: queries){
            int x1=c[0];
            int y1=c[1];
            int r=c[2];
            int temp=0;
            
            for(auto i:points){
                int x2=i[0];
                int y2=i[1];

                if(IsInsideCircle(x1,x2,y1,y2,r)){
                    temp++;
                }

            }

            ans.push_back(temp);

        }
        return ans;

    }
};
"
834,cpp,integer-to-roman,"class Solution {
public:
    string intToRoman(int num) {
        string ones[] = {"""",""I"",""II"",""III"",""IV"",""V"",""VI"",""VII"",""VIII"",""IX""};
        string tens[] = {"""",""X"",""XX"",""XXX"",""XL"",""L"",""LX"",""LXX"",""LXXX"",""XC""};
        string hrns[] = {"""",""C"",""CC"",""CCC"",""CD"",""D"",""DC"",""DCC"",""DCCC"",""CM""};
        string ths[]={"""",""M"",""MM"",""MMM""};

        return ths[num/10000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];
    }
};",None,"class Solution {
public:
    string intToRoman(int num) {
        string ones[] = {"""",""I"",""II"",""III"",""IV"",""V"",""VI"",""VII"",""VIII"",""IX""};
        string tens[] = {"""",""X"",""XX"",""XXX"",""XL"",""L"",""LX"",""LXX"",""LXXX"",""XC""};
        string hrns[] = {"""",""C"",""CC"",""CCC"",""CD"",""D"",""DC"",""DCC"",""DCCC"",""CM""};
        string ths[]={"""",""M"",""MM"",""MMM""};

        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];
    }
};
"
834,cpp,integer-to-roman,"class Solution {
public:
    string intToRoman(int num) {
        string ones[] = {"""",""I"",""II"",""III"",""IV"",""V"",""VI"",""VII"",""VIII"",""IX""};
        string tens[] = {"""",""X"",""XX"",""XXX"",""XL"",""L"",""LX"",""LXX"",""LXXX"",""XC""};
        string hrns[] = {"""",""C"",""CC"",""CCC"",""CD"",""D"",""DC"",""DCC"",""DCCC"",""CM""};
        string ths[]={"""",""M"",""MM"",""MMM""};

        return ths[num/10000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];
    }
};",None,"class Solution {
public:
    string intToRoman(int num) {
        string ones[] = {"""",""I"",""II"",""III"",""IV"",""V"",""VI"",""VII"",""VIII"",""IX""};
        string tens[] = {"""",""X"",""XX"",""XXX"",""XL"",""L"",""LX"",""LXX"",""LXXX"",""XC""};
        string hrns[] = {"""",""C"",""CC"",""CCC"",""CD"",""D"",""DC"",""DCC"",""DCCC"",""CM""};
        string ths[]={"""",""M"",""MM"",""MMM""};

        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];
    }
};
"
834,cpp,integer-to-roman,"class Solution {
public:
    string intToRoman(int num) {
        string ones[] = {"""",""I"",""II"",""III"",""IV"",""V"",""VI"",""VII"",""VIII"",""IX""};
        string tens[] = {"""",""X"",""XX"",""XXX"",""XL"",""L"",""LX"",""LXX"",""LXXX"",""XC""};
        string hrns[] = {"""",""C"",""CC"",""CCC"",""CD"",""D"",""DC"",""DCC"",""DCCC"",""CM""};
        string ths[]={"""",""M"",""MM"",""MMM""};

        return ths[num/10000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];
    }
};",None,"class Solution {
public:
    string intToRoman(int num) {
        string ones[] = {"""",""I"",""II"",""III"",""IV"",""V"",""VI"",""VII"",""VIII"",""IX""};
        string tens[] = {"""",""X"",""XX"",""XXX"",""XL"",""L"",""LX"",""LXX"",""LXXX"",""XC""};
        string hrns[] = {"""",""C"",""CC"",""CCC"",""CD"",""D"",""DC"",""DCC"",""DCCC"",""CM""};
        string ths[]={"""",""M"",""MM"",""MMM""};

        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];
    }
};
"
835,cpp,minimum-number-of-swaps-to-make-the-string-balanced,"class Solution {
public:
    int minSwaps(string s) {
        int size=0;
        for(char &ch:s){
          if(ch=='[')  size++;
          else if(size) size--;
        }
        return (size+2)/2;
    }
};",None,"class Solution {
public:
    int minSwaps(string s) {
        int imbalance=0, swaps=0;
        for(char &ch:s){
          if(ch=='[')  imbalance++;
          else if(imbalance) imbalance--;
          else { imbalance++; swaps++;}
        }
        return swaps;
    }
};
"
835,cpp,minimum-number-of-swaps-to-make-the-string-balanced,"class Solution {
public:
    int minSwaps(string s) {
        int size=0;
        for(char &ch:s){
          if(ch=='[')  size++;
          else if(size) size--;
        }
        return (size+2)/2;
    }
};",None,"class Solution {
public:
    int minSwaps(string s) {
        int balance = 0, swaps = 0;
        for (char ch : s) {
            balance += (ch == '[' ? 1 : -1);
            if (balance < 0) {
                swaps += 1;
                balance += 2;
            }
        }
        return swaps;
    }
};
"
835,cpp,minimum-number-of-swaps-to-make-the-string-balanced,"class Solution {
public:
    int minSwaps(string s) {
        int size=0;
        for(char &ch:s){
          if(ch=='[')  size++;
          else if(size) size--;
        }
        return (size+2)/2;
    }
};",None,"class Solution {
public:
    int minSwaps(string s) {
        int size=0, imbalance=0;
        for(char &ch:s){
          if(ch=='[')  size++;
          else if(size) size--;
		  else imbalance++;
        }
        return (imbalance+1)/2;
    }
};
"
836,cpp,number-of-matching-subsequences,"class Solution {
public:
map<char,vector<int>> count;
    int numMatchingSubseq(string s, vector<string>& words) {
        for(int i=0;i<s.size();i++){
            count[s[i]].push_back(i);
        }
        int z=0;
        for(auto& x:words){
            int p=-1;
            int r=0;
            for(int j=0;j<x.size();j++){
                if(count.find(x[j])==count.end()){r=1;break;}
                if(upper_bound(count[x[j]].begin(),count[x[j]].end(),p)==count[x[j]].end()){r=1;break;}
                p=upper_bound(count[x[j]].begin(),count[x[j]].end(),p)-count[x[j]].begin();
                }
            if(r==0)z+=1;
        }
        return z;
    }
};",None,"class Solution {
public:
    map<char,vector<int>> count;

    int numMatchingSubseq(string s, vector<string>& words) {
        for(int i=0;i<s.size();i++){
            count[s[i]].push_back(i);
        }
        int z=0;
        for(auto& x:words){
            int p=-1;
            int r=0;
            for(int j=0;j<x.size();j++){
                if(count.find(x[j])==count.end()){r=1;break;}
                auto it = upper_bound(count[x[j]].begin(),count[x[j]].end(),p);
                if(it == count[x[j]].end()){r=1;break;}
                p = *it;
            }
            if(r==0)z+=1;
        }
        return z;
    }
};
"
836,cpp,number-of-matching-subsequences,"class Solution {
public:
map<char,vector<int>> count;
    int numMatchingSubseq(string s, vector<string>& words) {
        for(int i=0;i<s.size();i++){
            count[s[i]].push_back(i);
        }
        int z=0;
        for(auto& x:words){
            int p=-1;
            int r=0;
            for(int j=0;j<x.size();j++){
                if(count.find(x[j])==count.end()){r=1;break;}
                if(upper_bound(count[x[j]].begin(),count[x[j]].end(),p)==count[x[j]].end()){r=1;break;}
                p=upper_bound(count[x[j]].begin(),count[x[j]].end(),p)-count[x[j]].begin();
                }
            if(r==0)z+=1;
        }
        return z;
    }
};",None,"class Solution {
public:
    map<char, vector<int>> count;

    int numMatchingSubseq(string s, vector<string>& words) {
        for(int i = 0; i < s.size(); i++){
            count[s[i]].push_back(i);
        }
        int z = 0;
        for(auto &x: words){
            int p=-1;
            int r=0;
            for(int j=0; j<x.size(); j++){
                if(count.find(x[j]) == count.end()) {r=1;break;}
                auto it = upper_bound(count[x[j]].begin(), count[x[j]].end(), p);
                if(it == count[x[j]].end()){r=1;break;}
                p = *it;
            }
            if(r==0) z++;
        }
        return z;
    }
};
"
836,cpp,number-of-matching-subsequences,"class Solution {
public:
map<char,vector<int>> count;
    int numMatchingSubseq(string s, vector<string>& words) {
        for(int i=0;i<s.size();i++){
            count[s[i]].push_back(i);
        }
        int z=0;
        for(auto& x:words){
            int p=-1;
            int r=0;
            for(int j=0;j<x.size();j++){
                if(count.find(x[j])==count.end()){r=1;break;}
                if(upper_bound(count[x[j]].begin(),count[x[j]].end(),p)==count[x[j]].end()){r=1;break;}
                p=upper_bound(count[x[j]].begin(),count[x[j]].end(),p)-count[x[j]].begin();
                }
            if(r==0)z+=1;
        }
        return z;
    }
};",None,"class Solution {
public:
map<char,vector<int>> count;
    int numMatchingSubseq(string s, vector<string>& words) {
        for(int i=0;i<s.size();i++){
            count[s[i]].push_back(i);
        }
        int z=0;
        for(auto& x:words){
            int p=-1;
            int r=0;
            for(int j=0;j<x.size();j++){
                if(count.find(x[j])==count.end()){r=1;break;}
                auto it = upper_bound(count[x[j]].begin(), count[x[j]].end(), p);
                if(it == count[x[j]].end()) {r=1;break;}
                p = *it;
            }
            if(r==0)z+=1;
        }
        return z;
    }
};
"
837,cpp,smallest-string-starting-from-leaf,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    string BFS(TreeNode* root)
    {
        if(!root) return """";
        queue<pair<TreeNode*,string>> q;
        vector<string> ans;
        string s = """";
        s+=root->val+96; 
        q.push({root,s});
        while(!q.empty())
        {
            TreeNode* node = q.front().first;
            string str = q.front().second;
            q.pop();
            if(!node->left && !node->right)
            {
                reverse(str.begin(),str.end());
                ans.push_back(str);
            }
            if(node->left)
            {
                string tmp = str;
                tmp+=node->left->val+97;
                q.push({node->left,tmp});
            }
            if(node->right)
            {
                string tmp = str;
                tmp+=node->right->val+97;
                q.push({node->right,tmp});
            }
        }
        sort(ans.begin(),ans.end());
        return ans[0];
    }
    string smallestFromLeaf(TreeNode* root) {
       return BFS(root);
    }
};",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    string BFS(TreeNode* root)
    {
        if(!root) return """";
        queue<pair<TreeNode*,string>> q;
        vector<string> ans;
        string s = """";
        s+=root->val+'a'; 
        q.push({root,s});
        while(!q.empty())
        {
            TreeNode* node = q.front().first;
            string str = q.front().second;
            q.pop();
            if(!node->left && !node->right)
            {
                reverse(str.begin(),str.end());
                ans.push_back(str);
            }
            if(node->left)
            {
                string tmp = str;
                tmp+=node->left->val+'a';
                q.push({node->left,tmp});
            }
            if(node->right)
            {
                string tmp = str;
                tmp+=node->right->val+'a';
                q.push({node->right,tmp});
            }
        }
        sort(ans.begin(),ans.end());
        return ans[0];
    }
    string smallestFromLeaf(TreeNode* root) {
       return BFS(root);
    }
};
"
837,cpp,smallest-string-starting-from-leaf,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    string BFS(TreeNode* root)
    {
        if(!root) return """";
        queue<pair<TreeNode*,string>> q;
        vector<string> ans;
        string s = """";
        s+=root->val+96; 
        q.push({root,s});
        while(!q.empty())
        {
            TreeNode* node = q.front().first;
            string str = q.front().second;
            q.pop();
            if(!node->left && !node->right)
            {
                reverse(str.begin(),str.end());
                ans.push_back(str);
            }
            if(node->left)
            {
                string tmp = str;
                tmp+=node->left->val+97;
                q.push({node->left,tmp});
            }
            if(node->right)
            {
                string tmp = str;
                tmp+=node->right->val+97;
                q.push({node->right,tmp});
            }
        }
        sort(ans.begin(),ans.end());
        return ans[0];
    }
    string smallestFromLeaf(TreeNode* root) {
       return BFS(root);
    }
};",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    string BFS(TreeNode* root)
    {
        if(!root) return """";
        queue<pair<TreeNode*,string>> q;
        vector<string> ans;
        string s = """";
        s += (root->val + 'a'); 
        q.push({root,s});
        while(!q.empty())
        {
            TreeNode* node = q.front().first;
            string str = q.front().second;
            q.pop();
            if(!node->left && !node->right)
            {
                reverse(str.begin(),str.end());
                ans.push_back(str);
            }
            if(node->left)
            {
                string tmp = str;
                tmp += (node->left->val+'a');
                q.push({node->left,tmp});
            }
            if(node->right)
            {
                string tmp = str;
                tmp += (node->right->val+'a');
                q.push({node->right,tmp});
            }
        }
        sort(ans.begin(),ans.end());
        return ans[0];
    }
    string smallestFromLeaf(TreeNode* root) {
       return BFS(root);
    }
};
"
837,cpp,smallest-string-starting-from-leaf,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    string BFS(TreeNode* root)
    {
        if(!root) return """";
        queue<pair<TreeNode*,string>> q;
        vector<string> ans;
        string s = """";
        s+=root->val+96; 
        q.push({root,s});
        while(!q.empty())
        {
            TreeNode* node = q.front().first;
            string str = q.front().second;
            q.pop();
            if(!node->left && !node->right)
            {
                reverse(str.begin(),str.end());
                ans.push_back(str);
            }
            if(node->left)
            {
                string tmp = str;
                tmp+=node->left->val+97;
                q.push({node->left,tmp});
            }
            if(node->right)
            {
                string tmp = str;
                tmp+=node->right->val+97;
                q.push({node->right,tmp});
            }
        }
        sort(ans.begin(),ans.end());
        return ans[0];
    }
    string smallestFromLeaf(TreeNode* root) {
       return BFS(root);
    }
};",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    string BFS(TreeNode* root)
    {
        if(!root) return """";
        queue<pair<TreeNode*,string>> q;
        vector<string> ans;
        string s = """";
        s+=root->val+'a'; 
        q.push({root,s});
        while(!q.empty())
        {
            TreeNode* node = q.front().first;
            string str = q.front().second;
            q.pop();
            if(!node->left && !node->right)
            {
                reverse(str.begin(),str.end());
                ans.push_back(str);
            }
            if(node->left)
            {
                string tmp = str;
                tmp+=node->left->val+'a';
                q.push({node->left,tmp});
            }
            if(node->right)
            {
                string tmp = str;
                tmp+=node->right->val+'a';
                q.push({node->right,tmp});
            }
        }
        sort(ans.begin(),ans.end());
        return ans[0];
    }
    string smallestFromLeaf(TreeNode* root) {
       return BFS(root);
    }
};
"
838,cpp,mean-of-array-after-removing-some-elements,"class Solution {
public:
    double trimMean(vector<int>& arr) {
        int i, k;
        double mean;
        sort(arr.begin(), arr.end());
        k = 0.05*arr.size();
        for(i=0 ; i<k ; i++)
        {
            arr.erase(arr.begin()+0);
            arr.erase(arr.begin()+arr.size());
        }
        mean = (double)accumulate(arr.begin(), arr.end(), 0)/arr.size();
        return mean;
    }
};",None,"class Solution {
public:
    double trimMean(vector<int>& arr) {
        int i, k;
        double mean;
        sort(arr.begin(), arr.end());
        k = 0.05*arr.size();
        for(i=0 ; i<k ; i++)
        {
            arr.erase(arr.begin()+0);
            arr.erase(arr.begin()+(arr.size()-1));
        }
        mean = (double)accumulate(arr.begin(), arr.end(), 0)/arr.size();
        return mean;
    }
};
"
838,cpp,mean-of-array-after-removing-some-elements,"class Solution {
public:
    double trimMean(vector<int>& arr) {
        int i, k;
        double mean;
        sort(arr.begin(), arr.end());
        k = 0.05*arr.size();
        for(i=0 ; i<k ; i++)
        {
            arr.erase(arr.begin()+0);
            arr.erase(arr.begin()+arr.size());
        }
        mean = (double)accumulate(arr.begin(), arr.end(), 0)/arr.size();
        return mean;
    }
};",None,"class Solution {
public:
    double trimMean(vector<int>& arr) {
        int i, k;
        double mean;
        sort(arr.begin(), arr.end());
        k = 0.05*arr.size();
        for(i=0 ; i<k ; i++)
        {
            arr.erase(arr.begin()+0);
            arr.erase(arr.begin()+arr.size()-1);
        }
        mean = (double)accumulate(arr.begin(), arr.end(), 0)/arr.size();
        return mean;
    }
};
"
838,cpp,mean-of-array-after-removing-some-elements,"class Solution {
public:
    double trimMean(vector<int>& arr) {
        int i, k;
        double mean;
        sort(arr.begin(), arr.end());
        k = 0.05*arr.size();
        for(i=0 ; i<k ; i++)
        {
            arr.erase(arr.begin()+0);
            arr.erase(arr.begin()+arr.size());
        }
        mean = (double)accumulate(arr.begin(), arr.end(), 0)/arr.size();
        return mean;
    }
};",None,"class Solution {
public:
    double trimMean(vector<int>& arr) {
        int i, k;
        double mean;
        sort(arr.begin(), arr.end());
        k = 0.05*arr.size();
        for(i=0 ; i<k ; i++)
        {
            arr.erase(arr.begin()+0);
            arr.pop_back();
        }
        mean = (double)accumulate(arr.begin(), arr.end(), 0)/arr.size();
        return mean;
    }
};
"
839,cpp,the-k-strongest-values-in-an-array,"class Solution {
public:
    vector<int> getStrongest(vector<int>& arr, int k) {
        vector<pair<int,int>>v;
        int sum=0,n=arr.size();
        sort(arr.begin(),arr.end());
        int median=arr[(n-2)/2]; 
        for(int i=0;i<arr.size();i++)
        {
            v.push_back({abs(arr[i]-median),arr[i]});
        }
        sort(v.begin(),v.end());
        reverse(v.begin(),v.end());
        vector<int>ans;
        for(int i=0;i<k;i++)
        {
            ans.push_back(v[i].second);
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> getStrongest(vector<int>& arr, int k) {
        vector<pair<int,int>>v;
        int n=arr.size();
        sort(arr.begin(),arr.end());
        int median=arr[(n-1)/2];
        for(int i=0;i<arr.size();i++)
        {
            v.push_back({abs(arr[i]-median),arr[i]});
        }
        sort(v.begin(),v.end(), [](pair<int,int>&a, pair<int,int>&b){
            return a.first == b.first ? a.second > b.second : a.first > b.first; 
        }); 
        vector<int>ans;
        for(int i=0;i<k;i++)
        {
            ans.push_back(v[i].second);
        }
        return ans;
    }
};
"
839,cpp,the-k-strongest-values-in-an-array,"class Solution {
public:
    vector<int> getStrongest(vector<int>& arr, int k) {
        vector<pair<int,int>>v;
        int sum=0,n=arr.size();
        sort(arr.begin(),arr.end());
        int median=arr[(n-2)/2]; 
        for(int i=0;i<arr.size();i++)
        {
            v.push_back({abs(arr[i]-median),arr[i]});
        }
        sort(v.begin(),v.end());
        reverse(v.begin(),v.end());
        vector<int>ans;
        for(int i=0;i<k;i++)
        {
            ans.push_back(v[i].second);
        }
        return ans;
    }
};",None,"class Solution {
public:
  vector<int> getStrongest(vector<int>& arr, int k) {
    vector<int> result(k);
    size_t m = (arr.size() - 1) / 2;
    nth_element(begin(arr), begin(arr) + m, end(arr));
    auto it = partition(begin(arr), end(arr), [median = arr[m]](int num) {
      return abs(num - median) > abs(median) || (abs(num - median) == abs(median) && num > median);
    });
    copy_n(begin(arr), k, begin(result));
    return result;
  }
};
"
839,cpp,the-k-strongest-values-in-an-array,"class Solution {
public:
    vector<int> getStrongest(vector<int>& arr, int k) {
        vector<pair<int,int>>v;
        int sum=0,n=arr.size();
        sort(arr.begin(),arr.end());
        int median=arr[(n-2)/2]; 
        for(int i=0;i<arr.size();i++)
        {
            v.push_back({abs(arr[i]-median),arr[i]});
        }
        sort(v.begin(),v.end());
        reverse(v.begin(),v.end());
        vector<int>ans;
        for(int i=0;i<k;i++)
        {
            ans.push_back(v[i].second);
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> getStrongest(vector<int>& arr, int k) {
        vector<pair<int,int>>v;
        int n=arr.size();
        sort(arr.begin(),arr.end());
        int median=arr[(n-1)/2]; 
        for(int i=0;i<arr.size();i++)
        {
            v.push_back({abs(arr[i]-median),arr[i]});
        }
        sort(v.begin(),v.end(), [](pair<int,int> &a, pair<int,int> &b){
            if(a.first==b.first)
                return a.second > b.second;
            return a.first > b.first;
        });
        vector<int>ans;
        for(int i=0;i<k;i++)
        {
            ans.push_back(v[i].second);
        }
        return ans;
    }
};
"
840,cpp,score-after-flipping-matrix,"class Solution {
public:
    void fliprow(int &r,vector<vector<int>>& grid)
    {
        for(int i=0; i<grid[0].size(); i++){
            grid[r][i]=1-grid[r][i];
        }
    }

    void flipcol(int &c,vector<vector<int>>& grid){
        for(int j=0; j<grid.size(); j++){
            grid[j][c]=1-grid[j][c];
        }
    }

    int matrixScore(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        for(int i=0; i<n; i++){
            if(grid[i][0]==0){    
                fliprow(i,grid);
            }
        }
        for(int j=0; j<m; j++){
            int cnt0=0;
            int cnt1=0;
            for(int i=0; i<n; i++){
                if(grid[i][j]==1) cnt0++;
                else cnt1++;
            }
            if(cnt0>cnt1){
                flipcol(j,grid);
            }
        }
        int sum=0;
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(grid[i][j]==1){
                    sum+= (1<<(m-j-1));
                }
            }
        }
        return sum;
        

    }
};",None,"class Solution {
public:
    void fliprow(int &r,vector<vector<int>>& grid)
    {
        for(int i=0; i<grid[0].size(); i++){
            grid[r][i]=1-grid[r][i];
        }
    }

    void flipcol(int &c,vector<vector<int>>& grid){
        for(int j=0; j<grid.size(); j++){
            grid[j][c]=1-grid[j][c];
        }
    }

    int matrixScore(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        for(int i=0; i<n; i++){
            if(grid[i][0]==0){    
                fliprow(i,grid);
            }
        }
        for(int j=1; j<m; j++){
            int cnt0=0;
            int cnt1=0;
            for(int i=0; i<n; i++){
                if(grid[i][j]==1) cnt1++;
                else cnt0++;
            }
            if(cnt0>cnt1){
                flipcol(j,grid);
            }
        }
        int sum=0;
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(grid[i][j]==1){
                    sum+= (1<<(m-j-1));
                }
            }
        }
        return sum;
    }
};
"
840,cpp,score-after-flipping-matrix,"class Solution {
public:
    void fliprow(int &r,vector<vector<int>>& grid)
    {
        for(int i=0; i<grid[0].size(); i++){
            grid[r][i]=1-grid[r][i];
        }
    }

    void flipcol(int &c,vector<vector<int>>& grid){
        for(int j=0; j<grid.size(); j++){
            grid[j][c]=1-grid[j][c];
        }
    }

    int matrixScore(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        for(int i=0; i<n; i++){
            if(grid[i][0]==0){    
                fliprow(i,grid);
            }
        }
        for(int j=0; j<m; j++){
            int cnt0=0;
            int cnt1=0;
            for(int i=0; i<n; i++){
                if(grid[i][j]==1) cnt0++;
                else cnt1++;
            }
            if(cnt0>cnt1){
                flipcol(j,grid);
            }
        }
        int sum=0;
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(grid[i][j]==1){
                    sum+= (1<<(m-j-1));
                }
            }
        }
        return sum;
        

    }
};",None,"class Solution {
public:
    void flipRow(int &r,vector<vector<int>>& grid)
    {
        for(int i=0; i<grid[0].size(); i++){
            grid[r][i]=1-grid[r][i];
        }
    }

    void flipCol(int &c,vector<vector<int>>& grid){
        for(int j=0; j<grid.size(); j++){
            grid[j][c]=1-grid[j][c];
        }
    }

    int matrixScore(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        for(int i=0; i<n; i++){
            if(grid[i][0]==0){    
                flipRow(i,grid);
            }
        }
        for(int j=0; j<m; j++){
            int cnt0=0;
            int cnt1=0;
            for(int i=0; i<n; i++){
                if(grid[i][j]==1) cnt1++;
                else cnt0++;
            }
            if(cnt0>cnt1){
                flipCol(j,grid);
            }
        }
        
        int sum=0;
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(grid[i][j]==1){
                    sum+= (1<<(m-j-1));
                }
            }
        }
        return sum;
    }
};
"
840,cpp,score-after-flipping-matrix,"class Solution {
public:
    void fliprow(int &r,vector<vector<int>>& grid)
    {
        for(int i=0; i<grid[0].size(); i++){
            grid[r][i]=1-grid[r][i];
        }
    }

    void flipcol(int &c,vector<vector<int>>& grid){
        for(int j=0; j<grid.size(); j++){
            grid[j][c]=1-grid[j][c];
        }
    }

    int matrixScore(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        for(int i=0; i<n; i++){
            if(grid[i][0]==0){    
                fliprow(i,grid);
            }
        }
        for(int j=0; j<m; j++){
            int cnt0=0;
            int cnt1=0;
            for(int i=0; i<n; i++){
                if(grid[i][j]==1) cnt0++;
                else cnt1++;
            }
            if(cnt0>cnt1){
                flipcol(j,grid);
            }
        }
        int sum=0;
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(grid[i][j]==1){
                    sum+= (1<<(m-j-1));
                }
            }
        }
        return sum;
        

    }
};",None,"class Solution {
public:
    void fliprow(int r,vector<vector<int>>& grid)
    {
        for(int i=0; i<grid[0].size(); i++){
            grid[r][i] = 1 - grid[r][i];
        }
    }

    void flipcol(int c,vector<vector<int>>& grid){
        for(int j=0; j<grid.size(); j++){
            grid[j][c] = 1 - grid[j][c];
        }
    }

    int matrixScore(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        for(int i=0; i<n; i++){
            if(grid[i][0]==0){    
                fliprow(i,grid);
            }
        }
        for(int j=1; j<m; j++){
            int cnt0=0;
            for(int i=0; i<n; i++){
                if(grid[i][j]==0) cnt0++;
            }
            if(cnt0*2>n){
                flipcol(j,grid);
            }
        }
        int sum=0;
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(grid[i][j]==1){
                    sum+= (1<<(m-j-1));
                }
            }
        }
        return sum;
    }
};
"
841,cpp,percentage-of-letter-in-string,"class Solution {
public:
    int percentageLetter(string s, char letter) {
        int count = 0;
        for(int i=0; i<s.length(); i++){
            if(s[i] == letter){
                count = count + 2;
            }
        }
        int ans = ((count*100)/s.length()); 
        return ans;
    }
};",None,"class Solution {
public:
    int percentageLetter(string s, char letter) {
        int count = 0;
        for(int i=0; i<s.length(); i++){
            if(s[i] == letter){
                count = count + 1;
            }
        }
        int ans = ((count*100)/s.length()); 
        return ans;
    }
};
"
841,cpp,percentage-of-letter-in-string,"class Solution {
public:
    int percentageLetter(string s, char letter) {
        int count = 0;
        for(int i=0; i<s.length(); i++){
            if(s[i] == letter){
                count = count + 2;
            }
        }
        int ans = ((count*100)/s.length()); 
        return ans;
    }
};",None,"class Solution {
public:
    int percentageLetter(string s, char letter) {
        int count = 0;
        for(int i=0; i<s.length(); i++){
            if(s[i] == letter){
                count = count + 1;
            }
        }
        int ans = ((count*100)/s.length()); 
        return ans;
    }
};
"
841,cpp,percentage-of-letter-in-string,"class Solution {
public:
    int percentageLetter(string s, char letter) {
        int count = 0;
        for(int i=0; i<s.length(); i++){
            if(s[i] == letter){
                count = count + 2;
            }
        }
        int ans = ((count*100)/s.length()); 
        return ans;
    }
};",None,"class Solution {
public:
    int percentageLetter(string s, char letter) {
        int count = 0;
        for(int i=0; i<s.length(); i++){
            if(s[i] == letter){
                count++;    // count correctly, just once per matching letter
            }
        }
        int ans = ((count * 100) / s.length()); // now the calculation will be correct
        return ans;
    }
};
"
842,cpp,minimum-changes-to-make-alternating-binary-string,"class Solution {
public:
    int minOperations(string s) {
        int n=s.size(), ans=0;
        for(int i=0;i<n;i++)
        {
            if(s[i]-'0' != i%2)
            ans++;
        }
        return min(ans, n+ans);
    }
};",None,"class Solution {
public:
    int minOperations(string s) {
        int n=s.size(), ans=0;
        for(int i=0;i<n;i++)
        {
            if(s[i]-'0' != i%2)
            ans++;
        }
        return min(ans, n-ans);
    }
};
"
842,cpp,minimum-changes-to-make-alternating-binary-string,"class Solution {
public:
    int minOperations(string s) {
        int n=s.size(), ans=0;
        for(int i=0;i<n;i++)
        {
            if(s[i]-'0' != i%2)
            ans++;
        }
        return min(ans, n+ans);
    }
};",None,"class Solution {
public:
    int minOperations(string s) {
        int n=s.size(), ans=0, alt=0;
        for(int i=0;i<n;i++)
        {
            if(s[i]-'0' != i%2)
            ans++;
            else
            alt++;
        }
        return min(ans, alt);
    }
};
"
842,cpp,minimum-changes-to-make-alternating-binary-string,"class Solution {
public:
    int minOperations(string s) {
        int n=s.size(), ans=0;
        for(int i=0;i<n;i++)
        {
            if(s[i]-'0' != i%2)
            ans++;
        }
        return min(ans, n+ans);
    }
};",None,"class Solution {
public:
    int minOperations(string s) {
        int n=s.size(), ans1=0, ans2=0;
        for(int i=0;i<n;i++)
        {
            if(s[i]-'0' != i%2)
            ans1++;
            else
            ans2++;
        }
        return min(ans1, ans2);
    }
};
"
843,cpp,length-of-longest-fibonacci-subsequence,"class Solution {
public:
  int f(int curr,int prev,vector<int>& nums,int n){
			int t=nums[curr]+nums[prev];
			int i=lower_bound(nums.begin(),nums.end(),t)-nums.begin();
			if(i<n && nums[i]==t) return 1+f(i,curr,nums,n);
			return 0;
		}

		int lenLongestFibSubseq(vector<int>& nums) {
			int n=nums.size();
			int maxi=0;
			for(int prev2=0;prev2<n;prev2++){
				for(int prev1=prev2+1;prev1<n;prev1++){
					int temp=nums[prev1]+nums[prev2];
					int ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();
					if(ind<n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));
				}
			}
			return maxi;
		}
	};",None,"class Solution {
public:
  int f(int curr,int prev,vector<int>& nums,int n){
        	int t=nums[curr]+nums[prev];
            int i=lower_bound(nums.begin(),nums.end(),t)-nums.begin();
            if(i<n && nums[i]==t) return 1+f(i,curr,nums,n);
        	return 2;
    	}

  int lenLongestFibSubseq(vector<int>& nums) {
    int n=nums.size();
    int maxi=0;
    for(int prev2=0;prev2<n;prev2++){
      for(int prev1=prev2+1;prev1<n;prev1++){
        int temp=f(prev1,prev2,nums,n);
        if(temp>2) maxi=max(maxi,temp);
        }
      }
    return maxi>=3?maxi:0;
  }
};
"
843,cpp,length-of-longest-fibonacci-subsequence,"class Solution {
public:
  int f(int curr,int prev,vector<int>& nums,int n){
			int t=nums[curr]+nums[prev];
			int i=lower_bound(nums.begin(),nums.end(),t)-nums.begin();
			if(i<n && nums[i]==t) return 1+f(i,curr,nums,n);
			return 0;
		}

		int lenLongestFibSubseq(vector<int>& nums) {
			int n=nums.size();
			int maxi=0;
			for(int prev2=0;prev2<n;prev2++){
				for(int prev1=prev2+1;prev1<n;prev1++){
					int temp=nums[prev1]+nums[prev2];
					int ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();
					if(ind<n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));
				}
			}
			return maxi;
		}
	};",None,"class Solution {
public:
  int f(int curr,int prev,vector<int>& nums,int n){
			int t=nums[curr]+nums[prev];
			int i=lower_bound(nums.begin(),nums.end(),t)-nums.begin();
			if(i<n && nums[i]==t) return 1+f(i,curr,nums,n);
			return 1;
		}

		int lenLongestFibSubseq(vector<int>& nums) {
			int n=nums.size();
			int maxi=0;
			for(int prev2=0;prev2<n;prev2++){
				for(int prev1=prev2+1;prev1<n;prev1++){
					int temp=nums[prev1]+nums[prev2];
					int ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();
					if(ind<n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));
				}
			}
			return (maxi > 2) ? maxi : 0;
		}
	};
"
843,cpp,length-of-longest-fibonacci-subsequence,"class Solution {
public:
  int f(int curr,int prev,vector<int>& nums,int n){
			int t=nums[curr]+nums[prev];
			int i=lower_bound(nums.begin(),nums.end(),t)-nums.begin();
			if(i<n && nums[i]==t) return 1+f(i,curr,nums,n);
			return 0;
		}

		int lenLongestFibSubseq(vector<int>& nums) {
			int n=nums.size();
			int maxi=0;
			for(int prev2=0;prev2<n;prev2++){
				for(int prev1=prev2+1;prev1<n;prev1++){
					int temp=nums[prev1]+nums[prev2];
					int ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();
					if(ind<n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));
				}
			}
			return maxi;
		}
	};",None,"class Solution {
public:
    int lenLongestFibSubseq(vector<int>& arr) {
        unordered_map<int, int> index;
        for (int i = 0; i < arr.size(); ++i)
            index[arr[i]] = i;

        unordered_map<int, int> longest;
        int ans = 0;
        for (int k = 0; k < arr.size(); ++k)
            for (int j = 0; j < k; ++j) {
                if (arr[k] - arr[j] < arr[j] && index.count(arr[k] - arr[j])) {
                    int i = index[arr[k] - arr[j]];
                    longest[j * arr.size() + k] = longest[i * arr.size() + j] + 1;
                    ans = max(ans, longest[j * arr.size() + k] + 2);
                }
            }

        return ans >= 3 ? ans : 0;
    }
};
"
844,cpp,longest-subarray-of-1s-after-deleting-one-element,"class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right, zeros = 0, ans = 0;

        for (right = 0; right < n; right++) {
            if (nums[right] == 0){
                zeros++;
                }
            if (zeros > 1 && nums[left++] == 0){
                zeros--;
                }
            ans = max(ans, right - left);
        }
        return ans + 1; 
    }
};",None,"class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right, zeros = 0, ans = 0;

        for (right = 0; right < n; right++) {
            if (nums[right] == 0) {
                zeros++;
            }
            while (zeros > 1) {
                if (nums[left++] == 0) {
                    zeros--;
                }
            }
            ans = max(ans, right - left);
        }
        return ans; 
    }
};
"
844,cpp,longest-subarray-of-1s-after-deleting-one-element,"class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right, zeros = 0, ans = 0;

        for (right = 0; right < n; right++) {
            if (nums[right] == 0){
                zeros++;
                }
            if (zeros > 1 && nums[left++] == 0){
                zeros--;
                }
            ans = max(ans, right - left);
        }
        return ans + 1; 
    }
};",None,"class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right, zeros = 0, ans = 0;

        for (right = 0; right < n; right++) {
            if (nums[right] == 0){
                zeros++;
                }
            while (zeros > 1) {
                if (nums[left] == 0) {
                    zeros--;
                }
                left++;
            }
            ans = max(ans, right - left);
        }
        return ans; 
    }
};
"
844,cpp,longest-subarray-of-1s-after-deleting-one-element,"class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right, zeros = 0, ans = 0;

        for (right = 0; right < n; right++) {
            if (nums[right] == 0){
                zeros++;
                }
            if (zeros > 1 && nums[left++] == 0){
                zeros--;
                }
            ans = max(ans, right - left);
        }
        return ans + 1; 
    }
};",None,"class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right, zeros = 0, ans = 0;

        for (right = 0; right < n; right++) {
            if (nums[right] == 0){
                zeros++;
            }
            while (zeros > 1) {
                if (nums[left++] == 0){
                    zeros--;
                }
            }
            if (zeros == 1) {
                ans = max(ans, right - left);
            }
        }
        return ans; 
    }
};
"
845,cpp,intervals-between-identical-elements,"class Solution {
public:
    vector<long long> getDistances(vector<int>& arr) {
        
        int n = arr.size();
        vector<long long> ans(n);
        unordered_map<long long,long long> sum,freq,currfreq,currsum;

        for(int i = 0;i<n;i++)
        {
           sum[arr[i]]+=i;
           freq[arr[i]]++;
        }

        for(int i = 0;i<n;i++)
        {
           currfreq[arr[i]]++;
           currsum[arr[i]]+=i;

           long long currfrq = currfreq[arr[i]],remfreq = freq[arr[i]]-currfreq[arr[i]];
           long long currsumval = currsum[arr[i]],remsum = sum[arr[i]]-currsum[arr[i]];
           ans[i] =  abs(i*currfrq-(currsumval-i))+abs(i*remfreq-remsum);
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<long long> getDistances(vector<int>& arr) {
        
        int n = arr.size();
        vector<long long> ans(n);
        unordered_map<int,long long> sum,freq,currfreq,currsum;

        for(int i = 0;i<n;i++)
        {
           sum[arr[i]]+=i;
           freq[arr[i]]++;
        }

        for(int i = 0;i<n;i++)
        {
           currfreq[arr[i]]++;
           currsum[arr[i]]+=i;

           long long currfrq = currfreq[arr[i]],remfreq = freq[arr[i]]-currfreq[arr[i]];
           long long currsumval = currsum[arr[i]],remsum = sum[arr[i]]-currsum[arr[i]];
           ans[i] =  (currfrq*i-currsumval)+(remsum-i*remfreq);
        }
        return ans;
    }
};
"
845,cpp,intervals-between-identical-elements,"class Solution {
public:
    vector<long long> getDistances(vector<int>& arr) {
        
        int n = arr.size();
        vector<long long> ans(n);
        unordered_map<long long,long long> sum,freq,currfreq,currsum;

        for(int i = 0;i<n;i++)
        {
           sum[arr[i]]+=i;
           freq[arr[i]]++;
        }

        for(int i = 0;i<n;i++)
        {
           currfreq[arr[i]]++;
           currsum[arr[i]]+=i;

           long long currfrq = currfreq[arr[i]],remfreq = freq[arr[i]]-currfreq[arr[i]];
           long long currsumval = currsum[arr[i]],remsum = sum[arr[i]]-currsum[arr[i]];
           ans[i] =  abs(i*currfrq-(currsumval-i))+abs(i*remfreq-remsum);
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<long long> getDistances(vector<int>& arr) {
        
        int n = arr.size();
        vector<long long> ans(n);
        unordered_map<long long,long long> sum,freq,currfreq,currsum;

        for(int i = 0;i<n;i++)
        {
           sum[arr[i]]+=i;
           freq[arr[i]]++;
        }

        for(int i = 0;i<n;i++)
        {  
           currfreq[arr[i]]++;
           currsum[arr[i]]+=i;

           long long currfrq = currfreq[arr[i]],remfreq = freq[arr[i]]-currfreq[arr[i]];
           long long currsumval = currsum[arr[i]],remsum = sum[arr[i]]-currsum[arr[i]];
           ans[i] = abs(currfrq*i - currsumval) + abs(remsum - remfreq*i);
        }
        return ans;
    }
};
"
845,cpp,intervals-between-identical-elements,"class Solution {
public:
    vector<long long> getDistances(vector<int>& arr) {
        
        int n = arr.size();
        vector<long long> ans(n);
        unordered_map<long long,long long> sum,freq,currfreq,currsum;

        for(int i = 0;i<n;i++)
        {
           sum[arr[i]]+=i;
           freq[arr[i]]++;
        }

        for(int i = 0;i<n;i++)
        {
           currfreq[arr[i]]++;
           currsum[arr[i]]+=i;

           long long currfrq = currfreq[arr[i]],remfreq = freq[arr[i]]-currfreq[arr[i]];
           long long currsumval = currsum[arr[i]],remsum = sum[arr[i]]-currsum[arr[i]];
           ans[i] =  abs(i*currfrq-(currsumval-i))+abs(i*remfreq-remsum);
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<long long> getDistances(vector<int>& arr) {
        
        int n = arr.size();
        vector<long long> ans(n);
        unordered_map<long long,long long> sum,freq,currfreq,currsum;

        for(int i = 0;i<n;i++)
        {
           sum[arr[i]]+=i;
           freq[arr[i]]++;
        }

        for(int i = 0;i<n;i++)
        {
           currfreq[arr[i]]++;
           currsum[arr[i]]+=i;

           long long currfrq = currfreq[arr[i]],remfreq = freq[arr[i]]-currfreq[arr[i]];
           long long currsumval = currsum[arr[i]],remsum = sum[arr[i]]-currsum[arr[i]];
           ans[i] =  abs((currsumval)-(i*currfrq-1))+abs((remsum)-(i*remfreq));
        }
        return ans;
    }
};
"
846,cpp,count-elements-with-strictly-smaller-and-greater-elements,"class Solution {
public:
    int countElements(vector<int>& nums) {

        if(nums.size() == 1 || nums.size() == 2) return 0;
        int ma = *max_element(nums.begin(),nums.end());
        int countma = count(nums.begin(),nums.end(),ma);
        int mi = *min_element(nums.begin(),nums.end());
        int countmi = count(nums.begin(),nums.end(),mi);
        int ans = nums.size() - (countma+countmi);
        if(ans <= 0) return 0;
        return nums.size() - (countma + countmi - 1);
        
    }
};",None,"class Solution {
public:
    int countElements(vector<int>& nums) {
        map<int, int> count;
        for(int num : nums) {
            count[num]++;
        }
        int firstElem = count.begin()->first, lastElem = count.rbegin()->first;
        int ans = 0;
        for(auto it : count) {
            if(it.first != firstElem && it.first != lastElem) {
                ans += it.second;
            }
        }
        return ans;
    }
};
"
846,cpp,count-elements-with-strictly-smaller-and-greater-elements,"class Solution {
public:
    int countElements(vector<int>& nums) {

        if(nums.size() == 1 || nums.size() == 2) return 0;
        int ma = *max_element(nums.begin(),nums.end());
        int countma = count(nums.begin(),nums.end(),ma);
        int mi = *min_element(nums.begin(),nums.end());
        int countmi = count(nums.begin(),nums.end(),mi);
        int ans = nums.size() - (countma+countmi);
        if(ans <= 0) return 0;
        return nums.size() - (countma + countmi - 1);
        
    }
};",None,"class Solution {
public:
    int countElements(vector<int>& nums) {

        if(nums.size() == 1 || nums.size() == 2) return 0;
        int ma = *max_element(nums.begin(),nums.end());
        int countma = count(nums.begin(),nums.end(),ma);
        int mi = *min_element(nums.begin(),nums.end());
        int countmi = count(nums.begin(),nums.end(),mi);
        int ans = nums.size() - (countma+countmi);
        if(ans <= 0) return 0;
        return ans;      
    }
};
"
846,cpp,count-elements-with-strictly-smaller-and-greater-elements,"class Solution {
public:
    int countElements(vector<int>& nums) {

        if(nums.size() == 1 || nums.size() == 2) return 0;
        int ma = *max_element(nums.begin(),nums.end());
        int countma = count(nums.begin(),nums.end(),ma);
        int mi = *min_element(nums.begin(),nums.end());
        int countmi = count(nums.begin(),nums.end(),mi);
        int ans = nums.size() - (countma+countmi);
        if(ans <= 0) return 0;
        return nums.size() - (countma + countmi - 1);
        
    }
};",None,"class Solution {
public:
    int countElements(vector<int>& nums) {

        if(nums.size() == 1 || nums.size() == 2) return 0;
        int ma = *max_element(nums.begin(),nums.end());
        int countma = count(nums.begin(),nums.end(),ma);
        int mi = *min_element(nums.begin(),nums.end());
        int countmi = count(nums.begin(),nums.end(),mi);
        int ans = nums.size() - (countma+countmi);
        if(ans <= 0) return 0;
        return ans;
    }
};
"
847,cpp,smallest-index-with-equal-value,"class Solution {
public:
    int smallestEqual(vector<int>& nums) {
        for (int i = 0 ; i < nums.size() ; i ++)
        {
            if ( (nums[i] % 10) == nums[i] )
            {
                return i ;
            }
        }
        return -1; 
    }
};",None,"class Solution {
public:
    int smallestEqual(vector<int>& nums) {
        for (int i = 0 ; i < nums.size() ; i ++)
        {
            if ( (i % 10) == nums[i] )
            {
                return i ;
            }
        }
        return -1; 
    }
};
"
847,cpp,smallest-index-with-equal-value,"class Solution {
public:
    int smallestEqual(vector<int>& nums) {
        for (int i = 0 ; i < nums.size() ; i ++)
        {
            if ( (nums[i] % 10) == nums[i] )
            {
                return i ;
            }
        }
        return -1; 
    }
};",None,"class Solution {
public:
    int smallestEqual(vector<int>& nums) {
        for (int i = 0 ; i < nums.size() ; i ++)
        {
            if ( (i % 10) == nums[i] )
            {
                return i ;
            }
        }
        return -1; 
    }
};
"
847,cpp,smallest-index-with-equal-value,"class Solution {
public:
    int smallestEqual(vector<int>& nums) {
        for (int i = 0 ; i < nums.size() ; i ++)
        {
            if ( (nums[i] % 10) == nums[i] )
            {
                return i ;
            }
        }
        return -1; 
    }
};",None,"class Solution {
public:
    int smallestEqual(vector<int>& nums) {
        for (int i = 0 ; i < nums.size() ; i ++)
        {
            if ( (i % 10) == nums[i] )
            {
                return i ;
            }
        }
        return -1; 
    }
};
"
848,cpp,middle-of-the-linked-list,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* temp = head;
        ListNode* mid = head;
        while(temp != NULL && temp -> next != NULL){
            mid = mid -> next;
            temp = temp->next;
        }
        return mid;
    }
};",None,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* temp = head;
        ListNode* mid = head;
        while(temp != NULL && temp -> next != NULL){
            mid = mid -> next;
            temp = temp->next->next;
        }
        return mid;
    }
};
"
848,cpp,middle-of-the-linked-list,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* temp = head;
        ListNode* mid = head;
        while(temp != NULL && temp -> next != NULL){
            mid = mid -> next;
            temp = temp->next;
        }
        return mid;
    }
};",None,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* temp = head;
        ListNode* mid = head;
        while(temp != NULL && temp -> next != NULL){
            mid = mid -> next;
            temp = temp->next->next;
        }
        return mid;
    }
};
"
848,cpp,middle-of-the-linked-list,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* temp = head;
        ListNode* mid = head;
        while(temp != NULL && temp -> next != NULL){
            mid = mid -> next;
            temp = temp->next;
        }
        return mid;
    }
};",None,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* temp = head;
        ListNode* mid = head;
        while(temp != NULL && temp -> next != NULL){
            mid = mid -> next;
            temp = temp->next->next;
        }
        return mid;
    }
};
"
849,cpp,shortest-path-to-get-all-keys,"class Solution {
public:

    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};

    int shortestPathAllKeys(vector<string>& grid) {
        
        int m = grid.size();
        int n = grid[0].size();
        queue<pair<pair<int, int>, int>> que;
        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));
        int target = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {
                    target |= 1 << (grid[i][j] - 'a');
                    continue;
                }

                if (grid[i][j] == '@') {
                    que.emplace(pair<int, int>(i, j), 0);
                    mapKey[i][j] = 1;
                }
            }
        }


        int step = 0;
        while (!que.empty()) {
            int size = que.size();
            for (int s = 0; s < size; s++) {
                int i = que.front().first.first;
                int j = que.front().first.second;
                int key = que.front().second;
                que.pop();
                
                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {
                    key |= 1 << (grid[i][j] - 'a');
                    if (key == target)
                        return step;

                    mapKey[i][j] |= 1l << key;
                }

                for (int d = 0; d < 4; d++) {
                    int newi = i + dir[d][0];
                    int newj = j + dir[d][1];
                    
                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))
                        continue;
                        
                    int val = grid[newi][newj];
                    if (val == '#')
                        continue;
                        
                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)
                        continue;
                        
                    if (mapKey[newi][newj] & (1l << key))
                        continue;
                        
                     mapKey[newi][newj] |= 1l << (key+1);  
                     que.emplace(pair<int, int>(newi, newj), key);
                }
            }
            step++;
        }
        return -1;
    }
};",None,"class Solution {
public:

    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};

    int shortestPathAllKeys(vector<string>& grid) {
        
        int m = grid.size();
        int n = grid[0].size();
        queue<pair<pair<int, int>, int>> que;
        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));
        int target = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {
                    target |= 1 << (grid[i][j] - 'a');
                    continue;
                }

                if (grid[i][j] == '@') {
                    que.emplace(pair<int, int>(i, j), 0);
                    mapKey[i][j] = 1;
                }
            }
        }


        int step = 0;
        while (!que.empty()) {
            int size = que.size();
            for (int s = 0; s < size; s++) {
                int i = que.front().first.first;
                int j = que.front().first.second;
                int key = que.front().second;
                que.pop();
                
                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {
                    key |= 1 << (grid[i][j] - 'a');
                    if (key == target)
                        return step;

                    mapKey[i][j] |= 1l << key;
                }

                for (int d = 0; d < 4; d++) {
                    int newi = i + dir[d][0];
                    int newj = j + dir[d][1];
                    
                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))
                        continue;
                        
                    int val = grid[newi][newj];
                    if (val == '#')
                        continue;
                        
                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)
                        continue;
                        
                    if (mapKey[newi][newj] & (1l << key))
                        continue;
                        
                     mapKey[newi][newj] |= 1l << key;  
                     que.emplace(pair<int, int>(newi, newj), key);
                }
            }
            step++;
        }
        return -1;
    }
};
"
849,cpp,shortest-path-to-get-all-keys,"class Solution {
public:

    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};

    int shortestPathAllKeys(vector<string>& grid) {
        
        int m = grid.size();
        int n = grid[0].size();
        queue<pair<pair<int, int>, int>> que;
        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));
        int target = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {
                    target |= 1 << (grid[i][j] - 'a');
                    continue;
                }

                if (grid[i][j] == '@') {
                    que.emplace(pair<int, int>(i, j), 0);
                    mapKey[i][j] = 1;
                }
            }
        }


        int step = 0;
        while (!que.empty()) {
            int size = que.size();
            for (int s = 0; s < size; s++) {
                int i = que.front().first.first;
                int j = que.front().first.second;
                int key = que.front().second;
                que.pop();
                
                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {
                    key |= 1 << (grid[i][j] - 'a');
                    if (key == target)
                        return step;

                    mapKey[i][j] |= 1l << key;
                }

                for (int d = 0; d < 4; d++) {
                    int newi = i + dir[d][0];
                    int newj = j + dir[d][1];
                    
                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))
                        continue;
                        
                    int val = grid[newi][newj];
                    if (val == '#')
                        continue;
                        
                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)
                        continue;
                        
                    if (mapKey[newi][newj] & (1l << key))
                        continue;
                        
                     mapKey[newi][newj] |= 1l << (key+1);  
                     que.emplace(pair<int, int>(newi, newj), key);
                }
            }
            step++;
        }
        return -1;
    }
};",None,"class Solution {
public:

    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};

    int shortestPathAllKeys(vector<string>& grid) {
        
        int m = grid.size();
        int n = grid[0].size();
        queue<pair<pair<int, int>, int>> que;
        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));
        int target = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {
                    target |= 1 << (grid[i][j] - 'a');
                    continue;
                }

                if (grid[i][j] == '@') {
                    que.emplace(pair<int, int>(i, j), 0);
                    mapKey[i][j] = 1;
                }
            }
        }


        int step = 0;
        while (!que.empty()) {
            int size = que.size();
            for (int s = 0; s < size; s++) {
                int i = que.front().first.first;
                int j = que.front().first.second;
                int key = que.front().second;
                que.pop();
                
                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {
                    key |= 1 << (grid[i][j] - 'a');
                    if (key == target)
                        return step;

                    mapKey[i][j] |= 1l << key;
                }

                for (int d = 0; d < 4; d++) {
                    int newi = i + dir[d][0];
                    int newj = j + dir[d][1];
                    
                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))
                        continue;
                        
                    int val = grid[newi][newj];
                    if (val == '#')
                        continue;
                        
                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)
                        continue;
                        
                    if (mapKey[newi][newj] & (1l << key))
                        continue;
                        
                     mapKey[newi][newj] |= 1l << key;  
                     que.emplace(pair<int, int>(newi, newj), key);
                }
            }
            step++;
        }
        return -1;
    }
};
"
849,cpp,shortest-path-to-get-all-keys,"class Solution {
public:

    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};

    int shortestPathAllKeys(vector<string>& grid) {
        
        int m = grid.size();
        int n = grid[0].size();
        queue<pair<pair<int, int>, int>> que;
        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));
        int target = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {
                    target |= 1 << (grid[i][j] - 'a');
                    continue;
                }

                if (grid[i][j] == '@') {
                    que.emplace(pair<int, int>(i, j), 0);
                    mapKey[i][j] = 1;
                }
            }
        }


        int step = 0;
        while (!que.empty()) {
            int size = que.size();
            for (int s = 0; s < size; s++) {
                int i = que.front().first.first;
                int j = que.front().first.second;
                int key = que.front().second;
                que.pop();
                
                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {
                    key |= 1 << (grid[i][j] - 'a');
                    if (key == target)
                        return step;

                    mapKey[i][j] |= 1l << key;
                }

                for (int d = 0; d < 4; d++) {
                    int newi = i + dir[d][0];
                    int newj = j + dir[d][1];
                    
                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))
                        continue;
                        
                    int val = grid[newi][newj];
                    if (val == '#')
                        continue;
                        
                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)
                        continue;
                        
                    if (mapKey[newi][newj] & (1l << key))
                        continue;
                        
                     mapKey[newi][newj] |= 1l << (key+1);  
                     que.emplace(pair<int, int>(newi, newj), key);
                }
            }
            step++;
        }
        return -1;
    }
};",None,"class Solution {
public:

    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};

    int shortestPathAllKeys(vector<string>& grid) {
        
        int m = grid.size();
        int n = grid[0].size();
        queue<pair<pair<int, int>, int>> que;
        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));
        int target = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {
                    target |= 1 << (grid[i][j] - 'a');
                    continue;
                }

                if (grid[i][j] == '@') {
                    que.emplace(pair<int, int>(i, j), 0);
                    mapKey[i][j] = 1;
                }
            }
        }


        int step = 0;
        while (!que.empty()) {
            int size = que.size();
            for (int s = 0; s < size; s++) {
                int i = que.front().first.first;
                int j = que.front().first.second;
                int key = que.front().second;
                que.pop();
                
                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {
                    key |= 1 << (grid[i][j] - 'a');
                    if (key == target)
                        return step;

                    mapKey[i][j] |= 1l << key;
                }

                for (int d = 0; d < 4; d++) {
                    int newi = i + dir[d][0];
                    int newj = j + dir[d][1];
                    
                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))
                        continue;
                        
                    int val = grid[newi][newj];
                    if (val == '#')
                        continue;
                        
                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)
                        continue;
                        
                    if (mapKey[newi][newj] & (1l << key))
                        continue;
                        
                     mapKey[newi][newj] |= 1l << key;  
                     que.emplace(pair<int, int>(newi, newj), key);
                }
            }
            step++;
        }
        return -1;
    }
};
"
850,cpp,plus-one,"class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int n=digits.size();
        digits[n]++;
        for(int i=n-1;i>=1;i--)
        {
            if(digits[i]>9)
            {
                digits[i]%=10;
                digits[i-1]++;
            }
        }
        if(digits[0]>9)
        {
            digits.insert(digits.begin(),1);
            digits[1]%=10;
        }
        return digits;
    }
};",None,"class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int n=digits.size();
        digits[n-1]++;
        for(int i=n-1;i>=1;i--)
        {
            if(digits[i]>9)
            {
                digits[i]%=10;
                digits[i-1]++;
            }
        }
        if(digits[0]>9)
        {
            digits.insert(digits.begin(),1);
            digits[1]%=10;
        }
        return digits;
    }
};
"
850,cpp,plus-one,"class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int n=digits.size();
        digits[n]++;
        for(int i=n-1;i>=1;i--)
        {
            if(digits[i]>9)
            {
                digits[i]%=10;
                digits[i-1]++;
            }
        }
        if(digits[0]>9)
        {
            digits.insert(digits.begin(),1);
            digits[1]%=10;
        }
        return digits;
    }
};",None,"class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int n = digits.size();
        digits[n-1]++;
        for(int i = n-1; i >= 1; i--){
            if(digits[i] > 9){
                digits[i] %= 10;
                digits[i-1]++;
            }
        }
        if(digits[0] > 9){
            digits[0] %= 10;
            digits.insert(digits.begin(),1);
        }
        return digits;
    }
};
"
850,cpp,plus-one,"class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int n=digits.size();
        digits[n]++;
        for(int i=n-1;i>=1;i--)
        {
            if(digits[i]>9)
            {
                digits[i]%=10;
                digits[i-1]++;
            }
        }
        if(digits[0]>9)
        {
            digits.insert(digits.begin(),1);
            digits[1]%=10;
        }
        return digits;
    }
};",None,"class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int n=digits.size();
        digits[n-1]++;
        for(int i=n-1;i>0;i--)
        {
            if(digits[i]>9)
            {
                digits[i]%=10;
                digits[i-1]++;
            }
        }
        if(digits[0]>9)
        {
            digits.insert(digits.begin(),1);
            digits[1]%=10;
        }
        return digits;
    }
};
"
851,cpp,valid-anagram,"class Solution {
public:
    bool isAnagram(string s, string t) {
        if(s.length()!=t.length())
            return false;
        vector<int> freq(26, 0);
        for(int i =0; i<s.length(); i++){
            freq[s[i]-'a']++;
            freq[t[i]-'a']++;
        }
        for(int i =0; i<freq.size(); i++){
            if(freq[i]!=0)
                return false;
        }
        return true;
    }
};",None,"class Solution {
public:
    bool isAnagram(string s, string t) {
        if(s.length()!=t.length())
            return false;
        vector<int> freq(26, 0);
        for(int i =0; i<s.length(); i++){
            freq[s[i]-'a']++;
            freq[t[i]-'a']--;
        }
        for(int i =0; i<freq.size(); i++){
            if(freq[i]!=0)
                return false;
        }
        return true;
    }
};
"
851,cpp,valid-anagram,"class Solution {
public:
    bool isAnagram(string s, string t) {
        if(s.length()!=t.length())
            return false;
        vector<int> freq(26, 0);
        for(int i =0; i<s.length(); i++){
            freq[s[i]-'a']++;
            freq[t[i]-'a']++;
        }
        for(int i =0; i<freq.size(); i++){
            if(freq[i]!=0)
                return false;
        }
        return true;
    }
};",None,"class Solution {
public:
    bool isAnagram(string s, string t) {
        if(s.length()!=t.length())
            return false;
        vector<int> freq(26, 0);
        for(int i =0; i<s.length(); i++){
            freq[s[i]-'a']++;
            freq[t[i]-'a']--;
        }
        for(int i =0; i<freq.size(); i++){
            if(freq[i]!=0)
                return false;
        }
        return true;
    }
};
"
851,cpp,valid-anagram,"class Solution {
public:
    bool isAnagram(string s, string t) {
        if(s.length()!=t.length())
            return false;
        vector<int> freq(26, 0);
        for(int i =0; i<s.length(); i++){
            freq[s[i]-'a']++;
            freq[t[i]-'a']++;
        }
        for(int i =0; i<freq.size(); i++){
            if(freq[i]!=0)
                return false;
        }
        return true;
    }
};",None,"class Solution {
public:
    bool isAnagram(string s, string t) {
        if(s.length()!=t.length())
            return false;
        vector<int> freq(26, 0);
        for(int i =0; i<s.length(); i++){
            freq[s[i]-'a']++;
            freq[t[i]-'a']--;
        }
        for(int i =0; i<freq.size(); i++){
            if(freq[i]!=0)
                return false;
        }
        return true;
    }
};
"
852,cpp,valid-boomerang,"class Solution {
public:
    bool isBoomerang(vector<vector<int>>& points) {
        float a, b, c, d;
        a = (points[1][1] - points[0][1]);
        b = (points[1][0] - points[0][0]);
        c = (points[2][1] - points[1][1]);
        d = (points[2][0] - points[1][0]);
        if((b != 0 && d != 0 && a * c == b * c) || (b == 0 && d == 0 && points[0][0] == points[1][0]))
        {
            return false;
        }
        if((points[0][0] == points[1][0] && points[0][1] == points[1][1]) || (points[0][0] == points[2][0] && points[0][1] == points[2][1]) || (points[1][0] == points[2][0] && points[1][1] == points[2][1]))
        {
            return false;
        }
        return true;
    }
};",None,"class Solution {
public:
    bool isBoomerang(vector<vector<int>>& points) {
        float a, b, c, d;
        a = (points[1][1] - points[0][1]);
        b = (points[1][0] - points[0][0]);
        c = (points[2][1] - points[1][1]);
        d = (points[2][0] - points[1][0]);
        if((b != 0 && d != 0 && a/b == c/d) || (b == 0 && d == 0 && points[0][0] == points[1][0]))
        {
            return false;
        }
        if((points[0][0] == points[1][0] && points[0][1] == points[1][1]) || (points[0][0] == points[2][0] && points[0][1] == points[2][1]) || (points[1][0] == points[2][0] && points[1][1] == points[2][1]))
        {
            return false;
        }
        return true;
    }
};
"
852,cpp,valid-boomerang,"class Solution {
public:
    bool isBoomerang(vector<vector<int>>& points) {
        float a, b, c, d;
        a = (points[1][1] - points[0][1]);
        b = (points[1][0] - points[0][0]);
        c = (points[2][1] - points[1][1]);
        d = (points[2][0] - points[1][0]);
        if((b != 0 && d != 0 && a * c == b * c) || (b == 0 && d == 0 && points[0][0] == points[1][0]))
        {
            return false;
        }
        if((points[0][0] == points[1][0] && points[0][1] == points[1][1]) || (points[0][0] == points[2][0] && points[0][1] == points[2][1]) || (points[1][0] == points[2][0] && points[1][1] == points[2][1]))
        {
            return false;
        }
        return true;
    }
};",None,"class Solution {
public:
    bool isBoomerang(vector<vector<int>>& points) {
        float a, b, c, d;
        a = (points[1][1] - points[0][1]);
        b = (points[1][0] - points[0][0]);
        c = (points[2][1] - points[1][1]);
        d = (points[2][0] - points[1][0]);
        if((b != 0 && d != 0 && a * d == b * c) || (b == 0 && d == 0 && points[0][0] == points[1][0]))
        {
            return false;
        }
        if((points[0][0] == points[1][0] && points[0][1] == points[1][1]) || (points[0][0] == points[2][0] && points[0][1] == points[2][1]) || (points[1][0] == points[2][0] && points[1][1] == points[2][1]))
        {
            return false;
        }
        return true;
    }
};
"
852,cpp,valid-boomerang,"class Solution {
public:
    bool isBoomerang(vector<vector<int>>& points) {
        float a, b, c, d;
        a = (points[1][1] - points[0][1]);
        b = (points[1][0] - points[0][0]);
        c = (points[2][1] - points[1][1]);
        d = (points[2][0] - points[1][0]);
        if((b != 0 && d != 0 && a * c == b * c) || (b == 0 && d == 0 && points[0][0] == points[1][0]))
        {
            return false;
        }
        if((points[0][0] == points[1][0] && points[0][1] == points[1][1]) || (points[0][0] == points[2][0] && points[0][1] == points[2][1]) || (points[1][0] == points[2][0] && points[1][1] == points[2][1]))
        {
            return false;
        }
        return true;
    }
};",None,"class Solution {
public:
    bool isBoomerang(vector<vector<int>>& points) {
        float a, b, c, d;
        a = (points[1][1] - points[0][1]);
        b = (points[1][0] - points[0][0]);
        c = (points[2][1] - points[1][1]);
        d = (points[2][0] - points[1][0]);
        if((b != 0 && d != 0 && a * d == b * c) || (b == 0 && d == 0 && points[0][0] == points[1][0]))
        {
            return false;
        }
        if((points[0][0] == points[1][0] && points[0][1] == points[1][1]) || (points[0][0] == points[2][0] && points[0][1] == points[2][1]) || (points[1][0] == points[2][0] && points[1][1] == points[2][1]))
        {
            return false;
        }
        return true;
    }
};
"
853,cpp,frequency-tracker,"class FrequencyTracker {
public:
    unordered_map<int,int> x,y;
    void add(int number) {
        x[number]++;
        if(x[number]!=1) y[x[number]-1]--;
        y[x[number]]--;
    }
    void deleteOne(int number) {
        if(x[number]!=0){
            x[number]--;
            y[x[number]+1]--;
            y[x[number]]++;
        }
    }
    bool hasFrequency(int frequency) {
        if(y[frequency]!=0) return true;
        return false;
    }
};",None,"class FrequencyTracker {
public:
    unordered_map<int,int> x,y;
    void add(int number) {
        if(x[number]!=0) y[x[number]]--;
        x[number]++;
        y[x[number]]++;
    }
    void deleteOne(int number) {
        if(x[number]!=0){
            y[x[number]]--;
            if(x[number]!=1) y[x[number]-1]++;
            x[number]--;
        }
    }
    bool hasFrequency(int frequency) {
        if(y[frequency]>0) return true;
        return false;
    }
};
"
853,cpp,frequency-tracker,"class FrequencyTracker {
public:
    unordered_map<int,int> x,y;
    void add(int number) {
        x[number]++;
        if(x[number]!=1) y[x[number]-1]--;
        y[x[number]]--;
    }
    void deleteOne(int number) {
        if(x[number]!=0){
            x[number]--;
            y[x[number]+1]--;
            y[x[number]]++;
        }
    }
    bool hasFrequency(int frequency) {
        if(y[frequency]!=0) return true;
        return false;
    }
};",None,"class FrequencyTracker {
public:
    unordered_map<int,int> x,y;
    void add(int number) {
        if(x[number] > 0) {
            --y[x[number]];
        }
        ++x[number];
        ++y[x[number]];
    }
    void deleteOne(int number) {
        if(x[number] > 0) {
            --y[x[number]];
            --x[number];
            if(x[number] > 0) {
                ++y[x[number]];
            }
        }
    }
    bool hasFrequency(int frequency) {
        return y[frequency] > 0;
    }
};
"
853,cpp,frequency-tracker,"class FrequencyTracker {
public:
    unordered_map<int,int> x,y;
    void add(int number) {
        x[number]++;
        if(x[number]!=1) y[x[number]-1]--;
        y[x[number]]--;
    }
    void deleteOne(int number) {
        if(x[number]!=0){
            x[number]--;
            y[x[number]+1]--;
            y[x[number]]++;
        }
    }
    bool hasFrequency(int frequency) {
        if(y[frequency]!=0) return true;
        return false;
    }
};",None,"class FrequencyTracker {
public:
    unordered_map<int,int> x,y;
    void add(int number) {
        if(x[number] > 0){
            y[x[number]]--;
        }
        x[number]++;
        y[x[number]]++;
    }
    void deleteOne(int number) {
        if(x[number] > 0){
            y[x[number]]--;
            x[number]--;
            if(x[number] > 0){
                y[x[number]]++;
            }
        }
    }
    bool hasFrequency(int frequency) {
        return y[frequency] > 0;
    }
};
"
854,cpp,single-number,"class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_map<int,int> mp;
        for(int i=0;i<nums.size();i++){
            mp[nums[i]] = 1;
        }
        for(auto m:mp){
            if(m.second==1){
                return m.first;
            }
        }
        return -1;
    }
};",None,"class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_map<int,int> mp;
        for(int i=0;i<nums.size();i++){
            mp[nums[i]]++;
        }
        for(auto m:mp){
            if(m.second==1){
                return m.first;
            }
        }
        return -1;
    }
};
"
854,cpp,single-number,"class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_map<int,int> mp;
        for(int i=0;i<nums.size();i++){
            mp[nums[i]] = 1;
        }
        for(auto m:mp){
            if(m.second==1){
                return m.first;
            }
        }
        return -1;
    }
};",None,"class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_map<int,int> mp;
        for(int i=0;i<nums.size();i++){
            mp[nums[i]] += 1;
        }
        for(auto m:mp){
            if(m.second==1){
                return m.first;
            }
        }
        return -1;
    }
};
"
854,cpp,single-number,"class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_map<int,int> mp;
        for(int i=0;i<nums.size();i++){
            mp[nums[i]] = 1;
        }
        for(auto m:mp){
            if(m.second==1){
                return m.first;
            }
        }
        return -1;
    }
};",None,"class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_map<int,int> mp;
        for(int i=0;i<nums.size();i++){
            mp[nums[i]]++;
        }
        for(auto m:mp){
            if(m.second==1){
                return m.first;
            }
        }
        return -1;
    }
};
"
855,cpp,factorial-trailing-zeroes,"class Solution {
public:
    unordered_map<long long int,long long int>mp;
    int trailingZeroes(int n) {
        for(int i=n;i>=1;i--)
         fun(i);
         
		 return max(mp[2],mp[5]); 
    }
     void fun(int n)
    {
         for(int i=2;i*i<=n;i++)
         {
         	while((n%i) == 0)
         	{
         	    mp[i]++;
				n = n / i;	
			}
		 }
		 if(n > 1)
		 mp[n]++;
    }
};",None,"class Solution {
public:
    int trailingZeroes(int n) {
        int count = 0;
        while(n > 0)
        {
            n = n/5;
            count += n;
        }
        return count; 
    }
};
"
855,cpp,factorial-trailing-zeroes,"class Solution {
public:
    unordered_map<long long int,long long int>mp;
    int trailingZeroes(int n) {
        for(int i=n;i>=1;i--)
         fun(i);
         
		 return max(mp[2],mp[5]); 
    }
     void fun(int n)
    {
         for(int i=2;i*i<=n;i++)
         {
         	while((n%i) == 0)
         	{
         	    mp[i]++;
				n = n / i;	
			}
		 }
		 if(n > 1)
		 mp[n]++;
    }
};",None,"class Solution {
public:
    int trailingZeroes(int n) {
        int count = 0;
        while (n >= 5) {
            n = n / 5;
            count += n;
        }
        return count;
    }
};
"
855,cpp,factorial-trailing-zeroes,"class Solution {
public:
    unordered_map<long long int,long long int>mp;
    int trailingZeroes(int n) {
        for(int i=n;i>=1;i--)
         fun(i);
         
		 return max(mp[2],mp[5]); 
    }
     void fun(int n)
    {
         for(int i=2;i*i<=n;i++)
         {
         	while((n%i) == 0)
         	{
         	    mp[i]++;
				n = n / i;	
			}
		 }
		 if(n > 1)
		 mp[n]++;
    }
};",None,"class Solution {
public:
    int trailingZeroes(int n) {
        int count = 0;
        for (long long i = 5; n / i >= 1; i *= 5)
            count += n / i;
        return count;
    }
};
"
856,cpp,unique-paths-iii,"class Solution {
public:
   int count = 0 ; 
   int zeroes = 0 ; 

   void creator(vector<vector<int>>& grid, int row, int col, int length) {
       if (row < 0 || col < 0 || row >= grid.size() || col >= grid[0].size() || grid[row][col] == 3 || grid[row][col] == -1)
           return; 

       if (grid[row][col] == 2 && zeroes == length) {
           count++;
           return;
       }

       int org = grid[row][col]; 
       grid[row][col] = 3; 

       creator(grid, row + 1, col, length + 1);
       creator(grid, row - 1, col, length + 1);
       creator(grid, row, col + 1, length + 1);
       creator(grid, row, col - 1, length + 1);
       
       grid[row][col] = org; 
       return;
   }

   int uniquePathsIII(vector<vector<int>>& grid) {
       int row = 0; 
       int col = 0; 
       int free = 0;

       for (int i = 0; i < grid.size(); i++) {
           for (int j = 0; j < grid[0].size(); j++) {
               if (grid[i][j] == 1) {
                   row = i; 
                   col = j;
                   free++;
               } else if (grid[i][j] == 0 || grid[i][j] == 2) {
                   free += 2;
               }
           }
       }
       
       zeroes = free; 
       
       creator(grid, row, col, 1);
       
       return count;
   }
};",None,"class Solution {
public:
   int count = 0 ; 
   int zeroes = 0 ; 

   void creator(vector<vector<int>>& grid, int row, int col, int length) {
       if (row < 0 || col < 0 || row >= grid.size() || col >= grid[0].size() || grid[row][col] == 3 || grid[row][col] == -1)
           return; 

       if (grid[row][col] == 2) {
           if(zeroes == length) {
               count++;
           }
           return;
       }

       int org = grid[row][col]; 
       grid[row][col] = 3; 

       creator(grid, row + 1, col, length + 1);
       creator(grid, row - 1, col, length + 1);
       creator(grid, row, col + 1, length + 1);
       creator(grid, row, col - 1, length + 1);
       
       grid[row][col] = org; 
       return;
   }

   int uniquePathsIII(vector<vector<int>>& grid) {
       int row = 0; 
       int col = 0; 
       int free = 0;

       for (int i = 0; i < grid.size(); i++) {
           for (int j = 0; j < grid[0].size(); j++) {
               if (grid[i][j] == 1) {
                   row = i; 
                   col = j;
                   free++;
               } else if (grid[i][j] == 0 || grid[i][j] == 2) {
                   free ++;
               }
           }
       }
       
       zeroes = free; 
       
       creator(grid, row, col, 1);
       
       return count;
   }
};
"
856,cpp,unique-paths-iii,"class Solution {
public:
   int count = 0 ; 
   int zeroes = 0 ; 

   void creator(vector<vector<int>>& grid, int row, int col, int length) {
       if (row < 0 || col < 0 || row >= grid.size() || col >= grid[0].size() || grid[row][col] == 3 || grid[row][col] == -1)
           return; 

       if (grid[row][col] == 2 && zeroes == length) {
           count++;
           return;
       }

       int org = grid[row][col]; 
       grid[row][col] = 3; 

       creator(grid, row + 1, col, length + 1);
       creator(grid, row - 1, col, length + 1);
       creator(grid, row, col + 1, length + 1);
       creator(grid, row, col - 1, length + 1);
       
       grid[row][col] = org; 
       return;
   }

   int uniquePathsIII(vector<vector<int>>& grid) {
       int row = 0; 
       int col = 0; 
       int free = 0;

       for (int i = 0; i < grid.size(); i++) {
           for (int j = 0; j < grid[0].size(); j++) {
               if (grid[i][j] == 1) {
                   row = i; 
                   col = j;
                   free++;
               } else if (grid[i][j] == 0 || grid[i][j] == 2) {
                   free += 2;
               }
           }
       }
       
       zeroes = free; 
       
       creator(grid, row, col, 1);
       
       return count;
   }
};",None,"class Solution {
public:
   int count = 0 ; 
   int zeroes = 0 ; 

   void creator(vector<vector<int>>& grid, int row, int col, int length) {
       if (row < 0 || col < 0 || row >= grid.size() || col >= grid[0].size() || grid[row][col] == 3 || grid[row][col] == -1)
           return; 

       if (grid[row][col] == 2 && zeroes == length) {
           count++;
           return;
       }

       int org = grid[row][col]; 
       grid[row][col] = 3; 

       creator(grid, row + 1, col, length + 1);
       creator(grid, row - 1, col, length + 1);
       creator(grid, row, col + 1, length + 1);
       creator(grid, row, col - 1, length + 1);
       
       grid[row][col] = org; 
       return;
   }

   int uniquePathsIII(vector<vector<int>>& grid) {
       int row = 0; 
       int col = 0; 
       int free = 0;

       for (int i = 0; i < grid.size(); i++) {
           for (int j = 0; j < grid[i].size(); j++) {
               if (grid[i][j] == 1) {
                   row = i; 
                   col = j;
                   free++;
               } else if (grid[i][j] == 0 || grid[i][j] == 2) {
                   free ++;
               }
           }
       }
       
       zeroes = free; 
       
       creator(grid, row, col, 1);
       
       return count;
   }
};
"
856,cpp,unique-paths-iii,"class Solution {
public:
   int count = 0 ; 
   int zeroes = 0 ; 

   void creator(vector<vector<int>>& grid, int row, int col, int length) {
       if (row < 0 || col < 0 || row >= grid.size() || col >= grid[0].size() || grid[row][col] == 3 || grid[row][col] == -1)
           return; 

       if (grid[row][col] == 2 && zeroes == length) {
           count++;
           return;
       }

       int org = grid[row][col]; 
       grid[row][col] = 3; 

       creator(grid, row + 1, col, length + 1);
       creator(grid, row - 1, col, length + 1);
       creator(grid, row, col + 1, length + 1);
       creator(grid, row, col - 1, length + 1);
       
       grid[row][col] = org; 
       return;
   }

   int uniquePathsIII(vector<vector<int>>& grid) {
       int row = 0; 
       int col = 0; 
       int free = 0;

       for (int i = 0; i < grid.size(); i++) {
           for (int j = 0; j < grid[0].size(); j++) {
               if (grid[i][j] == 1) {
                   row = i; 
                   col = j;
                   free++;
               } else if (grid[i][j] == 0 || grid[i][j] == 2) {
                   free += 2;
               }
           }
       }
       
       zeroes = free; 
       
       creator(grid, row, col, 1);
       
       return count;
   }
};",None,"class Solution {
public:
    int count = 0, empty = 1, sx, sy, ex, ey; 
    void travel(vector<vector<int>>& grid, int row, int col, int rest) {
       if(row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || grid[row][col] < 0)
           return;

       if(row == ex && col == ey) {
           if(rest == 0) 
               count++;
           return;
       }

       grid[row][col] = -2;
       travel(grid, row + 1, col, rest - 1);
       travel(grid, row - 1, col, rest - 1);
       travel(grid, row, col + 1, rest - 1);
       travel(grid, row, col - 1, rest - 1);
       grid[row][col] = 0;
   }

   int uniquePathsIII(vector<vector<int>>& grid) {
       for (int i = 0; i < grid.size(); i++) {
           for (int j = 0; j < grid[0].size(); j++) {
               if (grid[i][j] == 1) {
                   sx = i, sy = j;
               }
               else if (grid[i][j] == 0) {
                   empty++;
               }
               else if (grid[i][j] == 2) {
                   ex = i, ey = j;
               }
           }
       }
       
       travel(grid, sx, sy, empty);
       
       return count;
   }
};
"
857,cpp,check-if-point-is-reachable,"class Solution {
public:
    bool isReachable(int x, int y) {
        while(!(x&1)){
            x >>= 1;
        }
        while(!(y&1)){
            y >>= 1;
        }
        return __gcd(x,y)==0;
    }
};",None,"class Solution {
public:
    bool isReachable(int x, int y) {
        while (x > 1 && y > 1)
        {
            if (x > y)
                x %= y;
            else
                y %= x;
        }
        return x == 1 || y == 1;
    }
};
"
857,cpp,check-if-point-is-reachable,"class Solution {
public:
    bool isReachable(int x, int y) {
        while(!(x&1)){
            x >>= 1;
        }
        while(!(y&1)){
            y >>= 1;
        }
        return __gcd(x,y)==0;
    }
};",None,"class Solution {
public:
    bool isReachable(int targetX, int targetY) {
        while (targetX > 1 && targetY > 1) {
            if (targetX > targetY) {
                targetX %= targetY;
            } else {
                targetY %= targetX;
            }
        }
        return (targetX == 1 && targetY >= 2) || (targetY == 1 && targetX >= 2);
    }
};
"
857,cpp,check-if-point-is-reachable,"class Solution {
public:
    bool isReachable(int x, int y) {
        while(!(x&1)){
            x >>= 1;
        }
        while(!(y&1)){
            y >>= 1;
        }
        return __gcd(x,y)==0;
    }
};",None,"class Solution {
public:
    bool isReachable(int targetX, int targetY) {

        while (targetX > 1 && targetY > 1) {
            if (targetX > targetY)
                targetX %= targetY;
            else
                targetY %= targetX;
        }

        return (targetX == 1 && targetY > 1) || (targetY == 1 && targetX > 1);
    }
};
"
858,cpp,check-knight-tour-configuration,"class Solution {
private:
    bool helper(vector<vector<int>>& grid, int row, int col, int num){
        int n = grid.size();
        if(num == n*n) return true;
        int i = row-2;
        int j = col+1;
        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row-2;
        j = col-1;
        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+2);

        i = row + 2;
        j = col - 1;
        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 2;
        j = col + 1;
        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 1;
        j = col + 2;
        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row - 1;
        j = col + 2;
        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row - 1;
        j = col - 2;
        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 1;
        j = col - 2;
        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        return false;
    }
public:
    bool checkValidGrid(vector<vector<int>>& grid) {
        ios::sync_with_stdio(false);
        cin.tie(0);
        cout.tie(0);
        if(grid[0][0] != 0) return false;
        return helper(grid,0,0,1);
    }
};",None,"class Solution {
private:
    bool helper(vector<vector<int>>& grid, int row, int col, int num){
        int n = grid.size();
        if(num == n*n) return true;
        int i = row-2;
        int j = col+1;
        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row-2;
        j = col-1;
        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 2;
        j = col - 1;
        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 2;
        j = col + 1;
        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 1;
        j = col + 2;
        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row - 1;
        j = col + 2;
        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row - 1;
        j = col - 2;
        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 1;
        j = col - 2;
        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        return false;
    }
public:
    bool checkValidGrid(vector<vector<int>>& grid) {
        ios::sync_with_stdio(false);
        cin.tie(0);
        cout.tie(0);
        if(grid[0][0] != 0) return false;
        return helper(grid,0,0,1);
    }
};
"
858,cpp,check-knight-tour-configuration,"class Solution {
private:
    bool helper(vector<vector<int>>& grid, int row, int col, int num){
        int n = grid.size();
        if(num == n*n) return true;
        int i = row-2;
        int j = col+1;
        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row-2;
        j = col-1;
        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+2);

        i = row + 2;
        j = col - 1;
        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 2;
        j = col + 1;
        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 1;
        j = col + 2;
        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row - 1;
        j = col + 2;
        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row - 1;
        j = col - 2;
        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 1;
        j = col - 2;
        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        return false;
    }
public:
    bool checkValidGrid(vector<vector<int>>& grid) {
        ios::sync_with_stdio(false);
        cin.tie(0);
        cout.tie(0);
        if(grid[0][0] != 0) return false;
        return helper(grid,0,0,1);
    }
};",None,"class Solution {
private:
    bool helper(vector<vector<int>>& grid, int row, int col, int num){
        int n = grid.size();
        if(num == n*n) return true;
        int i = row-2;
        int j = col+1;
        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row-2;
        j = col-1;
        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 2;
        j = col - 1;
        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 2;
        j = col + 1;
        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 1;
        j = col + 2;
        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row - 1;
        j = col + 2;
        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row - 1;
        j = col - 2;
        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 1;
        j = col - 2;
        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        return false;
    }
public:
    bool checkValidGrid(vector<vector<int>>& grid) {
        ios::sync_with_stdio(false);
        cin.tie(0);
        cout.tie(0);
        if(grid[0][0] != 0) return false;
        return helper(grid,0,0,1);
    }
};
"
858,cpp,check-knight-tour-configuration,"class Solution {
private:
    bool helper(vector<vector<int>>& grid, int row, int col, int num){
        int n = grid.size();
        if(num == n*n) return true;
        int i = row-2;
        int j = col+1;
        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row-2;
        j = col-1;
        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+2);

        i = row + 2;
        j = col - 1;
        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 2;
        j = col + 1;
        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 1;
        j = col + 2;
        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row - 1;
        j = col + 2;
        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row - 1;
        j = col - 2;
        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 1;
        j = col - 2;
        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        return false;
    }
public:
    bool checkValidGrid(vector<vector<int>>& grid) {
        ios::sync_with_stdio(false);
        cin.tie(0);
        cout.tie(0);
        if(grid[0][0] != 0) return false;
        return helper(grid,0,0,1);
    }
};",None,"class Solution {
private:
    bool helper(vector<vector<int>>& grid, int row, int col, int num) {
        int n = grid.size();
        if(num == n*n) return true;
        vector<vector<int>> directions = {{-2,1}, {-2,-1}, {2,-1}, {2,1}, {1,2}, {-1,2}, {-1,-2}, {1,-2}};
        for(auto &dir : directions){
            int i = row + dir[0];
            int j = col + dir[1];
            if(i>=0 && i<n && j>=0 && j<n && grid[i][j] == num) {
                if(helper(grid,i,j,num+1)) {
                    return true;
                }
            }
        }
        return false;
    }
public:
    bool checkValidGrid(vector<vector<int>>& grid) {
        ios::sync_with_stdio(false);
        cin.tie(0);
        cout.tie(0);
        if(grid[0][0] != 0) return false;
        return helper(grid,0,0,1);
    }
};
"
859,cpp,climbing-stairs,"class Solution {
public:
    int solve(int n,vector<int> &dp){
        if(n<=2)
          return n;
        
        if(dp[n]!=-1) 
          return dp[n]; 
        
        dp[n]=solve(n-1,dp)+solve(n-3,dp); 
        return dp[n];
    }
    int climbStairs(int n) {
        if(n<=2)
         return n;
        vector<int> dp(n+1);
        for(int i=0;i<=n;i++)
         dp[i]=-1;
        
        return solve(n,dp);
    }
};",None,"class Solution {
public:
    int solve(int n,vector<int> &dp){
        if(n<=2)
          return n;
        
        if(dp[n]!=-1) 
          return dp[n]; 
        
        dp[n]=solve(n-1,dp)+solve(n-2,dp); 
        return dp[n];
    }
    int climbStairs(int n) {
        if(n<=2)
         return n;
        vector<int> dp(n+1);
        for(int i=0;i<=n;i++)
         dp[i]=-1;
        
        return solve(n,dp);
    }
};
"
859,cpp,climbing-stairs,"class Solution {
public:
    int solve(int n,vector<int> &dp){
        if(n<=2)
          return n;
        
        if(dp[n]!=-1) 
          return dp[n]; 
        
        dp[n]=solve(n-1,dp)+solve(n-3,dp); 
        return dp[n];
    }
    int climbStairs(int n) {
        if(n<=2)
         return n;
        vector<int> dp(n+1);
        for(int i=0;i<=n;i++)
         dp[i]=-1;
        
        return solve(n,dp);
    }
};",None,"class Solution {
public:
    int solve(int n,vector<int> &dp){
        if(n<=2)
          return n;
        
        if(dp[n]!=-1) 
          return dp[n]; 
        
        dp[n]=solve(n-1,dp)+solve(n-2,dp); 
        return dp[n];
    }
    int climbStairs(int n) {
        if(n<=2)
         return n;
        vector<int> dp(n+1, -1);
        
        return solve(n,dp);
    }
};
"
859,cpp,climbing-stairs,"class Solution {
public:
    int solve(int n,vector<int> &dp){
        if(n<=2)
          return n;
        
        if(dp[n]!=-1) 
          return dp[n]; 
        
        dp[n]=solve(n-1,dp)+solve(n-3,dp); 
        return dp[n];
    }
    int climbStairs(int n) {
        if(n<=2)
         return n;
        vector<int> dp(n+1);
        for(int i=0;i<=n;i++)
         dp[i]=-1;
        
        return solve(n,dp);
    }
};",None,"class Solution {
public:
    int solve(int n,vector<int> &dp){
        if(n<=2)
          return n;

        if(dp[n]!=-1) 
          return dp[n]; 

        dp[n]=solve(n-1,dp)+solve(n-2,dp); 
        return dp[n];
    }
    int climbStairs(int n) {
        if(n<=2)
         return n;
        vector<int> dp(n+1);
        for(int i=0;i<=n;i++)
         dp[i]=-1;

        return solve(n,dp);
    }
};
"
860,cpp,minimum-cost-to-split-an-array,"class Solution {
public:
    int minCost(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> dp(n,INT_MAX);
        dp[0]=k;
        unordered_map<int,int> freq;

        for(int i=1;i<n;i++)
        {
            int val=0;
            freq.clear();
            for(int j=i;j>=0;j--)
            {
                freq[nums[j]]++;
                if(freq[nums[j]]==2)
                val+=2;
                else if(freq[nums[j]]>2) 
                val++;
                dp[i]=min(dp[i],(j>0?dp[j]:0)+k+val);
            }
        }
        return dp[n];
    }
};",None,"class Solution {
public:
    int minCost(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> dp(n+1,INT_MAX);
        dp[0]=0;
        unordered_map<int,int> freq;

        for(int i=1;i<=n;i++)
        {
            int val=0;
            freq.clear();
            for(int j=i;j>=1;j--)
            {
                freq[nums[j-1]]++;
                if(freq[nums[j-1]]==2)
                val+=2;
                else if(freq[nums[j-1]]>2) 
                val++;
                dp[i]=min(dp[i],dp[j-1]+k+val);
            }
        }
        return dp[n];
    }
};
"
860,cpp,minimum-cost-to-split-an-array,"class Solution {
public:
    int minCost(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> dp(n,INT_MAX);
        dp[0]=k;
        unordered_map<int,int> freq;

        for(int i=1;i<n;i++)
        {
            int val=0;
            freq.clear();
            for(int j=i;j>=0;j--)
            {
                freq[nums[j]]++;
                if(freq[nums[j]]==2)
                val+=2;
                else if(freq[nums[j]]>2) 
                val++;
                dp[i]=min(dp[i],(j>0?dp[j]:0)+k+val);
            }
        }
        return dp[n];
    }
};",None,"class Solution {
public:
    int minCost(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> dp(n,INT_MAX);
        dp[0]=k;
        unordered_map<int,int> freq;

        for(int i=1;i<n;i++)
        {
            int val=0;
            freq.clear();
            for(int j=i;j>=0;j--)
            {
                freq[nums[j]]++;
                if(freq[nums[j]]==2)
                val+=2;
                else if(freq[nums[j]]>2) 
                val++;
                dp[i]=min(dp[i],(j>0?dp[j-1]:0)+k+val);
            }
        }
        return dp[n-1];
    }
};
"
860,cpp,minimum-cost-to-split-an-array,"class Solution {
public:
    int minCost(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> dp(n,INT_MAX);
        dp[0]=k;
        unordered_map<int,int> freq;

        for(int i=1;i<n;i++)
        {
            int val=0;
            freq.clear();
            for(int j=i;j>=0;j--)
            {
                freq[nums[j]]++;
                if(freq[nums[j]]==2)
                val+=2;
                else if(freq[nums[j]]>2) 
                val++;
                dp[i]=min(dp[i],(j>0?dp[j]:0)+k+val);
            }
        }
        return dp[n];
    }
};",None,"class Solution {
public:
    int minCost(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> dp(n,INT_MAX);
        dp[0]=k;
        unordered_map<int,int> freq;

        for(int i=1;i<n;i++)
        {
            int val=0;
            freq.clear();
            for(int j=i;j>=0;j--)
            {
                freq[nums[j]]++;
                if(freq[nums[j]]==2)
                val+=2;
                else if(freq[nums[j]]>2) 
                val++;
                dp[i]=min(dp[i],(j>0?dp[j-1]:0)+k+val);
            }
        }
        return dp[n-1];
    }
};
"
861,cpp,maximum-number-of-ways-to-partition-an-array,"class Solution {
public:
     long long int getSum(vector<int> &nums){
        long long int temp = 0;
        for(auto &i : nums) temp += i-1;
        return temp;
    }

    bool check(unordered_map<long long int, pair<int, int>> &mp, long long int val, int pivot, bool flag){
        
        if(flag){
            if(mp[val].second >= pivot) return true;
            return false;
        }

        else{
            if(mp[val].first < pivot) return true;
            return false;
        }
    }

    int waysToPartition(vector<int>& nums, int k) {
        unordered_map<long long int, pair<int, int>> mp;
        unordered_map<long long int, pair<int, int>> count;

        for(int i=0; i<nums.size(); i++){
            if(mp.find(nums[i]) == mp.end()){
                mp[nums[i]].first = i;
            }
            mp[nums[i]].second = i;
        }

        long long int totSum = getSum(nums);
        long long int left = nums[0];
        int ans = 0;

        for(int i=1; i<nums.size(); i++){
            long long int right = totSum - left;

            if(left == right){
                ans++;
            }
            else{
                long long int diff = left - right;

                long long int num = k - diff;

                if(mp.find(num) != mp.end()){
                    if(check(mp, num, i, 1)){

                        count[num].second++;
                    }
                }

                diff = right - left;
                num = k - diff;

                if(mp.find(num) != mp.end()){
                    if(check(mp, num, i, 0)){

                        count[num].first++; 
                    }
                }
            }

            left += nums[i];

            count[nums[i]].first = max(count[nums[i]].first, count[nums[i]].second);
        }

        int maxi = INT_MIN;
        for(auto [i,j] : count){
            maxi = max(maxi, max(j.first, j.second));
        }

        return max(maxi, ans);
    }
};",None,"class Solution {
public:
     long long int getSum(vector<int> &nums){
        long long int temp = 0;
        for(auto &i : nums) temp += i;
        return temp;
    }

    bool check(unordered_map<long long int, pair<int, int>> &mp, long long int val, int pivot, bool flag){
        
        if(flag){
            if(mp[val].second >= pivot) return true;
            return false;
        }

        else{
            if(mp[val].first < pivot) return true;
            return false;
        }
    }

    int waysToPartition(vector<int>& nums, int k) {
        unordered_map<long long int, pair<int, int>> mp;
        unordered_map<long long int, pair<int, int>> count;

        for(int i=0; i<nums.size(); i++){
            if(mp.find(nums[i]) == mp.end()){
                mp[nums[i]].first = i;
            }
            mp[nums[i]].second = i;
        }

        long long int totSum = getSum(nums);
        long long int left = nums[0];
        int ans = 0;

        for(int i=1; i<nums.size(); i++){
            long long int right = totSum - left;

            if(left == right){
                ans++;
            }
            else{
                long long int diff = left - right;

                long long int num = k - diff;

                if(mp.find(num) != mp.end()){
                    if(check(mp, num, i, true)){

                        count[num].second++;
                    }
                }

                diff = right - left;
                num = k - diff;

                if(mp.find(num) != mp.end()){
                    if(check(mp, num, i, false)){

                        count[num].first++; 
                    }
                }
            }

            left += nums[i];

            count[nums[i]].first = max(count[nums[i]].first, count[nums[i]].second);
        }

        int maxi = INT_MIN;
        for(auto [i,j] : count){
            maxi = max(maxi, max(j.first, j.second));
        }

        return max(maxi, ans);
    }
};
"
861,cpp,maximum-number-of-ways-to-partition-an-array,"class Solution {
public:
     long long int getSum(vector<int> &nums){
        long long int temp = 0;
        for(auto &i : nums) temp += i-1;
        return temp;
    }

    bool check(unordered_map<long long int, pair<int, int>> &mp, long long int val, int pivot, bool flag){
        
        if(flag){
            if(mp[val].second >= pivot) return true;
            return false;
        }

        else{
            if(mp[val].first < pivot) return true;
            return false;
        }
    }

    int waysToPartition(vector<int>& nums, int k) {
        unordered_map<long long int, pair<int, int>> mp;
        unordered_map<long long int, pair<int, int>> count;

        for(int i=0; i<nums.size(); i++){
            if(mp.find(nums[i]) == mp.end()){
                mp[nums[i]].first = i;
            }
            mp[nums[i]].second = i;
        }

        long long int totSum = getSum(nums);
        long long int left = nums[0];
        int ans = 0;

        for(int i=1; i<nums.size(); i++){
            long long int right = totSum - left;

            if(left == right){
                ans++;
            }
            else{
                long long int diff = left - right;

                long long int num = k - diff;

                if(mp.find(num) != mp.end()){
                    if(check(mp, num, i, 1)){

                        count[num].second++;
                    }
                }

                diff = right - left;
                num = k - diff;

                if(mp.find(num) != mp.end()){
                    if(check(mp, num, i, 0)){

                        count[num].first++; 
                    }
                }
            }

            left += nums[i];

            count[nums[i]].first = max(count[nums[i]].first, count[nums[i]].second);
        }

        int maxi = INT_MIN;
        for(auto [i,j] : count){
            maxi = max(maxi, max(j.first, j.second));
        }

        return max(maxi, ans);
    }
};",None,"class Solution {
public:
     long long int getSum(vector<int> &nums){
        long long int temp = 0;
        for(auto &i : nums) temp += i;
        return temp;
    }

    bool check(unordered_map<long long int, pair<int, int>> &mp, long long int val, int pivot, bool flag){
        
        if(flag){
            if(mp[val].second >= pivot) return true;
            return false;
        }

        else{
            if(mp[val].first < pivot) return true;
            return false;
        }
    }

    int waysToPartition(vector<int>& nums, int k) {
        unordered_map<long long int, pair<int, int>> mp;
        unordered_map<long long int, pair<int, int>> count;

        for(int i=0; i<nums.size(); i++){
            if(mp.find(nums[i]) == mp.end()){
                mp[nums[i]].first = i;
            }
            mp[nums[i]].second = i;
        }

        long long int totSum = getSum(nums);
        long long int left = nums[0];
        int ans = 0;

        for(int i=1; i<nums.size(); i++){
            long long int right = totSum - left;

            if(left == right){
                ans++;
            }
            else{
                long long int diff = left - right;

                long long int num = k - diff;

                if(mp.find(num) != mp.end()){
                    if(check(mp, num, i, 1)){

                        count[num].second++;
                    }
                }

                diff = right - left;
                num = k - diff;

                if(mp.find(num) != mp.end()){
                    if(check(mp, num, i, 0)){

                        count[num].first++; 
                    }
                }
            }

            left += nums[i];

            count[nums[i]].first = max(count[nums[i]].first, count[nums[i]].second);
        }

        int maxi = INT_MIN;
        for(auto [i,j] : count){
            maxi = max(maxi, max(j.first, j.second));
        }

        return max(maxi, ans);
    }
};
"
861,cpp,maximum-number-of-ways-to-partition-an-array,"class Solution {
public:
     long long int getSum(vector<int> &nums){
        long long int temp = 0;
        for(auto &i : nums) temp += i-1;
        return temp;
    }

    bool check(unordered_map<long long int, pair<int, int>> &mp, long long int val, int pivot, bool flag){
        
        if(flag){
            if(mp[val].second >= pivot) return true;
            return false;
        }

        else{
            if(mp[val].first < pivot) return true;
            return false;
        }
    }

    int waysToPartition(vector<int>& nums, int k) {
        unordered_map<long long int, pair<int, int>> mp;
        unordered_map<long long int, pair<int, int>> count;

        for(int i=0; i<nums.size(); i++){
            if(mp.find(nums[i]) == mp.end()){
                mp[nums[i]].first = i;
            }
            mp[nums[i]].second = i;
        }

        long long int totSum = getSum(nums);
        long long int left = nums[0];
        int ans = 0;

        for(int i=1; i<nums.size(); i++){
            long long int right = totSum - left;

            if(left == right){
                ans++;
            }
            else{
                long long int diff = left - right;

                long long int num = k - diff;

                if(mp.find(num) != mp.end()){
                    if(check(mp, num, i, 1)){

                        count[num].second++;
                    }
                }

                diff = right - left;
                num = k - diff;

                if(mp.find(num) != mp.end()){
                    if(check(mp, num, i, 0)){

                        count[num].first++; 
                    }
                }
            }

            left += nums[i];

            count[nums[i]].first = max(count[nums[i]].first, count[nums[i]].second);
        }

        int maxi = INT_MIN;
        for(auto [i,j] : count){
            maxi = max(maxi, max(j.first, j.second));
        }

        return max(maxi, ans);
    }
};",None,"class Solution {
public:
    long long int getSum(vector<int> &nums){
        long long int temp = 0;
        for(auto &i : nums) temp += i;
        return temp;
    }

    bool check(unordered_map<long long int, pair<int, int>> &mp, long long int val, int pivot, bool flag){   
        if(flag){
            if(mp[val].second >= pivot) return true;
            return false;
        }
        else{
            if(mp[val].first < pivot) return true;
            return false;
        }
    }

    int waysToPartition(vector<int>& nums, int k) {
        unordered_map<long long int, pair<int, int>> mp;
        unordered_map<long long int, pair<int, int>> count;

        for(int i=0; i<nums.size(); i++){
            if(mp.find(nums[i]) == mp.end()){
                mp[nums[i]].first = i;
            }
            mp[nums[i]].second = i;
        }

        long long int totSum = getSum(nums);
        long long int left = nums[0];
        int ans = 0;

        for(int i=1; i<nums.size(); i++){
            long long int right = totSum - left;

            if(left == right){
                ans++;
            }
            else{
                long long int diff = left - right;

                long long int num = k + diff;
                
                if(mp.find(num) != mp.end()){
                    if(check(mp, num, i, 1)){

                        count[num].second++;
                    }
                }

                diff = right - left;
                num = k + diff;

                if(mp.find(num) != mp.end()){
                    if(check(mp, num, i, 0)){

                        count[num].first++; 
                    }
                }
            }

            left += nums[i];
        }

        int maxi = ans;
        for(auto [i,j] : count){
            maxi = max(maxi, max(j.first, j.second) + ans);
        }

        return maxi;
    }
};
"
862,cpp,shortest-cycle-in-a-graph,"class Solution {
public:
    int f(int ind, unordered_map<int, vector<pair<int, int>>> &mp, int a, int b)
    {
        queue<pair<int, int>> q;
        unordered_map<int, int> vis;
        q.push({a, 0});
        vis[a]=1;
        while(!q.empty())
        {
            int curr = q.front().first;
            int dis = q.front().second;
            q.pop();
            for(auto &x: mp[curr])
            {
                if(x.second==ind || vis[x.first]==1)
                    continue;
                if(x.first == b)
                    return dis;
                q.push({x.first, dis+1});
                vis[x.first]=1;
            }
        }
        return 10000;
    }
    int findShortestCycle(int n, vector<vector<int>>& edges) {
        unordered_map<int, vector<pair<int, int>>> mp;
        for(int i=0; i<edges.size(); i++)
        {
            mp[edges[i][0]].push_back({edges[i][1], i});
            mp[edges[i][1]].push_back({edges[i][0], i});
        }
        int mn = 10000;
        for(int i=0; i<edges.size(); i++)
            mn = min(mn, f(i, mp, edges[i][0], edges[i][1]));
        if(mn>=10000)
            return -1;
        return mn+1;
    }
};",None,"class Solution {
public:
    int f(int ind, unordered_map<int, vector<pair<int, int>>> &mp, int a, int b)
    {
        queue<pair<int, int>> q;
        unordered_map<int, int> vis;
        q.push({a, 0});
        vis[a]=1;
        while(!q.empty())
        {
            int curr = q.front().first;
            int dis = q.front().second;
            q.pop();
            for(auto &x: mp[curr])
            {
                if(x.second==ind)
                    continue;
                if(x.first == b && dis >= 2)
                    return dis;
                if(vis[x.first]!=1){
                    q.push({x.first, dis+1});
                    vis[x.first]=1;
                }
            }
        }
        return 10000;
    }
    int findShortestCycle(int n, vector<vector<int>>& edges) {
        unordered_map<int, vector<pair<int, int>>> mp;
        for(int i=0; i<edges.size(); i++)
        {
            mp[edges[i][0]].push_back({edges[i][1], i});
            mp[edges[i][1]].push_back({edges[i][0], i});
        }
        int mn = 10000;
        for(int i=0; i<edges.size(); i++)
            mn = min(mn, f(i, mp, edges[i][0], edges[i][1]));
        if(mn>=10000)
            return -1;
        return mn+1;
    }
};
"
862,cpp,shortest-cycle-in-a-graph,"class Solution {
public:
    int f(int ind, unordered_map<int, vector<pair<int, int>>> &mp, int a, int b)
    {
        queue<pair<int, int>> q;
        unordered_map<int, int> vis;
        q.push({a, 0});
        vis[a]=1;
        while(!q.empty())
        {
            int curr = q.front().first;
            int dis = q.front().second;
            q.pop();
            for(auto &x: mp[curr])
            {
                if(x.second==ind || vis[x.first]==1)
                    continue;
                if(x.first == b)
                    return dis;
                q.push({x.first, dis+1});
                vis[x.first]=1;
            }
        }
        return 10000;
    }
    int findShortestCycle(int n, vector<vector<int>>& edges) {
        unordered_map<int, vector<pair<int, int>>> mp;
        for(int i=0; i<edges.size(); i++)
        {
            mp[edges[i][0]].push_back({edges[i][1], i});
            mp[edges[i][1]].push_back({edges[i][0], i});
        }
        int mn = 10000;
        for(int i=0; i<edges.size(); i++)
            mn = min(mn, f(i, mp, edges[i][0], edges[i][1]));
        if(mn>=10000)
            return -1;
        return mn+1;
    }
};",None,"class Solution {
public:
    int f(int ind, unordered_map<int, vector<pair<int, int>>> &mp, int a, int b)
    {
        queue<pair<int, int>> q;
        unordered_map<int, int> vis;
        q.push({a, 0});
        vis[a]=1;
        while(!q.empty())
        {
            int curr = q.front().first;
            int dis = q.front().second;
            q.pop();
            for(auto &x: mp[curr])
            {
                if(x.second==ind)
                    continue;
                if(x.first == b)
                    return dis+1;
                if(vis[x.first] == 0) {
                    q.push({x.first, dis+1});
                    vis[x.first]=1;
                }
            }
        }
        return 10000;
    }
    int findShortestCycle(int n, vector<vector<int>>& edges) {
        unordered_map<int, vector<pair<int, int>>> mp;
        for(int i=0; i<edges.size(); i++)
        {
            mp[edges[i][0]].push_back({edges[i][1], i});
            mp[edges[i][1]].push_back({edges[i][0], i});
        }
        int mn = 10000;
        for(int i=0; i<edges.size(); i++)
            mn = min(mn, f(i, mp, edges[i][0], edges[i][1]));
        if(mn>=10000)
            return -1;
        return mn;
    }
};
"
862,cpp,shortest-cycle-in-a-graph,"class Solution {
public:
    int f(int ind, unordered_map<int, vector<pair<int, int>>> &mp, int a, int b)
    {
        queue<pair<int, int>> q;
        unordered_map<int, int> vis;
        q.push({a, 0});
        vis[a]=1;
        while(!q.empty())
        {
            int curr = q.front().first;
            int dis = q.front().second;
            q.pop();
            for(auto &x: mp[curr])
            {
                if(x.second==ind || vis[x.first]==1)
                    continue;
                if(x.first == b)
                    return dis;
                q.push({x.first, dis+1});
                vis[x.first]=1;
            }
        }
        return 10000;
    }
    int findShortestCycle(int n, vector<vector<int>>& edges) {
        unordered_map<int, vector<pair<int, int>>> mp;
        for(int i=0; i<edges.size(); i++)
        {
            mp[edges[i][0]].push_back({edges[i][1], i});
            mp[edges[i][1]].push_back({edges[i][0], i});
        }
        int mn = 10000;
        for(int i=0; i<edges.size(); i++)
            mn = min(mn, f(i, mp, edges[i][0], edges[i][1]));
        if(mn>=10000)
            return -1;
        return mn+1;
    }
};",None,"class Solution {
public:
    int f(int ind, unordered_map<int, vector<pair<int, int>>> &mp, int a, int b)
    {
        queue<pair<int, int>> q;
        unordered_map<int, int> vis;
        q.push({a, 0});
        vis[a] = 1;
        while(!q.empty())
        {
            int curr = q.front().first;
            int dis = q.front().second;
            q.pop();
            for(auto &x: mp[curr])
            {
                if(x.second == ind)
                    continue;
                if(vis[x.first] == 1 && x.first != b)
                    continue;
                if(x.first == b)
                    return dis+1;
                q.push({x.first, dis+1});
                vis[x.first] = 1;
            }
        }
        return 10000;
    }
    int findShortestCycle(int n, vector<vector<int>>& edges) {
        unordered_map<int, vector<pair<int, int>>> mp;
        for(int i=0; i<edges.size(); i++)
        {
            mp[edges[i][0]].push_back({edges[i][1], i});
            mp[edges[i][1]].push_back({edges[i][0], i});
        }
        int mn = 10000;
        for(int i=0; i<edges.size(); i++)
            mn = min(mn, f(i, mp, edges[i][0], edges[i][1]));
        if(mn >= 10000)
            return -1;
        return mn;
    }
};
"
863,cpp,average-salary-excluding-the-minimum-and-maximum-salary,"class Solution {
public:
    double average(vector<int>& salary) {
        int n=salary.size(),sum=0,Min=INT_MAX,Max=INT_MIN;
        for(int i:salary){
            Max = Max < i ? i : 0 ;
            Min = Min > i ? i : Min ;
            sum += i;
        }
        sum -= (Min + Max);
        return sum/(n-2.0);
    }
};",None,"class Solution {
public:
    double average(vector<int>& salary) {
        int n=salary.size(),sum=0,Min=INT_MAX,Max=INT_MIN;
        for(int i:salary){
            Max = Max < i ? i : Max ;
            Min = Min > i ? i : Min ;
            sum += i;
        }
        sum -= (Min + Max);
        return sum/(n-2.0);
    }
};
"
863,cpp,average-salary-excluding-the-minimum-and-maximum-salary,"class Solution {
public:
    double average(vector<int>& salary) {
        int n=salary.size(),sum=0,Min=INT_MAX,Max=INT_MIN;
        for(int i:salary){
            Max = Max < i ? i : 0 ;
            Min = Min > i ? i : Min ;
            sum += i;
        }
        sum -= (Min + Max);
        return sum/(n-2.0);
    }
};",None,"class Solution {
public:
    double average(vector<int>& salary) {
        int n=salary.size(),sum=0,Min=INT_MAX,Max=INT_MIN;
        for(int i:salary){
            Max = Max < i ? i : Max ;
            Min = Min > i ? i : Min ;
            sum += i;
        }
        sum -= (Min + Max);
        return sum/(n-2.0);
    }
};
"
863,cpp,average-salary-excluding-the-minimum-and-maximum-salary,"class Solution {
public:
    double average(vector<int>& salary) {
        int n=salary.size(),sum=0,Min=INT_MAX,Max=INT_MIN;
        for(int i:salary){
            Max = Max < i ? i : 0 ;
            Min = Min > i ? i : Min ;
            sum += i;
        }
        sum -= (Min + Max);
        return sum/(n-2.0);
    }
};",None,"class Solution {
public:
    double average(vector<int>& salary) {
        int n=salary.size(),sum=0,Min=INT_MAX,Max=INT_MIN;
        for(int i:salary){
            Max = (Max < i) ? i : Max ;
            Min = (Min > i) ? i : Min ;
            sum += i;
        }
        sum -= (Min + Max);
        return sum/(n-2.0);
    }
};
"
864,cpp,01-matrix,"class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int n=mat.size();
        int m=mat[0].size();
        vector<vector<int>>dp(n,vector<int>(m,INT_MAX-2));
        for (int i=0;i<n;i++){
            for (int j=0;j<m;j++){
                if (mat[i][j]==0) dp[i][j]=0;
                else {
                    if (i>0) dp[i][j]= min (dp[i][j], dp[i-1][j]+1);
                    if (j>0) dp[i][j]=min (dp[i][j],dp[i][j-1]+1);
                }
            }
        }

        for (int i=n-1;i>=0;i--){
            for (int j=m-1;j>=0;j--){
                if (mat[i][j]==0) dp[i][j]=INT_MAX-1;
                else {
                    if (i<n-1) dp[i][j]= min (dp[i][j], dp[i+1][j]+1);
                    if (j<m-1) dp[i][j]=min (dp[i][j],dp[i][j+1]+1);
                }
            }
        }
        return dp;
    }
};",None,"class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int n=mat.size();
        int m=mat[0].size();
        vector<vector<int>>dp(n,vector<int>(m,INT_MAX-2));
        for (int i=0;i<n;i++){
            for (int j=0;j<m;j++){
                if (mat[i][j]==0) dp[i][j]=0;
                else {
                    if (i>0) dp[i][j]= min (dp[i][j], dp[i-1][j]+1);
                    if (j>0) dp[i][j]=min (dp[i][j],dp[i][j-1]+1);
                }
            }
        }

        for (int i=n-1;i>=0;i--){
            for (int j=m-1;j>=0;j--){
                if (mat[i][j]!=0) {
                    if (i<n-1) dp[i][j]= min (dp[i][j], dp[i+1][j]+1);
                    if (j<m-1) dp[i][j]=min (dp[i][j],dp[i][j+1]+1);
                }
            }
        }
        return dp;
    }
};
"
864,cpp,01-matrix,"class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int n=mat.size();
        int m=mat[0].size();
        vector<vector<int>>dp(n,vector<int>(m,INT_MAX-2));
        for (int i=0;i<n;i++){
            for (int j=0;j<m;j++){
                if (mat[i][j]==0) dp[i][j]=0;
                else {
                    if (i>0) dp[i][j]= min (dp[i][j], dp[i-1][j]+1);
                    if (j>0) dp[i][j]=min (dp[i][j],dp[i][j-1]+1);
                }
            }
        }

        for (int i=n-1;i>=0;i--){
            for (int j=m-1;j>=0;j--){
                if (mat[i][j]==0) dp[i][j]=INT_MAX-1;
                else {
                    if (i<n-1) dp[i][j]= min (dp[i][j], dp[i+1][j]+1);
                    if (j<m-1) dp[i][j]=min (dp[i][j],dp[i][j+1]+1);
                }
            }
        }
        return dp;
    }
};",None,"class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int n=mat.size();
        int m=mat[0].size();
        vector<vector<int>> dp(n, vector<int>(m, INT_MAX - 2));
        for (int i = 0; i < n; i++){
            for (int j = 0; j < m; j++){
                if (mat[i][j] == 0) dp[i][j] = 0;
                else {
                    if (i > 0) dp[i][j] = min(dp[i][j], dp[i-1][j] + 1);
                    if (j > 0) dp[i][j] = min(dp[i][j], dp[i][j-1] + 1);
                }
            }
        }

        for (int i = n - 1; i >= 0; i--){
            for (int j = m - 1; j >= 0; j--){
                if (mat[i][j] != 0) {
                    if (i < n - 1) dp[i][j] = min(dp[i][j], dp[i+1][j] + 1);
                    if (j < m - 1) dp[i][j] = min(dp[i][j], dp[i][j+1] + 1);
                }
            }
        }
        return dp;
    }
};
"
864,cpp,01-matrix,"class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int n=mat.size();
        int m=mat[0].size();
        vector<vector<int>>dp(n,vector<int>(m,INT_MAX-2));
        for (int i=0;i<n;i++){
            for (int j=0;j<m;j++){
                if (mat[i][j]==0) dp[i][j]=0;
                else {
                    if (i>0) dp[i][j]= min (dp[i][j], dp[i-1][j]+1);
                    if (j>0) dp[i][j]=min (dp[i][j],dp[i][j-1]+1);
                }
            }
        }

        for (int i=n-1;i>=0;i--){
            for (int j=m-1;j>=0;j--){
                if (mat[i][j]==0) dp[i][j]=INT_MAX-1;
                else {
                    if (i<n-1) dp[i][j]= min (dp[i][j], dp[i+1][j]+1);
                    if (j<m-1) dp[i][j]=min (dp[i][j],dp[i][j+1]+1);
                }
            }
        }
        return dp;
    }
};",None,"class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int n=mat.size();
        int m=mat[0].size();
        vector<vector<int>>dp(n,vector<int>(m,INT_MAX-2));
        for (int i=0;i<n;i++){
            for (int j=0;j<m;j++){
                if (mat[i][j]==0) dp[i][j]=0;
                else {
                    if (i>0) dp[i][j]= min (dp[i][j], dp[i-1][j]+1);
                    if (j>0) dp[i][j]=min (dp[i][j],dp[i][j-1]+1);
                }
            }
        }

        for (int i=n-1;i>=0;i--){
            for (int j=m-1;j>=0;j--){
                if (mat[i][j] != 0) {
                    if (i<n-1) dp[i][j]= min (dp[i][j], dp[i+1][j]+1);
                    if (j<m-1) dp[i][j]=min (dp[i][j],dp[i][j+1]+1);
                }
            }
        }
        return dp;
    }
};
"
865,cpp,find-the-winner-of-the-circular-game,"class Solution {
public:
    int findTheWinner(int n, int k) {
        vector<int> v;
        for (int i=1; i<=n; i++)v.push_back(i);
        int i=0;
        while (v.size() != 1){
            i= (i+k)%(v.size());
            v.erase(v.begin()+i);
        }
        return v[0];
    }
};",None,"class Solution {
public:
    int findTheWinner(int n, int k) {
        vector<int> v;
        for (int i = 1; i <= n; i++) v.push_back(i);
        int i = 0;
        while (v.size() != 1){
            i = (i + k - 1) % (v.size());
            v.erase(v.begin() + i);
        }
        return v[0];
    }
};
"
865,cpp,find-the-winner-of-the-circular-game,"class Solution {
public:
    int findTheWinner(int n, int k) {
        vector<int> v;
        for (int i=1; i<=n; i++)v.push_back(i);
        int i=0;
        while (v.size() != 1){
            i= (i+k)%(v.size());
            v.erase(v.begin()+i);
        }
        return v[0];
    }
};",None,"class Solution {
public:
    int findTheWinner(int n, int k) {
        vector<int> v;
        for (int i=1; i<=n; i++)v.push_back(i);
        int i=0;
        while (v.size() != 1){
            i= (i+k-1)%(v.size());
            v.erase(v.begin()+i);
        }
        return v[0];
    }
};
"
865,cpp,find-the-winner-of-the-circular-game,"class Solution {
public:
    int findTheWinner(int n, int k) {
        vector<int> v;
        for (int i=1; i<=n; i++)v.push_back(i);
        int i=0;
        while (v.size() != 1){
            i= (i+k)%(v.size());
            v.erase(v.begin()+i);
        }
        return v[0];
    }
};",None,"class Solution {
public:
    int findTheWinner(int n, int k) {
        vector<int> v;
        for (int i=1; i<=n; i++)v.push_back(i);
        int i=0;
        while (v.size() != 1){
            i= (i+k-1)%(v.size());
            v.erase(v.begin()+i);
        }
        return v[0];
    }
};
"
866,cpp,length-of-the-longest-valid-substring,"class Solution {
public:
    int longestValidSubstring(string word, vector<string>& forbidden) {
        vector<int> ends(word.size() , -1);
        unordered_map<string, int> forbidden_word;
        for(auto it : forbidden) forbidden_word[it] = 1;
        int n = word.size();
        for(int i = 0; i<n; i++){
            string temp = """";
            for(int j = i; j<i+10 && j<n; j++){
                temp += word[j];
                if(forbidden_word.find(temp) != forbidden_word.end()) {
                    ends[j] = i;
                }
            }
        }
        
        int i = 0, j = 0;
        int ans = INT_MIN;
        while(j < n){
            
            if(ends[j] != -1){
                int st = ends[j];
                if(st < i){
                    ans = max(ans, j-i+1);
                }
                else{
                    i = st+1;
                    ans = max(ans, j-i);
                }
            }
            else ans = max(ans,j-i+1);
            j++;
        }
        return ans;
    }
};",None,"class Solution {
public:
    int longestValidSubstring(string word, vector<string>& forbidden) {
        vector<int> ends(word.size() , -1);
        unordered_map<string, int> forbidden_word;
        for(auto it : forbidden) forbidden_word[it] = 1;
        int n = word.size();
        for(int i = 0; i<n; i++){
            string temp = """";
            for(int j = i; j<i+10 && j<n; j++){
                temp += word[j];
                if(forbidden_word.find(temp) != forbidden_word.end()) {
                    ends[j] = i;
                }
            }
        }
        
        int i = 0, j = 0;
        int ans = 0;
        while(j < n){
            
            if(ends[j] != -1){
                int st = ends[j];
                if(st < i){
                    ans = max(ans, j-i+1);
                }
                else{
                    i = st+1;
                }
            }
            else ans = max(ans,j-i+1);
            j++;
        }
        return ans;
    }
};
"
866,cpp,length-of-the-longest-valid-substring,"class Solution {
public:
    int longestValidSubstring(string word, vector<string>& forbidden) {
        vector<int> ends(word.size() , -1);
        unordered_map<string, int> forbidden_word;
        for(auto it : forbidden) forbidden_word[it] = 1;
        int n = word.size();
        for(int i = 0; i<n; i++){
            string temp = """";
            for(int j = i; j<i+10 && j<n; j++){
                temp += word[j];
                if(forbidden_word.find(temp) != forbidden_word.end()) {
                    ends[j] = i;
                }
            }
        }
        
        int i = 0, j = 0;
        int ans = INT_MIN;
        while(j < n){
            
            if(ends[j] != -1){
                int st = ends[j];
                if(st < i){
                    ans = max(ans, j-i+1);
                }
                else{
                    i = st+1;
                    ans = max(ans, j-i);
                }
            }
            else ans = max(ans,j-i+1);
            j++;
        }
        return ans;
    }
};",None,"class Solution {
public:
    int longestValidSubstring(string word, vector<string>& forbidden) {
        vector<int> ends(word.size() , -1);
        unordered_map<string, int> forbidden_word;
        for(auto it : forbidden) forbidden_word[it] = 1;
        int n = word.size();
        for(int i = 0; i<n; i++){
            string temp = """";
            for(int j = i; j<i+10 && j<n; j++){
                temp += word[j];
                if(forbidden_word.find(temp) != forbidden_word.end()) {
                    ends[j] = i;
                }
            }
        }
        
        int i = 0, j = 0;
        int ans = 0;
        while(j < n){
            
            if(ends[j] != -1){
                int st = ends[j];
                if(st < i){
                    ans = max(ans, j-i+1);
                }
                else{
                    i = st+1;
                    ans = max(ans, j-i);
                }
            }
            else ans = max(ans,j-i+1);
            j++;
        }
        return ans;
    }
};
"
866,cpp,length-of-the-longest-valid-substring,"class Solution {
public:
    int longestValidSubstring(string word, vector<string>& forbidden) {
        vector<int> ends(word.size() , -1);
        unordered_map<string, int> forbidden_word;
        for(auto it : forbidden) forbidden_word[it] = 1;
        int n = word.size();
        for(int i = 0; i<n; i++){
            string temp = """";
            for(int j = i; j<i+10 && j<n; j++){
                temp += word[j];
                if(forbidden_word.find(temp) != forbidden_word.end()) {
                    ends[j] = i;
                }
            }
        }
        
        int i = 0, j = 0;
        int ans = INT_MIN;
        while(j < n){
            
            if(ends[j] != -1){
                int st = ends[j];
                if(st < i){
                    ans = max(ans, j-i+1);
                }
                else{
                    i = st+1;
                    ans = max(ans, j-i);
                }
            }
            else ans = max(ans,j-i+1);
            j++;
        }
        return ans;
    }
};",None,"class Solution {
public:
    int longestValidSubstring(string word, vector<string>& forbidden) {
        vector<int> ends(word.size() , -1);
        unordered_map<string, int> forbidden_word;
        for(auto it : forbidden) forbidden_word[it] = 1;
        int n = word.size();
        for(int i = 0; i<n; i++){
            string temp = """";
            for(int j = i; j<i+10 && j<n; j++){
                temp += word[j];
                if(forbidden_word.find(temp) != forbidden_word.end()) {
                    ends[j] = i;
                }
            }
        }
        
        int i = 0, j = 0;
        int ans = 0;
        while(j < n){
            
            if(ends[j] != -1){
                int st = ends[j];
                if(st < i){
                    ans = max(ans, j-i+1);
                }
                else{
                    i = st+1;
                }
            }
            else ans = max(ans,j-i+1);
            j++;
        }
        return ans;
    }
};
"
867,cpp,maximum-strictly-increasing-cells-in-a-matrix,"class Solution {
public:
    int maxIncreasingCells(vector<vector<int>>& mat) {
        int n = mat.size(), m = mat[0].size();
        vector<int> row_max(n), col_max(m);
        
        map<int, vector<pair<int, int>>, greater<int>> pos;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                pos[mat[i][j]].push_back({i, j});
            }
        }
        
        int ans = 0;
        for (auto& [num, cells]: pos) {
            int k = cells.size();
            vector<int> next(k);
            for (int i = 0; i < k; ++i) {
                int r = cells[i].first, c = cells[i].second;
                next[i] = min(row_max[r], col_max[c]) + 1;
                ans = max(ans, next[i]);
            }
            for (int i = 0; i < k; ++i) {
                int r = cells[i].first, c = cells[i].second;
                row_max[r] = max(row_max[r], next[i]);
                col_max[c] = max(col_max[c], next[i]);
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    int maxIncreasingCells(vector<vector<int>>& mat) {
        int n = mat.size(), m = mat[0].size();
        vector<int> row_max(n, 0), col_max(m, 0);
        
        map<int, vector<pair<int, int>>, greater<int>> pos;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                pos[mat[i][j]].push_back({i, j});
            }
        }
        
        int ans = 1;
        for (auto& [num, cells]: pos) {
            int k = cells.size();
            vector<int> next(k, 1);
            for (int i = 0; i < k; ++i) {
                int r = cells[i].first, c = cells[i].second;
                next[i] = max(next[i], max(row_max[r], col_max[c]) + 1);
                ans = max(ans, next[i]);
            }
            for (int i = 0; i < k; ++i) {
                int r = cells[i].first, c = cells[i].second;
                row_max[r] = max(row_max[r], next[i]);
                col_max[c] = max(col_max[c], next[i]);
            }
        }
        return ans;
    }
};
"
867,cpp,maximum-strictly-increasing-cells-in-a-matrix,"class Solution {
public:
    int maxIncreasingCells(vector<vector<int>>& mat) {
        int n = mat.size(), m = mat[0].size();
        vector<int> row_max(n), col_max(m);
        
        map<int, vector<pair<int, int>>, greater<int>> pos;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                pos[mat[i][j]].push_back({i, j});
            }
        }
        
        int ans = 0;
        for (auto& [num, cells]: pos) {
            int k = cells.size();
            vector<int> next(k);
            for (int i = 0; i < k; ++i) {
                int r = cells[i].first, c = cells[i].second;
                next[i] = min(row_max[r], col_max[c]) + 1;
                ans = max(ans, next[i]);
            }
            for (int i = 0; i < k; ++i) {
                int r = cells[i].first, c = cells[i].second;
                row_max[r] = max(row_max[r], next[i]);
                col_max[c] = max(col_max[c], next[i]);
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    int maxIncreasingCells(vector<vector<int>>& mat) {
        int n = mat.size(), m = mat[0].size();
        vector<int> row_max(n, 1), col_max(m, 1);
        
        map<int, vector<pair<int, int>>, greater<int>> pos;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                pos[mat[i][j]].push_back({i, j});
            }
        }
        
        int ans = 1;
        for (auto& [num, cells]: pos) {
            int k = cells.size();
            vector<int> next(k);
            for (int i = 0; i < k; ++i) {
                int r = cells[i].first, c = cells[i].second;
                next[i] = max(max(row_max[r], col_max[c]), 1);
                ans = max(ans, next[i]);
            }
            for (int i = 0; i < k; ++i) {
                int r = cells[i].first, c = cells[i].second;
                row_max[r] = max(row_max[r], next[i] + 1);
                col_max[c] = max(col_max[c], next[i] + 1);
            }
        }
        return ans;
    }
};
"
867,cpp,maximum-strictly-increasing-cells-in-a-matrix,"class Solution {
public:
    int maxIncreasingCells(vector<vector<int>>& mat) {
        int n = mat.size(), m = mat[0].size();
        vector<int> row_max(n), col_max(m);
        
        map<int, vector<pair<int, int>>, greater<int>> pos;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                pos[mat[i][j]].push_back({i, j});
            }
        }
        
        int ans = 0;
        for (auto& [num, cells]: pos) {
            int k = cells.size();
            vector<int> next(k);
            for (int i = 0; i < k; ++i) {
                int r = cells[i].first, c = cells[i].second;
                next[i] = min(row_max[r], col_max[c]) + 1;
                ans = max(ans, next[i]);
            }
            for (int i = 0; i < k; ++i) {
                int r = cells[i].first, c = cells[i].second;
                row_max[r] = max(row_max[r], next[i]);
                col_max[c] = max(col_max[c], next[i]);
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    int maxIncreasingCells(vector<vector<int>>& mat) {
        int n = mat.size(), m = mat[0].size();
        vector<int> row_max(n, 0), col_max(m, 0);

        map<int, vector<pair<int, int>>, greater<int>> pos;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                pos[mat[i][j]].push_back({i, j});
            }
        }

        int ans = 0;
        for (auto& [num, cells]: pos) {
            vector<pair<int, int>> next(cells.size());
            for (int i = 0; i < cells.size(); ++i) {
                int r = cells[i].first, c = cells[i].second;
                next[i] = make_pair(r, c, max(row_max[r], col_max[c]) + 1);
                ans = max(ans, next[i].third);
            }
            for (auto &[r, c, max_val] : next) {
                row_max[r] = max(row_max[r], max_val);
                col_max[c] = max(col_max[c], max_val);
            }
        }
        return ans;
    }
};
"
868,cpp,find-the-minimum-and-maximum-number-of-nodes-between-critical-points,"class Solution {
public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        vector<int> ans={-1,-1};
        ListNode* prev=head;
        if(!prev) return ans;
        ListNode* curr=prev->next;
        if(!curr) return ans;
        ListNode* next=curr->next;
        if(!next) return ans;

        int first=-1;
        int last=-1;
        int mind=INT_MAX;
        int i=1;
        while(next){
            bool iscp=((curr->val>prev->val && curr->val>next->val)||(curr->val<prev->val&&curr->val<next->val))?true:false;
            if(iscp&&first==-1){
                first=i;
                last=i;
            }
            else if(iscp){
                mind=min(mind,i-last);
                last=i;
            }
            i++;
            prev=curr;
            curr=next;
            next=next->next;
        }
        if(first==last)
         return ans;
         else
         {
             ans[0]=mind;
             ans[1]=last+first;
         }
         return ans;
    }
};",None,"class Solution {
public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        vector<int> ans={-1,-1};
        ListNode* prev=head;
        if(!prev) return ans;
        ListNode* curr=prev->next;
        if(!curr) return ans;
        ListNode* next=curr->next;
        if(!next) return ans;

        int first=-1;
        int last=-1;
        int mind=INT_MAX;
        int i=1;
        while(next){
            bool iscp=((curr->val>prev->val && curr->val>next->val)||(curr->val<prev->val&&curr->val<next->val))?true:false;
            if(iscp && first==-1){
                first=i;
                last=i;
            }
            else if(iscp){
                mind=min(mind,i-last);
                last=i;
            }
            i++;
            prev=curr;
            curr=next;
            next=next->next;
        }
        if(first==last)
            return ans;
        else {
            ans[0]=mind;
            ans[1]=last-first;
        }
        return ans;
    }
};
"
868,cpp,find-the-minimum-and-maximum-number-of-nodes-between-critical-points,"class Solution {
public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        vector<int> ans={-1,-1};
        ListNode* prev=head;
        if(!prev) return ans;
        ListNode* curr=prev->next;
        if(!curr) return ans;
        ListNode* next=curr->next;
        if(!next) return ans;

        int first=-1;
        int last=-1;
        int mind=INT_MAX;
        int i=1;
        while(next){
            bool iscp=((curr->val>prev->val && curr->val>next->val)||(curr->val<prev->val&&curr->val<next->val))?true:false;
            if(iscp&&first==-1){
                first=i;
                last=i;
            }
            else if(iscp){
                mind=min(mind,i-last);
                last=i;
            }
            i++;
            prev=curr;
            curr=next;
            next=next->next;
        }
        if(first==last)
         return ans;
         else
         {
             ans[0]=mind;
             ans[1]=last+first;
         }
         return ans;
    }
};",None,"class Solution {
public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        vector<int> ans={-1,-1};
        ListNode* prev=head;
        if(!prev) return ans;
        ListNode* curr=prev->next;
        if(!curr) return ans;
        ListNode* next=curr->next;
        if(!next) return ans;

        int first=-1;
        int last=-1;
        int mind=INT_MAX;
        int i=1;
        while(next){
            bool iscp=((curr->val>prev->val && curr->val>next->val)||(curr->val<prev->val&&curr->val<next->val))?true:false;
            if(iscp&&first==-1){
                first=i;
                last=i;
            }
            else if(iscp){
                mind=min(mind,i-last);
                last=i;
            }
            i++;
            prev=curr;
            curr=next;
            next=next->next;
        }
        if(first==last)
         return ans;
         else
         {
             ans[0]=mind;
             ans[1]=last-first;
         }
         return ans;
    }
};
"
868,cpp,find-the-minimum-and-maximum-number-of-nodes-between-critical-points,"class Solution {
public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        vector<int> ans={-1,-1};
        ListNode* prev=head;
        if(!prev) return ans;
        ListNode* curr=prev->next;
        if(!curr) return ans;
        ListNode* next=curr->next;
        if(!next) return ans;

        int first=-1;
        int last=-1;
        int mind=INT_MAX;
        int i=1;
        while(next){
            bool iscp=((curr->val>prev->val && curr->val>next->val)||(curr->val<prev->val&&curr->val<next->val))?true:false;
            if(iscp&&first==-1){
                first=i;
                last=i;
            }
            else if(iscp){
                mind=min(mind,i-last);
                last=i;
            }
            i++;
            prev=curr;
            curr=next;
            next=next->next;
        }
        if(first==last)
         return ans;
         else
         {
             ans[0]=mind;
             ans[1]=last+first;
         }
         return ans;
    }
};",None,"class Solution {
public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        vector<int> ans={-1,-1};
        ListNode* prev=head;
        if(!prev) return ans;
        ListNode* curr=prev->next;
        if(!curr) return ans;
        ListNode* next=curr->next;
        if(!next) return ans;

        int first=-1;
        int last=-1;
        int mind=INT_MAX;
        int maxd=INT_MIN;
        int i=1;
        while(next){
            bool iscp=((curr->val>prev->val && curr->val>next->val)||(curr->val<prev->val&&curr->val<next->val))?true:false;
            if(iscp && first==-1){
                first=i;
            }
            if(iscp) {
                if (first != -1) {
                    mind = min(mind, i - first);
                    maxd = max(maxd, i - first);
                }
                first = i;
            }
            i++;
            prev=curr;
            curr=next;
            next=next->next;
        }
        if(mind == INT_MAX)
            return ans;
        ans[0] = mind;
        ans[1] = maxd;
        return ans;
    }
};
"
869,cpp,widest-vertical-area-between-two-points-containing-no-points,"class Solution {
public:
  int maxWidthOfVerticalArea(vector<vector<int>>& points) {
    set<int> x;
    int res = 0;
    for (auto &p : points)
        x.insert(p[0]);
    for (auto it = next(begin(x)); it != end(x); ++it)
        res = max(res, *it - *prev(it));
    return ++res;
}
};",None,"class Solution {
public:
  int maxWidthOfVerticalArea(vector<vector<int>>& points) {
    set<int> x;
    int res = 0;
    for (auto &p : points)
        x.insert(p[0]);
    for (auto it = next(begin(x)); it != end(x); ++it)
        res = max(res, *it - *prev(it));
    return res;
}
};
"
869,cpp,widest-vertical-area-between-two-points-containing-no-points,"class Solution {
public:
  int maxWidthOfVerticalArea(vector<vector<int>>& points) {
    set<int> x;
    int res = 0;
    for (auto &p : points)
        x.insert(p[0]);
    for (auto it = next(begin(x)); it != end(x); ++it)
        res = max(res, *it - *prev(it));
    return ++res;
}
};",None,"class Solution {
public:
  int maxWidthOfVerticalArea(vector<vector<int>>& points) {
    set<int> x;
    int res = 0;
    for (auto &p : points)
        x.insert(p[0]);
    for (auto it = next(begin(x)); it != end(x); ++it)
        res = max(res, *it - *prev(it));
    return res;
  }
};
"
869,cpp,widest-vertical-area-between-two-points-containing-no-points,"class Solution {
public:
  int maxWidthOfVerticalArea(vector<vector<int>>& points) {
    set<int> x;
    int res = 0;
    for (auto &p : points)
        x.insert(p[0]);
    for (auto it = next(begin(x)); it != end(x); ++it)
        res = max(res, *it - *prev(it));
    return ++res;
}
};",None,"class Solution {
public:
  int maxWidthOfVerticalArea(vector<vector<int>>& points) {
    set<int> x;
    int res = 0;
    for (auto &p : points)
        x.insert(p[0]);
    for (auto it = next(begin(x)); it != end(x); ++it)
        res = max(res, *it - *prev(it));
    return res;
  }
};
"
870,cpp,calculate-money-in-leetcode-bank,"class Solution {
public:
    int Rem(int a)
    {
        return (a * (a+1) )/2;
    }
    int totalMoney(int n) {
        int ans = 0,dif=28;
        int a = 0;

        a = n/7;
        
        for(int i=0;i<a;i++)
        {
            ans+=dif;
            dif+=7;
        }

        int b = n%7;
        int ad = Rem(b);
        ad+= a*b;

        ans-=ad; 


        return ans;
    }
};",None,"class Solution {
public:
    int Rem(int a)
    {
        return (a * (a+1) )/2;
    }
    int totalMoney(int n) {
        int ans = 0, dif=28;
        int a = 0;

        a = n/7;
        
        for(int i=0;i<a;i++)
        {
            ans+=dif;
            dif+=7;
        }

        int b = n%7;
        int ad = Rem(b);
        ad+= a*b;

        ans+=ad; 


        return ans;
    }
};
"
870,cpp,calculate-money-in-leetcode-bank,"class Solution {
public:
    int Rem(int a)
    {
        return (a * (a+1) )/2;
    }
    int totalMoney(int n) {
        int ans = 0,dif=28;
        int a = 0;

        a = n/7;
        
        for(int i=0;i<a;i++)
        {
            ans+=dif;
            dif+=7;
        }

        int b = n%7;
        int ad = Rem(b);
        ad+= a*b;

        ans-=ad; 


        return ans;
    }
};",None,"class Solution {
public:
    int Rem(int a)
    {
        return (a * (a+1) )/2;
    }
    int totalMoney(int n) {
        int ans = 0,dif=28;
        int a = 0;

        a = n/7;

        for(int i=0;i<a;i++)
        {
            ans+=dif;
            dif+=7;
        }

        int b = n%7;
        int ad = Rem(b);
        ad+= a*b;

        ans+=ad; 

        return ans;
    }
};
"
870,cpp,calculate-money-in-leetcode-bank,"class Solution {
public:
    int Rem(int a)
    {
        return (a * (a+1) )/2;
    }
    int totalMoney(int n) {
        int ans = 0,dif=28;
        int a = 0;

        a = n/7;
        
        for(int i=0;i<a;i++)
        {
            ans+=dif;
            dif+=7;
        }

        int b = n%7;
        int ad = Rem(b);
        ad+= a*b;

        ans-=ad; 


        return ans;
    }
};",None,"class Solution {
public:
    int Rem(int a)
    {
        return (a * (a+1) )/2;
    }
    int totalMoney(int n) {
        int ans = 0, dif=28;
        int a = 0;

        a = n/7;
        
        for(int i=0;i<a;i++)
        {
            ans+=dif;
            dif+=7;
        }

        int b = n%7;
        int ad = Rem(b);
        ad+= a*b;

        ans+=ad; 

        return ans;
    }
};
"
871,cpp,divide-array-in-sets-of-k-consecutive-numbers,"class Solution {
public:
    bool isPossibleDivide(vector<int>& nums, int k) {
        unordered_map<int,int> mpp;
        sort(nums.begin(), nums.end());
        if(nums.size()%k!=0){
            return false;
        }


        for(int i=0; i<nums.size(); i++){
            mpp[nums[i]]++;
        }
        for(int i=0; i<nums.size(); i++){
            if(mpp[nums[i]]<=0){
                continue;
            }
            for(int j=nums[i] ; j<nums[i]+ k - 1; j++){ 
                if(mpp[j]<=0){
                    return false;
                }
                
                    mpp[j]--;
                
            }
        }
        return true;
    }
};",None,"class Solution {
public:
    bool isPossibleDivide(vector<int>& nums, int k) {
        unordered_map<int,int> mpp;
        sort(nums.begin(), nums.end());
        if(nums.size()%k!=0){
            return false;
        }

        for(int i=0; i<nums.size(); i++){
            mpp[nums[i]]++;
        }
        for(int i=0; i<nums.size(); i++){
            if(mpp[nums[i]]<=0){
                continue;
            }
            for(int j=nums[i] ; j<nums[i]+ k; j++){
                if(mpp[j]<=0){
                    return false;
                }
                mpp[j]--;
                
            }
        }
        return true;
    }
};
"
871,cpp,divide-array-in-sets-of-k-consecutive-numbers,"class Solution {
public:
    bool isPossibleDivide(vector<int>& nums, int k) {
        unordered_map<int,int> mpp;
        sort(nums.begin(), nums.end());
        if(nums.size()%k!=0){
            return false;
        }


        for(int i=0; i<nums.size(); i++){
            mpp[nums[i]]++;
        }
        for(int i=0; i<nums.size(); i++){
            if(mpp[nums[i]]<=0){
                continue;
            }
            for(int j=nums[i] ; j<nums[i]+ k - 1; j++){ 
                if(mpp[j]<=0){
                    return false;
                }
                
                    mpp[j]--;
                
            }
        }
        return true;
    }
};",None,"class Solution {
public:
    bool isPossibleDivide(vector<int>& nums, int k) {
        unordered_map<int,int> mpp;
        sort(nums.begin(), nums.end());
        if(nums.size() % k != 0){
            return false;
        }

        for(int i = 0; i < nums.size(); i++){
            mpp[nums[i]]++;
        }
        for(int i = 0; i < nums.size(); i++){
            if(mpp[nums[i]] <= 0){
                continue;
            }
            for(int j = nums[i] ; j < nums[i] + k; j++){
                if(mpp[j] <= 0){
                    return false;
                } else {
                    mpp[j]--;
                }
            }
        }
        return true;
    }
};
"
871,cpp,divide-array-in-sets-of-k-consecutive-numbers,"class Solution {
public:
    bool isPossibleDivide(vector<int>& nums, int k) {
        unordered_map<int,int> mpp;
        sort(nums.begin(), nums.end());
        if(nums.size()%k!=0){
            return false;
        }


        for(int i=0; i<nums.size(); i++){
            mpp[nums[i]]++;
        }
        for(int i=0; i<nums.size(); i++){
            if(mpp[nums[i]]<=0){
                continue;
            }
            for(int j=nums[i] ; j<nums[i]+ k - 1; j++){ 
                if(mpp[j]<=0){
                    return false;
                }
                
                    mpp[j]--;
                
            }
        }
        return true;
    }
};",None,"class Solution {
public:
    bool isPossibleDivide(vector<int>& nums, int k) {
        unordered_map<int,int> mpp;
        sort(nums.begin(), nums.end());
        if(nums.size()%k!=0){
            return false;
        }


        for(int i=0; i<nums.size(); i++){
            mpp[nums[i]]++;
        }
        for(int i=0; i<nums.size(); i++){
            if(mpp[nums[i]]<=0){
                continue;
            }
            for(int j=nums[i] ; j<nums[i]+ k ; j++){ 
                if(mpp[j]<=0){
                    return false;
                }    
                    mpp[j]--;
            }
        }
        return true;
    }
};
"
872,cpp,my-calendar-i,"class MyCalendar {
public:
    map<int,int> m;
    MyCalendar() {
        
    }
    
    bool book(int start, int end) {
        auto p= m.upper_bound(start);
        if(p== m.end() || end <= p->second) 
        {
            m[start]=end; 
            return true;
        } 
        return false;
    }
};",None,"class MyCalendar {
public:
    map<int,int> m;
    MyCalendar() {
        
    }
    
    bool book(int start, int end) {
        auto p= m.upper_bound(start);
        if(p== m.begin() || end <= (--p)->second) 
        {
            m[start]=end; 
            return true;
        } 
        return false;
    }
};
"
872,cpp,my-calendar-i,"class MyCalendar {
public:
    map<int,int> m;
    MyCalendar() {
        
    }
    
    bool book(int start, int end) {
        auto p= m.upper_bound(start);
        if(p== m.end() || end <= p->second) 
        {
            m[start]=end; 
            return true;
        } 
        return false;
    }
};",None,"class MyCalendar {
public:
    map<int, int> m;
    MyCalendar() {
        
    }
    
    bool book(int start, int end) {
        auto nextEvent = m.lower_bound(start);
        if (nextEvent != m.end() && nextEvent->first < end) return false;
        if (nextEvent != m.begin() && (--nextEvent)->second > start) return false;
        m[start] = end;
        return true;
    }
};
"
872,cpp,my-calendar-i,"class MyCalendar {
public:
    map<int,int> m;
    MyCalendar() {
        
    }
    
    bool book(int start, int end) {
        auto p= m.upper_bound(start);
        if(p== m.end() || end <= p->second) 
        {
            m[start]=end; 
            return true;
        } 
        return false;
    }
};",None,"class MyCalendar {
public:
    map<int, int> m;
    
    MyCalendar() {
        
    }
    
    bool book(int start, int end) {
        auto next = m.lower_bound(start);
        if (next != m.end() && next->first < end) 
        {
            return false;
        }
        if (next != m.begin() && (--next)->second > start) 
        {
            return false;
        }
        m[start] = end;
        return true;
    }
};
"
873,cpp,find-elements-in-a-contaminated-binary-tree,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class FindElements {
  unordered_set<int> set;
public:
    void recover(TreeNode* root, int x) {
        if (!root) return;
        root->val = x;
        set.emplace(x);
        recover(root->left, 2 * x + 1);
        recover(root->right, 2 * x + 2);
    }
    
    FindElements(TreeNode* root) {
        recover(root, 0);
    }
    
    bool find(int target) {
        return set.count(target - 1);
    }
};

/**
 * Your FindElements object will be instantiated and called as such:
 * FindElements* obj = new FindElements(root);
 * bool param_1 = obj->find(target);
 */",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class FindElements {
  unordered_set<int> set;
public:
    void recover(TreeNode* root, int x) {
        if (!root) return;
        root->val = x;
        set.emplace(x);
        recover(root->left, 2 * x + 1);
        recover(root->right, 2 * x + 2);
    }
    
    FindElements(TreeNode* root) {
        recover(root, 0);
    }
    
    bool find(int target) {
        return set.count(target);
    }
};

/**
 * Your FindElements object will be instantiated and called as such:
 * FindElements* obj = new FindElements(root);
 * bool param_1 = obj->find(target);
 */
"
873,cpp,find-elements-in-a-contaminated-binary-tree,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class FindElements {
  unordered_set<int> set;
public:
    void recover(TreeNode* root, int x) {
        if (!root) return;
        root->val = x;
        set.emplace(x);
        recover(root->left, 2 * x + 1);
        recover(root->right, 2 * x + 2);
    }
    
    FindElements(TreeNode* root) {
        recover(root, 0);
    }
    
    bool find(int target) {
        return set.count(target - 1);
    }
};

/**
 * Your FindElements object will be instantiated and called as such:
 * FindElements* obj = new FindElements(root);
 * bool param_1 = obj->find(target);
 */",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class FindElements {
  unordered_set<int> set;
public:
    void recover(TreeNode* root, int x) {
        if (!root) return;
        root->val = x;
        set.emplace(x);
        recover(root->left, 2 * x + 1);
        recover(root->right, 2 * x + 2);
    }
    
    FindElements(TreeNode* root) {
        recover(root, 0);
    }
    
    bool find(int target) {
        return set.count(target);
    }
};

/**
 * Your FindElements object will be instantiated and called as such:
 * FindElements* obj = new FindElements(root);
 * bool param_1 = obj->find(target);
 */
"
873,cpp,find-elements-in-a-contaminated-binary-tree,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class FindElements {
  unordered_set<int> set;
public:
    void recover(TreeNode* root, int x) {
        if (!root) return;
        root->val = x;
        set.emplace(x);
        recover(root->left, 2 * x + 1);
        recover(root->right, 2 * x + 2);
    }
    
    FindElements(TreeNode* root) {
        recover(root, 0);
    }
    
    bool find(int target) {
        return set.count(target - 1);
    }
};

/**
 * Your FindElements object will be instantiated and called as such:
 * FindElements* obj = new FindElements(root);
 * bool param_1 = obj->find(target);
 */",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class FindElements {
  unordered_set<int> set;
public:
    void recover(TreeNode* root, int x) {
        if (!root) return;
        root->val = x;
        set.emplace(x);
        recover(root->left, 2 * x + 1);
        recover(root->right, 2 * x + 2);
    }
    
    FindElements(TreeNode* root) {
        recover(root, 0);
    }
    
    bool find(int target) {
        return set.count(target);
    }
};

/**
 * Your FindElements object will be instantiated and called as such:
 * FindElements* obj = new FindElements(root);
 * bool param_1 = obj->find(target);
 */
"
874,cpp,group-anagrams,"class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string,int> m;
        vector<vector<string>> ans;
        for(int i=0; i<strs.size(); i++) {
            string str = strs[i];
            sort(str.begin(),str.end());

            if(m.find(str) != m.end()) {
                ans[m[str]].push_back(str);
            }
            else {
                m[str] = ans.size(); 
                ans.push_back({strs[i]});
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string,vector<string>> m;
        for(int i=0; i<strs.size(); i++) {
            string str = strs[i];
            sort(str.begin(),str.end());

            if(m.find(str) != m.end()) {
                m[str].push_back(strs[i]);
            }
            else {
                m[str] = {strs[i]};
            }
        }

        vector<vector<string>> ans;
        for(auto it = m.begin(); it != m.end(); ++it)
            ans.push_back(it->second); 

        return ans;
    }
};
"
874,cpp,group-anagrams,"class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string,int> m;
        vector<vector<string>> ans;
        for(int i=0; i<strs.size(); i++) {
            string str = strs[i];
            sort(str.begin(),str.end());

            if(m.find(str) != m.end()) {
                ans[m[str]].push_back(str);
            }
            else {
                m[str] = ans.size(); 
                ans.push_back({strs[i]});
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string,int> m;
        vector<vector<string>> ans;
        for(int i=0; i<strs.size(); i++) {
            string str = strs[i];
            sort(str.begin(),str.end());

            if(m.find(str) != m.end()) {
                ans[m[str]].push_back(strs[i]);
            }
            else { 
                m[str] = ans.size(); 
                ans.push_back({strs[i]});
            }
        }
        return ans;
    }
};
"
874,cpp,group-anagrams,"class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string,int> m;
        vector<vector<string>> ans;
        for(int i=0; i<strs.size(); i++) {
            string str = strs[i];
            sort(str.begin(),str.end());

            if(m.find(str) != m.end()) {
                ans[m[str]].push_back(str);
            }
            else {
                m[str] = ans.size(); 
                ans.push_back({strs[i]});
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> m;
        vector<vector<string>> ans;
        for(int i=0; i<strs.size(); i++) {
            string str = strs[i];
            sort(str.begin(),str.end());

            if(m.find(str) != m.end()) {
                m[str].push_back(strs[i]);
            }
            else {
                m[str] = {strs[i]};
            }
        }
        for(auto it = m.begin(); it != m.end(); it++) {
            ans.push_back(it->second);
        }
        return ans;
    }
};
"
875,cpp,knight-probability-in-chessboard,"class Solution {
public:
    double f(int i,int j,int k,int n,vector<vector<vector<double>>> &dp){
        if(k==0) return 1.0;

        if(dp[i][j][k]!=-1.0) return dp[i][j][k];
        int dx[]={-2,-2,-1,1,2,2,1,-1},dy[]={-1,1,2,2,1,-1,-2,-2};
        double ans = 0.0;
        for(int t=0;t<8;t++){
            int nx=i+dx[t],ny=j+dy[t];
            if(nx>=0 && nx<n && ny>=0 && ny<n){
                ans += f(nx,ny,k-1,n,dp);
            }
        }

        return dp[i][j][k]=ans/8;
    }
    double knightProbability(int n, int k, int row, int column) {
        vector<vector<vector<double>>> dp(n,vector<vector<double>>(n,vector<double>(k+1,-1.0)));
        double ct=f(row,column,k,n,dp);
        for(int i=0;i<k;i++){
            ct = ct/8;
        }

        return ct;
    }
};",None,"class Solution {
public:
    double f(int i,int j,int k,int n,vector<vector<vector<double>>> &dp){
        if(k==0) return 1.0;

        if(dp[i][j][k]!=-1.0) return dp[i][j][k];
        int dx[]={-2,-2,-1,1,2,2,1,-1},dy[]={-1,1,2,2,1,-1,-2,-2};
        double ans = 0.0;
        for(int t=0;t<8;t++){
            int nx=i+dx[t],ny=j+dy[t];
            if(nx>=0 && nx<n && ny>=0 && ny<n){
                ans += f(nx,ny,k-1,n,dp);
            }
        }

        return dp[i][j][k]=ans/8;
    }
    double knightProbability(int n, int k, int row, int column) {
        vector<vector<vector<double>>> dp(n,vector<vector<double>>(n,vector<double>(k+1,-1.0)));
        return f(row,column,k,n,dp);
    }
};
"
875,cpp,knight-probability-in-chessboard,"class Solution {
public:
    double f(int i,int j,int k,int n,vector<vector<vector<double>>> &dp){
        if(k==0) return 1.0;

        if(dp[i][j][k]!=-1.0) return dp[i][j][k];
        int dx[]={-2,-2,-1,1,2,2,1,-1},dy[]={-1,1,2,2,1,-1,-2,-2};
        double ans = 0.0;
        for(int t=0;t<8;t++){
            int nx=i+dx[t],ny=j+dy[t];
            if(nx>=0 && nx<n && ny>=0 && ny<n){
                ans += f(nx,ny,k-1,n,dp);
            }
        }

        return dp[i][j][k]=ans/8;
    }
    double knightProbability(int n, int k, int row, int column) {
        vector<vector<vector<double>>> dp(n,vector<vector<double>>(n,vector<double>(k+1,-1.0)));
        double ct=f(row,column,k,n,dp);
        for(int i=0;i<k;i++){
            ct = ct/8;
        }

        return ct;
    }
};",None,"class Solution {
public:
    double f(int i,int j,int k,int n,vector<vector<vector<double>>> &dp){
        if(k==0) return 1.0;

        if(dp[i][j][k]!=-1.0) return dp[i][j][k];
        int dx[]={-2,-2,-1,1,2,2,1,-1},dy[]={-1,1,2,2,1,-1,-2,-2};
        double ans = 0.0;
        for(int t=0;t<8;t++){
            int nx=i+dx[t],ny=j+dy[t];
            if(nx>=0 && nx<n && ny>=0 && ny<n){
                ans += f(nx,ny,k-1,n,dp);
            }
        }

        return dp[i][j][k]=ans/8;
    }
    double knightProbability(int n, int k, int row, int column) {
        vector<vector<vector<double>>> dp(n,vector<vector<double>>(n,vector<double>(k+1,-1.0)));
        return f(row,column,k,n,dp);
    }
};
"
875,cpp,knight-probability-in-chessboard,"class Solution {
public:
    double f(int i,int j,int k,int n,vector<vector<vector<double>>> &dp){
        if(k==0) return 1.0;

        if(dp[i][j][k]!=-1.0) return dp[i][j][k];
        int dx[]={-2,-2,-1,1,2,2,1,-1},dy[]={-1,1,2,2,1,-1,-2,-2};
        double ans = 0.0;
        for(int t=0;t<8;t++){
            int nx=i+dx[t],ny=j+dy[t];
            if(nx>=0 && nx<n && ny>=0 && ny<n){
                ans += f(nx,ny,k-1,n,dp);
            }
        }

        return dp[i][j][k]=ans/8;
    }
    double knightProbability(int n, int k, int row, int column) {
        vector<vector<vector<double>>> dp(n,vector<vector<double>>(n,vector<double>(k+1,-1.0)));
        double ct=f(row,column,k,n,dp);
        for(int i=0;i<k;i++){
            ct = ct/8;
        }

        return ct;
    }
};",None,"class Solution {
public:
    double f(int i,int j,int k,int n,vector<vector<vector<double>>> &dp){
        if(k==0) return 1.0;
        
        if(dp[i][j][k]!=-1.0) return dp[i][j][k];
        
        int dx[]={-2,-2,-1,1,2,2,1,-1},dy[]={-1,1,2,2,1,-1,-2,-2};
        double ans = 0.0;
        
        for(int t=0;t<8;t++){
            int nx=i+dx[t],ny=j+dy[t];
            if(nx>=0 && nx<n && ny>=0 && ny<n){
                ans += f(nx,ny,k-1,n,dp);
            }
        }
        return dp[i][j][k]=ans/8.0;
    }
    double knightProbability(int n, int k, int row, int column) {
        vector<vector<vector<double>>> dp(n,vector<vector<double>>(n,vector<double>(k+1,-1.0)));
        return f(row,column,k,n,dp);
    }
};
"
876,cpp,neighboring-bitwise-xor,"class Solution {
public:
    bool doesValidArrayExist(vector<int>& derived) {
        int xoor = 0;
        for (auto i: derived) xoor += i;
        return !xoor;
    }
};",None,"class Solution {
public:
    bool doesValidArrayExist(vector<int>& derived) {
        int sum = 0;
        int n = derived.size();
        for (int x: derived) sum += x;
        if(n % 2 == 0) return sum % 2 == 0;
        else return derived[0] == sum % 2;
    }
};
"
876,cpp,neighboring-bitwise-xor,"class Solution {
public:
    bool doesValidArrayExist(vector<int>& derived) {
        int xoor = 0;
        for (auto i: derived) xoor += i;
        return !xoor;
    }
};",None,"class Solution {
public:
    bool doesValidArrayExist(vector<int>& derived) {
        int n = derived.size();
        vector<int> original(n, 0);
        for (int i = 0; i < n - 1; ++i) {
            original[i + 1] = original[i] ^ derived[i];
        }
        return original[0] == (original[n - 1] ^ derived[n - 1]);
    }
};
"
876,cpp,neighboring-bitwise-xor,"class Solution {
public:
    bool doesValidArrayExist(vector<int>& derived) {
        int xoor = 0;
        for (auto i: derived) xoor += i;
        return !xoor;
    }
};",None,"class Solution {
public:
    bool doesValidArrayExist(vector<int>& derived) {
        int n = derived.size();
        vector<int> original(n, 0);
        original[0] = derived[0];
        for (int i=1; i<n; i++) {
            original[i] = original[i-1] ^ derived[i-1];
        }
        return original[0] == (original[n-1] ^ derived[n-1]);
    }
};
"
877,cpp,maximize-grid-happiness,"class Solution {
public:
   int dp[25][7][7][64][64] = {};
int nCost(int m, int n, int i, int j, int mask_in, int mask_ex, int d) {
    int diff = 0, up = (1 << (n - 1));
    if (j > 0 && (mask_in & 1))
        diff += d - 30;
    if (i > 0 && (mask_in & up))
        diff += d - 30;
    if (j > 0 && (mask_ex & 1))
        diff += d + 20;
    if (i > 0 && (mask_ex & up))
        diff += d + 20;
    return diff;
}
int dfs(int m, int n, int p, int in, int ex, int mask_in, int mask_ex) {
    int i = p / n, j = p % n;
    if (i >= m)
        return 0;
    if (dp[p][in][ex][mask_in][mask_ex])
        return dp[p][in][ex][mask_in][mask_ex] - 1;
    int n_mask_in = (mask_in << 1) & 63, n_mask_ex = (mask_ex << 1) & 63;
    int res = dfs(m, n, p + 1, in, ex, n_mask_in, n_mask_ex);
    if (in > 0) {
        int diff = 120 + nCost(m, n, i, j, mask_in, mask_ex, -30);
        res = max(res, diff + dfs(m, n, p + 1, in - 1, ex, n_mask_in + 1, n_mask_ex));
    }
    if (ex > 0) {
        int diff = 40 + nCost(m, n, i, j, mask_in, mask_ex, +30);
        res = max(res, diff + dfs(m, n, p + 1, in, ex - 1, n_mask_in, n_mask_ex + 1));
    }
    dp[p][in][ex][mask_in][mask_ex] = res + 1;
    return res;
}
int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {
    return dfs(m, n, 0, introvertsCount, extrovertsCount, 0, 0);
}
};",None,"class Solution {
public:
   int dp[25][7][7][64][64] = {};
int nCost(int m, int n, int i, int j, int mask_in, int mask_ex, int d) {
    int diff = 0, up = (1 << (n - 1));
    if (j > 0 && (mask_in & 1))
        diff += d - 30;
    if (i > 0 && (mask_in & up))
        diff += d - 30;
    if (j > 0 && (mask_ex & 1))
        diff += d + 20;
    if (i > 0 && (mask_ex & up))
        diff += d + 20;
    return diff;
}
int dfs(int m, int n, int p, int in, int ex, int mask_in, int mask_ex) {
    int i = p / n, j = p % n;
    if (i >= m)
        return 0;
    if (dp[p][in][ex][mask_in][mask_ex])
        return dp[p][in][ex][mask_in][mask_ex] - 1;
    int n_mask_in = (mask_in << 1) & ((1<<n)-1), n_mask_ex = (mask_ex << 1) & ((1<<n)-1);
    int res = dfs(m, n, p + 1, in, ex, n_mask_in, n_mask_ex);
    if (in > 0) {
        int diff = 120 + nCost(m, n, i, j, mask_in, mask_ex, -30);
        res = max(res, diff + dfs(m, n, p + 1, in - 1, ex, n_mask_in + 1, n_mask_ex));
    }
    if (ex > 0) {
        int diff = 40 + nCost(m, n, i, j, mask_in, mask_ex, +20);
        res = max(res, diff + dfs(m, n, p + 1, in, ex - 1, n_mask_in, n_mask_ex + 1));
    }
    dp[p][in][ex][mask_in][mask_ex] = res + 1;
    return res;
}
int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {
    return dfs(m, n, 0, introvertsCount, extrovertsCount, 0, 0);
}
};
"
877,cpp,maximize-grid-happiness,"class Solution {
public:
   int dp[25][7][7][64][64] = {};
int nCost(int m, int n, int i, int j, int mask_in, int mask_ex, int d) {
    int diff = 0, up = (1 << (n - 1));
    if (j > 0 && (mask_in & 1))
        diff += d - 30;
    if (i > 0 && (mask_in & up))
        diff += d - 30;
    if (j > 0 && (mask_ex & 1))
        diff += d + 20;
    if (i > 0 && (mask_ex & up))
        diff += d + 20;
    return diff;
}
int dfs(int m, int n, int p, int in, int ex, int mask_in, int mask_ex) {
    int i = p / n, j = p % n;
    if (i >= m)
        return 0;
    if (dp[p][in][ex][mask_in][mask_ex])
        return dp[p][in][ex][mask_in][mask_ex] - 1;
    int n_mask_in = (mask_in << 1) & 63, n_mask_ex = (mask_ex << 1) & 63;
    int res = dfs(m, n, p + 1, in, ex, n_mask_in, n_mask_ex);
    if (in > 0) {
        int diff = 120 + nCost(m, n, i, j, mask_in, mask_ex, -30);
        res = max(res, diff + dfs(m, n, p + 1, in - 1, ex, n_mask_in + 1, n_mask_ex));
    }
    if (ex > 0) {
        int diff = 40 + nCost(m, n, i, j, mask_in, mask_ex, +30);
        res = max(res, diff + dfs(m, n, p + 1, in, ex - 1, n_mask_in, n_mask_ex + 1));
    }
    dp[p][in][ex][mask_in][mask_ex] = res + 1;
    return res;
}
int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {
    return dfs(m, n, 0, introvertsCount, extrovertsCount, 0, 0);
}
};",None,"class Solution {
public:
   int dp[25][7][7][64][64] = {};
int nCost(int m, int n, int i, int j, int mask_in, int mask_ex, int d) {
    int diff = 0, up = (1 << (n - 1));
    if (j > 0 && (mask_in & 1))
        diff += d - 30;
    if (i > 0 && (mask_in & up))
        diff += d - 30;
    if (j > 0 && (mask_ex & 1))
        diff += d + 20;
    if (i > 0 && (mask_ex & up))
        diff += d + 20;
    return diff;
}
int dfs(int m, int n, int p, int in, int ex, int mask_in, int mask_ex) {
    int i = p / n, j = p % n;
    if (i >= m)
        return 0;
    if (dp[p][in][ex][mask_in][mask_ex])
        return dp[p][in][ex][mask_in][mask_ex] - 1;
    int n_mask_in = (mask_in << 1) & 63, n_mask_ex = (mask_ex << 1) & 63;
    int res = dfs(m, n, p + 1, in, ex, n_mask_in, n_mask_ex);
    if (in > 0) {
        int diff = 120 + nCost(m, n, i, j, mask_in, mask_ex, -30);
        res = max(res, diff + dfs(m, n, p + 1, in - 1, ex, n_mask_in + 1, n_mask_ex));
    }
    if (ex > 0) {
        int diff = 40 + nCost(m, n, i, j, mask_in, mask_ex, +20);
        res = max(res, diff + dfs(m, n, p + 1, in, ex - 1, n_mask_in, n_mask_ex + 1));
    }
    dp[p][in][ex][mask_in][mask_ex] = res + 1;
    return res;
}
int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {
    return dfs(m, n, 0, introvertsCount, extrovertsCount, 0, 0);
}
};
"
877,cpp,maximize-grid-happiness,"class Solution {
public:
   int dp[25][7][7][64][64] = {};
int nCost(int m, int n, int i, int j, int mask_in, int mask_ex, int d) {
    int diff = 0, up = (1 << (n - 1));
    if (j > 0 && (mask_in & 1))
        diff += d - 30;
    if (i > 0 && (mask_in & up))
        diff += d - 30;
    if (j > 0 && (mask_ex & 1))
        diff += d + 20;
    if (i > 0 && (mask_ex & up))
        diff += d + 20;
    return diff;
}
int dfs(int m, int n, int p, int in, int ex, int mask_in, int mask_ex) {
    int i = p / n, j = p % n;
    if (i >= m)
        return 0;
    if (dp[p][in][ex][mask_in][mask_ex])
        return dp[p][in][ex][mask_in][mask_ex] - 1;
    int n_mask_in = (mask_in << 1) & 63, n_mask_ex = (mask_ex << 1) & 63;
    int res = dfs(m, n, p + 1, in, ex, n_mask_in, n_mask_ex);
    if (in > 0) {
        int diff = 120 + nCost(m, n, i, j, mask_in, mask_ex, -30);
        res = max(res, diff + dfs(m, n, p + 1, in - 1, ex, n_mask_in + 1, n_mask_ex));
    }
    if (ex > 0) {
        int diff = 40 + nCost(m, n, i, j, mask_in, mask_ex, +30);
        res = max(res, diff + dfs(m, n, p + 1, in, ex - 1, n_mask_in, n_mask_ex + 1));
    }
    dp[p][in][ex][mask_in][mask_ex] = res + 1;
    return res;
}
int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {
    return dfs(m, n, 0, introvertsCount, extrovertsCount, 0, 0);
}
};",None,"class Solution {
public:
   int dp[25][7][7][64][64] = {};
int nCost(int m, int n, int i, int j, int mask_in, int mask_ex, int d) {
    int diff = 0, up = (1 << (n - 1)), left = 1;
    if (j > 0 && (mask_in & left))
        diff += d - 30;
    if (i > 0 && (mask_in & up))
        diff += d - 30;
    if (j > 0 && (mask_ex & left))
        diff += d + 20;
    if (i > 0 && (mask_ex & up))
        diff += d + 20;
    return diff;
}
int dfs(int m, int n, int p, int in, int ex, int mask_in, int mask_ex) {
    int i = p / n, j = p % n;
    if (i >= m)
        return 0;
    if (dp[p][in][ex][mask_in][mask_ex])
        return dp[p][in][ex][mask_in][mask_ex] - 1;
    int n_mask_in = (mask_in << 1) & 63, n_mask_ex = (mask_ex << 1) & 63;
    int res = dfs(m, n, p + 1, in, ex, n_mask_in, n_mask_ex);
    if (in > 0) {
        int diff = 120 + nCost(m, n, i, j, mask_in, mask_ex, -30);
        res = max(res, diff + dfs(m, n, p + 1, in - 1, ex, n_mask_in + 1, n_mask_ex));
    }
    if (ex > 0) {
        int diff = 40 + nCost(m, n, i, j, mask_in, mask_ex, +20);
        res = max(res, diff + dfs(m, n, p + 1, in, ex - 1, n_mask_in, n_mask_ex + 1));
    }
    dp[p][in][ex][mask_in][mask_ex] = res + 1;
    return res;
}
int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {
    return dfs(m, n, 0, introvertsCount, extrovertsCount, 0, 0);
}
};
"
1160,cpp,detect-cycles-in-2d-grid,"class Solution {
public:
   vector<int> dir = { 0, 1, 0, -1, 0 }; 
    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)
    {
        visited[i][j] = false;
        for(int d = 0; d < 4; ++d)
        {
            int a = i+dir[d];
            int b = j+dir[d+1];
            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))
                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))
                    return true;
        }
        return false;
    }
    bool containsCycle(vector<vector<char>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> visited(n, vector<bool>(m, false));
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < m; ++j)
                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))
                    return true;
        return false;
    }
};",None,"class Solution {
public:
   vector<int> dir = { 0, 1, 0, -1, 0 }; 
    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)
    {
        visited[i][j] = true;
        for(int d = 0; d < 4; ++d)
        {
            int a = i+dir[d];
            int b = j+dir[d+1];
            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))
                if(!visited[a][b] && isCyclic(grid, visited, a,b,i,j))
                    return true;
        }
        return false;
    }
    bool containsCycle(vector<vector<char>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> visited(n, vector<bool>(m, false));
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < m; ++j)
                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))
                    return true;
        return false;
    }
};
"
1160,cpp,detect-cycles-in-2d-grid,"class Solution {
public:
   vector<int> dir = { 0, 1, 0, -1, 0 }; 
    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)
    {
        visited[i][j] = false;
        for(int d = 0; d < 4; ++d)
        {
            int a = i+dir[d];
            int b = j+dir[d+1];
            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))
                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))
                    return true;
        }
        return false;
    }
    bool containsCycle(vector<vector<char>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> visited(n, vector<bool>(m, false));
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < m; ++j)
                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))
                    return true;
        return false;
    }
};",None,"class Solution {
public:
   vector<int> dir = { 0, 1, 0, -1, 0 }; 
    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)
    {
        visited[i][j] = true;
        for(int d = 0; d < 4; ++d)
        {
            int a = i+dir[d];
            int b = j+dir[d+1];
            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))
                if(!visited[a][b] && isCyclic(grid, visited, a,b,i,j))
                    return true;
        }
        return false;
    }
    bool containsCycle(vector<vector<char>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> visited(n, vector<bool>(m, false));
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < m; ++j)
                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))
                    return true;
        return false;
    }
};
"
1160,cpp,detect-cycles-in-2d-grid,"class Solution {
public:
   vector<int> dir = { 0, 1, 0, -1, 0 }; 
    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)
    {
        visited[i][j] = false;
        for(int d = 0; d < 4; ++d)
        {
            int a = i+dir[d];
            int b = j+dir[d+1];
            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))
                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))
                    return true;
        }
        return false;
    }
    bool containsCycle(vector<vector<char>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> visited(n, vector<bool>(m, false));
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < m; ++j)
                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))
                    return true;
        return false;
    }
};",None,"class Solution {
public:
   vector<int> dir = { 0, 1, 0, -1, 0 }; 
    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)
    {
        visited[i][j] = true;
        for(int d = 0; d < 4; ++d)
        {
            int a = i+dir[d];
            int b = j+dir[d+1];
            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))
                if(!visited[a][b] && isCyclic(grid, visited, a,b,i,j))
                    return true;
        }
        return false;
    }
    bool containsCycle(vector<vector<char>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> visited(n, vector<bool>(m, false));
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < m; ++j)
                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))
                    return true;
        return false;
    }
};
"
1161,cpp,a-number-after-a-double-reversal,"class Solution {
public:
    bool isSameAfterReversals(int num) {
        string ans=to_string(num);
        reverse(ans.begin(), ans.end());
        int ab=stoi(ans);
        string ans2=to_string(ab);
        
        reverse(ans.begin(), ans.end());
        int ba=stoi(ans2);
        if(ba==num) return true;
        return false;
    }
};",None,"class Solution {
public:
    bool isSameAfterReversals(int num) {
        string ans=to_string(num);
        reverse(ans.begin(), ans.end());
        int ab=stoi(ans);
        string ans2=to_string(ab);
        
        reverse(ans2.begin(), ans2.end());
        int ba=stoi(ans2);
        if(ba==num) return true;
        return false;
    }
};
"
1161,cpp,a-number-after-a-double-reversal,"class Solution {
public:
    bool isSameAfterReversals(int num) {
        string ans=to_string(num);
        reverse(ans.begin(), ans.end());
        int ab=stoi(ans);
        string ans2=to_string(ab);
        
        reverse(ans.begin(), ans.end());
        int ba=stoi(ans2);
        if(ba==num) return true;
        return false;
    }
};",None,"class Solution {
public:
    bool isSameAfterReversals(int num) {
        string ans=to_string(num);
        reverse(ans.begin(), ans.end());
        int ab=stoi(ans);
        string ans2=to_string(ab);

        reverse(ans2.begin(), ans2.end());
        int ba=stoi(ans2);
        if(ba==num) return true;
        return false;
    }
};
"
1161,cpp,a-number-after-a-double-reversal,"class Solution {
public:
    bool isSameAfterReversals(int num) {
        string ans=to_string(num);
        reverse(ans.begin(), ans.end());
        int ab=stoi(ans);
        string ans2=to_string(ab);
        
        reverse(ans.begin(), ans.end());
        int ba=stoi(ans2);
        if(ba==num) return true;
        return false;
    }
};",None,"class Solution {
public:
    bool isSameAfterReversals(int num) {
        string ans = to_string(num);
        reverse(ans.begin(), ans.end());
        int ab = stoi(ans);
        string ans2 = to_string(ab);

        reverse(ans2.begin(), ans2.end());
        int ba = stoi(ans2);
        if (ba == num) return true;
        return false;
    }
};
"
1162,cpp,maximum-rows-covered-by-columns,"class Solution {
public:
    vector<vector<int>>comb;
    
    int find(vector<vector<int>>& mat1)
    {
        int c = 0;
        for(int i = 0; i < mat1.size(); i++)
        {
            int flg = 0;
            for(int j = 0; j < mat1[0].size(); j++)
                if(mat1[i][j] == 1)
                    flg = 1;
            if(flg == 0)
                c++;
        }
        return c;
    }
    
    
    int find_ans(vector<vector<int>>& mat)
    {
        int ans = 0;
        for(int i = 0; i < comb.size(); i++)
        {
            vector<int>temp = comb[i];
            vector<vector<int>> mat1 = mat;
            for(int j = 0; j < temp.size(); j++)
            {
                int col_val = temp[j];
                for(int k = 0; k < mat1.size(); k++)
                    mat1[k][col_val] = 1;
            }
            ans = max(ans, find(mat1));
        }
        return ans;
    }
    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)
    {
        int col = mat[0].size();
        if(count == cols)
        {
            comb.push_back(tans);
            return;
        }
        if(idx >= col)
            return;
        
        helper(mat, cols, count, idx+1, tans);
        tans.push_back(idx);
        helper(mat, cols, count+1, idx+1, tans);
    }
    
    int maximumRows(vector<vector<int>>& mat, int cols) {
        
        vector<int>tans;
        helper(mat, cols, 0, 0, tans);
        return find_ans(mat);
    }
};",None,"class Solution {
public:
    vector<vector<int>>comb;
    
    int find(vector<vector<int>>& mat1)
    {
        int c = 0;
        for(int i = 0; i < mat1.size(); i++)
        {
            int flg = 0;
            for(int j = 0; j < mat1[0].size(); j++)
                if(mat1[i][j] == 1)
                    flg = 1;
            if(flg == 1)
                c++;
        }
        return c;
    }
    
    int find_ans(vector<vector<int>>& mat)
    {
        int ans = 0;
        for(int i = 0; i < comb.size(); i++)
        {
            vector<int>temp = comb[i];
            vector<vector<int>> mat1 = mat;
            for(int j = 0; j < temp.size(); j++)
            {
                int col_val = temp[j];
                for(int k = 0; k < mat1.size(); k++)
                    mat1[k][col_val] = 1;
            }
            ans = max(ans, find(mat1));
        }
        return ans;
    }
    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)
    {
        int col = mat[0].size();
        if(count == cols)
        {
            comb.push_back(tans);
            return;
        }
        if(idx >= col)
            return;
        
        helper(mat, cols, count, idx+1, tans);
        tans.push_back(idx);
        helper(mat, cols, count+1, idx+1, tans);
    }
    
    int maximumRows(vector<vector<int>>& mat, int cols) {
        
        vector<int>tans;
        helper(mat, cols, 0, 0, tans);
        return find_ans(mat);
    }
};
"
1162,cpp,maximum-rows-covered-by-columns,"class Solution {
public:
    vector<vector<int>>comb;
    
    int find(vector<vector<int>>& mat1)
    {
        int c = 0;
        for(int i = 0; i < mat1.size(); i++)
        {
            int flg = 0;
            for(int j = 0; j < mat1[0].size(); j++)
                if(mat1[i][j] == 1)
                    flg = 1;
            if(flg == 0)
                c++;
        }
        return c;
    }
    
    
    int find_ans(vector<vector<int>>& mat)
    {
        int ans = 0;
        for(int i = 0; i < comb.size(); i++)
        {
            vector<int>temp = comb[i];
            vector<vector<int>> mat1 = mat;
            for(int j = 0; j < temp.size(); j++)
            {
                int col_val = temp[j];
                for(int k = 0; k < mat1.size(); k++)
                    mat1[k][col_val] = 1;
            }
            ans = max(ans, find(mat1));
        }
        return ans;
    }
    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)
    {
        int col = mat[0].size();
        if(count == cols)
        {
            comb.push_back(tans);
            return;
        }
        if(idx >= col)
            return;
        
        helper(mat, cols, count, idx+1, tans);
        tans.push_back(idx);
        helper(mat, cols, count+1, idx+1, tans);
    }
    
    int maximumRows(vector<vector<int>>& mat, int cols) {
        
        vector<int>tans;
        helper(mat, cols, 0, 0, tans);
        return find_ans(mat);
    }
};",None,"class Solution {
public:
    vector<vector<int>>comb;
    
    int find(vector<vector<int>>& mat1)
    {
        int c = 0;
        for(int i = 0; i < mat1.size(); i++)
        {
            int flg = 0;
            for(int j = 0; j < mat1[0].size(); j++)
                if(mat1[i][j] == 1)
                    flg = 1;
            if(flg == 1)
                c++;
        }
        return c;
    }

    int find_ans(vector<vector<int>>& mat)
    {
        int ans = 0;
        for(int i = 0; i < comb.size(); i++)
        {
            vector<int>temp = comb[i];
            vector<vector<int>> mat1(mat.size(), vector<int>(mat[0].size(),0));
            for(int j = 0; j < temp.size(); j++)
            {
                int col_val = temp[j];
                for(int k = 0; k < mat1.size(); k++)
                    mat1[k][col_val] = mat[k][col_val];
            }
            ans = max(ans, find(mat1));
        }
        return ans;
    }
    
    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)
    {
        int col = mat[0].size();
        if(count == cols)
        {
            comb.push_back(tans);
            return;
        }
        if(idx >= col)
            return;
        
        helper(mat, cols, count, idx+1, tans);
        tans.push_back(idx);
        helper(mat, cols, count+1, idx+1, tans);
    }
    
    int maximumRows(vector<vector<int>>& mat, int cols) {
        
        vector<int>tans;
        helper(mat, cols, 0, 0, tans);
        return find_ans(mat);
    }
};
"
1162,cpp,maximum-rows-covered-by-columns,"class Solution {
public:
    vector<vector<int>>comb;
    
    int find(vector<vector<int>>& mat1)
    {
        int c = 0;
        for(int i = 0; i < mat1.size(); i++)
        {
            int flg = 0;
            for(int j = 0; j < mat1[0].size(); j++)
                if(mat1[i][j] == 1)
                    flg = 1;
            if(flg == 0)
                c++;
        }
        return c;
    }
    
    
    int find_ans(vector<vector<int>>& mat)
    {
        int ans = 0;
        for(int i = 0; i < comb.size(); i++)
        {
            vector<int>temp = comb[i];
            vector<vector<int>> mat1 = mat;
            for(int j = 0; j < temp.size(); j++)
            {
                int col_val = temp[j];
                for(int k = 0; k < mat1.size(); k++)
                    mat1[k][col_val] = 1;
            }
            ans = max(ans, find(mat1));
        }
        return ans;
    }
    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)
    {
        int col = mat[0].size();
        if(count == cols)
        {
            comb.push_back(tans);
            return;
        }
        if(idx >= col)
            return;
        
        helper(mat, cols, count, idx+1, tans);
        tans.push_back(idx);
        helper(mat, cols, count+1, idx+1, tans);
    }
    
    int maximumRows(vector<vector<int>>& mat, int cols) {
        
        vector<int>tans;
        helper(mat, cols, 0, 0, tans);
        return find_ans(mat);
    }
};",None,"class Solution {
public:
    vector<vector<int>>comb;
    
    int find(vector<vector<int>>& mat1)
    {
        int c = 0;
        for(int i = 0; i < mat1.size(); i++)
        {
            int flg = 0;
            for(int j = 0; j < mat1[i].size(); j++)
                if(mat1[i][j] == 1)
                    flg = 1;
            if(flg == 1)
                c++;
        }
        return c;
    }
    
    
    int find_ans(vector<vector<int>>& mat)
    {
        int ans = 0;
        for(int i = 0; i < comb.size(); i++)
        {
            vector<int>temp = comb[i];
            vector<vector<int>> mat1(mat.size(), vector<int>(mat[0].size(), 0));
            for(int j = 0; j < temp.size(); j++)
            {
                int col_val = temp[j];
                for(int k = 0; k < mat.size(); k++)
                    mat1[k][col_val] = mat[k][col_val];
            }
            ans = max(ans, find(mat1));
        }
        return ans;
    }
    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)
    {
        int col = mat[0].size();
        if(count == cols)
        {
            comb.push_back(tans);
            return;
        }
        if(idx >= col)
            return;
        
        helper(mat, cols, count, idx+1, tans);
        tans.push_back(idx);
        helper(mat, cols, count+1, idx+1, tans);
    }
    
    int maximumRows(vector<vector<int>>& mat, int cols) {
        
        vector<int>tans;
        helper(mat, cols, 0, 0, tans);
        return find_ans(mat);
    }
};
"
1163,cpp,check-if-there-is-a-valid-path-in-a-grid,"class DisjointSet{
public:
    vector<int>par,size;
    DisjointSet(int n){
        par.resize(n+1);
        size.resize(n+1,1);
        for(int i=0; i<=n; i++){
            par[i] = i;
        }
    }
    int findpar(int u){
        if(u == par[u]) return u;
        return par[u] = findpar(par[u]);
    }

    void unionBySize(int u, int v){
        u = findpar(u);
        v = findpar(v);

        if(u == v) return;

        if(size[u] >= size[v]){
            par[v] = v;
            size[u] += size[v];
        }
        else{
            par[u] = u;
            size[v] += size[u];
        }
    }
    
};
class Solution {
public:
    bool hasValidPath(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        DisjointSet ds(n*m);
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                int p = i * m + j;
                int p1 = (i-1)*m + j;
                int p2 = (i+1)*m + j;
                int p3 = i*m + (j+1);
                int p4 = i*m + (j-1);

                if(grid[i][j] == 1){
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                }
                else if(grid[i][j] == 2){
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }

                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                }
                else if(grid[i][j] == 3){
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }
                }
                else if(grid[i][j] == 4){
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }
                }
                else if(grid[i][j] == 5){
                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                }
                else if(grid[i][j] == 6){
                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                }
            }
        }
        return ds.findpar(0) == ds.findpar(n*m-1);
    }
};",None,"class DisjointSet{
public:
    vector<int>par,size;
    DisjointSet(int n){
        par.resize(n+1);
        size.resize(n+1,1);
        for(int i=0; i<=n; i++){
            par[i] = i;
        }
    }
    int findpar(int u){
        if(u == par[u]) return u;
        return par[u] = findpar(par[u]);
    }

    void unionBySize(int u, int v){
        u = findpar(u);
        v = findpar(v);

        if(u == v) return;

        if(size[u] >= size[v]){
            par[v] = u;
            size[u] += size[v];
        }
        else{
            par[u] = v;
            size[v] += size[u];
        }
    }
    
};
class Solution {
public:
    bool hasValidPath(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        DisjointSet ds(n*m);
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                int p = i * m + j;
                int p1 = (i-1)*m + j;
                int p2 = (i+1)*m + j;
                int p3 = i*m + (j+1);
                int p4 = i*m + (j-1);

                if(grid[i][j] == 1){
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                }
                else if(grid[i][j] == 2){
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }

                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                }
                else if(grid[i][j] == 3){
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }
                }
                else if(grid[i][j] == 4){
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }
                }
                else if(grid[i][j] == 5){
                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                }
                else if(grid[i][j] == 6){
                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                }
            }
        }
        return ds.findpar(0) == ds.findpar(n*m-1);
    }
};
"
1163,cpp,check-if-there-is-a-valid-path-in-a-grid,"class DisjointSet{
public:
    vector<int>par,size;
    DisjointSet(int n){
        par.resize(n+1);
        size.resize(n+1,1);
        for(int i=0; i<=n; i++){
            par[i] = i;
        }
    }
    int findpar(int u){
        if(u == par[u]) return u;
        return par[u] = findpar(par[u]);
    }

    void unionBySize(int u, int v){
        u = findpar(u);
        v = findpar(v);

        if(u == v) return;

        if(size[u] >= size[v]){
            par[v] = v;
            size[u] += size[v];
        }
        else{
            par[u] = u;
            size[v] += size[u];
        }
    }
    
};
class Solution {
public:
    bool hasValidPath(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        DisjointSet ds(n*m);
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                int p = i * m + j;
                int p1 = (i-1)*m + j;
                int p2 = (i+1)*m + j;
                int p3 = i*m + (j+1);
                int p4 = i*m + (j-1);

                if(grid[i][j] == 1){
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                }
                else if(grid[i][j] == 2){
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }

                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                }
                else if(grid[i][j] == 3){
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }
                }
                else if(grid[i][j] == 4){
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }
                }
                else if(grid[i][j] == 5){
                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                }
                else if(grid[i][j] == 6){
                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                }
            }
        }
        return ds.findpar(0) == ds.findpar(n*m-1);
    }
};",None,"class DisjointSet{
public:
    vector<int>par,size;
    DisjointSet(int n){
        par.resize(n+1);
        size.resize(n+1,1);
        for(int i=0; i<=n; i++){
            par[i] = i;
        }
    }
    int findpar(int u){
        if(u == par[u]) return u;
        return par[u] = findpar(par[u]);
    }

    void unionBySize(int u, int v){
        u = findpar(u);
        v = findpar(v);

        if(u == v) return;

        if(size[u] >= size[v]){
            par[v] = u;
            size[u] += size[v];
        }
        else{
            par[u] = v;
            size[v] += size[u];
        }
    }
    
};
class Solution {
public:
    bool hasValidPath(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        DisjointSet ds(n*m);
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                int p = i * m + j;
                int p1 = (i-1)*m + j;
                int p2 = (i+1)*m + j;
                int p3 = i*m + (j+1);
                int p4 = i*m + (j-1);

                if(grid[i][j] == 1){
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                }
                else if(grid[i][j] == 2){
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }

                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                }
                else if(grid[i][j] == 3){
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }
                }
                else if(grid[i][j] == 4){
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }
                }
                else if(grid[i][j] == 5){
                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                }
                else if(grid[i][j] == 6){
                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                }
            }
        }
        return ds.findpar(0) == ds.findpar(n*m-1);
    }
};
"
1163,cpp,check-if-there-is-a-valid-path-in-a-grid,"class DisjointSet{
public:
    vector<int>par,size;
    DisjointSet(int n){
        par.resize(n+1);
        size.resize(n+1,1);
        for(int i=0; i<=n; i++){
            par[i] = i;
        }
    }
    int findpar(int u){
        if(u == par[u]) return u;
        return par[u] = findpar(par[u]);
    }

    void unionBySize(int u, int v){
        u = findpar(u);
        v = findpar(v);

        if(u == v) return;

        if(size[u] >= size[v]){
            par[v] = v;
            size[u] += size[v];
        }
        else{
            par[u] = u;
            size[v] += size[u];
        }
    }
    
};
class Solution {
public:
    bool hasValidPath(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        DisjointSet ds(n*m);
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                int p = i * m + j;
                int p1 = (i-1)*m + j;
                int p2 = (i+1)*m + j;
                int p3 = i*m + (j+1);
                int p4 = i*m + (j-1);

                if(grid[i][j] == 1){
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                }
                else if(grid[i][j] == 2){
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }

                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                }
                else if(grid[i][j] == 3){
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }
                }
                else if(grid[i][j] == 4){
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }
                }
                else if(grid[i][j] == 5){
                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                }
                else if(grid[i][j] == 6){
                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                }
            }
        }
        return ds.findpar(0) == ds.findpar(n*m-1);
    }
};",None,"class DisjointSet{
public:
    vector<int>par,size;
    DisjointSet(int n){
        par.resize(n+1);
        size.resize(n+1,1);
        for(int i=0; i<=n; i++){
            par[i] = i;
        }
    }
    int findpar(int u){
        if(u == par[u]) return u;
        return par[u] = findpar(par[u]);
    }

    void unionBySize(int u, int v){
        u = findpar(u);
        v = findpar(v);

        if(u == v) return;

        if(size[u] >= size[v]){
            par[v] = u;
            size[u] += size[v];
        }
        else{
            par[u] = v;
            size[v] += size[u];
        }
    }
    
};
class Solution {
public:
    bool hasValidPath(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        DisjointSet ds(n*m);
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                int p = i * m + j;
                int p1 = (i-1)*m + j;
                int p2 = (i+1)*m + j;
                int p3 = i*m + (j+1);
                int p4 = i*m + (j-1);

                if(grid[i][j] == 1){
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                }
                else if(grid[i][j] == 2){
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }

                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                }
                else if(grid[i][j] == 3){
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }
                }
                else if(grid[i][j] == 4){
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }
                }
                else if(grid[i][j] == 5){
                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                }
                else if(grid[i][j] == 6){
                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                }
            }
        }
        return ds.findpar(0) == ds.findpar(n*m-1);
    }
};
"
1164,cpp,reverse-only-letters,"class Solution {
public:
    string reverseOnlyLetters(string s) 
    {
      int i=0,j=s.length()-1;
      while(i<=j)
      {
        if(isalpha(s[i])&&isalpha(s[j]))
        {
            swap(s[i],s[j]);
            i--;
            j++;
        }
        else
        {
            if(!isalpha(s[i]))
            {
                i++;
            }
            if(!isalpha(s[j]))
            {
                j--;
            }
        }
      }
      return s;
    }
};",None,"class Solution {
public:
    string reverseOnlyLetters(string s) 
    {
      int i=0,j=s.length()-1;
      while(i<=j)
      {
        if(isalpha(s[i])&&isalpha(s[j]))
        {
            swap(s[i],s[j]);
            i++;
            j--;
        }
        else
        {
            if(!isalpha(s[i]))
            {
                i++;
            }
            if(!isalpha(s[j]))
            {
                j--;
            }
        }
      }
      return s;
    }
};
"
1164,cpp,reverse-only-letters,"class Solution {
public:
    string reverseOnlyLetters(string s) 
    {
      int i=0,j=s.length()-1;
      while(i<=j)
      {
        if(isalpha(s[i])&&isalpha(s[j]))
        {
            swap(s[i],s[j]);
            i--;
            j++;
        }
        else
        {
            if(!isalpha(s[i]))
            {
                i++;
            }
            if(!isalpha(s[j]))
            {
                j--;
            }
        }
      }
      return s;
    }
};",None,"class Solution {
public:
    string reverseOnlyLetters(string s) 
    {
      int i = 0, j = s.length() - 1;
      while(i < j)
      {
        if(isalpha(s[i]) && isalpha(s[j]))
        {
            swap(s[i],s[j]);
            i++;
            j--;
        }
        else
        {
            if(!isalpha(s[i]))
            {
                i++;
            }
            if(!isalpha(s[j]))
            {
                j--;
            }
        }
      }
      return s;
    }
};
"
1164,cpp,reverse-only-letters,"class Solution {
public:
    string reverseOnlyLetters(string s) 
    {
      int i=0,j=s.length()-1;
      while(i<=j)
      {
        if(isalpha(s[i])&&isalpha(s[j]))
        {
            swap(s[i],s[j]);
            i--;
            j++;
        }
        else
        {
            if(!isalpha(s[i]))
            {
                i++;
            }
            if(!isalpha(s[j]))
            {
                j--;
            }
        }
      }
      return s;
    }
};",None,"class Solution {
public:
    string reverseOnlyLetters(string s) 
    {
      int i = 0, j = s.length() - 1;
      while (i < j)
      {
        if (isalpha(s[i]) && isalpha(s[j]))
        {
            swap(s[i], s[j]);
            i++;
            j--;
        }
        else
        {
            if(!isalpha(s[i]))
            {
                i++;
            }
            if(!isalpha(s[j]))
            {
                j--;
            }
        }
      }
      return s;
    }
};
"
1165,cpp,minimum-impossible-or,"class Solution {
public:
    int minImpossibleOR(vector<int>& nums) {
        unordered_set<int> s(nums.begin(),nums.end());
        int temp=2;
        for(int i=1;i<32;i++){
            if(s.find(temp)==s.end()) return temp;
            temp=temp*2;
        }
        return temp; 
    }
};",None,"class Solution {
public:
    int minImpossibleOR(vector<int>& nums) {
        unordered_set<int> s(nums.begin(), nums.end());
        vector<int> ors(s.begin(), s.end());
        int tillNow = ors[0];
        for (int i = 1; i < ors.size(); ++i) {
            tillNow |= ors[i];
            ors[i] = tillNow;
        }
        int result = 1;
        for (int &orCol : ors) {
            if ((orCol & result) != result) {
                return result;
            }
            result++;
        }
        return result;
    }
};
"
1165,cpp,minimum-impossible-or,"class Solution {
public:
    int minImpossibleOR(vector<int>& nums) {
        unordered_set<int> s(nums.begin(),nums.end());
        int temp=2;
        for(int i=1;i<32;i++){
            if(s.find(temp)==s.end()) return temp;
            temp=temp*2;
        }
        return temp; 
    }
};",None,"class Solution {
public:
    int minImpossibleOR(vector<int>& nums) {
        unordered_set<int> s(nums.begin(),nums.end());
        for(int temp=1;temp<=INT_MAX;temp++){
            bool possible = false;
            for(int a: s) {
                if(s.count(temp | a)){
                    possible = true; 
                    break;
                }
            }
            if(!possible) return temp;
        }
        return 0; 
    }
};
"
1165,cpp,minimum-impossible-or,"class Solution {
public:
    int minImpossibleOR(vector<int>& nums) {
        unordered_set<int> s(nums.begin(),nums.end());
        int temp=2;
        for(int i=1;i<32;i++){
            if(s.find(temp)==s.end()) return temp;
            temp=temp*2;
        }
        return temp; 
    }
};",None,"class Solution {
public:
    long long minImpossibleOR(vector<int>& nums) {
    sort(nums.begin(), nums.end());
    
    long long ans = nums[0] + 1;
    for(int i = 1; i < nums.size(); i++){
        if(nums[i] > ans) break;
        ans |= nums[i];
        ans++;
    }
    return ans;
    }
};
"
1166,cpp,search-insert-position,"class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int l=0;
        int r=nums.size()-1;
        int m;
        while(l<=r){
            m=(l+r)/2;
            if(nums[m]==target){
                return m;
            }else if(nums[m]>target){
                r=m;
            }
            else{
                l=m;
            }
        }
        return l;
    }
};",None,"class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int l=0;
        int r=nums.size()-1;
        int m;
        while(l<=r){
            m=(l+r)/2;
            if(nums[m]==target){
                return m;
            }else if(nums[m]>target){
                r=m-1;
            }
            else{
                l=m+1;
            }
        }
        return l;
    }
};
"
1166,cpp,search-insert-position,"class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int l=0;
        int r=nums.size()-1;
        int m;
        while(l<=r){
            m=(l+r)/2;
            if(nums[m]==target){
                return m;
            }else if(nums[m]>target){
                r=m;
            }
            else{
                l=m;
            }
        }
        return l;
    }
};",None,"class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int l=0;
        int r=nums.size()-1;
        int m;
        while(l<=r){
            m=(l+r)/2;
            if(nums[m]==target){
                return m;
            }else if(nums[m]>target){
                r=m-1;
            }
            else{
                l=m+1;
            }
        }
        return l;
    }
};
"
1166,cpp,search-insert-position,"class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int l=0;
        int r=nums.size()-1;
        int m;
        while(l<=r){
            m=(l+r)/2;
            if(nums[m]==target){
                return m;
            }else if(nums[m]>target){
                r=m;
            }
            else{
                l=m;
            }
        }
        return l;
    }
};",None,"class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int l=0;
        int r=nums.size()-1;
        int m;
        while(l <= r){
            m = l + (r - l) / 2;
            if(nums[m] == target){
                return m;
            } else if(nums[m] > target){
                r = m - 1;
            } else {
                l = m + 1;
            }
        }
        return l;
    }
};
"
1167,cpp,filter-restaurants-by-vegan-friendly-price-and-distance,"class Solution {
public:
    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {
        if(veganFriendly == 1){
            for(int i = 0; i<restaurants.size(); i++){
                if(restaurants[i][2] != veganFriendly){
                    restaurants[i][0] = -1;
                }
            }
        }

        for(int i = 0; i<restaurants.size(); i++){
            if(restaurants[i][3] > maxPrice || restaurants[i][4] > maxDistance){  
                restaurants[i][0]=-1;
            }
        }

        vector<int> id;
        vector<int>rating;
        for(int i=0; i<restaurants.size(); i++){
            if(restaurants[i][0]>0){
                id.push_back(restaurants[i][0]);
                rating.push_back(restaurants[i][1]);
            }
            
        }

        for(int i=0; i<rating.size(); i++){
            for(int j=i+1; j<rating.size(); j++){
                if(rating[i] < rating[j]){
                    swap(rating[i], rating[j]);
                    swap(id[i], id[j]);
                }
            }
        }

        for(int i=0; i<rating.size(); i++){
            for(int j=i+1; j<rating.size(); j++){
                if(rating[i] == rating[j] && id[i] < id[j]){
                    swap(id[i], id[j]);
                }
            }
        }

        return rating;
    }
};",None,"class Solution {
public:
    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {
        if(veganFriendly == 1){
            for(int i = 0; i<restaurants.size(); i++){
                if(restaurants[i][2] != veganFriendly){
                    restaurants[i][0] = -1;
                }
            }
        }

        for(int i = 0; i<restaurants.size(); i++){
            if(restaurants[i][3] > maxPrice || restaurants[i][4] > maxDistance){  
                restaurants[i][0]=-1;
            }
        }

        vector<int> id;
        vector<int>rating;
        for(int i=0; i<restaurants.size(); i++){
            if(restaurants[i][0]>0){
                id.push_back(restaurants[i][0]);
                rating.push_back(restaurants[i][1]);
            }
            
        }

        for(int i=0; i<rating.size(); i++){
            for(int j=i+1; j<rating.size(); j++){
                if(rating[i] < rating[j]){
                    swap(rating[i], rating[j]);
                    swap(id[i], id[j]);
                }
            }
        }

        for(int i=0; i<rating.size(); i++){
            for(int j=i+1; j<rating.size(); j++){
                if(rating[i] == rating[j] && id[i] < id[j]){
                    swap(id[i], id[j]);
                }
            }
        }

        return id;
    }
};
"
1167,cpp,filter-restaurants-by-vegan-friendly-price-and-distance,"class Solution {
public:
    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {
        if(veganFriendly == 1){
            for(int i = 0; i<restaurants.size(); i++){
                if(restaurants[i][2] != veganFriendly){
                    restaurants[i][0] = -1;
                }
            }
        }

        for(int i = 0; i<restaurants.size(); i++){
            if(restaurants[i][3] > maxPrice || restaurants[i][4] > maxDistance){  
                restaurants[i][0]=-1;
            }
        }

        vector<int> id;
        vector<int>rating;
        for(int i=0; i<restaurants.size(); i++){
            if(restaurants[i][0]>0){
                id.push_back(restaurants[i][0]);
                rating.push_back(restaurants[i][1]);
            }
            
        }

        for(int i=0; i<rating.size(); i++){
            for(int j=i+1; j<rating.size(); j++){
                if(rating[i] < rating[j]){
                    swap(rating[i], rating[j]);
                    swap(id[i], id[j]);
                }
            }
        }

        for(int i=0; i<rating.size(); i++){
            for(int j=i+1; j<rating.size(); j++){
                if(rating[i] == rating[j] && id[i] < id[j]){
                    swap(id[i], id[j]);
                }
            }
        }

        return rating;
    }
};",None,"class Solution {
public:
    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {
        if(veganFriendly == 1){
            for(int i = 0; i<restaurants.size(); i++){
                if(restaurants[i][2] != veganFriendly){
                    restaurants[i][0] = -1;
                }
            }
        }

        for(int i = 0; i<restaurants.size(); i++){
            if(restaurants[i][3] > maxPrice || restaurants[i][4] > maxDistance){  
                restaurants[i][0]=-1;
            }
        }

        vector<int> id;
        vector<int>rating;
        for(int i=0; i<restaurants.size(); i++){
            if(restaurants[i][0]>0){
                id.push_back(restaurants[i][0]);
                rating.push_back(restaurants[i][1]);
            }
            
        }

        for(int i=0; i<rating.size(); i++){
            for(int j=i+1; j<rating.size(); j++){
                if(rating[i] < rating[j]){
                    swap(rating[i], rating[j]);
                    swap(id[i], id[j]);
                }
            }
        }

        for(int i=0; i<rating.size(); i++){
            for(int j=i+1; j<rating.size(); j++){
                if(rating[i] == rating[j] && id[i] < id[j]){
                    swap(id[i], id[j]);
                }
            }
        }

        return id;
    }
};
"
1167,cpp,filter-restaurants-by-vegan-friendly-price-and-distance,"class Solution {
public:
    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {
        if(veganFriendly == 1){
            for(int i = 0; i<restaurants.size(); i++){
                if(restaurants[i][2] != veganFriendly){
                    restaurants[i][0] = -1;
                }
            }
        }

        for(int i = 0; i<restaurants.size(); i++){
            if(restaurants[i][3] > maxPrice || restaurants[i][4] > maxDistance){  
                restaurants[i][0]=-1;
            }
        }

        vector<int> id;
        vector<int>rating;
        for(int i=0; i<restaurants.size(); i++){
            if(restaurants[i][0]>0){
                id.push_back(restaurants[i][0]);
                rating.push_back(restaurants[i][1]);
            }
            
        }

        for(int i=0; i<rating.size(); i++){
            for(int j=i+1; j<rating.size(); j++){
                if(rating[i] < rating[j]){
                    swap(rating[i], rating[j]);
                    swap(id[i], id[j]);
                }
            }
        }

        for(int i=0; i<rating.size(); i++){
            for(int j=i+1; j<rating.size(); j++){
                if(rating[i] == rating[j] && id[i] < id[j]){
                    swap(id[i], id[j]);
                }
            }
        }

        return rating;
    }
};",None,"class Solution {
public:
    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {
        if(veganFriendly == 1){
            for(int i = 0; i<restaurants.size(); i++){
                if(restaurants[i][2] != veganFriendly){
                    restaurants[i][0] = -1;
                }
            }
        }

        for(int i = 0; i<restaurants.size(); i++){
            if(restaurants[i][3] > maxPrice || restaurants[i][4] > maxDistance){  
                restaurants[i][0]=-1;
            }
        }

        vector<int> id;
        vector<int>rating;
        for(int i=0; i<restaurants.size(); i++){
            if(restaurants[i][0]>0){
                id.push_back(restaurants[i][0]);
                rating.push_back(restaurants[i][1]);
            }
            
        }

        for(int i=0; i<rating.size(); i++){
            for(int j=i+1; j<rating.size(); j++){
                if(rating[i] < rating[j]){
                    swap(rating[i], rating[j]);
                    swap(id[i], id[j]);
                } else if(rating[i] == rating[j] && id[i] < id[j]) {
                    swap(id[i], id[j]);
                }
            }
        }

        return id;
    }
};
"
1168,cpp,divide-players-into-teams-of-equal-skill,"class Solution {
public:
    long long dividePlayers(vector<int>& skill) {
        int n=skill.size();
        sort(skill.begin(), skill.end());
        long long ans=0;
        int low=1, high=n-1;
        int skl=skill[low]+skill[high];

        while(low<=high){
            if( (skill[low]+skill[high])!=skl) return -1;
            ans+=skill[low]*skill[high];
            low++;
            high--;
        }

        return ans;
    }
};",None,"class Solution {
public:
    long long dividePlayers(vector<int>& skill) {
        int n=skill.size();
        sort(skill.begin(), skill.end());
        long long ans=0;
        int low=0, high=n-1; // initialized to 0 instead of 1 to correctly access the first element
        int skl=skill[low]+skill[high];

        while(low<high){ // lower than instead of lower than or equal to prevent overlap in case of even number of elements
            if( (skill[low]+skill[high])!=skl) return -1;
            ans+=skill[low]*skill[high];
            low++;
            high--;
        }

        return ans;
    }
};
"
1168,cpp,divide-players-into-teams-of-equal-skill,"class Solution {
public:
    long long dividePlayers(vector<int>& skill) {
        int n=skill.size();
        sort(skill.begin(), skill.end());
        long long ans=0;
        int low=1, high=n-1;
        int skl=skill[low]+skill[high];

        while(low<=high){
            if( (skill[low]+skill[high])!=skl) return -1;
            ans+=skill[low]*skill[high];
            low++;
            high--;
        }

        return ans;
    }
};",None,"class Solution {
public:
    long long dividePlayers(vector<int>& skill) {
        int n=skill.size();
        sort(skill.begin(), skill.end());
        long long ans=0;
        int low=0, high=n-1;
        int skl=skill[low]+skill[high];

        while(low<high){
            if( (skill[low]+skill[high])!=skl) return -1;
            ans+=skill[low]*skill[high];
            low++;
            high--;
        }

        return ans;
    }
};
"
1168,cpp,divide-players-into-teams-of-equal-skill,"class Solution {
public:
    long long dividePlayers(vector<int>& skill) {
        int n=skill.size();
        sort(skill.begin(), skill.end());
        long long ans=0;
        int low=1, high=n-1;
        int skl=skill[low]+skill[high];

        while(low<=high){
            if( (skill[low]+skill[high])!=skl) return -1;
            ans+=skill[low]*skill[high];
            low++;
            high--;
        }

        return ans;
    }
};",None,"class Solution {
public:
    long long dividePlayers(vector<int>& skill) {
        int n=skill.size();
        sort(skill.begin(), skill.end());
        long long ans=0;
        int low=0, high=n-1;
        int skl=skill[low]+skill[high];

        while(low<high){
            if( (skill[low]+skill[high])!=skl) return -1;
            ans+=skill[low]*skill[high];
            low++;
            high--;
        }

        return ans;
    }
};
"
1169,cpp,minimum-time-visiting-all-points,"#include <cstdlib>
class Solution {
public:
    int minTimeToVisitAllPoints(vector<vector<int>>& points) {
        int ans=0;
        for(int i=0;i<points.size();i++)
        {
            int temp1=points[i][0]-points[i-1][0];
            int temp2=points[i][1]-points[i-1][1];
            temp1=abs(temp1);
            temp2=abs(temp2);
            int res = max(temp1,temp2);
            cout<<res;
            ans += res;
        }
        return ans;
    }
};",None,"#include <cstdlib>
class Solution {
public:
    int minTimeToVisitAllPoints(vector<vector<int>>& points) {
        int ans=0;
        for(int i=1;i<points.size();i++)
        {
            int temp1=points[i][0]-points[i-1][0];
            int temp2=points[i][1]-points[i-1][1];
            temp1=abs(temp1);
            temp2=abs(temp2);
            int res = max(temp1,temp2);
            ans += res;
        }
        return ans;
    }
};
"
1169,cpp,minimum-time-visiting-all-points,"#include <cstdlib>
class Solution {
public:
    int minTimeToVisitAllPoints(vector<vector<int>>& points) {
        int ans=0;
        for(int i=0;i<points.size();i++)
        {
            int temp1=points[i][0]-points[i-1][0];
            int temp2=points[i][1]-points[i-1][1];
            temp1=abs(temp1);
            temp2=abs(temp2);
            int res = max(temp1,temp2);
            cout<<res;
            ans += res;
        }
        return ans;
    }
};",None,"#include <cstdlib>
class Solution {
public:
    int minTimeToVisitAllPoints(vector<vector<int>>& points) {
        int ans=0;
        for(int i=1; i<points.size(); i++)
        {
            int temp1=abs(points[i][0]-points[i-1][0]);
            int temp2=abs(points[i][1]-points[i-1][1]);
            ans += max(temp1, temp2);
        }
        return ans;
    }
};
"
1169,cpp,minimum-time-visiting-all-points,"#include <cstdlib>
class Solution {
public:
    int minTimeToVisitAllPoints(vector<vector<int>>& points) {
        int ans=0;
        for(int i=0;i<points.size();i++)
        {
            int temp1=points[i][0]-points[i-1][0];
            int temp2=points[i][1]-points[i-1][1];
            temp1=abs(temp1);
            temp2=abs(temp2);
            int res = max(temp1,temp2);
            cout<<res;
            ans += res;
        }
        return ans;
    }
};",None,"#include <cstdlib>
class Solution {
public:
    int minTimeToVisitAllPoints(vector<vector<int>>& points) {
        int ans = 0;
        for(int i = 1; i < points.size(); i++)
        {
            int temp1 = abs(points[i][0] - points[i - 1][0]);
            int temp2 = abs(points[i][1] - points[i - 1][1]);
            int res = max(temp1, temp2);
            ans += res;
        }
        return ans;
    }
};
"
1170,cpp,distance-between-bus-stops,"class Solution {
public:
    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {
        int i, dis1=0, dis2=0, j, temp;

        if(start>destination)
        {
            temp = start;
            start = destination;
            destination = temp;
        }

        for(i=start ; i<destination ; i++)
        {
            dis1 += distance[i];
        }

        i = start;
        j = distance.size()-destination+start;
        while(j>0)
        {
            if(i<0)
            {
                dis2 += distance[distance.size()+i];
            }
            else
                dis2 += distance[i];
            i--;
            j--;
        }

        if(dis1<dis2)
            return dis1;
        return dis2;
    }
};",None,"class Solution {
public:
    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {
        int total = 0;
        for (int d : distance)
            total += d;
            
        if (start > destination)
            swap(start, destination);
            
        int dis1 = 0;
        for (int i = start; i < destination; i++)
            dis1 += distance[i];
        return min(dis1, total - dis1);
    }
};
"
1170,cpp,distance-between-bus-stops,"class Solution {
public:
    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {
        int i, dis1=0, dis2=0, j, temp;

        if(start>destination)
        {
            temp = start;
            start = destination;
            destination = temp;
        }

        for(i=start ; i<destination ; i++)
        {
            dis1 += distance[i];
        }

        i = start;
        j = distance.size()-destination+start;
        while(j>0)
        {
            if(i<0)
            {
                dis2 += distance[distance.size()+i];
            }
            else
                dis2 += distance[i];
            i--;
            j--;
        }

        if(dis1<dis2)
            return dis1;
        return dis2;
    }
};",None,"class Solution {
public:
    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {
        int total = 0;
        for (int dis : distance) total += dis;

        if (start > destination) swap(start, destination);
        
        int dis = 0;
        for (int i = start; i < destination; i++) {
            dis += distance[i];
        }
        
        return min(dis, total - dis);
    }
};
"
1170,cpp,distance-between-bus-stops,"class Solution {
public:
    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {
        int i, dis1=0, dis2=0, j, temp;

        if(start>destination)
        {
            temp = start;
            start = destination;
            destination = temp;
        }

        for(i=start ; i<destination ; i++)
        {
            dis1 += distance[i];
        }

        i = start;
        j = distance.size()-destination+start;
        while(j>0)
        {
            if(i<0)
            {
                dis2 += distance[distance.size()+i];
            }
            else
                dis2 += distance[i];
            i--;
            j--;
        }

        if(dis1<dis2)
            return dis1;
        return dis2;
    }
};",None,"class Solution {
public:
    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {
        int i, dis1=0, dis2=0, temp;

        if(start>destination)
        {
            temp = start;
            start = destination;
            destination = temp;
        }

        for(i=start ; i<destination ; i++)
        {
            dis1 += distance[i];
        }

        for(i=start-1, dis2=distance[i]; i!=destination; i=(i-1+distance.size())%distance.size())
        {
            dis2 += distance[i];
        }

        if(dis1<dis2)
            return dis1;
        return dis2;
    }
};
"
1171,cpp,shortest-bridge,"class Solution {
public:

int r[4] = {-1 , 0, 1, 0};
int c[4] = {0 ,1 , 0 , -1};

void dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)
{
    int n = grid[0].size();
    vis[row][col] = 1;
    v.push_back({row , col});
    for(int i=0; i<4; i++)
    {
        int nrow = row + r[i];
        int ncol = col + c[i];

        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)
        {
            dfs(nrow , ncol , v , vis , grid);
        }
    }

}

    int shortestBridge(vector<vector<int>>& grid) {
        
        vector<pair<int,int>> v;
        vector<pair<int,int>> v1;
        vector<pair<int,int>> v2;
        int n = grid.size();
        vector<vector<int>> vis(n , vector<int>(n , 0));
        bool flag = 0;
        for(int i=0; i<n; i++)
        {
            for(int j=0; j<n; j++)
            {
                if(grid[i][j] == 1 and vis[i][j] == 0)
                {
                    dfs(i , j , v , vis, grid);
                    if(flag == 0)
                    {
                        v1 = v;
                        flag = 1;
                        v.clear();
                    }
                    else
                    {
                        v2 = v;
                    }
                }
            
            }
           
        }

        int ans = 1e9;


        for(auto it: v1)
        {
            int row1 = it.first;
            int col1 = it.second;

            for(auto itt: v2)
            {
                int row2 = itt.first;
                int col2 = itt.second;

                int dist = abs(row1 - row2) + abs(col1 - col2);
                ans = min(ans , dist);
            }
        }
    
        return ans;
    }
};",None,"class Solution {
public:

int r[4] = {-1 , 0, 1, 0};
int c[4] = {0 ,1 , 0 , -1};

void dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)
{
    int n = grid[0].size();
    vis[row][col] = 1;
    v.push_back({row , col});
    for(int i=0; i<4; i++)
    {
        int nrow = row + r[i];
        int ncol = col + c[i];

        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)
        {
            dfs(nrow , ncol , v , vis , grid);
        }
    }

}

    int shortestBridge(vector<vector<int>>& grid) {
        
        vector<pair<int,int>> v;
        vector<pair<int,int>> v1;
        vector<pair<int,int>> v2;
        int n = grid.size();
        vector<vector<int>> vis(n , vector<int>(n , 0));
        bool flag = 0;
        for(int i=0; i<n; i++)
        {
            for(int j=0; j<n; j++)
            {
                if(grid[i][j] == 1 and vis[i][j] == 0)
                {
                    dfs(i , j , v , vis, grid);
                    if(flag == 0)
                    {
                        v1 = v;
                        flag = 1;
                        v.clear();
                    }
                    else
                    {
                        v2 = v;
                    }
                }
            
            }
           
        }

        int ans = INT_MAX;

        for(auto it: v1)
        {
            int row1 = it.first;
            int col1 = it.second;

            for(auto itt: v2)
            {
                int row2 = itt.first;
                int col2 = itt.second;

                int dist = abs(row1 - row2) + abs(col1 - col2) - 1;
                ans = min(ans , dist);
            }
        }
    
        return ans;
    }
};
"
1171,cpp,shortest-bridge,"class Solution {
public:

int r[4] = {-1 , 0, 1, 0};
int c[4] = {0 ,1 , 0 , -1};

void dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)
{
    int n = grid[0].size();
    vis[row][col] = 1;
    v.push_back({row , col});
    for(int i=0; i<4; i++)
    {
        int nrow = row + r[i];
        int ncol = col + c[i];

        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)
        {
            dfs(nrow , ncol , v , vis , grid);
        }
    }

}

    int shortestBridge(vector<vector<int>>& grid) {
        
        vector<pair<int,int>> v;
        vector<pair<int,int>> v1;
        vector<pair<int,int>> v2;
        int n = grid.size();
        vector<vector<int>> vis(n , vector<int>(n , 0));
        bool flag = 0;
        for(int i=0; i<n; i++)
        {
            for(int j=0; j<n; j++)
            {
                if(grid[i][j] == 1 and vis[i][j] == 0)
                {
                    dfs(i , j , v , vis, grid);
                    if(flag == 0)
                    {
                        v1 = v;
                        flag = 1;
                        v.clear();
                    }
                    else
                    {
                        v2 = v;
                    }
                }
            
            }
           
        }

        int ans = 1e9;


        for(auto it: v1)
        {
            int row1 = it.first;
            int col1 = it.second;

            for(auto itt: v2)
            {
                int row2 = itt.first;
                int col2 = itt.second;

                int dist = abs(row1 - row2) + abs(col1 - col2);
                ans = min(ans , dist);
            }
        }
    
        return ans;
    }
};",None,"class Solution {
public:

int r[4] = {-1 , 0, 1, 0};
int c[4] = {0 ,1 , 0 , -1};

void dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)
{
    int n = grid[0].size();
    vis[row][col] = 1;
    v.push_back({row , col});
    for(int i=0; i<4; i++)
    {
        int nrow = row + r[i];
        int ncol = col + c[i];

        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)
        {
            dfs(nrow , ncol , v , vis , grid);
        }
    }

}

    int shortestBridge(vector<vector<int>>& grid) {
        
        vector<pair<int,int>> v;
        vector<pair<int,int>> v1;
        vector<pair<int,int>> v2;
        int n = grid.size();
        vector<vector<int>> vis(n , vector<int>(n , 0));
        bool flag = 0;
        for(int i=0; i<n; i++)
        {
            for(int j=0; j<n; j++)
            {
                if(grid[i][j] == 1 and vis[i][j] == 0)
                {
                    dfs(i , j , v , vis, grid);
                    if(flag == 0)
                    {
                        v1 = v;
                        flag = 1;
                        v.clear();
                    }
                    else
                    {
                        v2 = v;
                    }
                }
            
            }
           
        }

        int ans = 1e9;


        for(auto it: v1)
        {
            int row1 = it.first;
            int col1 = it.second;

            for(auto itt: v2)
            {
                int row2 = itt.first;
                int col2 = itt.second;

                int dist = abs(row1 - row2) + abs(col1 - col2) - 1;
                ans = min(ans , dist);
            }
        }
    
        return ans;
    }
};
"
1171,cpp,shortest-bridge,"class Solution {
public:

int r[4] = {-1 , 0, 1, 0};
int c[4] = {0 ,1 , 0 , -1};

void dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)
{
    int n = grid[0].size();
    vis[row][col] = 1;
    v.push_back({row , col});
    for(int i=0; i<4; i++)
    {
        int nrow = row + r[i];
        int ncol = col + c[i];

        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)
        {
            dfs(nrow , ncol , v , vis , grid);
        }
    }

}

    int shortestBridge(vector<vector<int>>& grid) {
        
        vector<pair<int,int>> v;
        vector<pair<int,int>> v1;
        vector<pair<int,int>> v2;
        int n = grid.size();
        vector<vector<int>> vis(n , vector<int>(n , 0));
        bool flag = 0;
        for(int i=0; i<n; i++)
        {
            for(int j=0; j<n; j++)
            {
                if(grid[i][j] == 1 and vis[i][j] == 0)
                {
                    dfs(i , j , v , vis, grid);
                    if(flag == 0)
                    {
                        v1 = v;
                        flag = 1;
                        v.clear();
                    }
                    else
                    {
                        v2 = v;
                    }
                }
            
            }
           
        }

        int ans = 1e9;


        for(auto it: v1)
        {
            int row1 = it.first;
            int col1 = it.second;

            for(auto itt: v2)
            {
                int row2 = itt.first;
                int col2 = itt.second;

                int dist = abs(row1 - row2) + abs(col1 - col2);
                ans = min(ans , dist);
            }
        }
    
        return ans;
    }
};",None,"class Solution {
public:

int r[4] = {-1 , 0, 1, 0};
int c[4] = {0 ,1 , 0 , -1};

void dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)
{
    int n = grid.size();
    vis[row][col] = 1;
    v.push_back({row , col});
    for(int i=0; i<4; i++)
    {
        int nrow = row + r[i];
        int ncol = col + c[i];

        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)
        {
            dfs(nrow , ncol , v , vis , grid);
        }
    }

}

int shortestBridge(vector<vector<int>>& grid) {
        
    vector<pair<int,int>> v;
    vector<pair<int,int>> v1;
    vector<pair<int,int>> v2;
    int n = grid.size();
    vector<vector<int>> vis(n , vector<int>(n , 0));
    bool flag = 0;
    for(int i=0; i<n; i++)
    {
        for(int j=0; j<n; j++)
        {
            if(grid[i][j] == 1 and vis[i][j] == 0)
            {
                dfs(i , j , v , vis, grid);
                if(flag == 0)
                {
                    v1 = v;
                    flag = 1;
                    v.clear();
                }
                else
                {
                    v2 = v;
                }
            }
        
        }
       
    }

    int ans = 1e9;


    for(auto it: v1)
    {
        int row1 = it.first;
        int col1 = it.second;

        for(auto itt: v2)
        {
            int row2 = itt.first;
            int col2 = itt.second;

            int dist = abs(row1 - row2) + abs(col1 - col2) - 1;
            ans = min(ans , dist);
        }
    }

    return ans;
}
};
"
1172,cpp,count-stepping-numbers-in-range,"class Solution {
public:
    #define mod 1000000007
    long long dp[102][10][2][2];
    long long f(string &r,int n,int pre,int leadingZero,int tight){
        if(n==0) return 1;
        
        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];
        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;
        
        if(leadingZero){
            for(int i=0;i<=up;i++){
                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; 
            }
        } else {
            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;
            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;
        }
        
        
        return dp[n][pre][leadingZero][tight]=ans;
    }
    int countSteppingNumbers(string low, string high) {
        int n=high.size();
        memset(dp,-1,sizeof(dp));
        long long r= f(high,high.size(),0,1,0);  
        memset(dp,-1,sizeof(dp));
        for(int i=low.size()-1;i>=0;i--){
            if((low[i]-'0')>0){
                low[i]--;break;
            } else {
                low[i]='9';
            }
        }
        
        long long l= f(low,low.size(),0,1,1);
        cout<<l<<"" ""<<r<<endl;
        return (r-l+mod)%mod;
    }
};",None,"class Solution {
public:
    #define mod 1000000007
    long long dp[102][10][2][2];
    long long f(string &r,int n,int pre,int leadingZero,int tight){
        if(n==0) return 1;
        
        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];
        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;
        
        if(leadingZero){
            for(int i=0;i<=up;i++){
                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; 
            }
        } else {
            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;
            if(pre+1<=9) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;
        }
        
        return dp[n][pre][leadingZero][tight]=ans;
    }
    
    int countSteppingNumbers(string low, string high) {
        int n=high.size();
        memset(dp,-1,sizeof(dp));
        long long r= f(high,high.size(),0,1,1);  
        memset(dp,-1,sizeof(dp));

        for(int i=low.size()-1;i>=0;i--){
            if((low[i]-'0')>0){
                low[i]--;break;
            } else {
                low[i]='9';
            }
        }

        while(low.size()<n) low=""0""+low;
        
        long long l= f(low,low.size(),0,1,1);

        return (r-l+mod)%mod;
    }
};
"
1172,cpp,count-stepping-numbers-in-range,"class Solution {
public:
    #define mod 1000000007
    long long dp[102][10][2][2];
    long long f(string &r,int n,int pre,int leadingZero,int tight){
        if(n==0) return 1;
        
        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];
        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;
        
        if(leadingZero){
            for(int i=0;i<=up;i++){
                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; 
            }
        } else {
            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;
            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;
        }
        
        
        return dp[n][pre][leadingZero][tight]=ans;
    }
    int countSteppingNumbers(string low, string high) {
        int n=high.size();
        memset(dp,-1,sizeof(dp));
        long long r= f(high,high.size(),0,1,0);  
        memset(dp,-1,sizeof(dp));
        for(int i=low.size()-1;i>=0;i--){
            if((low[i]-'0')>0){
                low[i]--;break;
            } else {
                low[i]='9';
            }
        }
        
        long long l= f(low,low.size(),0,1,1);
        cout<<l<<"" ""<<r<<endl;
        return (r-l+mod)%mod;
    }
};",None,"class Solution {
public:
    #define mod 1000000007
    long long dp[102][10][2][2];
    long long f(string &r,int n,int pre,int leadingZero,int tight){
        if(n==0) return 1;

        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];
        long long up = tight ? (r[r.size()-n]-'0'):9, ans=0;

        if(leadingZero){
            for(int i=0;i<=up;i++){
                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; 
            }
        } else {
            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;
            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;
        }

        return dp[n][pre][leadingZero][tight]=ans;
    }
    int countSteppingNumbers(string low, string high) {
        int n=high.size();
        memset(dp,-1,sizeof(dp));
        long long r= f(high,high.size(),0,1,1);  
        memset(dp,-1,sizeof(dp));
        for(int i=low.size()-1;i>=0;i--){
            if((low[i]-'0')>0){
                low[i]--;
                break;
            } else {
                low[i]='9';
            }
        }

        long long l= f(low,low.size(),0,1,1);
        return (r-l+mod)%mod;
    }
};
"
1172,cpp,count-stepping-numbers-in-range,"class Solution {
public:
    #define mod 1000000007
    long long dp[102][10][2][2];
    long long f(string &r,int n,int pre,int leadingZero,int tight){
        if(n==0) return 1;
        
        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];
        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;
        
        if(leadingZero){
            for(int i=0;i<=up;i++){
                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; 
            }
        } else {
            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;
            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;
        }
        
        
        return dp[n][pre][leadingZero][tight]=ans;
    }
    int countSteppingNumbers(string low, string high) {
        int n=high.size();
        memset(dp,-1,sizeof(dp));
        long long r= f(high,high.size(),0,1,0);  
        memset(dp,-1,sizeof(dp));
        for(int i=low.size()-1;i>=0;i--){
            if((low[i]-'0')>0){
                low[i]--;break;
            } else {
                low[i]='9';
            }
        }
        
        long long l= f(low,low.size(),0,1,1);
        cout<<l<<"" ""<<r<<endl;
        return (r-l+mod)%mod;
    }
};",None,"class Solution {
public:
    #define mod 1000000007
    long long dp[102][10][2][2];
    long long f(string &r,int n,int pre,int leadingZero,int tight){
        if(n==0) return 1;

        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];
        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;

        if(leadingZero){
            for(int i=0;i<=up;i++){
                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; 
            }
        } else {
            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;
            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;
        }

        return dp[n][pre][leadingZero][tight]=ans;
    }
    int countSteppingNumbers(string low, string high) {
        int n=high.size();
        memset(dp,-1,sizeof(dp));
        long long r= f(high,high.size(),0,1,1);  
        memset(dp,-1,sizeof(dp));
        for(int i=low.size()-1;i>=0;i--){
            if((low[i]-'0')>0){
                low[i]--;break;
            } else {
                low[i]='9';
            }
        }

        long long l= f(low,low.size(),0,1,1);
        return (r-l+mod)%mod;
    }
};
"
1173,cpp,brace-expansion-ii,"class Solution {
public:
    
    vector<string> multiply(vector<string>& a, vector<string>& b){
        if(a.empty()) return b;
        if(b.empty()) return a;
        vector<string> ans;
        for(auto&i:a){
            for(auto&j:b) ans.push_back(i+j);
        }
        return ans;
    }
    
    vector<string> braceExpansionII(string expression) {
        vector<string>  res, curr;
        stack<vector<string>> st;
        for(auto&x:expression){
            if(x >= 'a' and x <= 'z'){
                if(curr.size()) for(auto&i:curr) i += x;
                else curr.push_back(string(1, x));
            }
            else if(x == '{'){
                st.push(res); st.push(curr);
                res.clear(), curr.clear();
            }
            else if(x == '}'){
                vector<string> preCurr = st.top(); st.pop();
                vector<string> preRes = st.top(); st.pop();
                for(auto&i:curr) res.push_back(i);
                res = multiply(preCurr, res);
                curr = preRes;
            }
            else if(x == ','){
                for(auto&i:curr) res.push_back(i);
                curr.clear();
            }
        }
        for(auto&i:curr) res.push_back(i);
        sort(res.begin(), res.end());
        return vector<string>(res.begin(), unique(res.begin(), res.end()));
    }
};",None,"class Solution {
public:

    vector<string> multiply(vector<string>& a, vector<string>& b){
        if(a.empty()) return b;
        if(b.empty()) return a;
        vector<string> ans;
        for(auto&i:a){
            for(auto&j:b) ans.push_back(i+j);
        }
        return ans;
    }
    
    vector<string> braceExpansionII(string expression) {
        vector<string>  res, curr, preRes, preCurr;
        stack<vector<string>> st;
        for(auto&x:expression){
            if(isalpha(x)) {
                for(auto &i: curr) i += x;
                if(curr.empty()) curr.push_back(string(1, x));
            }
            else if(x == '{'){
                st.push(res); st.push(curr);
                res.clear(); curr.clear();
            }
            else if(x == '}'){
                for(auto&i:curr) res.push_back(i);
                curr = st.top(); st.pop();
                preRes = st.top(); st.pop();
                res = multiply(preRes, res);
                curr = multiply(curr, preRes);
                res = multiply(curr, res);
            }
            else if(x == ','){
                for(auto&i:curr) res.push_back(i);
                curr.clear();
            }
        }
        for(auto&i:curr) res.push_back(i);
        sort(res.begin(), res.end());
        return vector<string>(res.begin(), unique(res.begin(), res.end()));
    }
};
"
1173,cpp,brace-expansion-ii,"class Solution {
public:
    
    vector<string> multiply(vector<string>& a, vector<string>& b){
        if(a.empty()) return b;
        if(b.empty()) return a;
        vector<string> ans;
        for(auto&i:a){
            for(auto&j:b) ans.push_back(i+j);
        }
        return ans;
    }
    
    vector<string> braceExpansionII(string expression) {
        vector<string>  res, curr;
        stack<vector<string>> st;
        for(auto&x:expression){
            if(x >= 'a' and x <= 'z'){
                if(curr.size()) for(auto&i:curr) i += x;
                else curr.push_back(string(1, x));
            }
            else if(x == '{'){
                st.push(res); st.push(curr);
                res.clear(), curr.clear();
            }
            else if(x == '}'){
                vector<string> preCurr = st.top(); st.pop();
                vector<string> preRes = st.top(); st.pop();
                for(auto&i:curr) res.push_back(i);
                res = multiply(preCurr, res);
                curr = preRes;
            }
            else if(x == ','){
                for(auto&i:curr) res.push_back(i);
                curr.clear();
            }
        }
        for(auto&i:curr) res.push_back(i);
        sort(res.begin(), res.end());
        return vector<string>(res.begin(), unique(res.begin(), res.end()));
    }
};",None,"class Solution {
public:
    
    vector<string> multiply(vector<string>& a, vector<string>& b){
        if(a.empty()) return b;
        if(b.empty()) return a;
        vector<string> ans;
        for(auto&i:a){
            for(auto&j:b) ans.push_back(i+j);
        }
        return ans;
    }
    
    vector<string> braceExpansionII(string expression) {
        vector<string>  res;
        stack<vector<string>> st;
        vector<string> curr;
        curr.push_back("""");
        
        for(auto&x:expression){
            if(x >= 'a' and x <= 'z'){
                for(auto&i:curr) i += x;
            }
            else if(x == '{'){
                st.push(res); st.push(curr);
                res.clear(); curr.clear();
                curr.push_back("""");
            }
            else if(x == '}'){
                for(auto&i:curr) res.push_back(i);
                curr = st.top(); st.pop();
                vector<string> preRes = st.top(); st.pop();
                res = multiply(preRes, res);
            }
            else if(x == ','){
                for(auto&i:curr) res.push_back(i);
                curr.clear();
                curr.push_back("""");
            }
        }
        for(auto&i:curr) res.push_back(i);
        sort(res.begin(), res.end());
        return vector<string>(res.begin(), unique(res.begin(), res.end()));
    }
};
"
1173,cpp,brace-expansion-ii,"class Solution {
public:
    
    vector<string> multiply(vector<string>& a, vector<string>& b){
        if(a.empty()) return b;
        if(b.empty()) return a;
        vector<string> ans;
        for(auto&i:a){
            for(auto&j:b) ans.push_back(i+j);
        }
        return ans;
    }
    
    vector<string> braceExpansionII(string expression) {
        vector<string>  res, curr;
        stack<vector<string>> st;
        for(auto&x:expression){
            if(x >= 'a' and x <= 'z'){
                if(curr.size()) for(auto&i:curr) i += x;
                else curr.push_back(string(1, x));
            }
            else if(x == '{'){
                st.push(res); st.push(curr);
                res.clear(), curr.clear();
            }
            else if(x == '}'){
                vector<string> preCurr = st.top(); st.pop();
                vector<string> preRes = st.top(); st.pop();
                for(auto&i:curr) res.push_back(i);
                res = multiply(preCurr, res);
                curr = preRes;
            }
            else if(x == ','){
                for(auto&i:curr) res.push_back(i);
                curr.clear();
            }
        }
        for(auto&i:curr) res.push_back(i);
        sort(res.begin(), res.end());
        return vector<string>(res.begin(), unique(res.begin(), res.end()));
    }
};",None,"class Solution {
public:

    vector<string> multiply(vector<string>& a, vector<string>& b){
        if(a.empty()) return b;
        if(b.empty()) return a;
        vector<string> ans;
        for(auto& i : a){
            for(auto& j : b){
                ans.push_back(i + j);
            }
        }
        return ans;
    }
 
    vector<string> braceExpansionII(string expression) {
        vector<string>  res, curr;
        stack<vector<string>> st;
        for(auto& x : expression){
            if(x >= 'a' && x <= 'z'){
                if(curr.size()){
                    for(auto& i : curr){
                        i += x;
                    }
                } else {
                    curr.push_back(string(1, x));
                }
            } else if(x == '{'){
                st.push(res); 
                st.push(curr);
                res.clear(); 
                curr.clear();
            } else if(x == '}'){
                for(auto& i : curr){
                    res.push_back(i);
                }
                curr = st.top(); st.pop();
                vector<string> preRes = st.top(); st.pop();
                res = multiply(curr, res);
                curr = preRes;
            } else if(x == ','){
                for(auto& i : curr){
                    res.push_back(i);
                }
                curr.clear();
            }
        }
        for(auto& i : curr){
            res.push_back(i);
        }
        sort(res.begin(), res.end());
        res.erase(unique(res.begin(), res.end()), res.end());
        return res;
    }
};
"
1174,cpp,longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit,"class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
        int ans=1,l=0,h=0,count=0;
        map<int,int> mp;
        mp[nums[l]]++;
        
        while(h<nums.size()){
            mp[nums[h]]++;
            count++;
            
            if(prev(mp.end())->first - mp.begin()->first <= limit){
                ans=max(ans,count);
            }else{
                while(prev(mp.end())->first - mp.begin()->first > limit && l<h){
                    if(mp[nums[l]]>1)mp[nums[l]]--;
                    else mp.erase(nums[l]);
                    count--;
                    l++;
                }
            }
            h++;
        }
        return ans;
    }
};",None,"class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
        int ans=0,l=0,h=0,count=0;
        multimap<int,int> mp;

        while(h<nums.size()){
            mp.insert({nums[h], h});
            count++;
            
            if(mp.rbegin()->first - mp.begin()->first > limit){
                while(mp.rbegin()->first - mp.begin()->first > limit && l<=h){
                    if(mp.find(nums[l]) != mp.end())
                        mp.erase(mp.find(nums[l]));
                    count--;
                    l++;
                }
            }
            ans=max(ans,count);
            h++;
        }
        return ans;
    }
};
"
1174,cpp,longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit,"class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
        int ans=1,l=0,h=0,count=0;
        map<int,int> mp;
        mp[nums[l]]++;
        
        while(h<nums.size()){
            mp[nums[h]]++;
            count++;
            
            if(prev(mp.end())->first - mp.begin()->first <= limit){
                ans=max(ans,count);
            }else{
                while(prev(mp.end())->first - mp.begin()->first > limit && l<h){
                    if(mp[nums[l]]>1)mp[nums[l]]--;
                    else mp.erase(nums[l]);
                    count--;
                    l++;
                }
            }
            h++;
        }
        return ans;
    }
};",None,"class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
        int ans=1,l=0,h=1,count=1;
        map<int,int> mp;
        mp[nums[l]]++;
        
        while(h < nums.size()){
            mp[nums[h]]++;
            count++;
            
            if(prev(mp.end())->first - mp.begin()->first <= limit){
                ans=max(ans,count);
            }
            else{
                while(prev(mp.end())->first - mp.begin()->first > limit && l<h){
                    if(mp[nums[l]]>1){
                        mp[nums[l]]--;
                    }
                    else{
                        mp.erase(nums[l]);
                    }
                    count--;
                    l++;
                }
            }
            h++;
        }
        return ans;
    }
};
"
1174,cpp,longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit,"class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
        int ans=1,l=0,h=0,count=0;
        map<int,int> mp;
        mp[nums[l]]++;
        
        while(h<nums.size()){
            mp[nums[h]]++;
            count++;
            
            if(prev(mp.end())->first - mp.begin()->first <= limit){
                ans=max(ans,count);
            }else{
                while(prev(mp.end())->first - mp.begin()->first > limit && l<h){
                    if(mp[nums[l]]>1)mp[nums[l]]--;
                    else mp.erase(nums[l]);
                    count--;
                    l++;
                }
            }
            h++;
        }
        return ans;
    }
};",None,"class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
        int ans=0,l=0,h=0;
        map<int,int> mp;
        
        while(h<nums.size()){
            mp[nums[h]]++;
            
            while(prev(mp.end())->first - mp.begin()->first > limit){
                if(mp[nums[l]]>1) mp[nums[l]]--;
                else mp.erase(nums[l]);
                l++;
            }
            ans = max(ans, h - l + 1);
            h++;
        }
        return ans;
    }
};
"
1175,cpp,construct-binary-tree-from-preorder-and-inorder-traversal,"class Solution {
public:
    int find(vector<int>& inorder, int k) {
        for (int i = 0; i < inorder.size(); i++) if (inorder[i] == k) return i;
        return -1;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int preIndex = 0, inStart = 0, inend = inorder.size();
        return build(preorder, inorder, preIndex, inStart, inend);
    }

    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int& preIndex, int inStart, int inend) {
        if (inStart > inend) {
            return NULL;
        }

        int ele = preorder[preIndex++];
        TreeNode* root = new TreeNode(ele);
        int pos_in_inorder = find(inorder, ele);

        root->left = build(preorder, inorder, preIndex, inStart, pos_in_inorder - 1);
        root->right = build(preorder, inorder, preIndex, pos_in_inorder + 1, inend);
        return root;
    }
};",None,"class Solution {
public:
    unordered_map<int, int> inorderIndexMap;

    int find(vector<int>& inorder, int start, int end, int value) {
        return inorderIndexMap[value];
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        for(int i=0; i<inorder.size(); i++){
            inorderIndexMap[inorder[i]] = i; 
        }
        
        int preIndex = 0, inStart = 0, inEnd = inorder.size() - 1;
        return build(preorder, inorder, preIndex, inStart, inEnd);
    }

    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int& preIndex, int inStart, int inEnd) {
        if (inStart > inEnd) {
            return NULL;
        }

        int ele = preorder[preIndex++];
        TreeNode* root = new TreeNode(ele);
        int pos_in_inorder = find(inorder, inStart, inEnd, ele);

        root->left = build(preorder, inorder, preIndex, inStart, pos_in_inorder - 1);
        root->right = build(preorder, inorder, preIndex, pos_in_inorder + 1, inEnd);
        return root;
    }
};
"
1175,cpp,construct-binary-tree-from-preorder-and-inorder-traversal,"class Solution {
public:
    int find(vector<int>& inorder, int k) {
        for (int i = 0; i < inorder.size(); i++) if (inorder[i] == k) return i;
        return -1;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int preIndex = 0, inStart = 0, inend = inorder.size();
        return build(preorder, inorder, preIndex, inStart, inend);
    }

    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int& preIndex, int inStart, int inend) {
        if (inStart > inend) {
            return NULL;
        }

        int ele = preorder[preIndex++];
        TreeNode* root = new TreeNode(ele);
        int pos_in_inorder = find(inorder, ele);

        root->left = build(preorder, inorder, preIndex, inStart, pos_in_inorder - 1);
        root->right = build(preorder, inorder, preIndex, pos_in_inorder + 1, inend);
        return root;
    }
};",None,"class Solution {
public:
    unordered_map<int, int> inorderIndex;

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        for (int i = 0; i < inorder.size(); i++) {
            inorderIndex[inorder[i]] = i;
        }
        int preIndex = 0;
        return build(preorder, 0, inorder.size() - 1, preIndex);
    }

    TreeNode* build(vector<int>& preorder, int inStart, int inEnd, int& preIndex) {
        if (inStart > inEnd) {
            return NULL;
        }

        int rootVal = preorder[preIndex++];
        TreeNode* root = new TreeNode(rootVal);
        int pos_in_inorder = inorderIndex[rootVal];

        root->left = build(preorder, inStart, pos_in_inorder - 1, preIndex);
        root->right = build(preorder, pos_in_inorder + 1, inEnd, preIndex);
        return root;
    }
};
"
1175,cpp,construct-binary-tree-from-preorder-and-inorder-traversal,"class Solution {
public:
    int find(vector<int>& inorder, int k) {
        for (int i = 0; i < inorder.size(); i++) if (inorder[i] == k) return i;
        return -1;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int preIndex = 0, inStart = 0, inend = inorder.size();
        return build(preorder, inorder, preIndex, inStart, inend);
    }

    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int& preIndex, int inStart, int inend) {
        if (inStart > inend) {
            return NULL;
        }

        int ele = preorder[preIndex++];
        TreeNode* root = new TreeNode(ele);
        int pos_in_inorder = find(inorder, ele);

        root->left = build(preorder, inorder, preIndex, inStart, pos_in_inorder - 1);
        root->right = build(preorder, inorder, preIndex, pos_in_inorder + 1, inend);
        return root;
    }
};",None,"class Solution {
public:
    unordered_map<int, int> inorder_map;

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int preIndex = 0, inStart = 0;
        int inend = inorder.size();

        for (int i = 0; i < inorder.size(); i++) inorder_map[inorder[i]] = i;
        return build(preorder, inStart, inend - 1, preIndex);
    }

    TreeNode* build(vector<int>& preorder, int inStart, int inend, int& preIndex) {
        if (inStart > inend) {
            return NULL;
        }

        int ele = preorder[preIndex++];
        TreeNode* root = new TreeNode(ele);
        int pos_in_inorder = inorder_map[ele];

        root->left = build(preorder, inStart, pos_in_inorder - 1, preIndex);
        root->right = build(preorder, pos_in_inorder + 1, inend, preIndex);
        return root;
    }
};
"
1176,cpp,tallest-billboard,"class Solution {
public:

    int build_board(vector<int> &rods, int balance, int i, vector<vector<int>> &memo)
    {
        if(i>=rods.size() && balance==0)
            return 0;
        if(i>=rods.size() && balance!=0)
            return INT_MIN;

        if(memo[i][balance+5000]!=-1)
            return memo[i][balance+5000];
        int left= build_board(rods,balance+rods[i],i+1,memo);
        int right= build_board(rods,balance-rods[i],i+1,memo);

        int ans= rods[i+1]+max(left,right);

        int skip= build_board(rods,balance,i+1,memo);

        ans= max(ans,skip);

        memo[i][balance+5000]=ans;
        return ans;

    }

    int tallestBillboard(vector<int>& rods) {
        
        vector<vector<int>> memo(rods.size(),vector<int>(10001,-1));
        int ans= build_board(rods,0,0,memo);

        if(ans<=0)
            return 0;
        else
            return ans/2;
    }
};",None,"class Solution {
public:

    int build_board(vector<int> &rods, int balance, int i, vector<vector<int>> &memo)
    {
        if(i>=rods.size() && balance==0)
            return 0;
        if(i>=rods.size() && balance!=0)
            return INT_MIN;

        if(memo[i][balance+5000]!=-1)
            return memo[i][balance+5000];
        int left= build_board(rods,balance+rods[i],i+1,memo);
        int right= build_board(rods,balance-rods[i],i+1,memo);

        int ans= max(left,right);
        if(balance>=0)
            ans= max(ans,balance);

        int skip= build_board(rods,balance,i+1,memo);

        ans= max(ans,skip);

        memo[i][balance+5000]=ans;
        return ans;

    }

    int tallestBillboard(vector<int>& rods) {
        
        vector<vector<int>> memo(rods.size(),vector<int>(10001,-1));
        int ans= build_board(rods,0,0,memo);

        if(ans<=0)
            return 0;
        else
            return ans/2;
    }
};
"
1176,cpp,tallest-billboard,"class Solution {
public:

    int build_board(vector<int> &rods, int balance, int i, vector<vector<int>> &memo)
    {
        if(i>=rods.size() && balance==0)
            return 0;
        if(i>=rods.size() && balance!=0)
            return INT_MIN;

        if(memo[i][balance+5000]!=-1)
            return memo[i][balance+5000];
        int left= build_board(rods,balance+rods[i],i+1,memo);
        int right= build_board(rods,balance-rods[i],i+1,memo);

        int ans= rods[i+1]+max(left,right);

        int skip= build_board(rods,balance,i+1,memo);

        ans= max(ans,skip);

        memo[i][balance+5000]=ans;
        return ans;

    }

    int tallestBillboard(vector<int>& rods) {
        
        vector<vector<int>> memo(rods.size(),vector<int>(10001,-1));
        int ans= build_board(rods,0,0,memo);

        if(ans<=0)
            return 0;
        else
            return ans/2;
    }
};",None,"class Solution {
public:

    int build_board(vector<int> &rods, int balance, int i, vector<vector<int>> &memo)
    {
        if(i>=rods.size() && balance==0)
            return 0;
        if(i>=rods.size() && balance!=0)
            return INT_MIN;

        if(memo[i][balance+5000]!=-1)
            return memo[i][balance+5000];
        int left= build_board(rods,balance+rods[i],i+1,memo);
        int right= build_board(rods,balance-rods[i],i+1,memo);

        int take = max(left, right);

        int skip= build_board(rods, balance,i+1,memo);

        int ans= max(skip, take+rods[i]);

        memo[i][balance+5000]=ans;
        return ans;

    }

    int tallestBillboard(vector<int>& rods) {
        
        vector<vector<int>> memo(rods.size(),vector<int>(10001,-1));
        int ans= build_board(rods,0,0,memo);

        if(ans<=0)
            return 0;
        else
            return ans/2;
    }
};
"
1176,cpp,tallest-billboard,"class Solution {
public:

    int build_board(vector<int> &rods, int balance, int i, vector<vector<int>> &memo)
    {
        if(i>=rods.size() && balance==0)
            return 0;
        if(i>=rods.size() && balance!=0)
            return INT_MIN;

        if(memo[i][balance+5000]!=-1)
            return memo[i][balance+5000];
        int left= build_board(rods,balance+rods[i],i+1,memo);
        int right= build_board(rods,balance-rods[i],i+1,memo);

        int ans= rods[i+1]+max(left,right);

        int skip= build_board(rods,balance,i+1,memo);

        ans= max(ans,skip);

        memo[i][balance+5000]=ans;
        return ans;

    }

    int tallestBillboard(vector<int>& rods) {
        
        vector<vector<int>> memo(rods.size(),vector<int>(10001,-1));
        int ans= build_board(rods,0,0,memo);

        if(ans<=0)
            return 0;
        else
            return ans/2;
    }
};",None,"class Solution {
public:

    int build_board(vector<int> &rods, int balance, int i, vector<vector<int>> &memo)
    {
        if(i>=rods.size() && balance==0)
            return 0;
        if(i>=rods.size() && balance!=0)
            return INT_MIN;

        if(memo[i][balance+5000]!=-1)
            return memo[i][balance+5000];

        int left= build_board(rods,balance+rods[i],i+1,memo);
        int right= build_board(rods,balance-rods[i],i+1,memo);

        int add_to_current = max(left,right);
        
        int ans = rods[i] + add_to_current;
        if(balance + add_to_current >= 0)
            ans = max(ans, add_to_current);

        int skip= build_board(rods,balance,i+1,memo);

        ans = max(ans, skip);

        memo[i][balance+5000]=ans;
        return ans;

    }

    int tallestBillboard(vector<int>& rods) {

        vector<vector<int>> memo(rods.size(),vector<int>(10001,-1));
        int ans = build_board(rods,0,0,memo);
        
        if(ans<=0)
            return 0;
        else
            return ans/2;
    }
};
"
1177,cpp,maximum-number-of-removable-characters,"class Solution {
 int rm[100001] = {};
    bool valid(string &s, string &p, vector<int> &A, int k) {
        memset(rm, 0, sizeof(rm));
        for (int i = 0; i < k; ++i) rm[A[i]] = 1; 
        int N = s.size(), M = p.size(), j = 0; 
        for (int i = 0; i < N && j < M; ++i) {
            if (rm[i] == 1) continue; 
            if (s[i] == p[j]) ++j; 
        }
        return j == N; 
    }
public:
    int maximumRemovals(string s, string p, vector<int>& A) {
        int L = 0, R = A.size();
        while (L <= R) {
            int M = (L + R) / 2;
            if (valid(s, p, A, M)) L = M + 1;
            else R = M - 1;
        }
        return R;
    }
};",None,"class Solution {
 int rm[100001] = {};
    bool valid(string &s, string &p, vector<int> &A, int k) {
        memset(rm, 0, sizeof(rm));
        for (int i = 0; i < k; ++i) rm[A[i]] = 1; 
        int N = s.size(), M = p.size(), j = 0; 
        for (int i = 0; i < N && j < M; ++i) {
            if (rm[i] == 1) continue; 
            if (s[i] == p[j]) ++j; 
        }
        return j == M; 
    }
public:
    int maximumRemovals(string s, string p, vector<int>& A) {
        int L = 0, R = A.size();
        while (L <= R) {
            int M = (L + R) / 2;
            if (valid(s, p, A, M)) L = M + 1;
            else R = M - 1;
        }
        return R;
    }
};
"
1177,cpp,maximum-number-of-removable-characters,"class Solution {
 int rm[100001] = {};
    bool valid(string &s, string &p, vector<int> &A, int k) {
        memset(rm, 0, sizeof(rm));
        for (int i = 0; i < k; ++i) rm[A[i]] = 1; 
        int N = s.size(), M = p.size(), j = 0; 
        for (int i = 0; i < N && j < M; ++i) {
            if (rm[i] == 1) continue; 
            if (s[i] == p[j]) ++j; 
        }
        return j == N; 
    }
public:
    int maximumRemovals(string s, string p, vector<int>& A) {
        int L = 0, R = A.size();
        while (L <= R) {
            int M = (L + R) / 2;
            if (valid(s, p, A, M)) L = M + 1;
            else R = M - 1;
        }
        return R;
    }
};",None,"class Solution {
    int rm[100001] = {};
    bool valid(string &s, string &p, vector<int> &A, int k) {
        memset(rm, 0, sizeof(rm));
        for (int i = 0; i < k; ++i) rm[A[i]] = 1; 
        int N = s.size(), M = p.size(), j = 0; 
        for (int i = 0; i < N && j < M; ++i) {
            if (rm[i] == 1) continue; 
            if (s[i] == p[j]) ++j; 
        }
        return j == M; 
    }
public:
    int maximumRemovals(string s, string p, vector<int>& A) {
        int L = 0, R = A.size();
        while (L <= R) {
            int M = (L + R) / 2;
            if (valid(s, p, A, M)) L = M + 1;
            else R = M - 1;
        }
        return R;
    }
};
"
1177,cpp,maximum-number-of-removable-characters,"class Solution {
 int rm[100001] = {};
    bool valid(string &s, string &p, vector<int> &A, int k) {
        memset(rm, 0, sizeof(rm));
        for (int i = 0; i < k; ++i) rm[A[i]] = 1; 
        int N = s.size(), M = p.size(), j = 0; 
        for (int i = 0; i < N && j < M; ++i) {
            if (rm[i] == 1) continue; 
            if (s[i] == p[j]) ++j; 
        }
        return j == N; 
    }
public:
    int maximumRemovals(string s, string p, vector<int>& A) {
        int L = 0, R = A.size();
        while (L <= R) {
            int M = (L + R) / 2;
            if (valid(s, p, A, M)) L = M + 1;
            else R = M - 1;
        }
        return R;
    }
};",None,"class Solution {
 int rm[100001] = {};
    bool valid(string &s, string &p, vector<int> &A, int k) {
        memset(rm, 0, sizeof(rm));
        for (int i = 0; i < k; ++i) rm[A[i]] = 1; 
        int N = s.size(), M = p.size(), j = 0; 
        for (int i = 0; i < N && j < M; ++i) {
            if (rm[i] == 1) continue; 
            if (s[i] == p[j]) ++j; 
        }
        return j == M; 
    }
public:
    int maximumRemovals(string s, string p, vector<int>& A) {
        int L = 0, R = A.size();
        while (L <= R) {
            int M = (L + R) / 2;
            if (valid(s, p, A, M)) L = M + 1;
            else R = M - 1;
        }
        return R;
    }
};
"
1178,cpp,kth-ancestor-of-a-tree-node,"class TreeAncestor {
public:
    vector<vector<int>>v;
    TreeAncestor(int n, vector<int>& parent) {
        vector<vector<int>> par(n, vector<int>(20));
        for (int i = 0; i < n; i++) par[i][0] = i; 
        for (int j = 1; j < 20; j++) {
            for (int i = 0; i < n; i++) {
                if (par[i][j - 1] == -1) par[i][j] = -1;
                else par[i][j] = par[par[i][j - 1]][j - 1];
            }
        }
        swap(v, par);
    }
    int getKthAncestor(int node, int k) {
        for (int i = 0; i < 20; i++) {
            if ((k >> i) & 1) {
                node = v[node][i];
                if (node == -1) return -1;
            }
        }
        return node;
    }
};",None,"class TreeAncestor {
public:
    vector<vector<int>>v;
    TreeAncestor(int n, vector<int>& parent) {
        vector<vector<int>> par(n, vector<int>(20));
        for (int i = 0; i < n; i++) par[i][0] = parent[i]; 
        for (int j = 1; j < 20; j++) {
            for (int i = 0; i < n; i++) {
                if (par[i][j - 1] == -1) par[i][j] = -1;
                else par[i][j] = par[par[i][j - 1]][j - 1];
            }
        }
        swap(v, par);
    }
    int getKthAncestor(int node, int k) {
        for (int i = 0; i < 20; i++) {
            if ((k >> i) & 1) {
                node = v[node][i];
                if (node == -1) return -1;
            }
        }
        return node;
    }
};
"
1178,cpp,kth-ancestor-of-a-tree-node,"class TreeAncestor {
public:
    vector<vector<int>>v;
    TreeAncestor(int n, vector<int>& parent) {
        vector<vector<int>> par(n, vector<int>(20));
        for (int i = 0; i < n; i++) par[i][0] = i; 
        for (int j = 1; j < 20; j++) {
            for (int i = 0; i < n; i++) {
                if (par[i][j - 1] == -1) par[i][j] = -1;
                else par[i][j] = par[par[i][j - 1]][j - 1];
            }
        }
        swap(v, par);
    }
    int getKthAncestor(int node, int k) {
        for (int i = 0; i < 20; i++) {
            if ((k >> i) & 1) {
                node = v[node][i];
                if (node == -1) return -1;
            }
        }
        return node;
    }
};",None,"class TreeAncestor {
public:
    vector<vector<int>>v;
    TreeAncestor(int n, vector<int>& parent) {
        vector<vector<int>> par(n, vector<int>(20));
        for (int i = 0; i < n; i++) par[i][0] = parent[i]; 
        for (int j = 1; j < 20; j++) {
            for (int i = 0; i < n; i++) {
                if (par[i][j - 1] == -1) par[i][j] = -1;
                else par[i][j] = par[par[i][j - 1]][j - 1];
            }
        }
        swap(v, par);
    }
    int getKthAncestor(int node, int k) {
        for (int i = 0; i < 20; i++) {
            if ((k >> i) & 1) {
                node = v[node][i];
                if (node == -1) return -1;
            }
        }
        return node;
    }
};
"
1178,cpp,kth-ancestor-of-a-tree-node,"class TreeAncestor {
public:
    vector<vector<int>>v;
    TreeAncestor(int n, vector<int>& parent) {
        vector<vector<int>> par(n, vector<int>(20));
        for (int i = 0; i < n; i++) par[i][0] = i; 
        for (int j = 1; j < 20; j++) {
            for (int i = 0; i < n; i++) {
                if (par[i][j - 1] == -1) par[i][j] = -1;
                else par[i][j] = par[par[i][j - 1]][j - 1];
            }
        }
        swap(v, par);
    }
    int getKthAncestor(int node, int k) {
        for (int i = 0; i < 20; i++) {
            if ((k >> i) & 1) {
                node = v[node][i];
                if (node == -1) return -1;
            }
        }
        return node;
    }
};",None,"class TreeAncestor {
public:
    vector<vector<int>>v;
    TreeAncestor(int n, vector<int>& parent) {
        vector<vector<int>> par(n, vector<int>(20, -1));
        for (int i = 0; i < n; i++) par[i][0] = parent[i]; 
        for (int j = 1; j < 20; j++) {
            for (int i = 0; i < n; i++) {
                if (par[i][j - 1] == -1) par[i][j] = -1;
                else par[i][j] = par[par[i][j - 1]][j - 1];
            }
        }
        swap(v, par);
    }
    int getKthAncestor(int node, int k) {
        for (int i = 0; i < 20; i++) {
            if ((k >> i) & 1) {
                node = v[node][i];
                if (node == -1) return -1;
            }
        }
        return node;
    }
};
"
1179,cpp,find-players-with-zero-or-one-losses,"class Solution {
public:
    map<int,int>mp1;
    map<int,int>mp2;
    vector<vector<int>> findWinners(vector<vector<int>>& matches) {
        for(int i=0;i<matches.size();i++)
        {
            mp1[matches[i][0]]++;
            mp2[matches[i][1]];
        }
        vector<vector<int>>ans;
        vector<int>temp1;
        for(auto it: mp1)
        {
            if(mp2.find(it.first)==mp2.end()) 
            {
                temp1.push_back(it.first);
            }
        }
        ans.push_back(temp1);
        vector<int>temp2;
        for(auto it: mp2)
        {
            if(it.second==1)
            {
                temp2.push_back(it.first);
            }
        }
        ans.push_back(temp2);
        return ans;
    }
};",None,"class Solution {
public:
    map<int,int>mp1;
    map<int,int>mp2;
    vector<vector<int>> findWinners(vector<vector<int>>& matches) {
        for(int i=0;i<matches.size();i++)
        {
            mp1[matches[i][0]]++;
            mp2[matches[i][1]]++;
        }
        vector<vector<int>>ans;
        vector<int>temp1;
        for(auto it: mp1)
        {
            if(mp2.find(it.first)==mp2.end()) 
            {
                temp1.push_back(it.first);
            }
        }
        ans.push_back(temp1);
        vector<int>temp2;
        for(auto it: mp2)
        {
            if(it.second==1 && mp1.find(it.first) != mp1.end())
            {
                temp2.push_back(it.first);
            }
        }
        ans.push_back(temp2);
        return ans;
    }
};
"
1179,cpp,find-players-with-zero-or-one-losses,"class Solution {
public:
    map<int,int>mp1;
    map<int,int>mp2;
    vector<vector<int>> findWinners(vector<vector<int>>& matches) {
        for(int i=0;i<matches.size();i++)
        {
            mp1[matches[i][0]]++;
            mp2[matches[i][1]];
        }
        vector<vector<int>>ans;
        vector<int>temp1;
        for(auto it: mp1)
        {
            if(mp2.find(it.first)==mp2.end()) 
            {
                temp1.push_back(it.first);
            }
        }
        ans.push_back(temp1);
        vector<int>temp2;
        for(auto it: mp2)
        {
            if(it.second==1)
            {
                temp2.push_back(it.first);
            }
        }
        ans.push_back(temp2);
        return ans;
    }
};",None,"class Solution {
public:
    map<int,int>mp1;
    map<int,int>mp2;
    vector<vector<int>> findWinners(vector<vector<int>>& matches) {
        for(int i=0;i<matches.size();i++)
        {
            mp1[matches[i][0]]++;
            mp2[matches[i][1]]++;
        }
        vector<vector<int>>ans;
        vector<int>temp1;
        for(auto it: mp1)
        {
            if(mp2.find(it.first)==mp2.end()) 
            {
                temp1.push_back(it.first);
            }
        }
        sort(temp1.begin(), temp1.end());
        ans.push_back(temp1);
        vector<int>temp2;
        for(auto it: mp2)
        {
            if(it.second==1)
            {
                temp2.push_back(it.first);
            }
        }
        sort(temp2.begin(), temp2.end());
        ans.push_back(temp2);
        return ans;
    }
};
"
1179,cpp,find-players-with-zero-or-one-losses,"class Solution {
public:
    map<int,int>mp1;
    map<int,int>mp2;
    vector<vector<int>> findWinners(vector<vector<int>>& matches) {
        for(int i=0;i<matches.size();i++)
        {
            mp1[matches[i][0]]++;
            mp2[matches[i][1]];
        }
        vector<vector<int>>ans;
        vector<int>temp1;
        for(auto it: mp1)
        {
            if(mp2.find(it.first)==mp2.end()) 
            {
                temp1.push_back(it.first);
            }
        }
        ans.push_back(temp1);
        vector<int>temp2;
        for(auto it: mp2)
        {
            if(it.second==1)
            {
                temp2.push_back(it.first);
            }
        }
        ans.push_back(temp2);
        return ans;
    }
};",None,"class Solution {
public:
    map<int,int>mp1;
    map<int,int>mp2;
    vector<vector<int>> findWinners(vector<vector<int>>& matches) {
        for(int i=0;i<matches.size();i++)
        {
            mp1[matches[i][0]]++;
            mp2[matches[i][1]]++;
        }
        vector<vector<int>>ans;
        vector<int>temp1;
        for(auto it: mp1)
        {
            if(mp2.find(it.first)==mp2.end()) 
            {
                temp1.push_back(it.first);
            }
        }
        ans.push_back(temp1);
        vector<int>temp2;
        for(auto it: mp2)
        {
            if(it.second==1 && mp1.find(it.first)!=mp1.end())
            {
                temp2.push_back(it.first);
            }
        }
        ans.push_back(temp2);
        return ans;
    }
};
"
1180,cpp,max-number-of-k-sum-pairs,"class Solution {
public:
    int maxOperations(vector<int>& nums, int k) {
        sort(nums.begin(),nums.end());
        int i=0;
        int j=nums.size();
        int count=0;
        while(j>i)
        {
            if(nums[i]+nums[j]==k)
            {
                i++;
                j--;
                count++;
            }
            else if(nums[i]+nums[j]<k)
            {
                i++;
            }
            else
            {
                j--;
            }
        }
        return count;

    }
};",None,"class Solution {
public:
    int maxOperations(vector<int>& nums, int k) {
        sort(nums.begin(),nums.end());
        int i=0;
        int j=nums.size() - 1;  // The initialization of j needs to account for base-0 array indexing. 
        int count=0;
        while(j>i)
        {
            if(nums[i]+nums[j]==k)
            {
                i++;
                j--;
                count++;
            }
            else if(nums[i]+nums[j]<k)
            {
                i++;
            }
            else
            {
                j--;
            }
        }
        return count;

    }
};
"
1180,cpp,max-number-of-k-sum-pairs,"class Solution {
public:
    int maxOperations(vector<int>& nums, int k) {
        sort(nums.begin(),nums.end());
        int i=0;
        int j=nums.size();
        int count=0;
        while(j>i)
        {
            if(nums[i]+nums[j]==k)
            {
                i++;
                j--;
                count++;
            }
            else if(nums[i]+nums[j]<k)
            {
                i++;
            }
            else
            {
                j--;
            }
        }
        return count;

    }
};",None,"class Solution {
public:
    int maxOperations(vector<int>& nums, int k) {
        sort(nums.begin(),nums.end());
        int i=0;
        int j=nums.size() - 1;
        int count=0;
        while(j>i)
        {
            if(nums[i]+nums[j]==k)
            {
                i++;
                j--;
                count++;
            }
            else if(nums[i]+nums[j]<k)
            {
                i++;
            }
            else
            {
                j--;
            }
        }
        return count;
    }
};
"
1180,cpp,max-number-of-k-sum-pairs,"class Solution {
public:
    int maxOperations(vector<int>& nums, int k) {
        sort(nums.begin(),nums.end());
        int i=0;
        int j=nums.size();
        int count=0;
        while(j>i)
        {
            if(nums[i]+nums[j]==k)
            {
                i++;
                j--;
                count++;
            }
            else if(nums[i]+nums[j]<k)
            {
                i++;
            }
            else
            {
                j--;
            }
        }
        return count;

    }
};",None,"class Solution {
public:
    int maxOperations(vector<int>& nums, int k) {
        sort(nums.begin(),nums.end());
        int i=0;
        int j = nums.size()-1;
        int count = 0;
        while( i < j )
        {
            if(nums[i] + nums[j] == k) {
                i++;
                j--;
                count++;
            } else if(nums[i] + nums[j] < k) {
                i++;
            } else {
                j--;
            }
        }
        return count;
    }
};
"
1181,cpp,minimum-cost-for-tickets,"class Solution {
public:
    int helper(vector<int>&costs,vector<int>&days,int ind,vector<int>&dp){
        if(ind<0){return 0;}
        if(dp[days[ind]]!=-1){return dp[days[ind]];}
        int daypoint=costs[0]+helper(costs,days,ind-1,dp);
        int indweek=upper_bound(days.begin(),days.end(),days[ind-1]-7)-days.begin();
        indweek--;
        int weekpoint=costs[1]+helper(costs,days,indweek,dp);
        int indmonth=upper_bound(days.begin(),days.end(),days[ind-1]-30)-days.begin();
        indmonth--;
        int monthpoint=costs[2]+helper(costs,days,indmonth,dp);
        return dp[days[ind]]=min({daypoint,weekpoint,monthpoint});
    }

    int mincostTickets(vector<int>& days, vector<int>& costs) {
        int n=days.size();
        vector<int>dp(366,-1);
        return helper(costs,days,n-1,dp);
    }
};",None,"class Solution {
public:
    int helper(vector<int>&costs,vector<int>&days,int ind,vector<int>&dp){
        if(ind<0){return 0;}
        if(dp[days[ind]]!=-1){return dp[days[ind]];}
        int daypoint=costs[0]+helper(costs,days,ind-1,dp);
        int indweek=lower_bound(days.begin(),days.end(),days[ind]-6)-days.begin();
        indweek--;
        int weekpoint=costs[1]+helper(costs,days,indweek,dp);
        int indmonth=lower_bound(days.begin(),days.end(),days[ind]-29)-days.begin();
        indmonth--;
        int monthpoint=costs[2]+helper(costs,days,indmonth,dp);
        return dp[days[ind]]=min({daypoint,weekpoint,monthpoint});
    }

    int mincostTickets(vector<int>& days, vector<int>& costs) {
        int n=days.size();
        vector<int>dp(366,-1);
        return helper(costs,days,n-1,dp);
    }
};
"
1181,cpp,minimum-cost-for-tickets,"class Solution {
public:
    int helper(vector<int>&costs,vector<int>&days,int ind,vector<int>&dp){
        if(ind<0){return 0;}
        if(dp[days[ind]]!=-1){return dp[days[ind]];}
        int daypoint=costs[0]+helper(costs,days,ind-1,dp);
        int indweek=upper_bound(days.begin(),days.end(),days[ind-1]-7)-days.begin();
        indweek--;
        int weekpoint=costs[1]+helper(costs,days,indweek,dp);
        int indmonth=upper_bound(days.begin(),days.end(),days[ind-1]-30)-days.begin();
        indmonth--;
        int monthpoint=costs[2]+helper(costs,days,indmonth,dp);
        return dp[days[ind]]=min({daypoint,weekpoint,monthpoint});
    }

    int mincostTickets(vector<int>& days, vector<int>& costs) {
        int n=days.size();
        vector<int>dp(366,-1);
        return helper(costs,days,n-1,dp);
    }
};",None,"class Solution {
public:
    int helper(vector<int>&costs,vector<int>&days,int ind,vector<int>&dp){
        if(ind<0){return 0;}
        if(dp[days[ind]]!=-1){return dp[days[ind]];}
        int daypoint=costs[0]+helper(costs,days,ind-1,dp);
        int indweek=upper_bound(days.begin(),days.begin()+ind,days[ind]-7)-days.begin();
        int weekpoint=costs[1]+helper(costs,days,indweek-1,dp);
        int indmonth=upper_bound(days.begin(),days.begin()+ind,days[ind]-30)-days.begin();
        int monthpoint=costs[2]+helper(costs,days,indmonth-1,dp);
        return dp[days[ind]]=min({daypoint,weekpoint,monthpoint});
    }

    int mincostTickets(vector<int>& days, vector<int>& costs) {
        int n=days.size();
        vector<int>dp(366,-1);
        return helper(costs,days,n-1,dp);
    }
};
"
1181,cpp,minimum-cost-for-tickets,"class Solution {
public:
    int helper(vector<int>&costs,vector<int>&days,int ind,vector<int>&dp){
        if(ind<0){return 0;}
        if(dp[days[ind]]!=-1){return dp[days[ind]];}
        int daypoint=costs[0]+helper(costs,days,ind-1,dp);
        int indweek=upper_bound(days.begin(),days.end(),days[ind-1]-7)-days.begin();
        indweek--;
        int weekpoint=costs[1]+helper(costs,days,indweek,dp);
        int indmonth=upper_bound(days.begin(),days.end(),days[ind-1]-30)-days.begin();
        indmonth--;
        int monthpoint=costs[2]+helper(costs,days,indmonth,dp);
        return dp[days[ind]]=min({daypoint,weekpoint,monthpoint});
    }

    int mincostTickets(vector<int>& days, vector<int>& costs) {
        int n=days.size();
        vector<int>dp(366,-1);
        return helper(costs,days,n-1,dp);
    }
};",None,"class Solution {
public:
    int helper(vector<int>&costs,vector<int>&days,int ind,vector<int>&dp){
        if(ind<0){return 0;}
        if(dp[days[ind]]!=-1){return dp[days[ind]];}
        int daypoint=costs[0]+helper(costs,days,ind-1,dp);
        int indweek=upper_bound(days.begin(),days.begin()+ind,days[ind]-7)-days.begin();
        int weekpoint=costs[1]+helper(costs,days,indweek-1,dp);
        int indmonth=upper_bound(days.begin(),days.begin()+ind,days[ind]-30)-days.begin();
        int monthpoint=costs[2]+helper(costs,days,indmonth-1,dp);
        return dp[days[ind]]=min({daypoint,weekpoint,monthpoint});
    }

    int mincostTickets(vector<int>& days, vector<int>& costs) {
        int n=days.size();
        vector<int>dp(366,-1);
        return helper(costs,days,n-1,dp);
    }
};
"
1182,cpp,find-first-palindromic-string-in-the-array,"class Solution {
public:
    bool check(string &word)
    {
        int l = 0;
        int r = word.size();

        while(l<r)
        {
            if(word[l] != word[r])
            {
                return false;
            }
            l++;
             r--;
        }
        return true;

    }
    string firstPalindrome(vector<string>& words) {
        for(int i=0;i<words.size();i++)
        {
            if(check(words[i]))
            return words[i];
        }

        return """";
        
    }
};",None,"class Solution {
public:
    bool check(string &word)
    {
        int l = 0;
        int r = word.size() - 1;

        while(l<r)
        {
            if(word[l] != word[r])
            {
                return false;
            }
            l++;
             r--;
        }
        return true;

    }
    string firstPalindrome(vector<string>& words) {
        for(int i=0;i<words.size();i++)
        {
            if(check(words[i]))
            return words[i];
        }

        return """";
        
    }
};
"
1182,cpp,find-first-palindromic-string-in-the-array,"class Solution {
public:
    bool check(string &word)
    {
        int l = 0;
        int r = word.size();

        while(l<r)
        {
            if(word[l] != word[r])
            {
                return false;
            }
            l++;
             r--;
        }
        return true;

    }
    string firstPalindrome(vector<string>& words) {
        for(int i=0;i<words.size();i++)
        {
            if(check(words[i]))
            return words[i];
        }

        return """";
        
    }
};",None,"class Solution {
public:
    bool check(string &word)
    {
        int l = 0;
        int r = word.size() - 1;

        while(l<r)
        {
            if(word[l] != word[r])
            {
                return false;
            }
            l++;
            r--;
        }
        return true;

    }
    string firstPalindrome(vector<string>& words) {
        for(int i=0;i<words.size();i++)
        {
            if(check(words[i]))
            return words[i];
        }

        return """";
        
    }
};
"
1182,cpp,find-first-palindromic-string-in-the-array,"class Solution {
public:
    bool check(string &word)
    {
        int l = 0;
        int r = word.size();

        while(l<r)
        {
            if(word[l] != word[r])
            {
                return false;
            }
            l++;
             r--;
        }
        return true;

    }
    string firstPalindrome(vector<string>& words) {
        for(int i=0;i<words.size();i++)
        {
            if(check(words[i]))
            return words[i];
        }

        return """";
        
    }
};",None,"class Solution {
public:
    bool check(string &word)
    {
        int l = 0;
        int r = word.size() - 1;

        while(l<r)
        {
            if(word[l] != word[r])
            {
                return false;
            }
            l++;
            r--;
        }
        return true;

    }
    string firstPalindrome(vector<string>& words) {
        for(int i=0;i<words.size();i++)
        {
            if(check(words[i]))
            return words[i];
        }

        return """";
        
    }
};
"
1183,cpp,most-profit-assigning-work,"class Solution {
public:
    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker){
        int n=difficulty.size();
        vector<pair<int,int>> nums;

        for(int i=0;i<n;i++){
            nums.push_back({profit[i],difficulty[i]});
        }
        sort(nums.begin(),nums.end());
        int index=n;
        int ans=0;
        sort(worker.begin(),worker.end());
        
        for(int i=worker.size()-1;i>=0;i--){
            while(index>=0 && nums[index].second>worker[i]) index--;
            if(index==-1) continue;
            ans+=nums[index].first;
        }
        return ans;        
    }
};",None,"class Solution {
public:
    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {
        int n = difficulty.size();
        vector<pair<int, int>> nums;
        
        for(int i = 0; i < n; i++) {
            nums.push_back({difficulty[i], profit[i]});
        }
        
        sort(nums.begin(), nums.end());
        int maxprofit = 0;
        for(int i = 1; i < n; i++) {
            if(nums[i].second < maxprofit) {
                nums[i].second = maxprofit;
            } else {
                maxprofit = nums[i].second;
            }
        }
        
        int ans = 0;
        for(int& ability : worker) {
            auto it = upper_bound(nums.begin(), nums.end(), make_pair(ability + 1, 0));
            if(it != nums.begin()) {
                ans += prev(it)->second;
            }
        }
        
        return ans;  
    }
};
"
1183,cpp,most-profit-assigning-work,"class Solution {
public:
    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker){
        int n=difficulty.size();
        vector<pair<int,int>> nums;

        for(int i=0;i<n;i++){
            nums.push_back({profit[i],difficulty[i]});
        }
        sort(nums.begin(),nums.end());
        int index=n;
        int ans=0;
        sort(worker.begin(),worker.end());
        
        for(int i=worker.size()-1;i>=0;i--){
            while(index>=0 && nums[index].second>worker[i]) index--;
            if(index==-1) continue;
            ans+=nums[index].first;
        }
        return ans;        
    }
};",None,"class Solution {
public:
    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {
        int n=difficulty.size();
        vector<pair<int,int>> nums;

        for(int i=0;i<n;i++){
            nums.push_back({difficulty[i],profit[i]});
        }
        sort(nums.begin(),nums.end());
        int ans=0;
        sort(worker.begin(),worker.end());
        int idx=0;
        int best = 0;
        
        for(int i=0;i<worker.size();i++){
            while(idx<n && nums[idx].first <= worker[i]){
                best = max(best, nums[idx++].second);
            }
            ans+=best;
        }
        return ans;        
    }
};
"
1183,cpp,most-profit-assigning-work,"class Solution {
public:
    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker){
        int n=difficulty.size();
        vector<pair<int,int>> nums;

        for(int i=0;i<n;i++){
            nums.push_back({profit[i],difficulty[i]});
        }
        sort(nums.begin(),nums.end());
        int index=n;
        int ans=0;
        sort(worker.begin(),worker.end());
        
        for(int i=worker.size()-1;i>=0;i--){
            while(index>=0 && nums[index].second>worker[i]) index--;
            if(index==-1) continue;
            ans+=nums[index].first;
        }
        return ans;        
    }
};",None,"class Solution {
public:
    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker){
        int n=difficulty.size();
        vector<pair<int,int>> nums;

        for(int i=0;i<n;i++){
            nums.push_back({difficulty[i], profit[i]});
        }
        sort(nums.begin(),nums.end());
        int maxProfit = nums[0].second;
        for(int i = 1; i < n; i++){
            if(nums[i].second < maxProfit){
                nums[i].second = maxProfit;
            }
            else{
                maxProfit = nums[i].second;
            }
        }

        int index=0;
        int ans=0;
        sort(worker.begin(),worker.end());
        
        for(int i=0;i<worker.size();i++){
            while(index<n && nums[index].first<=worker[i]) index++;
            if(index==0) continue;
            ans+=nums[index-1].second;
        }
        return ans;        
    }
};
"
1184,cpp,lru-cache,"class LRUCache {
public:
class node
{
  public:
  int key;
  int val;
  node* next;
  node* prev;
  node(int _key,int _val)
  {
    key = _key;
    val = _val;
  }
};
node* head = new node(-1,-1);
node* tail = new node(-1,-1);

int size;
unordered_map<int,node*>mpp;
    LRUCache(int capacity) {
       size = capacity; 
       head->next = tail;
       tail->prev = head;  
    }

    void addNode(node* newNode){
       
       node* temp = head->next;
       newNode->next = temp;
       newNode->prev = head;
       head->next = newNode;
       temp->prev = newNode;
    }

    void deleteNode(node* delNode){
         
       node* delprev = delNode->prev;
       node* delnext = delNode->next;
       delprev->next = delnext;
       delnext->prev = delprev;
    }
    
    int get(int _key) {
        
        if(mpp.count(_key))
        {
          node* nde = mpp[_key];
          int curr = nde->val;
          mpp.erase(_key);
          deleteNode(nde);
          addNode(nde);
          mpp[_key] = head->next;
          return curr;
        }
        return -1;
    }
    
    void put(int _key, int value) {
        
        if(mpp.count(_key))
        {
           node* nde = mpp[_key];
           mpp.erase(_key);
           deleteNode(nde);
        }
        if(mpp.size()==size)
        {
           mpp.erase(tail->prev->key);
           deleteNode(tail->prev);
        }
        addNode(new node(_key,value));
        mpp[_key] = tail->next;
    }
};",None,"class LRUCache {
public:
class node
{
  public:
  int key;
  int val;
  node* next;
  node* prev;
  node(int _key,int _val)
  {
    key = _key;
    val = _val;
  }
};
node* head = new node(-1,-1);
node* tail = new node(-1,-1);

int size;
unordered_map<int,node*>mpp;
    LRUCache(int capacity) {
       size = capacity; 
       head->next = tail;
       tail->prev = head;  
    }

    void addNode(node* newNode){
       
       node* temp = head->next;
       newNode->next = temp;
       newNode->prev = head;
       head->next = newNode;
       temp->prev = newNode;
    }

    void deleteNode(node* delNode){
         
       node* delprev = delNode->prev;
       node* delnext = delNode->next;
       delprev->next = delnext;
       delnext->prev = delprev;
    }
    
    int get(int _key) {
        
        if(mpp.count(_key))
        {
          node* nde = mpp[_key];
          int curr = nde->val;
          mpp.erase(_key);
          deleteNode(nde);
          addNode(nde);
          mpp[_key] = head->next;
          return curr;
        }
        return -1;
    }
    
    void put(int _key, int value) {
        
        if(mpp.count(_key))
        {
           node* nde = mpp[_key];
           mpp.erase(_key);
           deleteNode(nde);
        }
        if(mpp.size()==size)
        {
           mpp.erase(tail->prev->key);
           deleteNode(tail->prev);
        }
        addNode(new node(_key,value));
        mpp[_key] = head->next;
    }
};
"
1184,cpp,lru-cache,"class LRUCache {
public:
class node
{
  public:
  int key;
  int val;
  node* next;
  node* prev;
  node(int _key,int _val)
  {
    key = _key;
    val = _val;
  }
};
node* head = new node(-1,-1);
node* tail = new node(-1,-1);

int size;
unordered_map<int,node*>mpp;
    LRUCache(int capacity) {
       size = capacity; 
       head->next = tail;
       tail->prev = head;  
    }

    void addNode(node* newNode){
       
       node* temp = head->next;
       newNode->next = temp;
       newNode->prev = head;
       head->next = newNode;
       temp->prev = newNode;
    }

    void deleteNode(node* delNode){
         
       node* delprev = delNode->prev;
       node* delnext = delNode->next;
       delprev->next = delnext;
       delnext->prev = delprev;
    }
    
    int get(int _key) {
        
        if(mpp.count(_key))
        {
          node* nde = mpp[_key];
          int curr = nde->val;
          mpp.erase(_key);
          deleteNode(nde);
          addNode(nde);
          mpp[_key] = head->next;
          return curr;
        }
        return -1;
    }
    
    void put(int _key, int value) {
        
        if(mpp.count(_key))
        {
           node* nde = mpp[_key];
           mpp.erase(_key);
           deleteNode(nde);
        }
        if(mpp.size()==size)
        {
           mpp.erase(tail->prev->key);
           deleteNode(tail->prev);
        }
        addNode(new node(_key,value));
        mpp[_key] = tail->next;
    }
};",None,"class LRUCache {
public:
class node
{
  public:
  int key;
  int val;
  node* next;
  node* prev;
  node(int _key,int _val)
  {
    key = _key;
    val = _val;
  }
};
node* head = new node(-1,-1);
node* tail = new node(-1,-1);

int size;
unordered_map<int,node*>mpp;
    LRUCache(int capacity) {
       size = capacity; 
       head->next = tail;
       tail->prev = head;  
    }

    void addNode(node* newNode){
       
       node* temp = head->next;
       newNode->next = temp;
       newNode->prev = head;
       head->next = newNode;
       temp->prev = newNode;
    }

    void deleteNode(node* delNode){
         
       node* delprev = delNode->prev;
       node* delnext = delNode->next;
       delprev->next = delnext;
       delnext->prev = delprev;
    }
    
    int get(int _key) {
        
        if(mpp.count(_key))
        {
          node* nde = mpp[_key];
          int curr = nde->val;
          mpp.erase(_key);
          deleteNode(nde);
          addNode(nde);
          mpp[_key] = head->next;
          return curr;
        }
        return -1;
    }
    
    void put(int _key, int value) {
        
        if(mpp.count(_key))
        {
           node* nde = mpp[_key];
           mpp.erase(_key);
           deleteNode(nde);
        }
        if(mpp.size()==size)
        {
           mpp.erase(tail->prev->key);
           deleteNode(tail->prev);
        }
        addNode(new node(_key,value));
        mpp[_key] = head->next;
    }
};
"
1184,cpp,lru-cache,"class LRUCache {
public:
class node
{
  public:
  int key;
  int val;
  node* next;
  node* prev;
  node(int _key,int _val)
  {
    key = _key;
    val = _val;
  }
};
node* head = new node(-1,-1);
node* tail = new node(-1,-1);

int size;
unordered_map<int,node*>mpp;
    LRUCache(int capacity) {
       size = capacity; 
       head->next = tail;
       tail->prev = head;  
    }

    void addNode(node* newNode){
       
       node* temp = head->next;
       newNode->next = temp;
       newNode->prev = head;
       head->next = newNode;
       temp->prev = newNode;
    }

    void deleteNode(node* delNode){
         
       node* delprev = delNode->prev;
       node* delnext = delNode->next;
       delprev->next = delnext;
       delnext->prev = delprev;
    }
    
    int get(int _key) {
        
        if(mpp.count(_key))
        {
          node* nde = mpp[_key];
          int curr = nde->val;
          mpp.erase(_key);
          deleteNode(nde);
          addNode(nde);
          mpp[_key] = head->next;
          return curr;
        }
        return -1;
    }
    
    void put(int _key, int value) {
        
        if(mpp.count(_key))
        {
           node* nde = mpp[_key];
           mpp.erase(_key);
           deleteNode(nde);
        }
        if(mpp.size()==size)
        {
           mpp.erase(tail->prev->key);
           deleteNode(tail->prev);
        }
        addNode(new node(_key,value));
        mpp[_key] = tail->next;
    }
};",None,"class LRUCache {
public:
class node
{
  public:
  int key;
  int val;
  node* next;
  node* prev;
  node(int _key,int _val)
  {
    key = _key;
    val = _val;
  }
};
node* head = new node(-1,-1);
node* tail = new node(-1,-1);

int size;
unordered_map<int,node*>mpp;
    LRUCache(int capacity) {
       size = capacity; 
       head->next = tail;
       tail->prev = head;  
    }

    void addNode(node* newNode){
       
       node* temp = head->next;
       newNode->next = temp;
       newNode->prev = head;
       head->next = newNode;
       temp->prev = newNode;
    }

    void deleteNode(node* delNode){
       node* delprev = delNode->prev;
       node* delnext = delNode->next;
       delprev->next = delnext;
       delnext->prev = delprev;
    }
    
    int get(int _key) {
        if(mpp.find(_key) != mpp.end())
        {
          node* nde = mpp[_key];
          int curr = nde->val;
          mpp.erase(nde->key);
          deleteNode(nde);
          addNode(new node(_key, curr));
          mpp[_key] = head->next;
          return curr;
        }
        return -1;
    }
    
    void put(int _key, int value) {
        if(mpp.find(_key) != mpp.end())
        {
           node* nde = mpp[_key];
           mpp.erase(nde->key);
           deleteNode(nde);
        }
        if(mpp.size() == size)
        {
           mpp.erase(tail->prev->key);
           deleteNode(tail->prev);
        }
        addNode(new node(_key,value));
        mpp[_key] = head->next;
    }
};
"
1185,cpp,all-ancestors-of-a-node-in-a-directed-acyclic-graph,"class Solution {
public:
   
    void dfs(int i,int ansc,vector<vector<int>>&ans,vector<int>&vis,vector<vector<int>>&res){
        
        vis[i]=1;
        
        for(auto t:ans[i]){
            if(!vis[t]){
                dfs(t,ansc,ans,vis,res);
            }
        }
       
        if(i!=ansc)
            res[i].push_back(ansc);
    }
    
    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {
        
        vector<vector<int>>ans(n),result(n);
        
        for(auto a:edges){
            ans[a[0]].push_back(a[1]);
        }

        vector<int>visited(n);

        for(int i=0;i<n;i++){
            dfs(i,i,ans,visited,result);
        }
      
        return result;
    }
};",None,"class Solution {
public:

    void dfs(int i,int ansc,vector<vector<int>>&ans,vector<int>&vis,vector<vector<int>>&res){
        
        vis[i]=1;
        for(auto t:ans[i]){
            if(!vis[t]){
                dfs(t,ansc,ans,vis,res);
            }
            if(t!=ansc)
                res[ansc].push_back(t);
        }
        
    }

    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {
        
        vector<vector<int>>ans(n),result(n);
        
        for(auto a:edges){
            ans[a[0]].push_back(a[1]);
        }

        vector<int>visited(n, 0);

        for(int i=0;i<n;i++){
            dfs(i,i,ans,visited,result);
            sort(result[i].begin(), result[i].end());
            visited = vector<int>(n, 0);
        }
        
        return result;
    }
};
"
1185,cpp,all-ancestors-of-a-node-in-a-directed-acyclic-graph,"class Solution {
public:
   
    void dfs(int i,int ansc,vector<vector<int>>&ans,vector<int>&vis,vector<vector<int>>&res){
        
        vis[i]=1;
        
        for(auto t:ans[i]){
            if(!vis[t]){
                dfs(t,ansc,ans,vis,res);
            }
        }
       
        if(i!=ansc)
            res[i].push_back(ansc);
    }
    
    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {
        
        vector<vector<int>>ans(n),result(n);
        
        for(auto a:edges){
            ans[a[0]].push_back(a[1]);
        }

        vector<int>visited(n);

        for(int i=0;i<n;i++){
            dfs(i,i,ans,visited,result);
        }
      
        return result;
    }
};",None,"class Solution {
public:

    void dfs(int i, int ansc, vector<vector<int>>& edges_list, vector<int>& visited, vector<vector<int>>& result){
        visited[i] = 1;
        for(auto t: edges_list[i]){
            if(!visited[t]){
                dfs(t, ansc, edges_list, visited, result);
            }
            if(t != ansc) {
                result[ansc].push_back(t);
            }
        }
    }
    
    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {
        vector<vector<int>> edges_list(n), result(n);
        for(auto a: edges){
            edges_list[a[1]].push_back(a[0]);
        }

        vector<int> visited(n);

        for(int i = 0; i < n; i++){
            dfs(i, i, edges_list, visited, result);
            sort(result[i].begin(), result[i].end());
            visited = vector<int>(n);
        }
        return result;
    }
};
"
1185,cpp,all-ancestors-of-a-node-in-a-directed-acyclic-graph,"class Solution {
public:
   
    void dfs(int i,int ansc,vector<vector<int>>&ans,vector<int>&vis,vector<vector<int>>&res){
        
        vis[i]=1;
        
        for(auto t:ans[i]){
            if(!vis[t]){
                dfs(t,ansc,ans,vis,res);
            }
        }
       
        if(i!=ansc)
            res[i].push_back(ansc);
    }
    
    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {
        
        vector<vector<int>>ans(n),result(n);
        
        for(auto a:edges){
            ans[a[0]].push_back(a[1]);
        }

        vector<int>visited(n);

        for(int i=0;i<n;i++){
            dfs(i,i,ans,visited,result);
        }
      
        return result;
    }
};",None,"class Solution {
public:
  
    void dfs(int i, int ansc, vector<vector<int>>& ans, vector<int>& vis, vector<vector<int>>& res) {

        vis[i]=1;

        for(auto t: ans[i]){
            if(!vis[t]){
                dfs(t, ansc, ans, vis, res);
            }
        }

        if(i!=ansc)
            res[ansc].push_back(i);
    }

    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {

        vector<vector<int>> ans(n), result(n);

        for(auto a : edges){
            ans[a[1]].push_back(a[0]);
        }

        for(int i=0; i<n; i++){
            vector<int> visited(n, 0);
            dfs(i, i, ans, visited, result);
            sort(result[i].begin(), result[i].end());
        }

        return result;
    }
};
"
1186,cpp,find-the-winner-of-the-circular-game,"class Solution {
public:
    int findTheWinner(int n, int k) {
        queue<int> q;
        for(int i=1;i<=n;i++){
            q.push(i);
        }
        while(q.size() != 1){
            int i = 0;
            while(i < k){
                int f = q.front();
                q.pop();
                q.push(f);
                i++;
            }
            q.pop();
        }

        return q.front();
    }
};",None,"class Solution {
public:
    int findTheWinner(int n, int k) {
        queue<int> q;
        for(int i=1;i<=n;i++){
            q.push(i);
        }
        while(q.size() != 1){
            int i = 1;
            while(i < k){
                int f = q.front();
                q.pop();
                q.push(f);
                i++;
            }
            q.pop();
        }

        return q.front();
    }
};
"
1186,cpp,find-the-winner-of-the-circular-game,"class Solution {
public:
    int findTheWinner(int n, int k) {
        queue<int> q;
        for(int i=1;i<=n;i++){
            q.push(i);
        }
        while(q.size() != 1){
            int i = 0;
            while(i < k){
                int f = q.front();
                q.pop();
                q.push(f);
                i++;
            }
            q.pop();
        }

        return q.front();
    }
};",None,"class Solution {
public:
    int findTheWinner(int n, int k) {
        queue<int> q;
        for(int i=1;i<=n;i++){
            q.push(i);
        }
        while(q.size() != 1){
            int i = 1;
            while(i < k){
                int f = q.front();
                q.pop();
                q.push(f);
                i++;
            }
            q.pop();
        }

        return q.front();
    }
};
"
1186,cpp,find-the-winner-of-the-circular-game,"class Solution {
public:
    int findTheWinner(int n, int k) {
        queue<int> q;
        for(int i=1;i<=n;i++){
            q.push(i);
        }
        while(q.size() != 1){
            int i = 0;
            while(i < k){
                int f = q.front();
                q.pop();
                q.push(f);
                i++;
            }
            q.pop();
        }

        return q.front();
    }
};",None,"class Solution {
public:
    int findTheWinner(int n, int k){
        queue<int> q;
        for(int i=1; i<=n; i++){
            q.push(i);
        }
        while(q.size() != 1){
            int i = 1;
            while(i < k){
                int f = q.front();
                q.pop();
                q.push(f);
                i++;
            }
            q.pop();
        }

        return q.front();
    }
};
"
1187,cpp,longest-ideal-subsequence,"class Solution {

   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)
   {
       if(index == s.length())
       return 0;

       if(dp[index][prev] != -1)
       return dp[index][prev];

       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);

       int op2 = 0 ;

       if(prev == 26)
       op2 = 1 + SolveByMemo(s, k , index+1 , prev , dp);
       else if(abs(s[index]-'a' - prev) <= k)
       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);

       return dp[index][prev] = max(op1 , op2);
   }

   int SolveByTab(string &s , int &k )
   {
        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));
       
        for(int index = s.length()-1 ; index>=0 ; index--)
        {
            for(int prev = 0 ; prev<= 26 ; prev++)
            {
                int op1 = 0 + dp[index+1][prev];
                int op2 = 0 ;

               if(prev == 26)
               op2 = 1 + dp[index+1][prev];
               else if(abs(s[index]-'a' - prev) <= k)
               op2 = 1 + dp[index+1][s[index]-'a'];

               dp[index][prev] = max(op1 , op2);
            }
        }

       return max(dp[0][s[0]-'a'] , dp[0][26]);
   }
public:
    int longestIdealString(string s, int k) {
        

        return SolveByTab(s, k);
    }
};",None,"class Solution {
public:

    int SolveByTab(string &s , int &k )
    {
        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));
        
        for(int index = s.length()-1 ; index>=0 ; index--)
        {
            for(int prev = 0 ; prev<= 26 ; prev++)
            {
                int op1 = 0 + dp[index+1][prev];

                int op2 = 0 ;

                if(prev == 26)
                    op2 = 1 + dp[index+1][s[index]-'a'];
                else if(abs(s[index]-'a' - prev) <= k)
                    op2 = 1 + dp[index+1][s[index]-'a'];

                dp[index][prev] = max(op1 , op2);
            }
        } 

        return max(*max_element(dp[0].begin(), dp[0].end()), dp[0][26]);
    }

    int longestIdealString(string s, int k) {

        return SolveByTab(s, k);
    }
};
"
1187,cpp,longest-ideal-subsequence,"class Solution {

   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)
   {
       if(index == s.length())
       return 0;

       if(dp[index][prev] != -1)
       return dp[index][prev];

       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);

       int op2 = 0 ;

       if(prev == 26)
       op2 = 1 + SolveByMemo(s, k , index+1 , prev , dp);
       else if(abs(s[index]-'a' - prev) <= k)
       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);

       return dp[index][prev] = max(op1 , op2);
   }

   int SolveByTab(string &s , int &k )
   {
        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));
       
        for(int index = s.length()-1 ; index>=0 ; index--)
        {
            for(int prev = 0 ; prev<= 26 ; prev++)
            {
                int op1 = 0 + dp[index+1][prev];
                int op2 = 0 ;

               if(prev == 26)
               op2 = 1 + dp[index+1][prev];
               else if(abs(s[index]-'a' - prev) <= k)
               op2 = 1 + dp[index+1][s[index]-'a'];

               dp[index][prev] = max(op1 , op2);
            }
        }

       return max(dp[0][s[0]-'a'] , dp[0][26]);
   }
public:
    int longestIdealString(string s, int k) {
        

        return SolveByTab(s, k);
    }
};",None,"class Solution {

   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)
   {
       if(index == s.length())
       return 0;

       if(dp[index][prev] != -1)
       return dp[index][prev];

       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);

       int op2 = 0 ;

       if(prev == 26)
       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);
       else if(abs(s[index]-'a' - prev) <= k)
       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);

       return dp[index][prev] = max(op1 , op2);
   }

   int SolveByTab(string &s , int &k )
   {
        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));
       
        for(int index = s.length()-1 ; index>=0 ; index--)
        {
            for(int prev = 0 ; prev<= 26 ; prev++)
            {
                int op1 = 0 + dp[index+1][prev];
                int op2 = 0 ;

               if(prev == 26)
               op2 = 1 + dp[index+1][s[index]-'a'];
               else if(abs(s[index]-'a' - prev) <= k)
               op2 = 1 + dp[index+1][s[index]-'a'];

               dp[index][prev] = max(op1 , op2);
            }
        }

       return max(dp[0][s[0]-'a'] , dp[0][26]);
   }
public:
    int longestIdealString(string s, int k) {
        

        return SolveByTab(s, k);
    }
};
"
1187,cpp,longest-ideal-subsequence,"class Solution {

   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)
   {
       if(index == s.length())
       return 0;

       if(dp[index][prev] != -1)
       return dp[index][prev];

       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);

       int op2 = 0 ;

       if(prev == 26)
       op2 = 1 + SolveByMemo(s, k , index+1 , prev , dp);
       else if(abs(s[index]-'a' - prev) <= k)
       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);

       return dp[index][prev] = max(op1 , op2);
   }

   int SolveByTab(string &s , int &k )
   {
        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));
       
        for(int index = s.length()-1 ; index>=0 ; index--)
        {
            for(int prev = 0 ; prev<= 26 ; prev++)
            {
                int op1 = 0 + dp[index+1][prev];
                int op2 = 0 ;

               if(prev == 26)
               op2 = 1 + dp[index+1][prev];
               else if(abs(s[index]-'a' - prev) <= k)
               op2 = 1 + dp[index+1][s[index]-'a'];

               dp[index][prev] = max(op1 , op2);
            }
        }

       return max(dp[0][s[0]-'a'] , dp[0][26]);
   }
public:
    int longestIdealString(string s, int k) {
        

        return SolveByTab(s, k);
    }
};",None,"class Solution {

   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)
   {
       if(index == s.length())
       return 0;

       if(dp[index][prev] != -1)
       return dp[index][prev];

       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);

       int op2 = 0 ;

       if(prev == 26)
       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);
       else if(abs(s[index]-'a' - prev) <= k)
       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);

       return dp[index][prev] = max(op1 , op2);
   }

   int SolveByTab(string &s , int &k )
   {
        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));
       
        for(int index = s.length()-1 ; index>=0 ; index--)
        {
            for(int prev = 0 ; prev<= 26 ; prev++)
            {
                int op1 = 0 + dp[index+1][prev];
                int op2 = 0 ;

               if(prev == 26)
               op2 = 1 + dp[index+1][s[index]-'a'];
               else if(abs(s[index]-'a' - prev) <= k)
               op2 = 1 + dp[index+1][s[index]-'a'];

               dp[index][prev] = max(op1 , op2);
            }
        }

       return max(dp[0][s[0]-'a'] , dp[0][26]);
   }
public:
    int longestIdealString(string s, int k) {

        return SolveByTab(s, k);
    }
};
"
1188,cpp,closest-prime-numbers-in-range,"class Solution {
public:
    vector<int> closestPrimes(int left, int right) {
        if(left==1)left++;
        vector<bool> v(right+1,true);
        for(int i = 2; i <= sqrt(right); i++){
            if(v[i]){
                for(int j = i*i; j <= right; j += i){
                    v[j] = false;
                }
            }
        }
        int i = left;
        int j;
        int a = -1, b = -1, k = INT_MAX;
        while(i<= right){
            if(v[i])break;
            i++;
        }
        j = i;
        while(j<=right){
            if(v[j]){
                if(j-i<k){
                    k = j-i;
                    a = i,b = j;
                }
                    i = j;
            }
            j++;
        }
        return {a,b};
    }
};",None,"class Solution {
public:
    vector<int> closestPrimes(int left, int right) {
        if(left==1)left++;
        vector<bool> v(right+1,true);
        v[0] = false;
        v[1] = false;
        for(int i = 2; i*i <= right; i++){
            if(v[i]){
                for(int j = i*i; j <= right; j += i){
                    v[j] = false;
                }
            }
        }
        
        int prev = -1;
        int a = -1, b = -1, k = INT_MAX;
        for (int i = left; i <= right; ++i){
            if (v[i]){
                if (prev != -1 && i - prev < k){
                    a = prev;
                    b = i;
                    k = i - prev;
                }
                prev = i;
            }
        }
        if(a == -1 || b == -1)
        {
            return {-1,-1};
        }
        return {a,b};
    }
};
"
1188,cpp,closest-prime-numbers-in-range,"class Solution {
public:
    vector<int> closestPrimes(int left, int right) {
        if(left==1)left++;
        vector<bool> v(right+1,true);
        for(int i = 2; i <= sqrt(right); i++){
            if(v[i]){
                for(int j = i*i; j <= right; j += i){
                    v[j] = false;
                }
            }
        }
        int i = left;
        int j;
        int a = -1, b = -1, k = INT_MAX;
        while(i<= right){
            if(v[i])break;
            i++;
        }
        j = i;
        while(j<=right){
            if(v[j]){
                if(j-i<k){
                    k = j-i;
                    a = i,b = j;
                }
                    i = j;
            }
            j++;
        }
        return {a,b};
    }
};",None,"class Solution {
public:
    vector<int> closestPrimes(int left, int right) {
        if(left==1)left++;
        vector<bool> v(right+1,true);
        for(int i = 2; i <= sqrt(right); i++){
            if(v[i]){
                for(int j = i*i; j <= right; j += i){
                    v[j] = false;
                }
            }
        }
        int i = left;
        int j;
        int a = -1, b = -1, k = INT_MAX;
        while(i<= right){
            if(v[i])break;
            i++;
        }
        j = i+1;
        while(j<=right){
            if(v[j]){
                if(j-i<k){
                    k = j-i;
                    a = i,b = j;
                }
                i = j;
            }
            j++;
        }
        if(a==-1 || b==-1)
            return {-1,-1};
        else
            return {a,b};
    }
};
"
1188,cpp,closest-prime-numbers-in-range,"class Solution {
public:
    vector<int> closestPrimes(int left, int right) {
        if(left==1)left++;
        vector<bool> v(right+1,true);
        for(int i = 2; i <= sqrt(right); i++){
            if(v[i]){
                for(int j = i*i; j <= right; j += i){
                    v[j] = false;
                }
            }
        }
        int i = left;
        int j;
        int a = -1, b = -1, k = INT_MAX;
        while(i<= right){
            if(v[i])break;
            i++;
        }
        j = i;
        while(j<=right){
            if(v[j]){
                if(j-i<k){
                    k = j-i;
                    a = i,b = j;
                }
                    i = j;
            }
            j++;
        }
        return {a,b};
    }
};",None,"class Solution {
public:
    vector<int> closestPrimes(int left, int right) {
        if(left==1)left++;
        vector<bool> v(right+1,true);
        for(int i = 2; i <= sqrt(right); i++){
            if(v[i]){
                for(int j = i*i; j <= right; j += i){
                    v[j] = false;
                }
            }
        }
        int i = left;
        int j;
        int a = -1, b = -1, k = INT_MAX;
        while(i<= right){
            if(v[i])break;
            i++;
        }
        j = i+1;
        while(j<=right){
            if(v[j]){
                if(j-i<k){
                    k = j-i;
                    a = i,b = j;
                }
                    i = j;
            }
            j++;
        }
        if(a==-1 || b==-1)
            return {-1, -1};
        return {a,b};
    }
};
"
1189,cpp,design-twitter,"class Twitter {
    int timer = INT_MAX;
    map<int, map<int, bool>> friends;
    map<int, pair<int, int>> tweets;

public:
    Twitter() {
    }
    
    void postTweet(int userId, int tweetId) {
        tweets[timer--] = {userId, tweetId};
    }
    
    vector<int> getNewsFeed(int userId) {
        vector<int> ans;
        for(auto it: tweets){
            if(it.second.first == userId || friends[userId].find(it.second.first)!=friends[userId].end())
                ans.push_back(it.second.second);
            if(ans.size() == 10) break;
        }
        return ans;
    }
    
    void follow(int followerId, int followeeId) {
        friends[followerId][followerId] = true;
    }
    
    void unfollow(int followerId, int followeeId) {
        friends[followerId].erase(followeeId);
    }
};",None,M
1189,cpp,design-twitter,"class Twitter {
    int timer = INT_MAX;
    map<int, map<int, bool>> friends;
    map<int, pair<int, int>> tweets;

public:
    Twitter() {
    }
    
    void postTweet(int userId, int tweetId) {
        tweets[timer--] = {userId, tweetId};
    }
    
    vector<int> getNewsFeed(int userId) {
        vector<int> ans;
        for(auto it: tweets){
            if(it.second.first == userId || friends[userId].find(it.second.first)!=friends[userId].end())
                ans.push_back(it.second.second);
            if(ans.size() == 10) break;
        }
        return ans;
    }
    
    void follow(int followerId, int followeeId) {
        friends[followerId][followerId] = true;
    }
    
    void unfollow(int followerId, int followeeId) {
        friends[followerId].erase(followeeId);
    }
};",None,"class Twitter {
    int timer = INT_MAX;
    map<int, map<int, bool>> friends;
    map<int, pair<int, int>> tweets;

public:
    Twitter() {
    }
    
    void postTweet(int userId, int tweetId) {
        tweets[timer--] = {userId, tweetId};
    }
    
    vector<int> getNewsFeed(int userId) {
        vector<int> ans;
        for(auto it: tweets){
            if(it.second.first == userId || friends[userId].find(it.second.first) != friends[userId].end())
                ans.push_back(it.second.second);
            if(ans.size() == 10) break;
        }
        return ans;
    }
    
    void follow(int followerId, int followeeId) {
        if(followerId != followeeId){
            friends[followerId][followeeId] = true;
        }
    }
    
    void unfollow(int followerId, int followeeId) {
        friends[followerId].erase(followeeId);
    }
};
"
1189,cpp,design-twitter,"class Twitter {
    int timer = INT_MAX;
    map<int, map<int, bool>> friends;
    map<int, pair<int, int>> tweets;

public:
    Twitter() {
    }
    
    void postTweet(int userId, int tweetId) {
        tweets[timer--] = {userId, tweetId};
    }
    
    vector<int> getNewsFeed(int userId) {
        vector<int> ans;
        for(auto it: tweets){
            if(it.second.first == userId || friends[userId].find(it.second.first)!=friends[userId].end())
                ans.push_back(it.second.second);
            if(ans.size() == 10) break;
        }
        return ans;
    }
    
    void follow(int followerId, int followeeId) {
        friends[followerId][followerId] = true;
    }
    
    void unfollow(int followerId, int followeeId) {
        friends[followerId].erase(followeeId);
    }
};",None,"class Twitter {
    int timer = INT_MAX;
    map<int, map<int, bool>> friends;
    map<int, pair<int, int>> tweets;

public:
    Twitter() {
    }
    
    void postTweet(int userId, int tweetId) {
        tweets[timer--] = {userId, tweetId};
    }
    
    vector<int> getNewsFeed(int userId) {
        vector<int> ans;
        for(auto it: tweets){
            if(it.second.first == userId || friends[userId].find(it.second.first)!=friends[userId].end())
                ans.push_back(it.second.second);
            if(ans.size() == 10) break;
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }
    
    void follow(int followerId, int followeeId) {
        friends[followerId][followeeId] = true;
    }
    
    void unfollow(int followerId, int followeeId) {
        friends[followerId].erase(followeeId);
    }
};
"
1190,cpp,count-all-possible-routes,"class Solution {
    private:
    int mod = 7+1e9;
public:
    int countRoutes(vector<int>& locations, int start, int finish, int fuel) {
        vector<vector<int>>dp(locations.size()+1, vector<int>(fuel+1, -1));
        return solve(locations, start, finish, fuel, dp);
    }

    int solve(vector<int>& locations, int current, int& finish, int currentfuel, vector<vector<int>>& dp)
    {
        int ans = 0;
        if(current == finish)
        {
            ans = 1;
        }
        if(currentfuel == 0)
        {
            return ans;
        }
        if(dp[current][currentfuel] != -1)
        {
            return dp[finish][currentfuel];
        }
        for(int i = 0;i < locations.size(); i++)
        {
            if(i != current && (currentfuel - abs(locations[current]-locations[i])) >= 0)
            {
                ans = (ans + (solve(locations, i, finish, currentfuel-abs(locations[current]-locations[i]), dp))%mod)%mod;
            }
        }
        return dp[current][currentfuel] = ans%mod;
    }
};",None,"class Solution {
    private:
    int mod = 1e9+7;
public:
    int countRoutes(vector<int>& locations, int start, int finish, int fuel) {
        vector<vector<int>>dp(locations.size()+1, vector<int>(fuel+1, -1));
        return solve(locations, start, finish, fuel, dp);
    }

    int solve(vector<int>& locations, int current, int& finish, int currentfuel, vector<vector<int>>& dp)
    {
        int ans = 0;
        if(current == finish)
        {
            ans = 1;
        }
        if(currentfuel == 0)
        {
            return ans;
        }
        if(dp[current][currentfuel] != -1)
        {
            return dp[current][currentfuel];
        }
        for(int i = 0;i < locations.size(); i++)
        {
            if(i != current && (currentfuel - abs(locations[current]-locations[i])) >= 0)
            {
                ans = (ans + (solve(locations, i, finish, currentfuel-abs(locations[current]-locations[i]), dp))%mod)%mod;
            }
        }
        return dp[current][currentfuel] = ans%mod;
    }
};
"
1190,cpp,count-all-possible-routes,"class Solution {
    private:
    int mod = 7+1e9;
public:
    int countRoutes(vector<int>& locations, int start, int finish, int fuel) {
        vector<vector<int>>dp(locations.size()+1, vector<int>(fuel+1, -1));
        return solve(locations, start, finish, fuel, dp);
    }

    int solve(vector<int>& locations, int current, int& finish, int currentfuel, vector<vector<int>>& dp)
    {
        int ans = 0;
        if(current == finish)
        {
            ans = 1;
        }
        if(currentfuel == 0)
        {
            return ans;
        }
        if(dp[current][currentfuel] != -1)
        {
            return dp[finish][currentfuel];
        }
        for(int i = 0;i < locations.size(); i++)
        {
            if(i != current && (currentfuel - abs(locations[current]-locations[i])) >= 0)
            {
                ans = (ans + (solve(locations, i, finish, currentfuel-abs(locations[current]-locations[i]), dp))%mod)%mod;
            }
        }
        return dp[current][currentfuel] = ans%mod;
    }
};",None,"class Solution {
    private:
    int mod = 1e9+7;
public:
    int countRoutes(vector<int>& locations, int start, int finish, int fuel) {
        vector<vector<int>>dp(locations.size()+1, vector<int>(fuel+1, -1));
        return solve(locations, start, finish, fuel, dp);
    }

    int solve(vector<int>& locations, int current, int& finish, int currentfuel, vector<vector<int>>& dp)
    {
        int ans = 0;
        if(current == finish)
        {
            ans = 1;
        }
        if(currentfuel == 0)
        {
            return ans;
        }
        if(dp[current][currentfuel] != -1)
        {
            return dp[current][currentfuel];
        }
        for(int i = 0;i < locations.size(); i++)
        {
            if(i != current && (currentfuel - abs(locations[current]-locations[i])) >= 0)
            {
                ans = (ans + (solve(locations, i, finish, currentfuel-abs(locations[current]-locations[i]), dp))%mod)%mod;
            }
        }
        return dp[current][currentfuel] = ans;
    }
};
"
1190,cpp,count-all-possible-routes,"class Solution {
    private:
    int mod = 7+1e9;
public:
    int countRoutes(vector<int>& locations, int start, int finish, int fuel) {
        vector<vector<int>>dp(locations.size()+1, vector<int>(fuel+1, -1));
        return solve(locations, start, finish, fuel, dp);
    }

    int solve(vector<int>& locations, int current, int& finish, int currentfuel, vector<vector<int>>& dp)
    {
        int ans = 0;
        if(current == finish)
        {
            ans = 1;
        }
        if(currentfuel == 0)
        {
            return ans;
        }
        if(dp[current][currentfuel] != -1)
        {
            return dp[finish][currentfuel];
        }
        for(int i = 0;i < locations.size(); i++)
        {
            if(i != current && (currentfuel - abs(locations[current]-locations[i])) >= 0)
            {
                ans = (ans + (solve(locations, i, finish, currentfuel-abs(locations[current]-locations[i]), dp))%mod)%mod;
            }
        }
        return dp[current][currentfuel] = ans%mod;
    }
};",None,"class Solution {
    private:
    int mod = 1e9 + 7;
public:
    int countRoutes(vector<int>& locations, int start, int finish, int fuel) {
        vector<vector<int>>dp(locations.size()+1, vector<int>(fuel+1, -1));
        return solve(locations, start, finish, fuel, dp);
    }

    int solve(vector<int>& locations, int current, int& finish, int currentfuel, vector<vector<int>>& dp)
    {
        int ans = 0;
        if(current == finish)
        {
            ans = 1;
        }
        if(currentfuel == 0)
        {
            return ans;
        }
        if(dp[current][currentfuel] != -1)
        {
            return dp[current][currentfuel];
        }
        for(int i = 0;i < locations.size(); i++)
        {
            if(i != current && (currentfuel - abs(locations[current]-locations[i])) >= 0)
            {
                ans = (ans + (solve(locations, i, finish, currentfuel-abs(locations[current]-locations[i]), dp)) % mod) % mod;
            }
        }
        return dp[current][currentfuel] = ans;
    }
};
"
1191,cpp,find-the-array-concatenation-value,"class Solution {
public:
    long long findTheArrayConcVal(vector<int>& nums) {
        int i = 0,j=nums.size()-1,x,y;
        long long int ans=0;
        while(i<j){
            x = nums[i];
            y = 0;
            while(x){
                y++;
                x /= 10;
            }
            ans += (nums[i]*1LL*pow(10,y)+nums[j]);
            i++;
            j--;
        }
        if(i==j){
            ans += nums[i];
        }
        return ans;
    }
};",None,"class Solution {
public:
    long long findTheArrayConcVal(vector<int>& nums) {
        int i = 0,j=nums.size()-1,x,y;
        long long int ans=0;
        while(i<j){
            x = nums[j];
            y = 0;
            while(x){
                y++;
                x /= 10;
            }
            ans += (nums[i]*1LL*pow(10,y)+nums[j]);
            i++;
            j--;
        }
        if(i==j){
            ans += nums[i];
        }
        return ans;
    }
};
"
1191,cpp,find-the-array-concatenation-value,"class Solution {
public:
    long long findTheArrayConcVal(vector<int>& nums) {
        int i = 0,j=nums.size()-1,x,y;
        long long int ans=0;
        while(i<j){
            x = nums[i];
            y = 0;
            while(x){
                y++;
                x /= 10;
            }
            ans += (nums[i]*1LL*pow(10,y)+nums[j]);
            i++;
            j--;
        }
        if(i==j){
            ans += nums[i];
        }
        return ans;
    }
};",None,"class Solution {
public:
    long long findTheArrayConcVal(vector<int>& nums) {
        int i = 0,j=nums.size()-1,x,y;
        long long int ans=0;
        while(i<j){
            x = nums[j];
            y = 0;
            while(x){
                y++;
                x /= 10;
            }
            ans += (nums[i]*1LL*pow(10,y)+nums[j]);
            i++;
            j--;
        }
        if(i==j){
            ans += nums[i];
        }
        return ans;
    }
};
"
1191,cpp,find-the-array-concatenation-value,"class Solution {
public:
    long long findTheArrayConcVal(vector<int>& nums) {
        int i = 0,j=nums.size()-1,x,y;
        long long int ans=0;
        while(i<j){
            x = nums[i];
            y = 0;
            while(x){
                y++;
                x /= 10;
            }
            ans += (nums[i]*1LL*pow(10,y)+nums[j]);
            i++;
            j--;
        }
        if(i==j){
            ans += nums[i];
        }
        return ans;
    }
};",None,"class Solution {
public:
    long long findTheArrayConcVal(vector<int>& nums) {
        int i = 0,j=nums.size()-1,x,y;
        long long int ans=0;
        while(i<j){
            x = nums[j];
            y = 0;
            while(x){
                y++;
                x /= 10;
            }
            ans += (nums[i]*1LL*pow(10,y)+nums[j]);
            i++;
            j--;
        }
        if(i==j){
            ans += nums[i];
        }
        return ans;
    }
};
"
1192,cpp,count-good-numbers,"class Solution {
public:
    int mod=1e9+7;
    int binExpo(long long x,long long n){
        int ans=1;
        while(n){
            if(n&1){
                ans=(ans*x)%mod;
            }
            x=(x*x)%mod;
            n=1;
        }
        return ans;
    }
    int countGoodNumbers(long long n) {
        long long even=n/2+n%2,odd=n/2;
        int even_val=binExpo(5,even);
        int odd_val=binExpo(4,odd);
        return (1ll*even_val*odd_val)%mod;
    }
};",None,"class Solution {
public:
    int mod=1e9+7;
    long long binExpo(long long x,long long n){
        long long ans=1;
        while(n){
            if(n&1){
                ans=(ans*x)%mod;
            }
            x=(x*x)%mod;
            n>>=1;
        }
        return ans;
    }
    int countGoodNumbers(long long n) {
        long long even=n/2+n%2,odd=n/2;
        long long even_val=binExpo(5,even);
        long long odd_val=binExpo(4,odd);
        return (1ll*even_val*odd_val)%mod;
    }
};
"
1192,cpp,count-good-numbers,"class Solution {
public:
    int mod=1e9+7;
    int binExpo(long long x,long long n){
        int ans=1;
        while(n){
            if(n&1){
                ans=(ans*x)%mod;
            }
            x=(x*x)%mod;
            n=1;
        }
        return ans;
    }
    int countGoodNumbers(long long n) {
        long long even=n/2+n%2,odd=n/2;
        int even_val=binExpo(5,even);
        int odd_val=binExpo(4,odd);
        return (1ll*even_val*odd_val)%mod;
    }
};",None,"class Solution {
public:
    int mod=1e9+7;
    long long binExpo(long long x,long long n){
        long long ans=1;
        while(n){
            if(n&1){
                ans=(ans*x)%mod;
            }
            x=(x*x)%mod;
            n>>=1;
        }
        return ans;
    }
    int countGoodNumbers(long long n) {
        long long even=n/2+n%2,odd=n/2;
        long long even_val=binExpo(5,even);
        long long odd_val=binExpo(4,odd);
        return (1ll*even_val*odd_val)%mod;
    }
};
"
1192,cpp,count-good-numbers,"class Solution {
public:
    int mod=1e9+7;
    int binExpo(long long x,long long n){
        int ans=1;
        while(n){
            if(n&1){
                ans=(ans*x)%mod;
            }
            x=(x*x)%mod;
            n=1;
        }
        return ans;
    }
    int countGoodNumbers(long long n) {
        long long even=n/2+n%2,odd=n/2;
        int even_val=binExpo(5,even);
        int odd_val=binExpo(4,odd);
        return (1ll*even_val*odd_val)%mod;
    }
};",None,"class Solution {
public:
    int mod=1e9+7;
    long long binExpo(long long x,long long n){
        long long ans=1;
        while(n){
            if(n&1){
                ans=(ans*x)%mod;
            }
            x=(x*x)%mod;
            n>>=1;
        }
        return ans;
    }
    int countGoodNumbers(long long n) {
        long long even=n/2+n%2,odd=n/2;
        long long even_val=binExpo(5,even);
        long long odd_val=binExpo(4,odd);
        return (even_val*odd_val)%mod;
    }
};
"
1193,cpp,number-of-subarrays-with-gcd-equal-to-k,"class Solution {
public:
    int subarrayGCD(vector<int>& nums, int k) {
        
        int result = 0;
        
        int n = nums.size();
        
        for (int l = 0; l < n; l++)
        {
            int current_gcd = nums[l];
            for (int r = l; r < n; r++)
            {
                /* 
                We update our current_gcd value in the inner loop. 
                If we somehow reach to k at some point, we'll draw an arrow from our left anchor to the that point. 
                If we found a subarray that has elements with gcd k, increment result.
                We repeat that steps for each left anchor.
                */ 
                current_gcd = gcd(nums[l], nums[r]); 
                if (current_gcd == k)
                    result++;
            }
        }
        return result;
    }
};",None,"class Solution {
public:
    int gcd(int a, int b) {
        if(b == 0)
            return a;
        return gcd(b, a % b);
    }
    
    int subarrayGCD(vector<int>& nums, int k) {
        
        int result = 0;
        
        int n = nums.size();
        
        for (int l = 0; l < n; l++)
        {
            int current_gcd = nums[l];
            for (int r = l; r < n; r++)
            {
                /* 
                We update our current_gcd value in the inner loop. 
                If we somehow reach to k at some point, we'll draw an arrow from our left anchor to the that point. 
                If we found a subarray that has elements with gcd k, increment result.
                We repeat that steps for each left anchor.
                */ 
                current_gcd = gcd(current_gcd, nums[r]); 
                if (current_gcd == k)
                    result++;
            }
        }
        return result;
    }
};
"
1193,cpp,number-of-subarrays-with-gcd-equal-to-k,"class Solution {
public:
    int subarrayGCD(vector<int>& nums, int k) {
        
        int result = 0;
        
        int n = nums.size();
        
        for (int l = 0; l < n; l++)
        {
            int current_gcd = nums[l];
            for (int r = l; r < n; r++)
            {
                /* 
                We update our current_gcd value in the inner loop. 
                If we somehow reach to k at some point, we'll draw an arrow from our left anchor to the that point. 
                If we found a subarray that has elements with gcd k, increment result.
                We repeat that steps for each left anchor.
                */ 
                current_gcd = gcd(nums[l], nums[r]); 
                if (current_gcd == k)
                    result++;
            }
        }
        return result;
    }
};",None,"class Solution {
public:
    int subarrayGCD(vector<int>& nums, int k) {
        
        int result = 0;
        
        int n = nums.size();
        
        for (int l = 0; l < n; l++)
        {
            int current_gcd = nums[l];
            for (int r = l; r < n; r++)
            {
                /*
                We update our current_gcd value in the inner loop. 
                If we somehow reach to k at some point, we'll draw an arrow from our left anchor to that point. 
                If we found a subarray that has elements with gcd k, increment result.
                We repeat that steps for each left anchor.
                */
                current_gcd = gcd(current_gcd, nums[r]);
                if (current_gcd == k)
                    result++;
            }
        }
        return result;
    }
    
    int gcd(int a, int b) {
        if (b == 0)
            return a;
        return gcd(b, a % b);
    }
};
"
1193,cpp,number-of-subarrays-with-gcd-equal-to-k,"class Solution {
public:
    int subarrayGCD(vector<int>& nums, int k) {
        
        int result = 0;
        
        int n = nums.size();
        
        for (int l = 0; l < n; l++)
        {
            int current_gcd = nums[l];
            for (int r = l; r < n; r++)
            {
                /* 
                We update our current_gcd value in the inner loop. 
                If we somehow reach to k at some point, we'll draw an arrow from our left anchor to the that point. 
                If we found a subarray that has elements with gcd k, increment result.
                We repeat that steps for each left anchor.
                */ 
                current_gcd = gcd(nums[l], nums[r]); 
                if (current_gcd == k)
                    result++;
            }
        }
        return result;
    }
};",None,"class Solution {
public:
    int gcd(int a, int b) {
        if (b == 0)
            return a;
        return gcd(b, a % b);
    }

    int subarrayGCD(vector<int>& nums, int k) {
        int result = 0;
        int n = nums.size();

        for (int l = 0; l < n; l++)
        {
            int current_gcd = nums[l];
            for (int r = l; r < n; r++)
            {
                current_gcd = gcd(current_gcd, nums[r]); 
                if (current_gcd == k)
                    result++;
            }
        }
        return result;
    }
};
"
1194,cpp,special-array-with-x-elements-greater-than-or-equal-x,"class Solution {
public:
    int specialArray(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(),nums.end(),greater<int>());
        for(int i=1;i<=n;i++){
            int cnt=n;
            for(int j=0;j<n;j++){
                if(nums[j]>=i){
                    cnt++;
                }
            }
            if(cnt==i){
                return i;
            }
        }
        return -1;
    }
};",None,"class Solution {
public:
    int specialArray(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(),nums.end(),greater<int>());
        for(int i=1; i<=n; i++){
            int cnt=0;
            for(int j=0; j<n; j++){
                if(nums[j]>=i){
                    cnt++;
                }
            }
            if(cnt==i){
                return i;
            }
        }
        return -1;
    }
};
"
1194,cpp,special-array-with-x-elements-greater-than-or-equal-x,"class Solution {
public:
    int specialArray(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(),nums.end(),greater<int>());
        for(int i=1;i<=n;i++){
            int cnt=n;
            for(int j=0;j<n;j++){
                if(nums[j]>=i){
                    cnt++;
                }
            }
            if(cnt==i){
                return i;
            }
        }
        return -1;
    }
};",None,"class Solution {
public:
    int specialArray(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(),nums.end(),greater<int>());
        for(int i=1;i<=n;i++){
            int cnt=0;
            for(int j=0;j<n;j++){
                if(nums[j]>=i){
                    cnt++;
                }
            }
            if(cnt==i){
                return i;
            }
        }
        return -1;
    }
};
"
1194,cpp,special-array-with-x-elements-greater-than-or-equal-x,"class Solution {
public:
    int specialArray(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(),nums.end(),greater<int>());
        for(int i=1;i<=n;i++){
            int cnt=n;
            for(int j=0;j<n;j++){
                if(nums[j]>=i){
                    cnt++;
                }
            }
            if(cnt==i){
                return i;
            }
        }
        return -1;
    }
};",None,"class Solution {
public:
    int specialArray(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(), nums.end(), greater<int>());
        for(int i = 1; i <= n; i++){
            int cnt = 0;
            for(int j = 0; j < n; j++){
                if(nums[j] >= i){
                    cnt++;
                }
            }
            if(cnt == i){
                return i;
            }
        }
        return -1;
    }
};
"
1195,cpp,total-appeal-of-a-string,"class Solution {
public:
    long long appealSum(string s) {
        long long int x = 1, y = 1, k = 0;
        vector<int> v(26,-1);

        v[s[0]-'a'] = 1; 
        for(int i = 1; i < s.length(); i++){
            x += i+1;
            if(v[s[i]-'a'] > 0){
                x -= v[s[i]-'a'];
            }
            y += x;
            v[s[i]-'a'] = 0;
        }
        return y;
    }
};",None,"class Solution {
public:
    long long appealSum(string s) {
        long long int x = 1, y = 1, k = 0;
        vector<int> v(26,-1);

        v[s[0]-'a'] = 0; 
        for(int i = 1; i < s.length(); i++){
            x += i+1;
            if(v[s[i]-'a'] != -1){
                x -= v[s[i]-'a'];
            }
            y += x;
            v[s[i]-'a'] = i+1;
        }
        return y;
    }
};
"
1195,cpp,total-appeal-of-a-string,"class Solution {
public:
    long long appealSum(string s) {
        long long int x = 1, y = 1, k = 0;
        vector<int> v(26,-1);

        v[s[0]-'a'] = 1; 
        for(int i = 1; i < s.length(); i++){
            x += i+1;
            if(v[s[i]-'a'] > 0){
                x -= v[s[i]-'a'];
            }
            y += x;
            v[s[i]-'a'] = 0;
        }
        return y;
    }
};",None,M
1195,cpp,total-appeal-of-a-string,"class Solution {
public:
    long long appealSum(string s) {
        long long int x = 1, y = 1, k = 0;
        vector<int> v(26,-1);

        v[s[0]-'a'] = 1; 
        for(int i = 1; i < s.length(); i++){
            x += i+1;
            if(v[s[i]-'a'] > 0){
                x -= v[s[i]-'a'];
            }
            y += x;
            v[s[i]-'a'] = 0;
        }
        return y;
    }
};",None,"class Solution {
public:
    long long appealSum(string s) {
        long long int x = 1, y = 1, k = 0;
        vector<int> v(26,-1);

        v[s[0]-'a'] = 1; 
        for(int i = 1; i < s.length(); i++){
            x += i+1;
            if(v[s[i]-'a'] > 0){
                x -= v[s[i]-'a'];
            }
            y += x;
            v[s[i]-'a'] = i + 1;
        }
        return y;
    }
};
"
1196,cpp,destination-city,"class Solution {
public:
    string destCity(vector<vector<string>>& paths) {
        unordered_set<string> st;
        for (auto row : paths)st.insert(row[0]); 
        for (auto row : paths)if(st.count(row[0]) > 0) st.erase(row[0]);
        return *st.begin();
    }
};",None,"class Solution {
public:
    string destCity(vector<vector<string>>& paths) {
        unordered_set<string> st;
        for (auto row : paths)st.insert(row[0]); 
        for (auto row : paths)if(st.count(row[1]) > 0) st.erase(row[1]);
        return *st.begin();
    }
};
"
1196,cpp,destination-city,"class Solution {
public:
    string destCity(vector<vector<string>>& paths) {
        unordered_set<string> st;
        for (auto row : paths)st.insert(row[0]); 
        for (auto row : paths)if(st.count(row[0]) > 0) st.erase(row[0]);
        return *st.begin();
    }
};",None,"class Solution {
public:
    string destCity(vector<vector<string>>& paths) {
        unordered_set<string> st;
        for(auto row : paths){
            st.insert(row[0]);
            st.erase(row[1]);
        }
        for(auto row : paths){
            if(st.count(row[1]) > 0) st.erase(row[1]);
        }
        return *st.begin();
    }
};
"
1196,cpp,destination-city,"class Solution {
public:
    string destCity(vector<vector<string>>& paths) {
        unordered_set<string> st;
        for (auto row : paths)st.insert(row[0]); 
        for (auto row : paths)if(st.count(row[0]) > 0) st.erase(row[0]);
        return *st.begin();
    }
};",None,"class Solution {
public:
    string destCity(vector<vector<string>>& paths) {
        unordered_set<string> st;
        for (auto row : paths)st.insert(row[0]);
        for (auto row : paths)if(st.count(row[1]) > 0) st.erase(row[1]);
        return *st.begin();
    }
};
"
1197,cpp,reduction-operations-to-make-the-array-elements-equal,"class Solution {
public:
    int reductionOperations(vector<int>& nums) {
        int ans = 0;
        map<int,int> mp;
        for(auto &i: nums){
            mp[i]++;
        }
        auto it = mp.begin();
        while(mp.begin() != --it){
            auto x = it;
            --x;
            ans += it->second;
            x->second += it->second;
        }
        return ans;
    }
};",None,"class Solution {
public:
    int reductionOperations(vector<int>& nums) {
        int ans = 0;
        map<int,int> mp;
        for(auto &i: nums){
            mp[i]++;
        }
        auto it = mp.end();
        --it; // start from the second largest value
        while(mp.begin() != it){
            auto x = it;
            --x;
            ans += it->second;
            x->second += it->second;
            it = x;
        }
        return ans;
    }
};
"
1197,cpp,reduction-operations-to-make-the-array-elements-equal,"class Solution {
public:
    int reductionOperations(vector<int>& nums) {
        int ans = 0;
        map<int,int> mp;
        for(auto &i: nums){
            mp[i]++;
        }
        auto it = mp.begin();
        while(mp.begin() != --it){
            auto x = it;
            --x;
            ans += it->second;
            x->second += it->second;
        }
        return ans;
    }
};",None,"class Solution {
public:
    int reductionOperations(vector<int>& nums) {
        int ans = 0;
        map<int,int> mp;
        for(auto &i: nums){
            mp[i]++;
        }
        auto it = mp.rbegin();
        it++;
        while(it != mp.rend()){
            auto x = it;
            --x;
            ans += it->second;
            x->second += it->second;
            it++;
        }
        return ans;
    }
};
"
1197,cpp,reduction-operations-to-make-the-array-elements-equal,"class Solution {
public:
    int reductionOperations(vector<int>& nums) {
        int ans = 0;
        map<int,int> mp;
        for(auto &i: nums){
            mp[i]++;
        }
        auto it = mp.begin();
        while(mp.begin() != --it){
            auto x = it;
            --x;
            ans += it->second;
            x->second += it->second;
        }
        return ans;
    }
};",None,"class Solution {
public:
    int reductionOperations(vector<int>& nums) {
        int ans = 0;
        map<int,int> mp;
        for(auto &i: nums){
            mp[i]++;
        }
        auto it = mp.rbegin();
        ++it;
        while(it != mp.rend()){
            auto x = it;
            --x;
            ans += x->second;
            it->second += x->second;
            ++it;
        }
        return ans;
    }
};
"
1198,cpp,greatest-common-divisor-of-strings,"class Solution {
public:
    string gcdOfStrings(string str1, string str2) {

        if(str1+str2==str2+str1)
        {
            return str1.substr(0,gcd(str1.length(),str2.length()));
        }
        else{
            return "" "";
        }
        
    }
};",None,"class Solution {
public:
    string gcdOfStrings(string str1, string str2) {

        if(str1+str2==str2+str1)
        {
            return str1.substr(0,gcd(str1.length(),str2.length()));
        }
        else{
            return """";
        }
        
    }
    int gcd(int a, int b) {
        if (b == 0) {
            return a;
        } 
        else {
            return gcd(b, a % b);
        }
     }
};
"
1198,cpp,greatest-common-divisor-of-strings,"class Solution {
public:
    string gcdOfStrings(string str1, string str2) {

        if(str1+str2==str2+str1)
        {
            return str1.substr(0,gcd(str1.length(),str2.length()));
        }
        else{
            return "" "";
        }
        
    }
};",None,"class Solution {
public:
    string gcdOfStrings(string str1, string str2) {

        if(str1+str2 != str2+str1) {
            return """";
        }
        else {
            return str1.substr(0,gcd(str1.length(),str2.length()));
        }
        
    }
    
    int gcd(int a, int b) {
        if(b == 0) {
            return a;
        }
        else {
            return gcd(b, a % b);
        }
    }
};
"
1198,cpp,greatest-common-divisor-of-strings,"class Solution {
public:
    string gcdOfStrings(string str1, string str2) {

        if(str1+str2==str2+str1)
        {
            return str1.substr(0,gcd(str1.length(),str2.length()));
        }
        else{
            return "" "";
        }
        
    }
};",None,"class Solution {
public:
    string gcdOfStrings(string str1, string str2) {

        if(str1+str2 != str2+str1)
        {
            return """";
        }
        else{
            return str1.substr(0,gcd(str1.length(),str2.length()));
        }
        
    }

private:
    int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
};
"
1438,java,relative-sort-array,"import java.util.Arrays;

class Solution {
    public int[] relativeSortArray(int[] arr1, int[] arr2) {
        Arrays.sort(arr1);
        int[] ans = new int[arr1.length];
        int start = 0;
        int end = arr1.length - 1;
        int index = 0;

        for (int i = 0; i < arr2.length; i++) {
            int target = arr2[i];
            start = 0;
            end = arr1.length - 1;

            while (end >= start) {
                int mid = start + (end - start) / 2;
                if (arr1[mid] == target) {
                    for (int j = start; j <= end; j++) {
                        if (arr1[j] == target) {
                            ans[index++] = arr1[j];
                            arr1[j] = -1;
                        }
                    }
                    break;
                }
                if (arr1[mid] < target) {
                    start = mid + 1;
                } else {
                    end = mid - 1;
                }
            }
        }

        Arrays.sort(arr1);

        for (int i = 0; i < arr1.length; i++) {
            if (index == arr1.length) {
                break;
            }
            boolean found = false;
            for (int num : arr2) {
                if (arr1[i] == num) {
                    found = true;
                    break;
                }
            }
            if (!found && arr1[i] != -1) {
                ans[index++] = arr1[i];
            }
        }

        return ans;
    }
}",None,"import java.util.Arrays;

class Solution {
    public int[] relativeSortArray(int[] arr1, int[] arr2) {
        int[] ans = new int[arr1.length];
        int index = 0;

        for (int i = 0; i < arr2.length; i++) {
            for (int j = 0; j < arr1.length; j++) {
                if (arr1[j] == arr2[i]) {
                    ans[index++] = arr1[j];
                    arr1[j] = -1;
                }
            }
        }

        Arrays.sort(arr1);
        
        for (int i = 0; i < arr1.length; i++) {
            if (arr1[i] != -1) {
                ans[index++] = arr1[i];
            }
        }

        return ans;
    }
}
"
1438,java,relative-sort-array,"import java.util.Arrays;

class Solution {
    public int[] relativeSortArray(int[] arr1, int[] arr2) {
        Arrays.sort(arr1);
        int[] ans = new int[arr1.length];
        int start = 0;
        int end = arr1.length - 1;
        int index = 0;

        for (int i = 0; i < arr2.length; i++) {
            int target = arr2[i];
            start = 0;
            end = arr1.length - 1;

            while (end >= start) {
                int mid = start + (end - start) / 2;
                if (arr1[mid] == target) {
                    for (int j = start; j <= end; j++) {
                        if (arr1[j] == target) {
                            ans[index++] = arr1[j];
                            arr1[j] = -1;
                        }
                    }
                    break;
                }
                if (arr1[mid] < target) {
                    start = mid + 1;
                } else {
                    end = mid - 1;
                }
            }
        }

        Arrays.sort(arr1);

        for (int i = 0; i < arr1.length; i++) {
            if (index == arr1.length) {
                break;
            }
            boolean found = false;
            for (int num : arr2) {
                if (arr1[i] == num) {
                    found = true;
                    break;
                }
            }
            if (!found && arr1[i] != -1) {
                ans[index++] = arr1[i];
            }
        }

        return ans;
    }
}",None,"import java.util.Arrays;
import java.util.HashMap;

class Solution {
    public int[] relativeSortArray(int[] arr1, int[] arr2) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for(int i = 0; i < arr1.length; i++) {
            map.put(arr1[i], map.getOrDefault(arr1[i], 0) + 1);
        }
        
        int i = 0;
        for(int num: arr2) {
            for(int count = 0; count < map.get(num); count++) {
                arr1[i++] = num;
            }
            map.remove(num);
        }

        int start = i; 
        for(int num: map.keySet()) {
            for(int count = 0; count < map.get(num); count++) {
                arr1[i++] = num;
            }
        }

        Arrays.sort(arr1, start, arr1.length);
        
        return arr1;
    }
}
"
1438,java,relative-sort-array,"import java.util.Arrays;

class Solution {
    public int[] relativeSortArray(int[] arr1, int[] arr2) {
        Arrays.sort(arr1);
        int[] ans = new int[arr1.length];
        int start = 0;
        int end = arr1.length - 1;
        int index = 0;

        for (int i = 0; i < arr2.length; i++) {
            int target = arr2[i];
            start = 0;
            end = arr1.length - 1;

            while (end >= start) {
                int mid = start + (end - start) / 2;
                if (arr1[mid] == target) {
                    for (int j = start; j <= end; j++) {
                        if (arr1[j] == target) {
                            ans[index++] = arr1[j];
                            arr1[j] = -1;
                        }
                    }
                    break;
                }
                if (arr1[mid] < target) {
                    start = mid + 1;
                } else {
                    end = mid - 1;
                }
            }
        }

        Arrays.sort(arr1);

        for (int i = 0; i < arr1.length; i++) {
            if (index == arr1.length) {
                break;
            }
            boolean found = false;
            for (int num : arr2) {
                if (arr1[i] == num) {
                    found = true;
                    break;
                }
            }
            if (!found && arr1[i] != -1) {
                ans[index++] = arr1[i];
            }
        }

        return ans;
    }
}",None,"import java.util.Arrays;

class Solution {
    public int[] relativeSortArray(int[] arr1, int[] arr2) {
        int[] ans = new int[arr1.length];
        int index = 0;

        for (int i = 0; i < arr2.length; i++) {
            int target = arr2[i];
            for (int j = 0; j < arr1.length; j++) {
                if (arr1[j] == target) {
                    ans[index++] = arr1[j];
                    arr1[j] = -1;
                }
            }
        }

        int start = index;
        Arrays.sort(arr1);

        for (int i = 0; i < arr1.length; i++) {
            if (arr1[i] != -1) {
                ans[index++] = arr1[i];
            }
        }

        return ans;
    }
}
"
1439,java,maximum-product-of-splitted-binary-tree,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        def dfs(node):
            if node:
                dfs(node.left)
                dfs(node.right)
                if node.left and node.right:
                    node.val += node.left.val + node.right.val
                elif node.left and not node.right:
                    node.val += node.left.val
                elif node.right:
                    node.val += node.right.val
                elif node.val:
                    node.val += node.val
        dfs(root)

        ans, val = 0, root.val
        def f(node):
            nonlocal ans
            if node:
                ans = max(ans, (val - node.val) * node.val)
                f(node.left)
                f(node.right)
        f(root)
        return ans % 1000000007",None,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        def dfs(node):
            if node:
                s = node.val
                if node.left:
                    s += dfs(node.left)
                if node.right:
                    s += dfs(node.right)
                nodes.append(s)
                return s
            return 0
        nodes = []
        total = dfs(root)

        ans = 0
        for node in nodes:
            ans = max(ans, node * (total - node))
        return ans % 1000000007
"
1439,java,maximum-product-of-splitted-binary-tree,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        def dfs(node):
            if node:
                dfs(node.left)
                dfs(node.right)
                if node.left and node.right:
                    node.val += node.left.val + node.right.val
                elif node.left and not node.right:
                    node.val += node.left.val
                elif node.right:
                    node.val += node.right.val
                elif node.val:
                    node.val += node.val
        dfs(root)

        ans, val = 0, root.val
        def f(node):
            nonlocal ans
            if node:
                ans = max(ans, (val - node.val) * node.val)
                f(node.left)
                f(node.right)
        f(root)
        return ans % 1000000007",None,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        totals = []
        def dfs(node):
            if not node:
                return 0
            sub_total = node.val + dfs(node.left) + dfs(node.right)
            totals.append(sub_total)
            return sub_total
        total = dfs(root)
        return max([(total - t) * t for t in totals]) % (10**9 + 7)
"
1439,java,maximum-product-of-splitted-binary-tree,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        def dfs(node):
            if node:
                dfs(node.left)
                dfs(node.right)
                if node.left and node.right:
                    node.val += node.left.val + node.right.val
                elif node.left and not node.right:
                    node.val += node.left.val
                elif node.right:
                    node.val += node.right.val
                elif node.val:
                    node.val += node.val
        dfs(root)

        ans, val = 0, root.val
        def f(node):
            nonlocal ans
            if node:
                ans = max(ans, (val - node.val) * node.val)
                f(node.left)
                f(node.right)
        f(root)
        return ans % 1000000007",None,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        sums = []
        def dfs(node):
            if not node:
                return 0
            s = node.val + dfs(node.left) + dfs(node.right)
            sums.append(s)
            return s
        total = dfs(root)

        ans = max(s * (total - s) for s in sums)
        return ans % 1000000007
"
1440,java,count-negative-numbers-in-a-sorted-matrix,"class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        ROWS, COLS = len(grid), len(grid[0])
        negatives = 0
        col = 0
        for row in range(ROWS - 1, -1, -1):
            while col < COLS and grid[row][col] >= 0:
                col += 1
            negatives += COLS
        return negatives",None,"class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        ROWS, COLS = len(grid), len(grid[0])
        negatives = 0
        col = 0
        for row in range(ROWS - 1, -1, -1):
            while col < COLS and grid[row][col] >= 0:
                col += 1
            negatives += COLS - col
        return negatives
"
1440,java,count-negative-numbers-in-a-sorted-matrix,"class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        ROWS, COLS = len(grid), len(grid[0])
        negatives = 0
        col = 0
        for row in range(ROWS - 1, -1, -1):
            while col < COLS and grid[row][col] >= 0:
                col += 1
            negatives += COLS
        return negatives",None,"class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        ROWS, COLS = len(grid), len(grid[0])
        negatives = 0
        col = 0
        for row in range(ROWS - 1, -1, -1):
            while col < COLS and grid[row][col] >= 0:
                col += 1
            negatives += COLS - col
            col = 0
        return negatives
"
1440,java,count-negative-numbers-in-a-sorted-matrix,"class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        ROWS, COLS = len(grid), len(grid[0])
        negatives = 0
        col = 0
        for row in range(ROWS - 1, -1, -1):
            while col < COLS and grid[row][col] >= 0:
                col += 1
            negatives += COLS
        return negatives",None,M
1441,java,rearrange-characters-to-make-target-string,"class Solution {
    public int rearrangeCharacters(String s, String target) {
        int[] cnt1 = new int[26];
        int[] cnt2 = new int[26];
        for (int i = 0; i < s.length(); ++i) {
            ++cnt1[s.charAt(i) - 'a'];
        }
        for (int i = 0; i < target.length(); ++i) {
            ++cnt2[target.charAt(i) - 'a'];
        }
        int ans = 100;
        for (int i = 0; i < 26; ++i) {
            if (cnt2[i] > 0) {
                ans = Math.min(ans, cnt1[i]);
            }
        }
        return ans;
    }
}",None,"class Solution {
    public int rearrangeCharacters(String s, String target) {
        int[] cnt1 = new int[26];
        int[] cnt2 = new int[26];
        for (int i = 0; i < s.length(); ++i) {
            ++cnt1[s.charAt(i) - 'a'];
        }
        for (int i = 0; i < target.length(); ++i) {
            ++cnt2[target.charAt(i) - 'a'];
        }
        int ans = Integer.MAX_VALUE;
        for (int i = 0; i < 26; ++i) {
            if (cnt2[i] > 0) {
                ans = Math.min(ans, cnt1[i] / cnt2[i]);
            }
        }
        return ans;
    }
}
"
1441,java,rearrange-characters-to-make-target-string,"class Solution {
    public int rearrangeCharacters(String s, String target) {
        int[] cnt1 = new int[26];
        int[] cnt2 = new int[26];
        for (int i = 0; i < s.length(); ++i) {
            ++cnt1[s.charAt(i) - 'a'];
        }
        for (int i = 0; i < target.length(); ++i) {
            ++cnt2[target.charAt(i) - 'a'];
        }
        int ans = 100;
        for (int i = 0; i < 26; ++i) {
            if (cnt2[i] > 0) {
                ans = Math.min(ans, cnt1[i]);
            }
        }
        return ans;
    }
}",None,"class Solution {
    public int rearrangeCharacters(String s, String target) {
        int[] cnt1 = new int[26];
        int[] cnt2 = new int[26];
        for (int i = 0; i < s.length(); ++i) {
            ++cnt1[s.charAt(i) - 'a'];
        }
        for (int i = 0; i < target.length(); ++i) {
            ++cnt2[target.charAt(i) - 'a'];
        }
        int ans = Integer.MAX_VALUE;
        for (int i = 0; i < 26; ++i) {
            if (cnt2[i] > 0) {
                ans = Math.min(ans, cnt1[i] / cnt2[i]);
            }
        }
        return ans;
    }
}
"
1441,java,rearrange-characters-to-make-target-string,"class Solution {
    public int rearrangeCharacters(String s, String target) {
        int[] cnt1 = new int[26];
        int[] cnt2 = new int[26];
        for (int i = 0; i < s.length(); ++i) {
            ++cnt1[s.charAt(i) - 'a'];
        }
        for (int i = 0; i < target.length(); ++i) {
            ++cnt2[target.charAt(i) - 'a'];
        }
        int ans = 100;
        for (int i = 0; i < 26; ++i) {
            if (cnt2[i] > 0) {
                ans = Math.min(ans, cnt1[i]);
            }
        }
        return ans;
    }
}",None,"class Solution {
    public int rearrangeCharacters(String s, String target) {
        int[] cnt1 = new int[26];
        int[] cnt2 = new int[26];
        for (int i = 0; i < s.length(); ++i) {
            ++cnt1[s.charAt(i) - 'a'];
        }
        for (int i = 0; i < target.length(); ++i) {
            ++cnt2[target.charAt(i) - 'a'];
        }
        int ans = Integer.MAX_VALUE;
        for (int i = 0; i < 26; ++i) {
            if (cnt2[i] > 0) {
                ans = Math.min(ans, cnt1[i] / cnt2[i]);
            }
        }
        return ans;
    }
}
"
1442,java,pass-the-pillow,"class Solution {
    public int passThePillow(int n, int time) {
        int num=(time/(n-1));
        if(n>time){
            return time;
        }
        if(num%2==1){
            return n-((time%(n-1)));
        }
            
        return (time%(n-1))+1;
    }
}",None,"class Solution {
    public int passThePillow(int n, int time) {
        int num=(time/n);
        if(n>time){
            return time + 1;
        }
        if(num%2==1){
            return n-(time%n);
        } 
        else {
            int result = time%n + 1;
            return (result == 1) ? n : result;
        }
    }
}
"
1442,java,pass-the-pillow,"class Solution {
    public int passThePillow(int n, int time) {
        int num=(time/(n-1));
        if(n>time){
            return time;
        }
        if(num%2==1){
            return n-((time%(n-1)));
        }
            
        return (time%(n-1))+1;
    }
}",None,"class Solution {
    public int passThePillow(int n, int time) {
        int position = time % (2 * n - 2);
        if(position < n){
            return position + 1;
        }else{
            return 2 * n - position - 1;
        }
    }
}
"
1442,java,pass-the-pillow,"class Solution {
    public int passThePillow(int n, int time) {
        int num=(time/(n-1));
        if(n>time){
            return time;
        }
        if(num%2==1){
            return n-((time%(n-1)));
        }
            
        return (time%(n-1))+1;
    }
}",None,"class Solution {
    public int passThePillow(int n, int time) {
        int cycleTime = 2 * (n - 1);
        time %= cycleTime;
        if(time <= n - 1)
            return time + 1;
        else
            return cycleTime - time + 1;
    }
}
"
1443,java,add-binary,"import java.math.BigInteger;
class Solution {
    public String addBinary(String a, String b) {
        BigInteger A=new BigInteger(a,2);
        BigInteger B=new BigInteger(b,2);
        BigInteger c=A.add(B);
        return c.toString(10);
    }
}",None,"import java.math.BigInteger;
class Solution {
    public String addBinary(String a, String b) {
        BigInteger A=new BigInteger(a,2);
        BigInteger B=new BigInteger(b,2);
        BigInteger c=A.add(B);
        return c.toString(2);
    }
}
"
1443,java,add-binary,"import java.math.BigInteger;
class Solution {
    public String addBinary(String a, String b) {
        BigInteger A=new BigInteger(a,2);
        BigInteger B=new BigInteger(b,2);
        BigInteger c=A.add(B);
        return c.toString(10);
    }
}",None,"import java.math.BigInteger;
class Solution {
    public String addBinary(String a, String b) {
        BigInteger A=new BigInteger(a,2);
        BigInteger B=new BigInteger(b,2);
        BigInteger c=A.add(B);
        return c.toString(2);
    }
}
"
1443,java,add-binary,"import java.math.BigInteger;
class Solution {
    public String addBinary(String a, String b) {
        BigInteger A=new BigInteger(a,2);
        BigInteger B=new BigInteger(b,2);
        BigInteger c=A.add(B);
        return c.toString(10);
    }
}",None,"import java.math.BigInteger;
class Solution {
    public String addBinary(String a, String b) {
        BigInteger A=new BigInteger(a,2);
        BigInteger B=new BigInteger(b,2);
        BigInteger c=A.add(B);
        return c.toString(2);
    }
}
"
1444,java,design-authentication-manager,"class AuthenticationManager {

    int time=0;

    HashMap<String,Integer>mp=new HashMap<>();

    public AuthenticationManager(int timeToLive) {
        
    time=timeToLive;

    }
    
    public void generate(String tokenId, int currentTime) {
        
    mp.put(tokenId,currentTime);

    }
    
    public void renew(String tokenId, int currentTime) {
        
    if(!mp.containsKey(tokenId)||mp.get(tokenId)<=currentTime)
    {
    return;
    }

    mp.put(tokenId,currentTime+time);

    }
    
    public int countUnexpiredTokens(int currentTime) {
    
    List<String>lr=new ArrayList<>(mp.keySet());
    
    for(int i=0;i<lr.size();i++){
    
    if(mp.get(lr.get(i))<=currentTime)mp.remove(lr.get(i));

    }

    return mp.size();
    
    }
}
/**
 * Your AuthenticationManager object will be instantiated and called as such:
 * AuthenticationManager obj = new AuthenticationManager(timeToLive);
 * obj.generate(tokenId,currentTime);
 * obj.renew(tokenId,currentTime);
 * int param_3 = obj.countUnexpiredTokens(currentTime);
 */",None,"class AuthenticationManager {

    private final int time;
    private final HashMap<String,Integer> mp;

    public AuthenticationManager(int timeToLive) {
        time = timeToLive;
        mp = new HashMap<>();
    }
    
    public void generate(String tokenId, int currentTime) { 
        mp.put(tokenId, currentTime + time);
    }
    
    public void renew(String tokenId, int currentTime) {
        if(mp.containsKey(tokenId) && mp.get(tokenId) > currentTime) {
            mp.put(tokenId, currentTime + time);
        }
    }
    
    public int countUnexpiredTokens(int currentTime) {
        List<String> tokens = new ArrayList<>(mp.keySet());
        
        for(String token : tokens){
            if(mp.get(token) <= currentTime){
                mp.remove(token);
            }
        }
        return mp.size();
    }
}
/**
 * Your AuthenticationManager object will be instantiated and called as such:
 * AuthenticationManager obj = new AuthenticationManager(timeToLive);
 * obj.generate(tokenId,currentTime);
 * obj.renew(tokenId,currentTime);
 * int param_3 = obj.countUnexpiredTokens(currentTime);
 */
"
1444,java,design-authentication-manager,"class AuthenticationManager {

    int time=0;

    HashMap<String,Integer>mp=new HashMap<>();

    public AuthenticationManager(int timeToLive) {
        
    time=timeToLive;

    }
    
    public void generate(String tokenId, int currentTime) {
        
    mp.put(tokenId,currentTime);

    }
    
    public void renew(String tokenId, int currentTime) {
        
    if(!mp.containsKey(tokenId)||mp.get(tokenId)<=currentTime)
    {
    return;
    }

    mp.put(tokenId,currentTime+time);

    }
    
    public int countUnexpiredTokens(int currentTime) {
    
    List<String>lr=new ArrayList<>(mp.keySet());
    
    for(int i=0;i<lr.size();i++){
    
    if(mp.get(lr.get(i))<=currentTime)mp.remove(lr.get(i));

    }

    return mp.size();
    
    }
}
/**
 * Your AuthenticationManager object will be instantiated and called as such:
 * AuthenticationManager obj = new AuthenticationManager(timeToLive);
 * obj.generate(tokenId,currentTime);
 * obj.renew(tokenId,currentTime);
 * int param_3 = obj.countUnexpiredTokens(currentTime);
 */",None,"class AuthenticationManager {

    int timeToLive;
    HashMap<String, Integer> tokenExpiration;

    public AuthenticationManager(int timeToLive) {
        this.timeToLive = timeToLive;
        this.tokenExpiration = new HashMap<>();
    }
    
    public void generate(String tokenId, int currentTime) {
        tokenExpiration.put(tokenId, currentTime + timeToLive);
    }
    
    public void renew(String tokenId, int currentTime) {
        if (tokenExpiration.containsKey(tokenId) && tokenExpiration.get(tokenId) > currentTime) {
            tokenExpiration.put(tokenId, currentTime + timeToLive);
        }
    }
    
    public int countUnexpiredTokens(int currentTime) {
        int count = 0;
        Iterator<Integer> tokens = tokenExpiration.values().iterator();
        while (tokens.hasNext()) {
            if (tokens.next() > currentTime) {
                count++;
            }
        }
        return count;
    }
}
/**
 * Your AuthenticationManager object will be instantiated and called as such:
 * AuthenticationManager obj = new AuthenticationManager(timeToLive);
 * obj.generate(tokenId,currentTime);
 * obj.renew(tokenId,currentTime);
 * int param_3 = obj.countUnexpiredTokens(currentTime);
 */
"
1444,java,design-authentication-manager,"class AuthenticationManager {

    int time=0;

    HashMap<String,Integer>mp=new HashMap<>();

    public AuthenticationManager(int timeToLive) {
        
    time=timeToLive;

    }
    
    public void generate(String tokenId, int currentTime) {
        
    mp.put(tokenId,currentTime);

    }
    
    public void renew(String tokenId, int currentTime) {
        
    if(!mp.containsKey(tokenId)||mp.get(tokenId)<=currentTime)
    {
    return;
    }

    mp.put(tokenId,currentTime+time);

    }
    
    public int countUnexpiredTokens(int currentTime) {
    
    List<String>lr=new ArrayList<>(mp.keySet());
    
    for(int i=0;i<lr.size();i++){
    
    if(mp.get(lr.get(i))<=currentTime)mp.remove(lr.get(i));

    }

    return mp.size();
    
    }
}
/**
 * Your AuthenticationManager object will be instantiated and called as such:
 * AuthenticationManager obj = new AuthenticationManager(timeToLive);
 * obj.generate(tokenId,currentTime);
 * obj.renew(tokenId,currentTime);
 * int param_3 = obj.countUnexpiredTokens(currentTime);
 */",None,"class AuthenticationManager {

    int timeToLive=0;
    HashMap<String,Integer>mp=new HashMap<>();

    public AuthenticationManager(int timeToLive) {
        this.timeToLive = timeToLive;
    }
    
    public void generate(String tokenId, int currentTime) {
        mp.put(tokenId, currentTime + timeToLive);
    }
    
    public void renew(String tokenId, int currentTime) {
        if (mp.containsKey(tokenId) && mp.get(tokenId) > currentTime){
            mp.put(tokenId, currentTime + timeToLive);
        }
    }
    
    public int countUnexpiredTokens(int currentTime) {
        int count = 0;
        for (Map.Entry<String,Integer> entry : mp.entrySet()){
            if (entry.getValue() > currentTime){
                count++;
            }
        }
        return count;
    }
}
/**
 * Your AuthenticationManager object will be instantiated and called as such:
 * AuthenticationManager obj = new AuthenticationManager(timeToLive);
 * obj.generate(tokenId,currentTime);
 * obj.renew(tokenId,currentTime);
 * int param_3 = obj.countUnexpiredTokens(currentTime);
 */
"
1445,java,design-a-stack-with-increment-operation,"class CustomStack:

    def __init__(self, maxSize: int):
        self.arr = []
        self.m = maxSize
        self.top = -1

    def push(self, x: int) -> None:
        if self.top < self.m - 1:
            self.arr.append(x)
            self.top += 1

    def pop(self) -> int:
        if self.top == -1: return -1
        self.top -= 1
        return(self.arr.pop(self.top))

    def increment(self, k: int, val: int) -> None:
        for i in range(min(k, self.top + 1)): self.arr[i] += val",None,"class CustomStack:

    def __init__(self, maxSize: int):
        self.arr = []
        self.m = maxSize
        self.top = -1

    def push(self, x: int) -> None:
        if self.top < self.m - 1:
            self.arr.append(x)
            self.top += 1

    def pop(self) -> int:
        if self.top == -1: return -1
        self.top -= 1
        return(self.arr.pop())

    def increment(self, k: int, val: int) -> None:
        for i in range(min(k, self.top + 1)): self.arr[i] += val
"
1445,java,design-a-stack-with-increment-operation,"class CustomStack:

    def __init__(self, maxSize: int):
        self.arr = []
        self.m = maxSize
        self.top = -1

    def push(self, x: int) -> None:
        if self.top < self.m - 1:
            self.arr.append(x)
            self.top += 1

    def pop(self) -> int:
        if self.top == -1: return -1
        self.top -= 1
        return(self.arr.pop(self.top))

    def increment(self, k: int, val: int) -> None:
        for i in range(min(k, self.top + 1)): self.arr[i] += val",None,"class CustomStack:

    def __init__(self, maxSize: int):
        self.arr = []
        self.m = maxSize

    def push(self, x: int) -> None:
        if len(self.arr) < self.m:
            self.arr.append(x)

    def pop(self) -> int:
        if len(self.arr) == 0: return -1
        return self.arr.pop()

    def increment(self, k: int, val: int) -> None:
        for i in range(min(k, len(self.arr))): self.arr[i] += val
"
1445,java,design-a-stack-with-increment-operation,"class CustomStack:

    def __init__(self, maxSize: int):
        self.arr = []
        self.m = maxSize
        self.top = -1

    def push(self, x: int) -> None:
        if self.top < self.m - 1:
            self.arr.append(x)
            self.top += 1

    def pop(self) -> int:
        if self.top == -1: return -1
        self.top -= 1
        return(self.arr.pop(self.top))

    def increment(self, k: int, val: int) -> None:
        for i in range(min(k, self.top + 1)): self.arr[i] += val",None,"class CustomStack:

    def __init__(self, maxSize: int):
        self.arr = []
        self.m = maxSize
        self.top = -1

    def push(self, x: int) -> None:
        if self.top < self.m - 1:
            self.arr.append(x)
            self.top += 1

    def pop(self) -> int:
        if self.top == -1: return -1
        popped_value = self.arr.pop(self.top)
        self.top -= 1
        return popped_value

    def increment(self, k: int, val: int) -> None:
        for i in range(min(k, self.top + 1)): self.arr[i] += val
"
1446,java,n-th-tribonacci-number,"class Solution {
    public int tribonacci(int n) {
        if(n==0)return 0;
        if(n==1||n==2) return 1;
        int dp[]=new int[n+1];
        dp[0]=0;
        dp[1]=1;
        dp[2]=1;
        for(int i=3;i<=n;i++){
            dp[i]=dp[i-1]+dp[i-2]+dp[i-4];
        }
        return dp[n];
    }
}",None,"class Solution {
    public int tribonacci(int n) {
        if(n==0) return 0;
        if(n==1 || n==2) return 1;
        int dp[] = new int[n+1];
        dp[0] = 0;
        dp[1] = 1;
        dp[2] = 1;
        for(int i=3; i<=n; i++) {
            dp[i] = dp[i-1] + dp[i-2] + dp[i-3];
        }
        return dp[n];
    }
}
"
1446,java,n-th-tribonacci-number,"class Solution {
    public int tribonacci(int n) {
        if(n==0)return 0;
        if(n==1||n==2) return 1;
        int dp[]=new int[n+1];
        dp[0]=0;
        dp[1]=1;
        dp[2]=1;
        for(int i=3;i<=n;i++){
            dp[i]=dp[i-1]+dp[i-2]+dp[i-4];
        }
        return dp[n];
    }
}",None,"class Solution {
    public int tribonacci(int n) {
        if(n==0)return 0;
        if(n==1||n==2) return 1;
        int dp[]=new int[n+1];
        dp[0]=0;
        dp[1]=1;
        dp[2]=1;
        for(int i=3;i<=n;i++){
            dp[i]=dp[i-1]+dp[i-2]+dp[i-3];
        }
        return dp[n];
    }
}
"
1446,java,n-th-tribonacci-number,"class Solution {
    public int tribonacci(int n) {
        if(n==0)return 0;
        if(n==1||n==2) return 1;
        int dp[]=new int[n+1];
        dp[0]=0;
        dp[1]=1;
        dp[2]=1;
        for(int i=3;i<=n;i++){
            dp[i]=dp[i-1]+dp[i-2]+dp[i-4];
        }
        return dp[n];
    }
}",None,"class Solution {
    public int tribonacci(int n) {
        if(n==0)return 0;
        if(n==1||n==2) return 1;
        int dp[]=new int[n+1];
        dp[0]=0;
        dp[1]=1;
        dp[2]=1;
        for(int i=3;i<=n;i++){
            dp[i]=dp[i-1]+dp[i-2]+dp[i-3];
        }
        return dp[n];
    }
}
"
1447,java,longest-uncommon-subsequence-i,"class Solution {
    public int findLUSlength(String a, String b) {
        if(a.equals(b)){
            return -1;
        }else{
            return Math.min(a.length(),b.length());
        }
    }
}",None,"class Solution {
    public int findLUSlength(String a, String b) {
        if(a.equals(b)){
            return -1;
        }else{
            return Math.max(a.length(),b.length());
        }
    }
}
"
1447,java,longest-uncommon-subsequence-i,"class Solution {
    public int findLUSlength(String a, String b) {
        if(a.equals(b)){
            return -1;
        }else{
            return Math.min(a.length(),b.length());
        }
    }
}",None,"class Solution {
    public int findLUSlength(String a, String b) {
        if(a.equals(b)){
            return -1;
        }else{
            return Math.max(a.length(),b.length());
        }
    }
}
"
1447,java,longest-uncommon-subsequence-i,"class Solution {
    public int findLUSlength(String a, String b) {
        if(a.equals(b)){
            return -1;
        }else{
            return Math.min(a.length(),b.length());
        }
    }
}",None,"class Solution {
    public int findLUSlength(String a, String b) {
        if(a.equals(b)){
            return -1;
        }else{
            return Math.max(a.length(),b.length());
        }
    }
}
"
1448,java,minimum-number-of-swaps-to-make-the-string-balanced,"class Solution {
    public int minSwaps(String s) {
        return util1(s);
    }
    public int util1(String str) {
        Stack<Character> s = new Stack<>();
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == '[') {
                s.push(str.charAt(i));
            } else {
                if (s.isEmpty() == false && s.peek() == '[') {
                    s.pop();
                } else {
                    s.push(str.charAt(i));
                }
            }
        }
        double pairs = s.size() / 2;
        double a = pairs / 10.0;
        int ans = (int) Math.ceil(a);
        return ans;
    }
}",None,"class Solution {
    public int minSwaps(String s) {
        return util1(s);
    }
    public int util1(String str) {
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == '[') {
                stack.push(str.charAt(i));
            } else {
                if (!stack.isEmpty() && stack.peek() == '[') {
                    stack.pop();
                } else {
                    stack.push(str.charAt(i));
                }
            }
        }
        int mismatchedPairs = stack.size() / 2;
        int ans = (int) Math.ceil(mismatchedPairs / 2.0);
        return ans;
    }
}
"
1448,java,minimum-number-of-swaps-to-make-the-string-balanced,"class Solution {
    public int minSwaps(String s) {
        return util1(s);
    }
    public int util1(String str) {
        Stack<Character> s = new Stack<>();
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == '[') {
                s.push(str.charAt(i));
            } else {
                if (s.isEmpty() == false && s.peek() == '[') {
                    s.pop();
                } else {
                    s.push(str.charAt(i));
                }
            }
        }
        double pairs = s.size() / 2;
        double a = pairs / 10.0;
        int ans = (int) Math.ceil(a);
        return ans;
    }
}",None,"class Solution {
    public int minSwaps(String s) {
        return util1(s);
    }
    public int util1(String str) {
        Stack<Character> s = new Stack<>();
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == '[') {
                s.push(str.charAt(i));
            } else {
                if (s.isEmpty() == false && s.peek() == '[') {
                    s.pop();
                } else {
                    s.push(str.charAt(i));
                }
            }
        }
        double pairs = s.size() / 2.0;
        int ans = (int) Math.ceil(pairs);
        return ans;
    }
}
"
1448,java,minimum-number-of-swaps-to-make-the-string-balanced,"class Solution {
    public int minSwaps(String s) {
        return util1(s);
    }
    public int util1(String str) {
        Stack<Character> s = new Stack<>();
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == '[') {
                s.push(str.charAt(i));
            } else {
                if (s.isEmpty() == false && s.peek() == '[') {
                    s.pop();
                } else {
                    s.push(str.charAt(i));
                }
            }
        }
        double pairs = s.size() / 2;
        double a = pairs / 10.0;
        int ans = (int) Math.ceil(a);
        return ans;
    }
}",None,"class Solution {
    public int minSwaps(String s) {
        return util1(s);
    }
    public int util1(String str) {
        Stack<Character> s = new Stack<>();
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == '[') {
                s.push(str.charAt(i));
            } else {
                if (!s.isEmpty() && s.peek() == '[') {
                    s.pop();
                } else {
                    s.push(str.charAt(i));
                }
            }
        }
        int pairs = s.size() / 2;
        int ans = (int) Math.ceil(pairs / 2.0);
        return ans;
    }
}
"
1449,java,find-first-palindromic-string-in-the-array,"class Solution {
    public String firstPalindrome(String[] words) {
        for(String x : words) {
            StringBuilder SB = new StringBuilder(x);
            x = SB.reverse().toString();
            if(x.equals(SB.toString())) {
                return x;
            }
        }
        return """";
    }
}",None,"class Solution {
  public String firstPalindrome(String[] words) {
    for(String x : words) {
      String reversed = new StringBuilder(x).reverse().toString();
      if(x.equals(reversed)) {
        return x;
      }
    }
    return """";
  }
}
"
1449,java,find-first-palindromic-string-in-the-array,"class Solution {
    public String firstPalindrome(String[] words) {
        for(String x : words) {
            StringBuilder SB = new StringBuilder(x);
            x = SB.reverse().toString();
            if(x.equals(SB.toString())) {
                return x;
            }
        }
        return """";
    }
}",None,"class Solution {
    public String firstPalindrome(String[] words) {
        for(String x : words) {
            StringBuilder SB = new StringBuilder(x);
            String reversed = SB.reverse().toString();
            if(x.equals(reversed)) {
                return x;
            }
        }
        return """";
    }
}
"
1449,java,find-first-palindromic-string-in-the-array,"class Solution {
    public String firstPalindrome(String[] words) {
        for(String x : words) {
            StringBuilder SB = new StringBuilder(x);
            x = SB.reverse().toString();
            if(x.equals(SB.toString())) {
                return x;
            }
        }
        return """";
    }
}",None,"class Solution {
    public String firstPalindrome(String[] words) {
        for(String x : words) {
            String reversed = new StringBuilder(x).reverse().toString();
            if(x.equals(reversed)) {
                return x;
            }
        }
        return """";
    }
}
"
1450,java,neighboring-bitwise-xor,"class Solution {
    public boolean doesValidArrayExist(int[] de) {
        int ans=0;
        for(int a:de){
            if(a==1)
                ans++;
        }
        return (ans%3==0);
    }
}",None,"class Solution {
    public boolean doesValidArrayExist(int[] derived) {
        int n=derived.length;
        int[] original=new int[n];
        original[0]=derived[0];
        
        for(int i=1;i<n-1;i++){
            original[i]=derived[i-1]^derived[i]; 
        }
        
        original[n-1]=derived[n-1] ^ original[0];
        
        for(int i=0;i<n-1;i++){
            if(original[i]^original[i+1] != derived[i]){
                return false;
            }
        }
        
        if(original[n-1]^original[0] != derived[n-1]){
            return false;
        }
        
        return true;
    }
}
"
1450,java,neighboring-bitwise-xor,"class Solution {
    public boolean doesValidArrayExist(int[] de) {
        int ans=0;
        for(int a:de){
            if(a==1)
                ans++;
        }
        return (ans%3==0);
    }
}",None,"class Solution {
    public boolean doesValidArrayExist(int[] de) {
        int n = de.length;
        int[] original = new int[n];
        for(int i=0; i<n; i++){
            if(i==n-1){
                original[i] = de[i] ^ original[0];
            }
            else{
                original[i] = de[i] ^ original[i+1];
            }
        }
        for(int i=0; i<n-1; i++){
            if(original[i] != (original[i+1]^de[i])){
                return false;
            }
        }
        return original[n-1] == (original[0]^de[n-1]);
    }
}
"
1450,java,neighboring-bitwise-xor,"class Solution {
    public boolean doesValidArrayExist(int[] de) {
        int ans=0;
        for(int a:de){
            if(a==1)
                ans++;
        }
        return (ans%3==0);
    }
}",None,"class Solution {
    public boolean doesValidArrayExist(int[] de) {
        if(de.length == 1)
            return de[0] == 0;
        int[] xor = new int[de.length];
        xor[0] = de[0];
        for(int i=1;i<de.length-1;i++) {
            xor[i] = xor[i-1] ^ de[i];
        }
        xor[de.length-1] = de[de.length-1] ^ xor[0];
        for(int i=0;i<de.length;i++) {
            if(xor[i] != de[i])
                return false;
        }
        return true;
    }
}
"
1451,java,sign-of-the-product-of-an-array,"class Solution { 
  public int arraySign(int[] nums) {
    int z = 0;
    for (int v : nums)
      if (v == 0)
        return 0;
      else
        z ^= v;
    return z;
  }
}",None,"class Solution { 
  public int arraySign(int[] nums) {
    int negativeCount = 0;
    for (int v : nums) {
      if (v == 0)
        return 0;
      else if (v < 0)
        negativeCount++;
    }
    return negativeCount % 2 == 0 ? 1 : -1;
  }
}
"
1451,java,sign-of-the-product-of-an-array,"class Solution { 
  public int arraySign(int[] nums) {
    int z = 0;
    for (int v : nums)
      if (v == 0)
        return 0;
      else
        z ^= v;
    return z;
  }
}",None,"class Solution { 
  public int arraySign(int[] nums) {
    int z = 1;
    for (int v : nums) {
      if (v == 0) return 0;
      else if (v < 0) z *= -1;
    }
    return z;
  }
}
"
1451,java,sign-of-the-product-of-an-array,"class Solution { 
  public int arraySign(int[] nums) {
    int z = 0;
    for (int v : nums)
      if (v == 0)
        return 0;
      else
        z ^= v;
    return z;
  }
}",None,"class Solution { 
  public int arraySign(int[] nums) {
    int negCount = 0;
    for (int v : nums) {
      if (v == 0) {
        return 0;
      } else if (v < 0) {
        negCount++;
      }
    }
    return negCount % 2 == 0 ? 1 : -1;
  }
}
"
1452,java,maximal-rectangle,"class Pair<T, U> {
    public final T first;
    public final U second;

    public Pair(T first, U second) {
        this.first = first;
        this.second = second;
    }
}

class Solution {
    public int maximalRectangle(char[][] matrix) {
        int n = matrix.length, m = matrix[0].length;
        int[] nums = new int[m];
        for (int j = 0; j < m; j++) {
            nums[j] = matrix[0][j] - '1';
        }
        int max = maximumAreaHistogram(nums);
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix[i][j] == '0') {
                    nums[j] = 0;
                } else {
                    nums[j] += (matrix[i][j] - '0');
                }
            }
            max = Math.max(max, maximumAreaHistogram(nums));
        }
        return max;
    }
    public int maximumAreaHistogram(int[] heights) {
        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();
        int[] left = new int[heights.length];
        int pseudoIndex = -1;
        for (int i = 0; i < heights.length; i++) {
            if (stack1.size() == 0) {
                left[i] = pseudoIndex;
            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {
                left[i] = stack1.peek().second;
            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {
                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {
                    stack1.pop();
                }
                if (stack1.size() == 0) {
                    left[i] = pseudoIndex;
                } else {
                    left[i] = stack1.peek().second;
                }
            }
            stack1.push(new Pair<>(heights[i], i));
        }
        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();
        int[] right = new int[heights.length];
        pseudoIndex = heights.length;
        for (int i = heights.length - 1; i >= 0; i--) {
            if (stack2.size() == 0) {
                right[i] = pseudoIndex;
            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {
                right[i] = stack2.peek().second;
            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {
                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {
                    stack2.pop();
                }
                if (stack2.size() == 0) {
                    right[i] = pseudoIndex;
                } else {
                    right[i] = stack2.peek().second;
                }
            }
            stack2.push(new Pair<>(heights[i], i));
        }

        int[] width = new int[heights.length];
        for (int i = 0; i < heights.length; i++) {
            width[i] = right[i] - left[i] - 1;
        }

        int[] area = new int[heights.length];
        int maxArea = 0;
        for (int i = 0; i < heights.length; i++) {
            area[i] = heights[i] * width[i];
            if (area[i] > maxArea) maxArea = area[i];
        }
        return maxArea;
    }
}",None,"class Pair<T, U> {
    public final T first;
    public final U second;

    public Pair(T first, U second) {
        this.first = first;
        this.second = second;
    }
}

class Solution {
    public int maximalRectangle(char[][] matrix) {
        if(matrix.length == 0) return 0;
        int n = matrix.length, m = matrix[0].length;
        int[] nums = new int[m];
        for (int j = 0; j < m; j++) {
            nums[j] = matrix[0][j] - '0';
        }
        int max = maximumAreaHistogram(nums);
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix[i][j] == '0') {
                    nums[j] = 0;
                } else {
                    nums[j] += (matrix[i][j] - '0');
                }
            }
            max = Math.max(max, maximumAreaHistogram(nums));
        }
        return max;
    }
    public int maximumAreaHistogram(int[] heights) {
        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();
        int[] left = new int[heights.length];
        int pseudoIndex = -1;
        for (int i = 0; i < heights.length; i++) {
            while (!stack1.isEmpty() && stack1.peek().first >= heights[i]) {
                stack1.pop();
            }
            left[i] = (stack1.isEmpty() ? pseudoIndex : stack1.peek().second);
            stack1.push(new Pair<>(heights[i], i));
        }
        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();
        int[] right = new int[heights.length];
        pseudoIndex = heights.length;
        for (int i = heights.length - 1; i >= 0; i--) {
            while (!stack2.isEmpty() && stack2.peek().first >= heights[i]) {
                stack2.pop();
            }
            right[i] = (stack2.isEmpty() ? pseudoIndex : stack2.peek().second);
            stack2.push(new Pair<>(heights[i], i));
        }

        int maxArea = 0;
        for (int i = 0; i < heights.length; i++) {
            maxArea = Math.max(maxArea, heights[i] * (right[i] - left[i] - 1));
        }
        return maxArea;
    }
}
"
1452,java,maximal-rectangle,"class Pair<T, U> {
    public final T first;
    public final U second;

    public Pair(T first, U second) {
        this.first = first;
        this.second = second;
    }
}

class Solution {
    public int maximalRectangle(char[][] matrix) {
        int n = matrix.length, m = matrix[0].length;
        int[] nums = new int[m];
        for (int j = 0; j < m; j++) {
            nums[j] = matrix[0][j] - '1';
        }
        int max = maximumAreaHistogram(nums);
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix[i][j] == '0') {
                    nums[j] = 0;
                } else {
                    nums[j] += (matrix[i][j] - '0');
                }
            }
            max = Math.max(max, maximumAreaHistogram(nums));
        }
        return max;
    }
    public int maximumAreaHistogram(int[] heights) {
        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();
        int[] left = new int[heights.length];
        int pseudoIndex = -1;
        for (int i = 0; i < heights.length; i++) {
            if (stack1.size() == 0) {
                left[i] = pseudoIndex;
            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {
                left[i] = stack1.peek().second;
            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {
                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {
                    stack1.pop();
                }
                if (stack1.size() == 0) {
                    left[i] = pseudoIndex;
                } else {
                    left[i] = stack1.peek().second;
                }
            }
            stack1.push(new Pair<>(heights[i], i));
        }
        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();
        int[] right = new int[heights.length];
        pseudoIndex = heights.length;
        for (int i = heights.length - 1; i >= 0; i--) {
            if (stack2.size() == 0) {
                right[i] = pseudoIndex;
            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {
                right[i] = stack2.peek().second;
            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {
                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {
                    stack2.pop();
                }
                if (stack2.size() == 0) {
                    right[i] = pseudoIndex;
                } else {
                    right[i] = stack2.peek().second;
                }
            }
            stack2.push(new Pair<>(heights[i], i));
        }

        int[] width = new int[heights.length];
        for (int i = 0; i < heights.length; i++) {
            width[i] = right[i] - left[i] - 1;
        }

        int[] area = new int[heights.length];
        int maxArea = 0;
        for (int i = 0; i < heights.length; i++) {
            area[i] = heights[i] * width[i];
            if (area[i] > maxArea) maxArea = area[i];
        }
        return maxArea;
    }
}",None,"class Pair<T, U> {
    public final T first;
    public final U second;

    public Pair(T first, U second) {
        this.first = first;
        this.second = second;
    }
}

class Solution {
    public int maximalRectangle(char[][] matrix) {
        if(matrix.length == 0) return 0;

        int n = matrix.length, m = matrix[0].length;
        int[] nums = new int[m];
        for (int j = 0; j < m; j++) {
            nums[j] = matrix[0][j] - '0';
        }
        int max = maximumAreaHistogram(nums);
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix[i][j] == '0') {
                    nums[j] = 0;
                } else {
                    nums[j] += (matrix[i][j] - '0');
                }
            }
            max = Math.max(max, maximumAreaHistogram(nums));
        }
        return max;
    }
    public int maximumAreaHistogram(int[] heights) {
        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();
        int[] left = new int[heights.length];
        int pseudoIndex = -1;
        for (int i = 0; i < heights.length; i++) {
            if (stack1.size() == 0) {
                left[i] = pseudoIndex;
            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {
                left[i] = stack1.peek().second;
            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {
                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {
                    stack1.pop();
                }
                if (stack1.size() == 0) {
                    left[i] = pseudoIndex;
                } else {
                    left[i] = stack1.peek().second;
                }
            }
            stack1.push(new Pair<>(heights[i], i));
        }
        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();
        int[] right = new int[heights.length];
        pseudoIndex = heights.length;
        for (int i = heights.length - 1; i >= 0; i--) {
            if (stack2.size() == 0) {
                right[i] = pseudoIndex;
            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {
                right[i] = stack2.peek().second;
            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {
                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {
                    stack2.pop();
                }
                if (stack2.size() == 0) {
                    right[i] = pseudoIndex;
                } else {
                    right[i] = stack2.peek().second;
                }
            }
            stack2.push(new Pair<>(heights[i], i));
        }

        int[] width = new int[heights.length];
        for (int i = 0; i < heights.length; i++) {
            width[i] = right[i] - left[i] - 1;
        }

        int[] area = new int[heights.length];
        int maxArea = 0;
        for (int i = 0; i < heights.length; i++) {
            area[i] = heights[i] * width[i];
            if (area[i] > maxArea) maxArea = area[i];
        }
        return maxArea;
    }
}
"
1452,java,maximal-rectangle,"class Pair<T, U> {
    public final T first;
    public final U second;

    public Pair(T first, U second) {
        this.first = first;
        this.second = second;
    }
}

class Solution {
    public int maximalRectangle(char[][] matrix) {
        int n = matrix.length, m = matrix[0].length;
        int[] nums = new int[m];
        for (int j = 0; j < m; j++) {
            nums[j] = matrix[0][j] - '1';
        }
        int max = maximumAreaHistogram(nums);
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix[i][j] == '0') {
                    nums[j] = 0;
                } else {
                    nums[j] += (matrix[i][j] - '0');
                }
            }
            max = Math.max(max, maximumAreaHistogram(nums));
        }
        return max;
    }
    public int maximumAreaHistogram(int[] heights) {
        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();
        int[] left = new int[heights.length];
        int pseudoIndex = -1;
        for (int i = 0; i < heights.length; i++) {
            if (stack1.size() == 0) {
                left[i] = pseudoIndex;
            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {
                left[i] = stack1.peek().second;
            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {
                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {
                    stack1.pop();
                }
                if (stack1.size() == 0) {
                    left[i] = pseudoIndex;
                } else {
                    left[i] = stack1.peek().second;
                }
            }
            stack1.push(new Pair<>(heights[i], i));
        }
        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();
        int[] right = new int[heights.length];
        pseudoIndex = heights.length;
        for (int i = heights.length - 1; i >= 0; i--) {
            if (stack2.size() == 0) {
                right[i] = pseudoIndex;
            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {
                right[i] = stack2.peek().second;
            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {
                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {
                    stack2.pop();
                }
                if (stack2.size() == 0) {
                    right[i] = pseudoIndex;
                } else {
                    right[i] = stack2.peek().second;
                }
            }
            stack2.push(new Pair<>(heights[i], i));
        }

        int[] width = new int[heights.length];
        for (int i = 0; i < heights.length; i++) {
            width[i] = right[i] - left[i] - 1;
        }

        int[] area = new int[heights.length];
        int maxArea = 0;
        for (int i = 0; i < heights.length; i++) {
            area[i] = heights[i] * width[i];
            if (area[i] > maxArea) maxArea = area[i];
        }
        return maxArea;
    }
}",None,"class Pair<T, U> {
    public final T first;
    public final U second;

    public Pair(T first, U second) {
        this.first = first;
        this.second = second;
    }
}

class Solution {
    public int maximalRectangle(char[][] matrix) {
        int n = matrix.length, m = matrix[0].length;
        int[] nums = new int[m];
        for (int j = 0; j < m; j++) {
            nums[j] = matrix[0][j] - '0';
        }
        int max = maximumAreaHistogram(nums);
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix[i][j] == '0') {
                    nums[j] = 0;
                } else {
                    nums[j] += (matrix[i][j] - '0');
                }
            }
            max = Math.max(max, maximumAreaHistogram(nums));
        }
        return max;
    }
    public int maximumAreaHistogram(int[] heights) {
        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();
        int[] left = new int[heights.length];
        int pseudoIndex = -1;
        for (int i = 0; i < heights.length; i++) {
            while (!stack1.isEmpty() && stack1.peek().first >= heights[i]) {
                stack1.pop();
            }
            left[i] = (stack1.isEmpty())? pseudoIndex : stack1.peek().second;
            stack1.push(new Pair<>(heights[i], i));
        }
        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();
        int[] right = new int[heights.length];
        pseudoIndex = heights.length;
        for (int i = heights.length - 1; i >= 0; i--) {
            while (!stack2.isEmpty() && stack2.peek().first >= heights[i]) {
                stack2.pop();
            }
            right[i] = (stack2.isEmpty())? pseudoIndex : stack2.peek().second;
            stack2.push(new Pair<>(heights[i], i));
        }

        int[] width = new int[heights.length];
        for (int i = 0; i < heights.length; i++) {
            width[i] = right[i] - left[i] - 1;
        }

        int[] area = new int[heights.length];
        int maxArea = 0;
        for (int i = 0; i < heights.length; i++) {
            area[i] = heights[i] * width[i];
            if (area[i] > maxArea) maxArea = area[i];
        }
        return maxArea;
    }
}
"
1453,java,print-in-order,"class Foo {
    private volatile int num = 1;
    public Foo() {

    }

    public void first(Runnable printFirst) throws InterruptedException {
        while(num != 1){
        }

        printFirst.run();
    }

    public void second(Runnable printSecond) throws InterruptedException {
        while(num != 2){
        }
        printSecond.run();
        num++;
    }

    public void third(Runnable printThird) throws InterruptedException {
        while(num != 3){
        }
        printThird.run();
        num++;
    }
}",None,"class Foo {
    private volatile int num = 1;
    public Foo() {

    }

    public void first(Runnable printFirst) throws InterruptedException {
        while(num != 1){
        }

        printFirst.run();
        num++;
    }

    public void second(Runnable printSecond) throws InterruptedException {
        while(num != 2){
        }
        printSecond.run();
        num++;
    }

    public void third(Runnable printThird) throws InterruptedException {
        while(num != 3){
        }
        printThird.run();
        num++;
    }
}
"
1453,java,print-in-order,"class Foo {
    private volatile int num = 1;
    public Foo() {

    }

    public void first(Runnable printFirst) throws InterruptedException {
        while(num != 1){
        }

        printFirst.run();
    }

    public void second(Runnable printSecond) throws InterruptedException {
        while(num != 2){
        }
        printSecond.run();
        num++;
    }

    public void third(Runnable printThird) throws InterruptedException {
        while(num != 3){
        }
        printThird.run();
        num++;
    }
}",None,"class Foo {
    private volatile int num = 1;
    public Foo() {

    }

    public void first(Runnable printFirst) throws InterruptedException {
        while(num != 1){
        }

        printFirst.run();
        num++;
    }

    public void second(Runnable printSecond) throws InterruptedException {
        while(num != 2){
        }
        printSecond.run();
        num++;
    }

    public void third(Runnable printThird) throws InterruptedException {
        while(num != 3){
        }
        printThird.run();
        num++;
    }
}
"
1453,java,print-in-order,"class Foo {
    private volatile int num = 1;
    public Foo() {

    }

    public void first(Runnable printFirst) throws InterruptedException {
        while(num != 1){
        }

        printFirst.run();
    }

    public void second(Runnable printSecond) throws InterruptedException {
        while(num != 2){
        }
        printSecond.run();
        num++;
    }

    public void third(Runnable printThird) throws InterruptedException {
        while(num != 3){
        }
        printThird.run();
        num++;
    }
}",None,"class Foo {
    private volatile int num = 1;

    public Foo() {

    }

    public void first(Runnable printFirst) throws InterruptedException {
        while(num != 1){
        }       

        printFirst.run();
        num++;
    }

    public void second(Runnable printSecond) throws InterruptedException {
        while(num != 2){
        }   

        printSecond.run();
        num++;
    }

    public void third(Runnable printThird) throws InterruptedException {
        while(num != 3){
        }  

        printThird.run();
        num++;
    }
}
"
1454,java,count-number-of-pairs-with-absolute-difference-k,"class Solution {
    public int countKDifference(int[] nums, int k) {
       int ans = 0;

        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (Math.abs(nums[i] - nums[j]) == k) {
                    ans--;
                }
            }
        }
        return ans;
    }
}",None,"class Solution {
    public int countKDifference(int[] nums, int k) {
       int ans = 0;

        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (Math.abs(nums[i] - nums[j]) == k) {
                    ans++;
                }
            }
        }
        return ans;
    }
}
"
1454,java,count-number-of-pairs-with-absolute-difference-k,"class Solution {
    public int countKDifference(int[] nums, int k) {
       int ans = 0;

        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (Math.abs(nums[i] - nums[j]) == k) {
                    ans--;
                }
            }
        }
        return ans;
    }
}",None,"class Solution {
    public int countKDifference(int[] nums, int k) {
       int ans = 0;

        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (Math.abs(nums[i] - nums[j]) == k) {
                    ans++;
                }
            }
        }
        return ans;
    }
}
"
1454,java,count-number-of-pairs-with-absolute-difference-k,"class Solution {
    public int countKDifference(int[] nums, int k) {
       int ans = 0;

        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (Math.abs(nums[i] - nums[j]) == k) {
                    ans--;
                }
            }
        }
        return ans;
    }
}",None,"class Solution {
    public int countKDifference(int[] nums, int k) {
       int ans = 0;

        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (Math.abs(nums[i] - nums[j]) == k) {
                    ans++;
                }
            }
        }
        return ans;
    }
}
"
1455,java,increasing-decreasing-string,"class Solution {
    public String sortString(String s) {
        int[] arr = new int[27];
        String str = ""abcdefghijklmnopqrstuvwxyz"";
        for(int i=0;i<s.length();i++){
            int num = str.indexOf((s.charAt(i)));
            arr[num]=arr[num]+1; 
            ++num; 
        }

        int len = s.length();
        int count=0;
        StringBuilder ans = new StringBuilder();

        while(count<len){
            for(int i=1;i<27;i++){
                if(arr[i]>0){
                    ans.append(str.charAt(i - 1));
                    arr[i]=arr[i]-1;
                    count++;
                }
            }
            for(int j=26;j>=1;j--){
                if(arr[j]>0){
                    ans.append(str.charAt(j - 1));
                    arr[j]=arr[j]-1;
                    count++;
                }
            }
        }
        return new String(ans);
    }
}",None,"class Solution {
    public String sortString(String s) {
        int[] arr = new int[26];
        String str = ""abcdefghijklmnopqrstuvwxyz"";
        for(int i=0;i<s.length();i++){
            int num = str.indexOf((s.charAt(i)));
            arr[num]=arr[num]+1;
        }

        int len = s.length();
        int count=0;
        StringBuilder ans = new StringBuilder();

        while(count<len){
            for(int i=0;i<26;i++){
                if(arr[i]>0){
                    ans.append(str.charAt(i));
                    arr[i]=arr[i]-1;
                    count++;
                }
            }
            for(int j=25;j>=0;j--){
                if(arr[j]>0){
                    ans.append(str.charAt(j));
                    arr[j]=arr[j]-1;
                    count++;
                }
            }
        }
        return new String(ans);
    }
}
"
1455,java,increasing-decreasing-string,"class Solution {
    public String sortString(String s) {
        int[] arr = new int[27];
        String str = ""abcdefghijklmnopqrstuvwxyz"";
        for(int i=0;i<s.length();i++){
            int num = str.indexOf((s.charAt(i)));
            arr[num]=arr[num]+1; 
            ++num; 
        }

        int len = s.length();
        int count=0;
        StringBuilder ans = new StringBuilder();

        while(count<len){
            for(int i=1;i<27;i++){
                if(arr[i]>0){
                    ans.append(str.charAt(i - 1));
                    arr[i]=arr[i]-1;
                    count++;
                }
            }
            for(int j=26;j>=1;j--){
                if(arr[j]>0){
                    ans.append(str.charAt(j - 1));
                    arr[j]=arr[j]-1;
                    count++;
                }
            }
        }
        return new String(ans);
    }
}",None,"class Solution {
    public String sortString(String s) {
        int[] arr = new int[26];
        String str = ""abcdefghijklmnopqrstuvwxyz"";
        for(int i=0;i<s.length();i++){
            int num = str.indexOf((s.charAt(i)));
            arr[num]=arr[num]+1;  
        }

        int len = s.length();
        int count=0;
        StringBuilder ans = new StringBuilder();

        while(count<len){
            for(int i=0;i<26;i++){
                if(arr[i]>0){
                    ans.append(str.charAt(i));
                    arr[i]=arr[i]-1;
                    count++;
                }
            }
            for(int j=25;j>=0;j--){
                if(arr[j]>0){
                    ans.append(str.charAt(j));
                    arr[j]=arr[j]-1;
                    count++;
                }
            }
        }
        return new String(ans);
    }
}
"
1455,java,increasing-decreasing-string,"class Solution {
    public String sortString(String s) {
        int[] arr = new int[27];
        String str = ""abcdefghijklmnopqrstuvwxyz"";
        for(int i=0;i<s.length();i++){
            int num = str.indexOf((s.charAt(i)));
            arr[num]=arr[num]+1; 
            ++num; 
        }

        int len = s.length();
        int count=0;
        StringBuilder ans = new StringBuilder();

        while(count<len){
            for(int i=1;i<27;i++){
                if(arr[i]>0){
                    ans.append(str.charAt(i - 1));
                    arr[i]=arr[i]-1;
                    count++;
                }
            }
            for(int j=26;j>=1;j--){
                if(arr[j]>0){
                    ans.append(str.charAt(j - 1));
                    arr[j]=arr[j]-1;
                    count++;
                }
            }
        }
        return new String(ans);
    }
}",None,"class Solution {
    public String sortString(String s) {
        int[] arr = new int[26];
        String str = ""abcdefghijklmnopqrstuvwxyz"";
        for(int i=0;i<s.length();i++){
            int num = str.indexOf((s.charAt(i)));
            arr[num]=arr[num]+1; 
        }

        int len = s.length();
        int count=0;
        StringBuilder ans = new StringBuilder();

        while(count<len){
            for(int i=0;i<26;i++){
                if(arr[i]>0){
                    ans.append(str.charAt(i));
                    arr[i]=arr[i]-1;
                    count++;
                }
            }
            for(int j=25;j>=0;j--){
                if(arr[j]>0){
                    ans.append(str.charAt(j));
                    arr[j]=arr[j]-1;
                    count++;
                }
            }
        }
        return new String(ans);
    }
}
"
1456,java,count-odd-numbers-in-an-interval-range,"class Solution {
    public int countOdds(int low, int high) {
        if(low%2==0 && high%2==0)
            return (high-low)/2+1;
        else
            return (high-low)/2+1;
    }
}",None,"class Solution {
    public int countOdds(int low, int high) {
        if(low%2==0 && high%2==0)
            return (high-low)/2;
        else
            return (high-low)/2+1;
    }
}
"
1456,java,count-odd-numbers-in-an-interval-range,"class Solution {
    public int countOdds(int low, int high) {
        if(low%2==0 && high%2==0)
            return (high-low)/2+1;
        else
            return (high-low)/2+1;
    }
}",None,"class Solution {
    public int countOdds(int low, int high) {
        if(low%2!=0 || high%2!=0)
            return (high-low)/2+1;
        else
            return (high-low)/2;
    }
}
"
1456,java,count-odd-numbers-in-an-interval-range,"class Solution {
    public int countOdds(int low, int high) {
        if(low%2==0 && high%2==0)
            return (high-low)/2+1;
        else
            return (high-low)/2+1;
    }
}",None,"class Solution {
    public int countOdds(int low, int high) {
        if(low%2==0 && high%2==0)
            return (high-low)/2;
        else
            return (high-low)/2+1;
    }
}
"
1457,java,mirror-reflection,"class Solution {
    public int mirrorReflection(int p, int q) {
        while(((p|q)&1) == 0){
            p >>= 1;
            q <<= 1;
        }
        return (q&1) + ((p&1)^1);
    }
}",None,"class Solution {
    public int mirrorReflection(int p, int q) {
        while(((p|q)&1) == 0){
            p >>= 1;
            q >>= 1;
        }
        return (q&1) + ((p&1)^1);
    }
}
"
1457,java,mirror-reflection,"class Solution {
    public int mirrorReflection(int p, int q) {
        while(((p|q)&1) == 0){
            p >>= 1;
            q <<= 1;
        }
        return (q&1) + ((p&1)^1);
    }
}",None,"class Solution {
    public int mirrorReflection(int p, int q) {
        while(p % 2 == 0 && q % 2 == 0){
            p /= 2;
            q /= 2;
        }
        if(p % 2 == 0) return 0;
        if(q % 2 == 0) return 1;
        return 2;
    }
}
"
1457,java,mirror-reflection,"class Solution {
    public int mirrorReflection(int p, int q) {
        while(((p|q)&1) == 0){
            p >>= 1;
            q <<= 1;
        }
        return (q&1) + ((p&1)^1);
    }
}",None,"class Solution {
    public int mirrorReflection(int p, int q) {
        while((p % 2) == 0 && (q % 2) == 0){
            p /= 2;
            q /= 2;
        }
        if (p % 2 == 0 && q % 2 != 0){
            return 2;
        }
        else if (p % 2 != 0 && q % 2 == 0){
            return 0;
        }
        else {
            return 1;
        }
    }
}
"
1458,java,diagonal-traverse-ii,"class Solution {
    public int[] findDiagonalOrder(List<List<Integer>> nums) {
        int m = nums.size(), maxSum = 0, size = 0, index = 0;
        List<Integer>[] map = new ArrayList[100001];
        for (int i = 0; i < m; i++) {
            size += nums.get(i).size();
            for (int j = 0; j < nums.get(i).size(); j++) {
                int sum = i + j;
                if (map[sum] == null) map[sum] = new ArrayList<>();
                map[sum].add(nums.get(i).get(j));
                maxSum = Math.max(maxSum, j);
            }
        }
        int[] res = new int[size];
        for (int i = 0; i <= maxSum; i++) {
            List<Integer> cur = map[i];
            for (int j = cur.size() - 1; j >= 0; j--) {
                res[index++] = cur.get(j);
            }
        }
        return res;
    }
}",None,"class Solution {
    public int[] findDiagonalOrder(List<List<Integer>> nums) {
        int m = nums.size(), maxSum = 0, size = 0, index = 0;
        List<Integer>[] map = new ArrayList[200001];
        for (int i = 0; i < m; i++) {
            size += nums.get(i).size();
            for (int j = 0; j < nums.get(i).size(); j++) {
                int sum = i + j;
                if (map[sum] == null) map[sum] = new ArrayList<>();
                map[sum].add(nums.get(i).get(j));
                maxSum = Math.max(maxSum, sum);
            }
        }
        int[] res = new int[size];
        for (int i = 0; i <= maxSum; i++) {
            List<Integer> cur = map[i];
            for (int j = cur.size() - 1; j >= 0; j--) {
                res[index++] = cur.get(j);
            }
        }
        return res;
    }
}
"
1458,java,diagonal-traverse-ii,"class Solution {
    public int[] findDiagonalOrder(List<List<Integer>> nums) {
        int m = nums.size(), maxSum = 0, size = 0, index = 0;
        List<Integer>[] map = new ArrayList[100001];
        for (int i = 0; i < m; i++) {
            size += nums.get(i).size();
            for (int j = 0; j < nums.get(i).size(); j++) {
                int sum = i + j;
                if (map[sum] == null) map[sum] = new ArrayList<>();
                map[sum].add(nums.get(i).get(j));
                maxSum = Math.max(maxSum, j);
            }
        }
        int[] res = new int[size];
        for (int i = 0; i <= maxSum; i++) {
            List<Integer> cur = map[i];
            for (int j = cur.size() - 1; j >= 0; j--) {
                res[index++] = cur.get(j);
            }
        }
        return res;
    }
}",None,"class Solution {
    public int[] findDiagonalOrder(List<List<Integer>> nums) {
        int size = 0, index = 0;
        Map<Integer, List<Integer>> map = new HashMap<>();
        int maxKey = 0;
        for (int i = 0; i < nums.size(); i++) {
            for (int j = 0; j < nums.get(i).size(); j++) {
                size++;
                int key = i + j;
                if (!map.containsKey(key)) {
                    map.put(key, new ArrayList<>());
                }
                map.get(key).add(nums.get(i).get(j));
                maxKey = Math.max(maxKey, key);
            }
        }
        int[] res = new int[size];
        for (int i = 0; i <= maxKey; i++) {
            if (map.containsKey(i)) {
                List<Integer> cur = map.get(i);
                for (int k = cur.size() - 1; k >= 0; k--) {
                    res[index++] = cur.get(k);
                }
            }
        }
        return res;
    }
}
"
1458,java,diagonal-traverse-ii,"class Solution {
    public int[] findDiagonalOrder(List<List<Integer>> nums) {
        int m = nums.size(), maxSum = 0, size = 0, index = 0;
        List<Integer>[] map = new ArrayList[100001];
        for (int i = 0; i < m; i++) {
            size += nums.get(i).size();
            for (int j = 0; j < nums.get(i).size(); j++) {
                int sum = i + j;
                if (map[sum] == null) map[sum] = new ArrayList<>();
                map[sum].add(nums.get(i).get(j));
                maxSum = Math.max(maxSum, j);
            }
        }
        int[] res = new int[size];
        for (int i = 0; i <= maxSum; i++) {
            List<Integer> cur = map[i];
            for (int j = cur.size() - 1; j >= 0; j--) {
                res[index++] = cur.get(j);
            }
        }
        return res;
    }
}",None,"class Solution {
    public int[] findDiagonalOrder(List<List<Integer>> nums) {
        int m = nums.size(), maxSize = 0, size = 0, index = 0;
        List<Integer>[] map = new ArrayList[100001];
        for (int i = 0; i < m; i++) {
            size += nums.get(i).size();
            for (int j = 0; j < nums.get(i).size(); j++) {
                int sum = i + j;
                if (map[sum] == null) map[sum] = new ArrayList<>();
                map[sum].add(nums.get(i).get(j));
                maxSize = Math.max(maxSize, sum);
            }
        }
        int[] res = new int[size];
        for (int i = 0; i <= maxSize; i++) {
            if (map[i] != null) {
                List<Integer> cur = map[i];
                for (int j = cur.size() - 1; j >= 0; j--) {
                    res[index++] = cur.get(j);
                }
            }    
        }
        return res;
    }
}
"
1459,java,maximal-score-after-applying-k-operations,"class Solution {
    public long maxKelements(int[] nums, int k) {
    PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
        public int compare(Integer a, Integer b) {
            return b - a;
        }
    });
    
    for (int num : nums) {
        pq.add(num);
    }
        
    long score = 0;
    
    for (int i = 0; i < k; i++) {
        int max = pq.poll();
        
        score += max;
        
        pq.add((int) Math.ceil(max / 4.0));
    }
    
    return score;
    }
}",None,"class Solution {
    public long maxKelements(int[] nums, int k) {
    PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
        public int compare(Integer a, Integer b) {
            return b - a;
        }
    });
    
    for (int num : nums) {
        pq.add(num);
    }
        
    long score = 0;
    
    for (int i = 0; i < k; i++) {
        int max = pq.poll();
        
        score += max;
        
        pq.add((int) Math.ceil(max / 3.0));
    }
    
    return score;
    }
}
"
1459,java,maximal-score-after-applying-k-operations,"class Solution {
    public long maxKelements(int[] nums, int k) {
    PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
        public int compare(Integer a, Integer b) {
            return b - a;
        }
    });
    
    for (int num : nums) {
        pq.add(num);
    }
        
    long score = 0;
    
    for (int i = 0; i < k; i++) {
        int max = pq.poll();
        
        score += max;
        
        pq.add((int) Math.ceil(max / 4.0));
    }
    
    return score;
    }
}",None,"class Solution {
    public long maxKelements(int[] nums, int k) {
    PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
        public int compare(Integer a, Integer b) {
            return b - a;
        }
    });
    
    for (int num : nums) {
        pq.add(num);
    }
        
    long score = 0;
    
    for (int i = 0; i < k; i++) {
        int max = pq.poll();
        
        score += max;
        
        pq.add((int) Math.ceil(max / 3.0));
    }
    
    return score;
    }
}
"
1459,java,maximal-score-after-applying-k-operations,"class Solution {
    public long maxKelements(int[] nums, int k) {
    PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
        public int compare(Integer a, Integer b) {
            return b - a;
        }
    });
    
    for (int num : nums) {
        pq.add(num);
    }
        
    long score = 0;
    
    for (int i = 0; i < k; i++) {
        int max = pq.poll();
        
        score += max;
        
        pq.add((int) Math.ceil(max / 4.0));
    }
    
    return score;
    }
}",None,"class Solution {
    public long maxKelements(int[] nums, int k) {
    PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
        public int compare(Integer a, Integer b) {
            return b - a;
        }
    });
    
    for (int num : nums) {
        pq.add(num);
    }
        
    long score = 0;
    
    for (int i = 0; i < k; i++) {
        int max = pq.poll();
        
        score += max;
        
        pq.add((int) Math.ceil(max / 3.0));
    }
    
    return score;
    }
}
"
1460,java,search-insert-position,"class Solution {
    public int searchInsert(int[] nums, int target) {
        ArrayList<Integer>atr=new ArrayList<>();
        for(int a:nums){
            atr.add(a);
        }
        atr.add(target);
        Collections.sort(atr);
        atr.remove(target);
        int k=atr.indexOf(target);
        return k;
        
    }
}",None,"class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int middle = left + (right - left) / 2;
            if (nums[middle] == target) {
                return middle;
            } else if (nums[middle] < target) {
                left = middle + 1;
            } else {
                right = middle - 1;
            }
        }
        return left;
    }
}
"
1460,java,search-insert-position,"class Solution {
    public int searchInsert(int[] nums, int target) {
        ArrayList<Integer>atr=new ArrayList<>();
        for(int a:nums){
            atr.add(a);
        }
        atr.add(target);
        Collections.sort(atr);
        atr.remove(target);
        int k=atr.indexOf(target);
        return k;
        
    }
}",None,"class Solution {
    public int searchInsert(int[] nums, int target) {
        int start = 0, end = nums.length - 1;
        while(start <= end) {
            int mid = start + (end - start) / 2;
            if(target == nums[mid]) return mid;
            else if(target < nums[mid]) end = mid - 1;
            else start = mid + 1;
        }
        return start;
    }
}
"
1460,java,search-insert-position,"class Solution {
    public int searchInsert(int[] nums, int target) {
        ArrayList<Integer>atr=new ArrayList<>();
        for(int a:nums){
            atr.add(a);
        }
        atr.add(target);
        Collections.sort(atr);
        atr.remove(target);
        int k=atr.indexOf(target);
        return k;
        
    }
}",None,"class Solution {
    public int searchInsert(int[] nums, int target) {
       int left=0;
       int right=nums.length-1;

       while(left<=right){
           int mid=(left+right)/2;

           if(target==nums[mid]) return mid;
           else if(target>nums[mid]) left=mid+1;
           else right=mid-1;
       }
       return left;
    }
}
"
1461,java,the-number-of-weak-characters-in-the-game,"class Solution {
    public int numberOfWeakCharacters(int[][] properties) {
        Arrays.sort(properties, (a,b) -> (a[0] == b[0]) ? (b[1]-a[1]) : (b[0]-a[0]));
        int count = 0, max = 0;
        for(int[] arr: properties){
            if(arr[1] < max)    count++;
            max = Math.max(max, arr[1]);
        }
        return count;
    }
}",None,"class Solution {
    public int numberOfWeakCharacters(int[][] properties) {
        Arrays.sort(properties, (a,b) -> (a[0] == b[0]) ? (b[1]-a[1]) : (a[0]-b[0]));
        int count = 0, max = 0;
        for(int i = properties.length - 1; i >= 0; i--){
            if(properties[i][1] < max)    count++;
            else max = properties[i][1];
        }
        return count;
    }
}
"
1461,java,the-number-of-weak-characters-in-the-game,"class Solution {
    public int numberOfWeakCharacters(int[][] properties) {
        Arrays.sort(properties, (a,b) -> (a[0] == b[0]) ? (b[1]-a[1]) : (b[0]-a[0]));
        int count = 0, max = 0;
        for(int[] arr: properties){
            if(arr[1] < max)    count++;
            max = Math.max(max, arr[1]);
        }
        return count;
    }
}",None,"class Solution {
    public int numberOfWeakCharacters(int[][] properties) {
        Arrays.sort(properties, (a,b) -> (a[0] == b[0]) ? (b[1]-a[1]) : (a[0]-b[0]));
        int count = 0, max = 0;
        for(int i = properties.length - 1; i >= 0; i--){
            if(properties[i][1] < max) count++;
            else max = properties[i][1];
        }
        return count;
    }
}
"
1461,java,the-number-of-weak-characters-in-the-game,"class Solution {
    public int numberOfWeakCharacters(int[][] properties) {
        Arrays.sort(properties, (a,b) -> (a[0] == b[0]) ? (b[1]-a[1]) : (b[0]-a[0]));
        int count = 0, max = 0;
        for(int[] arr: properties){
            if(arr[1] < max)    count++;
            max = Math.max(max, arr[1]);
        }
        return count;
    }
}",None,"class Solution {
    public int numberOfWeakCharacters(int[][] properties) {
        Arrays.sort(properties, (a,b) -> (a[0] == b[0]) ? (b[1]-a[1]) : (a[0]-b[0]));
        int count = 0, max = 0;
        for(int i = properties.length - 1; i >= 0; i--){
            if(properties[i][1] < max) count++;
            else max = properties[i][1];
        }
        return count;
    }
}
"
1462,java,sum-of-mutated-array-closest-to-target,"class Solution {
    public int findBestValue(int[] arr, int target) {
      int n = arr.length;
        int lo = 0, hi = 0;
        for (int i = 0; i < n; i++) {
            hi = Math.max(hi, arr[i]);
        }
        
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            int sum = 0;
            for (int i = 0; i < n; i++) {
                sum += Math.max(arr[i], mid);
            }
            if (sum >= target) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        
        int sum1 = 0, sum2 = 0;
        for (int i = 0; i < n; i++) {
            sum1 += Math.min(arr[i], lo);
            sum2 += Math.min(arr[i], lo - 1);
        }
        
        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;
    }
}",None,"class Solution {
    public int findBestValue(int[] arr, int target) {
      int n = arr.length;
        int lo = 0, hi = 0;
        for (int i = 0; i < n; i++) {
            hi = Math.max(hi, arr[i]);
        }
        
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            int sum = 0;
            for (int i = 0; i < n; i++) {
                sum += Math.min(arr[i], mid);
            }
            if (sum >= target) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        
        int sum1 = 0, sum2 = 0;
        for (int i = 0; i < n; i++) {
            sum1 += Math.min(arr[i], lo);
            sum2 += Math.min(arr[i], lo - 1);
        }
        
        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;
    }
}
"
1462,java,sum-of-mutated-array-closest-to-target,"class Solution {
    public int findBestValue(int[] arr, int target) {
      int n = arr.length;
        int lo = 0, hi = 0;
        for (int i = 0; i < n; i++) {
            hi = Math.max(hi, arr[i]);
        }
        
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            int sum = 0;
            for (int i = 0; i < n; i++) {
                sum += Math.max(arr[i], mid);
            }
            if (sum >= target) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        
        int sum1 = 0, sum2 = 0;
        for (int i = 0; i < n; i++) {
            sum1 += Math.min(arr[i], lo);
            sum2 += Math.min(arr[i], lo - 1);
        }
        
        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;
    }
}",None,"class Solution {
    public int findBestValue(int[] arr, int target) {
      int n = arr.length;
        int lo = 0, hi = 0;
        for (int i = 0; i < n; i++) {
            hi = Math.max(hi, arr[i]);
        }
        
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            int sum = 0;
            for (int i = 0; i < n; i++) {
                sum += Math.min(arr[i], mid);
            }
            if (sum >= target) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        
        int sum1 = 0, sum2 = 0;
        for (int i = 0; i < n; i++) {
            sum1 += Math.min(arr[i], lo);
            sum2 += Math.min(arr[i], lo - 1);
        }
        
        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;
    }
}
"
1462,java,sum-of-mutated-array-closest-to-target,"class Solution {
    public int findBestValue(int[] arr, int target) {
      int n = arr.length;
        int lo = 0, hi = 0;
        for (int i = 0; i < n; i++) {
            hi = Math.max(hi, arr[i]);
        }
        
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            int sum = 0;
            for (int i = 0; i < n; i++) {
                sum += Math.max(arr[i], mid);
            }
            if (sum >= target) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        
        int sum1 = 0, sum2 = 0;
        for (int i = 0; i < n; i++) {
            sum1 += Math.min(arr[i], lo);
            sum2 += Math.min(arr[i], lo - 1);
        }
        
        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;
    }
}",None,"class Solution {
    public int findBestValue(int[] arr, int target) {
      int n = arr.length;
        int lo = 0, hi = 0;
        for (int i = 0; i < n; i++) {
            hi = Math.max(hi, arr[i]);
        }
        
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            int sum = 0;
            for (int i = 0; i < n; i++) {
                sum += Math.min(arr[i], mid);
            }
            if (sum >= target) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        
        int sum1 = 0, sum2 = 0;
        for (int i = 0; i < n; i++) {
            sum1 += Math.min(arr[i], lo);
            sum2 += Math.min(arr[i], lo - 1);
        }
        
        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;
    }
}
"
1463,java,max-sum-of-rectangle-no-larger-than-k,"class Solution {
    public int maxSumSubmatrix(int[][] matrix, int k) {
        int result = Integer.MIN_VALUE;
        
        for(int left =0 ;left<matrix[0].length; left++){
            
            int[] rSum = new int[matrix.length];
            
            for(int right = left;right<matrix[0].length;right++){
                for(int row=0; row < matrix.length; row++)
                    rSum[row] -= matrix[row][right];
                
                TreeSet<Integer> set = new TreeSet<>();
                
                set.add(0);
                int cs = 0;
                
                for(int a: rSum){
                    cs += a;
                    
                    Integer target = set.ceiling(cs-k);
                    
                    if(target !=null)
                        result = Math.max(result,cs-target);
                    set.add(cs);
                }
            }
        }
        return result;
    }
}",None,"class Solution {
    public int maxSumSubmatrix(int[][] matrix, int k) {
        int result = Integer.MIN_VALUE;
        
        for(int left =0 ;left<matrix[0].length; left++){
            
            int[] rSum = new int[matrix.length];
            
            for(int right = left;right<matrix[0].length;right++){
                for(int row=0; row < matrix.length; row++)
                    rSum[row] += matrix[row][right];
                
                TreeSet<Integer> set = new TreeSet<>();
                
                set.add(0);
                int cs = 0;
                
                for(int a: rSum){
                    cs += a;
                    
                    Integer target = set.ceiling(cs-k);
                    
                    if(target !=null)
                        result = Math.max(result,cs-target);
                    set.add(cs);
                }
            }
        }
        return result;
    }
}
"
1463,java,max-sum-of-rectangle-no-larger-than-k,"class Solution {
    public int maxSumSubmatrix(int[][] matrix, int k) {
        int result = Integer.MIN_VALUE;
        
        for(int left =0 ;left<matrix[0].length; left++){
            
            int[] rSum = new int[matrix.length];
            
            for(int right = left;right<matrix[0].length;right++){
                for(int row=0; row < matrix.length; row++)
                    rSum[row] -= matrix[row][right];
                
                TreeSet<Integer> set = new TreeSet<>();
                
                set.add(0);
                int cs = 0;
                
                for(int a: rSum){
                    cs += a;
                    
                    Integer target = set.ceiling(cs-k);
                    
                    if(target !=null)
                        result = Math.max(result,cs-target);
                    set.add(cs);
                }
            }
        }
        return result;
    }
}",None,"class Solution {
    public int maxSumSubmatrix(int[][] matrix, int k) {
        int result = Integer.MIN_VALUE;
        
        for(int left =0 ;left<matrix[0].length; left++){
            
            int[] rSum = new int[matrix.length];
            
            for(int right = left;right<matrix[0].length;right++){
                for(int row=0; row < matrix.length; row++)
                    rSum[row] += matrix[row][right];
                
                TreeSet<Integer> set = new TreeSet<>();
                
                set.add(0);
                int cs = 0;
                
                for(int a: rSum){
                    cs += a;
                    
                    Integer target = set.ceiling(cs-k);
                    
                    if(target !=null)
                        result = Math.max(result,cs-target);
                    set.add(cs);
                }
            }
        }
        return result;
    }
}
"
1463,java,max-sum-of-rectangle-no-larger-than-k,"class Solution {
    public int maxSumSubmatrix(int[][] matrix, int k) {
        int result = Integer.MIN_VALUE;
        
        for(int left =0 ;left<matrix[0].length; left++){
            
            int[] rSum = new int[matrix.length];
            
            for(int right = left;right<matrix[0].length;right++){
                for(int row=0; row < matrix.length; row++)
                    rSum[row] -= matrix[row][right];
                
                TreeSet<Integer> set = new TreeSet<>();
                
                set.add(0);
                int cs = 0;
                
                for(int a: rSum){
                    cs += a;
                    
                    Integer target = set.ceiling(cs-k);
                    
                    if(target !=null)
                        result = Math.max(result,cs-target);
                    set.add(cs);
                }
            }
        }
        return result;
    }
}",None,"class Solution {
    public int maxSumSubmatrix(int[][] matrix, int k) {
        int result = Integer.MIN_VALUE;
        
        for(int left =0 ;left<matrix[0].length; left++){
            
            int[] rSum = new int[matrix.length];
            
            for(int right = left;right<matrix[0].length;right++){
                for(int row=0; row < matrix.length; row++)
                    rSum[row] += matrix[row][right];
                
                TreeSet<Integer> set = new TreeSet<>();
                
                set.add(0);
                int cs = 0;
                
                for(int a: rSum){
                    cs += a;
                    
                    Integer target = set.ceiling(cs-k);
                    
                    if(target !=null)
                        result = Math.max(result,cs-target);
                    set.add(cs);
                }
            }
        }
        return result;
    }
}
"
1464,java,maximum-sum-with-exactly-k-elements,"class Solution {
    public int maximizeSum(int[] nums, int k) {
        int max = 0;
        for(int i = 0; i<nums.length; i++){ 
            max = Math.max(max, nums[i]);
        }
        
        int ans = 0;
        while(k>0){
            ans+=max;
            max = max-1;
            k--;
        }
        return ans;
    }   
}",None,"class Solution {
    public int maximizeSum(int[] nums, int k) {
        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
        for (int num : nums) {
            pq.add(num);
        }
        
        int ans = 0;
        while(k > 0){
            int max = pq.poll();
            ans += max;
            pq.offer(max + 1);
            k--;
        }

        return ans;
    }   
}
"
1464,java,maximum-sum-with-exactly-k-elements,"class Solution {
    public int maximizeSum(int[] nums, int k) {
        int max = 0;
        for(int i = 0; i<nums.length; i++){ 
            max = Math.max(max, nums[i]);
        }
        
        int ans = 0;
        while(k>0){
            ans+=max;
            max = max-1;
            k--;
        }
        return ans;
    }   
}",None,"class Solution {
    public int maximizeSum(int[] nums, int k) {
        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);

        for (int num : nums){
            pq.add(num);
        }
        
        int ans = 0;
        while (k-- > 0){
            int max = (int)pq.poll();
            ans += max;
            pq.add(max + 1);
        }

        return ans;
    }
}
"
1464,java,maximum-sum-with-exactly-k-elements,"class Solution {
    public int maximizeSum(int[] nums, int k) {
        int max = 0;
        for(int i = 0; i<nums.length; i++){ 
            max = Math.max(max, nums[i]);
        }
        
        int ans = 0;
        while(k>0){
            ans+=max;
            max = max-1;
            k--;
        }
        return ans;
    }   
}",None,"class Solution {
    public int maximizeSum(int[] nums, int k) {
        PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());
        for (int num : nums) {
            queue.add(num);
        }

        int ans = 0;
        while (k > 0) {
            int max = queue.poll();
            ans += max;
            queue.add(max + 1);
            k--;
        }

        return ans;
    }
}
"
1465,java,first-completely-painted-row-or-column,"class Solution {
    public int firstCompleteIndex(int[] arr, int[][] mat) {
        int ind=0;
        int m=mat.length,n=mat[0].length;
        int row[]=new int[m];
        int col[]=new int[n];
        boolean flag=true;;
        while(flag){
            int i=0;
            for(i=0;i<m;i++){
                int j=0;
                for(j=0;j<n;j++){
                    if(mat[i][j]==arr[ind]){
                        ind++;
                        row[i]++;
                        col[j]++;
                        if(row[i]==n || col[j]==m){
                            flag=false;
                            break;
                        }
                    }
                }
                if(!flag)   break;
            }
        }
       return ind+1;
    }
}",None,"class Solution {
    public int firstCompleteIndex(int[] arr, int[][] mat) {
        int ind=0;
        int m=mat.length,n=mat[0].length;
        int row[]=new int[m];
        int col[]=new int[n];
        
        Map<Integer,Integer> map= new HashMap<>();
        
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
               map.put(mat[i][j], i*n+j);
            }
        }
    
        while(ind<m*n){
            int pos= map.get(arr[ind]);
            int i=pos/n;
            int j=pos%n;
            row[i]++;
            col[j]++;
            if(row[i]==n || col[j]==m) return ind;
            ind++;
        }
       return -1;
    }
}
"
1465,java,first-completely-painted-row-or-column,"class Solution {
    public int firstCompleteIndex(int[] arr, int[][] mat) {
        int ind=0;
        int m=mat.length,n=mat[0].length;
        int row[]=new int[m];
        int col[]=new int[n];
        boolean flag=true;;
        while(flag){
            int i=0;
            for(i=0;i<m;i++){
                int j=0;
                for(j=0;j<n;j++){
                    if(mat[i][j]==arr[ind]){
                        ind++;
                        row[i]++;
                        col[j]++;
                        if(row[i]==n || col[j]==m){
                            flag=false;
                            break;
                        }
                    }
                }
                if(!flag)   break;
            }
        }
       return ind+1;
    }
}",None,"class Solution {
    public int firstCompleteIndex(int[] arr, int[][] mat) {
        int m=mat.length, n=mat[0].length;
        int[][] pos = new int[m*n+1][2];
        int[] row = new int[m], col = new int[n];
        for(int i=0;i<m;i++) {
            for(int j=0;j<n;j++) {
                pos[mat[i][j]][0] = i;
                pos[mat[i][j]][1] = j;
            }
        }
        for(int i=0;i<arr.length;i++) {
            int x = pos[arr[i]][0],y = pos[arr[i]][1];
            row[x]++;
            col[y]++;
            if(row[x] == n  || col[y] == m) return i;
        }
        return arr.length;
    }
}
"
1465,java,first-completely-painted-row-or-column,"class Solution {
    public int firstCompleteIndex(int[] arr, int[][] mat) {
        int ind=0;
        int m=mat.length,n=mat[0].length;
        int row[]=new int[m];
        int col[]=new int[n];
        boolean flag=true;;
        while(flag){
            int i=0;
            for(i=0;i<m;i++){
                int j=0;
                for(j=0;j<n;j++){
                    if(mat[i][j]==arr[ind]){
                        ind++;
                        row[i]++;
                        col[j]++;
                        if(row[i]==n || col[j]==m){
                            flag=false;
                            break;
                        }
                    }
                }
                if(!flag)   break;
            }
        }
       return ind+1;
    }
}",None,"class Solution {
    public int firstCompleteIndex(int[] arr, int[][] mat) {
        int m=mat.length,n=mat[0].length;
        int row[]=new int[m];
        int col[]=new int[n];
        int ind=0;
        Map<Integer, int[]> map = new HashMap<>();
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                map.put(mat[i][j], new int[]{i, j});
            }
        }
        for(ind=0; ind<arr.length; ind++){
            int[] point = map.get(arr[ind]);
            row[point[0]]++;
            col[point[1]]++;
            if(row[point[0]]==n || col[point[1]]==m) break;
        }
       return ind;
    }
}
"
1466,java,lexicographically-smallest-equivalent-string,"class Solution {
    public String smallestEquivalentString(String s1, String s2, String baseStr) {
        
        UFDS dsu = new UFDS(26);
        for(int i = 0; i < s1.length(); i++){
            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);
        }

        StringBuilder sb = new StringBuilder(); 

        for(int i = 0; i < baseStr.length(); i++){
            int root = dsu.root(baseStr.charAt(i) - 97);
            sb.append((char)(dsu.min[root] + 97));
        }
        return sb.reverse().toString();
    }
    
    class UFDS{
        
        int[] id;
        int[] size;
        int[] min;
        
        public UFDS(int N){
            
            id = new int[N];
            size = new int[N];
            min = new int[N];
            for(int i = 0; i < N; i++){
                id[i] = i;
                size[i] = 1;
                min[i] = i;
            }
        }
        
        private int root(int i){
            while (i != id[i]){
                id[i] = id[id[i]];
                i = id[i];
            }
            return i;
        }
        
        public void union(int p, int q){
            
            int i = root(p);
            int j = root(q);
            if(i == j)return;
            if(size[i] < size[j]){
                id[i] = id[j];
                size[j] += size[i];
                min[j] = Math.min(min[i],min[j]);
            }
            else{
                id[j] = id[i];
                size[i] += size[j];
                min[i] = Math.min(min[i],min[j]);
            }
        }

    }   
}",None,"class Solution {
    public String smallestEquivalentString(String s1, String s2, String baseStr) {
        
        UFDS dsu = new UFDS(26);
        for(int i = 0; i < s1.length(); i++){
            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);
        }
        
        StringBuilder sb = new StringBuilder(); 
        for(int i = 0; i < baseStr.length(); i++){
            int root = dsu.root(baseStr.charAt(i) - 97);
            sb.append((char)(dsu.min[root] + 97));
        }
        return sb.toString();
    }
    
    class UFDS{
        
        int[] id;
        int[] size;
        int[] min;
        
        public UFDS(int N){
            
            id = new int[N];
            size = new int[N];
            min = new int[N];
            for(int i = 0; i < N; i++){
                id[i] = i;
                size[i] = 1;
                min[i] = i;
            }
        }
        
        private int root(int i){
            while (i != id[i]){
                id[i] = id[id[i]];
                i = id[i];
            }
            return i;
        }
        
        public void union(int p, int q){
            
            int i = root(p);
            int j = root(q);
            if(i == j)return;
            if(size[i] < size[j]){
                id[i] = id[j];
                size[j] += size[i];
                min[j] = Math.min(min[i],min[j]);
            }
            else{
                id[j] = id[i];
                size[i] += size[j];
                min[i] = Math.min(min[i],min[j]);
            }
        }
    }   
}
"
1466,java,lexicographically-smallest-equivalent-string,"class Solution {
    public String smallestEquivalentString(String s1, String s2, String baseStr) {
        
        UFDS dsu = new UFDS(26);
        for(int i = 0; i < s1.length(); i++){
            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);
        }

        StringBuilder sb = new StringBuilder(); 

        for(int i = 0; i < baseStr.length(); i++){
            int root = dsu.root(baseStr.charAt(i) - 97);
            sb.append((char)(dsu.min[root] + 97));
        }
        return sb.reverse().toString();
    }
    
    class UFDS{
        
        int[] id;
        int[] size;
        int[] min;
        
        public UFDS(int N){
            
            id = new int[N];
            size = new int[N];
            min = new int[N];
            for(int i = 0; i < N; i++){
                id[i] = i;
                size[i] = 1;
                min[i] = i;
            }
        }
        
        private int root(int i){
            while (i != id[i]){
                id[i] = id[id[i]];
                i = id[i];
            }
            return i;
        }
        
        public void union(int p, int q){
            
            int i = root(p);
            int j = root(q);
            if(i == j)return;
            if(size[i] < size[j]){
                id[i] = id[j];
                size[j] += size[i];
                min[j] = Math.min(min[i],min[j]);
            }
            else{
                id[j] = id[i];
                size[i] += size[j];
                min[i] = Math.min(min[i],min[j]);
            }
        }

    }   
}",None,"class Solution {
    public String smallestEquivalentString(String s1, String s2, String baseStr) {
        
        UFDS dsu = new UFDS(26);
        for(int i = 0; i < s1.length(); i++){
            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);
        }

        StringBuilder sb = new StringBuilder(); 

        for(int i = 0; i < baseStr.length(); i++){
            int root = dsu.root(baseStr.charAt(i) - 97);
            sb.append((char)(dsu.min[root] + 97));
        }
        return sb.toString();
    }
    
    class UFDS{
        
        int[] id;
        int[] size;
        int[] min;
        
        public UFDS(int N){
            
            id = new int[N];
            size = new int[N];
            min = new int[N];
            for(int i = 0; i < N; i++){
                id[i] = i;
                size[i] = 1;
                min[i] = i;
            }
        }
        
        private int root(int i){
            while (i != id[i]){
                id[i] = id[id[i]];
                i = id[i];
            }
            return i;
        }
        
        public void union(int p, int q){
            
            int i = root(p);
            int j = root(q);
            if(i == j)return;
            if(size[i] < size[j]){
                id[i] = id[j];
                size[j] += size[i];
                min[j] = Math.min(min[i],min[j]);
            }
            else{
                id[j] = id[i];
                size[i] += size[j];
                min[i] = Math.min(min[i],min[j]);
            }
        }

    }   
}
"
1466,java,lexicographically-smallest-equivalent-string,"class Solution {
    public String smallestEquivalentString(String s1, String s2, String baseStr) {
        
        UFDS dsu = new UFDS(26);
        for(int i = 0; i < s1.length(); i++){
            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);
        }

        StringBuilder sb = new StringBuilder(); 

        for(int i = 0; i < baseStr.length(); i++){
            int root = dsu.root(baseStr.charAt(i) - 97);
            sb.append((char)(dsu.min[root] + 97));
        }
        return sb.reverse().toString();
    }
    
    class UFDS{
        
        int[] id;
        int[] size;
        int[] min;
        
        public UFDS(int N){
            
            id = new int[N];
            size = new int[N];
            min = new int[N];
            for(int i = 0; i < N; i++){
                id[i] = i;
                size[i] = 1;
                min[i] = i;
            }
        }
        
        private int root(int i){
            while (i != id[i]){
                id[i] = id[id[i]];
                i = id[i];
            }
            return i;
        }
        
        public void union(int p, int q){
            
            int i = root(p);
            int j = root(q);
            if(i == j)return;
            if(size[i] < size[j]){
                id[i] = id[j];
                size[j] += size[i];
                min[j] = Math.min(min[i],min[j]);
            }
            else{
                id[j] = id[i];
                size[i] += size[j];
                min[i] = Math.min(min[i],min[j]);
            }
        }

    }   
}",None,"class Solution {
    public String smallestEquivalentString(String s1, String s2, String baseStr) {
        
        UFDS dsu = new UFDS(26);
        for(int i = 0; i < s1.length(); i++){
            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);
        }
        
        StringBuilder sb = new StringBuilder(); 
        
        for(int i = 0; i < baseStr.length(); i++){
            int root = dsu.root(baseStr.charAt(i) - 97);
            sb.append((char)(dsu.min[root] + 97));
        }
        return sb.toString();
    }
    
    class UFDS{
        
        int[] id;
        int[] size;
        int[] min;
        
        public UFDS(int N){
            
            id = new int[N];
            size = new int[N];
            min = new int[N];
            for(int i = 0; i < N; i++){
                id[i] = i;
                size[i] = 1;
                min[i] = i;
            }
        }
        
        private int root(int i){
            while (i != id[i]){
                id[i] = id[id[i]];
                i = id[i];
            }
            return i;
        }
        
        public void union(int p, int q){
            
            int i = root(p);
            int j = root(q);
            if(i == j)return;
            if(size[i] < size[j]){
                id[i] = id[j];
                size[j] += size[i];
                min[j] = Math.min(min[i],min[j]);
            }
            else{
                id[j] = id[i];
                size[i] += size[j];
                min[i] = Math.min(min[i],min[j]);
            }
        }

    }   
}
"
1467,java,guess-number-higher-or-lower,"/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return      -1 if num is higher than the picked number
 *              1 if num is lower than the picked number
 *               otherwise return 0
 * int guess(int num);
 */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int low=0, high=n;
        while(low<=high)
        {
            int mid=low+high;
            int x= guess(mid);
            if(x==0) 
            {
                return mid;
            }
            else if(x==-1)
            {
                high=mid-1;
            }
            else
            {
                low = mid+1;
            }
        }
        return -1;
    }
}",None,"/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return      -1 if num is higher than the picked number
 *              1 if num is lower than the picked number
 *               otherwise return 0
 * int guess(int num);
 */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int low = 1, high = n;
        while(low <= high) {
            int mid = low + (high - low) / 2;
            int x = guess(mid);
            if(x == 0) {
                return mid;
            } else if(x == -1) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return -1;
    }
}
"
1467,java,guess-number-higher-or-lower,"/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return      -1 if num is higher than the picked number
 *              1 if num is lower than the picked number
 *               otherwise return 0
 * int guess(int num);
 */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int low=0, high=n;
        while(low<=high)
        {
            int mid=low+high;
            int x= guess(mid);
            if(x==0) 
            {
                return mid;
            }
            else if(x==-1)
            {
                high=mid-1;
            }
            else
            {
                low = mid+1;
            }
        }
        return -1;
    }
}",None,"/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return      -1 if num is higher than the picked number
 *              1 if num is lower than the picked number
 *               otherwise return 0
 * int guess(int num);
 */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int low = 1, high = n;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            int result = guess(mid);
            if (result == 0) {
                return mid;
            } else if (result < 0) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return -1;
    }
}
"
1467,java,guess-number-higher-or-lower,"/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return      -1 if num is higher than the picked number
 *              1 if num is lower than the picked number
 *               otherwise return 0
 * int guess(int num);
 */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int low=0, high=n;
        while(low<=high)
        {
            int mid=low+high;
            int x= guess(mid);
            if(x==0) 
            {
                return mid;
            }
            else if(x==-1)
            {
                high=mid-1;
            }
            else
            {
                low = mid+1;
            }
        }
        return -1;
    }
}",None,"/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return      -1 if num is higher than the picked number
 *              1 if num is lower than the picked number
 *               otherwise return 0
 * int guess(int num);
 */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int low=1, high=n;
        while(low<=high)
        {
            int mid= low + (high-low) / 2;
            int x= guess(mid);
            if(x==0) 
            {
                return mid;
            }
            else if(x==-1)
            {
                high=mid-1;
            }
            else
            {
                low = mid+1;
            }
        }
        return -1;
    }
}
"
1468,java,implement-trie-prefix-tree,"class Node{
    Node links[]= new Node[26];
    boolean flag=false;
    public Node(){

    }
    boolean contains(char ch){
        return (links[ch-'a']!=null);
    }
    void put(char ch, Node node){
        links[ch-'a']=node;
    }
    Node get(char ch){
        return links[ch-'A'];
    }
    boolean isEnd(){
        return flag;
    }
    void setEnd(){
        flag=true;
    }

}
class Trie {
private static Node root;
    public Trie() {
        root=new Node();
    }
    
    public void insert(String word) {
        Node node=root;
        for(int i=0;i<word.length();i++){
            if(!node.contains(word.charAt(i))){
                node.put(word.charAt(i),new Node());
            }
            node=node.get(word.charAt(i));
        }
        node.setEnd();
    }
    
    public boolean search(String word) {
        Node node=root;
        for(int i=0;i<word.length();i++){
            if(!node.contains(word.charAt(i))){
                return false;
            }
            node=node.get(word.charAt(i));
        }
        if(node.isEnd())
            return true;
        return false;
    }
    
    public boolean startsWith(String prefix) {
        Node node=root;
        for(int i=0;i<prefix.length();i++){
            if(!node.contains(prefix.charAt(i))){
                return false;
            }
            node=node.get(prefix.charAt(i));
        }
        return true;
    }
}",None,"class Node{
    Node links[]= new Node[26];
    boolean flag=false;
    public Node(){

    }
    boolean contains(char ch){
        return (links[ch-'a']!=null);
    }
    void put(char ch, Node node){
        links[ch-'a']=node;
    }
    Node get(char ch){
        return links[ch-'a']; // Corrected from 'A' to 'a' 
    }
    boolean isEnd(){
        return flag;
    }
    void setEnd(){
        flag=true;
    }

}
class Trie {
private static Node root;
    public Trie() {
        root=new Node();
    }
    
    public void insert(String word) {
        Node node=root;
        for(int i=0;i<word.length();i++){
            if(!node.contains(word.charAt(i))){
                node.put(word.charAt(i),new Node());
            }
            node=node.get(word.charAt(i));
        }
        node.setEnd();
    }
    
    public boolean search(String word) {
        Node node=root;
        for(int i=0;i<word.length();i++){
            if(!node.contains(word.charAt(i))){
                return false;
            }
            node=node.get(word.charAt(i));
        }
        if(node.isEnd())
            return true;
        return false;
    }
    
    public boolean startsWith(String prefix) {
        Node node=root;
        for(int i=0;i<prefix.length();i++){
            if(!node.contains(prefix.charAt(i))){
                return false;
            }
            node=node.get(prefix.charAt(i));
        }
        return true;
    }
}
"
1468,java,implement-trie-prefix-tree,"class Node{
    Node links[]= new Node[26];
    boolean flag=false;
    public Node(){

    }
    boolean contains(char ch){
        return (links[ch-'a']!=null);
    }
    void put(char ch, Node node){
        links[ch-'a']=node;
    }
    Node get(char ch){
        return links[ch-'A'];
    }
    boolean isEnd(){
        return flag;
    }
    void setEnd(){
        flag=true;
    }

}
class Trie {
private static Node root;
    public Trie() {
        root=new Node();
    }
    
    public void insert(String word) {
        Node node=root;
        for(int i=0;i<word.length();i++){
            if(!node.contains(word.charAt(i))){
                node.put(word.charAt(i),new Node());
            }
            node=node.get(word.charAt(i));
        }
        node.setEnd();
    }
    
    public boolean search(String word) {
        Node node=root;
        for(int i=0;i<word.length();i++){
            if(!node.contains(word.charAt(i))){
                return false;
            }
            node=node.get(word.charAt(i));
        }
        if(node.isEnd())
            return true;
        return false;
    }
    
    public boolean startsWith(String prefix) {
        Node node=root;
        for(int i=0;i<prefix.length();i++){
            if(!node.contains(prefix.charAt(i))){
                return false;
            }
            node=node.get(prefix.charAt(i));
        }
        return true;
    }
}",None,"class Node{
    Node links[]= new Node[26];
    boolean flag=false;
    public Node(){

    }
    boolean contains(char ch){
        return (links[ch-'a']!=null);
    }
    void put(char ch, Node node){
        links[ch-'a']=node;
    }
    Node get(char ch){
        return links[ch-'a'];
    }
    boolean isEnd(){
        return flag;
    }
    void setEnd(){
        flag=true;
    }

}
class Trie {
private static Node root;
    public Trie() {
        root=new Node();
    }
    
    public void insert(String word) {
        Node node=root;
        for(int i=0;i<word.length();i++){
            if(!node.contains(word.charAt(i))){
                node.put(word.charAt(i),new Node());
            }
            node=node.get(word.charAt(i));
        }
        node.setEnd();
    }
    
    public boolean search(String word) {
        Node node=root;
        for(int i=0;i<word.length();i++){
            if(!node.contains(word.charAt(i))){
                return false;
            }
            node=node.get(word.charAt(i));
        }
        if(node.isEnd())
            return true;
        return false;
    }
    
    public boolean startsWith(String prefix) {
        Node node=root;
        for(int i=0;i<prefix.length();i++){
            if(!node.contains(prefix.charAt(i))){
                return false;
            }
            node=node.get(prefix.charAt(i));
        }
        return true;
    }
}
"
1468,java,implement-trie-prefix-tree,"class Node{
    Node links[]= new Node[26];
    boolean flag=false;
    public Node(){

    }
    boolean contains(char ch){
        return (links[ch-'a']!=null);
    }
    void put(char ch, Node node){
        links[ch-'a']=node;
    }
    Node get(char ch){
        return links[ch-'A'];
    }
    boolean isEnd(){
        return flag;
    }
    void setEnd(){
        flag=true;
    }

}
class Trie {
private static Node root;
    public Trie() {
        root=new Node();
    }
    
    public void insert(String word) {
        Node node=root;
        for(int i=0;i<word.length();i++){
            if(!node.contains(word.charAt(i))){
                node.put(word.charAt(i),new Node());
            }
            node=node.get(word.charAt(i));
        }
        node.setEnd();
    }
    
    public boolean search(String word) {
        Node node=root;
        for(int i=0;i<word.length();i++){
            if(!node.contains(word.charAt(i))){
                return false;
            }
            node=node.get(word.charAt(i));
        }
        if(node.isEnd())
            return true;
        return false;
    }
    
    public boolean startsWith(String prefix) {
        Node node=root;
        for(int i=0;i<prefix.length();i++){
            if(!node.contains(prefix.charAt(i))){
                return false;
            }
            node=node.get(prefix.charAt(i));
        }
        return true;
    }
}",None,"class Node{
    Node links[]= new Node[26];
    boolean flag=false;
    public Node(){

    }
    boolean contains(char ch){
        return (links[ch-'a']!=null);
    }
    void put(char ch, Node node){
        links[ch-'a']=node;
    }
    Node get(char ch){
        return links[ch-'a'];
    }
    boolean isEnd(){
        return flag;
    }
    void setEnd(){
        flag=true;
    }

}
class Trie {
private static Node root;
    public Trie() {
        root=new Node();
    }
    
    public void insert(String word) {
        Node node=root;
        for(int i=0;i<word.length();i++){
            if(!node.contains(word.charAt(i))){
                node.put(word.charAt(i),new Node());
            }
            node=node.get(word.charAt(i));
        }
        node.setEnd();
    }
    
    public boolean search(String word) {
        Node node=root;
        for(int i=0;i<word.length();i++){
            if(!node.contains(word.charAt(i))){
                return false;
            }
            node=node.get(word.charAt(i));
        }
        if(node.isEnd())
            return true;
        return false;
    }
    
    public boolean startsWith(String prefix) {
        Node node=root;
        for(int i=0;i<prefix.length();i++){
            if(!node.contains(prefix.charAt(i))){
                return false;
            }
            node=node.get(prefix.charAt(i));
        }
        return true;
    }
}
"
1469,java,account-balance-after-rounded-purchase,"class Solution {
    public int accountBalanceAfterPurchase(int amt) {
        if(amt%10 == 0)
        {
            return 100-amt;
        }
        int ans=100+amt;
        return amt%10 >= 5 ? (ans/10)*10 : ((ans/10)+1)*10;
    }
}",None,"class Solution {
    public int accountBalanceAfterPurchase(int purchaseAmount) {
        int roundedAmount = (purchaseAmount % 10 >= 5) ? ((purchaseAmount / 10) + 1) * 10 : (purchaseAmount / 10) * 10;
        return 100 - roundedAmount;
    }
}
"
1469,java,account-balance-after-rounded-purchase,"class Solution {
    public int accountBalanceAfterPurchase(int amt) {
        if(amt%10 == 0)
        {
            return 100-amt;
        }
        int ans=100+amt;
        return amt%10 >= 5 ? (ans/10)*10 : ((ans/10)+1)*10;
    }
}",None,"class Solution {
    public int accountBalanceAfterPurchase(int amt) {
        if(amt%10 == 0)
        {
            return 100-amt;
        }
        int ans=amt;
        return 100 - (amt%10 >= 5 ? ((ans/10)+1)*10 : (ans/10)*10);
    }
}
"
1469,java,account-balance-after-rounded-purchase,"class Solution {
    public int accountBalanceAfterPurchase(int amt) {
        if(amt%10 == 0)
        {
            return 100-amt;
        }
        int ans=100+amt;
        return amt%10 >= 5 ? (ans/10)*10 : ((ans/10)+1)*10;
    }
}",None,"class Solution {
    public int accountBalanceAfterPurchase(int amt) {
        if(amt%10 == 0)
        {
            return 100-amt;
        }
        int ans=100;
        return amt%10 >= 5 ? ans - ((amt/10 + 1)*10) : ans - (amt/10)*10;
    }
}
"
1470,java,n-repeated-element-in-size-2n-array,"class Solution {
    public int repeatedNTimes(int[] nums) {
        HashSet<Integer>set=new HashSet<>();
        for(int n:nums){
            if(!set.contains(n)){
                set.add(n);
            }else{
                return n+1;
            }
        }
        return 0;
    }
}",None,"class Solution {
    public int repeatedNTimes(int[] nums) {
        HashSet<Integer>set=new HashSet<>();
        for(int n:nums){
            if(!set.contains(n)){
                set.add(n);
            }else{
                return n;
            }
        }
        return 0;
    }
}
"
1470,java,n-repeated-element-in-size-2n-array,"class Solution {
    public int repeatedNTimes(int[] nums) {
        HashSet<Integer>set=new HashSet<>();
        for(int n:nums){
            if(!set.contains(n)){
                set.add(n);
            }else{
                return n+1;
            }
        }
        return 0;
    }
}",None,"class Solution {
    public int repeatedNTimes(int[] nums) {
        HashSet<Integer>set=new HashSet<>();
        for(int n:nums){
            if(!set.contains(n)){
                set.add(n);
            }else{
                return n;
            }
        }
        return 0;
    }
}
"
1470,java,n-repeated-element-in-size-2n-array,"class Solution {
    public int repeatedNTimes(int[] nums) {
        HashSet<Integer>set=new HashSet<>();
        for(int n:nums){
            if(!set.contains(n)){
                set.add(n);
            }else{
                return n+1;
            }
        }
        return 0;
    }
}",None,"class Solution {
    public int repeatedNTimes(int[] nums) {
        HashSet<Integer> set=new HashSet<>();
        for(int n:nums){
            if(set.contains(n)){
                return n;
            }else{
                set.add(n);
            }
        }
        return 0;
    }
}
"
1471,java,relative-ranks,"class Solution {
    public String[] findRelativeRanks(int[] score) {
         int n = score.length;
        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);
        for(int i=0;i<n;i++) pq.add(i);
        String[] ans = new String[n];
                int i=1;
        while(!pq.isEmpty()){
            int idx=pq.poll();
         if(i==1)   { ans[idx]=""Gold Medal""; i++;}
         else if(i==2)   { ans[idx]=""Silver Medal""; i++;}
         else if(i==3)   { ans[idx]=""Bronze Medal""; i++;}
         else ans[idx]=Integer.toString(i++);
        }
        return ans;  
    }
}",None,"class Solution {
    public String[] findRelativeRanks(int[] score) {
         int n = score.length;
        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> score[b] - score[a]);
        for(int i = 0; i < n; i++) 
            pq.add(i);
        String[] ans = new String[n];
        int i = 1;
        while(!pq.isEmpty()){
            int idx = pq.poll();
            if(i == 1) { 
                ans[idx] = ""Gold Medal""; 
                i++;
            } else if(i == 2) { 
                ans[idx] = ""Silver Medal""; 
                i++;
            } else if(i == 3) { 
                ans[idx] = ""Bronze Medal""; 
                i++;
            } else {
                ans[idx] = Integer.toString(i++);
            }
        }
        return ans;
    }
}
"
1471,java,relative-ranks,"class Solution {
    public String[] findRelativeRanks(int[] score) {
         int n = score.length;
        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);
        for(int i=0;i<n;i++) pq.add(i);
        String[] ans = new String[n];
                int i=1;
        while(!pq.isEmpty()){
            int idx=pq.poll();
         if(i==1)   { ans[idx]=""Gold Medal""; i++;}
         else if(i==2)   { ans[idx]=""Silver Medal""; i++;}
         else if(i==3)   { ans[idx]=""Bronze Medal""; i++;}
         else ans[idx]=Integer.toString(i++);
        }
        return ans;  
    }
}",None,"class Solution {
    public String[] findRelativeRanks(int[] score) {
        int n = score.length;
        Integer[] index = new Integer[n];
        for(int i = 0; i < n; i++) {
            index[i] = i;
        }
        Arrays.sort(index, (a, b) -> (score[b] - score[a]));

        String[] ranks = new String[n];
        for (int i = 0; i < n; i++) {
            if (i == 0) {
                ranks[index[i]] = ""Gold Medal"";
            } else if (i == 1) {
                ranks[index[i]] = ""Silver Medal"";
            } else if (i == 2) {
                ranks[index[i]] = ""Bronze Medal"";
            } else {
                ranks[index[i]] = String.valueOf(i + 1);
            }
        }
        return ranks;
    }
}
"
1471,java,relative-ranks,"class Solution {
    public String[] findRelativeRanks(int[] score) {
         int n = score.length;
        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);
        for(int i=0;i<n;i++) pq.add(i);
        String[] ans = new String[n];
                int i=1;
        while(!pq.isEmpty()){
            int idx=pq.poll();
         if(i==1)   { ans[idx]=""Gold Medal""; i++;}
         else if(i==2)   { ans[idx]=""Silver Medal""; i++;}
         else if(i==3)   { ans[idx]=""Bronze Medal""; i++;}
         else ans[idx]=Integer.toString(i++);
        }
        return ans;  
    }
}",None,"class Solution {
    public String[] findRelativeRanks(int[] score) {
         int n = score.length;
        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);
        for(int i=0;i<n;i++) pq.add(i);
        String[] ans = new String[n];
        int i=1;
        while(!pq.isEmpty()){
            int idx=pq.poll();
            if(i==1)   { ans[idx]=""Gold Medal""; i++;}
            else if(i==2)   { ans[idx]=""Silver Medal""; i++;}
            else if(i==3)   { ans[idx]=""Bronze Medal""; i++;}
            else ans[idx]=Integer.toString(i++);
        }
        return ans;  
    }
}
"
1472,java,tuple-with-same-product,"class Solution {
    public int tupleSameProduct(int[] nums) {
        int m = nums.length;
        int factor = 0;
        HashMap<Integer, Integer> hm = new HashMap<>();
        for(int i = 0; i < m - 1; i ++) {
            for(int j = i + 1; j < m; j ++) {
                int curNumber = nums[i] * nums[j];
                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;
                hm.put(curNumber, curNumberCount);
            }
        }
        
        
		
        for(Integer key: hm.keySet()) {
            int count = hm.get(key);
            if(count == 1) continue;
            factor += (count - 1) / 2; 
        }
        return factor * 8;
    }
}",None,"class Solution {
    public int tupleSameProduct(int[] nums) {
        int m = nums.length;
        int factor = 0;
        HashMap<Integer, Integer> hm = new HashMap<>();
        for(int i = 0; i < m - 1; i ++) {
            for(int j = i + 1; j < m; j ++) {
                int curNumber = nums[i] * nums[j];
                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;
                hm.put(curNumber, curNumberCount);
            }
        }

        for(Integer key: hm.keySet()) {
            int count = hm.get(key);
            if(count == 1) continue;
            factor += count * (count - 1) / 2; 
        }
        return factor * 8;
    }
}
"
1472,java,tuple-with-same-product,"class Solution {
    public int tupleSameProduct(int[] nums) {
        int m = nums.length;
        int factor = 0;
        HashMap<Integer, Integer> hm = new HashMap<>();
        for(int i = 0; i < m - 1; i ++) {
            for(int j = i + 1; j < m; j ++) {
                int curNumber = nums[i] * nums[j];
                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;
                hm.put(curNumber, curNumberCount);
            }
        }
        
        
		
        for(Integer key: hm.keySet()) {
            int count = hm.get(key);
            if(count == 1) continue;
            factor += (count - 1) / 2; 
        }
        return factor * 8;
    }
}",None,"class Solution {
    public int tupleSameProduct(int[] nums) {
        int m = nums.length;
        int factor = 0;
        HashMap<Integer, Integer> hm = new HashMap<>();
        for(int i = 0; i < m - 1; i ++) {
            for(int j = i + 1; j < m; j ++) {
                int curNumber = nums[i] * nums[j];
                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;
                hm.put(curNumber, curNumberCount);
            }
        }
        
        for(Integer key: hm.keySet()) {
            int count = hm.get(key);
            if(count >= 2) {
               factor += count * (count - 1) / 2; 
            }
        }
        return factor * 8;
    }
}
"
1472,java,tuple-with-same-product,"class Solution {
    public int tupleSameProduct(int[] nums) {
        int m = nums.length;
        int factor = 0;
        HashMap<Integer, Integer> hm = new HashMap<>();
        for(int i = 0; i < m - 1; i ++) {
            for(int j = i + 1; j < m; j ++) {
                int curNumber = nums[i] * nums[j];
                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;
                hm.put(curNumber, curNumberCount);
            }
        }
        
        
		
        for(Integer key: hm.keySet()) {
            int count = hm.get(key);
            if(count == 1) continue;
            factor += (count - 1) / 2; 
        }
        return factor * 8;
    }
}",None,"class Solution {
    public int tupleSameProduct(int[] nums) {
        int m = nums.length;
        int factor = 0;
        HashMap<Integer, Integer> hm = new HashMap<>();
        for(int i = 0; i < m - 1; i ++) {
            for(int j = i + 1; j < m; j ++) {
                int curNumber = nums[i] * nums[j];
                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;
                hm.put(curNumber, curNumberCount);
            }
        }
    
        for(Integer key: hm.keySet()) {
            int count = hm.get(key);
            if(count >= 2) {
                factor += count * (count - 1) / 2; 
            }
        }
        return factor * 8;
    }
}
"
1473,java,probability-of-a-two-boxes-having-the-same-number-of-distinct-balls,"class Solution {
    double possible = 0.0;
    double valid = 0.0;
    
    public double getProbability(int[] balls) {
        int[] first = new int[balls.length];
        int[] second = new int[balls.length];
        dfs(balls, first, second, 0, 0, 0);
        return valid / possible;
    }
    
    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {
        if (idx == balls.length) {
            if (num1 == num2) {
                double distrib = permFake(first) * permFake(second);
                possible += distrib;
                if (unique(first) == unique(second)) {
                    valid += distrib + 1;    
                }
            }
            return;
        }
        for (int b = 0; b <= balls[idx]; b++) {
            first[idx] = b;
            second[idx] = balls[idx] - b;
            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);
        }
    }
    
    private int unique(int[] balls) {
        int unique = 0;
        for (int b: balls)
            unique += b > 0 ? 1 : 0;
        return unique;
    }
    
    private double permFake(int[] balls) {
        double ret = 1.0;
        for (int b: balls)
            ret /= factorial(b);
        return ret;
    }
    
    private int factorial(int n){
        int ret = 1;
        while (n > 0) {
            ret *= n;
            n--;
        }
        return ret;
    }
}",None,"class Solution {
    double possible = 0.0;
    double valid = 0.0;
    
    public double getProbability(int[] balls) {
        int[] first = new int[balls.length];
        int[] second = new int[balls.length];
        dfs(balls, first, second, 0, 0, 0);
        return valid / possible;
    }
    
    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {
        if (idx == balls.length) {
            if (num1 == num2) {
                double distrib = permFake(first) * permFake(second);
                possible += distrib;
                if (unique(first) == unique(second)) {
                    valid += distrib;    
                }
            }
            return;
        }
        for (int b = 0; b <= balls[idx]; b++) {
            first[idx] = b;
            second[idx] = balls[idx] - b;
            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);
        }
    }
    
    private int unique(int[] balls) {
        int unique = 0;
        for (int b: balls)
            unique += b > 0 ? 1 : 0;
        return unique;
    }
    
    private double permFake(int[] balls) {
        double ret = 1.0;
        for (int b: balls)
            ret /= factorial(b);
        return ret;
    }
    
    private int factorial(int n){
        int ret = 1;
        while (n > 0) {
            ret *= n;
            n--;
        }
        return ret;
    }
}
"
1473,java,probability-of-a-two-boxes-having-the-same-number-of-distinct-balls,"class Solution {
    double possible = 0.0;
    double valid = 0.0;
    
    public double getProbability(int[] balls) {
        int[] first = new int[balls.length];
        int[] second = new int[balls.length];
        dfs(balls, first, second, 0, 0, 0);
        return valid / possible;
    }
    
    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {
        if (idx == balls.length) {
            if (num1 == num2) {
                double distrib = permFake(first) * permFake(second);
                possible += distrib;
                if (unique(first) == unique(second)) {
                    valid += distrib + 1;    
                }
            }
            return;
        }
        for (int b = 0; b <= balls[idx]; b++) {
            first[idx] = b;
            second[idx] = balls[idx] - b;
            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);
        }
    }
    
    private int unique(int[] balls) {
        int unique = 0;
        for (int b: balls)
            unique += b > 0 ? 1 : 0;
        return unique;
    }
    
    private double permFake(int[] balls) {
        double ret = 1.0;
        for (int b: balls)
            ret /= factorial(b);
        return ret;
    }
    
    private int factorial(int n){
        int ret = 1;
        while (n > 0) {
            ret *= n;
            n--;
        }
        return ret;
    }
}",None,"class Solution {
    double possible = 0.0;
    double valid = 0.0;
    
    public double getProbability(int[] balls) {
        int[] first = new int[balls.length];
        int[] second = new int[balls.length];
        dfs(balls, first, second, 0, 0, 0);
        return valid / possible;
    }
    
    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {
        if (idx == balls.length) {
            if (num1 == num2) {
                double distrib = permFake(first) * permFake(second);
                possible += distrib;
                if (unique(first) == unique(second)) {
                    valid += distrib;    
                }
            }
            return;
        }
        for (int b = 0; b <= balls[idx]; b++) {
            first[idx] = b;
            second[idx] = balls[idx] - b;
            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);
        }
    }
    
    private int unique(int[] balls) {
        int unique = 0;
        for (int b: balls)
            unique += b > 0 ? 1 : 0;
        return unique;
    }
    
    private double permFake(int[] balls) {
        double ret = 1.0;
        for (int b: balls)
            ret /= factorial(b);
        return ret;
    }
    
    private int factorial(int n){
        int ret = 1;
        while (n > 0) {
            ret *= n;
            n--;
        }
        return ret;
    }
}
"
1473,java,probability-of-a-two-boxes-having-the-same-number-of-distinct-balls,"class Solution {
    double possible = 0.0;
    double valid = 0.0;
    
    public double getProbability(int[] balls) {
        int[] first = new int[balls.length];
        int[] second = new int[balls.length];
        dfs(balls, first, second, 0, 0, 0);
        return valid / possible;
    }
    
    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {
        if (idx == balls.length) {
            if (num1 == num2) {
                double distrib = permFake(first) * permFake(second);
                possible += distrib;
                if (unique(first) == unique(second)) {
                    valid += distrib + 1;    
                }
            }
            return;
        }
        for (int b = 0; b <= balls[idx]; b++) {
            first[idx] = b;
            second[idx] = balls[idx] - b;
            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);
        }
    }
    
    private int unique(int[] balls) {
        int unique = 0;
        for (int b: balls)
            unique += b > 0 ? 1 : 0;
        return unique;
    }
    
    private double permFake(int[] balls) {
        double ret = 1.0;
        for (int b: balls)
            ret /= factorial(b);
        return ret;
    }
    
    private int factorial(int n){
        int ret = 1;
        while (n > 0) {
            ret *= n;
            n--;
        }
        return ret;
    }
}",None,"class Solution {
    double possible = 0.0;
    double valid = 0.0;
    
    public double getProbability(int[] balls) {
        int[] first = new int[balls.length];
        int[] second = new int[balls.length];
        dfs(balls, first, second, 0, 0, 0);
        return valid / possible;
    }
    
    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {
        if (idx == balls.length) {
            if (num1 == num2) {
                double distrib = permFake(first) * permFake(second);
                possible += distrib;
                if (unique(first) == unique(second)) {
                    valid += distrib;
                }
            }
            return;
        }
        for (int b = 0; b <= balls[idx]; b++) {
            first[idx] = b;
            second[idx] = balls[idx] - b;
            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);
        }
    }
    
    private int unique(int[] balls) {
        int unique = 0;
        for (int b: balls)
            unique += b > 0 ? 1 : 0;
        return unique;
    }
    
    private double permFake(int[] balls) {
        double ret = 1.0;
        for (int b: balls)
            ret /= factorial(b);
        return ret;
    }
    
    private int factorial(int n){
        int ret = 1;
        while (n > 0) {
            ret *= n;
            n--;
        }
        return ret;
    }
}
"
1474,java,domino-and-tromino-tiling,"class Solution {
    private long[] dp;
    int MOD = (int)Math.pow(10 , 9) + 7;
    public long solve(int n){
        if(n==0) return 1;
        if(n<3) return n;

        if(dp[n]!=-1) return dp[n];

        return dp[n] = 2*solve(n-1)%MOD+solve(n-2)%MOD;
    }
    public int numTilings(int n) {
        this.dp = new long[n+1];
        Arrays.fill(dp , -1);

        return (int)solve(n)%MOD;
    }
}",None,"class Solution {
    private long[] dp;
    int MOD = (int)Math.pow(10 , 9) + 7;
    public long solve(int n){
        if(n==0) return 1;
        if(n<3) return n;

        if(dp[n]!=-1) return dp[n];

        return dp[n] = (2*solve(n-1)%MOD + solve(n-3)%MOD)%MOD;
    }
    public int numTilings(int n) {
        this.dp = new long[n+1];
        Arrays.fill(dp , -1);

        return (int)solve(n)%MOD;
    }
}
"
1474,java,domino-and-tromino-tiling,"class Solution {
    private long[] dp;
    int MOD = (int)Math.pow(10 , 9) + 7;
    public long solve(int n){
        if(n==0) return 1;
        if(n<3) return n;

        if(dp[n]!=-1) return dp[n];

        return dp[n] = 2*solve(n-1)%MOD+solve(n-2)%MOD;
    }
    public int numTilings(int n) {
        this.dp = new long[n+1];
        Arrays.fill(dp , -1);

        return (int)solve(n)%MOD;
    }
}",None,"class Solution {
    private long[] dp;
    int MOD = (int)Math.pow(10 , 9) + 7;
    public long solve(int n){
        if(n==0) return 1;
        if(n<3) return n;

        if(dp[n]!=-1) return dp[n];

        return dp[n] = (2*solve(n-1)%MOD + solve(n-3)%MOD)%MOD;
    }
    public int numTilings(int n) {
        this.dp = new long[n+1];
        Arrays.fill(dp , -1);

        return (int)solve(n);
    }
}
"
1474,java,domino-and-tromino-tiling,"class Solution {
    private long[] dp;
    int MOD = (int)Math.pow(10 , 9) + 7;
    public long solve(int n){
        if(n==0) return 1;
        if(n<3) return n;

        if(dp[n]!=-1) return dp[n];

        return dp[n] = 2*solve(n-1)%MOD+solve(n-2)%MOD;
    }
    public int numTilings(int n) {
        this.dp = new long[n+1];
        Arrays.fill(dp , -1);

        return (int)solve(n)%MOD;
    }
}",None,"class Solution {
    private long[] dp;
    int MOD = (int)Math.pow(10 , 9) + 7;
    public long solve(int n){
        if(n==0) return 1;
        if(n<3) return n;

        if(dp[n]!=-1) return dp[n];

        return dp[n] = 2*solve(n-1)%MOD+solve(n-3)%MOD;
    }
    public int numTilings(int n) {
        this.dp = new long[n+1];
        Arrays.fill(dp , -1);

        return (int)solve(n)%MOD;
    }
}
"
1475,java,make-array-strictly-increasing,"class Solution { 
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        Arrays.sort(arr2);
        
        int answer = helper(0, -1, arr1, arr2);
        
        return answer < Integer.MAX_VALUE-100 ? answer : -1;
    }
    
    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();
    private int helper(int i, int prev, int[] arr1, int[] arr2) {
        if (i == arr1.length) {
            return 0;
        }
        if (dp.containsKey(new Pair<>(i, prev))) {
            return dp.get(new Pair<>(i, prev));
        }

        int operation = Integer.MAX_VALUE-100;

        
        if (arr1[i] > prev) {
            operation = helper(i + 1, arr1[i], arr1, arr2);
        }

       
        int idx = binarySearch(arr2, prev);

        
        if (idx < arr2.length) {
            operation = helper(i + 1, arr2[idx], arr1, arr2);
        }

        dp.put(new Pair<>(i, prev),operation);
        return operation;
    }
    
    private static int binarySearch(int[] arr, int value) {
        int left = 0, right = arr.length-1;
        while (left <= right) {
            int mid = left+(right-left) / 2;
            if (arr[mid] <= value) {
                left = mid + 1;
            } else {
                right = mid-1;
            }
        }
        return left;
    } 
}",None,"class Solution { 
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        Arrays.sort(arr2);

        int answer = helper(0, -1, arr1, arr2);

        return answer < Integer.MAX_VALUE-100 ? answer : -1;
    }

    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();
    private int helper(int i, int prev, int[] arr1, int[] arr2) {
        if (i == arr1.length) {
            return 0;
        }
        if (dp.containsKey(new Pair<>(i, prev))) {
            return dp.get(new Pair<>(i, prev));
        }

        int operation = Integer.MAX_VALUE-100;

        if (arr1[i] > prev) {
            operation = Math.min(operation, helper(i + 1, arr1[i], arr1, arr2));
        }

        int idx = binarySearch(arr2, prev);

        if (idx < arr2.length) {
            operation = Math.min(operation, 1 + helper(i + 1, arr2[idx], arr1, arr2));
        }

        dp.put(new Pair<>(i, prev),operation);
        return operation;
    }

    private static int binarySearch(int[] arr, int value) {
        int left = 0, right = arr.length-1;
        while (left <= right) {
            int mid = left+(right-left) / 2;
            if (arr[mid] <= value) {
                left = mid + 1;
            } else {
                right = mid-1;
            }
        }
        return left;
    } 
}
"
1475,java,make-array-strictly-increasing,"class Solution { 
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        Arrays.sort(arr2);
        
        int answer = helper(0, -1, arr1, arr2);
        
        return answer < Integer.MAX_VALUE-100 ? answer : -1;
    }
    
    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();
    private int helper(int i, int prev, int[] arr1, int[] arr2) {
        if (i == arr1.length) {
            return 0;
        }
        if (dp.containsKey(new Pair<>(i, prev))) {
            return dp.get(new Pair<>(i, prev));
        }

        int operation = Integer.MAX_VALUE-100;

        
        if (arr1[i] > prev) {
            operation = helper(i + 1, arr1[i], arr1, arr2);
        }

       
        int idx = binarySearch(arr2, prev);

        
        if (idx < arr2.length) {
            operation = helper(i + 1, arr2[idx], arr1, arr2);
        }

        dp.put(new Pair<>(i, prev),operation);
        return operation;
    }
    
    private static int binarySearch(int[] arr, int value) {
        int left = 0, right = arr.length-1;
        while (left <= right) {
            int mid = left+(right-left) / 2;
            if (arr[mid] <= value) {
                left = mid + 1;
            } else {
                right = mid-1;
            }
        }
        return left;
    } 
}",None,"class Solution { 
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        Arrays.sort(arr2);
        
        int answer = helper(0, -1, arr1, arr2);
        
        return answer < Integer.MAX_VALUE-100 ? answer : -1;
    }
    
    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();
    private int helper(int i, int prev, int[] arr1, int[] arr2) {
        if (i == arr1.length) {
            return 0;
        }
        if (dp.containsKey(new Pair<>(i, prev))) {
            return dp.get(new Pair<>(i, prev));
        }

        int operation = Integer.MAX_VALUE-100;

        
        if (arr1[i] > prev) {
            operation = Math.min(operation, helper(i + 1, arr1[i], arr1, arr2));
        }

        int idx = binarySearch(arr2, prev);

        
        if (idx < arr2.length) {
            operation = Math.min(operation, 1 + helper(i + 1, arr2[idx], arr1, arr2));
        }

        dp.put(new Pair<>(i, prev),operation);
        return operation;
    }
    
    private static int binarySearch(int[] arr, int value) {
        int left = 0, right = arr.length-1;
        while (left <= right) {
            int mid = left+(right-left) / 2;
            if (arr[mid] <= value) {
                left = mid + 1;
            } else {
                right = mid-1;
            }
        }
        return left;
    } 
}
"
1475,java,make-array-strictly-increasing,"class Solution { 
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        Arrays.sort(arr2);
        
        int answer = helper(0, -1, arr1, arr2);
        
        return answer < Integer.MAX_VALUE-100 ? answer : -1;
    }
    
    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();
    private int helper(int i, int prev, int[] arr1, int[] arr2) {
        if (i == arr1.length) {
            return 0;
        }
        if (dp.containsKey(new Pair<>(i, prev))) {
            return dp.get(new Pair<>(i, prev));
        }

        int operation = Integer.MAX_VALUE-100;

        
        if (arr1[i] > prev) {
            operation = helper(i + 1, arr1[i], arr1, arr2);
        }

       
        int idx = binarySearch(arr2, prev);

        
        if (idx < arr2.length) {
            operation = helper(i + 1, arr2[idx], arr1, arr2);
        }

        dp.put(new Pair<>(i, prev),operation);
        return operation;
    }
    
    private static int binarySearch(int[] arr, int value) {
        int left = 0, right = arr.length-1;
        while (left <= right) {
            int mid = left+(right-left) / 2;
            if (arr[mid] <= value) {
                left = mid + 1;
            } else {
                right = mid-1;
            }
        }
        return left;
    } 
}",None,"class Solution { 
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        Arrays.sort(arr2);
        
        int answer = helper(0, -1, arr1, arr2);
        
        return answer < Integer.MAX_VALUE-100 ? answer : -1;
    }
    
    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();
    private int helper(int i, int prev, int[] arr1, int[] arr2) {
        if (i == arr1.length) {
            return 0;
        }
        if (dp.containsKey(new Pair<>(i, prev))) {
            return dp.get(new Pair<>(i, prev));
        }

        int operation = Integer.MAX_VALUE-100;

        
        if (arr1[i] > prev) {
            operation = Math.min(operation, helper(i + 1, arr1[i], arr1, arr2));
        }

       
        int idx = binarySearch(arr2, prev);

        
        if (idx < arr2.length) {
            operation = Math.min(operation, 1 + helper(i + 1, arr2[idx], arr1, arr2));
        }

        dp.put(new Pair<>(i, prev),operation);
        return operation;
    }
    
    private static int binarySearch(int[] arr, int value) {
        int left = 0, right = arr.length-1;
        while (left <= right) {
            int mid = left+(right-left) / 2;
            if (arr[mid] <= value) {
                left = mid + 1;
            } else {
                right = mid-1;
            }
        }
        return left;
    } 
}
"
1476,java,queens-that-can-attack-the-king,"class Solution {
    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {
        boolean[][] q = new boolean[8][8];
        for (int[] queen: queens) {
            q[queen[0]][queen[1]] = true;
        }
        List<List<Integer>> output = new ArrayList<>();
        int[][] moves = {{-1,-1}, {0,-1}, {1,-1},{1,0}, {1,1}, {0,1}, {-1,1}, {-1,0}};
        for(int i = 0; i < moves.length; i++){
            int k = king[0] + moves[i][0];
            int l = king[1] + moves[i][1];
            while(k >= 0 && l >=0 && k < 8 && l < 8){
                if(q[k][l]){
                    List<Integer> pair = new ArrayList<>();
                    pair.add(k);
                    pair.add(l);
                    output.add(pair);
                    break;
                }
                k = k + moves[i][1]; 
                l = l + moves[i][1];
            }
        }
        
        return output;
    }
}",None,"class Solution {
    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {
        boolean[][] q = new boolean[8][8];
        for (int[] queen: queens) {
            q[queen[0]][queen[1]] = true;
        }
        List<List<Integer>> output = new ArrayList<>();
        int[][] moves = {{-1,-1}, {0,-1}, {1,-1},{1,0}, {1,1}, {0,1}, {-1,1}, {-1,0}};
        for(int i = 0; i < moves.length; i++){
            int k = king[0] + moves[i][0];
            int l = king[1] + moves[i][1];
            while(k >= 0 && l >=0 && k < 8 && l < 8){
                if(q[k][l]){
                    List<Integer> pair = new ArrayList<>();
                    pair.add(k);
                    pair.add(l);
                    output.add(pair);
                    break;
                }
                k = k + moves[i][0]; 
                l = l + moves[i][1];
            }
        }
        
        return output;
    }
}
"
1476,java,queens-that-can-attack-the-king,"class Solution {
    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {
        boolean[][] q = new boolean[8][8];
        for (int[] queen: queens) {
            q[queen[0]][queen[1]] = true;
        }
        List<List<Integer>> output = new ArrayList<>();
        int[][] moves = {{-1,-1}, {0,-1}, {1,-1},{1,0}, {1,1}, {0,1}, {-1,1}, {-1,0}};
        for(int i = 0; i < moves.length; i++){
            int k = king[0] + moves[i][0];
            int l = king[1] + moves[i][1];
            while(k >= 0 && l >=0 && k < 8 && l < 8){
                if(q[k][l]){
                    List<Integer> pair = new ArrayList<>();
                    pair.add(k);
                    pair.add(l);
                    output.add(pair);
                    break;
                }
                k = k + moves[i][1]; 
                l = l + moves[i][1];
            }
        }
        
        return output;
    }
}",None,"class Solution {
    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {
        boolean[][] q = new boolean[8][8];
        for (int[] queen: queens) {
            q[queen[0]][queen[1]] = true;
        }
        List<List<Integer>> output = new ArrayList<>();
        int[][] moves = {{-1,-1}, {0,-1}, {1,-1},{1,0}, {1,1}, {0,1}, {-1,1}, {-1,0}};
        for(int i = 0; i < moves.length; i++){
            int k = king[0] + moves[i][0];
            int l = king[1] + moves[i][1];
            while(k >= 0 && l >=0 && k < 8 && l < 8){
                if(q[k][l]){
                    List<Integer> pair = new ArrayList<>();
                    pair.add(k);
                    pair.add(l);
                    output.add(pair);
                    break;
                }
                k = k + moves[i][0]; 
                l = l + moves[i][1];
            }
        }
        
        return output;
    }
}
"
1476,java,queens-that-can-attack-the-king,"class Solution {
    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {
        boolean[][] q = new boolean[8][8];
        for (int[] queen: queens) {
            q[queen[0]][queen[1]] = true;
        }
        List<List<Integer>> output = new ArrayList<>();
        int[][] moves = {{-1,-1}, {0,-1}, {1,-1},{1,0}, {1,1}, {0,1}, {-1,1}, {-1,0}};
        for(int i = 0; i < moves.length; i++){
            int k = king[0] + moves[i][0];
            int l = king[1] + moves[i][1];
            while(k >= 0 && l >=0 && k < 8 && l < 8){
                if(q[k][l]){
                    List<Integer> pair = new ArrayList<>();
                    pair.add(k);
                    pair.add(l);
                    output.add(pair);
                    break;
                }
                k = k + moves[i][1]; 
                l = l + moves[i][1];
            }
        }
        
        return output;
    }
}",None,"class Solution {
    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {
        boolean[][] q = new boolean[8][8];
        for (int[] queen: queens) {
            q[queen[0]][queen[1]] = true;
        }
        List<List<Integer>> output = new ArrayList<>();
        int[][] moves = {{-1,-1}, {0,-1}, {1,-1},{1,0}, {1,1}, {0,1}, {-1,1}, {-1,0}};
        for(int i = 0; i < moves.length; i++){
            int k = king[0] + moves[i][0];
            int l = king[1] + moves[i][1];
            while(k >= 0 && l >=0 && k < 8 && l < 8){
                if(q[k][l]){
                    List<Integer> pair = new ArrayList<>();
                    pair.add(k);
                    pair.add(l);
                    output.add(pair);
                    break;
                }
                k = k + moves[i][0]; 
                l = l + moves[i][1];
            }
        }
        
        return output;
    }
}
"
1477,java,maximize-number-of-subsequences-in-a-string,"class Solution {

    public long maximumSubsequenceCount(String s, String p) {
        long ans = 0, max = 0;
        int cnt = 1;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == p.charAt(1)) ans += cnt;
            if (s.charAt(i) == p.charAt(0)) cnt--;
        }
        max = Math.max(max, ans);
        ans = 0; cnt = 1;
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == p.charAt(0)) ans += cnt;
            if (s.charAt(i) == p.charAt(1)) cnt++;
        }
        max = Math.max(max, ans);
        return max;
    }
}",None,"class Solution {

    public long maximumSubsequenceCount(String s, String p) {
        long ans = 0, max = 0;
        long cnt = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == p.charAt(1)) ans += cnt;
            if (s.charAt(i) == p.charAt(0)) cnt++;
        }
        max = Math.max(max, ans);
        ans = 0; cnt = 0;
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == p.charAt(0)) ans += cnt;
            if (s.charAt(i) == p.charAt(1)) cnt++;
        }
        max = Math.max(max, ans);
        return max;
    }
}
"
1477,java,maximize-number-of-subsequences-in-a-string,"class Solution {

    public long maximumSubsequenceCount(String s, String p) {
        long ans = 0, max = 0;
        int cnt = 1;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == p.charAt(1)) ans += cnt;
            if (s.charAt(i) == p.charAt(0)) cnt--;
        }
        max = Math.max(max, ans);
        ans = 0; cnt = 1;
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == p.charAt(0)) ans += cnt;
            if (s.charAt(i) == p.charAt(1)) cnt++;
        }
        max = Math.max(max, ans);
        return max;
    }
}",None,"class Solution {
    public long maximumSubsequenceCount(String s, String p) {
        long ans = 0, max = 0;
        int cnt = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == p.charAt(1)) ans += cnt;
            if (s.charAt(i) == p.charAt(0)) cnt++;
        }
        max = Math.max(max, ans);
        ans = 0; cnt = 0;
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == p.charAt(0)) ans += cnt;
            if (s.charAt(i) == p.charAt(1)) cnt++;
        }
        max = Math.max(max, ans);
        return max;
    }
}
"
1477,java,maximize-number-of-subsequences-in-a-string,"class Solution {

    public long maximumSubsequenceCount(String s, String p) {
        long ans = 0, max = 0;
        int cnt = 1;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == p.charAt(1)) ans += cnt;
            if (s.charAt(i) == p.charAt(0)) cnt--;
        }
        max = Math.max(max, ans);
        ans = 0; cnt = 1;
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == p.charAt(0)) ans += cnt;
            if (s.charAt(i) == p.charAt(1)) cnt++;
        }
        max = Math.max(max, ans);
        return max;
    }
}",None,"class Solution {

    public long maximumSubsequenceCount(String s, String p) {
        long ans = 0, max = 0;
        int cnt = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == p.charAt(0)) cnt++;
            if (s.charAt(i) == p.charAt(1)) ans += cnt;
        }
        max = Math.max(max, ans);
        ans = 0; cnt = 0;
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == p.charAt(1)) cnt++;
            if (s.charAt(i) == p.charAt(0)) ans += cnt;
        }
        max = Math.max(max, ans);
        return max;
    }
}
"
1478,java,destroying-asteroids,"class Solution {
    public boolean asteroidsDestroyed(int mass, int[] asteroids) {
        Arrays.sort(asteroids);
        int c=0;
        long s=(long)mass;
        for(int i=0;i<asteroids.length;i++)
        {
            long d=(long)asteroids[i];
            if(s>=d)
            {
                c-=1;
                s+=d;
            }
        }
        if(c==asteroids.length)return true;
        else return false;
    }
}",None,"class Solution {
    public boolean asteroidsDestroyed(int mass, int[] asteroids) {
        Arrays.sort(asteroids);
        int c=0;
        long s=(long)mass;
        for(int i=0;i<asteroids.length;i++)
        {
            long d=(long)asteroids[i];
            if(s>=d)
            {
                c++;
                s+=d;
            }
        }
        if(c==asteroids.length)return true;
        else return false;
    }
}
"
1478,java,destroying-asteroids,"class Solution {
    public boolean asteroidsDestroyed(int mass, int[] asteroids) {
        Arrays.sort(asteroids);
        int c=0;
        long s=(long)mass;
        for(int i=0;i<asteroids.length;i++)
        {
            long d=(long)asteroids[i];
            if(s>=d)
            {
                c-=1;
                s+=d;
            }
        }
        if(c==asteroids.length)return true;
        else return false;
    }
}",None,"class Solution {
    public boolean asteroidsDestroyed(int mass, int[] asteroids) {
        Arrays.sort(asteroids);
        int c=0;
        long s=(long)mass;
        for(int i=0;i<asteroids.length;i++)
        {
            long d=(long)asteroids[i];
            if(s>=d)
            {
                c++;
                s+=d;
            }
        }
        if(c==asteroids.length)return true;
        else return false;
    }
}
"
1478,java,destroying-asteroids,"class Solution {
    public boolean asteroidsDestroyed(int mass, int[] asteroids) {
        Arrays.sort(asteroids);
        int c=0;
        long s=(long)mass;
        for(int i=0;i<asteroids.length;i++)
        {
            long d=(long)asteroids[i];
            if(s>=d)
            {
                c-=1;
                s+=d;
            }
        }
        if(c==asteroids.length)return true;
        else return false;
    }
}",None,"class Solution {
    public boolean asteroidsDestroyed(int mass, int[] asteroids) {
        Arrays.sort(asteroids);
        int c=0;
        long s=(long)mass;
        for(int i=0;i<asteroids.length;i++)
        {
            long d=(long)asteroids[i];
            if(s>=d)
            {
                c+=1; // Correction
                s+=d;
            }
        }
        if(c==asteroids.length)return true;
        else return false;
    }
}
"
1479,java,maximum-number-of-achievable-transfer-requests,"class Solution:
    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:
        l=len(requests)
        for i in range(l,0,-1):
            for j in combinations(requests,i):
                if Counter(x for x ,y in j)==Counter(y for x,y in j):
                    return i-1
        return 0",None,"class Solution:
    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:
        l=len(requests)
        for i in range(l,0,-1):
            for j in combinations(requests,i):
                if Counter(x for x ,y in j)==Counter(y for x,y in j):
                    return i
        return 0
"
1479,java,maximum-number-of-achievable-transfer-requests,"class Solution:
    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:
        l=len(requests)
        for i in range(l,0,-1):
            for j in combinations(requests,i):
                if Counter(x for x ,y in j)==Counter(y for x,y in j):
                    return i-1
        return 0",None,"class Solution:
    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:
        l=len(requests)
        for i in range(l,0,-1):
            for j in itertools.combinations(requests,i):
                if collections.Counter(x for x ,y in j)==collections.Counter(y for x,y in j):
                    return i
        return 0
"
1479,java,maximum-number-of-achievable-transfer-requests,"class Solution:
    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:
        l=len(requests)
        for i in range(l,0,-1):
            for j in combinations(requests,i):
                if Counter(x for x ,y in j)==Counter(y for x,y in j):
                    return i-1
        return 0",None,"class Solution:
    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:
        l=len(requests)
        for i in range(l,0,-1):
            for j in combinations(requests,i):
                if Counter(x for x ,y in j)==Counter(y for x,y in j):
                    return i
        return 0
"
1480,java,orderly-queue,"class Solution {
    public String orderlyQueue(String s, int k) {
        if(k>1){
            char ch[]=s.toCharArray();  
            Arrays.sort(ch);
            return String.valueOf(ch);
        }
        else{
             String str2=new String(s);
             for(int i=0;i<s.length();i++){
                s=s.substring(2)+s.charAt(1); 
                if(str2.compareTo(s)>0){
                    str2=s;
                } 
             }
             return str2;
        }     
    }
}",None,"class Solution {
    public String orderlyQueue(String s, int k) {
        if(k > 1){
            char ch[]=s.toCharArray();  
            Arrays.sort(ch);
            return String.valueOf(ch);
        }
        else{
            String str2 = s;
            for(int i=0;i<s.length();i++){
                s = s.substring(1) + s.charAt(0); 
                if(str2.compareTo(s) > 0){
                    str2 = s;
                } 
            }
            return str2;
        }     
    }
}
"
1480,java,orderly-queue,"class Solution {
    public String orderlyQueue(String s, int k) {
        if(k>1){
            char ch[]=s.toCharArray();  
            Arrays.sort(ch);
            return String.valueOf(ch);
        }
        else{
             String str2=new String(s);
             for(int i=0;i<s.length();i++){
                s=s.substring(2)+s.charAt(1); 
                if(str2.compareTo(s)>0){
                    str2=s;
                } 
             }
             return str2;
        }     
    }
}",None,"class Solution {
    public String orderlyQueue(String s, int k) {
        if(k>1){
            char ch[]=s.toCharArray();  
            Arrays.sort(ch);
            return String.valueOf(ch);
        }
        else{
             String str2=new String(s);
             for(int i=0;i<s.length();i++){
                s=s.substring(1)+s.charAt(0); 
                if(str2.compareTo(s)>0){
                    str2=s;
                } 
             }
             return str2;
        }     
    }
}
"
1480,java,orderly-queue,"class Solution {
    public String orderlyQueue(String s, int k) {
        if(k>1){
            char ch[]=s.toCharArray();  
            Arrays.sort(ch);
            return String.valueOf(ch);
        }
        else{
             String str2=new String(s);
             for(int i=0;i<s.length();i++){
                s=s.substring(2)+s.charAt(1); 
                if(str2.compareTo(s)>0){
                    str2=s;
                } 
             }
             return str2;
        }     
    }
}",None,"class Solution {
    public String orderlyQueue(String s, int k) {
        if(k>1){
            char ch[]=s.toCharArray();  
            Arrays.sort(ch);
            return new String(ch);
        }
        else{
             String str2=new String(s);
             for(int i=0;i<s.length();i++){
                s=s.substring(1)+s.charAt(0); 
                if(str2.compareTo(s)>0){
                    str2=s;
                } 
             }
             return str2;
        }     
    }
}
"
1481,java,find-palindrome-with-fixed-length,"class Solution {
    public long[] kthPalindrome(int[] queries, int intLength) {
        int n=queries.length;
        long ans[]=new long[n];
        int ans_i=0;
        
        
        int palindrome_present = ( intLength+1 )/2 ;
        
        long l=(long)Math.pow(10,palindrome_present-1);
        long r=(long)Math.pow(10,palindrome_present)-1;
        for(int q:queries){
            
            if(q<=(r-l+1)){
                String left_half=Long.toString(l+q-1);
                String right_half=(new StringBuilder(left_half)).reverse().toString();
                ans[ans_i]=-1; 
                
            }
            else{
                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );
            }
            
            ans_i++;
        }
        
        return ans;
    }
}",None,"class Solution {
    public long[] kthPalindrome(int[] queries, int intLength) {
        int n=queries.length;
        long ans[]=new long[n];
        int ans_i=0;
        
        int palindrome_present = ( intLength+1 )/2 ;
        
        long l=(long)Math.pow(10,palindrome_present-1);
        long r=(long)Math.pow(10,palindrome_present)-1;
        for(int q:queries){
            
            if(q>(r-l+1)){
                ans[ans_i]=-1; 
            }
            else{
                String left_half=Long.toString(l+q-1);
                String right_half=(new StringBuilder(left_half)).reverse().toString();
                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );
            }
            
            ans_i++;
        }
        
        return ans;
    }
}
"
1481,java,find-palindrome-with-fixed-length,"class Solution {
    public long[] kthPalindrome(int[] queries, int intLength) {
        int n=queries.length;
        long ans[]=new long[n];
        int ans_i=0;
        
        
        int palindrome_present = ( intLength+1 )/2 ;
        
        long l=(long)Math.pow(10,palindrome_present-1);
        long r=(long)Math.pow(10,palindrome_present)-1;
        for(int q:queries){
            
            if(q<=(r-l+1)){
                String left_half=Long.toString(l+q-1);
                String right_half=(new StringBuilder(left_half)).reverse().toString();
                ans[ans_i]=-1; 
                
            }
            else{
                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );
            }
            
            ans_i++;
        }
        
        return ans;
    }
}",None,"class Solution {
    public long[] kthPalindrome(int[] queries, int intLength) {
        int n=queries.length;
        long ans[]=new long[n];
        
        
        int palindrome_present = ( intLength+1 )/2 ;
        
        long l=(long)Math.pow(10,palindrome_present-1);
        long r=(long)Math.pow(10,palindrome_present)-1;
        for(int i=0; i<n; i++){
            int q=queries[i];
            
            if(q<=(r-l+1)){
                String left_half=Long.toString(l+q-1);
                String right_half=(new StringBuilder(left_half)).reverse().toString();
                ans[i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );  
            }
            else{
                ans[i]=-1; 
            }           
        }
        
        return ans;
    }
}
"
1481,java,find-palindrome-with-fixed-length,"class Solution {
    public long[] kthPalindrome(int[] queries, int intLength) {
        int n=queries.length;
        long ans[]=new long[n];
        int ans_i=0;
        
        
        int palindrome_present = ( intLength+1 )/2 ;
        
        long l=(long)Math.pow(10,palindrome_present-1);
        long r=(long)Math.pow(10,palindrome_present)-1;
        for(int q:queries){
            
            if(q<=(r-l+1)){
                String left_half=Long.toString(l+q-1);
                String right_half=(new StringBuilder(left_half)).reverse().toString();
                ans[ans_i]=-1; 
                
            }
            else{
                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );
            }
            
            ans_i++;
        }
        
        return ans;
    }
}",None,"class Solution {
    public long[] kthPalindrome(int[] queries, int intLength) {
        int n=queries.length;
        long ans[]=new long[n];
        
        int palindrome_present = ( intLength+1 ) /2 ;
        long start=(long)Math.pow(10, palindrome_present-1);
        long end=(long)Math.pow(10, palindrome_present)-1;
        
        for(int i = 0; i < n; i++){
            if(queries[i] > (end - start + 1)){
                ans[i] = -1;
            } else{
                String left_half = Long.toString(start + queries[i] - 1);
                String right_half = (new StringBuilder(left_half)).reverse().toString();
                ans[i] = Long.parseLong( left_half + right_half.substring(intLength % 2 ));
            }
        }
        
        return ans;
    }
}
"
1482,java,maximum-product-difference-between-two-pairs,"class Solution {
    public int maxProductDifference(int[] nums) {
        Arrays.sort(nums);
        int n =nums.length;
    return nums[n-1]*nums[n-3]-nums[0]*nums[1];
    }
}",None,"class Solution {
    public int maxProductDifference(int[] nums) {
        Arrays.sort(nums);
        int n =nums.length;
        return nums[n-1]*nums[n-2]-nums[0]*nums[1];
    }
}
"
1482,java,maximum-product-difference-between-two-pairs,"class Solution {
    public int maxProductDifference(int[] nums) {
        Arrays.sort(nums);
        int n =nums.length;
    return nums[n-1]*nums[n-3]-nums[0]*nums[1];
    }
}",None,"class Solution {
    public int maxProductDifference(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        return nums[n-1]*nums[n-2]-nums[0]*nums[1];
    }
}
"
1482,java,maximum-product-difference-between-two-pairs,"class Solution {
    public int maxProductDifference(int[] nums) {
        Arrays.sort(nums);
        int n =nums.length;
    return nums[n-1]*nums[n-3]-nums[0]*nums[1];
    }
}",None,"class Solution {
    public int maxProductDifference(int[] nums) {
        Arrays.sort(nums);
        int n =nums.length;
    return nums[n-1]*nums[n-2]-nums[0]*nums[1];
    }
}
"
1483,java,arithmetic-slices-ii-subsequence,"class Solution {
	public int numberOfArithmeticSlices(int[] arr) {
		int n = arr.length;
		HashMap<Integer, Integer>[] map = new HashMap[n];
		for (int i = 0; i < n; i++) {
			map[i] = new HashMap<>();
		}
		int ans = 0;
		for (int i = 1; i < n; i++) {
			for (int j = 0; j < i; j++) {
				long cd = (long) arr[i] - (long) arr[j];
				if (cd <= Integer.MIN_VALUE || cd >= Integer.MAX_VALUE)
					continue;
				int asj = map[j].getOrDefault((int) cd, 0);
				int asi = map[i].getOrDefault((int) cd, 0);
				ans += asj;
				map[i].put((int) cd, asi + 1); 
			}
		}
		return ans;
	}
}",None,"class Solution {
	public int numberOfArithmeticSlices(int[] arr) {
		int n = arr.length;
		HashMap<Integer, Integer>[] map = new HashMap[n];
		for (int i = 0; i < n; i++) {
			map[i] = new HashMap<>();
		}
		int ans = 0;
		for (int i = 1; i < n; i++) {
			for (int j = 0; j < i; j++) {
				long cd = (long) arr[i] - (long) arr[j];
				if (cd <= Integer.MIN_VALUE || cd >= Integer.MAX_VALUE)
					continue;
				int asj = map[j].getOrDefault((int) cd, 0);
				int asi = map[i].getOrDefault((int) cd, 0);
				ans += asj;
				map[i].put((int) cd, asi + asj + 1); 
			}
		}
		return ans;
	}
}
"
1483,java,arithmetic-slices-ii-subsequence,"class Solution {
	public int numberOfArithmeticSlices(int[] arr) {
		int n = arr.length;
		HashMap<Integer, Integer>[] map = new HashMap[n];
		for (int i = 0; i < n; i++) {
			map[i] = new HashMap<>();
		}
		int ans = 0;
		for (int i = 1; i < n; i++) {
			for (int j = 0; j < i; j++) {
				long cd = (long) arr[i] - (long) arr[j];
				if (cd <= Integer.MIN_VALUE || cd >= Integer.MAX_VALUE)
					continue;
				int asj = map[j].getOrDefault((int) cd, 0);
				int asi = map[i].getOrDefault((int) cd, 0);
				ans += asj;
				map[i].put((int) cd, asi + 1); 
			}
		}
		return ans;
	}
}",None,"class Solution {
    public int numberOfArithmeticSlices(int[] arr) {
        int n = arr.length;
        HashMap<Integer, Integer>[] map = new HashMap[n];
        for (int i = 0; i < n; i++) {
            map[i] = new HashMap<>();
        }
        int ans = 0;
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                long cd = (long) arr[i] - (long) arr[j];
                if (cd <= Integer.MIN_VALUE || cd >= Integer.MAX_VALUE)
                    continue;
                int asj = map[j].getOrDefault((int) cd, 0);
                int asi = map[i].getOrDefault((int) cd, 0);
                ans += asj;
                map[i].put((int) cd, asi + asj + 1); 
            }
        }
        return ans;
    }
}
"
1483,java,arithmetic-slices-ii-subsequence,"class Solution {
	public int numberOfArithmeticSlices(int[] arr) {
		int n = arr.length;
		HashMap<Integer, Integer>[] map = new HashMap[n];
		for (int i = 0; i < n; i++) {
			map[i] = new HashMap<>();
		}
		int ans = 0;
		for (int i = 1; i < n; i++) {
			for (int j = 0; j < i; j++) {
				long cd = (long) arr[i] - (long) arr[j];
				if (cd <= Integer.MIN_VALUE || cd >= Integer.MAX_VALUE)
					continue;
				int asj = map[j].getOrDefault((int) cd, 0);
				int asi = map[i].getOrDefault((int) cd, 0);
				ans += asj;
				map[i].put((int) cd, asi + 1); 
			}
		}
		return ans;
	}
}",None,"class Solution {
	public int numberOfArithmeticSlices(int[] arr) {
		int n = arr.length;
		HashMap<Integer, Integer>[] map = new HashMap[n];
		for (int i = 0; i < n; i++) {
			map[i] = new HashMap<>();
		}
		int ans = 0;
		for (int i = 1; i < n; i++) {
			for (int j = 0; j < i; j++) {
				long cd = (long) arr[i] - (long) arr[j];
				if (cd <= Integer.MIN_VALUE || cd >= Integer.MAX_VALUE)
					continue;
				int asj = map[j].getOrDefault((int) cd, 0);
				int asi = map[i].getOrDefault((int) cd, 0);
				ans += asj;
				map[i].put((int) cd, asi + asj + 1); 
			}
		}
		return ans;
	}
}
"
1484,java,largest-substring-between-two-equal-characters,"class Solution {
    public int maxLengthBetweenEqualCharacters(String s) {
        int res=-1;
        HashMap<Character,Integer> hm=new HashMap<>();
        for(int i=0;i<s.length();i++){
            char c=s.charAt(i);
            if(hm.containsKey(c))
                res=Math.max(res,i-hm.get(c)+1); 
            else
                hm.put(c,i);
        }

        return res;
    }
}",None,"class Solution {
    public int maxLengthBetweenEqualCharacters(String s) {
        int res=-1;
        HashMap<Character,Integer> hm=new HashMap<>();
        for(int i=0;i<s.length();i++){
            char c=s.charAt(i);
            if(hm.containsKey(c))
                res=Math.max(res,i-hm.get(c)-1); 
            else
                hm.put(c,i);
        }

        return res;
    }
}
"
1484,java,largest-substring-between-two-equal-characters,"class Solution {
    public int maxLengthBetweenEqualCharacters(String s) {
        int res=-1;
        HashMap<Character,Integer> hm=new HashMap<>();
        for(int i=0;i<s.length();i++){
            char c=s.charAt(i);
            if(hm.containsKey(c))
                res=Math.max(res,i-hm.get(c)+1); 
            else
                hm.put(c,i);
        }

        return res;
    }
}",None,"class Solution {
    public int maxLengthBetweenEqualCharacters(String s) {
        int res = -1;
        HashMap<Character, Integer> hm = new HashMap<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (hm.containsKey(c)) {
                res = Math.max(res, i - hm.get(c) - 1); 
            } else {
                hm.put(c, i);
            }
        }

        return res;
    }
}
"
1484,java,largest-substring-between-two-equal-characters,"class Solution {
    public int maxLengthBetweenEqualCharacters(String s) {
        int res=-1;
        HashMap<Character,Integer> hm=new HashMap<>();
        for(int i=0;i<s.length();i++){
            char c=s.charAt(i);
            if(hm.containsKey(c))
                res=Math.max(res,i-hm.get(c)+1); 
            else
                hm.put(c,i);
        }

        return res;
    }
}",None,"class Solution {
    public int maxLengthBetweenEqualCharacters(String s) {
        int res=-1;
        HashMap<Character,Integer> hm=new HashMap<>();
        for(int i=0;i<s.length();i++){
            char c=s.charAt(i);
            if(hm.containsKey(c))
                res=Math.max(res,i-hm.get(c)-1); 
            else
                hm.put(c,i);
        }

        return res;
    }
}
"
1485,java,difference-between-element-sum-and-digit-sum-of-an-array,"class Solution {
    public int differenceOfSum(int[] nums) {
        
        int sum=0;
        int digitSum=0;

        for(int num:nums){
            sum+=num;

            while(num>0){
                int digit=num%10;
                digitSum+=digit;
                num=num/100;
            }

        }

        return sum-digitSum;
    }
}",None,"class Solution {
    public int differenceOfSum(int[] nums) {
        
        int sum=0;
        int digitSum=0;

        for(int num:nums){
            sum+=num;

            while(num>0){
                int digit=num%10;
                digitSum+=digit;
                num=num/10;
            }

        }

        return Math.abs(sum-digitSum);
    }
}
"
1485,java,difference-between-element-sum-and-digit-sum-of-an-array,"class Solution {
    public int differenceOfSum(int[] nums) {
        
        int sum=0;
        int digitSum=0;

        for(int num:nums){
            sum+=num;

            while(num>0){
                int digit=num%10;
                digitSum+=digit;
                num=num/100;
            }

        }

        return sum-digitSum;
    }
}",None,"class Solution {
    public int differenceOfSum(int[] nums) {
        
        int sum=0;
        int digitSum=0;

        for(int num:nums){
            sum+=num;

            while(num>0){
                int digit=num%10;
                digitSum+=digit;
                num=num/10;
            }

        }

        return Math.abs(sum-digitSum);
    }
}
"
1485,java,difference-between-element-sum-and-digit-sum-of-an-array,"class Solution {
    public int differenceOfSum(int[] nums) {
        
        int sum=0;
        int digitSum=0;

        for(int num:nums){
            sum+=num;

            while(num>0){
                int digit=num%10;
                digitSum+=digit;
                num=num/100;
            }

        }

        return sum-digitSum;
    }
}",None,"class Solution {
    public int differenceOfSum(int[] nums) {
        
        int sum=0;
        int digitSum=0;

        for(int num:nums){
            sum+=num;

            while(num>0){
                int digit=num%10;
                digitSum+=digit;
                num=num/10;
            }

        }

        return Math.abs(sum-digitSum);
    }
}
"
1486,java,reverse-words-in-a-string,"class Solution {
    public String reverseWords(String s) {
        StringBuilder ans = new StringBuilder();
        for(int i=s.length()-1; i>=0; i--){
            if(s.charAt(i)==' '){
                continue;
            }
            int start=-1;
            for(int y=i-1; y>=0; y--){
                if(s.charAt(y)==' '){
                    start=y;
                    break;
                }
            }
            ans.append(s.substring(start+1, i) + "" "");
            i=start;
        }
        ans.deleteCharAt(ans.length()-1);
        return ans.toString();
    }
}",None,"class Solution {
    public String reverseWords(String s) {
        String[] words = s.trim().split(""\\s+"");
        StringBuilder ans = new StringBuilder();
        for(int i=words.length-1; i>=0; i--){
            ans.append(words[i] + "" "");
        }
        return ans.toString().trim();
    }
}
"
1486,java,reverse-words-in-a-string,"class Solution {
    public String reverseWords(String s) {
        StringBuilder ans = new StringBuilder();
        for(int i=s.length()-1; i>=0; i--){
            if(s.charAt(i)==' '){
                continue;
            }
            int start=-1;
            for(int y=i-1; y>=0; y--){
                if(s.charAt(y)==' '){
                    start=y;
                    break;
                }
            }
            ans.append(s.substring(start+1, i) + "" "");
            i=start;
        }
        ans.deleteCharAt(ans.length()-1);
        return ans.toString();
    }
}",None,"class Solution {
    public String reverseWords(String s) {
        String[] words = s.trim().split(""\\s+"");
        StringBuilder ans = new StringBuilder();
        for(int i=words.length-1; i>=0; i--){
            ans.append(words[i]);
            if(i != 0) ans.append("" "");
        }
        return ans.toString();
    }
}
"
1486,java,reverse-words-in-a-string,"class Solution {
    public String reverseWords(String s) {
        StringBuilder ans = new StringBuilder();
        for(int i=s.length()-1; i>=0; i--){
            if(s.charAt(i)==' '){
                continue;
            }
            int start=-1;
            for(int y=i-1; y>=0; y--){
                if(s.charAt(y)==' '){
                    start=y;
                    break;
                }
            }
            ans.append(s.substring(start+1, i) + "" "");
            i=start;
        }
        ans.deleteCharAt(ans.length()-1);
        return ans.toString();
    }
}",None,"class Solution {
    public String reverseWords(String s) {
        StringBuilder ans = new StringBuilder();
        int j = s.length();
        for(int i = s.length() - 1; i >= 0; i--){
            if(s.charAt(i) == ' '){
                j = i;
            }
            else if(i == 0 || s.charAt(i - 1) == ' '){
                if(ans.length() != 0){
                    ans.append(' ');
                }
                ans.append(s.substring(i, j));
            }
        }
        return ans.toString();
    }
}
"
1487,java,number-of-arithmetic-triplets,"class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        int ans =0;
        for(int i=0; i<nums.length-2;i++){
            int count =0;
            for(int j=i+1; j<nums.length; j++){
                if(nums[j]-nums[i]==diff || nums[j]+nums[i]==2*diff){
                    count++;
                }
            }
            if(count >= 2){
                ans++;
            }
        }

        return ans;
        
    }
}",None,"class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        int ans =0;
        for(int i=0; i<nums.length-2;i++){
            for(int j=i+1; j<nums.length-1; j++){
                if(nums[j]-nums[i]==diff){
                    for(int k=j+1; k<nums.length; k++){
                        if(nums[k]-nums[j]==diff){
                            ans++;
                        }
                    }
                }
            }
        }

        return ans;
    }
}
"
1487,java,number-of-arithmetic-triplets,"class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        int ans =0;
        for(int i=0; i<nums.length-2;i++){
            int count =0;
            for(int j=i+1; j<nums.length; j++){
                if(nums[j]-nums[i]==diff || nums[j]+nums[i]==2*diff){
                    count++;
                }
            }
            if(count >= 2){
                ans++;
            }
        }

        return ans;
        
    }
}",None,"class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        int ans = 0;
        for(int i=0; i<nums.length-2; i++){
            for(int j=i+1; j<nums.length-1; j++){
                if(nums[j] - nums[i] == diff){
                    for(int k=j+1; k<nums.length; k++){
                        if(nums[k] - nums[j] == diff){
                            ans++;
                        }
                    }
                }
            }
        }
        return ans;
    }
}
"
1487,java,number-of-arithmetic-triplets,"class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        int ans =0;
        for(int i=0; i<nums.length-2;i++){
            int count =0;
            for(int j=i+1; j<nums.length; j++){
                if(nums[j]-nums[i]==diff || nums[j]+nums[i]==2*diff){
                    count++;
                }
            }
            if(count >= 2){
                ans++;
            }
        }

        return ans;
        
    }
}",None,"class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        int ans = 0;
        for(int i=0; i<nums.length-2;i++){
            for(int j=i+1; j<nums.length-1; j++){
                if(nums[j]-nums[i]==diff){
                    for(int k=j+1; k<nums.length; k++){
                        if(nums[k]-nums[j]==diff){
                            ans++;
                        }
                    }
                }
            }
        }

        return ans;
        
    }
}
"
1488,java,remove-duplicates-from-sorted-array-ii,"class Solution {
    public int removeDuplicates(int[] nums) {
     int   index = 1;
      int  count = 0;
        for(int i = 1;i<nums.length;i++){
            if(nums[i] == nums[i-1]){
                count++;
            }
            else{
                count++;
            }

            if(count <= 1){
                nums[index] = nums[i];
                index++;
            }
        }
        return index;
    }
}",None,"class Solution {
    public int removeDuplicates(int[] nums) {
        int index = 1;
        int count = 1;
        for(int i = 1; i < nums.length; i++){
            if(nums[i] == nums[i-1]){
                count++;
            } else {
                count = 1;
            }

            if(count <= 2){
                nums[index] = nums[i];
                index++;
            }
        }
        return index;
    }
}
"
1488,java,remove-duplicates-from-sorted-array-ii,"class Solution {
    public int removeDuplicates(int[] nums) {
     int   index = 1;
      int  count = 0;
        for(int i = 1;i<nums.length;i++){
            if(nums[i] == nums[i-1]){
                count++;
            }
            else{
                count++;
            }

            if(count <= 1){
                nums[index] = nums[i];
                index++;
            }
        }
        return index;
    }
}",None,"class Solution {
    public int removeDuplicates(int[] nums) {
        int index = 1;
        int count = 1;
        for(int i = 1; i<nums.length; i++){
            if(nums[i] == nums[i-1]){
                count++;
            } else {
                count = 1;
            }

            if(count <= 2){
                nums[index] = nums[i];
                index++;
            }
        }
        return index;
    }
}
"
1488,java,remove-duplicates-from-sorted-array-ii,"class Solution {
    public int removeDuplicates(int[] nums) {
     int   index = 1;
      int  count = 0;
        for(int i = 1;i<nums.length;i++){
            if(nums[i] == nums[i-1]){
                count++;
            }
            else{
                count++;
            }

            if(count <= 1){
                nums[index] = nums[i];
                index++;
            }
        }
        return index;
    }
}",None,"class Solution {
    public int removeDuplicates(int[] nums) {
        int index = 1;
        int count = 1;
        for(int i = 1; i < nums.length; i++){
            if(nums[i] == nums[i-1]){
                count++;
            }
            else{
                count = 1;
            }

            if(count <= 2){
                nums[index] = nums[i];
                index++;
            }
        }
        return index;
    }
}
"
1489,java,construct-binary-tree-from-inorder-and-postorder-traversal,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int index;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        Map<Integer, Integer> m = new HashMap<>();

        for(int i = 0; i < inorder.length; i++) {
            m.put(inorder[i], i);
        }
        index = postorder.length - 1;
        
        return buildTree(0, postorder.length - 2, postorder, m);
    }

    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {
        if(l > r) return null;

        int val = postorder[index];
        index--;

        TreeNode root = new TreeNode(val);
        if(l == r) return root;

        int in = m.get(val);

        root.right = buildTree(in + 1, r, postorder, m);
        root.left = buildTree(l, in - 1, postorder, m);

        return root;
    }
}",None,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int index;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        Map<Integer, Integer> m = new HashMap<>();

        for(int i = 0; i < inorder.length; i++) {
            m.put(inorder[i], i);
        }
        index = postorder.length - 1;
        
        return buildTree(0, postorder.length - 1, postorder, m);
    }

    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {
        if(l > r) return null;

        int val = postorder[index];
        index--;

        TreeNode root = new TreeNode(val);
        if(l == r) return root;

        int in = m.get(val);

        root.right = buildTree(in + 1, r, postorder, m);
        root.left = buildTree(l, in - 1, postorder, m);

        return root;
    }
}
"
1489,java,construct-binary-tree-from-inorder-and-postorder-traversal,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int index;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        Map<Integer, Integer> m = new HashMap<>();

        for(int i = 0; i < inorder.length; i++) {
            m.put(inorder[i], i);
        }
        index = postorder.length - 1;
        
        return buildTree(0, postorder.length - 2, postorder, m);
    }

    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {
        if(l > r) return null;

        int val = postorder[index];
        index--;

        TreeNode root = new TreeNode(val);
        if(l == r) return root;

        int in = m.get(val);

        root.right = buildTree(in + 1, r, postorder, m);
        root.left = buildTree(l, in - 1, postorder, m);

        return root;
    }
}",None,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int index;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        Map<Integer, Integer> m = new HashMap<>();

        for(int i = 0; i < inorder.length; i++) {
            m.put(inorder[i], i);
        }
        index = postorder.length - 1;
        
        return buildTree(0, postorder.length - 1, postorder, m);
    }

    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {
        if(l > r) return null;

        int val = postorder[index];
        index--;

        TreeNode root = new TreeNode(val);
        if(l == r) return root;

        int in = m.get(val);

        root.right = buildTree(in + 1, r, postorder, m);
        root.left = buildTree(l, in - 1, postorder, m);

        return root;
    }
}
"
1489,java,construct-binary-tree-from-inorder-and-postorder-traversal,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int index;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        Map<Integer, Integer> m = new HashMap<>();

        for(int i = 0; i < inorder.length; i++) {
            m.put(inorder[i], i);
        }
        index = postorder.length - 1;
        
        return buildTree(0, postorder.length - 2, postorder, m);
    }

    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {
        if(l > r) return null;

        int val = postorder[index];
        index--;

        TreeNode root = new TreeNode(val);
        if(l == r) return root;

        int in = m.get(val);

        root.right = buildTree(in + 1, r, postorder, m);
        root.left = buildTree(l, in - 1, postorder, m);

        return root;
    }
}",None,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int index;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        Map<Integer, Integer> m = new HashMap<>();

        for(int i = 0; i < inorder.length; i++) {
            m.put(inorder[i], i);
        }
        index = postorder.length - 1;
        
        return buildTree(0, postorder.length - 1, postorder, m);
    }

    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {
        if(l > r) return null;

        int val = postorder[index];
        index--;

        TreeNode root = new TreeNode(val);
        if(l == r) return root;

        int in = m.get(val);

        root.right = buildTree(in + 1, r, postorder, m);
        root.left = buildTree(l, in - 1, postorder, m);

        return root;
    }
}
"
1490,java,convert-the-temperature,"class Solution {
    public double[] convertTemperature(double celsius) {
        double arr[] = new double[2];
        arr[1] = (celsius * 9.0/5.0) + 32.0;
        arr[0] = celsius + 237.15;
        return arr;
    }
}",None,"class Solution {
    public double[] convertTemperature(double celsius) {
        double arr[] = new double[2];
        arr[1] = (celsius * 9.0/5.0) + 32.0;
        arr[0] = celsius + 273.15;
        return arr;
    }
}
"
1490,java,convert-the-temperature,"class Solution {
    public double[] convertTemperature(double celsius) {
        double arr[] = new double[2];
        arr[1] = (celsius * 9.0/5.0) + 32.0;
        arr[0] = celsius + 237.15;
        return arr;
    }
}",None,"class Solution {
    public double[] convertTemperature(double celsius) {
        double arr[] = new double[2];
        arr[1] = (celsius * 9.0/5.0) + 32.0;
        arr[0] = celsius + 273.15;
        return arr;
    }
}
"
1490,java,convert-the-temperature,"class Solution {
    public double[] convertTemperature(double celsius) {
        double arr[] = new double[2];
        arr[1] = (celsius * 9.0/5.0) + 32.0;
        arr[0] = celsius + 237.15;
        return arr;
    }
}",None,"class Solution {
    public double[] convertTemperature(double celsius) {
        double arr[] = new double[2];
        arr[1] = (celsius * 9.0/5.0) + 32.0;
        arr[0] = celsius + 273.15;
        return arr;
    }
}
"
1491,java,longest-valid-parentheses,"class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> st = new Stack<>();
        st.push(-1);
        int n = 0;
        for(int i = 0; i < s.length(); i++)
        {
            if(s.charAt(i) == '(')
                st.push(i);
            else if(s.charAt(i) == ')')
            {
                st.pop();
                if(st.empty())
                    st.push(i);
                else
                    n = Math.max(n, i - st.pop());
            }
        }
        return n;
    }
}",None,"class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> st = new Stack<>();
        st.push(-1);
        int n = 0;
        for(int i = 0; i < s.length(); i++)
        {
            if(s.charAt(i) == '(')
                st.push(i);
            else if(s.charAt(i) == ')')
            {
                st.pop();
                if(st.empty())
                    st.push(i);
                else
                    n = Math.max(n, i - st.peek());
            }
        }
        return n;
    }
}
"
1491,java,longest-valid-parentheses,"class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> st = new Stack<>();
        st.push(-1);
        int n = 0;
        for(int i = 0; i < s.length(); i++)
        {
            if(s.charAt(i) == '(')
                st.push(i);
            else if(s.charAt(i) == ')')
            {
                st.pop();
                if(st.empty())
                    st.push(i);
                else
                    n = Math.max(n, i - st.pop());
            }
        }
        return n;
    }
}",None,"class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> st = new Stack<>();
        st.push(-1);
        int n = 0;
        for(int i = 0; i < s.length(); i++)
        {
            if(s.charAt(i) == '(')
                st.push(i);
            else if(s.charAt(i) == ')')
            {
                st.pop();
                if(st.empty())
                    st.push(i);
                else
                    n = Math.max(n, i - st.peek());
            }
        }
        return n;
    }
}
"
1491,java,longest-valid-parentheses,"class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> st = new Stack<>();
        st.push(-1);
        int n = 0;
        for(int i = 0; i < s.length(); i++)
        {
            if(s.charAt(i) == '(')
                st.push(i);
            else if(s.charAt(i) == ')')
            {
                st.pop();
                if(st.empty())
                    st.push(i);
                else
                    n = Math.max(n, i - st.pop());
            }
        }
        return n;
    }
}",None,"class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> st = new Stack<>();
        st.push(-1);
        int n = 0;
        for(int i = 0; i < s.length(); i++)
        {
            if(s.charAt(i) == '(')
                st.push(i);
            else if(s.charAt(i) == ')')
            {
                st.pop();
                if(st.empty())
                    st.push(i);
                else
                    n = Math.max(n, i - st.peek());
            }
        }
        return n;
    }
}
"
1492,java,maximum-strictly-increasing-cells-in-a-matrix,"class Solution {
    public int maxIncreasingCells(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        int[] rows = new int[m], cols = new int[n];
        int[] rowMaxVals = new int[m], colMaxVals = new int[n];
        
        int[] rowSubMaxVals = new int[m], colSubMaxVals = new int[n];
        for(int i=0;i<m;i++) {
            rows[i] = Integer.MIN_VALUE;
        }
        for(int i=0;i<n;i++) {
            cols[i] = Integer.MIN_VALUE;
        }
        PriorityQueue<int[]> queue = new PriorityQueue<>((int[] a, int[] b) -> {
            return a[0] - b[0];
        });
        for(int i=0;i<m;i++) {
            for(int j=0;j<n;j++) {
                queue.add(new int[]{mat[i][j], i, j});
            }
        }
        int res = 0;
        while(!queue.isEmpty()) {
            int[] arr = queue.remove();
            int val = arr[0], row = arr[1], col = arr[2];
            int cur = 1;
            if(val == rows[row]) {
                cur = Math.max(rowSubMaxVals[row] + 1, cur);
            } else {
                cur = Math.max(rowMaxVals[row] + 1, cur);
            }
            if(val == cols[col]) {
                cur = Math.max(colSubMaxVals[col] + 1, cur);
            } else {
                cur = Math.max(colMaxVals[col] + 2, cur); 
            }


            if(val > rows[row]) {
                rowSubMaxVals[row] = rowMaxVals[row];
                rows[row] = val;
            }
            if(val > cols[col]) {
                colSubMaxVals[col] = colMaxVals[col];
                cols[col] = val;
            }
            rowMaxVals[row] = Math.max(rowMaxVals[row], cur);
            colMaxVals[col] = Math.max(colMaxVals[col], cur);
            
            res = Math.max(res, cur);
        }
        
        return res;
    }
}",None,"class Solution {
    public int maxIncreasingCells(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        int[] rows = new int[m], cols = new int[n];
        int[] rowMaxVals = new int[m], colMaxVals = new int[n];

        for(int i=0;i<m;i++) {
            rows[i] = Integer.MIN_VALUE;
        }
        for(int i=0;i<n;i++) {
            cols[i] = Integer.MIN_VALUE;
        }
        PriorityQueue<int[]> queue = new PriorityQueue<>((int[] a, int[] b) -> {
            return a[0] - b[0];
        });
        for(int i=0;i<m;i++) {
            for(int j=0;j<n;j++) {
                queue.add(new int[]{mat[i][j], i, j});
            }
        }

        int res = 0;
        while(!queue.isEmpty()) {
            int[] arr = queue.remove();
            int val = arr[0], row = arr[1], col = arr[2];
            int cur = 1;
            if(val > rows[row]) {
                cur = rowMaxVals[row] + 1;
                rows[row] = val;
            } 
            if(val > cols[col]) {
                cur = Math.max(cur, colMaxVals[col] + 1);
                cols[col] = val;
            }
            rowMaxVals[row] = Math.max(rowMaxVals[row], cur);
            colMaxVals[col] = Math.max(colMaxVals[col], cur);
            res = Math.max(res, cur);
        }

        return res;
    }
}
"
1492,java,maximum-strictly-increasing-cells-in-a-matrix,"class Solution {
    public int maxIncreasingCells(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        int[] rows = new int[m], cols = new int[n];
        int[] rowMaxVals = new int[m], colMaxVals = new int[n];
        
        int[] rowSubMaxVals = new int[m], colSubMaxVals = new int[n];
        for(int i=0;i<m;i++) {
            rows[i] = Integer.MIN_VALUE;
        }
        for(int i=0;i<n;i++) {
            cols[i] = Integer.MIN_VALUE;
        }
        PriorityQueue<int[]> queue = new PriorityQueue<>((int[] a, int[] b) -> {
            return a[0] - b[0];
        });
        for(int i=0;i<m;i++) {
            for(int j=0;j<n;j++) {
                queue.add(new int[]{mat[i][j], i, j});
            }
        }
        int res = 0;
        while(!queue.isEmpty()) {
            int[] arr = queue.remove();
            int val = arr[0], row = arr[1], col = arr[2];
            int cur = 1;
            if(val == rows[row]) {
                cur = Math.max(rowSubMaxVals[row] + 1, cur);
            } else {
                cur = Math.max(rowMaxVals[row] + 1, cur);
            }
            if(val == cols[col]) {
                cur = Math.max(colSubMaxVals[col] + 1, cur);
            } else {
                cur = Math.max(colMaxVals[col] + 2, cur); 
            }


            if(val > rows[row]) {
                rowSubMaxVals[row] = rowMaxVals[row];
                rows[row] = val;
            }
            if(val > cols[col]) {
                colSubMaxVals[col] = colMaxVals[col];
                cols[col] = val;
            }
            rowMaxVals[row] = Math.max(rowMaxVals[row], cur);
            colMaxVals[col] = Math.max(colMaxVals[col], cur);
            
            res = Math.max(res, cur);
        }
        
        return res;
    }
}",None,"class Solution {
    public int maxIncreasingCells(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        int[] rows = new int[m], cols = new int[n];
        int[] rowMaxVals = new int[m], colMaxVals = new int[n];
        
        int[] rowSubMaxVals = new int[m], colSubMaxVals = new int[n];
        for(int i=0;i<m;i++) {
            rows[i] = Integer.MIN_VALUE;
        }
        for(int i=0;i<n;i++) {
            cols[i] = Integer.MIN_VALUE;
        }
        PriorityQueue<int[]> queue = new PriorityQueue<>((int[] a, int[] b) -> {
            return b[0] - a[0];
        });
        for(int i=0;i<m;i++) {
            for(int j=0;j<n;j++) {
                queue.add(new int[]{mat[i][j], i, j});
            }
        }
        int res = 0;
        while(!queue.isEmpty()) {
            int[] arr = queue.remove();
            int val = arr[0], row = arr[1], col = arr[2];
            int cur = 1;
            if(val == rows[row]) {
                cur = Math.max(rowSubMaxVals[row] + 1, cur);
            } else {
                cur = Math.max(rowMaxVals[row] + 1, cur);
            }
            if(val == cols[col]) {
                cur = Math.max(colSubMaxVals[col] + 1, cur);
            } else {
                cur = Math.max(colMaxVals[col] + 1, cur); 
            }


            if(val > rows[row]) {
                rowSubMaxVals[row] = rowMaxVals[row];
                rows[row] = val;
            }
            if(val > cols[col]) {
                colSubMaxVals[col] = colMaxVals[col];
                cols[col] = val;
            }
            rowMaxVals[row] = Math.max(rowMaxVals[row], cur);
            colMaxVals[col] = Math.max(colMaxVals[col], cur);
            
            res = Math.max(res, cur);
        }
        
        return res;
    }
}
"
1492,java,maximum-strictly-increasing-cells-in-a-matrix,"class Solution {
    public int maxIncreasingCells(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        int[] rows = new int[m], cols = new int[n];
        int[] rowMaxVals = new int[m], colMaxVals = new int[n];
        
        int[] rowSubMaxVals = new int[m], colSubMaxVals = new int[n];
        for(int i=0;i<m;i++) {
            rows[i] = Integer.MIN_VALUE;
        }
        for(int i=0;i<n;i++) {
            cols[i] = Integer.MIN_VALUE;
        }
        PriorityQueue<int[]> queue = new PriorityQueue<>((int[] a, int[] b) -> {
            return a[0] - b[0];
        });
        for(int i=0;i<m;i++) {
            for(int j=0;j<n;j++) {
                queue.add(new int[]{mat[i][j], i, j});
            }
        }
        int res = 0;
        while(!queue.isEmpty()) {
            int[] arr = queue.remove();
            int val = arr[0], row = arr[1], col = arr[2];
            int cur = 1;
            if(val == rows[row]) {
                cur = Math.max(rowSubMaxVals[row] + 1, cur);
            } else {
                cur = Math.max(rowMaxVals[row] + 1, cur);
            }
            if(val == cols[col]) {
                cur = Math.max(colSubMaxVals[col] + 1, cur);
            } else {
                cur = Math.max(colMaxVals[col] + 2, cur); 
            }


            if(val > rows[row]) {
                rowSubMaxVals[row] = rowMaxVals[row];
                rows[row] = val;
            }
            if(val > cols[col]) {
                colSubMaxVals[col] = colMaxVals[col];
                cols[col] = val;
            }
            rowMaxVals[row] = Math.max(rowMaxVals[row], cur);
            colMaxVals[col] = Math.max(colMaxVals[col], cur);
            
            res = Math.max(res, cur);
        }
        
        return res;
    }
}",None,"class Solution {
    public int maxIncreasingCells(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        int[] rows = new int[m], cols = new int[n];
        int[] rowMaxVals = new int[m], colMaxVals = new int[n];
        
        int[] rowSubMaxVals = new int[m], colSubMaxVals = new int[n];
        for(int i=0;i<m;i++) {
            rows[i] = Integer.MIN_VALUE;
        }
        for(int i=0;i<n;i++) {
            cols[i] = Integer.MIN_VALUE;
        }
        PriorityQueue<int[]> queue = new PriorityQueue<>((int[] a, int[] b) -> {
            return b[0] - a[0];
        });
        for(int i=0;i<m;i++) {
            for(int j=0;j<n;j++) {
                queue.add(new int[]{mat[i][j], i, j});
            }
        }
        int res = 0;
        while(!queue.isEmpty()) {
            int[] arr = queue.remove();
            int val = arr[0], row = arr[1], col = arr[2];
            int cur = 1;
            if(val > rows[row]) {
                rowSubMaxVals[row] = rowMaxVals[row];
                rows[row] = val;
            }
            if(val > cols[col]) {
                colSubMaxVals[col] = colMaxVals[col];
                cols[col] = val;
            }
            if(val == rows[row]) {
                cur = Math.max(rowSubMaxVals[row] + 1, cur);
            } else {
                cur = Math.max(rowMaxVals[row] + 1, cur);
            }
            if(val == cols[col]) {
                cur = Math.max(colSubMaxVals[col] + 1, cur);
            } else {
                cur = Math.max(colMaxVals[col] + 1, cur); 
            }

            rowMaxVals[row] = Math.max(rowMaxVals[row], cur);
            colMaxVals[col] = Math.max(colMaxVals[col], cur);
            
            res = Math.max(res, cur);
        }
        
        return res;
    }
}
"
1493,java,subrectangle-queries,"class SubrectangleQueries {
    int[][] ans;
    public SubrectangleQueries(int[][] rectangle) {
        ans = rectangle;
    }
    
    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {
        for(int i=row1; i<=row2; i++){
            for(int j=col1; j<=col2; j++){
                ans[i][j] = newValue;
                newValue++;
            }
        }
    }
    
    public int getValue(int row, int col) {
        int val = ans[row][col];
        return val;
    }
}

/**
 * Your SubrectangleQueries object will be instantiated and called as such:
 * SubrectangleQueries obj = new SubrectangleQueries(rectangle);
 * obj.updateSubrectangle(row1,col1,row2,col2,newValue);
 * int param_2 = obj.getValue(row,col);
 */",None,"class SubrectangleQueries {
    int[][] ans;
    public SubrectangleQueries(int[][] rectangle) {
        ans = rectangle;
    }
    
    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {
        for(int i=row1; i<=row2; i++){
            for(int j=col1; j<=col2; j++){
                ans[i][j] = newValue;
            }
        }
    }
    
    public int getValue(int row, int col) {
        int val = ans[row][col];
        return val;
    }
}

/**
 * Your SubrectangleQueries object will be instantiated and called as such:
 * SubrectangleQueries obj = new SubrectangleQueries(rectangle);
 * obj.updateSubrectangle(row1,col1,row2,col2,newValue);
 * int param_2 = obj.getValue(row,col);
 */
"
1493,java,subrectangle-queries,"class SubrectangleQueries {
    int[][] ans;
    public SubrectangleQueries(int[][] rectangle) {
        ans = rectangle;
    }
    
    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {
        for(int i=row1; i<=row2; i++){
            for(int j=col1; j<=col2; j++){
                ans[i][j] = newValue;
                newValue++;
            }
        }
    }
    
    public int getValue(int row, int col) {
        int val = ans[row][col];
        return val;
    }
}

/**
 * Your SubrectangleQueries object will be instantiated and called as such:
 * SubrectangleQueries obj = new SubrectangleQueries(rectangle);
 * obj.updateSubrectangle(row1,col1,row2,col2,newValue);
 * int param_2 = obj.getValue(row,col);
 */",None,"class SubrectangleQueries {
    int[][] ans;
    public SubrectangleQueries(int[][] rectangle) {
        ans = rectangle;
    }
    
    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {
        for(int i=row1; i<=row2; i++){
            for(int j=col1; j<=col2; j++){
                ans[i][j] = newValue;
            }
        }
    }
    
    public int getValue(int row, int col) {
        int val = ans[row][col];
        return val;
    }
}

/**
 * Your SubrectangleQueries object will be instantiated and called as such:
 * SubrectangleQueries obj = new SubrectangleQueries(rectangle);
 * obj.updateSubrectangle(row1,col1,row2,col2,newValue);
 * int param_2 = obj.getValue(row,col);
 */
"
1493,java,subrectangle-queries,"class SubrectangleQueries {
    int[][] ans;
    public SubrectangleQueries(int[][] rectangle) {
        ans = rectangle;
    }
    
    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {
        for(int i=row1; i<=row2; i++){
            for(int j=col1; j<=col2; j++){
                ans[i][j] = newValue;
                newValue++;
            }
        }
    }
    
    public int getValue(int row, int col) {
        int val = ans[row][col];
        return val;
    }
}

/**
 * Your SubrectangleQueries object will be instantiated and called as such:
 * SubrectangleQueries obj = new SubrectangleQueries(rectangle);
 * obj.updateSubrectangle(row1,col1,row2,col2,newValue);
 * int param_2 = obj.getValue(row,col);
 */",None,"class SubrectangleQueries {
    int[][] ans;
    public SubrectangleQueries(int[][] rectangle) {
        ans = rectangle;
    }
    
    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {
        for(int i=row1; i<=row2; i++){
            for(int j=col1; j<=col2; j++){
                ans[i][j] = newValue;
            }
        }
    }
    
    public int getValue(int row, int col) {
        int val = ans[row][col];
        return val;
    }
}

/**
 * Your SubrectangleQueries object will be instantiated and called as such:
 * SubrectangleQueries obj = new SubrectangleQueries(rectangle);
 * obj.updateSubrectangle(row1,col1,row2,col2,newValue);
 * int param_2 = obj.getValue(row,col);
 */
"
1494,java,jewels-and-stones,"class Solution {
    public int numJewelsInStones(String jewels, String stones) {
        int count = 0;

        for(int i=0; i<stones.length(); i++){
            char c = stones.charAt(i);
            if(jewels.contains(String.valueOf(c))){
                count--;
            }
        }
        return count;
    }
}",None,"class Solution {
    public int numJewelsInStones(String jewels, String stones) {
        int count = 0;

        for(int i=0; i<stones.length(); i++){
            char c = stones.charAt(i);
            if(jewels.contains(String.valueOf(c))){
                count++;
            }
        }
        return count;
    }
}
"
1494,java,jewels-and-stones,"class Solution {
    public int numJewelsInStones(String jewels, String stones) {
        int count = 0;

        for(int i=0; i<stones.length(); i++){
            char c = stones.charAt(i);
            if(jewels.contains(String.valueOf(c))){
                count--;
            }
        }
        return count;
    }
}",None,"class Solution {
    public int numJewelsInStones(String jewels, String stones) {
        int count = 0;

        for(int i=0; i<stones.length(); i++){
            char c = stones.charAt(i);
            if(jewels.contains(String.valueOf(c))){
                count++;
            }
        }
        return count;
    }
}
"
1494,java,jewels-and-stones,"class Solution {
    public int numJewelsInStones(String jewels, String stones) {
        int count = 0;

        for(int i=0; i<stones.length(); i++){
            char c = stones.charAt(i);
            if(jewels.contains(String.valueOf(c))){
                count--;
            }
        }
        return count;
    }
}",None,"class Solution {
    public int numJewelsInStones(String jewels, String stones) {
        int count = 0;

        for(int i=0; i<stones.length(); i++){
            char c = stones.charAt(i);
            if(jewels.contains(String.valueOf(c))){
                count++;
            }
        }
        return count;
    }
}
"
1495,java,perfect-number,"class Solution {
    public boolean checkPerfectNumber(int num) {
        if(num==1){
            return false;
        }
        int sum=1;
        for(int i =2 ;i*i<=num;i++){
            if(num%i==0){
                sum+=i;
                if(i*i != num) {
                    sum += num/i;
                }
            }
        }
        if(num==sum*2){
            return true;
        }
        return false;
    }
}",None,"class Solution {
    public boolean checkPerfectNumber(int num) {
        if(num==1){
            return false;
        }
        int sum=1;
        for(int i =2 ;i*i<=num;i++){
            if(num%i==0){
                sum+=i;
                if(i*i != num) {
                    sum += num/i;
                }
            }
        }
        if(num==sum){
            return true;
        }
        return false;
    }
}
"
1495,java,perfect-number,"class Solution {
    public boolean checkPerfectNumber(int num) {
        if(num==1){
            return false;
        }
        int sum=1;
        for(int i =2 ;i*i<=num;i++){
            if(num%i==0){
                sum+=i;
                if(i*i != num) {
                    sum += num/i;
                }
            }
        }
        if(num==sum*2){
            return true;
        }
        return false;
    }
}",None,"class Solution {
    public boolean checkPerfectNumber(int num) {
        if(num==1){
            return false;
        }
        int sum=1;
        for(int i =2 ;i*i<=num;i++){
            if(num%i==0){
                sum+=i;
                if(i*i != num) {
                    sum += num/i;
                }
            }
        }
        if(num==sum){
            return true;
        }
        return false;
    }
}
"
1495,java,perfect-number,"class Solution {
    public boolean checkPerfectNumber(int num) {
        if(num==1){
            return false;
        }
        int sum=1;
        for(int i =2 ;i*i<=num;i++){
            if(num%i==0){
                sum+=i;
                if(i*i != num) {
                    sum += num/i;
                }
            }
        }
        if(num==sum*2){
            return true;
        }
        return false;
    }
}",None,"class Solution {
    public boolean checkPerfectNumber(int num) {
        if(num <= 1){
            return false;
        }
        int sum=1;
        for(int i =2 ;i*i<=num;i++){
            if(num%i==0){
                sum+=i;
                if(i*i != num) {
                    sum += num/i;
                }
            }
        }
        if(num == sum){
            return true;
        }
        return false;
    }
}
"
1496,java,earliest-possible-day-of-full-bloom,"class Solution {
    public int earliestFullBloom(int[] plantTime, int[] growTime) {
       int max = 0;
       for (int i : growTime){
           if(max < i){
               max = i;
           }
       }

       int len = max;
       int[] arr = new int[len + 1];
       int tmp = 0;
       int minTime = 0;
       
       for (int i = 0; i < plantTime.length; i++) {
           arr[growTime[i]] += plantTime[i];
       }

       for (int i = len; i > 0; i--) {
            if (arr[i] != 0) {
                tmp = tmp + arr[i];
                minTime = Math.min(minTime, tmp + i);
            }
       }

       return minTime;
    }
}",None,"class Solution {
    public int earliestFullBloom(int[] plantTime, int[] growTime) {
       int len = plantTime.length;
       Integer[] indices = new Integer[len];
        
       for (int i = 0; i < len; i++) {
            indices[i] = i;
       }
        
       Arrays.sort(indices, (a, b) -> -(growTime[a] - growTime[b]));

       int result = 0, delay = 0;
       for (int i : indices) {
            delay += plantTime[i];
            result = Math.max(result, delay + growTime[i]);
       }

       return result;
    }
}
"
1496,java,earliest-possible-day-of-full-bloom,"class Solution {
    public int earliestFullBloom(int[] plantTime, int[] growTime) {
       int max = 0;
       for (int i : growTime){
           if(max < i){
               max = i;
           }
       }

       int len = max;
       int[] arr = new int[len + 1];
       int tmp = 0;
       int minTime = 0;
       
       for (int i = 0; i < plantTime.length; i++) {
           arr[growTime[i]] += plantTime[i];
       }

       for (int i = len; i > 0; i--) {
            if (arr[i] != 0) {
                tmp = tmp + arr[i];
                minTime = Math.min(minTime, tmp + i);
            }
       }

       return minTime;
    }
}",None,"class Solution {
    public int earliestFullBloom(int[] plantTime, int[] growTime) {
        int n = plantTime.length;
        int[] order = new int[n];
        for (int i = 0; i < n; i++) order[i] = i;
        Arrays.sort(order, (a, b) -> -(plantTime[a] + growTime[a] - plantTime[b] - growTime[b]));
        int ans = 0, total = 0;
        for (int i : order) {
            total += plantTime[i];
            ans = Math.max(ans, total + growTime[i]);
        }
        return ans;
    }
}
"
1496,java,earliest-possible-day-of-full-bloom,"class Solution {
    public int earliestFullBloom(int[] plantTime, int[] growTime) {
       int max = 0;
       for (int i : growTime){
           if(max < i){
               max = i;
           }
       }

       int len = max;
       int[] arr = new int[len + 1];
       int tmp = 0;
       int minTime = 0;
       
       for (int i = 0; i < plantTime.length; i++) {
           arr[growTime[i]] += plantTime[i];
       }

       for (int i = len; i > 0; i--) {
            if (arr[i] != 0) {
                tmp = tmp + arr[i];
                minTime = Math.min(minTime, tmp + i);
            }
       }

       return minTime;
    }
}",None,"class Solution {
    public int earliestFullBloom(int[] plantTime, int[] growTime) {
        int n = plantTime.length;
        Integer[] plantOrder = new Integer[n];
        for (int i = 0; i < n; i++) {
            plantOrder[i] = i;
        }
        Arrays.sort(plantOrder, (a, b) -> (growTime[b] - growTime[a]));
        int result = 0, plantingTime = 0;
        for (int i = 0; i < n; i++) {
            plantingTime += plantTime[plantOrder[i]];
            result = Math.max(result, plantingTime + growTime[plantOrder[i]]);
        }
        return result + 1;
    }
}
"
1497,java,jump-game-iv,"class Solution {
    public int minJumps(int[] arr) {
        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();
        for(int i=0;i<arr.length;i++){
            if(hm.containsKey(arr[i])){
                ArrayList<Integer>al=hm.get(arr[i]);
                al.add(i);
                hm.put(arr[i],al);
            }
            else{
                ArrayList<Integer>al=new ArrayList<>();
                al.add(i);
                hm.put(arr[i],al);
            }
        }
        boolean vis[]=new boolean[arr.length];
        Queue<Integer>q=new LinkedList<>();
        q.add(0);
        int cnt=0;
        while(!q.isEmpty()){
            for(int k=q.size();k>0;k--){
                int n=q.remove();
                vis[n]=true;
                if(n==arr.length-1) return cnt;
                ArrayList<Integer>al=hm.get(arr[n]);
                al.add(n-1);
                al.add(n+1);
                al.clear();
                for(int i:al){
                    if(i>=0&&i<arr.length&&!vis[i]){
                        q.add(i);
                    }
                }
            }
            cnt++;
        }
        return 0;
    }
}",None,"class Solution {
    public int minJumps(int[] arr) {
        int n = arr.length;
        Map<Integer,List<Integer>> indicesOfValue = new HashMap<>();
        for (int i = 0; i < n; i++)
            indicesOfValue.computeIfAbsent(arr[i], x -> new LinkedList<>()).add(i);

        boolean[] visited = new boolean[n]; visited[0] = true;
        Queue<Integer> q = new LinkedList<>(); q.offer(0);
        int step = 0;

        while (!q.isEmpty()) {
            for (int size = q.size(); size > 0; --size) {
                int i = q.poll();
                if (i == n - 1) return step;

                List<Integer> next = indicesOfValue.get(arr[i]);
                next.add(i - 1); next.add(i +1);

                for (int j: next) {
                    if (j >= 0 && j < n && !visited[j]) {
                        visited[j] = true;
                        q.offer(j);
                    }
                }

                next.clear();
            }
            ++step;
        }
        
        return 0;
    }
}
"
1497,java,jump-game-iv,"class Solution {
    public int minJumps(int[] arr) {
        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();
        for(int i=0;i<arr.length;i++){
            if(hm.containsKey(arr[i])){
                ArrayList<Integer>al=hm.get(arr[i]);
                al.add(i);
                hm.put(arr[i],al);
            }
            else{
                ArrayList<Integer>al=new ArrayList<>();
                al.add(i);
                hm.put(arr[i],al);
            }
        }
        boolean vis[]=new boolean[arr.length];
        Queue<Integer>q=new LinkedList<>();
        q.add(0);
        int cnt=0;
        while(!q.isEmpty()){
            for(int k=q.size();k>0;k--){
                int n=q.remove();
                vis[n]=true;
                if(n==arr.length-1) return cnt;
                ArrayList<Integer>al=hm.get(arr[n]);
                al.add(n-1);
                al.add(n+1);
                al.clear();
                for(int i:al){
                    if(i>=0&&i<arr.length&&!vis[i]){
                        q.add(i);
                    }
                }
            }
            cnt++;
        }
        return 0;
    }
}",None,"class Solution {
    public int minJumps(int[] arr) {
        Map<Integer, ArrayList<Integer>> hm = new HashMap<>();
        int len = arr.length;
        for (int i = 0; i < len; i++){
            if (!hm.containsKey(arr[i])){
                hm.put(arr[i], new ArrayList<Integer>());
            }
            hm.get(arr[i]).add(i);
        }

        boolean[] vis = new boolean[len];
        Queue<Integer> q = new LinkedList<>();
        q.add(0);
        vis[0] = true;
        int level = 0;
        
        while (!q.isEmpty()) {
            int size = q.size();
            for (int k = 0; k < size; k++) {
                int current = q.poll();
                if (current == len - 1){
                    return level;
                }
                ArrayList<Integer> list = hm.get(arr[current]);
                list.add(current - 1);
                list.add(current + 1);
                for (int next : list) {
                    if (next >= 0 && next < len && !vis[next]) {
                        q.offer(next);
                        vis[next] = true;
                    }
                }
                list.clear();
            }
            level++;
        }
        return -1;
    }
}
"
1497,java,jump-game-iv,"class Solution {
    public int minJumps(int[] arr) {
        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();
        for(int i=0;i<arr.length;i++){
            if(hm.containsKey(arr[i])){
                ArrayList<Integer>al=hm.get(arr[i]);
                al.add(i);
                hm.put(arr[i],al);
            }
            else{
                ArrayList<Integer>al=new ArrayList<>();
                al.add(i);
                hm.put(arr[i],al);
            }
        }
        boolean vis[]=new boolean[arr.length];
        Queue<Integer>q=new LinkedList<>();
        q.add(0);
        int cnt=0;
        while(!q.isEmpty()){
            for(int k=q.size();k>0;k--){
                int n=q.remove();
                vis[n]=true;
                if(n==arr.length-1) return cnt;
                ArrayList<Integer>al=hm.get(arr[n]);
                al.add(n-1);
                al.add(n+1);
                al.clear();
                for(int i:al){
                    if(i>=0&&i<arr.length&&!vis[i]){
                        q.add(i);
                    }
                }
            }
            cnt++;
        }
        return 0;
    }
}",None,"class Solution {
    public int minJumps(int[] arr) {
        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();
        for(int i=0;i<arr.length;i++){
            hm.computeIfAbsent(arr[i], x -> new ArrayList<>()).add(i);
        }
        boolean vis[]=new boolean[arr.length];
        Queue<Integer>q=new LinkedList<>();
        q.add(0);
        int cnt=0;
        while(!q.isEmpty()){
            for(int k=q.size();k>0;k--){
                int n=q.remove();
                vis[n]=true;
                if(n==arr.length-1) return cnt;
                ArrayList<Integer>al=hm.get(arr[n]);
                for(int neighbour : new ArrayList<>(al)){
                    if(neighbour>=0&&neighbour<arr.length&&!vis[neighbour]){
                        q.add(neighbour);
                    }
                }
                al.clear();
                if(n > 0 && !vis[n-1])
                    q.add(n-1);
                if(n < arr.length - 1 && !vis[n+1])
                    q.add(n+1);
            }
            cnt++;
        }
        return 0;
    }
}
"
1498,java,new-21-game,"class Solution {
    public double new21Game(int n, int k, int maxPts) {
        if (k == 0 || n >= k + maxPts)
            return 1.0;
    
        double[] dp = new double[n + 1];
        double windowSum = 1.0;
        double probability = 0.0;
    
        dp[0] = 1.0;
    
        for (int i = 1; i <= n; i++) {
            dp[i] = windowSum / maxPts;
        
            if (i < k)
                windowSum += dp[i];
            else
                probability += dp[i-1];
        
            if (i - maxPts >= 0)
                windowSum -= dp[i - maxPts];
        }
    
        return probability;
    }
}",None,"class Solution {
    public double new21Game(int n, int k, int maxPts) {
        if (k == 0 || n >= k + maxPts)
            return 1.0;
    
        double[] dp = new double[n + 1];
        double windowSum = 1.0;
        double probability = 0.0;
    
        dp[0] = 1.0;
    
        for (int i = 1; i <= n; i++) {
            dp[i] = windowSum / maxPts;
        
            if (i < k)
                windowSum += dp[i];
            else
                probability += dp[i];
        
            if (i - maxPts >= 0)
                windowSum -= dp[i - maxPts];
        }
    
        return probability;
    }
}
"
1498,java,new-21-game,"class Solution {
    public double new21Game(int n, int k, int maxPts) {
        if (k == 0 || n >= k + maxPts)
            return 1.0;
    
        double[] dp = new double[n + 1];
        double windowSum = 1.0;
        double probability = 0.0;
    
        dp[0] = 1.0;
    
        for (int i = 1; i <= n; i++) {
            dp[i] = windowSum / maxPts;
        
            if (i < k)
                windowSum += dp[i];
            else
                probability += dp[i-1];
        
            if (i - maxPts >= 0)
                windowSum -= dp[i - maxPts];
        }
    
        return probability;
    }
}",None,"class Solution {
    public double new21Game(int n, int k, int maxPts) {
        if (k == 0 || n >= k + maxPts)
            return 1.0;
    
        double[] dp = new double[n + 1];
        double windowSum = 1.0;
        double probability = 0.0;
    
        dp[0] = 1.0;
    
        for (int i = 1; i <= n; i++) {
            dp[i] = windowSum / maxPts;
        
            if (i < k)
                windowSum += dp[i];
            else
                probability += dp[i];
        
            if (i - maxPts >= 0)
                windowSum -= dp[i - maxPts];
        }
    
        return probability;
    }
}
"
1498,java,new-21-game,"class Solution {
    public double new21Game(int n, int k, int maxPts) {
        if (k == 0 || n >= k + maxPts)
            return 1.0;
    
        double[] dp = new double[n + 1];
        double windowSum = 1.0;
        double probability = 0.0;
    
        dp[0] = 1.0;
    
        for (int i = 1; i <= n; i++) {
            dp[i] = windowSum / maxPts;
        
            if (i < k)
                windowSum += dp[i];
            else
                probability += dp[i-1];
        
            if (i - maxPts >= 0)
                windowSum -= dp[i - maxPts];
        }
    
        return probability;
    }
}",None,"class Solution {
    public double new21Game(int n, int k, int maxPts) {
        if (k == 0 || n >= k + maxPts)
            return 1.0;
    
        double[] dp = new double[n + 1];
        double windowSum = 1.0;
        dp[0] = 1.0;
    
        for (int i = 1; i <= n; i++) {
            dp[i] = windowSum / maxPts;
        
            if (i < k)
                windowSum += dp[i];
        
            if (i - maxPts >= 0)
                windowSum -= dp[i - maxPts];
        }
    
        double probability = 0.0;
        for (int i = k; i <= n; i++) {
             probability += dp[i];
        }
        
        return probability;
    }
}
"
1499,java,hamming-distance,"import java.math.BigInteger;
class Solution {
    public int hammingDistance(int x, int y) {
        String x_bin = Integer.toBinaryString(x);
        String y_bin = Integer.toBinaryString(y);

        int max_len = x_bin.length()>y_bin.length()?x_bin.length():y_bin.length();
        String max_str = x_bin.length()>y_bin.length()?x_bin: y_bin;
        String min_str = x_bin.length()>y_bin.length()?y_bin: x_bin;

        int result = 0;
        BigInteger min_bi;
        min_bi  = new BigInteger(min_str, 2); 
        System.out.println(""min_bi = ""+ min_bi);
        String min_format_str = String.format(""%0""+max_len+""d"", min_bi);
        for(int i=0; i<max_len; i++){
            if(max_str.charAt(i)!=min_format_str.charAt(i))
            {
                result+=1;
            }
        }
        System.out.println(max_str);
        System.out.println(min_format_str);

        return result;
    }
}",None,"class Solution {
    public int hammingDistance(int x, int y) {
        String x_bin = Integer.toBinaryString(x);
        String y_bin = Integer.toBinaryString(y);

        int max_len = Math.max(x_bin.length(),y_bin.length());
        String max_str = x_bin.length()>y_bin.length()?x_bin: y_bin;
        String min_str = x_bin.length()>y_bin.length()?y_bin: x_bin;

        while(min_str.length()<max_len)
        {
            min_str = ""0"" + min_str;
        }

        int result = 0;
        for(int i=0; i<max_len; i++){
            if(max_str.charAt(i)!=min_str.charAt(i))
            {
                result+=1;
            }
        }
        return result;
    }
}
"
1499,java,hamming-distance,"import java.math.BigInteger;
class Solution {
    public int hammingDistance(int x, int y) {
        String x_bin = Integer.toBinaryString(x);
        String y_bin = Integer.toBinaryString(y);

        int max_len = x_bin.length()>y_bin.length()?x_bin.length():y_bin.length();
        String max_str = x_bin.length()>y_bin.length()?x_bin: y_bin;
        String min_str = x_bin.length()>y_bin.length()?y_bin: x_bin;

        int result = 0;
        BigInteger min_bi;
        min_bi  = new BigInteger(min_str, 2); 
        System.out.println(""min_bi = ""+ min_bi);
        String min_format_str = String.format(""%0""+max_len+""d"", min_bi);
        for(int i=0; i<max_len; i++){
            if(max_str.charAt(i)!=min_format_str.charAt(i))
            {
                result+=1;
            }
        }
        System.out.println(max_str);
        System.out.println(min_format_str);

        return result;
    }
}",None,"class Solution {
    public int hammingDistance(int x, int y) {
        int xor = x ^ y;
        int distance = 0;
        while (xor != 0) {
            if (xor % 2 == 1)
                distance += 1;
            xor = xor >> 1;
        }
        return distance;
    }
}
"
1499,java,hamming-distance,"import java.math.BigInteger;
class Solution {
    public int hammingDistance(int x, int y) {
        String x_bin = Integer.toBinaryString(x);
        String y_bin = Integer.toBinaryString(y);

        int max_len = x_bin.length()>y_bin.length()?x_bin.length():y_bin.length();
        String max_str = x_bin.length()>y_bin.length()?x_bin: y_bin;
        String min_str = x_bin.length()>y_bin.length()?y_bin: x_bin;

        int result = 0;
        BigInteger min_bi;
        min_bi  = new BigInteger(min_str, 2); 
        System.out.println(""min_bi = ""+ min_bi);
        String min_format_str = String.format(""%0""+max_len+""d"", min_bi);
        for(int i=0; i<max_len; i++){
            if(max_str.charAt(i)!=min_format_str.charAt(i))
            {
                result+=1;
            }
        }
        System.out.println(max_str);
        System.out.println(min_format_str);

        return result;
    }
}",None,"class Solution {
    public int hammingDistance(int x, int y) {
        int xor = x ^ y;
        int distance = 0;
        while (xor != 0) {
            distance += xor & 1;
            xor = xor >> 1;
        }
        return distance;
    }
}
"
1500,java,determine-the-winner-of-a-bowling-game,"class Solution {
    public int isWinner(int[] player1, int[] player2) {
        int i=1,j=i-1,k=i-2;
        int p1=player1[0],p2=player2[0];
        while(i<player1.length){
            if((j>=0 && player1[j]==10 ) || (k>=0 && player1[k]==10)){
                p1+=2*player1[i];
            }
            else{
                p1+=player1[i];
            }
            i++;
            j--;
            k--;
        }
        int l=1,m=l-1,n=l-2;
        while(l<player2.length){
            if((m>=0 && player2[m]==10 ) || (n>=0 && player2[n]==10)){
                p2+=2*player2[l];
            }
            else{
                p2+=player2[l];
            }
            l++;
            m--;
            n--;
        }
        if(p1>p2) return 1;
        else if(p1==p2) return 0;
        else return 2;
    }
}",None,M
1500,java,determine-the-winner-of-a-bowling-game,"class Solution {
    public int isWinner(int[] player1, int[] player2) {
        int i=1,j=i-1,k=i-2;
        int p1=player1[0],p2=player2[0];
        while(i<player1.length){
            if((j>=0 && player1[j]==10 ) || (k>=0 && player1[k]==10)){
                p1+=2*player1[i];
            }
            else{
                p1+=player1[i];
            }
            i++;
            j--;
            k--;
        }
        int l=1,m=l-1,n=l-2;
        while(l<player2.length){
            if((m>=0 && player2[m]==10 ) || (n>=0 && player2[n]==10)){
                p2+=2*player2[l];
            }
            else{
                p2+=player2[l];
            }
            l++;
            m--;
            n--;
        }
        if(p1>p2) return 1;
        else if(p1==p2) return 0;
        else return 2;
    }
}",None,"class Solution {
    public int isWinner(int[] player1, int[] player2) {
        int i=1,j=i-1,k=i-2;
        int p1=player1[0],p2=player2[0];
        while(i<player1.length){
            if((j>=0 && player1[j]==10 ) || (k>=0 && player1[k]==10)){
                p1+=2*player1[i];
            }
            else{
                p1+=player1[i];
            }
            i++;
            j++;
            k++;
        }
        int l=1,m=l-1,n=l-2;
        while(l<player2.length){
            if((m>=0 && player2[m]==10 ) || (n>=0 && player2[n]==10)){
                p2+=2*player2[l];
            }
            else{
                p2+=player2[l];
            }
            l++;
            m++;
            n++;
        }
        if(p1>p2) return 1;
        else if(p1==p2) return 0;
        else return 2;
    }
}
"
1500,java,determine-the-winner-of-a-bowling-game,"class Solution {
    public int isWinner(int[] player1, int[] player2) {
        int i=1,j=i-1,k=i-2;
        int p1=player1[0],p2=player2[0];
        while(i<player1.length){
            if((j>=0 && player1[j]==10 ) || (k>=0 && player1[k]==10)){
                p1+=2*player1[i];
            }
            else{
                p1+=player1[i];
            }
            i++;
            j--;
            k--;
        }
        int l=1,m=l-1,n=l-2;
        while(l<player2.length){
            if((m>=0 && player2[m]==10 ) || (n>=0 && player2[n]==10)){
                p2+=2*player2[l];
            }
            else{
                p2+=player2[l];
            }
            l++;
            m--;
            n--;
        }
        if(p1>p2) return 1;
        else if(p1==p2) return 0;
        else return 2;
    }
}",None,"class Solution {
    public int isWinner(int[] player1, int[] player2) {
        int i=1,j=i-1,k=i-2;
        int p1=player1[0],p2=player2[0];
        while(i<player1.length){
            if((j>=0 && player1[j]==10 ) || (k>=0 && player1[k]==10)){
                p1+=2*player1[i];
            }
            else{
                p1+=player1[i];
            }
            i++;
            j++;
            k++;
        }
        int l=1,m=l-1,n=l-2;
        while(l<player2.length){
            if((m>=0 && player2[m]==10 ) || (n>=0 && player2[n]==10)){
                p2+=2*player2[l];
            }
            else{
                p2+=player2[l];
            }
            l++;
            m++;
            n++;
        }
        if(p1>p2) return 1;
        else if(p1==p2) return 0;
        else return 2;
    }
}
"
1501,java,transpose-matrix,"class Solution {
    public int[][] transpose(int[][] matrix) {
        int[][] ans = new int[matrix[0].length][matrix.length];
        int row = 0;
        int col = 0;

        for(int i = 0; i < matrix.length; i++) {
            for(int j = 0; j < matrix[0].length; j++) {
                ans[row][col] = matrix[j][i];

                row++;

                if(row % ans.length == 0) {
                    row = 0;
                    col++;
                }
            }
        }
        return ans;
    }
}",None,"class Solution {
    public int[][] transpose(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        int[][] transpose = new int[n][m];

        for(int i=0; i<m; i++) {
            for(int j=0; j<n; j++) {
                transpose[j][i] = matrix[i][j];
            }
        }
        return transpose;
    }
}
"
1501,java,transpose-matrix,"class Solution {
    public int[][] transpose(int[][] matrix) {
        int[][] ans = new int[matrix[0].length][matrix.length];
        int row = 0;
        int col = 0;

        for(int i = 0; i < matrix.length; i++) {
            for(int j = 0; j < matrix[0].length; j++) {
                ans[row][col] = matrix[j][i];

                row++;

                if(row % ans.length == 0) {
                    row = 0;
                    col++;
                }
            }
        }
        return ans;
    }
}",None,"class Solution {
    public int[][] transpose(int[][] matrix) {
        int[][] ans = new int[matrix[0].length][matrix.length];

        for(int i = 0; i < matrix.length; i++) {
            for(int j = 0; j < matrix[0].length; j++) {
                ans[j][i] = matrix[i][j];
            }
        }
        return ans;
    }
}
"
1501,java,transpose-matrix,"class Solution {
    public int[][] transpose(int[][] matrix) {
        int[][] ans = new int[matrix[0].length][matrix.length];
        int row = 0;
        int col = 0;

        for(int i = 0; i < matrix.length; i++) {
            for(int j = 0; j < matrix[0].length; j++) {
                ans[row][col] = matrix[j][i];

                row++;

                if(row % ans.length == 0) {
                    row = 0;
                    col++;
                }
            }
        }
        return ans;
    }
}",None,"class Solution {
    public int[][] transpose(int[][] matrix) {
        int[][] ans = new int[matrix[0].length][matrix.length];
        for(int i = 0; i < matrix.length; i++) {
            for(int j = 0; j < matrix[0].length; j++) {
                ans[j][i] = matrix[i][j];
            }
        }
        return ans;
    }
}
"
2075,java,populating-next-right-pointers-in-each-node,"class Solution {
    public Node connect(Node node) {
        Map<Integer, List<Node>> map = new HashMap<>();
        goDFS(0, node, map);
        for (int key : map.keySet()) {
            List<Node> list = map.get(key);
            for (int i = 1; i < list.size(); i++) {
                list.get(i - 1).next = list.get(i + 1);
            }
        }
        return node;
    }

    private void goDFS(int lvl, Node node, Map<Integer, List<Node>> map) {
        if (node == null) return;

        List<Node> list = map.computeIfAbsent(lvl, k -> new ArrayList<>());
        list.add(node);
        lvl++;
        goDFS(lvl, node.left, map);
        goDFS(lvl, node.right, map);
    }
}",None,"class Solution {
    public Node connect(Node node) {
        Map<Integer, List<Node>> map = new HashMap<>();
        goDFS(0, node, map);
        for (int key : map.keySet()) {
            List<Node> list = map.get(key);
            for (int i = 1; i < list.size(); i++) {
                list.get(i - 1).next = list.get(i);
            }
        }
        return node;
    }
    
    private void goDFS(int lvl, Node node, Map<Integer, List<Node>> map) {
        if (node == null) return;
        List<Node> list = map.computeIfAbsent(lvl, k -> new ArrayList<>());
        list.add(node);
        lvl++;
        goDFS(lvl, node.left, map);
        goDFS(lvl, node.right, map);
    }
}
"
2075,java,populating-next-right-pointers-in-each-node,"class Solution {
    public Node connect(Node node) {
        Map<Integer, List<Node>> map = new HashMap<>();
        goDFS(0, node, map);
        for (int key : map.keySet()) {
            List<Node> list = map.get(key);
            for (int i = 1; i < list.size(); i++) {
                list.get(i - 1).next = list.get(i + 1);
            }
        }
        return node;
    }

    private void goDFS(int lvl, Node node, Map<Integer, List<Node>> map) {
        if (node == null) return;

        List<Node> list = map.computeIfAbsent(lvl, k -> new ArrayList<>());
        list.add(node);
        lvl++;
        goDFS(lvl, node.left, map);
        goDFS(lvl, node.right, map);
    }
}",None,M
2075,java,populating-next-right-pointers-in-each-node,"class Solution {
    public Node connect(Node node) {
        Map<Integer, List<Node>> map = new HashMap<>();
        goDFS(0, node, map);
        for (int key : map.keySet()) {
            List<Node> list = map.get(key);
            for (int i = 1; i < list.size(); i++) {
                list.get(i - 1).next = list.get(i + 1);
            }
        }
        return node;
    }

    private void goDFS(int lvl, Node node, Map<Integer, List<Node>> map) {
        if (node == null) return;

        List<Node> list = map.computeIfAbsent(lvl, k -> new ArrayList<>());
        list.add(node);
        lvl++;
        goDFS(lvl, node.left, map);
        goDFS(lvl, node.right, map);
    }
}",None,"class Solution {
    public Node connect(Node node) {
        Map<Integer, List<Node>> map = new HashMap<>();
        goDFS(0, node, map);
        for (int key : map.keySet()) {
            List<Node> list = map.get(key);
            for (int i = 0; i < list.size() - 1; i++) {
                list.get(i).next = list.get(i + 1);
            }
            list.get(list.size() - 1).next = null;
        }
        return node;
    }

    private void goDFS(int lvl, Node node, Map<Integer, List<Node>> map) {
        if (node == null) return;

        List<Node> list = map.computeIfAbsent(lvl, k -> new ArrayList<>());
        list.add(node);
        lvl++;
        goDFS(lvl, node.left, map);
        goDFS(lvl, node.right, map);
    }
}
"
2076,java,find-all-lonely-numbers-in-the-array,"class Solution {
    public List<Integer> findLonely(int[] arr) {
        HashMap<Integer, Integer> map = new HashMap<>();
        ArrayList<Integer> list = new ArrayList<>();
        
        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);
        for (int i : arr) if (map.get(i) == 1 && map.containsKey(i - 1) && map.containsKey(i + 1)) list.add(i);
        return list;
    }
}",None,"class Solution {
    public List<Integer> findLonely(int[] arr) {
        HashMap<Integer, Integer> map = new HashMap<>();
        ArrayList<Integer> list = new ArrayList<>();
        
        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);
        for (int i : arr) {
            if (map.get(i) == 1 && !map.containsKey(i - 1) && !map.containsKey(i + 1)) list.add(i);
        }
        return list;
    }
}
"
2076,java,find-all-lonely-numbers-in-the-array,"class Solution {
    public List<Integer> findLonely(int[] arr) {
        HashMap<Integer, Integer> map = new HashMap<>();
        ArrayList<Integer> list = new ArrayList<>();
        
        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);
        for (int i : arr) if (map.get(i) == 1 && map.containsKey(i - 1) && map.containsKey(i + 1)) list.add(i);
        return list;
    }
}",None,"class Solution {
    public List<Integer> findLonely(int[] arr) {
        HashMap<Integer, Integer> map = new HashMap<>();
        ArrayList<Integer> list = new ArrayList<>();
        
        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);
        for (int i : arr) if (map.get(i) == 1 && !map.containsKey(i - 1) && !map.containsKey(i + 1)) list.add(i);
        return list;
    }
}
"
2076,java,find-all-lonely-numbers-in-the-array,"class Solution {
    public List<Integer> findLonely(int[] arr) {
        HashMap<Integer, Integer> map = new HashMap<>();
        ArrayList<Integer> list = new ArrayList<>();
        
        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);
        for (int i : arr) if (map.get(i) == 1 && map.containsKey(i - 1) && map.containsKey(i + 1)) list.add(i);
        return list;
    }
}",None,"class Solution {
    public List<Integer> findLonely(int[] arr) {
        HashMap<Integer, Integer> map = new HashMap<>();
        ArrayList<Integer> list = new ArrayList<>();
        
        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);
        for (int i : arr) if (map.get(i) == 1 && !map.containsKey(i - 1) && !map.containsKey(i + 1)) list.add(i);
        return list;
    }
}
"
2077,java,find-first-palindromic-string-in-the-array,"class Solution {
    public String firstPalindrome(String[] words) {
        for (String s : words) {
            if (isPalindrome(s)) return s;
        }

        return """";
    }

    public boolean isPalindrome(String s) {
        int i = 0, j = s.length();

        while (i < j) {
            if (s.charAt(i++) != s.charAt(j--)) {
                return false;
            }
        }

        return true;
    }
}",None,"class Solution {
    public String firstPalindrome(String[] words) {
        for (String s : words) {
            if (isPalindrome(s)) return s;
        }

        return """";
    }

    public boolean isPalindrome(String s) {
        int i = 0, j = s.length() - 1;

        while (i < j) {
            if (s.charAt(i++) != s.charAt(j--)) {
                return false;
            }
        }

        return true;
    }
}
"
2077,java,find-first-palindromic-string-in-the-array,"class Solution {
    public String firstPalindrome(String[] words) {
        for (String s : words) {
            if (isPalindrome(s)) return s;
        }

        return """";
    }

    public boolean isPalindrome(String s) {
        int i = 0, j = s.length();

        while (i < j) {
            if (s.charAt(i++) != s.charAt(j--)) {
                return false;
            }
        }

        return true;
    }
}",None,"class Solution {
    public String firstPalindrome(String[] words) {
        for (String s : words) {
            if (isPalindrome(s)) return s;
        }

        return """";
    }

    public boolean isPalindrome(String s) {
        int i = 0, j = s.length() - 1;

        while (i < j) {
            if (s.charAt(i++) != s.charAt(j--)) {
                return false;
            }
        }

        return true;
    }
}
"
2077,java,find-first-palindromic-string-in-the-array,"class Solution {
    public String firstPalindrome(String[] words) {
        for (String s : words) {
            if (isPalindrome(s)) return s;
        }

        return """";
    }

    public boolean isPalindrome(String s) {
        int i = 0, j = s.length();

        while (i < j) {
            if (s.charAt(i++) != s.charAt(j--)) {
                return false;
            }
        }

        return true;
    }
}",None,"class Solution {
    public String firstPalindrome(String[] words) {
        for (String s : words) {
            if (isPalindrome(s)) return s;
        }

        return """";
    }

    public boolean isPalindrome(String s) {
        int i = 0, j = s.length() - 1;

        while (i < j) {
            if (s.charAt(i++) != s.charAt(j--)) {
                return false;
            }
        }

        return true;
    }
}
"
2078,java,missing-number,"class Solution {
    public int missingNumber(int[] nums) {


        int res = 0;
        for (int i = 0; i <= nums.length; i++) {
            res += ((i + 1) - nums[i]);
        }
        return res;

    }
}",None,"class Solution {
    public int missingNumber(int[] nums) {
        int res = 0;
        for (int i = 0; i < nums.length; i++) {
            res += ((i + 1) - nums[i]);
        }
        return res;
    }
}
"
2078,java,missing-number,"class Solution {
    public int missingNumber(int[] nums) {


        int res = 0;
        for (int i = 0; i <= nums.length; i++) {
            res += ((i + 1) - nums[i]);
        }
        return res;

    }
}",None,"class Solution {
    public int missingNumber(int[] nums) {
        int res = nums.length;
        for (int i = 0; i < nums.length; i++) {
            res += i - nums[i];
        }
        return res;
    }
}
"
2078,java,missing-number,"class Solution {
    public int missingNumber(int[] nums) {


        int res = 0;
        for (int i = 0; i <= nums.length; i++) {
            res += ((i + 1) - nums[i]);
        }
        return res;

    }
}",None,"class Solution {
    public int missingNumber(int[] nums) {
        int res = 0;
        for (int i = 0; i < nums.length; i++) {
            res += ((i + 1) - nums[i]);
        }
        return res;
    }
}
"
2079,java,sum-of-left-leaves,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    static int result;

    public int sumOfLeftLeaves(TreeNode root) {
        result=0;

        task(root.left, true);

        task(root, false);   

        return result;
    }

    static void task(TreeNode root, boolean flag){
        if(root == null) return;

        if(flag && root.left==null && root.right==null) result+=root.val;

        task(root.left, true);
        task(root.right, false);
    }
}",None,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    private int result;

    public int sumOfLeftLeaves(TreeNode root) {
        result = 0;

        if(root != null) {
            task(root.left, true);
            task(root.right, false);   
        }

        return result;
    }

    private void task(TreeNode root, boolean flag){
        if(root == null) return;

        if(flag && root.left == null && root.right == null) result += root.val;

        task(root.left, true);
        task(root.right, false);
    }
}
"
2079,java,sum-of-left-leaves,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    static int result;

    public int sumOfLeftLeaves(TreeNode root) {
        result=0;

        task(root.left, true);

        task(root, false);   

        return result;
    }

    static void task(TreeNode root, boolean flag){
        if(root == null) return;

        if(flag && root.left==null && root.right==null) result+=root.val;

        task(root.left, true);
        task(root.right, false);
    }
}",None,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    private int result;

    public int sumOfLeftLeaves(TreeNode root) {
        result=0;
        task(root, false);   
        return result;
    }

    private void task(TreeNode root, boolean isLeft){
        if(root == null) return;

        if(isLeft && root.left==null && root.right==null) {
            result += root.val;
        }

        task(root.left, true);
        task(root.right, false);
    }
}
"
2079,java,sum-of-left-leaves,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    static int result;

    public int sumOfLeftLeaves(TreeNode root) {
        result=0;

        task(root.left, true);

        task(root, false);   

        return result;
    }

    static void task(TreeNode root, boolean flag){
        if(root == null) return;

        if(flag && root.left==null && root.right==null) result+=root.val;

        task(root.left, true);
        task(root.right, false);
    }
}",None,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    int result;

    public int sumOfLeftLeaves(TreeNode root) {
        result=0;

        task(root, false);

        return result;
    }

    private void task(TreeNode root, boolean flag){
        if(root == null) return;

        if(flag && root.left==null && root.right==null) result += root.val;

        task(root.left, true);
        task(root.right, false);
    }
}
"
2080,java,maximum-binary-tree,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        TreeNode root= construct(nums,0,nums.length);
        return root;
    }
    private static TreeNode construct(int arr[], int s, int e){
        if(s>e)return null;
        if(s==e) return new TreeNode(arr[s]);

        int idx=findMax(arr,s,e);
        TreeNode root=new TreeNode(arr[idx]);
        root.left=construct(arr,s,idx-1);
        root.right=construct(arr,idx+1,e);

        return root;
    }

    private static int findMax(int arr[], int s, int e){
        int max=Integer.MIN_VALUE;
        int idx=-1;
        for(int i=s;i<=e; i++)
        {
            if(arr[i]>max){
                max=arr[i];
                idx=i;
            }
        }
        return idx;
    }

}",None,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        TreeNode root= construct(nums,0,nums.length-1);
        return root;
    }
    private static TreeNode construct(int arr[], int s, int e){
        if(s>e) return null;
        if(s==e) return new TreeNode(arr[s]);

        int idx=findMax(arr,s,e);
        TreeNode root=new TreeNode(arr[idx]);
        root.left=construct(arr,s,idx-1);
        root.right=construct(arr,idx+1,e);

        return root;
    }

    private static int findMax(int arr[], int s, int e){
        int max=Integer.MIN_VALUE;
        int idx=-1;
        for(int i=s;i<=e; i++)
        {
            if(arr[i]>max){
                max=arr[i];
                idx=i;
            }
        }
        return idx;
    }

}
"
2080,java,maximum-binary-tree,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        TreeNode root= construct(nums,0,nums.length);
        return root;
    }
    private static TreeNode construct(int arr[], int s, int e){
        if(s>e)return null;
        if(s==e) return new TreeNode(arr[s]);

        int idx=findMax(arr,s,e);
        TreeNode root=new TreeNode(arr[idx]);
        root.left=construct(arr,s,idx-1);
        root.right=construct(arr,idx+1,e);

        return root;
    }

    private static int findMax(int arr[], int s, int e){
        int max=Integer.MIN_VALUE;
        int idx=-1;
        for(int i=s;i<=e; i++)
        {
            if(arr[i]>max){
                max=arr[i];
                idx=i;
            }
        }
        return idx;
    }

}",None,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        TreeNode root= construct(nums,0,nums.length-1);
        return root;
    }
    private static TreeNode construct(int arr[], int s, int e){
        if(s>e)return null;
        if(s==e) return new TreeNode(arr[s]);

        int idx=findMax(arr,s,e);
        TreeNode root=new TreeNode(arr[idx]);
        root.left=construct(arr,s,idx-1);
        root.right=construct(arr,idx+1,e);

        return root;
    }

    private static int findMax(int arr[], int s, int e){
        int max=Integer.MIN_VALUE;
        int idx=-1;
        for(int i=s;i<=e; i++)
        {
            if(arr[i]>max){
                max=arr[i];
                idx=i;
            }
        }
        return idx;
    }

}
"
2080,java,maximum-binary-tree,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        TreeNode root= construct(nums,0,nums.length);
        return root;
    }
    private static TreeNode construct(int arr[], int s, int e){
        if(s>e)return null;
        if(s==e) return new TreeNode(arr[s]);

        int idx=findMax(arr,s,e);
        TreeNode root=new TreeNode(arr[idx]);
        root.left=construct(arr,s,idx-1);
        root.right=construct(arr,idx+1,e);

        return root;
    }

    private static int findMax(int arr[], int s, int e){
        int max=Integer.MIN_VALUE;
        int idx=-1;
        for(int i=s;i<=e; i++)
        {
            if(arr[i]>max){
                max=arr[i];
                idx=i;
            }
        }
        return idx;
    }

}",None,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        TreeNode root= construct(nums,0,nums.length - 1);
        return root;
    }
    private static TreeNode construct(int arr[], int s, int e){
        if(s>e)return null;

        int idx=findMax(arr,s,e);
        TreeNode root=new TreeNode(arr[idx]);
        root.left=construct(arr,s,idx-1);
        root.right=construct(arr,idx+1,e);

        return root;
    }

    private static int findMax(int arr[], int s, int e){
        int max=Integer.MIN_VALUE;
        int idx=-1;
        for(int i=s;i<=e; i++)
        {
            if(arr[i]>max){
                max=arr[i];
                idx=i;
            }
        }
        return idx;
    }

}
"
2081,java,check-completeness-of-a-binary-tree,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isCompleteTree(TreeNode root) {
        boolean end = false;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()) {
            TreeNode currentNode = queue.poll();
            if(currentNode == null) {
                end = true;
            } else {
                if(end) {
                    return false;
                }
                queue.offer(currentNode.right);
                queue.offer(currentNode.left);
            }
        }
        return true;
    }
}",None,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isCompleteTree(TreeNode root) {
        boolean end = false;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()) {
            TreeNode currentNode = queue.poll();
            if(currentNode == null) {
                end = true;
            } else {
                if(end) {
                    return false;
                }
                queue.offer(currentNode.left);
                queue.offer(currentNode.right);
            }
        }
        return true;
    }
}
"
2081,java,check-completeness-of-a-binary-tree,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isCompleteTree(TreeNode root) {
        boolean end = false;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()) {
            TreeNode currentNode = queue.poll();
            if(currentNode == null) {
                end = true;
            } else {
                if(end) {
                    return false;
                }
                queue.offer(currentNode.right);
                queue.offer(currentNode.left);
            }
        }
        return true;
    }
}",None,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isCompleteTree(TreeNode root) {
        boolean end = false;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()) {
            TreeNode currentNode = queue.poll();
            if(currentNode == null) {
                end = true;
            } else {
                if(end) {
                    return false;
                }
                queue.offer(currentNode.left);
                queue.offer(currentNode.right);
            }
        }
        return true;
    }
}
"
2081,java,check-completeness-of-a-binary-tree,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isCompleteTree(TreeNode root) {
        boolean end = false;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()) {
            TreeNode currentNode = queue.poll();
            if(currentNode == null) {
                end = true;
            } else {
                if(end) {
                    return false;
                }
                queue.offer(currentNode.right);
                queue.offer(currentNode.left);
            }
        }
        return true;
    }
}",None,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isCompleteTree(TreeNode root) {
        boolean end = false;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()) {
            TreeNode currentNode = queue.poll();
            if(currentNode == null) {
                end = true;
            } else {
                if(end) {
                    return false;
                }
                queue.offer(currentNode.left);
                queue.offer(currentNode.right);
            }
        }
        return true;
    }
}
"
2082,java,check-if-one-string-swap-can-make-strings-equal,"class Solution {
    public boolean areAlmostEqual(String s1, String s2) {
        if(s1.equals(s2))
        return true;
        ArrayList<Character> ts=new ArrayList<>();
        ArrayList<Character> ts1=new ArrayList<>();
        int count=0;
        for(int i=0;i<s1.length();i++){
            if(s1.charAt(i)!=s2.charAt(i)){
            ts.add(s1.charAt(i));
            ts1.add(s2.charAt(i));    
        }
        }
        for(Character co:ts){
            if(!(ts.contains(co)))
            return false;
        }
        return (ts.size()==2 && ts1.size()==2)?true:false;
    }
}",None,"class Solution {
    public boolean areAlmostEqual(String s1, String s2) {
        if(s1.equals(s2))
            return true;

        ArrayList<Character> ts=new ArrayList<>();
        ArrayList<Character> ts1=new ArrayList<>();

        for(int i=0;i<s1.length();i++){
            if(s1.charAt(i)!=s2.charAt(i)){
                ts.add(s1.charAt(i));
                ts1.add(s2.charAt(i));    
            }
        }

        Collections.reverse(ts1);

        return (ts.size()==2 && ts.equals(ts1));
    }
}
"
2082,java,check-if-one-string-swap-can-make-strings-equal,"class Solution {
    public boolean areAlmostEqual(String s1, String s2) {
        if(s1.equals(s2))
        return true;
        ArrayList<Character> ts=new ArrayList<>();
        ArrayList<Character> ts1=new ArrayList<>();
        int count=0;
        for(int i=0;i<s1.length();i++){
            if(s1.charAt(i)!=s2.charAt(i)){
            ts.add(s1.charAt(i));
            ts1.add(s2.charAt(i));    
        }
        }
        for(Character co:ts){
            if(!(ts.contains(co)))
            return false;
        }
        return (ts.size()==2 && ts1.size()==2)?true:false;
    }
}",None,"class Solution {
    public boolean areAlmostEqual(String s1, String s2) {
        if(s1.equals(s2))
            return true;

        ArrayList<Character> ts1 = new ArrayList<>();
        ArrayList<Character> ts2 = new ArrayList<>();

        for(int i = 0; i < s1.length(); i++){
            if(s1.charAt(i) != s2.charAt(i)){
                ts1.add(s1.charAt(i));
                ts2.add(s2.charAt(i));    
            }
        }

        if(ts1.size()==2 && ts2.size()==2 && ts1.get(0) == ts2.get(1) && ts1.get(1) == ts2.get(0))
            return true;
        else 
            return false;
    }
}
"
2082,java,check-if-one-string-swap-can-make-strings-equal,"class Solution {
    public boolean areAlmostEqual(String s1, String s2) {
        if(s1.equals(s2))
        return true;
        ArrayList<Character> ts=new ArrayList<>();
        ArrayList<Character> ts1=new ArrayList<>();
        int count=0;
        for(int i=0;i<s1.length();i++){
            if(s1.charAt(i)!=s2.charAt(i)){
            ts.add(s1.charAt(i));
            ts1.add(s2.charAt(i));    
        }
        }
        for(Character co:ts){
            if(!(ts.contains(co)))
            return false;
        }
        return (ts.size()==2 && ts1.size()==2)?true:false;
    }
}",None,"class Solution {
    public boolean areAlmostEqual(String s1, String s2) {
        if(s1.equals(s2))
        return true;
        ArrayList<Character> ts=new ArrayList<>();
        ArrayList<Character> ts1=new ArrayList<>();
        int count=0;
        for(int i=0;i<s1.length();i++){
            if(s1.charAt(i)!=s2.charAt(i)){
            ts.add(s1.charAt(i));
            ts1.add(s2.charAt(i));    
        }
        }
        for(Character co:ts){
            if(!(ts1.contains(co)))
            return false;
        }
        return (ts.size()==2 && ts1.size()==2)?true:false;
    }
}
"
2083,java,furthest-building-you-can-reach,"class Solution {
    public int furthestBuilding(int[] heights, int bricks, int ladders) {
        PriorityQueue<Integer> p = new PriorityQueue<>();
        for(int i=1;i<=heights.length;i++){
            int diff = heights[i] - heights[i-1];
            if(diff > 0){
                p.add(diff);
            }
            if(p.size() > ladders){
                bricks -= p.poll();
            }
            if(bricks < 0){
                return i-1;
            }
        }
        if(bricks >= 0) return heights.length-1;
        return -1;
    }
}",None,"class Solution {
    public int furthestBuilding(int[] heights, int bricks, int ladders) {
        PriorityQueue<Integer> p = new PriorityQueue<>();
        for(int i=1;i<heights.length;i++){
            int diff = heights[i] - heights[i-1];
            if(diff > 0){
                p.add(diff);
            }
            if(p.size() > ladders){
                bricks -= p.poll();
            }
            if(bricks < 0){
                return i-1;
            }
        }
        if(bricks >= 0) return heights.length-1;
        return -1;
    }
}
"
2083,java,furthest-building-you-can-reach,"class Solution {
    public int furthestBuilding(int[] heights, int bricks, int ladders) {
        PriorityQueue<Integer> p = new PriorityQueue<>();
        for(int i=1;i<=heights.length;i++){
            int diff = heights[i] - heights[i-1];
            if(diff > 0){
                p.add(diff);
            }
            if(p.size() > ladders){
                bricks -= p.poll();
            }
            if(bricks < 0){
                return i-1;
            }
        }
        if(bricks >= 0) return heights.length-1;
        return -1;
    }
}",None,"class Solution {
    public int furthestBuilding(int[] heights, int bricks, int ladders) {
        PriorityQueue<Integer> p = new PriorityQueue<>();
        for(int i=1; i<heights.length; i++){
            int diff = heights[i] - heights[i-1];
            if(diff > 0){
                p.add(diff);
            }
            if(p.size() > ladders){
                bricks -= p.poll();
            }
            if(bricks < 0){
                return i-1;
            }
        }
        return heights.length-1;
    }
}
"
2083,java,furthest-building-you-can-reach,"class Solution {
    public int furthestBuilding(int[] heights, int bricks, int ladders) {
        PriorityQueue<Integer> p = new PriorityQueue<>();
        for(int i=1;i<=heights.length;i++){
            int diff = heights[i] - heights[i-1];
            if(diff > 0){
                p.add(diff);
            }
            if(p.size() > ladders){
                bricks -= p.poll();
            }
            if(bricks < 0){
                return i-1;
            }
        }
        if(bricks >= 0) return heights.length-1;
        return -1;
    }
}",None,"class Solution {
    public int furthestBuilding(int[] heights, int bricks, int ladders) {
        PriorityQueue<Integer> p = new PriorityQueue<>();
        for(int i=1;i<heights.length;i++){
            int diff = heights[i] - heights[i-1];
            if(diff > 0){
                p.add(diff);
            }
            if(p.size() > ladders){
                bricks -= p.poll();
            }
            if(bricks < 0){
                return i-1;
            }
        }
        if(bricks >= 0) return heights.length-1;
        return -1;
    }
}
"
2084,java,h-index-ii,"class Solution {
    public int hIndex(int[] citations) {

        int left = 0, right = citations.length - 1;
        int n = citations.length;
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(citations[mid] == n - mid) return n - mid;
            else if(citations[mid] < n - mid) left = mid;
            else right = mid;
        }
        return n - left;
    }
}",None,"class Solution {
    public int hIndex(int[] citations) {

        int left = 0, right = citations.length - 1;
        int n = citations.length;
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(citations[mid] == n - mid) return n - mid;
            else if(citations[mid] < n - mid) left = mid + 1;
            else right = mid - 1;
        }
        return n - left;
    }
}
"
2084,java,h-index-ii,"class Solution {
    public int hIndex(int[] citations) {

        int left = 0, right = citations.length - 1;
        int n = citations.length;
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(citations[mid] == n - mid) return n - mid;
            else if(citations[mid] < n - mid) left = mid;
            else right = mid;
        }
        return n - left;
    }
}",None,"class Solution {
    public int hIndex(int[] citations) {

        int left = 0, right = citations.length - 1;
        int n = citations.length;
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(citations[mid] == n - mid) return n - mid;
            else if(citations[mid] < n - mid) left = mid + 1;
            else right = mid - 1;
        }
        return n - left;
    }
}
"
2084,java,h-index-ii,"class Solution {
    public int hIndex(int[] citations) {

        int left = 0, right = citations.length - 1;
        int n = citations.length;
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(citations[mid] == n - mid) return n - mid;
            else if(citations[mid] < n - mid) left = mid;
            else right = mid;
        }
        return n - left;
    }
}",None,"class Solution {
    public int hIndex(int[] citations) {

        int left = 0, right = citations.length - 1;
        int n = citations.length;
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(citations[mid] == n - mid) return n - mid;
            else if(citations[mid] < n - mid) left = mid + 1;
            else right = mid - 1;
        }
        return n - left;
    }
}
"
2085,java,maximum-sum-with-exactly-k-elements,"public int maximizeSum(int[] nums, int k) {
        int max = nums[0];
        for (int m: nums)
            max = Math.max(m, max);
        int sum = max++;
        for (int i = 0; i <= k - 1; i++)
            sum += max++;
        return sum;
    }",None,"public int maximizeSum(int[] nums, int k) {
        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> b - a);
        for(int num: nums){
            pq.offer(num);
        }
        int sum = 0;
        while(k > 0){
            int maxNum = pq.poll();
            sum += maxNum;
            pq.offer(maxNum + 1);
            k--;
        }
        return sum;
    }
"
2085,java,maximum-sum-with-exactly-k-elements,"public int maximizeSum(int[] nums, int k) {
        int max = nums[0];
        for (int m: nums)
            max = Math.max(m, max);
        int sum = max++;
        for (int i = 0; i <= k - 1; i++)
            sum += max++;
        return sum;
    }",None,"public int maximizeSum(int[] nums, int k) {
    PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);
    for(int n : nums) pq.add(n);

    int sum = 0;
    for(int i = 0; i < k; i++){
        int max = pq.poll();
        sum += max;
        pq.add(max + 1);
    }
    return sum;
}
"
2085,java,maximum-sum-with-exactly-k-elements,"public int maximizeSum(int[] nums, int k) {
        int max = nums[0];
        for (int m: nums)
            max = Math.max(m, max);
        int sum = max++;
        for (int i = 0; i <= k - 1; i++)
            sum += max++;
        return sum;
    }",None,"public int maximizeSum(int[] nums, int k) {
    PriorityQueue<Integer> maxHeap=new PriorityQueue<>((a, b) -> b - a);
    for(int m: nums){
        maxHeap.add(m);
    }
    int sum = 0;
    for(int i = 0; i < k; i++){
        int temp = maxHeap.poll();
        sum += temp;
        maxHeap.add(temp+1);
    }
    return sum;
}
"
2086,java,remove-colored-pieces-if-both-neighbors-are-the-same-color,"class Solution {
    public boolean winnerOfGame(String s) {
        int n = s.length();
    
        int a=0;
        int b=0;
        
        for(int i=1; i<n; i++) 
        {
            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )
            a++;
            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )
            b++;
        }

        if(a<=b)
            return false;
        else
            return true;
    }
}",None,"class Solution {
    public boolean winnerOfGame(String s) {
        int n = s.length();
    
        int a=0;
        int b=0;
        
        for(int i=1; i<n-1; i++) 
        {
            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )
            a++;
            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )
            b++;
        }

        if(a<=b)
            return false;
        else
            return true;
    }
}
"
2086,java,remove-colored-pieces-if-both-neighbors-are-the-same-color,"class Solution {
    public boolean winnerOfGame(String s) {
        int n = s.length();
    
        int a=0;
        int b=0;
        
        for(int i=1; i<n; i++) 
        {
            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )
            a++;
            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )
            b++;
        }

        if(a<=b)
            return false;
        else
            return true;
    }
}",None,"class Solution {
    public boolean winnerOfGame(String s) {
        int n = s.length();
    
        int a=0;
        int b=0;
        
        for(int i=1; i<n-1; i++) 
        {
            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )
            a++;
            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )
            b++;
        }

        if(a<=b)
            return false;
        else
            return true;
    }
}
"
2086,java,remove-colored-pieces-if-both-neighbors-are-the-same-color,"class Solution {
    public boolean winnerOfGame(String s) {
        int n = s.length();
    
        int a=0;
        int b=0;
        
        for(int i=1; i<n; i++) 
        {
            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )
            a++;
            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )
            b++;
        }

        if(a<=b)
            return false;
        else
            return true;
    }
}",None,"class Solution {
    public boolean winnerOfGame(String s) {
        int n = s.length();
    
        int a=0;
        int b=0;
        
        for(int i=1; i<n-1; i++) 
        {
            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )
            a++;
            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )
            b++;
        }

        if(a<=b)
            return false;
        else
            return true;
    }
}
"
2087,java,minimum-suffix-flips,"class Solution {
    public int minFlips(String target) {
        int flips = 0;
        char prev = target.charAt(0);
        if (prev == '1') flips++;

        for (int i = 1; i <= target.length(); i++) {
            char c = target.charAt(i);
            if (c != prev) {
                flips++;
                prev = c;
            }
        }
        return flips;
    }
}",None,"class Solution {
    public int minFlips(String target) {
        int flips = 0;
        char prev = target.charAt(0);
        if (prev == '1') flips++;

        for (int i = 1; i < target.length(); i++) {
            char c = target.charAt(i);
            if (c != prev) {
                flips++;
                prev = c;
            }
        }
        return flips;
    }
}
"
2087,java,minimum-suffix-flips,"class Solution {
    public int minFlips(String target) {
        int flips = 0;
        char prev = target.charAt(0);
        if (prev == '1') flips++;

        for (int i = 1; i <= target.length(); i++) {
            char c = target.charAt(i);
            if (c != prev) {
                flips++;
                prev = c;
            }
        }
        return flips;
    }
}",None,"class Solution {
    public int minFlips(String target) {
        int flips = 0;
        char prev = target.charAt(0);
        if (prev == '1') flips++;

        for (int i = 1; i < target.length(); i++) {
            char c = target.charAt(i);
            if (c != prev) {
                flips++;
                prev = c;
            }
        }
        return flips;
    }
}
"
2087,java,minimum-suffix-flips,"class Solution {
    public int minFlips(String target) {
        int flips = 0;
        char prev = target.charAt(0);
        if (prev == '1') flips++;

        for (int i = 1; i <= target.length(); i++) {
            char c = target.charAt(i);
            if (c != prev) {
                flips++;
                prev = c;
            }
        }
        return flips;
    }
}",None,"class Solution {
    public int minFlips(String target) {
        int flips = 0;
        char prev = target.charAt(0);
        if (prev == '1') flips++;

        for (int i = 1; i < target.length(); i++) {
            char c = target.charAt(i);
            if (c != prev) {
                flips++;
                prev = c;
            }
        }
        return flips;
    }
}
"
2088,java,number-of-arithmetic-triplets,"class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        
        int count=0;
        for(int i=0;i<=nums.length;i++){
            for(int j=i+1;j<=nums.length;j++){
                for(int k=j+1;k<=nums.length;k++){
                    if(nums[j]-nums[i]==diff && nums[k] - nums[j] == diff){
                        count++;
                    }
                }
            }
        }
        
        return count;
    }
}",None,"class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        
        int count=0;
        for(int i=0;i<nums.length-2;i++){
            for(int j=i+1;j<nums.length-1;j++){
                for(int k=j+1;k<nums.length;k++){
                    if(nums[j]-nums[i]==diff && nums[k] - nums[j] == diff){
                        count++;
                    }
                }
            }
        }
        
        return count;
    }
}
"
2088,java,number-of-arithmetic-triplets,"class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        
        int count=0;
        for(int i=0;i<=nums.length;i++){
            for(int j=i+1;j<=nums.length;j++){
                for(int k=j+1;k<=nums.length;k++){
                    if(nums[j]-nums[i]==diff && nums[k] - nums[j] == diff){
                        count++;
                    }
                }
            }
        }
        
        return count;
    }
}",None,"class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        
        int count=0;
        for(int i=0;i<nums.length-2;i++){
            for(int j=i+1;j<nums.length-1;j++){
                for(int k=j+1;k<nums.length;k++){
                    if(nums[j]-nums[i]==diff && nums[k] - nums[j] == diff){
                        count++;
                    }
                }
            }
        }
        
        return count;
    }
}
"
2088,java,number-of-arithmetic-triplets,"class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        
        int count=0;
        for(int i=0;i<=nums.length;i++){
            for(int j=i+1;j<=nums.length;j++){
                for(int k=j+1;k<=nums.length;k++){
                    if(nums[j]-nums[i]==diff && nums[k] - nums[j] == diff){
                        count++;
                    }
                }
            }
        }
        
        return count;
    }
}",None,"class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        
        int count=0;
        for(int i=0;i<nums.length;i++){
            for(int j=i+1;j<nums.length;j++){
                for(int k=j+1;k<nums.length;k++){
                    if(nums[j]-nums[i]==diff && nums[k] - nums[j] == diff){
                        count++;
                    }
                }
            }
        }
        
        return count;
    }
}
"
2089,java,word-search,"class Solution {
    private boolean visited[][];
    public boolean exist(char[][] board, String word) {
        int m=board.length, n=board[0].length;
        visited=new boolean[m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(board[i][j]==word.charAt(0)&&dfs(board,i,j,0,word)) return true;
            }
        }
        return false;

        
    }
    public boolean dfs(char[][] board,int i,int j,int index,String word){
        if(index==word.length()) return true;
        if(i<0||j<0||i>=board.length||j>=board[0].length||board[i][j]!=word.charAt(index)||visited[i][j]){
            return false;
        }
        visited[i][j]=true;
        boolean found= dfs(board,i+1,j,index,word)||dfs(board,i-1,j,index,word)||dfs(board,i,j+1,index,word)||dfs(board,i,j-1,index,word);
        visited[i][j]  = false;
        return found;
    }
}",None,"class Solution {
    private boolean visited[][];
    public boolean exist(char[][] board, String word) {
        int m=board.length, n=board[0].length;
        visited=new boolean[m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(board[i][j]==word.charAt(0)&&dfs(board,i,j,0,word)) return true;
            }
        }
        return false;
    }
    public boolean dfs(char[][] board,int i,int j,int index,String word){
        if(index==word.length()) return true;
        if(i<0||j<0||i>=board.length||j>=board[0].length||board[i][j]!=word.charAt(index)||visited[i][j]){
            return false;
        }
        visited[i][j]=true;
        boolean found= dfs(board,i+1,j,index+1,word)||dfs(board,i-1,j,index+1,word)||dfs(board,i,j+1,index+1,word)||dfs(board,i,j-1,index+1,word);
        visited[i][j]  = false;
        return found;
    }
}
"
2089,java,word-search,"class Solution {
    private boolean visited[][];
    public boolean exist(char[][] board, String word) {
        int m=board.length, n=board[0].length;
        visited=new boolean[m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(board[i][j]==word.charAt(0)&&dfs(board,i,j,0,word)) return true;
            }
        }
        return false;

        
    }
    public boolean dfs(char[][] board,int i,int j,int index,String word){
        if(index==word.length()) return true;
        if(i<0||j<0||i>=board.length||j>=board[0].length||board[i][j]!=word.charAt(index)||visited[i][j]){
            return false;
        }
        visited[i][j]=true;
        boolean found= dfs(board,i+1,j,index,word)||dfs(board,i-1,j,index,word)||dfs(board,i,j+1,index,word)||dfs(board,i,j-1,index,word);
        visited[i][j]  = false;
        return found;
    }
}",None,"class Solution {
    private boolean visited[][];
    public boolean exist(char[][] board, String word) {
        int m=board.length, n=board[0].length;
        visited=new boolean[m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(board[i][j]==word.charAt(0)&&dfs(board,i,j,0,word)) return true;
            }
        }
        return false;
    }
    public boolean dfs(char[][] board,int i,int j,int index,String word){
        if(index==word.length()) return true;
        if(i<0||j<0||i>=board.length||j>=board[0].length||board[i][j]!=word.charAt(index)||visited[i][j]){
            return false;
        }
        visited[i][j]=true;
        boolean found= dfs(board,i+1,j,index+1,word)||dfs(board,i-1,j,index+1,word)||dfs(board,i,j+1,index+1,word)||dfs(board,i,j-1,index+1,word);
        visited[i][j]  = false;
        return found;
    }
}
"
2089,java,word-search,"class Solution {
    private boolean visited[][];
    public boolean exist(char[][] board, String word) {
        int m=board.length, n=board[0].length;
        visited=new boolean[m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(board[i][j]==word.charAt(0)&&dfs(board,i,j,0,word)) return true;
            }
        }
        return false;

        
    }
    public boolean dfs(char[][] board,int i,int j,int index,String word){
        if(index==word.length()) return true;
        if(i<0||j<0||i>=board.length||j>=board[0].length||board[i][j]!=word.charAt(index)||visited[i][j]){
            return false;
        }
        visited[i][j]=true;
        boolean found= dfs(board,i+1,j,index,word)||dfs(board,i-1,j,index,word)||dfs(board,i,j+1,index,word)||dfs(board,i,j-1,index,word);
        visited[i][j]  = false;
        return found;
    }
}",None,"class Solution {
    private boolean visited[][];
    public boolean exist(char[][] board, String word) {
        int m=board.length, n=board[0].length;
        visited=new boolean[m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(board[i][j]==word.charAt(0)&&dfs(board,i,j,0,word)) return true;
            }
        }
        return false;

        
    }
    public boolean dfs(char[][] board,int i,int j,int index,String word){
        if(index==word.length()) return true;
        if(i<0||j<0||i>=board.length||j>=board[0].length||board[i][j]!=word.charAt(index)||visited[i][j]){
            return false;
        }
        visited[i][j]=true;
        boolean found= dfs(board,i+1,j,index+1,word)||dfs(board,i-1,j,index+1,word)||dfs(board,i,j+1,index+1,word)||dfs(board,i,j-1,index+1,word);
        visited[i][j]  = false;
        return found;
    }
}
"
2090,java,make-costs-of-paths-equal-in-a-binary-tree,"class Solution {
    int res = 0;
    public int minIncrements(int n, int[] cost) {
        dfs(1, cost);
        return res;
    }

    public int dfs(int i, int[] cost) {
        
        if (i >= cost.length) return 0;
        int left = dfs(i * 2, cost), right = dfs(i * 2 + 1, cost);
        res += Math.abs(left - right);
        return cost[i - 1] + Math.max(left, right);
    }
}",None,"class Solution {
    int res = 0;
    public int minIncrements(int n, int[] cost) {
        return dfs(0, cost);
    }

    public int dfs(int i, int[] cost) {
        if (i >= cost.length) return 0;
        int left = dfs(2 * i + 1, cost), right = dfs(2 * i + 2, cost);
        res += Math.abs(left - right);
        return cost[i] + Math.max(left, right);
    }
}
"
2090,java,make-costs-of-paths-equal-in-a-binary-tree,"class Solution {
    int res = 0;
    public int minIncrements(int n, int[] cost) {
        dfs(1, cost);
        return res;
    }

    public int dfs(int i, int[] cost) {
        
        if (i >= cost.length) return 0;
        int left = dfs(i * 2, cost), right = dfs(i * 2 + 1, cost);
        res += Math.abs(left - right);
        return cost[i - 1] + Math.max(left, right);
    }
}",None,"class Solution {
    int res = 0;
    public int minIncrements(int n, int[] cost) {
        dfs(1, cost, 0);
        return res;
    }

    public void dfs(int i, int[] cost, int maxSoFar) {
        
        if (i > cost.length) return;
        maxSoFar = Math.max(maxSoFar, cost[i-1]);
        if (2*i > cost.length) {
            res += maxSoFar - cost[i-1];
        }
        dfs(2 * i, cost, maxSoFar);
        dfs(2 * i + 1, cost, maxSoFar);
    }
}
"
2090,java,make-costs-of-paths-equal-in-a-binary-tree,"class Solution {
    int res = 0;
    public int minIncrements(int n, int[] cost) {
        dfs(1, cost);
        return res;
    }

    public int dfs(int i, int[] cost) {
        
        if (i >= cost.length) return 0;
        int left = dfs(i * 2, cost), right = dfs(i * 2 + 1, cost);
        res += Math.abs(left - right);
        return cost[i - 1] + Math.max(left, right);
    }
}",None,"class Solution {
    int res = 0;
    public int minIncrements(int n, int[] cost) {
        dfs(0, cost);
        return res;
    }

    public int dfs(int i, int[] cost) {
        
        if (i >= cost.length) return 0;
        int left = dfs(i * 2 + 1, cost), right = dfs(i * 2 + 2, cost);
        res += Math.abs(left - right);
        return cost[i] + Math.max(left, right);
    }
}
"
2091,java,continuous-subarray-sum,"class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        HashMap<Integer,Integer> hm  = new HashMap<>();
        hm.put(0,0);
        
        int sum = 0;
        for( int  i = 0;i < nums.length; i++){
            int num = nums[i];
            sum+=num;
      
            if(hm.containsKey(sum%k)){
                if(hm.get(sum%k)  <= i )
                    return true;
            }else
                hm.put(sum%k, i+1);
            
        }
        return false;
    }
}",None,"class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        HashMap<Integer,Integer> hm  = new HashMap<>();
        hm.put(0,-1);
        
        int sum = 0;
        for( int  i = 0; i < nums.length; i++){
            sum += nums[i];
            sum = sum % k;
      
            if(hm.containsKey(sum)){
                if(i - hm.get(sum) > 1)
                    return true;
            } else
                hm.put(sum, i);
        }
        return false;
    }
}
"
2091,java,continuous-subarray-sum,"class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        HashMap<Integer,Integer> hm  = new HashMap<>();
        hm.put(0,0);
        
        int sum = 0;
        for( int  i = 0;i < nums.length; i++){
            int num = nums[i];
            sum+=num;
      
            if(hm.containsKey(sum%k)){
                if(hm.get(sum%k)  <= i )
                    return true;
            }else
                hm.put(sum%k, i+1);
            
        }
        return false;
    }
}",None,"class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        HashMap<Integer,Integer> hm  = new HashMap<>();
        hm.put(0,-1);
        
        int sum = 0;
        for( int  i = 0;i < nums.length; i++){
            int num = nums[i];
            sum+=num;
            sum %=k;
      
            if(hm.containsKey(sum)){
                if(i - hm.get(sum)  >= 2)
                    return true;
            }else
                hm.put(sum, i);
        }
        return false;
    }
}
"
2091,java,continuous-subarray-sum,"class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        HashMap<Integer,Integer> hm  = new HashMap<>();
        hm.put(0,0);
        
        int sum = 0;
        for( int  i = 0;i < nums.length; i++){
            int num = nums[i];
            sum+=num;
      
            if(hm.containsKey(sum%k)){
                if(hm.get(sum%k)  <= i )
                    return true;
            }else
                hm.put(sum%k, i+1);
            
        }
        return false;
    }
}",None,"class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        HashMap<Integer,Integer> hm  = new HashMap<>();
        hm.put(0,-1);
        
        int sum = 0;
        for( int  i = 0;i < nums.length; i++){
            sum += nums[i];
            if(k != 0) sum = sum % k;
            if(hm.containsKey(sum)){
                if(i - hm.get(sum) > 1 )
                    return true;
            }else
                hm.put(sum, i);
        }
        return false;
    }
}
"
2092,java,count-common-words-with-one-occurrence,"class Solution {
    public int countWords(String[] words1, String[] words2) {
        Map<String, Integer> map1 = new HashMap<>();
        Map<String, Integer> map2 = new HashMap<>();

        for (String s: words1){
            if(map1.containsKey(s)) map1.put(s, map1.get(s)+1);
            else map1.put(s, 1);
        }
        for (String s: words2){
            if(map2.containsKey(s)) map2.put(s, map2.get(s)+1);
            else map2.put(s, 1);
        }
        int count = 0;
        for(String i : words2){
            if(map1.get(i) == 1 && map2.getOrDefault(i,0) == 1 ){
                count++;
            }
        }

        return count;
    }
}",None,"class Solution {
    public int countWords(String[] words1, String[] words2) {
        Map<String, Integer> map1 = new HashMap<>();
        Map<String, Integer> map2 = new HashMap<>();

        for (String s: words1){
            map1.put(s, map1.getOrDefault(s, 0) + 1);
        }
        for (String s: words2){
            map2.put(s, map2.getOrDefault(s, 0) + 1);
        }
        int count = 0;
        for(String i : map1.keySet()){
            if(map1.get(i) == 1 && map2.get(i) == 1) {
                count++;
            }
        }

        return count;
    }
}
"
2092,java,count-common-words-with-one-occurrence,"class Solution {
    public int countWords(String[] words1, String[] words2) {
        Map<String, Integer> map1 = new HashMap<>();
        Map<String, Integer> map2 = new HashMap<>();

        for (String s: words1){
            if(map1.containsKey(s)) map1.put(s, map1.get(s)+1);
            else map1.put(s, 1);
        }
        for (String s: words2){
            if(map2.containsKey(s)) map2.put(s, map2.get(s)+1);
            else map2.put(s, 1);
        }
        int count = 0;
        for(String i : words2){
            if(map1.get(i) == 1 && map2.getOrDefault(i,0) == 1 ){
                count++;
            }
        }

        return count;
    }
}",None,"class Solution {
    public int countWords(String[] words1, String[] words2) {
        Map<String, Integer> map1 = new HashMap<>();
        Map<String, Integer> map2 = new HashMap<>();

        for (String s: words1){
            if(map1.containsKey(s)) map1.put(s, map1.get(s)+1);
            else map1.put(s, 1);
        }
        for (String s: words2){
            if(map2.containsKey(s)) map2.put(s, map2.get(s)+1);
            else map2.put(s, 1);
        }
        int count = 0;
        for(String i : map1.keySet()){
            if(map1.get(i) == 1 && map2.getOrDefault(i,0) == 1 ){
                count++;
            }
        }

        return count;
    }
}
"
2092,java,count-common-words-with-one-occurrence,"class Solution {
    public int countWords(String[] words1, String[] words2) {
        Map<String, Integer> map1 = new HashMap<>();
        Map<String, Integer> map2 = new HashMap<>();

        for (String s: words1){
            if(map1.containsKey(s)) map1.put(s, map1.get(s)+1);
            else map1.put(s, 1);
        }
        for (String s: words2){
            if(map2.containsKey(s)) map2.put(s, map2.get(s)+1);
            else map2.put(s, 1);
        }
        int count = 0;
        for(String i : words2){
            if(map1.get(i) == 1 && map2.getOrDefault(i,0) == 1 ){
                count++;
            }
        }

        return count;
    }
}",None,"class Solution {
    public int countWords(String[] words1, String[] words2) {
        Map<String, Integer> map1 = new HashMap<>();
        Map<String, Integer> map2 = new HashMap<>();

        for (String s: words1){
            if(map1.containsKey(s)) map1.put(s, map1.get(s)+1);
            else map1.put(s, 1);
        }
        for (String s: words2){
            if(map2.containsKey(s)) map2.put(s, map2.get(s)+1);
            else map2.put(s, 1);
        }
        int count = 0;
        for(String i : map1.keySet()){
            if(map1.get(i) == 1 && map2.getOrDefault(i,0) == 1 ){
                count++;
            }
        }

        return count;
    }
}
"
2093,java,n-queens,"class Solution {
    public List<List<String>> solveNQueens(int n) {
        
        char [][] board = new char[n][n];
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board.length; j++) {
                board[i][j] = '.';
            }
        }
        
        List<List<String>> ans = new ArrayList<>();
        queen(board, 0, ans);
        return ans;
    }

    static void queen(char[][] board, int row, List<List<String>> list) {

        if(row == board.length) {

            list.add(construct(board));
            return;
        }

        for (int col = 0; col < board.length - 1; col++) {
            if(isSafe(board, row, col)) {
                board[row][col] = 'Q';
                queen(board, row + 1, list);
                board[row][col] = '.';
            }
        }
    }

    static List<String> construct(char[][] board) {

        List<String> internal = new ArrayList<>();
        for (int i = 0; i < board.length; i++) {
            String row = new String(board[i]);
            internal.add(row);
        }
        return internal;
    }

    static boolean isSafe(char[][] board, int row, int col) {

        for (int i = 0; i < row; i++) {
            if(board[i][col] == 'Q') {
                return false;
            }
        }


        int maxLeft = Math.min(row, col);

        for (int i = 1; i <= maxLeft; i++) {
            if(board[row - i][col - i] == 'Q') {
                return false;
            }
        }


        int maxRight = Math.min(row, board.length - 1 - col);

        for (int i = 1; i <= maxRight; i++) {
            if(board[row - i][col + i] == 'Q') {
                return false;
            }
        }

        return true;
    }
}",None,"class Solution {
    public List<List<String>> solveNQueens(int n) {
        
        char [][] board = new char[n][n];
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board.length; j++) {
                board[i][j] = '.';
            }
        }
        
        List<List<String>> ans = new ArrayList<>();
        queen(board, 0, ans);
        return ans;
    }

    static void queen(char[][] board, int row, List<List<String>> list) {

        if(row == board.length) {

            list.add(construct(board));
            return;
        }

        for (int col = 0; col < board.length; col++) {
            if(isSafe(board, row, col)) {
                board[row][col] = 'Q';
                queen(board, row + 1, list);
                board[row][col] = '.';
            }
        }
    }

    static List<String> construct(char[][] board) {

        List<String> internal = new ArrayList<>();
        for (int i = 0; i < board.length; i++) {
            String row = new String(board[i]);
            internal.add(row);
        }
        return internal;
    }

    static boolean isSafe(char[][] board, int row, int col) {

        for (int i = 0; i < row; i++) {
            if(board[i][col] == 'Q') {
                return false;
            }
        }


        int maxLeft = Math.min(row, col);

        for (int i = 1; i <= maxLeft; i++) {
            if(board[row - i][col - i] == 'Q') {
                return false;
            }
        }


        int maxRight = Math.min(row, board.length - 1 - col);

        for (int i = 1; i <= maxRight; i++) {
            if(board[row - i][col + i] == 'Q') {
                return false;
            }
        }

        return true;
    }
}
"
2093,java,n-queens,"class Solution {
    public List<List<String>> solveNQueens(int n) {
        
        char [][] board = new char[n][n];
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board.length; j++) {
                board[i][j] = '.';
            }
        }
        
        List<List<String>> ans = new ArrayList<>();
        queen(board, 0, ans);
        return ans;
    }

    static void queen(char[][] board, int row, List<List<String>> list) {

        if(row == board.length) {

            list.add(construct(board));
            return;
        }

        for (int col = 0; col < board.length - 1; col++) {
            if(isSafe(board, row, col)) {
                board[row][col] = 'Q';
                queen(board, row + 1, list);
                board[row][col] = '.';
            }
        }
    }

    static List<String> construct(char[][] board) {

        List<String> internal = new ArrayList<>();
        for (int i = 0; i < board.length; i++) {
            String row = new String(board[i]);
            internal.add(row);
        }
        return internal;
    }

    static boolean isSafe(char[][] board, int row, int col) {

        for (int i = 0; i < row; i++) {
            if(board[i][col] == 'Q') {
                return false;
            }
        }


        int maxLeft = Math.min(row, col);

        for (int i = 1; i <= maxLeft; i++) {
            if(board[row - i][col - i] == 'Q') {
                return false;
            }
        }


        int maxRight = Math.min(row, board.length - 1 - col);

        for (int i = 1; i <= maxRight; i++) {
            if(board[row - i][col + i] == 'Q') {
                return false;
            }
        }

        return true;
    }
}",None,"class Solution {
    public List<List<String>> solveNQueens(int n) {
        
        char[][] board = new char[n][n];
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board.length; j++) {
                board[i][j] = '.';
            }
        }
        
        List<List<String>> ans = new ArrayList<>();
        queen(board, 0, ans);
        return ans;  
    }

    static void queen(char[][] board, int row, List<List<String>> list) {

        if(row == board.length) {

            list.add(construct(board));
            return;
        }

        for (int col = 0; col < board.length; col++) {
            if(isSafe(board, row, col)) {
                board[row][col] = 'Q';
                queen(board, row + 1, list);
                board[row][col] = '.';
            }
        }
    }

    static List<String> construct(char[][] board) {

        List<String> internal = new ArrayList<>();
        for (int i = 0; i < board.length; i++) {
            String row = new String(board[i]);
            internal.add(row);
        }
        return internal;
    }

    static boolean isSafe(char[][] board, int row, int col) {

        for (int i = 0; i < row; i++) {
            if(board[i][col] == 'Q') {
                return false;
            }
        }


        int maxLeft = Math.min(row, col);

        for (int i = 1; i <= maxLeft; i++) {
            if(board[row - i][col - i] == 'Q') {
                return false;
            }
        }


        int maxRight = Math.min(row, board.length - 1 - col);

        for (int i = 1; i <= maxRight; i++) {
            if(board[row - i][col + i] == 'Q') {
                return false;
            }
        }

        return true;
    }
}
"
2093,java,n-queens,"class Solution {
    public List<List<String>> solveNQueens(int n) {
        
        char [][] board = new char[n][n];
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board.length; j++) {
                board[i][j] = '.';
            }
        }
        
        List<List<String>> ans = new ArrayList<>();
        queen(board, 0, ans);
        return ans;
    }

    static void queen(char[][] board, int row, List<List<String>> list) {

        if(row == board.length) {

            list.add(construct(board));
            return;
        }

        for (int col = 0; col < board.length - 1; col++) {
            if(isSafe(board, row, col)) {
                board[row][col] = 'Q';
                queen(board, row + 1, list);
                board[row][col] = '.';
            }
        }
    }

    static List<String> construct(char[][] board) {

        List<String> internal = new ArrayList<>();
        for (int i = 0; i < board.length; i++) {
            String row = new String(board[i]);
            internal.add(row);
        }
        return internal;
    }

    static boolean isSafe(char[][] board, int row, int col) {

        for (int i = 0; i < row; i++) {
            if(board[i][col] == 'Q') {
                return false;
            }
        }


        int maxLeft = Math.min(row, col);

        for (int i = 1; i <= maxLeft; i++) {
            if(board[row - i][col - i] == 'Q') {
                return false;
            }
        }


        int maxRight = Math.min(row, board.length - 1 - col);

        for (int i = 1; i <= maxRight; i++) {
            if(board[row - i][col + i] == 'Q') {
                return false;
            }
        }

        return true;
    }
}",None,"class Solution {
    public List<List<String>> solveNQueens(int n) {
        
        char [][] board = new char[n][n];
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board.length; j++) {
                board[i][j] = '.';
            }
        }
        
        List<List<String>> ans = new ArrayList<>();
        queen(board, 0, ans);
        return ans;
    }

    static void queen(char[][] board, int row, List<List<String>> list) {

        if(row == board.length) {

            list.add(construct(board));
            return;
        }

        for (int col = 0; col < board.length; col++) {
            if(isSafe(board, row, col)) {
                board[row][col] = 'Q';
                queen(board, row + 1, list);
                board[row][col] = '.';
            }
        }
    }

    static List<String> construct(char[][] board) {

        List<String> internal = new ArrayList<>();
        for (int i = 0; i < board.length; i++) {
            String row = new String(board[i]);
            internal.add(row);
        }
        return internal;
    }

    static boolean isSafe(char[][] board, int row, int col) {

        for (int i = 0; i < row; i++) {
            if(board[i][col] == 'Q') {
                return false;
            }
        }


        int i = row, j = col;
        while (i >= 0 && j >= 0) {
            if(board[i][j] == 'Q') {
                return false;
            }
            i--;
            j--;
        }


        i = row; j = col;
        while (i >= 0 && j < board.length) {
            if(board[i][j] == 'Q') {
                return false;
            }
            i--;
            j++;
        }

        return true;
    }
}
"
2094,java,next-permutation,"class Solution {
    public void nextPermutation(int[] n) {
       if(  n==null || n.length<=1)return;
		
		int i = n.length-2;

		while(i>=0 && n[i]>=n[i+1])i--;
		
		int j=n.length-1;
		
		if(i>=0) {
			while(n[j]>=n[i])j--;
			swap(n,i,j);
		}
		
		reverse(n,i+1,n.length-1);
		
		for(int p=0;p<n.length;p++) {
			System.out.println(n[p]);
		}
		
	}
	public static void swap(int n[],int i,int j) {
		int temp=n[i];
		n[i]=n[j];
		n[j]=temp;
	}
	public static void reverse(int n[],int i,int j) {
		while(i<j) {
			swap(n,i,j);
			i++;
			j--;
		}
	}
}",None,"class Solution {
    public void nextPermutation(int[] n) {
       if(  n==null || n.length<=1)return;
		
		int i = n.length-2;

		while(i>=0 && n[i]>=n[i+1])i--;
		
		if(i>=0) {
		    int j=n.length-1;
			while(n[j]<=n[i])j--;
			swap(n,i,j);
		}
		
		reverse(n,i+1,n.length-1);
	}
	public static void swap(int n[],int i,int j) {
		int temp=n[i];
		n[i]=n[j];
		n[j]=temp;
	}
	public static void reverse(int n[],int i,int j) {
		while(i<j) {
			swap(n,i,j);
			i++;
			j--;
		}
	}
}
"
2094,java,next-permutation,"class Solution {
    public void nextPermutation(int[] n) {
       if(  n==null || n.length<=1)return;
		
		int i = n.length-2;

		while(i>=0 && n[i]>=n[i+1])i--;
		
		int j=n.length-1;
		
		if(i>=0) {
			while(n[j]>=n[i])j--;
			swap(n,i,j);
		}
		
		reverse(n,i+1,n.length-1);
		
		for(int p=0;p<n.length;p++) {
			System.out.println(n[p]);
		}
		
	}
	public static void swap(int n[],int i,int j) {
		int temp=n[i];
		n[i]=n[j];
		n[j]=temp;
	}
	public static void reverse(int n[],int i,int j) {
		while(i<j) {
			swap(n,i,j);
			i++;
			j--;
		}
	}
}",None,"class Solution {
    public void nextPermutation(int[] n) {
       if(  n==null || n.length<=1)return;
		
		int i = n.length-2;

		while(i>=0 && n[i]>=n[i+1])i--;
		
		int j=n.length-1;
		
		if(i>=0) {
			while(n[j]<=n[i])j--;
			swap(n,i,j);
		}
		
		reverse(n,i+1,n.length-1);
		
	}
	public static void swap(int n[],int i,int j) {
		int temp=n[i];
		n[i]=n[j];
		n[j]=temp;
	}
	public static void reverse(int n[],int i,int j) {
		while(i<j) {
			swap(n,i,j);
			i++;
			j--;
		}
	}
}
"
2094,java,next-permutation,"class Solution {
    public void nextPermutation(int[] n) {
       if(  n==null || n.length<=1)return;
		
		int i = n.length-2;

		while(i>=0 && n[i]>=n[i+1])i--;
		
		int j=n.length-1;
		
		if(i>=0) {
			while(n[j]>=n[i])j--;
			swap(n,i,j);
		}
		
		reverse(n,i+1,n.length-1);
		
		for(int p=0;p<n.length;p++) {
			System.out.println(n[p]);
		}
		
	}
	public static void swap(int n[],int i,int j) {
		int temp=n[i];
		n[i]=n[j];
		n[j]=temp;
	}
	public static void reverse(int n[],int i,int j) {
		while(i<j) {
			swap(n,i,j);
			i++;
			j--;
		}
	}
}",None,"class Solution {
    public void nextPermutation(int[] nums) {
        if(nums == null || nums.length <= 1) return;
		
        int i = nums.length - 2;

        while(i >= 0 && nums[i] >= nums[i + 1]) i--;
		
        if(i >= 0) {
            int j = nums.length - 1;
	    while(nums[j] <= nums[i]) j--;
	    swap(nums, i, j);
        }
		
        reverse(nums, i + 1, nums.length - 1);
    }

    public static void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    public static void reverse(int[] nums, int i, int j) {
        while(i < j) {
            swap(nums, i, j);
            i++;
            j--;
        }
    }
}
"
2095,java,largest-3-same-digit-number-in-string,"class Solution {
    public String largestGoodInteger(String num) {
        int n=-1;
        StringBuilder sb = new StringBuilder();
        for(int i=0;i<=num.length()-2;i++){
            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){
                sb.append(num.charAt(i));
                sb.append(num.charAt(i));
                sb.append(num.charAt(i));
                if(Integer.parseInt(sb.toString())>n)
                    n=Integer.parseInt(sb.toString());
                sb.setLength(0);
            }
        }
        if(n==-1)
            return """";
        String s = Integer.toString(n);
        if(s.equals(""0""))
            return ""000"";
        return s;
    }
}",None,"class Solution {
    public String largestGoodInteger(String num) {
        String res=""-1"";
        StringBuilder sb = new StringBuilder();
        for(int i=0;i<=num.length()-3;i++){
            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){
                sb.append(num.charAt(i));
                sb.append(num.charAt(i+1));
                sb.append(num.charAt(i+2));
                if(sb.toString().compareTo(res) > 0)
                    res = sb.toString();
                sb.setLength(0);
            }
        }
        if(res.equals(""-1""))
            return """";
        return res;
    }
}
"
2095,java,largest-3-same-digit-number-in-string,"class Solution {
    public String largestGoodInteger(String num) {
        int n=-1;
        StringBuilder sb = new StringBuilder();
        for(int i=0;i<=num.length()-2;i++){
            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){
                sb.append(num.charAt(i));
                sb.append(num.charAt(i));
                sb.append(num.charAt(i));
                if(Integer.parseInt(sb.toString())>n)
                    n=Integer.parseInt(sb.toString());
                sb.setLength(0);
            }
        }
        if(n==-1)
            return """";
        String s = Integer.toString(n);
        if(s.equals(""0""))
            return ""000"";
        return s;
    }
}",None,"class Solution {
    public String largestGoodInteger(String num) {
        String res = """";
        for(int i=0;i<=num.length()-3;i++){
            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){
                String cur = num.substring(i, i+3);
                if(cur.compareTo(res) > 0) {
                    res = cur;
                }
            }
        }
        return res;
    }
}
"
2095,java,largest-3-same-digit-number-in-string,"class Solution {
    public String largestGoodInteger(String num) {
        int n=-1;
        StringBuilder sb = new StringBuilder();
        for(int i=0;i<=num.length()-2;i++){
            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){
                sb.append(num.charAt(i));
                sb.append(num.charAt(i));
                sb.append(num.charAt(i));
                if(Integer.parseInt(sb.toString())>n)
                    n=Integer.parseInt(sb.toString());
                sb.setLength(0);
            }
        }
        if(n==-1)
            return """";
        String s = Integer.toString(n);
        if(s.equals(""0""))
            return ""000"";
        return s;
    }
}",None,"class Solution {
    public String largestGoodInteger(String num) {
        int n=-1;
        StringBuilder sb = new StringBuilder();
        for(int i=0;i<=num.length()-3;i++){
            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){
                sb.append(num.charAt(i));
                sb.append(num.charAt(i));
                sb.append(num.charAt(i));
                if(Integer.parseInt(sb.toString())>n)
                    n=Integer.parseInt(sb.toString());
                sb.setLength(0);
            }
        }
        if(n==-1)
            return """";
        String s = Integer.toString(n);
        if(s.equals(""0""))
            return ""000"";
        return s;
    }
}
"
2096,java,matrix-block-sum,"class Solution {
    public int[][] matrixBlockSum(int[][] mat, int k) {
        int[][] answer = new int[mat.length][mat[0].length];

        for(int i = 0; i < mat.length; i++) {
            for(int j = 0; j < mat[0].length; j++) {
                int rowStart = i-k;
                int rowEnd = i+k;
                int colStart = j-k;
                int colEnd = j+k;

                if(rowStart < 0) {
                    rowStart = 0;
                }

                if(rowEnd >= mat.length) {
                    rowEnd = mat.length - 1;
                }

                if(colStart < 0) {
                    colStart = 0;
                }

                if(colEnd >= mat[0].length) {
                    colEnd = mat[0].length - 1;
                }

                answer[i][j] = blockSum(mat, rowStart, rowEnd, colStart, colEnd);
            }
        }

        return answer;
    }

    private int blockSum(int[][] mat, int rowStart, int rowEnd, int colStart, int colEnd) {
        int sum = 0;

        for(int i = rowStart; i <= rowEnd; i++) {
            for(int j = colStart; j < colEnd; j++) {
                sum += mat[i][j];
            }
        }
        return sum;
    }
}",None,"class Solution {
    public int[][] matrixBlockSum(int[][] mat, int k) {
        int[][] answer = new int[mat.length][mat[0].length];

        for(int i = 0; i < mat.length; i++) {
            for(int j = 0; j < mat[0].length; j++) {
                int rowStart = i-k;
                int rowEnd = i+k;
                int colStart = j-k;
                int colEnd = j+k;

                if(rowStart < 0) {
                    rowStart = 0;
                }

                if(rowEnd >= mat.length) {
                    rowEnd = mat.length - 1;
                }

                if(colStart < 0) {
                    colStart = 0;
                }

                if(colEnd >= mat[0].length) {
                    colEnd = mat[0].length - 1;
                }

                answer[i][j] = blockSum(mat, rowStart, rowEnd, colStart, colEnd);
            }
        }

        return answer;
    }

    private int blockSum(int[][] mat, int rowStart, int rowEnd, int colStart, int colEnd) {
        int sum = 0;

        for(int i = rowStart; i <= rowEnd; i++) {
            for(int j = colStart; j <= colEnd; j++) {
                sum += mat[i][j];
            }
        }
        return sum;
    }
}
"
2096,java,matrix-block-sum,"class Solution {
    public int[][] matrixBlockSum(int[][] mat, int k) {
        int[][] answer = new int[mat.length][mat[0].length];

        for(int i = 0; i < mat.length; i++) {
            for(int j = 0; j < mat[0].length; j++) {
                int rowStart = i-k;
                int rowEnd = i+k;
                int colStart = j-k;
                int colEnd = j+k;

                if(rowStart < 0) {
                    rowStart = 0;
                }

                if(rowEnd >= mat.length) {
                    rowEnd = mat.length - 1;
                }

                if(colStart < 0) {
                    colStart = 0;
                }

                if(colEnd >= mat[0].length) {
                    colEnd = mat[0].length - 1;
                }

                answer[i][j] = blockSum(mat, rowStart, rowEnd, colStart, colEnd);
            }
        }

        return answer;
    }

    private int blockSum(int[][] mat, int rowStart, int rowEnd, int colStart, int colEnd) {
        int sum = 0;

        for(int i = rowStart; i <= rowEnd; i++) {
            for(int j = colStart; j < colEnd; j++) {
                sum += mat[i][j];
            }
        }
        return sum;
    }
}",None,"class Solution {
    public int[][] matrixBlockSum(int[][] mat, int k) {
        int[][] answer = new int[mat.length][mat[0].length];

        for(int i = 0; i < mat.length; i++) {
            for(int j = 0; j < mat[0].length; j++) {
                int rowStart = i-k;
                int rowEnd = i+k;
                int colStart = j-k;
                int colEnd = j+k;

                if(rowStart < 0) {
                    rowStart = 0;
                }

                if(rowEnd >= mat.length) {
                    rowEnd = mat.length - 1;
                }

                if(colStart < 0) {
                    colStart = 0;
                }

                if(colEnd >= mat[0].length) {
                    colEnd = mat[0].length - 1;
                }

                answer[i][j] = blockSum(mat, rowStart, rowEnd, colStart, colEnd);
            }
        }

        return answer;
    }

    private int blockSum(int[][] mat, int rowStart, int rowEnd, int colStart, int colEnd) {
        int sum = 0;

        for(int i = rowStart; i <= rowEnd; i++) {
            for(int j = colStart; j <= colEnd; j++) {
                sum += mat[i][j];
            }
        }
        return sum;
    }
}  
"
2096,java,matrix-block-sum,"class Solution {
    public int[][] matrixBlockSum(int[][] mat, int k) {
        int[][] answer = new int[mat.length][mat[0].length];

        for(int i = 0; i < mat.length; i++) {
            for(int j = 0; j < mat[0].length; j++) {
                int rowStart = i-k;
                int rowEnd = i+k;
                int colStart = j-k;
                int colEnd = j+k;

                if(rowStart < 0) {
                    rowStart = 0;
                }

                if(rowEnd >= mat.length) {
                    rowEnd = mat.length - 1;
                }

                if(colStart < 0) {
                    colStart = 0;
                }

                if(colEnd >= mat[0].length) {
                    colEnd = mat[0].length - 1;
                }

                answer[i][j] = blockSum(mat, rowStart, rowEnd, colStart, colEnd);
            }
        }

        return answer;
    }

    private int blockSum(int[][] mat, int rowStart, int rowEnd, int colStart, int colEnd) {
        int sum = 0;

        for(int i = rowStart; i <= rowEnd; i++) {
            for(int j = colStart; j < colEnd; j++) {
                sum += mat[i][j];
            }
        }
        return sum;
    }
}",None,"class Solution {
    public int[][] matrixBlockSum(int[][] mat, int k) {
        int[][] answer = new int[mat.length][mat[0].length];

        for(int i = 0; i < mat.length; i++) {
            for(int j = 0; j < mat[0].length; j++) {
                int rowStart = i-k;
                int rowEnd = i+k;
                int colStart = j-k;
                int colEnd = j+k;

                if(rowStart < 0) {
                    rowStart = 0;
                }

                if(rowEnd >= mat.length) {
                    rowEnd = mat.length - 1;
                }

                if(colStart < 0) {
                    colStart = 0;
                }

                if(colEnd >= mat[0].length) {
                    colEnd = mat[0].length - 1;
                }

                answer[i][j] = blockSum(mat, rowStart, rowEnd, colStart, colEnd);
            }
        }

        return answer;
    }

    private int blockSum(int[][] mat, int rowStart, int rowEnd, int colStart, int colEnd) {
        int sum = 0;

        for(int i = rowStart; i <= rowEnd; i++) {
            for(int j = colStart; j <= colEnd; j++) {
                sum += mat[i][j];
            }
        }
        return sum;
    }
}
"
2097,java,special-array-with-x-elements-greater-than-or-equal-x,"class Solution {
    public int countPossibility(int []nums,int x){
        int cnt=0;
        for(int n:nums) if(n>x) cnt++;
        return cnt;
    }
    public int specialArray(int[] nums) {
        int maxi=Integer.MIN_VALUE,start=1,mid=0;
        for(int x:nums) maxi=Math.max(maxi,x);
        int end = maxi;
        while(start<=end){
            mid = (start+end)/2;
            int check = countPossibility(nums,mid);
            if(check==mid) return mid;
            if(mid<check) start=mid+1;
            else end=mid-1;
        }
        return -1;
    }
}",None,"class Solution {
    public int countPossibility(int []nums,int x){
        int cnt=0;
        for(int n:nums) if(n>=x) cnt++;
        return cnt;
    }
    public int specialArray(int[] nums) {
        int maxi=Integer.MIN_VALUE,start=1,mid=0;
        for(int x:nums) maxi=Math.max(maxi,x);
        int end = maxi;
        while(start<=end){
            mid = (start+end)/2;
            int check = countPossibility(nums,mid);
            if(check==mid) return mid;
            if(mid<check) start=mid+1;
            else end=mid-1;
        }
        return -1;
    }
}
"
2097,java,special-array-with-x-elements-greater-than-or-equal-x,"class Solution {
    public int countPossibility(int []nums,int x){
        int cnt=0;
        for(int n:nums) if(n>x) cnt++;
        return cnt;
    }
    public int specialArray(int[] nums) {
        int maxi=Integer.MIN_VALUE,start=1,mid=0;
        for(int x:nums) maxi=Math.max(maxi,x);
        int end = maxi;
        while(start<=end){
            mid = (start+end)/2;
            int check = countPossibility(nums,mid);
            if(check==mid) return mid;
            if(mid<check) start=mid+1;
            else end=mid-1;
        }
        return -1;
    }
}",None,"class Solution {
    public int countPossibility(int []nums,int x){
        int cnt=0;
        for(int n:nums) if(n>=x) cnt++;
        return cnt;
    }
    public int specialArray(int[] nums) {
        int maxi=Integer.MIN_VALUE,start=1,mid=0;
        for(int x:nums) maxi=Math.max(maxi,x);
        int end = maxi;
        while(start<=end){
            mid = (start+end)/2;
            int check = countPossibility(nums,mid);
            if(check==mid) return mid;
            if(mid<check) start=mid+1;
            else end=mid-1;
        }
        return -1;
    }
}
"
2097,java,special-array-with-x-elements-greater-than-or-equal-x,"class Solution {
    public int countPossibility(int []nums,int x){
        int cnt=0;
        for(int n:nums) if(n>x) cnt++;
        return cnt;
    }
    public int specialArray(int[] nums) {
        int maxi=Integer.MIN_VALUE,start=1,mid=0;
        for(int x:nums) maxi=Math.max(maxi,x);
        int end = maxi;
        while(start<=end){
            mid = (start+end)/2;
            int check = countPossibility(nums,mid);
            if(check==mid) return mid;
            if(mid<check) start=mid+1;
            else end=mid-1;
        }
        return -1;
    }
}",None,"class Solution {
    public int countPossibility(int []nums,int x){
        int cnt=0;
        for(int n:nums) if(n>=x) cnt++;
        return cnt;
    }
    public int specialArray(int[] nums) {
        int maxi=Integer.MIN_VALUE,start=1,mid=0;
        for(int x:nums) maxi=Math.max(maxi,x);
        int end = maxi;
        while(start<=end){
            mid = (start+end)/2;
            int check = countPossibility(nums,mid);
            if(check==mid) return mid;
            if(mid<check) start=mid+1;
            else end=mid-1;
        }
        return -1;
    }
}
"
2098,java,number-of-provinces,"class DSU:
    def __init__(self, n):
        self.par = list(range(n))
        self.rank = [1] * n
        self.size = 1
    def find(self, u):
        if u != self.par[u]:
            self.par[u] = self.find(self.par[u])
        return self.par[u]
    def union(self, u, v):
        uu, vv = self.find(u), self.find(v)
        if uu == vv:
            return False
        if self.rank[uu] > self.rank[vv]:
            self.par[vv] = uu
        elif self.rank[vv] > self.rank[uu]:
            self.par[uu] = vv
        else:
            self.par[uu] = vv
            self.rank[vv] += 1
        self.size += 1
        return True

class Solution:
    def isConnected(self, u, v, G):
        return G[u][v] == 1

    def findCircleNum(self, G: List[List[int]]) -> int:
        n = len(G)
        uf = DSU(n)
        if not G:
            return 0
        for u in range(n):
            for v in range(n):
                if self.isConnected(u, v, G):
                    uf.union(u, v)
        return len(set([uf.find(i) for i in range(n)]))",None,"class DSU:
    def __init__(self, n):
        self.par = list(range(n))
        self.rank = [1] * n

    def find(self, u):
        if u != self.par[u]:
            self.par[u] = self.find(self.par[u])
        return self.par[u]

    def union(self, u, v):
        uu, vv = self.find(u), self.find(v)
        if uu == vv:
            return False
        if self.rank[uu] > self.rank[vv]:
            self.par[vv] = uu
        elif self.rank[vv] > self.rank[uu]:
            self.par[uu] = vv
        else:
            self.par[uu] = vv
            self.rank[vv] += 1
        return True

class Solution:
    def isConnected(self, u, v, G):
        return G[u][v] == 1

    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        n = len(isConnected)
        uf = DSU(n)
        if not isConnected:
            return 0
        for u in range(n):
            for v in range(n):
                if self.isConnected(u, v, isConnected):
                    uf.union(u, v)
        return len(set([uf.find(i) for i in range(n)]))
"
2098,java,number-of-provinces,"class DSU:
    def __init__(self, n):
        self.par = list(range(n))
        self.rank = [1] * n
        self.size = 1
    def find(self, u):
        if u != self.par[u]:
            self.par[u] = self.find(self.par[u])
        return self.par[u]
    def union(self, u, v):
        uu, vv = self.find(u), self.find(v)
        if uu == vv:
            return False
        if self.rank[uu] > self.rank[vv]:
            self.par[vv] = uu
        elif self.rank[vv] > self.rank[uu]:
            self.par[uu] = vv
        else:
            self.par[uu] = vv
            self.rank[vv] += 1
        self.size += 1
        return True

class Solution:
    def isConnected(self, u, v, G):
        return G[u][v] == 1

    def findCircleNum(self, G: List[List[int]]) -> int:
        n = len(G)
        uf = DSU(n)
        if not G:
            return 0
        for u in range(n):
            for v in range(n):
                if self.isConnected(u, v, G):
                    uf.union(u, v)
        return len(set([uf.find(i) for i in range(n)]))",None,"class DSU:
    def __init__(self, n):
        self.par = list(range(n))
        self.rank = [1] * n
    
    def find(self, u):
        if u != self.par[u]:
            self.par[u] = self.find(self.par[u])
        return self.par[u]

    def union(self, u, v):
        uu, vv = self.find(u), self.find(v)
        if uu == vv:
            return False
        if self.rank[uu] > self.rank[vv]:
            self.par[vv] = uu
        elif self.rank[vv] > self.rank[uu]:
            self.par[uu] = vv
        else:
            self.par[uu] = vv
            self.rank[vv] += 1
        return True

class Solution:
    def isConnected(self, u, v, G):
        return G[u][v] == 1

    def findCircleNum(self, G: List[List[int]]) -> int:
        n = len(G)
        uf = DSU(n)
        for u in range(n):
            for v in range(n):
                if self.isConnected(u, v, G):
                    uf.union(u, v)
        return len(set([uf.find(i) for i in range(n)]))
"
2098,java,number-of-provinces,"class DSU:
    def __init__(self, n):
        self.par = list(range(n))
        self.rank = [1] * n
        self.size = 1
    def find(self, u):
        if u != self.par[u]:
            self.par[u] = self.find(self.par[u])
        return self.par[u]
    def union(self, u, v):
        uu, vv = self.find(u), self.find(v)
        if uu == vv:
            return False
        if self.rank[uu] > self.rank[vv]:
            self.par[vv] = uu
        elif self.rank[vv] > self.rank[uu]:
            self.par[uu] = vv
        else:
            self.par[uu] = vv
            self.rank[vv] += 1
        self.size += 1
        return True

class Solution:
    def isConnected(self, u, v, G):
        return G[u][v] == 1

    def findCircleNum(self, G: List[List[int]]) -> int:
        n = len(G)
        uf = DSU(n)
        if not G:
            return 0
        for u in range(n):
            for v in range(n):
                if self.isConnected(u, v, G):
                    uf.union(u, v)
        return len(set([uf.find(i) for i in range(n)]))",None,"class DSU:
    def __init__(self, n):
        self.par = list(range(n))
        self.rank = [1] * n
    def find(self, u):
        if u != self.par[u]:
            self.par[u] = self.find(self.par[u])
        return self.par[u]
    def union(self, u, v):
        uu, vv = self.find(u), self.find(v)
        if uu == vv:
            return False
        if self.rank[uu] > self.rank[vv]:
            self.par[vv] = uu
        elif self.rank[vv] > self.rank[uu]:
            self.par[uu] = vv
        else:
            self.par[uu] = vv
            self.rank[vv] += 1
        return True

class Solution:
    def isConnected(self, u, v, G):
        return G[u][v] == 1

    def findCircleNum(self, G: List[List[int]]) -> int:
        n = len(G)
        uf = DSU(n)
        if not G:
            return 0
        for u in range(n):
            for v in range(n):
                if self.isConnected(u, v, G):
                    uf.union(u, v)
        return len(set([uf.find(i) for i in range(n)]))"
2099,java,number-of-senior-citizens,"class Solution {
    public int countSeniors(String[] details) {

     int count=0;
     for(int i=0;i<details.length;i++)
     {
         int a=details[i].charAt(11)-'0';
         a*=10;
         a+=details[i].charAt(12)-'0';
         if(a<60)
         {
             count++;
         }
     }
     return count;    
    }
}",None,"class Solution {
    public int countSeniors(String[] details) {

     int count=0;
     for(int i=0;i<details.length;i++)
     {
         int a=details[i].charAt(11)-'0';
         a*=10;
         a+=details[i].charAt(12)-'0';
         if(a>60)
         {
             count++;
         }
     }
     return count;    
    }
}
"
2099,java,number-of-senior-citizens,"class Solution {
    public int countSeniors(String[] details) {

     int count=0;
     for(int i=0;i<details.length;i++)
     {
         int a=details[i].charAt(11)-'0';
         a*=10;
         a+=details[i].charAt(12)-'0';
         if(a<60)
         {
             count++;
         }
     }
     return count;    
    }
}",None,"class Solution {
    public int countSeniors(String[] details) {

     int count=0;
     for(int i=0;i<details.length;i++)
     {
         int a=details[i].charAt(11)-'0';
         a*=10;
         a+=details[i].charAt(12)-'0';
         if(a>60)
         {
             count++;
         }
     }
     return count;    
    }
}
"
2099,java,number-of-senior-citizens,"class Solution {
    public int countSeniors(String[] details) {

     int count=0;
     for(int i=0;i<details.length;i++)
     {
         int a=details[i].charAt(11)-'0';
         a*=10;
         a+=details[i].charAt(12)-'0';
         if(a<60)
         {
             count++;
         }
     }
     return count;    
    }
}",None,"class Solution {
    public int countSeniors(String[] details) {

     int count=0;
     for(int i=0;i<details.length;i++)
     {
         int a=details[i].charAt(11)-'0';
         a*=10;
         a+=details[i].charAt(12)-'0';
         if(a>60)
         {
             count++;
         }
     }
     return count;    
    }
}
"
2100,java,find-nearest-point-that-has-the-same-x-or-y-coordinate,"class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        int minManh = Integer.MAX_VALUE;
        int indMin = -1;
        for (int i = 0; i < points.length; i++)
        {
            int tmpManh = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
            if ((x == points[i][0] && y == points[i][1]) && (tmpManh < minManh))
            {
                minManh = tmpManh;
                indMin = i;
            }
        }
        return indMin;
    }
}",None,"class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        int minManh = Integer.MAX_VALUE;
        int indMin = -1;
        for (int i = 0; i < points.length; i++)
        {
            int tmpManh = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
            if ((x == points[i][0] || y == points[i][1]) && (tmpManh < minManh))
            {
                minManh = tmpManh;
                indMin = i;
            }
        }
        return indMin;
    }
}
"
2100,java,find-nearest-point-that-has-the-same-x-or-y-coordinate,"class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        int minManh = Integer.MAX_VALUE;
        int indMin = -1;
        for (int i = 0; i < points.length; i++)
        {
            int tmpManh = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
            if ((x == points[i][0] && y == points[i][1]) && (tmpManh < minManh))
            {
                minManh = tmpManh;
                indMin = i;
            }
        }
        return indMin;
    }
}",None,"class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        int minManh = Integer.MAX_VALUE;
        int indMin = -1;
        for (int i = 0; i < points.length; i++)
        {
            if (x == points[i][0] || y == points[i][1])
            {
                int tmpManh = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
                if (tmpManh < minManh)
                {
                    minManh = tmpManh;
                    indMin = i;
                }
            }
        }
        return indMin;
    }
}
"
2100,java,find-nearest-point-that-has-the-same-x-or-y-coordinate,"class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        int minManh = Integer.MAX_VALUE;
        int indMin = -1;
        for (int i = 0; i < points.length; i++)
        {
            int tmpManh = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
            if ((x == points[i][0] && y == points[i][1]) && (tmpManh < minManh))
            {
                minManh = tmpManh;
                indMin = i;
            }
        }
        return indMin;
    }
}",None,"class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        int minManh = Integer.MAX_VALUE;
        int indMin = -1;
        for (int i = 0; i < points.length; i++)
        {
            if (x == points[i][0] || y == points[i][1]) 
            {
                int tmpManh = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
                if (tmpManh < minManh)
                {
                    minManh = tmpManh;
                    indMin = i;
                }
            }
        }
        return indMin;
    }
}
"
2101,java,count-and-say,"class Solution {
    String convert(String s)
    {
        char prevCh = s.charAt(0);
        int prevCount = 1;
        StringBuilder ans = new StringBuilder();
        for (int i = 1; i <= s.length(); i++)
        {
            char currCh = s.charAt(i);
            if (currCh != prevCh)   
            {
                ans.append(Integer.toString(prevCount));
                ans.append(prevCh);
                prevCount = 1;
                prevCh = currCh;
            }
            else prevCount++;
        }
        ans.append(Integer.toString(prevCount));
        ans.append(prevCh);
        return ans.toString();
    }
    public String countAndSay(int n) 
    {
        String prevStr = ""1"";
        for (int i = 2; i <= n; i++)
        {
            String cnsNum = convert(prevStr);
            prevStr = cnsNum;
        }
        return prevStr;
        
        
    }
}",None,"class Solution {
    
    String convert(String s)
    {
        char prevCh = s.charAt(0);
        int prevCount = 1;
        StringBuilder ans = new StringBuilder();
        
        for (int i = 1; i < s.length(); i++)
        {
            char currCh = s.charAt(i);
            if (currCh != prevCh)
            {
                ans.append(Integer.toString(prevCount));
                ans.append(prevCh);
                prevCount = 1;
                prevCh = currCh;
            }
            else
            {
                prevCount++;
            }
        }

        ans.append(Integer.toString(prevCount));
        ans.append(prevCh);
        return ans.toString();
    }

    public String countAndSay(int n) 
    {
        String prevStr = ""1"";
        for (int i = 2; i <= n; i++)
        {
            String cnsNum = convert(prevStr);
            prevStr = cnsNum;
        }
        return prevStr;
        
    }
}
"
2101,java,count-and-say,"class Solution {
    String convert(String s)
    {
        char prevCh = s.charAt(0);
        int prevCount = 1;
        StringBuilder ans = new StringBuilder();
        for (int i = 1; i <= s.length(); i++)
        {
            char currCh = s.charAt(i);
            if (currCh != prevCh)   
            {
                ans.append(Integer.toString(prevCount));
                ans.append(prevCh);
                prevCount = 1;
                prevCh = currCh;
            }
            else prevCount++;
        }
        ans.append(Integer.toString(prevCount));
        ans.append(prevCh);
        return ans.toString();
    }
    public String countAndSay(int n) 
    {
        String prevStr = ""1"";
        for (int i = 2; i <= n; i++)
        {
            String cnsNum = convert(prevStr);
            prevStr = cnsNum;
        }
        return prevStr;
        
        
    }
}",None,"class Solution {
    String convert(String s)
    {
        char prevCh = s.charAt(0);
        int prevCount = 1;
        StringBuilder ans = new StringBuilder();
        for (int i = 1; i < s.length(); i++)
        {
            char currCh = s.charAt(i);
            if (currCh != prevCh)   
            {
                ans.append(Integer.toString(prevCount));
                ans.append(prevCh);
                prevCount = 1;
                prevCh = currCh;
            }
            else prevCount++;
        }
        ans.append(Integer.toString(prevCount));
        ans.append(prevCh);
        return ans.toString();
    }
    public String countAndSay(int n) 
    {
        String prevStr = ""1"";
        for (int i = 2; i <= n; i++)
        {
            String cnsNum = convert(prevStr);
            prevStr = cnsNum;
        }
        return prevStr;
        
        
    }
}
"
2101,java,count-and-say,"class Solution {
    String convert(String s)
    {
        char prevCh = s.charAt(0);
        int prevCount = 1;
        StringBuilder ans = new StringBuilder();
        for (int i = 1; i <= s.length(); i++)
        {
            char currCh = s.charAt(i);
            if (currCh != prevCh)   
            {
                ans.append(Integer.toString(prevCount));
                ans.append(prevCh);
                prevCount = 1;
                prevCh = currCh;
            }
            else prevCount++;
        }
        ans.append(Integer.toString(prevCount));
        ans.append(prevCh);
        return ans.toString();
    }
    public String countAndSay(int n) 
    {
        String prevStr = ""1"";
        for (int i = 2; i <= n; i++)
        {
            String cnsNum = convert(prevStr);
            prevStr = cnsNum;
        }
        return prevStr;
        
        
    }
}",None,"class Solution {
    String convert(String s)
    {
        char prevCh = s.charAt(0);
        int prevCount = 1;
        StringBuilder ans = new StringBuilder();
        for (int i = 1; i < s.length(); i++)
        {
            char currCh = s.charAt(i);
            if (currCh != prevCh)   
            {
                ans.append(Integer.toString(prevCount));
                ans.append(prevCh);
                prevCount = 1;
                prevCh = currCh;
            }
            else prevCount++;
        }
        ans.append(Integer.toString(prevCount));
        ans.append(prevCh);
        return ans.toString();
    }
    public String countAndSay(int n) 
    {
        String prevStr = ""1"";
        for (int i = 2; i <= n; i++)
        {
            String cnsNum = convert(prevStr);
            prevStr = cnsNum;
        }
        return prevStr;
    }
}
"
2102,java,sort-array-by-increasing-frequency,"class Solution {
    public int[] frequencySort(int[] a) {
	ArrayList<Integer>al=new ArrayList<>();
	    for(int i=0;i<a.length;i++){
	        al.add(a[i]);
	    }
	    
TreeSet<Integer>t2=new TreeSet<>(al);
int k[]=new int[t2.size()];
int c[]=new int[t2.size()];
int x=0;
	    for(int i:t2){
	        c[x]=i;
	k[x]=Collections.frequency(al,i);
	x++;
	    }
	    for(int i=0;i<k.length;i++){
	        for(int j=i+1;j<k.length;j++){
	            if(k[i]<=k[j]){
	                int t=k[i];
	                k[i]=k[j];
	                k[j]=t;
	                int t1=c[i];
	                c[i]=c[j];
	                c[j]=t1;
	            }
	        }    
	    }
			int ans[]=new int[a.length];
			int r=0;
	    for(int i=0;i<k.length;i++){
	        int l=k[i];
	        while(l>0){
	        ans[r]=c[i];
			r++;
	        l--;
	        }
	    }
return ans;
    }
}",None,"class Solution {
    public int[] frequencySort(int[] nums) {
        HashMap<Integer, Integer> count = new HashMap<>();
        for (int n : nums)
            count.put(n, count.getOrDefault(n, 0) + 1);

        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);
        for (int n : count.keySet())
            pq.offer(new int[]{count.get(n), n});

        int i = 0;
        while (!pq.isEmpty()) {
            int[] temp = pq.poll();
            int freq = temp[0];
            int num = temp[1];
            for (int j = 0; j < freq; j++)
                nums[i++] = num;
        }
        return nums;
    }
}
"
2102,java,sort-array-by-increasing-frequency,"class Solution {
    public int[] frequencySort(int[] a) {
	ArrayList<Integer>al=new ArrayList<>();
	    for(int i=0;i<a.length;i++){
	        al.add(a[i]);
	    }
	    
TreeSet<Integer>t2=new TreeSet<>(al);
int k[]=new int[t2.size()];
int c[]=new int[t2.size()];
int x=0;
	    for(int i:t2){
	        c[x]=i;
	k[x]=Collections.frequency(al,i);
	x++;
	    }
	    for(int i=0;i<k.length;i++){
	        for(int j=i+1;j<k.length;j++){
	            if(k[i]<=k[j]){
	                int t=k[i];
	                k[i]=k[j];
	                k[j]=t;
	                int t1=c[i];
	                c[i]=c[j];
	                c[j]=t1;
	            }
	        }    
	    }
			int ans[]=new int[a.length];
			int r=0;
	    for(int i=0;i<k.length;i++){
	        int l=k[i];
	        while(l>0){
	        ans[r]=c[i];
			r++;
	        l--;
	        }
	    }
return ans;
    }
}",None,"class Solution {
    public int[] frequencySort(int[] a) {
        ArrayList<Integer>al=new ArrayList<>();
        for(int i=0;i<a.length;i++){
            al.add(a[i]);
        }
        
        TreeSet<Integer>t2=new TreeSet<>(Collections.reverseOrder());
        t2.addAll(al);
        int c[]=new int[t2.size()];
        int k[]=new int[t2.size()];
        int x=0;
        for(int i:t2){
            c[x]=i;
	        k[x]=Collections.frequency(al,i);
	        x++;
	    }
	    
	    for(int i=0;i<k.length;i++){
	        for(int j=i+1;j<k.length;j++){
	            if(k[i]<k[j] || (k[i]==k[j] && c[i]<c[j])){
	                int t=k[i];
	                k[i]=k[j];
	                k[j]=t;
	                int t1=c[i];
	                c[i]=c[j];
	                c[j]=t1;
	            }
	        }    
	    }
			
	    int ans[]=new int[a.length];
	    int r=0;
	    for(int i=0;i<k.length;i++){
	        int l=k[i];
	        while(l>0){
	            ans[r]=c[i];
				r++;
	            l--;
	        }
	    }
	    return ans;
    }
}
"
2102,java,sort-array-by-increasing-frequency,"class Solution {
    public int[] frequencySort(int[] a) {
	ArrayList<Integer>al=new ArrayList<>();
	    for(int i=0;i<a.length;i++){
	        al.add(a[i]);
	    }
	    
TreeSet<Integer>t2=new TreeSet<>(al);
int k[]=new int[t2.size()];
int c[]=new int[t2.size()];
int x=0;
	    for(int i:t2){
	        c[x]=i;
	k[x]=Collections.frequency(al,i);
	x++;
	    }
	    for(int i=0;i<k.length;i++){
	        for(int j=i+1;j<k.length;j++){
	            if(k[i]<=k[j]){
	                int t=k[i];
	                k[i]=k[j];
	                k[j]=t;
	                int t1=c[i];
	                c[i]=c[j];
	                c[j]=t1;
	            }
	        }    
	    }
			int ans[]=new int[a.length];
			int r=0;
	    for(int i=0;i<k.length;i++){
	        int l=k[i];
	        while(l>0){
	        ans[r]=c[i];
			r++;
	        l--;
	        }
	    }
return ans;
    }
}",None,"class Solution {
    public int[] frequencySort(int[] a) {
        ArrayList<Integer> al=new ArrayList<>();
        for(int i=0; i<a.length; i++){
            al.add(a[i]);
        }

        TreeSet<Integer> t2=new TreeSet<>(al);
        int k[]=new int[t2.size()];
        int c[]=new int[t2.size()];
        int x=0;
        for(int i:t2){
            c[x]=i;
            k[x]=Collections.frequency(al,i);
            x++;
        }

        for(int i=0; i<k.length; i++){
            for(int j=i+1; j<k.length; j++){
                if(k[i]<k[j] || (k[i] == k[j] && c[i] < c[j])){
                    int t=k[i];
                    int t1=c[i];
                    k[i]=k[j];
                    c[i]=c[j];
                    k[j]=t;
                    c[j]=t1;                
                }    
            }
        }

        int ans[]=new int[a.length];
        int r=0;
        for(int i=0; i<k.length; i++){
            int l=k[i];
            while(l>0){
                ans[r]=c[i];
                r++;
                l--;    
            }
        }
        return ans;
    }
}
"
2103,java,similar-string-groups,"class Solution {
    boolean isSimilar(String str1,String str2)
    {
        int count=0;
        for(int i=0;i<str1.length();i++)
        {
            if(str1.charAt(i)!=str2.charAt(i))
            {
                count++;
                if(count>2)
                {
                    return false;
                }
            }
            
        }
        return count==0 || count==2;
    }
    void dfs(String curr, String []strs, Set<String> visited)
    {
        if(visited.contains(curr))
        {
            return;
        }
        visited.add(curr);
        for(int i=0;i<=strs.length;i++)
        {
         if(isSimilar(curr,strs[i]))
         {
             dfs(strs[i],strs,visited);
         }   
        }
    }
    public int numSimilarGroups(String[] strs)
    {
        int count =0;

        if(strs==null ||strs.length ==0)
        {
            return 0;
        }

        Set<String> visited = new HashSet<>();
        for(String s:strs)
        {
            if(!visited.contains(s))
            {
                dfs(s,strs,visited);
                count++;
            }
        }
        return count;
    }
}",None,"class Solution {
    boolean isSimilar(String str1, String str2){
        int count = 0;
        for(int i = 0; i < str1.length(); i++){
            if(str1.charAt(i) != str2.charAt(i)){
                count++;
                if(count > 2){
                    return false;
                }
            }
        }
        return count == 0 || count == 2;
    }
    
    void dfs(String curr, String []strs, Set<String> visited){
        if(visited.contains(curr)){
            return;
        }
        visited.add(curr);
        for(int i = 0; i < strs.length; i++){
            if(isSimilar(curr, strs[i])){
                dfs(strs[i], strs, visited);
            }
        }
    }

    public int numSimilarGroups(String[] strs){
        int count = 0;
        if(strs == null || strs.length == 0){
            return 0;
        }
        Set<String> visited = new HashSet<>();
        for(String s: strs){
            if(!visited.contains(s)){
                dfs(s, strs, visited);
                count++;
            }
        }
        return count;
    }
}
"
2103,java,similar-string-groups,"class Solution {
    boolean isSimilar(String str1,String str2)
    {
        int count=0;
        for(int i=0;i<str1.length();i++)
        {
            if(str1.charAt(i)!=str2.charAt(i))
            {
                count++;
                if(count>2)
                {
                    return false;
                }
            }
            
        }
        return count==0 || count==2;
    }
    void dfs(String curr, String []strs, Set<String> visited)
    {
        if(visited.contains(curr))
        {
            return;
        }
        visited.add(curr);
        for(int i=0;i<=strs.length;i++)
        {
         if(isSimilar(curr,strs[i]))
         {
             dfs(strs[i],strs,visited);
         }   
        }
    }
    public int numSimilarGroups(String[] strs)
    {
        int count =0;

        if(strs==null ||strs.length ==0)
        {
            return 0;
        }

        Set<String> visited = new HashSet<>();
        for(String s:strs)
        {
            if(!visited.contains(s))
            {
                dfs(s,strs,visited);
                count++;
            }
        }
        return count;
    }
}",None,"class Solution {
    boolean isSimilar(String str1,String str2)
    {
        int count=0;
        for(int i=0;i<str1.length();i++)
        {
            if(str1.charAt(i)!=str2.charAt(i))
            {
                count++;
                if(count>2)
                {
                    return false;
                }
            }
            
        }
        return count==0 || count==2;
    }
    void dfs(String curr, String []strs, Set<String> visited)
    {
        if(visited.contains(curr))
        {
            return;
        }
        visited.add(curr);
        for(int i=0;i<strs.length;i++)
        {
         if(isSimilar(curr,strs[i]))
         {
             dfs(strs[i],strs,visited);
         }   
        }
    }
    public int numSimilarGroups(String[] strs)
    {
        int count =0;

        if(strs==null ||strs.length ==0)
        {
            return 0;
        }

        Set<String> visited = new HashSet<>();
        for(String s:strs)
        {
            if(!visited.contains(s))
            {
                dfs(s,strs,visited);
                count++;
            }
        }
        return count;
    }
}
"
2103,java,similar-string-groups,"class Solution {
    boolean isSimilar(String str1,String str2)
    {
        int count=0;
        for(int i=0;i<str1.length();i++)
        {
            if(str1.charAt(i)!=str2.charAt(i))
            {
                count++;
                if(count>2)
                {
                    return false;
                }
            }
            
        }
        return count==0 || count==2;
    }
    void dfs(String curr, String []strs, Set<String> visited)
    {
        if(visited.contains(curr))
        {
            return;
        }
        visited.add(curr);
        for(int i=0;i<=strs.length;i++)
        {
         if(isSimilar(curr,strs[i]))
         {
             dfs(strs[i],strs,visited);
         }   
        }
    }
    public int numSimilarGroups(String[] strs)
    {
        int count =0;

        if(strs==null ||strs.length ==0)
        {
            return 0;
        }

        Set<String> visited = new HashSet<>();
        for(String s:strs)
        {
            if(!visited.contains(s))
            {
                dfs(s,strs,visited);
                count++;
            }
        }
        return count;
    }
}",None,"class Solution {
    boolean isSimilar(String str1,String str2)
    {
        int count=0;
        for(int i=0;i<str1.length();i++)
        {
            if(str1.charAt(i)!=str2.charAt(i))
            {
                count++;
                if(count>2)
                {
                    return false;
                }
            }
            
        }
        return count==0 || count==2;
    }
    void dfs(String curr, String []strs, Set<String> visited)
    {
        if(visited.contains(curr))
        {
            return;
        }
        visited.add(curr);
        for(int i=0;i<strs.length;i++)
        {
         if(isSimilar(curr,strs[i]))
         {
             dfs(strs[i],strs,visited);
         }   
        }
    }
    public int numSimilarGroups(String[] strs)
    {
        int count =0;

        if(strs==null ||strs.length ==0)
        {
            return 0;
        }

        Set<String> visited = new HashSet<>();
        for(String s:strs)
        {
            if(!visited.contains(s))
            {
                dfs(s,strs,visited);
                count++;
            }
        }
        return count;
    }
}
"
2104,java,remove-element,"class Solution {
    public int removeElement(int[] nums, int val) {
        int i = 0;
        for (int j = 0; j < nums.length; j++) {
            if (nums[j] == val) {
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                i++;
            }
        }
        return i;
    }
}",None,"class Solution {
    public int removeElement(int[] nums, int val) {
        int i = 0;
        for (int j = 0; j < nums.length; j++) {
            if (nums[j] != val) {
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                i++;
            }
        }
        return i;
    }
}
"
2104,java,remove-element,"class Solution {
    public int removeElement(int[] nums, int val) {
        int i = 0;
        for (int j = 0; j < nums.length; j++) {
            if (nums[j] == val) {
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                i++;
            }
        }
        return i;
    }
}",None,"class Solution {
    public int removeElement(int[] nums, int val) {
        int i = 0;
        for (int j = 0; j < nums.length; j++) {
            if (nums[j] != val) {
                nums[i] = nums[j];
                i++;
            }
        }
        return i;
    }
}
"
2104,java,remove-element,"class Solution {
    public int removeElement(int[] nums, int val) {
        int i = 0;
        for (int j = 0; j < nums.length; j++) {
            if (nums[j] == val) {
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                i++;
            }
        }
        return i;
    }
}",None,"class Solution {
    public int removeElement(int[] nums, int val) {
        int i = 0;
        for (int j = 0; j < nums.length; j++) {
            if (nums[j] != val) {
                nums[i] = nums[j];
                i++;
            }
        }
        return i;
    }
}
"
2105,java,max-area-of-island,"class Solution {
    public int max = 0;
    public int sum = 0;
    public int maxAreaOfIsland(int[][] grid) {
        for(int i = 0; i<grid.length;i++)
        {
            for(int j = 0; j<grid[i].length;j++)
            {
                if(grid[i][j]!=0)
                {
                    sum = 0; 
                    dfs(grid,i,j);
                    max  = Math.max(max,sum);
                }
            }
        }

        return max;
    }

    private void dfs(int[][] grid ,int r ,int c)
    {
        if(r>=grid.length || c>=grid[0].length || r<0|| c<0 || grid[r][c]==1)
        {
            return ;
        }

        sum++;
        grid[r][c] = 0;
        dfs(grid,r,c+1);
        dfs(grid,r,c-1);
        dfs(grid,r+1,c);
        dfs(grid,r-1,c);
    }
}",None,"class Solution {
    public int max = 0;
    public int sum = 0;
    public int maxAreaOfIsland(int[][] grid) {
        for(int i = 0; i<grid.length;i++)
        {
            for(int j = 0; j<grid[i].length;j++)
            {
                if(grid[i][j] == 1)
                {
                    sum = 0; 
                    dfs(grid,i,j);
                    max  = Math.max(max,sum);
                }
            }
        }

        return max;
    }

    private void dfs(int[][] grid ,int r ,int c)
    {
        if(r>=grid.length || c>=grid[0].length || r<0|| c<0 || grid[r][c] == 0)
        {
            return ;
        }

        sum++;
        grid[r][c] = 0;
        dfs(grid,r,c+1);
        dfs(grid,r,c-1);
        dfs(grid,r+1,c);
        dfs(grid,r-1,c);
    }
}
"
2105,java,max-area-of-island,"class Solution {
    public int max = 0;
    public int sum = 0;
    public int maxAreaOfIsland(int[][] grid) {
        for(int i = 0; i<grid.length;i++)
        {
            for(int j = 0; j<grid[i].length;j++)
            {
                if(grid[i][j]!=0)
                {
                    sum = 0; 
                    dfs(grid,i,j);
                    max  = Math.max(max,sum);
                }
            }
        }

        return max;
    }

    private void dfs(int[][] grid ,int r ,int c)
    {
        if(r>=grid.length || c>=grid[0].length || r<0|| c<0 || grid[r][c]==1)
        {
            return ;
        }

        sum++;
        grid[r][c] = 0;
        dfs(grid,r,c+1);
        dfs(grid,r,c-1);
        dfs(grid,r+1,c);
        dfs(grid,r-1,c);
    }
}",None,"class Solution {
    public int max = 0;
    public int sum = 0;
    public int maxAreaOfIsland(int[][] grid) {
        for(int i = 0; i<grid.length;i++)
        {
            for(int j = 0; j<grid[i].length;j++)
            {
                if(grid[i][j]==1)
                {
                    sum = 0; 
                    dfs(grid,i,j);
                    max  = Math.max(max,sum);
                }
            }
        }

        return max;
    }

    private void dfs(int[][] grid ,int r ,int c)
    {
        if(r>=grid.length || c>=grid[0].length || r<0|| c<0 || grid[r][c]==0)
        {
            return ;
        }

        sum++;
        grid[r][c] = 0;
        dfs(grid,r,c+1);
        dfs(grid,r,c-1);
        dfs(grid,r+1,c);
        dfs(grid,r-1,c);
    }
}
"
2105,java,max-area-of-island,"class Solution {
    public int max = 0;
    public int sum = 0;
    public int maxAreaOfIsland(int[][] grid) {
        for(int i = 0; i<grid.length;i++)
        {
            for(int j = 0; j<grid[i].length;j++)
            {
                if(grid[i][j]!=0)
                {
                    sum = 0; 
                    dfs(grid,i,j);
                    max  = Math.max(max,sum);
                }
            }
        }

        return max;
    }

    private void dfs(int[][] grid ,int r ,int c)
    {
        if(r>=grid.length || c>=grid[0].length || r<0|| c<0 || grid[r][c]==1)
        {
            return ;
        }

        sum++;
        grid[r][c] = 0;
        dfs(grid,r,c+1);
        dfs(grid,r,c-1);
        dfs(grid,r+1,c);
        dfs(grid,r-1,c);
    }
}",None,"class Solution {
    public int max = 0;
    public int sum = 0;
    public int maxAreaOfIsland(int[][] grid) {
        for(int i = 0; i<grid.length;i++)
        {
            for(int j = 0; j<grid[i].length;j++)
            {
                if(grid[i][j]==1) // Bug fix: conditional updated to check if grid[i][j] is equal to 1, not unequal to 0
                {
                    sum = 0; 
                    dfs(grid,i,j);
                    max  = Math.max(max,sum);
                }
            }
        }

        return max;
    }

    private void dfs(int[][] grid ,int r ,int c)
    {
        if(r>=grid.length || c>=grid[0].length || r<0|| c<0 || grid[r][c]==0) // Bug fix: conditional updated to check if grid[r][c] is equal to 0, not 1
        {
            return ;
        }

        sum++;
        grid[r][c] = 0;
        dfs(grid,r,c+1);
        dfs(grid,r,c-1);
        dfs(grid,r+1,c);
        dfs(grid,r-1,c);
    }
}
"
2106,java,minimum-distance-to-the-target-element,"class Solution {
    public int getMinDistance(int[] nums, int target, int start) {
     int n = nums.length;
     int min = Integer.MAX_VALUE;
     for(int i=0;i<n;i++){
         if(nums[i]!=target){ 
          if(Math.abs(i-start)<min){
              min = Math.abs(i-start);
          }   
         }
     }
     return min;   
    }
}",None,"class Solution {
    public int getMinDistance(int[] nums, int target, int start) {
     int n = nums.length;
     int min = Integer.MAX_VALUE;
     for(int i=0;i<n;i++){
         if(nums[i]==target){ 
          if(Math.abs(i-start)<min){
              min = Math.abs(i-start);
          }   
         }
     }
     return min;   
    }
}
"
2106,java,minimum-distance-to-the-target-element,"class Solution {
    public int getMinDistance(int[] nums, int target, int start) {
     int n = nums.length;
     int min = Integer.MAX_VALUE;
     for(int i=0;i<n;i++){
         if(nums[i]!=target){ 
          if(Math.abs(i-start)<min){
              min = Math.abs(i-start);
          }   
         }
     }
     return min;   
    }
}",None,"class Solution {
    public int getMinDistance(int[] nums, int target, int start) {
     int n = nums.length;
     int min = Integer.MAX_VALUE;
     for(int i=0;i<n;i++){
         if(nums[i]==target){ 
          if(Math.abs(i-start)<min){
              min = Math.abs(i-start);
          }   
         }
     }
     return min;   
    }
}
"
2106,java,minimum-distance-to-the-target-element,"class Solution {
    public int getMinDistance(int[] nums, int target, int start) {
     int n = nums.length;
     int min = Integer.MAX_VALUE;
     for(int i=0;i<n;i++){
         if(nums[i]!=target){ 
          if(Math.abs(i-start)<min){
              min = Math.abs(i-start);
          }   
         }
     }
     return min;   
    }
}",None,"class Solution {
    public int getMinDistance(int[] nums, int target, int start) {
     int n = nums.length;
     int min = Integer.MAX_VALUE;
     for(int i=0;i<n;i++){
         if(nums[i]==target){ 
          if(Math.abs(i-start)<min){
              min = Math.abs(i-start);
          }   
         }
     }
     return min;   
    }
}
"
2107,java,most-frequent-subtree-sum,"class Solution{
    public int[] findFrequentTreeSum(TreeNode root) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        helper(root, map);
        List<Integer> list = new ArrayList();
        
        int max = (Collections.max(map.values()));
        for(Map.Entry<Integer, Integer> entry : map.entrySet()){
            if(entry.getValue() == max){
                list.add(entry.getKey());
            }
        }
        
        int[] arr = new int[list.size()];
        for(int i=0; i<=list.size(); i++){
            arr[i] = list.get(i);
        }
        
        return arr;
    }
    public int helper(TreeNode root, Map<Integer, Integer> map){
        if(root==null) return 0;
        int left = helper(root.left, map);
        int right = helper(root.right, map);
        
        int sum = root.val+left+right;
        if(map.containsKey(sum)){
            map.put(sum, map.get(sum)+1);
        }else{
            map.put(sum, 1);
        }
        
        return sum;
    }
}",None,"class Solution{
    public int[] findFrequentTreeSum(TreeNode root) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        helper(root, map);
        List<Integer> list = new ArrayList();
        
        int max = (Collections.max(map.values()));
        for(Map.Entry<Integer, Integer> entry : map.entrySet()){
            if(entry.getValue() == max){
                list.add(entry.getKey());
            }
        }
        
        int[] arr = new int[list.size()];
        for(int i=0; i<list.size(); i++){
            arr[i] = list.get(i);
        }
        
        return arr;
    }
    public int helper(TreeNode root, Map<Integer, Integer> map){
        if(root==null) return 0;
        int left = helper(root.left, map);
        int right = helper(root.right, map);
        
        int sum = root.val+left+right;
        if(map.containsKey(sum)){
            map.put(sum, map.get(sum)+1);
        }else{
            map.put(sum, 1);
        }
        
        return sum;
    }
}
"
2107,java,most-frequent-subtree-sum,"class Solution{
    public int[] findFrequentTreeSum(TreeNode root) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        helper(root, map);
        List<Integer> list = new ArrayList();
        
        int max = (Collections.max(map.values()));
        for(Map.Entry<Integer, Integer> entry : map.entrySet()){
            if(entry.getValue() == max){
                list.add(entry.getKey());
            }
        }
        
        int[] arr = new int[list.size()];
        for(int i=0; i<=list.size(); i++){
            arr[i] = list.get(i);
        }
        
        return arr;
    }
    public int helper(TreeNode root, Map<Integer, Integer> map){
        if(root==null) return 0;
        int left = helper(root.left, map);
        int right = helper(root.right, map);
        
        int sum = root.val+left+right;
        if(map.containsKey(sum)){
            map.put(sum, map.get(sum)+1);
        }else{
            map.put(sum, 1);
        }
        
        return sum;
    }
}",None,"class Solution{
    public int[] findFrequentTreeSum(TreeNode root) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        helper(root, map);
        List<Integer> list = new ArrayList();
        
        int max = (Collections.max(map.values()));
        for(Map.Entry<Integer, Integer> entry : map.entrySet()){
            if(entry.getValue() == max){
                list.add(entry.getKey());
            }
        }
        
        int[] arr = new int[list.size()];
        for(int i=0; i<list.size(); i++){
            arr[i] = list.get(i);
        }
        
        return arr;
    }
    public int helper(TreeNode root, Map<Integer, Integer> map){
        if(root==null) return 0;
        int left = helper(root.left, map);
        int right = helper(root.right, map);
        
        int sum = root.val+left+right;
        if(map.containsKey(sum)){
            map.put(sum, map.get(sum)+1);
        }else{
            map.put(sum, 1);
        }
        
        return sum;
    }
}
"
2107,java,most-frequent-subtree-sum,"class Solution{
    public int[] findFrequentTreeSum(TreeNode root) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        helper(root, map);
        List<Integer> list = new ArrayList();
        
        int max = (Collections.max(map.values()));
        for(Map.Entry<Integer, Integer> entry : map.entrySet()){
            if(entry.getValue() == max){
                list.add(entry.getKey());
            }
        }
        
        int[] arr = new int[list.size()];
        for(int i=0; i<=list.size(); i++){
            arr[i] = list.get(i);
        }
        
        return arr;
    }
    public int helper(TreeNode root, Map<Integer, Integer> map){
        if(root==null) return 0;
        int left = helper(root.left, map);
        int right = helper(root.right, map);
        
        int sum = root.val+left+right;
        if(map.containsKey(sum)){
            map.put(sum, map.get(sum)+1);
        }else{
            map.put(sum, 1);
        }
        
        return sum;
    }
}",None,"class Solution{
    public int[] findFrequentTreeSum(TreeNode root) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        helper(root, map);
        List<Integer> list = new ArrayList();
        
        int max = (Collections.max(map.values()));
        for(Map.Entry<Integer, Integer> entry : map.entrySet()){
            if(entry.getValue() == max){
                list.add(entry.getKey());
            }
        }
        
        int[] arr = new int[list.size()];
        for(int i=0; i<list.size(); i++){
            arr[i] = list.get(i);
        }
        
        return arr;
    }
    public int helper(TreeNode root, Map<Integer, Integer> map){
        if(root==null) return 0;
        int left = helper(root.left, map);
        int right = helper(root.right, map);
        
        int sum = root.val+left+right;
        if(map.containsKey(sum)){
            map.put(sum, map.get(sum)+1);
        }else{
            map.put(sum, 1);
        }
        
        return sum;
    }
}
"
2108,java,maximum-value-at-a-given-index-in-a-bounded-array,"class Solution {
    public int maxValue(int n, int index, int maxSum) {
        int left = 0, right = maxSum - n;

        while (left < right) {
            int middle = (left + right + 1) / 2;
            if (isPossible(n, index, maxSum - n, middle))
                right = middle;
            else
                left = middle - 1;
        }
        return left + 1;
    }

    private boolean isPossible(int n, int index, int maxSum, int value) {
        int leftValue = Math.max(value - index, 0);
        int rightValue = Math.max(value - ((n - 1) - index), 0);

        long sumBefore = (long) (value + leftValue) * (value - leftValue + 1) / 2;
        long sumAfter = (long) (value + rightValue) * (value - rightValue + 1) / 2;

        return sumBefore + sumAfter - value <= maxSum;
    }
}",None,"class Solution {
    public int maxValue(int n, int index, int maxSum) {
        int left = 0, right = maxSum;

        while (left < right) {
            int middle = (left + right + 1) / 2;
            if (isPossible(n, index, maxSum, middle))
                left = middle;
            else
                right = middle - 1;
        }
        return left;
    }

    private boolean isPossible(int n, int index, int maxSum, int value) {
        int leftValue = Math.max(value - index, 0);
        int rightValue = Math.max(value - ((n - 1) - index), 0);

        long sumBefore = (long) (value + leftValue) * (value - leftValue + 1) / 2;
        long sumAfter = (long) (value + rightValue) * (value - rightValue + 1) / 2;

        return sumBefore + sumAfter - value <= maxSum;
    }
}
"
2108,java,maximum-value-at-a-given-index-in-a-bounded-array,"class Solution {
    public int maxValue(int n, int index, int maxSum) {
        int left = 0, right = maxSum - n;

        while (left < right) {
            int middle = (left + right + 1) / 2;
            if (isPossible(n, index, maxSum - n, middle))
                right = middle;
            else
                left = middle - 1;
        }
        return left + 1;
    }

    private boolean isPossible(int n, int index, int maxSum, int value) {
        int leftValue = Math.max(value - index, 0);
        int rightValue = Math.max(value - ((n - 1) - index), 0);

        long sumBefore = (long) (value + leftValue) * (value - leftValue + 1) / 2;
        long sumAfter = (long) (value + rightValue) * (value - rightValue + 1) / 2;

        return sumBefore + sumAfter - value <= maxSum;
    }
}",None,"class Solution {
    public int maxValue(int n, int index, int maxSum) {
        int left = 0, right = maxSum;

        while (left < right) {
            int middle = (left + right + 1) / 2;
            if (isPossible(n, index, maxSum, middle))
                left = middle;
            else
                right = middle - 1;
        }
        return left;
    }

    private boolean isPossible(int n, int index, int maxSum, int value) {
        int leftValue = Math.max(value - index, 0);
        int rightValue = Math.max(value - ((n - 1) - index), 0);

        long sumBefore = (long) (value + leftValue) * (value - leftValue + 1) / 2;
        long sumAfter = (long) (value + rightValue) * (value - rightValue + 1) / 2;

        return sumBefore + sumAfter - value <= maxSum;
    }
}
"
2108,java,maximum-value-at-a-given-index-in-a-bounded-array,"class Solution {
    public int maxValue(int n, int index, int maxSum) {
        int left = 0, right = maxSum - n;

        while (left < right) {
            int middle = (left + right + 1) / 2;
            if (isPossible(n, index, maxSum - n, middle))
                right = middle;
            else
                left = middle - 1;
        }
        return left + 1;
    }

    private boolean isPossible(int n, int index, int maxSum, int value) {
        int leftValue = Math.max(value - index, 0);
        int rightValue = Math.max(value - ((n - 1) - index), 0);

        long sumBefore = (long) (value + leftValue) * (value - leftValue + 1) / 2;
        long sumAfter = (long) (value + rightValue) * (value - rightValue + 1) / 2;

        return sumBefore + sumAfter - value <= maxSum;
    }
}",None,"class Solution {
    public int maxValue(int n, int index, int maxSum) {
        maxSum -= n;
        int left = 0, right = maxSum;

        while (left < right) {
            int middle = (left + right + 1) / 2;
            if (isPossible(n, index, maxSum, middle))
                left = middle;
            else
                right = middle - 1;
        }
        return left + 1;
    }

    private boolean isPossible(int n, int index, int maxSum, int value) {
        int leftValue = Math.max(value - index, 0);
        int rightValue = Math.max(value - ((n - 1) - index), 0);

        long sumBefore = (long) (value + leftValue) * (value - leftValue + 1) / 2;
        long sumAfter = (long) (value + rightValue) * (value - rightValue + 1) / 2;

        return sumBefore + sumAfter - value <= maxSum;
    }
}
"
2109,java,clone-graph,"/*
class Node {
    public int val;
    public List<Node> neighbors;
    public Node() {
        val = 0;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val) {
        val = _val;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val, ArrayList<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}
*/

class Solution {
    public void dfs(Node node, HashMap<Node, Node> dict)
    {
        for (Node nd : node.neighbors) {
            if (!dict.containsKey(nd))
                dict.put(nd, new Node(nd.val));
            dict.get(node).neighbors.add(dict.get(nd));
        }
        for (Node nd : node.neighbors)
        {
            if (dict.get(nd).neighbors.size() == 1)
                dfs(nd, dict);
        }
    }
    public Node cloneGraph(Node node) {
        HashMap<Node, Node> dict = new HashMap<>();
        if (node != null) {
            dict.put(node, new Node(node.val));
            dfs(node, dict);
            return dict.get(node);
        }
        return null;
    }
}",None,"/*
class Node {
    public int val;
    public List<Node> neighbors;
    public Node() {
        val = 0;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val) {
        val = _val;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val, ArrayList<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}
*/

class Solution {
    HashMap<Node, Node> map = new HashMap<>();
    
    public Node cloneGraph(Node node) {
        return clone(node);
    }

    private Node clone(Node node) {
        if (node == null) return null;
        
        if (map.containsKey(node)) {
            return map.get(node);
        }
        
        Node newNode = new Node(node.val, new ArrayList<>());
        map.put(node, newNode); 
        
        for (Node neighbor: node.neighbors) {
            newNode.neighbors.add(clone(neighbor));
        }
        return newNode;
    }
}
"
2109,java,clone-graph,"/*
class Node {
    public int val;
    public List<Node> neighbors;
    public Node() {
        val = 0;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val) {
        val = _val;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val, ArrayList<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}
*/

class Solution {
    public void dfs(Node node, HashMap<Node, Node> dict)
    {
        for (Node nd : node.neighbors) {
            if (!dict.containsKey(nd))
                dict.put(nd, new Node(nd.val));
            dict.get(node).neighbors.add(dict.get(nd));
        }
        for (Node nd : node.neighbors)
        {
            if (dict.get(nd).neighbors.size() == 1)
                dfs(nd, dict);
        }
    }
    public Node cloneGraph(Node node) {
        HashMap<Node, Node> dict = new HashMap<>();
        if (node != null) {
            dict.put(node, new Node(node.val));
            dfs(node, dict);
            return dict.get(node);
        }
        return null;
    }
}",None,"/*
class Node {
    public int val;
    public List<Node> neighbors;
    public Node() {
        val = 0;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val) {
        val = _val;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val, ArrayList<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}
*/

class Solution {
    public void dfs(Node node, HashMap<Node, Node> dict)
    {
        dict.put(node, new Node(node.val));
        for (Node nd : node.neighbors) {
            if (!dict.containsKey(nd)) {
                dfs(nd, dict);
            }
            dict.get(node).neighbors.add(dict.get(nd));
        }
    }
    public Node cloneGraph(Node node) {
        HashMap<Node, Node> dict = new HashMap<>();
        if (node != null) {
            dfs(node, dict);
            return dict.get(node);
        }
        return null;
    }
}
"
2109,java,clone-graph,"/*
class Node {
    public int val;
    public List<Node> neighbors;
    public Node() {
        val = 0;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val) {
        val = _val;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val, ArrayList<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}
*/

class Solution {
    public void dfs(Node node, HashMap<Node, Node> dict)
    {
        for (Node nd : node.neighbors) {
            if (!dict.containsKey(nd))
                dict.put(nd, new Node(nd.val));
            dict.get(node).neighbors.add(dict.get(nd));
        }
        for (Node nd : node.neighbors)
        {
            if (dict.get(nd).neighbors.size() == 1)
                dfs(nd, dict);
        }
    }
    public Node cloneGraph(Node node) {
        HashMap<Node, Node> dict = new HashMap<>();
        if (node != null) {
            dict.put(node, new Node(node.val));
            dfs(node, dict);
            return dict.get(node);
        }
        return null;
    }
}",None,"/*
class Node {
    public int val;
    public List<Node> neighbors;
    public Node() {
        val = 0;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val) {
        val = _val;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val, ArrayList<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}
*/

class Solution {
    public void dfs(Node node, HashMap<Node, Node> dict)
    {
        dict.put(node, new Node(node.val, new ArrayList<>()));
        for(Node neighbor : node.neighbors){
            if(!dict.containsKey(neighbor)) dfs(neighbor, dict);
        }
    }
    public void assignNeighbors(Node node, HashMap<Node, Node> dict) {
        for (Node neighbor : node.neighbors) {
            dict.get(node).neighbors.add(dict.get(neighbor));
            if(dict.get(neighbor).neighbors.contains(dict.get(node))) continue; 
            assignNeighbors(neighbor, dict);
        }
    }
    public Node cloneGraph(Node node) {
        if (node == null) return null;
        
        HashMap<Node, Node> dict = new HashMap<>();
        dfs(node, dict);
        assignNeighbors(node, dict);
        return dict.get(node);
    }
}
"
2110,java,maximum-number-of-integers-to-choose-from-a-range-i,"class Solution {
    public int maxCount(int[] banned, int n, int maxSum) {

        Set<Integer> banSet = new HashSet<>();
        for (int num : banned) {
            banSet.add(num);
        }

        int count = 0;
        int sum = 0;

        for (int i = 1; i <= n; i++) {

            if (!banSet.contains(i) && (sum + i < maxSum)) {
                count++;
                sum += i;
            }
        }
    return count;
    }
}",None,"class Solution {
    public int maxCount(int[] banned, int n, int maxSum) {

        Set<Integer> banSet = new HashSet<>();
        for (int num : banned) {
            banSet.add(num);
        }

        int count = 0;
        int sum = 0;

        for (int i = 1; i <= n; i++) {

            if (!banSet.contains(i) && (sum + i <= maxSum)) {
                count++;
                sum += i;
            }
        }
    return count;
    }
}
"
2110,java,maximum-number-of-integers-to-choose-from-a-range-i,"class Solution {
    public int maxCount(int[] banned, int n, int maxSum) {

        Set<Integer> banSet = new HashSet<>();
        for (int num : banned) {
            banSet.add(num);
        }

        int count = 0;
        int sum = 0;

        for (int i = 1; i <= n; i++) {

            if (!banSet.contains(i) && (sum + i < maxSum)) {
                count++;
                sum += i;
            }
        }
    return count;
    }
}",None,"class Solution {
    public int maxCount(int[] banned, int n, int maxSum) {

        Set<Integer> banSet = new HashSet<>();
        for (int num : banned) {
            banSet.add(num);
        }

        int count = 0;
        int sum = 0;

        for (int i = n; i >= 1; i--) {

            if (!banSet.contains(i) && (sum + i <= maxSum)) {
                count++;
                sum += i;
            }
        }
    return count;
    }
}
"
2110,java,maximum-number-of-integers-to-choose-from-a-range-i,"class Solution {
    public int maxCount(int[] banned, int n, int maxSum) {

        Set<Integer> banSet = new HashSet<>();
        for (int num : banned) {
            banSet.add(num);
        }

        int count = 0;
        int sum = 0;

        for (int i = 1; i <= n; i++) {

            if (!banSet.contains(i) && (sum + i < maxSum)) {
                count++;
                sum += i;
            }
        }
    return count;
    }
}",None,"class Solution {
    public int maxCount(int[] banned, int n, int maxSum) {

        Set<Integer> banSet = new HashSet<>();
        for (int num : banned) {
            banSet.add(num);
        }

        int count = 0;
        int sum = 0;

        for (int i = 1; i <= n; i++) {

            if (!banSet.contains(i) && (sum + i <= maxSum)) {
                count++;
                sum += i;
            }
        }
    return count;
    }
}
"
2111,java,word-ladder-ii,"class Solution {
    String b;

    HashMap < String, Integer > mpp;

    List < List < String >> ans;
    private void dfs(String word, List < String > seq) {

        if (word.equals(b)) {

            List < String > dup = new ArrayList < > (seq);
            Collections.reverse(dup);
            ans.add(dup);
            return;
        }
        int steps = mpp.get(word);
        int sz = word.length();

        for (int i = 0; i < sz; i++) {

            for (char ch = 'a'; ch <= 'y'; ch++) { 
                char replacedCharArray[] = word.toCharArray();
                replacedCharArray[i] = ch;
                String replacedWord = new String(replacedCharArray);
                if (mpp.containsKey(replacedWord) &&
                    mpp.get(replacedWord) + 1 == steps) {

                    seq.add(replacedWord);
                    dfs(replacedWord, seq);

                    seq.remove(seq.size() - 1);
                }
            }
        }
    }
    public List < List < String >> findLadders(String beginWord, String endWord,
        List < String > wordList) {

        Set < String > st = new HashSet < String > ();
        int len = wordList.size();
        for (int i = 0; i < len; i++) {
            st.add(wordList.get(i));
        }
        Queue < String > q = new LinkedList < > ();
        b = beginWord;
        q.add(beginWord);
        mpp = new HashMap < > ();
        mpp.put(beginWord, 1);
        int sizee = beginWord.length();
        st.remove(beginWord);
        while (!q.isEmpty()) {
            String word = q.peek();
            int steps = mpp.get(word);
            q.remove();

            if (word.equals(endWord)) break;

            for (int i = 0; i < sizee; i++) {

                for (char ch = 'a'; ch <= 'y'; ch++) { 
                    char replacedCharArray[] = word.toCharArray();
                    replacedCharArray[i] = ch;
                    String replacedWord = new String(replacedCharArray);
                    if (st.contains(replacedWord) == true) {
                        q.add(replacedWord);
                        st.remove(replacedWord);
                        mpp.put(replacedWord, steps + 1);
                    }
                }
            }
        }
        ans = new ArrayList < > ();

        if (mpp.containsKey(endWord) == true) {
            List < String > seq = new ArrayList < > ();
            seq.add(endWord);
            dfs(endWord, seq);
        }
        return ans;
    }
}",None,"class Solution {
    String b;
    HashMap < String, Integer > mpp;
    List < List < String >> ans;
    private void dfs(String word, List < String > seq) {

        if (word.equals(b)) {
            List < String > dup = new ArrayList < > (seq);
            Collections.reverse(dup);
            ans.add(dup);
            return;
        }
        int steps = mpp.get(word);
        int sz = word.length();

        for (int i = 0; i < sz; i++) {
            for (char ch = 'a'; ch <= 'z'; ch++) {
                char replacedCharArray[] = word.toCharArray();
                replacedCharArray[i] = ch;
                String replacedWord = new String(replacedCharArray);
                if (mpp.containsKey(replacedWord) && mpp.get(replacedWord) + 1 == steps) {
                    seq.add(replacedWord);
                    dfs(replacedWord, seq);
                    seq.remove(seq.size() - 1);
                }
            }
        }
    }
    public List < List < String >> findLadders(String beginWord, String endWord, List < String > wordList) {
        Set < String > st = new HashSet < String > ();
        int len = wordList.size();
        for (int i = 0; i < len; i++) {
            st.add(wordList.get(i));
        }
        Queue < String > q = new LinkedList < > ();
        b = beginWord;
        q.add(beginWord);
        mpp = new HashMap < > ();
        mpp.put(beginWord, 1);
        int sizee = beginWord.length();
        st.remove(beginWord);
        while (!q.isEmpty()) {
            String word = q.peek();
            int steps = mpp.get(word);
            q.remove();

            if (word.equals(endWord)) break;

            for (int i = 0; i < sizee; i++) {
                for (char ch = 'a'; ch <= 'z'; ch++) { 
                    char replacedCharArray[] = word.toCharArray();
                    replacedCharArray[i] = ch;
                    String replacedWord = new String(replacedCharArray);
                    if (st.contains(replacedWord) == true) {
                        q.add(replacedWord);
                        st.remove(replacedWord);
                        mpp.put(replacedWord, steps + 1);
                    }
                }
            }
        }
        ans = new ArrayList < > ();
        if (mpp.containsKey(endWord) == true) {
            List < String > seq = new ArrayList < > ();
            seq.add(endWord);
            dfs(endWord, seq);
        }
        return ans;
    }
}
"
2111,java,word-ladder-ii,"class Solution {
    String b;

    HashMap < String, Integer > mpp;

    List < List < String >> ans;
    private void dfs(String word, List < String > seq) {

        if (word.equals(b)) {

            List < String > dup = new ArrayList < > (seq);
            Collections.reverse(dup);
            ans.add(dup);
            return;
        }
        int steps = mpp.get(word);
        int sz = word.length();

        for (int i = 0; i < sz; i++) {

            for (char ch = 'a'; ch <= 'y'; ch++) { 
                char replacedCharArray[] = word.toCharArray();
                replacedCharArray[i] = ch;
                String replacedWord = new String(replacedCharArray);
                if (mpp.containsKey(replacedWord) &&
                    mpp.get(replacedWord) + 1 == steps) {

                    seq.add(replacedWord);
                    dfs(replacedWord, seq);

                    seq.remove(seq.size() - 1);
                }
            }
        }
    }
    public List < List < String >> findLadders(String beginWord, String endWord,
        List < String > wordList) {

        Set < String > st = new HashSet < String > ();
        int len = wordList.size();
        for (int i = 0; i < len; i++) {
            st.add(wordList.get(i));
        }
        Queue < String > q = new LinkedList < > ();
        b = beginWord;
        q.add(beginWord);
        mpp = new HashMap < > ();
        mpp.put(beginWord, 1);
        int sizee = beginWord.length();
        st.remove(beginWord);
        while (!q.isEmpty()) {
            String word = q.peek();
            int steps = mpp.get(word);
            q.remove();

            if (word.equals(endWord)) break;

            for (int i = 0; i < sizee; i++) {

                for (char ch = 'a'; ch <= 'y'; ch++) { 
                    char replacedCharArray[] = word.toCharArray();
                    replacedCharArray[i] = ch;
                    String replacedWord = new String(replacedCharArray);
                    if (st.contains(replacedWord) == true) {
                        q.add(replacedWord);
                        st.remove(replacedWord);
                        mpp.put(replacedWord, steps + 1);
                    }
                }
            }
        }
        ans = new ArrayList < > ();

        if (mpp.containsKey(endWord) == true) {
            List < String > seq = new ArrayList < > ();
            seq.add(endWord);
            dfs(endWord, seq);
        }
        return ans;
    }
}",None,"class Solution {
    String b;

    HashMap < String, Integer > mpp;

    List < List < String >> ans;
    private void dfs(String word, List < String > seq) {

        if (word.equals(b)) {

            List < String > dup = new ArrayList < > (seq);
            Collections.reverse(dup);
            ans.add(dup);
            return;
        }
        int steps = mpp.get(word);
        int sz = word.length();

        for (int i = 0; i < sz; i++) {

            for (char ch = 'a'; ch <= 'z'; ch++) { 
                char replacedCharArray[] = word.toCharArray();
                replacedCharArray[i] = ch;
                String replacedWord = new String(replacedCharArray);
                if (mpp.containsKey(replacedWord) &&
                    mpp.get(replacedWord) + 1 == steps) {

                    seq.add(replacedWord);
                    dfs(replacedWord, seq);
                    seq.remove(seq.size() - 1);
                }
            }
        }
    }
    public List < List < String >> findLadders(String beginWord, String endWord,
        List < String > wordList) {

        Set < String > st = new HashSet < String > ();
        int len = wordList.size();
        for (int i = 0; i < len; i++) {
            st.add(wordList.get(i));
        }
        Queue < String > q = new LinkedList < > ();
        b = beginWord;
        q.add(beginWord);
        mpp = new HashMap < > ();
        mpp.put(beginWord, 1);
        int sizee = beginWord.length();
        st.remove(beginWord);
        while (!q.isEmpty()) {
            String word = q.peek();
            int steps = mpp.get(word);
            q.remove();

            if (word.equals(endWord)) break;

            for (int i = 0; i < sizee; i++) {

                for (char ch = 'a'; ch <= 'z'; ch++) {
                    char replacedCharArray[] = word.toCharArray();
                    replacedCharArray[i] = ch;
                    String replacedWord = new String(replacedCharArray);
                    if (st.contains(replacedWord) == true) {
                        q.add(replacedWord);
                        st.remove(replacedWord);
                        mpp.put(replacedWord, steps + 1);
                    }
                }
            }
        }
        ans = new ArrayList < > ();

        if (mpp.containsKey(endWord) == true) {
            List < String > seq = new ArrayList < > ();
            seq.add(endWord);
            dfs(endWord, seq);
        }
        return ans;
    }
}
"
2111,java,word-ladder-ii,"class Solution {
    String b;

    HashMap < String, Integer > mpp;

    List < List < String >> ans;
    private void dfs(String word, List < String > seq) {

        if (word.equals(b)) {

            List < String > dup = new ArrayList < > (seq);
            Collections.reverse(dup);
            ans.add(dup);
            return;
        }
        int steps = mpp.get(word);
        int sz = word.length();

        for (int i = 0; i < sz; i++) {

            for (char ch = 'a'; ch <= 'y'; ch++) { 
                char replacedCharArray[] = word.toCharArray();
                replacedCharArray[i] = ch;
                String replacedWord = new String(replacedCharArray);
                if (mpp.containsKey(replacedWord) &&
                    mpp.get(replacedWord) + 1 == steps) {

                    seq.add(replacedWord);
                    dfs(replacedWord, seq);

                    seq.remove(seq.size() - 1);
                }
            }
        }
    }
    public List < List < String >> findLadders(String beginWord, String endWord,
        List < String > wordList) {

        Set < String > st = new HashSet < String > ();
        int len = wordList.size();
        for (int i = 0; i < len; i++) {
            st.add(wordList.get(i));
        }
        Queue < String > q = new LinkedList < > ();
        b = beginWord;
        q.add(beginWord);
        mpp = new HashMap < > ();
        mpp.put(beginWord, 1);
        int sizee = beginWord.length();
        st.remove(beginWord);
        while (!q.isEmpty()) {
            String word = q.peek();
            int steps = mpp.get(word);
            q.remove();

            if (word.equals(endWord)) break;

            for (int i = 0; i < sizee; i++) {

                for (char ch = 'a'; ch <= 'y'; ch++) { 
                    char replacedCharArray[] = word.toCharArray();
                    replacedCharArray[i] = ch;
                    String replacedWord = new String(replacedCharArray);
                    if (st.contains(replacedWord) == true) {
                        q.add(replacedWord);
                        st.remove(replacedWord);
                        mpp.put(replacedWord, steps + 1);
                    }
                }
            }
        }
        ans = new ArrayList < > ();

        if (mpp.containsKey(endWord) == true) {
            List < String > seq = new ArrayList < > ();
            seq.add(endWord);
            dfs(endWord, seq);
        }
        return ans;
    }
}",None,"class Solution {
    String b;

    HashMap<String, Integer> mpp;
    
    List<List<String>> ans;

    private void dfs(String word, List<String> seq) {
        if (word.equals(b)) {
            List<String> dup = new ArrayList<>(seq);
            Collections.reverse(dup);
            ans.add(dup);
            return;
        }
        int steps = mpp.get(word);
        int sz = word.length();
        
        for (int i = 0; i < sz; i++) {
            for (char ch = 'a'; ch <= 'z'; ch++) { 
                char replacedCharArray[] = word.toCharArray();
                replacedCharArray[i] = ch;
                String replacedWord = new String(replacedCharArray);
                if (mpp.containsKey(replacedWord) && mpp.get(replacedWord) + 1 == steps) {
                    seq.add(replacedWord);
                    dfs(replacedWord, seq);
                    seq.remove(seq.size() - 1);
                }
            }
        }
    }

    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        Set<String> st = new HashSet<String>();
        int len = wordList.size();
        for (int i = 0; i < len; i++) {
            st.add(wordList.get(i));
        }
        
        Queue<String> q = new LinkedList<>();
        b = beginWord;
        q.add(beginWord);
        mpp = new HashMap<>();
        mpp.put(beginWord, 1);
        int sizee = beginWord.length();
        st.remove(beginWord);

        while (!q.isEmpty()) {
            String word = q.peek();
            int steps = mpp.get(word);
            q.remove();
            if (word.equals(endWord)) break;

            for (int i = 0; i < sizee; i++) {
                for (char ch = 'a'; ch <= 'z'; ch++) { 
                    char replacedCharArray[] = word.toCharArray();
                    replacedCharArray[i] = ch;
                    String replacedWord = new String(replacedCharArray);
                    if (st.contains(replacedWord)) {
                        q.add(replacedWord);
                        st.remove(replacedWord);
                        mpp.put(replacedWord, steps + 1);
                    }
                }
            }
        }

        ans = new ArrayList<>();
        if (mpp.containsKey(endWord)) {
            List<String> seq = new ArrayList<>();
            seq.add(endWord);
            dfs(endWord, seq);
        }
        return ans;
    }
}
"
2112,java,find-nearest-point-that-has-the-same-x-or-y-coordinate,"class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        
        int sIndex = 100000;
        int sDistance = 100000;

        for (int i = 0; i <= points.length; i++) {
            
            if (points[i][0] == x || points[i][1] == y) {

                int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
                if (sDistance > distance) {
                    sDistance = distance;
                    sIndex = i;
                }
            }
        }

        if (sIndex == 100000)
            return -1;
        return sIndex;
    }
}",None,"class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        
        int sIndex = -1;
        int sDistance = Integer.MAX_VALUE;

        for (int i = 0; i < points.length; i++) {
            
            if (points[i][0] == x || points[i][1] == y) {
                
                int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
                if (sDistance > distance) {
                    sDistance = distance;
                    sIndex = i;
                }
            }
        }
        
        return sIndex;
    }
}
"
2112,java,find-nearest-point-that-has-the-same-x-or-y-coordinate,"class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        
        int sIndex = 100000;
        int sDistance = 100000;

        for (int i = 0; i <= points.length; i++) {
            
            if (points[i][0] == x || points[i][1] == y) {

                int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
                if (sDistance > distance) {
                    sDistance = distance;
                    sIndex = i;
                }
            }
        }

        if (sIndex == 100000)
            return -1;
        return sIndex;
    }
}",None,"class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        
        int sIndex = 100000;
        int sDistance = 100000;

        for (int i = 0; i < points.length; i++) {
            
            if (points[i][0] == x || points[i][1] == y) {

                int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
                if (sDistance > distance) {
                    sDistance = distance;
                    sIndex = i;
                }
            }
        }

        if (sIndex == 100000)
            return -1;
        return sIndex;
    }
}
"
2112,java,find-nearest-point-that-has-the-same-x-or-y-coordinate,"class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        
        int sIndex = 100000;
        int sDistance = 100000;

        for (int i = 0; i <= points.length; i++) {
            
            if (points[i][0] == x || points[i][1] == y) {

                int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
                if (sDistance > distance) {
                    sDistance = distance;
                    sIndex = i;
                }
            }
        }

        if (sIndex == 100000)
            return -1;
        return sIndex;
    }
}",None,"class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        
        int sIndex = 100000;
        int sDistance = 100000;

        for (int i = 0; i < points.length; i++) {
            
            if (points[i][0] == x || points[i][1] == y) {

                int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
                if (sDistance > distance) {
                    sDistance = distance;
                    sIndex = i;
                }
            }
        }

        if (sIndex == 100000)
            return -1;
        return sIndex;
    }
}
"
2113,java,distribute-candies,"class Solution {
    public int distributeCandies(int[] candyType) {

    Set<Integer>st=new HashSet<>();

    for(int i=0;i<=candyType.length;i++){
        st.add(candyType[i]);
        if(st.size()>candyType.length/2)return candyType.length/2;
    }

    return st.size();

    }
}",None,"class Solution {
    public int distributeCandies(int[] candyType) {

    Set<Integer>st=new HashSet<>();

    for(int i=0;i<candyType.length;i++){
        st.add(candyType[i]);
        if(st.size()>candyType.length/2)return candyType.length/2;
    }

    return st.size();

    }
}
"
2113,java,distribute-candies,"class Solution {
    public int distributeCandies(int[] candyType) {

    Set<Integer>st=new HashSet<>();

    for(int i=0;i<=candyType.length;i++){
        st.add(candyType[i]);
        if(st.size()>candyType.length/2)return candyType.length/2;
    }

    return st.size();

    }
}",None,"class Solution {
    public int distributeCandies(int[] candyType) {

        Set<Integer>st=new HashSet<>();

        for(int i=0;i<candyType.length;i++){
            st.add(candyType[i]);
            if(st.size()>candyType.length/2) return candyType.length/2;
        }

        return st.size();
    }
}
"
2113,java,distribute-candies,"class Solution {
    public int distributeCandies(int[] candyType) {

    Set<Integer>st=new HashSet<>();

    for(int i=0;i<=candyType.length;i++){
        st.add(candyType[i]);
        if(st.size()>candyType.length/2)return candyType.length/2;
    }

    return st.size();

    }
}",None,"class Solution {
    public int distributeCandies(int[] candyType) {

    Set<Integer>st=new HashSet<>();

    for(int i=0;i<candyType.length;i++){
        st.add(candyType[i]);
        if(st.size()>candyType.length/2)return candyType.length/2;
    }

    return st.size();

    }
}
"
2114,java,unique-paths-iii,"class Solution {
    public int uniquePathsIII(int[][] grid) {
        
        int row = 0;
        int col = 0;
        for(int i = 0; i < grid.length; i++) {
            for(int j = 0; j < grid[0].length; j++) {
                if(grid[i][j] == 1) {
                    row = i;
                    col = j;
                    
                    break;
                }
            }
        }
        boolean[][] used = new boolean[grid.length][grid[0].length];
        return count(grid, used, row, col);
    }
    
}",None,"class Solution {
    int[][] dirs={{0,1},{0,-1},{-1,0},{1,0}};
    int empty=1, endRow=0, endCol=0;
    public int uniquePathsIII(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        for (int i=0; i<m; i++)
            for (int j=0; j<n; j++){
                if (grid[i][j]==0) empty++;
                else if (grid[i][j]==2) {endRow=i; endCol=j;}
            }
        return dfs(grid, 0, 0, empty);
    }
    
    public int dfs(int[][] grid, int row, int col, int n){
        int m = grid.length, n = grid[0].length;
        if (row<0 || row>=m || col<0 || col>=n || grid[row][col]<0) return 0;
        if (row==endRow && col==endCol) return n==0? 1:0;
        grid[row][col] = -2;
        int res = dfs(grid, row+1, col, n-1) + dfs(grid, row, col+1, n-1) + dfs(grid, row-1, col, n-1) + dfs(grid, row, col-1, n-1);
        grid[row][col] = 0;
        return res;
    }
}
"
2114,java,unique-paths-iii,"class Solution {
    public int uniquePathsIII(int[][] grid) {
        
        int row = 0;
        int col = 0;
        for(int i = 0; i < grid.length; i++) {
            for(int j = 0; j < grid[0].length; j++) {
                if(grid[i][j] == 1) {
                    row = i;
                    col = j;
                    
                    break;
                }
            }
        }
        boolean[][] used = new boolean[grid.length][grid[0].length];
        return count(grid, used, row, col);
    }
    
}",None,"class Solution {
    int stepCount = 1, resultCount = 0, emptyCount = 0;
    public int uniquePathsIII(int[][] grid) {
        int row = 0, col = 0;
        int endRow = 0, endCol = 0;

        // Aside from the start and end cells, count empty cells
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 0) {
                    emptyCount++;
                } else if (grid[i][j] == 1) {
                    row = i;
                    col = j;
                } else if (grid[i][j] == 2) {
                    endRow = i;
                    endCol = j;
                }
            }
        }

        boolean[][] visited = new boolean[grid.length][grid[0].length];
        visited[row][col] = true;

        // Start the DFS search
        dfs(grid, visited, row, col, endRow, endCol);

        return resultCount;
    }

    private void dfs(int[][] grid, boolean[][] visited, int row, int col, int endRow, int endCol) {
        if (stepCount > emptyCount + 2) return; // already too many steps, return directly

        if (row == endRow && col == endCol) { // reach the end
            if (stepCount == emptyCount + 2) resultCount++; // if stepCount is correct, increment resultCount
            return;
        }

        // No boundary check needed since grid[i][j] is guaranteed to be within the boundary at all steps
        int[] dir = new int[]{-1, 0, 1, 0, -1};
        for (int i = 0; i < 4; i++) {
            int newRow = row + dir[i], newCol = col + dir[i + 1];
            if (grid[newRow][newCol] != -1 && !visited[newRow][newCol]) {
                visited[newRow][newCol] = true; // mark as visited
                stepCount++;
                dfs(grid, visited, newRow, newCol, endRow, endCol);
                visited[newRow][newCol] = false; // mark as unvisited
                stepCount--;
            }
        }
    }
}
"
2114,java,unique-paths-iii,"class Solution {
    public int uniquePathsIII(int[][] grid) {
        
        int row = 0;
        int col = 0;
        for(int i = 0; i < grid.length; i++) {
            for(int j = 0; j < grid[0].length; j++) {
                if(grid[i][j] == 1) {
                    row = i;
                    col = j;
                    
                    break;
                }
            }
        }
        boolean[][] used = new boolean[grid.length][grid[0].length];
        return count(grid, used, row, col);
    }
    
}",None,"class Solution {
    private static final int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    private int rows, cols, empty, result;

    public int uniquePathsIII(int[][] grid) {
        int start_i = 0, start_j = 0;
        this.rows = grid.length;
        this.cols = grid[0].length;
        this.empty = 1;
        for(int i = 0; i < rows; i++) {
            for(int j = 0; j < cols; j++) {
                if(grid[i][j] == 0) 
                    ++this.empty;
                else if(grid[i][j] == 1) {
                    start_i = i;
                    start_j = j;
                }
            }
        }
        this.result = 0;
        dfs(grid, start_i, start_j);
        return result;
    }

    private void dfs(int[][] grid, int i, int j) {
        if(i<0 || i == rows || j<0 || j == cols || grid[i][j] < 0) return;
        if(grid[i][j] == 2) {
            if(empty == 0) ++result;
            return;
        }
        grid[i][j] = -2;
        --empty;
        for(int[] d : directions) dfs(grid, i+d[0], j+d[1]);
        grid[i][j] = 0;
        ++empty;
    }
}
"
2115,java,n-ary-tree-preorder-traversal,"class Solution {
    List<Integer> arr = new ArrayList<>();
    public List<Integer> preorder(Node root) {
        if (root==null) return arr;
        arr.add(root.val);
        for (Node i : root.children) {
            preorder(root);
        }
        return arr;
    }
}",None,"class Solution {
    List<Integer> arr = new ArrayList<>();
    public List<Integer> preorder(Node root) {
        if (root == null) return arr;
        arr.add(root.val);
        for (Node i : root.children) {
            preorder(i);
        }
        return arr;
    }
}
"
2115,java,n-ary-tree-preorder-traversal,"class Solution {
    List<Integer> arr = new ArrayList<>();
    public List<Integer> preorder(Node root) {
        if (root==null) return arr;
        arr.add(root.val);
        for (Node i : root.children) {
            preorder(root);
        }
        return arr;
    }
}",None,"class Solution {
    List<Integer> arr = new ArrayList<>();
    public List<Integer> preorder(Node root) {
        if (root==null) return arr;
        arr.add(root.val);
        for (Node i : root.children) {
            preorder(i);
        }
        return arr;
    }
}
"
2115,java,n-ary-tree-preorder-traversal,"class Solution {
    List<Integer> arr = new ArrayList<>();
    public List<Integer> preorder(Node root) {
        if (root==null) return arr;
        arr.add(root.val);
        for (Node i : root.children) {
            preorder(root);
        }
        return arr;
    }
}",None,"class Solution {
    List<Integer> arr = new ArrayList<>();
    public List<Integer> preorder(Node root) {
        if (root==null) return arr;
        arr.add(root.val);
        for (Node i : root.children) {
            preorder(i);
        }
        return arr;
    }
}
"
2116,java,count-primes,"class Solution {
    public int countPrimes(int n) {
        if(n<2) return 0;
        boolean[] primes = new boolean[n];
        Arrays.fill(primes, true);
         
        int count=0;
        for (int p = 2;p < n; p++) {
            if(primes[p])
            {
                count++;
                if((long)p*p<n)
                {
                    for(int i=p*p;i<=n;i+=p)
                    primes[i]=false;
                }
            }
          }
    return count;
    }
}",None,"class Solution {
    public int countPrimes(int n) {
        if(n<2) return 0;
        boolean[] primes = new boolean[n];
        Arrays.fill(primes, true);
        primes[0] = false;
        primes[1] = false;

        int count=0;
        for (int p = 2;p < n; p++) {
            if(primes[p])
            {
                count++;
                if((long)p*p<n)
                {
                    for(int i=p*p;i<n;i+=p)
                    primes[i]=false;
                }
            }
        }
        return count;
    }
}
"
2116,java,count-primes,"class Solution {
    public int countPrimes(int n) {
        if(n<2) return 0;
        boolean[] primes = new boolean[n];
        Arrays.fill(primes, true);
         
        int count=0;
        for (int p = 2;p < n; p++) {
            if(primes[p])
            {
                count++;
                if((long)p*p<n)
                {
                    for(int i=p*p;i<=n;i+=p)
                    primes[i]=false;
                }
            }
          }
    return count;
    }
}",None,"class Solution {
    public int countPrimes(int n) {
        if(n<2) return 0;
        boolean[] primes = new boolean[n];
        Arrays.fill(primes, true);
         
        int count=0;
        for (int p = 2;p < n; p++) {
            if(primes[p])
            {
                count++;
                if((long)p*p<n)
                {
                    for(int i=p*p;i<n;i+=p)
                    primes[i]=false;
                }
            }
          }
    return count;
    }
}
"
2116,java,count-primes,"class Solution {
    public int countPrimes(int n) {
        if(n<2) return 0;
        boolean[] primes = new boolean[n];
        Arrays.fill(primes, true);
         
        int count=0;
        for (int p = 2;p < n; p++) {
            if(primes[p])
            {
                count++;
                if((long)p*p<n)
                {
                    for(int i=p*p;i<=n;i+=p)
                    primes[i]=false;
                }
            }
          }
    return count;
    }
}",None,"class Solution {
    public int countPrimes(int n) {
        if(n<2) return 0;
        boolean[] primes = new boolean[n];
        Arrays.fill(primes, true);
         
        int count=0;
        for (int p = 2;p < n; p++) {
            if(primes[p])
            {
                count++;
                if((long)p*p<n)
                {
                    for(int i=p*p;i<n;i+=p)
                    primes[i]=false;
                }
            }
          }
    return count;
    }
}
"
2117,java,check-if-point-is-reachable,"class Solution {
    public boolean isReachable(int targetX, int targetY) {
        if (targetX > targetY)
            return isReachable(targetY, targetX);
        if (targetX % 2 == 0)
            return isReachable(targetX / 2, targetY);
        if (targetY % 2 == 0)
            return isReachable(targetX, targetY / 2);
            
        if (targetX == 1)
            return true;

        if (targetY == targetX)
            return true;

        return isReachable(targetX, (targetX + targetY) / 2);
    }
}",None,"class Solution {
    public boolean isReachable(int targetX, int targetY) {
        while(targetX > 1 && targetY > 1) {
            if(targetX > targetY) {
                targetX %= targetY;
            } else {
                targetY %= targetX;
            }
        }
        return targetX == 1 && targetY >= 1 || targetY == 1 && targetX >= 1;
    }
}
"
2117,java,check-if-point-is-reachable,"class Solution {
    public boolean isReachable(int targetX, int targetY) {
        if (targetX > targetY)
            return isReachable(targetY, targetX);
        if (targetX % 2 == 0)
            return isReachable(targetX / 2, targetY);
        if (targetY % 2 == 0)
            return isReachable(targetX, targetY / 2);
            
        if (targetX == 1)
            return true;

        if (targetY == targetX)
            return true;

        return isReachable(targetX, (targetX + targetY) / 2);
    }
}",None,"class Solution {
    public boolean isReachable(int targetX, int targetY) {
        while (targetX >= 1 && targetY >= 1) {
            if(targetX > targetY){
                int temp = targetX;
                targetX = targetY;
                targetY = temp;
            }

            if (targetY > targetX) {
                if (targetX > 1) return false;
                return targetY % 2 == 0;
            }

            targetY -= targetX;
        }
        return targetX == targetY && targetX == 1;
    }
}
"
2117,java,check-if-point-is-reachable,"class Solution {
    public boolean isReachable(int targetX, int targetY) {
        if (targetX > targetY)
            return isReachable(targetY, targetX);
        if (targetX % 2 == 0)
            return isReachable(targetX / 2, targetY);
        if (targetY % 2 == 0)
            return isReachable(targetX, targetY / 2);
            
        if (targetX == 1)
            return true;

        if (targetY == targetX)
            return true;

        return isReachable(targetX, (targetX + targetY) / 2);
    }
}",None,"class Solution {
    public boolean isReachable(int targetX, int targetY) {
        if (targetX > targetY)
            return isReachable(targetY, targetX);
        if (targetX == targetY)
            return targetX == 1;

        if (targetX == 1)
            return true;

        if (targetY % targetX == 0)
            return false;

        return isReachable(targetX, targetY % targetX);
    }
}
"
2118,java,number-of-students-doing-homework-at-a-given-time,"class Solution {
    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {
        int n=endTime.length;
        int cnt=0;
        for(int i=0;i<=n;i++)
        {
            if(endTime[i]>=queryTime && queryTime>=startTime[i] )
            {
                cnt++;
            }
        }
        return cnt;
    }
}",None,"class Solution {
    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {
        int n=endTime.length;
        int cnt=0;
        for(int i=0;i<n;i++) // changed condition i<=n to i<n
        {
            if(endTime[i]>=queryTime && queryTime>=startTime[i] )
            {
                cnt++;
            }
        }
        return cnt;
    }
}
"
2118,java,number-of-students-doing-homework-at-a-given-time,"class Solution {
    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {
        int n=endTime.length;
        int cnt=0;
        for(int i=0;i<=n;i++)
        {
            if(endTime[i]>=queryTime && queryTime>=startTime[i] )
            {
                cnt++;
            }
        }
        return cnt;
    }
}",None,"class Solution {
    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {
        int n=endTime.length;
        int cnt=0;
        for(int i=0;i<n;i++)
        {
            if(endTime[i]>=queryTime && queryTime>=startTime[i] )
            {
                cnt++;
            }
        }
        return cnt;
    }
}
"
2118,java,number-of-students-doing-homework-at-a-given-time,"class Solution {
    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {
        int n=endTime.length;
        int cnt=0;
        for(int i=0;i<=n;i++)
        {
            if(endTime[i]>=queryTime && queryTime>=startTime[i] )
            {
                cnt++;
            }
        }
        return cnt;
    }
}",None,"class Solution {
    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {
        int n=endTime.length;
        int cnt=0;
        for(int i=0;i<n;i++)
        {
            if(endTime[i]>=queryTime && queryTime>=startTime[i] )
            {
                cnt++;
            }
        }
        return cnt;
    }
}
"
2119,java,row-with-maximum-ones,"class Solution {
    public int[] rowAndMaximumOnes(int[][] mat) {
        int count;
        int maxCount = 0;
        int maxCountRow = 0;
        for(int i = 0; i <= mat.length; i++) {
            count = 0;
            for(int j = 0; j < mat[0].length; j++) {
                count += mat[i][j];
            }
            if(count > maxCount) {
                maxCount = count;
                maxCountRow = i;
            }
        }
        return new int[]{maxCountRow, maxCount};
    }
}",None,"class Solution {
    public int[] rowAndMaximumOnes(int[][] mat) {
        int count;
        int maxCount = 0;
        int maxCountRow = 0;
        for(int i = 0; i < mat.length; i++) {
            count = 0;
            for(int j = 0; j < mat[0].length; j++) {
                count += mat[i][j];
            }
            if(count > maxCount) {
                maxCount = count;
                maxCountRow = i;
            }
        }
        return new int[]{maxCountRow, maxCount};
    }
}
"
2119,java,row-with-maximum-ones,"class Solution {
    public int[] rowAndMaximumOnes(int[][] mat) {
        int count;
        int maxCount = 0;
        int maxCountRow = 0;
        for(int i = 0; i <= mat.length; i++) {
            count = 0;
            for(int j = 0; j < mat[0].length; j++) {
                count += mat[i][j];
            }
            if(count > maxCount) {
                maxCount = count;
                maxCountRow = i;
            }
        }
        return new int[]{maxCountRow, maxCount};
    }
}",None,"class Solution {
    public int[] rowAndMaximumOnes(int[][] mat) {
        int count;
        int maxCount = 0;
        int maxCountRow = 0;
        for(int i = 0; i < mat.length; i++) {
            count = 0;
            for(int j = 0; j < mat[0].length; j++) {
                count += mat[i][j];
            }
            if(count > maxCount) {
                maxCount = count;
                maxCountRow = i;
            }
        }
        return new int[]{maxCountRow, maxCount};
    }
}
"
2119,java,row-with-maximum-ones,"class Solution {
    public int[] rowAndMaximumOnes(int[][] mat) {
        int count;
        int maxCount = 0;
        int maxCountRow = 0;
        for(int i = 0; i <= mat.length; i++) {
            count = 0;
            for(int j = 0; j < mat[0].length; j++) {
                count += mat[i][j];
            }
            if(count > maxCount) {
                maxCount = count;
                maxCountRow = i;
            }
        }
        return new int[]{maxCountRow, maxCount};
    }
}",None,"class Solution {
    public int[] rowAndMaximumOnes(int[][] mat) {
        int count;
        int maxCount = 0;
        int maxCountRow = -1;
        for(int i = 0; i < mat.length; i++) {
            count = 0;
            for(int j = 0; j < mat[0].length; j++) {
                count += mat[i][j];
            }
            if(count > maxCount) {
                maxCount = count;
                maxCountRow = i;
            }
        }
        if (maxCountRow == -1) return new int[] {0, 0};
        else return new int[]{maxCountRow, maxCount};
    }
}
"
2120,java,best-time-to-buy-and-sell-stock-ii,"class Solution {
    public int maxProfit(int[] prices) {
        int profit=0;
        for(int i=0; i<prices.length; i++){
            if(prices[i]>prices[i-1]){
                profit+=prices[i]-prices[i-1];
            }
        }
        return profit;
    }
}",None,"class Solution {
    public int maxProfit(int[] prices) {
        int profit=0;
        for(int i=1; i<prices.length; i++){
            if(prices[i]>prices[i-1]){
                profit+=prices[i]-prices[i-1];
            }
        }
        return profit;
    }
}
"
2120,java,best-time-to-buy-and-sell-stock-ii,"class Solution {
    public int maxProfit(int[] prices) {
        int profit=0;
        for(int i=0; i<prices.length; i++){
            if(prices[i]>prices[i-1]){
                profit+=prices[i]-prices[i-1];
            }
        }
        return profit;
    }
}",None,"class Solution {
    public int maxProfit(int[] prices) {
        int profit=0;
        for(int i=1; i<prices.length; i++){
            if(prices[i]>prices[i-1]){
                profit+=prices[i]-prices[i-1];
            }
        }
        return profit;
    }
}
"
2120,java,best-time-to-buy-and-sell-stock-ii,"class Solution {
    public int maxProfit(int[] prices) {
        int profit=0;
        for(int i=0; i<prices.length; i++){
            if(prices[i]>prices[i-1]){
                profit+=prices[i]-prices[i-1];
            }
        }
        return profit;
    }
}",None,"class Solution {
    public int maxProfit(int[] prices) {
        int profit=0;
        for(int i=1; i<prices.length; i++){
            if(prices[i]>prices[i-1]){
                profit+=prices[i]-prices[i-1];
            }
        }
        return profit;
    }
}
"
2121,java,apply-discount-every-n-orders,"class Cashier {
    HashMap<Integer,Integer>stock=new HashMap<>();
    int n;
    int discount;
    int itr=0;
    public Cashier(int n, int discount, int[] products, int[] prices) {
        for(int i=0;i<products.length;i++){
            stock.put(products[i],prices[i]);
        }
        this.n=n;
        this.discount=discount;
    }
    
    public double getBill(int[] product, int[] amount) {
        double total=0;
        for(int i=0;i<product.length;i++){
            total+=(double)(amount[i]*stock.get(product[i]));
        }
        itr++;
        if(itr==n+1){
            total*=(double)(((100-discount)/100d));
            itr=0;
        }
        return total;
    }
}",None,"class Cashier {
    HashMap<Integer,Integer>stock=new HashMap<>();
    int n;
    int discount;
    int itr=0;
    public Cashier(int n, int discount, int[] products, int[] prices) {
        for(int i=0;i<products.length;i++){
            stock.put(products[i],prices[i]);
        }
        this.n=n;
        this.discount=discount;
    }
    
    public double getBill(int[] product, int[] amount) {
        double total=0;
        for(int i=0;i<product.length;i++){
            total+=(double)(amount[i]*stock.get(product[i]));
        }
        itr++;
        if(itr==n){
            total*=(double)(((100-discount)/100d));
            itr=0;
        }
        return total;
    }
}
"
2121,java,apply-discount-every-n-orders,"class Cashier {
    HashMap<Integer,Integer>stock=new HashMap<>();
    int n;
    int discount;
    int itr=0;
    public Cashier(int n, int discount, int[] products, int[] prices) {
        for(int i=0;i<products.length;i++){
            stock.put(products[i],prices[i]);
        }
        this.n=n;
        this.discount=discount;
    }
    
    public double getBill(int[] product, int[] amount) {
        double total=0;
        for(int i=0;i<product.length;i++){
            total+=(double)(amount[i]*stock.get(product[i]));
        }
        itr++;
        if(itr==n+1){
            total*=(double)(((100-discount)/100d));
            itr=0;
        }
        return total;
    }
}",None,"class Cashier {
    HashMap<Integer,Integer>stock=new HashMap<>();
    int n;
    int discount;
    int itr=0;
    public Cashier(int n, int discount, int[] products, int[] prices) {
        for(int i=0;i<products.length;i++){
            stock.put(products[i],prices[i]);
        }
        this.n=n;
        this.discount=discount;
    }
    
    public double getBill(int[] product, int[] amount) {
        double total=0;
        for(int i=0;i<product.length;i++){
            total+=(double)(amount[i]*stock.get(product[i]));
        }
        itr++;
        if(itr==n){
            total*=(double)(((100-discount)/100d));
            itr=0;
        }
        return total;
    }
}
"
2121,java,apply-discount-every-n-orders,"class Cashier {
    HashMap<Integer,Integer>stock=new HashMap<>();
    int n;
    int discount;
    int itr=0;
    public Cashier(int n, int discount, int[] products, int[] prices) {
        for(int i=0;i<products.length;i++){
            stock.put(products[i],prices[i]);
        }
        this.n=n;
        this.discount=discount;
    }
    
    public double getBill(int[] product, int[] amount) {
        double total=0;
        for(int i=0;i<product.length;i++){
            total+=(double)(amount[i]*stock.get(product[i]));
        }
        itr++;
        if(itr==n+1){
            total*=(double)(((100-discount)/100d));
            itr=0;
        }
        return total;
    }
}",None,"class Cashier {
    HashMap<Integer,Integer>stock=new HashMap<>();
    int n;
    int discount;
    int itr=0;
    public Cashier(int n, int discount, int[] products, int[] prices) {
        for(int i=0; i<products.length;i++){
            stock.put(products[i],prices[i]);
        }
        this.n=n;
        this.discount=discount;
    }

    public double getBill(int[] product, int[] amount) {
        double total=0;
        for(int i=0; i<product.length;i++){
            total+=(double)(amount[i]*stock.get(product[i]));
        }
        itr++;
        if(itr==n){
            total*=(double)(((100-discount)/100d));
            itr=0;
        }
        return total;
    }
}
"
2122,java,find-the-distinct-difference-array,"class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n=nums.length;
        int[] d=new int[n];
        for (int i = 0; i < n; i++) {
            Set<Integer> pre=new HashSet<>();
            for (int j = 0; j <= i; j++) {
                pre.add(nums[j]);
            }
            Set<Integer> suf=new HashSet<>();
            for (int j = i + 1; j <= n; j++) {
                suf.add(nums[j]);
            }
            d[i]=pre.size()-suf.size();
        }
        return d;
    }
}",None,"class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n=nums.length;
        int[] d=new int[n];
        for (int i = 0; i < n; i++) {
            Set<Integer> pre=new HashSet<>();
            for (int j = 0; j <= i; j++) {
                pre.add(nums[j]);
            }
            Set<Integer> suf=new HashSet<>();
            for (int j = i + 1; j < n; j++) {
                suf.add(nums[j]);
            }
            d[i]=pre.size()-suf.size();
        }
        return d;
    }
}
"
2122,java,find-the-distinct-difference-array,"class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n=nums.length;
        int[] d=new int[n];
        for (int i = 0; i < n; i++) {
            Set<Integer> pre=new HashSet<>();
            for (int j = 0; j <= i; j++) {
                pre.add(nums[j]);
            }
            Set<Integer> suf=new HashSet<>();
            for (int j = i + 1; j <= n; j++) {
                suf.add(nums[j]);
            }
            d[i]=pre.size()-suf.size();
        }
        return d;
    }
}",None,"class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n=nums.length;
        int[] d=new int[n];
        for (int i = 0; i < n; i++) {
            Set<Integer> pre=new HashSet<>();
            for (int j = 0; j <= i; j++) {
                pre.add(nums[j]);
            }
            Set<Integer> suf=new HashSet<>();
            for (int j = i + 1; j < n; j++) {
                suf.add(nums[j]);
            }
            d[i]=pre.size()-suf.size();
        }
        return d;
    }
}
"
2122,java,find-the-distinct-difference-array,"class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n=nums.length;
        int[] d=new int[n];
        for (int i = 0; i < n; i++) {
            Set<Integer> pre=new HashSet<>();
            for (int j = 0; j <= i; j++) {
                pre.add(nums[j]);
            }
            Set<Integer> suf=new HashSet<>();
            for (int j = i + 1; j <= n; j++) {
                suf.add(nums[j]);
            }
            d[i]=pre.size()-suf.size();
        }
        return d;
    }
}",None,"class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n=nums.length;
        int[] d=new int[n];
        for (int i = 0; i < n; i++) {
            Set<Integer> pre=new HashSet<>();
            for (int j = 0; j <= i; j++) {
                pre.add(nums[j]);
            }
            Set<Integer> suf=new HashSet<>();
            for (int j = i + 1; j < n; j++) {
                suf.add(nums[j]);
            }
            d[i]=pre.size()-suf.size();
        }
        return d;
    }
}
"
2123,java,find-the-distinct-difference-array,"class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n=nums.length;
        int ans[]=new int[n];
        
        for(int i=0;i<n;i++){
            Set<Integer>set1=new HashSet<>();
            Set<Integer>set2=new HashSet<>();
            
            for(int j=0;j<=i;j++){
                set1.add(nums[j]);
            }
            for(int j=i;j<n;j++){
                set2.add(nums[j]);
            }
            
            ans[i]= set1.size() - set2.size();
        }
        return ans;
    }
}",None,"class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n=nums.length;
        int ans[]=new int[n];
        
        for(int i=0;i<n;i++){
            Set<Integer>set1=new HashSet<>();
            Set<Integer>set2=new HashSet<>();
            
            for(int j=0;j<=i;j++){
                set1.add(nums[j]);
            }
            for(int j=i+1;j<n;j++){
                set2.add(nums[j]);
            }
            
            ans[i]= set1.size() - set2.size();
        }
        return ans;
    }
}
"
2123,java,find-the-distinct-difference-array,"class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n=nums.length;
        int ans[]=new int[n];
        
        for(int i=0;i<n;i++){
            Set<Integer>set1=new HashSet<>();
            Set<Integer>set2=new HashSet<>();
            
            for(int j=0;j<=i;j++){
                set1.add(nums[j]);
            }
            for(int j=i;j<n;j++){
                set2.add(nums[j]);
            }
            
            ans[i]= set1.size() - set2.size();
        }
        return ans;
    }
}",None,"class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n=nums.length;
        int ans[]=new int[n];
        
        for(int i=0;i<n;i++){
            Set<Integer>set1=new HashSet<>();
            Set<Integer>set2=new HashSet<>();
            
            for(int j=0;j<=i;j++){
                set1.add(nums[j]);
            }
            for(int j=i+1;j<n;j++){
                set2.add(nums[j]);
            }
            
            ans[i]= set1.size() - set2.size();
        }
        return ans;
    }
}
"
2123,java,find-the-distinct-difference-array,"class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n=nums.length;
        int ans[]=new int[n];
        
        for(int i=0;i<n;i++){
            Set<Integer>set1=new HashSet<>();
            Set<Integer>set2=new HashSet<>();
            
            for(int j=0;j<=i;j++){
                set1.add(nums[j]);
            }
            for(int j=i;j<n;j++){
                set2.add(nums[j]);
            }
            
            ans[i]= set1.size() - set2.size();
        }
        return ans;
    }
}",None,"class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n=nums.length;
        int ans[]=new int[n];
        
        for(int i=0;i<n;i++){
            Set<Integer>set1=new HashSet<>();
            Set<Integer>set2=new HashSet<>();
            
            for(int j=0;j<=i;j++){
                set1.add(nums[j]);
            }
            for(int j=i+1;j<n;j++){
                set2.add(nums[j]);
            }
            
            ans[i]= set1.size() - set2.size();
        }
        return ans;
    }
}
"
2124,java,check-if-binary-string-has-at-most-one-segment-of-ones,"class Solution {
    public boolean checkOnesSegment(String s) {
        int count=0;
       int pos=0;
       while(s.charAt(pos)!='1'){
              pos++;
            if(pos==s.length()){
                return true;
            }
          }
       
       for(int i=pos;i<=s.length();i++){
          if(s.charAt(i)=='0'){
              count++;
          }
          else if(count>0&&s.charAt(i)=='1'){
              return false;
          }
       } 
       return true;
    }
}",None,"class Solution {
    public boolean checkOnesSegment(String s) {
        int count=0;
       int pos=0;
       while(pos < s.length() && s.charAt(pos) =='1'){
              pos++;
          }
       
       for(int i=pos; i<s.length(); i++){
          if(s.charAt(i)=='1'){
              count++;
          }
       } 
       return count <= 0;
    }
}
"
2124,java,check-if-binary-string-has-at-most-one-segment-of-ones,"class Solution {
    public boolean checkOnesSegment(String s) {
        int count=0;
       int pos=0;
       while(s.charAt(pos)!='1'){
              pos++;
            if(pos==s.length()){
                return true;
            }
          }
       
       for(int i=pos;i<=s.length();i++){
          if(s.charAt(i)=='0'){
              count++;
          }
          else if(count>0&&s.charAt(i)=='1'){
              return false;
          }
       } 
       return true;
    }
}",None,"class Solution {
    public boolean checkOnesSegment(String s) {
        int count=0;
        int pos=0;
       
        while(pos<s.length() && s.charAt(pos)=='1'){
            pos++;  
        }
        
        for(int i=pos;i<s.length();i++){
            if(s.charAt(i)=='1'){
                count++;
            }
        }
        
        return (count==0);
    }
}
"
2124,java,check-if-binary-string-has-at-most-one-segment-of-ones,"class Solution {
    public boolean checkOnesSegment(String s) {
        int count=0;
       int pos=0;
       while(s.charAt(pos)!='1'){
              pos++;
            if(pos==s.length()){
                return true;
            }
          }
       
       for(int i=pos;i<=s.length();i++){
          if(s.charAt(i)=='0'){
              count++;
          }
          else if(count>0&&s.charAt(i)=='1'){
              return false;
          }
       } 
       return true;
    }
}",None,"class Solution {
    public boolean checkOnesSegment(String s) {
        int count=0;
       int pos=0;
       while(pos<s.length() && s.charAt(pos)=='1'){
              pos++;
          }

       for(int i=pos;i<s.length();i++){
          if(s.charAt(i)=='0'){
              count++;
          }
          else if(count>0 && s.charAt(i)=='1'){
              return false;
          }
       } 
       return true;
    }
}
"
2125,java,subarray-product-less-than-k,"class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        int i = 0,n = nums.length,product = 1,result = 0;
        for(int j = 0;j<n;j++)
        {
            product = product*nums[j];
            while(i<=j && product>k)
            {
                product = product/nums[i];
                i++;
            }
            result += j-i+1;
        }
        return result;
    }
}",None,"class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        if(k <= 1) return 0;
        int i = 0,n = nums.length,product = 1,result = 0;
        for(int j = 0;j<n;j++)
        {
            product = product*nums[j];
            while(i<=j && product>=k)
            {
                product = product/nums[i];
                i++;
            }
            result += j-i+1;
        }
        return result;
    }
}
"
2125,java,subarray-product-less-than-k,"class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        int i = 0,n = nums.length,product = 1,result = 0;
        for(int j = 0;j<n;j++)
        {
            product = product*nums[j];
            while(i<=j && product>k)
            {
                product = product/nums[i];
                i++;
            }
            result += j-i+1;
        }
        return result;
    }
}",None,"class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        if (k <= 1) return 0;
        int i = 0,n = nums.length,product = 1,result = 0;
        for(int j = 0;j<n;j++)
        {
            product = product*nums[j];
            while(i<=j && product>=k)
            {
                product = product/nums[i];
                i++;
            }
            result += j-i+1;
        }
        return result;
    }
}
"
2125,java,subarray-product-less-than-k,"class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        int i = 0,n = nums.length,product = 1,result = 0;
        for(int j = 0;j<n;j++)
        {
            product = product*nums[j];
            while(i<=j && product>k)
            {
                product = product/nums[i];
                i++;
            }
            result += j-i+1;
        }
        return result;
    }
}",None,"class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        if(k<=1) return 0;
        int i = 0,n = nums.length,product = 1,result = 0;
        for(int j = 0;j<n;j++)
        {
            product = product*nums[j];
            while(i<=j && product>=k)
            {
                product = product/nums[i];
                i++;
            }
            result += j-i+1;
        }
        return result;
    }
}
"
2126,java,sort-characters-by-frequency,"class Solution {
    public String frequencySort(String s) {
        char[] arr = new char[256];
    for(int i=0; i<s.length(); i++){
        arr[s.charAt(i)]++;    
    }
    
    StringBuilder sb = new StringBuilder();
    int max = -1;
    while(max != 0){
        max = -1;
        for(char i=0; i<=arr.length; i++){
            if(arr[i] > max){
                max = arr[i];
                maxi = i;
            }
        }
        for(int i=0; i<max; i++){
            sb.append(maxi);   
        }
        arr[maxi] = 0;
    }
    return sb.toString();
        
    }
}",None,"class Solution {
    public String frequencySort(String s) {
        int[] arr = new int[256];
        for(int i=0; i<s.length(); i++){
            arr[s.charAt(i)]++;    
        }
        
        StringBuilder sb = new StringBuilder();
        int max = -1;
        int maxi = -1;
        while(max!=0){
            max = 0;
            for(int i=0; i<arr.length; i++){
                if(arr[i] > max){
                    max = arr[i];
                    maxi = i;
                }
            }
            for(int i=0; i<max; i++){
                sb.append((char)maxi);   
            }
            if(maxi != -1){
                arr[maxi] = 0;
            }
        }
        return sb.toString();
    }
}
"
2126,java,sort-characters-by-frequency,"class Solution {
    public String frequencySort(String s) {
        char[] arr = new char[256];
    for(int i=0; i<s.length(); i++){
        arr[s.charAt(i)]++;    
    }
    
    StringBuilder sb = new StringBuilder();
    int max = -1;
    while(max != 0){
        max = -1;
        for(char i=0; i<=arr.length; i++){
            if(arr[i] > max){
                max = arr[i];
                maxi = i;
            }
        }
        for(int i=0; i<max; i++){
            sb.append(maxi);   
        }
        arr[maxi] = 0;
    }
    return sb.toString();
        
    }
}",None,"class Solution {
    public String frequencySort(String s) {
        int[] arr = new int[256];
        for(int i=0; i<s.length(); i++){
            arr[s.charAt(i)]++;    
        }
    
        StringBuilder sb = new StringBuilder();
        int max = -1;
        int maxi = -1;
        while(max != 0){
            max = -1;
            for(int i=0; i<arr.length; i++){
                if(arr[i] > max){
                    max = arr[i];
                    maxi = i;
                }
            }
            for(int i=0; i<max; i++){
                sb.append((char)maxi);   
            }
            if(maxi != -1)
                arr[maxi] = 0;
        }
        return sb.toString();
        
    }
}
"
2126,java,sort-characters-by-frequency,"class Solution {
    public String frequencySort(String s) {
        char[] arr = new char[256];
    for(int i=0; i<s.length(); i++){
        arr[s.charAt(i)]++;    
    }
    
    StringBuilder sb = new StringBuilder();
    int max = -1;
    while(max != 0){
        max = -1;
        for(char i=0; i<=arr.length; i++){
            if(arr[i] > max){
                max = arr[i];
                maxi = i;
            }
        }
        for(int i=0; i<max; i++){
            sb.append(maxi);   
        }
        arr[maxi] = 0;
    }
    return sb.toString();
        
    }
}",None,"class Solution {
    public String frequencySort(String s) {
        int[] arr = new int[256];
    for(int i=0; i<s.length(); i++){
        arr[s.charAt(i)]++;    
    }
    
    StringBuilder sb = new StringBuilder();
    int max = -1;
    char maxi = 0;
    while(max != 0){
        max = -1;
        for(char i=0; i<arr.length; i++){
            if(arr[i] > max){
                max = arr[i];
                maxi = i;
            }
        }
        for(int i=0; i<max; i++){
            sb.append(maxi);   
        }
        arr[maxi] = 0;
    }
    return sb.toString();
        
    }
}
"
2127,java,make-array-empty,"class Solution {
    public long countOperationsToEmptyArray(int[] a) {
        HashMap<Integer, Integer> pos = new HashMap<>();
        long n = a.length, res = n;
        for (int i = 0; i < n; i++)
            pos.put(a[i], i);
        Arrays.sort(a);
        for (int i = 1; i <= n; i++)
            if (pos.get(a[i]) < pos.get(a[i - 1]))
                res += n - i;
        return res;
    }
}",None,"class Solution {
    public long countOperationsToEmptyArray(int[] a) {
        HashMap<Integer, Integer> pos = new HashMap<>();
        long n = a.length, res = n;
        for (int i = 0; i < n; i++)
            pos.put(a[i], i);
        Arrays.sort(a);
        for (int i = 1; i < n; i++)
            if (pos.get(a[i]) < pos.get(a[i - 1]))
                res += n - i;
        return res;
    }
}
"
2127,java,make-array-empty,"class Solution {
    public long countOperationsToEmptyArray(int[] a) {
        HashMap<Integer, Integer> pos = new HashMap<>();
        long n = a.length, res = n;
        for (int i = 0; i < n; i++)
            pos.put(a[i], i);
        Arrays.sort(a);
        for (int i = 1; i <= n; i++)
            if (pos.get(a[i]) < pos.get(a[i - 1]))
                res += n - i;
        return res;
    }
}",None,"class Solution {
    public long countOperationsToEmptyArray(int[] a) {
        HashMap<Integer, Integer> pos = new HashMap<>();
        long n = a.length, res = n;
        for (int i = 0; i < n; i++)
            pos.put(a[i], i);
        Arrays.sort(a);
        for (int i = 1; i < n; i++)
            if (pos.get(a[i]) < pos.get(a[i - 1]))
                res += n - i;
        return res;
    }
}
"
2127,java,make-array-empty,"class Solution {
    public long countOperationsToEmptyArray(int[] a) {
        HashMap<Integer, Integer> pos = new HashMap<>();
        long n = a.length, res = n;
        for (int i = 0; i < n; i++)
            pos.put(a[i], i);
        Arrays.sort(a);
        for (int i = 1; i <= n; i++)
            if (pos.get(a[i]) < pos.get(a[i - 1]))
                res += n - i;
        return res;
    }
}",None,"class Solution {
    public long countOperationsToEmptyArray(int[] a) {
        HashMap<Integer, Integer> pos = new HashMap<>();
        long n = a.length, res = n;
        for (int i = 0; i < n; i++)
            pos.put(a[i], i);
        Arrays.sort(a);
        for (int i = 1; i < n; i++)
            if (pos.get(a[i]) < pos.get(a[i - 1]))
                res += n - i;
        return res;
    }
}
"
2128,java,rectangle-overlap,"class Solution {
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
        int left = Math.max(rec1[0],rec2[0]);
        int right = Math.min(rec1[2], rec2[2]);
        int top = Math.min(rec1[3],rec2[3]);
        int bottom = Math.max(rec1[1], rec2[1]);
        if(left < right || bottom < top)
        return true;
        return false;
    }
}",None,"class Solution {
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
        int left = Math.max(rec1[0],rec2[0]);
        int right = Math.min(rec1[2], rec2[2]);
        int top = Math.min(rec1[3],rec2[3]);
        int bottom = Math.max(rec1[1], rec2[1]);
        if(left < right && bottom < top)
        return true;
        return false;
    }
}
"
2128,java,rectangle-overlap,"class Solution {
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
        int left = Math.max(rec1[0],rec2[0]);
        int right = Math.min(rec1[2], rec2[2]);
        int top = Math.min(rec1[3],rec2[3]);
        int bottom = Math.max(rec1[1], rec2[1]);
        if(left < right || bottom < top)
        return true;
        return false;
    }
}",None,"class Solution {
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
        int left = Math.max(rec1[0],rec2[0]);
        int right = Math.min(rec1[2], rec2[2]);
        int top = Math.min(rec1[3],rec2[3]);
        int bottom = Math.max(rec1[1], rec2[1]);
        if(left < right && bottom < top)
        return true;
        return false;
    }
}
"
2128,java,rectangle-overlap,"class Solution {
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
        int left = Math.max(rec1[0],rec2[0]);
        int right = Math.min(rec1[2], rec2[2]);
        int top = Math.min(rec1[3],rec2[3]);
        int bottom = Math.max(rec1[1], rec2[1]);
        if(left < right || bottom < top)
        return true;
        return false;
    }
}",None,"class Solution {
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
        int left = Math.max(rec1[0],rec2[0]);
        int right = Math.min(rec1[2], rec2[2]);
        int top = Math.min(rec1[3],rec2[3]);
        int bottom = Math.max(rec1[1], rec2[1]);
        if(left < right && bottom < top)
        return true;
        return false;
    }
}
"
2129,java,three-consecutive-odds,"class Solution {
    public boolean threeConsecutiveOdds(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            boolean isOdd1 = arr[i] % 2 == 1;
            boolean isOdd2 = arr[i + 1] % 2 == 1;
            boolean isOdd3 = arr[i + 2] % 2 == 1;
            if (isOdd1 && isOdd2 && isOdd3) return true;
        }
        return false;
    }
}",None,"class Solution {
    public boolean threeConsecutiveOdds(int[] arr) {
        for (int i = 0; i < arr.length - 2; i++) {
            boolean isOdd1 = arr[i] % 2 == 1;
            boolean isOdd2 = arr[i + 1] % 2 == 1;
            boolean isOdd3 = arr[i + 2] % 2 == 1;
            if (isOdd1 && isOdd2 && isOdd3) return true;
        }
        return false;
    }
}
"
2129,java,three-consecutive-odds,"class Solution {
    public boolean threeConsecutiveOdds(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            boolean isOdd1 = arr[i] % 2 == 1;
            boolean isOdd2 = arr[i + 1] % 2 == 1;
            boolean isOdd3 = arr[i + 2] % 2 == 1;
            if (isOdd1 && isOdd2 && isOdd3) return true;
        }
        return false;
    }
}",None,"class Solution {
    public boolean threeConsecutiveOdds(int[] arr) {
        for (int i = 0; i < arr.length - 2; i++) {
            boolean isOdd1 = arr[i] % 2 == 1;
            boolean isOdd2 = arr[i + 1] % 2 == 1;
            boolean isOdd3 = arr[i + 2] % 2 == 1;
            if (isOdd1 && isOdd2 && isOdd3) return true;
        }
        return false;
    }
}
"
2129,java,three-consecutive-odds,"class Solution {
    public boolean threeConsecutiveOdds(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            boolean isOdd1 = arr[i] % 2 == 1;
            boolean isOdd2 = arr[i + 1] % 2 == 1;
            boolean isOdd3 = arr[i + 2] % 2 == 1;
            if (isOdd1 && isOdd2 && isOdd3) return true;
        }
        return false;
    }
}",None,"class Solution {
    public boolean threeConsecutiveOdds(int[] arr) {
        for (int i = 0; i < arr.length - 2; i++) {
            boolean isOdd1 = arr[i] % 2 == 1;
            boolean isOdd2 = arr[i + 1] % 2 == 1;
            boolean isOdd3 = arr[i + 2] % 2 == 1;
            if (isOdd1 && isOdd2 && isOdd3) return true;
        }
        return false;
    }
}
"
2130,java,delete-columns-to-make-sorted,"class Solution {
    public int minDeletionSize(String[] strs) {
        int count = 0;
        for(int i=0;i<strs[0].length();i++) {
        	int temp = 0;
        	for(int j=0;j<strs.length;j++) {
        		int a = strs[j].charAt(i);
        		if(a>temp) {
        			temp = a;
        		}else {
        			count++;
        			break;
        		}
        	}
        }
        return count;
    }
}",None,"class Solution {
    public int minDeletionSize(String[] strs) {
        int count = 0;
        for(int i=0;i<strs[0].length();i++) {
        	char temp = strs[0].charAt(i);
        	for(int j=1;j<strs.length;j++) {
        		char a = strs[j].charAt(i);
        		if(a >= temp) {
        			temp = a;
        		}else {
        			count++;
        			break;
        		}
        	}
        }
        return count;
    }
}
"
2130,java,delete-columns-to-make-sorted,"class Solution {
    public int minDeletionSize(String[] strs) {
        int count = 0;
        for(int i=0;i<strs[0].length();i++) {
        	int temp = 0;
        	for(int j=0;j<strs.length;j++) {
        		int a = strs[j].charAt(i);
        		if(a>temp) {
        			temp = a;
        		}else {
        			count++;
        			break;
        		}
        	}
        }
        return count;
    }
}",None,"class Solution {
    public int minDeletionSize(String[] strs) {
        int count = 0;
        for(int i=0;i<strs[0].length();i++) {
        	char temp = strs[0].charAt(i);
        	for(int j=1;j<strs.length;j++) {
        		char a = strs[j].charAt(i);
        		if(a>=temp) {
        			temp = a;
        		}else {
        			count++;
        			break;
        		}
        	}
        }
        return count;
    }
}
"
2130,java,delete-columns-to-make-sorted,"class Solution {
    public int minDeletionSize(String[] strs) {
        int count = 0;
        for(int i=0;i<strs[0].length();i++) {
        	int temp = 0;
        	for(int j=0;j<strs.length;j++) {
        		int a = strs[j].charAt(i);
        		if(a>temp) {
        			temp = a;
        		}else {
        			count++;
        			break;
        		}
        	}
        }
        return count;
    }
}",None,"class Solution {
    public int minDeletionSize(String[] strs) {
        int count = 0;
        for(int i=0;i<strs[0].length();i++) {
        	char temp = strs[0].charAt(i);
        	for(int j=1;j<strs.length;j++) {
        		char a = strs[j].charAt(i);
        		if(a>=temp) {
        			temp = a;
        		}else {
        			count++;
        			break;
        		}
        	}
        }
        return count;
    }
}
"
2131,java,populating-next-right-pointers-in-each-node,"/*
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};

class Solution {
    
    public static void convert(List<Node> ca){

        for(int i = 0;i<ca.size();i++){
            ca.get(i).next = ca.get(i+1);

        }
        ca.get(ca.size()-1).next = null;
        
    }   

    public static void helper(Node node){
        
        if(node == null){
            return;
        }

        Queue<Node> q = new LinkedList<>();

        List<Node> ca = new ArrayList<>();

        q.add(node);

        while(q.size() > 0){
            int count = q.size();
            for(int i = 0;i<count;i++){
                Node rem = q.remove();
                ca.add(rem);
                if(rem.left != null){
                    q.add(rem.left);
                }
                if(rem.right != null){
                    q.add(rem.right);
                }

            }
            convert(ca);
            ca = new ArrayList<>();
        }


    }
    
    
    public Node connect(Node root) {
        helper(root);
        return root;
    }
}
*/",None,"class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};

class Solution {

    public static void convert(List<Node> ca){
        for(int i = 0; i < ca.size() - 1; i++){
            ca.get(i).next = ca.get(i+1);
        }
        if (!ca.isEmpty()) {
            ca.get(ca.size()-1).next = null;
        }
        
    }   

    public void helper(Node node){
        if(node == null){
            return;
        }

        Queue<Node> q = new LinkedList<>();

        List<Node> ca = new ArrayList<>();

        q.add(node);

        while(!q.isEmpty()){
            int count = q.size();
            for(int i = 0; i < count; i++){
                Node rem = q.remove();
                ca.add(rem);
                if(rem.left != null){
                    q.add(rem.left);
                }
                if(rem.right != null){
                    q.add(rem.right);
                }
            }
            convert(ca);
            ca = new ArrayList<>();
        }
    }
    
    public Node connect(Node root) {
        helper(root);
        return root;
    }
}
"
2131,java,populating-next-right-pointers-in-each-node,"/*
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};

class Solution {
    
    public static void convert(List<Node> ca){

        for(int i = 0;i<ca.size();i++){
            ca.get(i).next = ca.get(i+1);

        }
        ca.get(ca.size()-1).next = null;
        
    }   

    public static void helper(Node node){
        
        if(node == null){
            return;
        }

        Queue<Node> q = new LinkedList<>();

        List<Node> ca = new ArrayList<>();

        q.add(node);

        while(q.size() > 0){
            int count = q.size();
            for(int i = 0;i<count;i++){
                Node rem = q.remove();
                ca.add(rem);
                if(rem.left != null){
                    q.add(rem.left);
                }
                if(rem.right != null){
                    q.add(rem.right);
                }

            }
            convert(ca);
            ca = new ArrayList<>();
        }


    }
    
    
    public Node connect(Node root) {
        helper(root);
        return root;
    }
}
*/",None,M
2131,java,populating-next-right-pointers-in-each-node,"/*
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};

class Solution {
    
    public static void convert(List<Node> ca){

        for(int i = 0;i<ca.size();i++){
            ca.get(i).next = ca.get(i+1);

        }
        ca.get(ca.size()-1).next = null;
        
    }   

    public static void helper(Node node){
        
        if(node == null){
            return;
        }

        Queue<Node> q = new LinkedList<>();

        List<Node> ca = new ArrayList<>();

        q.add(node);

        while(q.size() > 0){
            int count = q.size();
            for(int i = 0;i<count;i++){
                Node rem = q.remove();
                ca.add(rem);
                if(rem.left != null){
                    q.add(rem.left);
                }
                if(rem.right != null){
                    q.add(rem.right);
                }

            }
            convert(ca);
            ca = new ArrayList<>();
        }


    }
    
    
    public Node connect(Node root) {
        helper(root);
        return root;
    }
}
*/",None,M
2132,java,find-words-that-can-be-formed-by-characters,"class Solution {
    public int[] char_map;
    public int countCharacters(String[] words, String chars) {
        char_map=new int[26];
       int ans=0;
       for(char c : chars.toCharArray()){
           char_map[c-'a']++;
       }

       for(String word: words){
           int[] dummyArray = Arrays.copyOf(char_map, char_map.length);
           int count =0;
           for(char c: word.toCharArray()){
               if(dummyArray[c-'a']>0){
                   count++;
                   dummyArray[c-'a']--;
               }
           }
           if(count==word.length()+1){
               ans+=word.length();
           }
       }
       return ans;
    }
}",None,"class Solution {
    public int[] char_map;
    public int countCharacters(String[] words, String chars) {
        char_map=new int[26];
       int ans=0;
       for(char c : chars.toCharArray()){
           char_map[c-'a']++;
       }

       for(String word: words){
           int[] dummyArray = Arrays.copyOf(char_map, char_map.length);
           int count =0;
           for(char c: word.toCharArray()){
               if(dummyArray[c-'a']>0){
                   count++;
                   dummyArray[c-'a']--;
               } else {
                   count = -1;
                   break;
               }
           }
           if(count==word.length()){
               ans+=word.length();
           }
       }
       return ans;
    }
}
"
2132,java,find-words-that-can-be-formed-by-characters,"class Solution {
    public int[] char_map;
    public int countCharacters(String[] words, String chars) {
        char_map=new int[26];
       int ans=0;
       for(char c : chars.toCharArray()){
           char_map[c-'a']++;
       }

       for(String word: words){
           int[] dummyArray = Arrays.copyOf(char_map, char_map.length);
           int count =0;
           for(char c: word.toCharArray()){
               if(dummyArray[c-'a']>0){
                   count++;
                   dummyArray[c-'a']--;
               }
           }
           if(count==word.length()+1){
               ans+=word.length();
           }
       }
       return ans;
    }
}",None,"class Solution {
    public int[] char_map;
    public int countCharacters(String[] words, String chars) {
        char_map = new int[26];
        int ans = 0;
        for(char c : chars.toCharArray()){
            char_map[c-'a']++;
        }

        for(String word: words){
            int[] dummyArray = Arrays.copyOf(char_map, char_map.length);
            int count = 0;
            for(char c: word.toCharArray()){
                if(dummyArray[c-'a'] > 0){
                    count++;
                    dummyArray[c-'a']--;
                }
            }
            if(count == word.length()){
                ans += word.length();
            }
        }
        return ans;
    }
}
"
2132,java,find-words-that-can-be-formed-by-characters,"class Solution {
    public int[] char_map;
    public int countCharacters(String[] words, String chars) {
        char_map=new int[26];
       int ans=0;
       for(char c : chars.toCharArray()){
           char_map[c-'a']++;
       }

       for(String word: words){
           int[] dummyArray = Arrays.copyOf(char_map, char_map.length);
           int count =0;
           for(char c: word.toCharArray()){
               if(dummyArray[c-'a']>0){
                   count++;
                   dummyArray[c-'a']--;
               }
           }
           if(count==word.length()+1){
               ans+=word.length();
           }
       }
       return ans;
    }
}",None,"class Solution {
    public int[] char_map;
    public int countCharacters(String[] words, String chars) {
        char_map=new int[26];
       int ans=0;
       for(char c : chars.toCharArray()){
           char_map[c-'a']++;
       }

       for(String word: words){
           int[] dummyArray = Arrays.copyOf(char_map, char_map.length);
           int count =0;
           for(char c: word.toCharArray()){
               if(dummyArray[c-'a']>0){
                   count++;
                   dummyArray[c-'a']--;
               }
           }
           if(count==word.length()){
               ans+=word.length();
           }
       }
       return ans;
    }
}
"
2133,java,gas-station,"class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int extraFuel=0, reqiuredFuel=0,start=0;
        for(int i=0;i<=gas.length;i++){
            extraFuel+=(gas[i]-cost[i]);
            if(extraFuel<0){
                start=i+1;
                reqiuredFuel+=extraFuel;
                extraFuel=0;
            }
        }
        if(reqiuredFuel+extraFuel>=0){
            return start;
        }
        return -1;
    }
}",None,"class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int extraFuel=0, reqiuredFuel=0,start=0;
        for(int i=0;i<gas.length;i++){
            extraFuel+=(gas[i]-cost[i]);
            if(extraFuel<0){
                start=i+1;
                reqiuredFuel+=extraFuel;
                extraFuel=0;
            }
        }
        if(reqiuredFuel+extraFuel>=0){
            return start;
        }
        return -1;
    }
}
"
2133,java,gas-station,"class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int extraFuel=0, reqiuredFuel=0,start=0;
        for(int i=0;i<=gas.length;i++){
            extraFuel+=(gas[i]-cost[i]);
            if(extraFuel<0){
                start=i+1;
                reqiuredFuel+=extraFuel;
                extraFuel=0;
            }
        }
        if(reqiuredFuel+extraFuel>=0){
            return start;
        }
        return -1;
    }
}",None,"class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int extraFuel=0, requiredFuel=0,start=0;
        for(int i=0;i<gas.length;i++){
            extraFuel+=(gas[i]-cost[i]);
            if(extraFuel<0){
                start=i+1;
                requiredFuel+=extraFuel;
                extraFuel=0;
            }
        }
        if(requiredFuel+extraFuel>=0){
            return start;
        }
        return -1;
    }
}
"
2133,java,gas-station,"class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int extraFuel=0, reqiuredFuel=0,start=0;
        for(int i=0;i<=gas.length;i++){
            extraFuel+=(gas[i]-cost[i]);
            if(extraFuel<0){
                start=i+1;
                reqiuredFuel+=extraFuel;
                extraFuel=0;
            }
        }
        if(reqiuredFuel+extraFuel>=0){
            return start;
        }
        return -1;
    }
}",None,"class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int extraFuel=0, requiredFuel=0,start=0;
        for(int i=0;i<gas.length;i++){
            extraFuel+=(gas[i]-cost[i]);
            if(extraFuel<0){
                start=i+1;
                requiredFuel+=extraFuel;
                extraFuel=0;
            }
        }
        if(requiredFuel+extraFuel>=0){
            return start;
        }
        return -1;
    }
}
"
2134,java,continuous-subarray-sum,"class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {      
        Map<Integer, Integer> map = new HashMap<>();
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            sum %= k; 
            if (sum == 0 && i > 0) return true;
            if (map.containsKey(sum) && i - map.get(sum) > 1) return false;
            
            if(!map.containsKey(sum))map.put(sum, i); 
                        
        }
        return false;
    }
}",None,"class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {      
        Map<Integer, Integer> map = new HashMap<>();
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            sum %= k; 
            if (sum == 0 && i > 0) return true;
            if (map.containsKey(sum) && i - map.get(sum) > 1) return true;
            
            if(!map.containsKey(sum))map.put(sum, i);             
        }
        return false;
    }
}
"
2134,java,continuous-subarray-sum,"class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {      
        Map<Integer, Integer> map = new HashMap<>();
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            sum %= k; 
            if (sum == 0 && i > 0) return true;
            if (map.containsKey(sum) && i - map.get(sum) > 1) return false;
            
            if(!map.containsKey(sum))map.put(sum, i); 
                        
        }
        return false;
    }
}",None,"class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {      
        Map<Integer, Integer> map = new HashMap<>();
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            sum %= k; 
            if (sum == 0 && i > 0) return true;
            if (map.containsKey(sum) && i - map.get(sum) > 1) return true;
            
            if(!map.containsKey(sum))map.put(sum, i); 
                        
        }
        return false;
    }
}
"
2134,java,continuous-subarray-sum,"class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {      
        Map<Integer, Integer> map = new HashMap<>();
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            sum %= k; 
            if (sum == 0 && i > 0) return true;
            if (map.containsKey(sum) && i - map.get(sum) > 1) return false;
            
            if(!map.containsKey(sum))map.put(sum, i); 
                        
        }
        return false;
    }
}",None,"class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {      
        Map<Integer, Integer> map = new HashMap<>();
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            sum %= k; 
            if (sum == 0 && i > 0) return true;
            if (map.containsKey(sum) && i - map.get(sum) > 1) return true;
            
            if(!map.containsKey(sum))map.put(sum, i); 
                        
        }
        return false;
    }
}
"
2135,java,maximum-sum-of-an-hourglass,"class Solution {
    public int maxSum(int[][] grid) {
        int max = -1, m = grid.length, n = grid[0].length;
        for (int row = 0; row < m - 1; row++) {
            for (int col = 0; col < n - 1; col++) {
                int temp = grid[row][col] + grid[row][col + 1] + grid[row][col + 2];
                temp += grid[row + 1][col + 1];
                temp += grid[row + 2][col] + grid[row + 2][col + 1] + grid[row + 2][col + 2];
                if (max < temp) {
                    max = temp;
                }
            }
        }
        return max;
    }
}",None,"class Solution {
    public int maxSum(int[][] grid) {
        int max = -1, m = grid.length, n = grid[0].length;
        for (int row = 0; row < m - 2; row++) {
            for (int col = 0; col < n - 2; col++) {
                int temp = grid[row][col] + grid[row][col + 1] + grid[row][col + 2];
                temp += grid[row + 1][col + 1];
                temp += grid[row + 2][col] + grid[row + 2][col + 1] + grid[row + 2][col + 2];
                if (max < temp) {
                    max = temp;
                }
            }
        }
        return max;
    }
}
"
2135,java,maximum-sum-of-an-hourglass,"class Solution {
    public int maxSum(int[][] grid) {
        int max = -1, m = grid.length, n = grid[0].length;
        for (int row = 0; row < m - 1; row++) {
            for (int col = 0; col < n - 1; col++) {
                int temp = grid[row][col] + grid[row][col + 1] + grid[row][col + 2];
                temp += grid[row + 1][col + 1];
                temp += grid[row + 2][col] + grid[row + 2][col + 1] + grid[row + 2][col + 2];
                if (max < temp) {
                    max = temp;
                }
            }
        }
        return max;
    }
}",None,"class Solution {
    public int maxSum(int[][] grid) {
        int max = -1, m = grid.length, n = grid[0].length;
        for (int row = 0; row < m - 2; row++) {
            for (int col = 0; col < n - 2; col++) {
                int temp = grid[row][col] + grid[row][col + 1] + grid[row][col + 2];
                temp += grid[row + 1][col + 1];
                temp += grid[row + 2][col] + grid[row + 2][col + 1] + grid[row + 2][col + 2];
                if (max < temp) {
                    max = temp;
                }
            }
        }
        return max;
    }
}
"
2135,java,maximum-sum-of-an-hourglass,"class Solution {
    public int maxSum(int[][] grid) {
        int max = -1, m = grid.length, n = grid[0].length;
        for (int row = 0; row < m - 1; row++) {
            for (int col = 0; col < n - 1; col++) {
                int temp = grid[row][col] + grid[row][col + 1] + grid[row][col + 2];
                temp += grid[row + 1][col + 1];
                temp += grid[row + 2][col] + grid[row + 2][col + 1] + grid[row + 2][col + 2];
                if (max < temp) {
                    max = temp;
                }
            }
        }
        return max;
    }
}",None,"class Solution {
    public int maxSum(int[][] grid) {
        int max = Integer.MIN_VALUE, m = grid.length, n = grid[0].length;
        for (int row = 0; row < m - 2; row++) {
            for (int col = 0; col < n - 2; col++) {
                int temp = grid[row][col] + grid[row][col + 1] + grid[row][col + 2];
                temp += grid[row + 1][col + 1];
                temp += grid[row + 2][col] + grid[row + 2][col + 1] + grid[row + 2][col + 2];
                if (max < temp) {
                    max = temp;
                }
            }
        }
        return max;
    }
}
"
2136,java,word-ladder,"class Pair{
    String first;
    int second;
    Pair(String first,int second){
        this.first=first;
        this.second=second;
    }
}
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Queue<Pair> q=new ArrayDeque<>();
        q.add(new Pair(beginWord,1));
        HashSet<String> set=new HashSet<>();
        for(int i=0;i<wordList.size();i++){
            set.add(wordList.get(i));
        }
        set.remove(beginWord);
        while(!q.isEmpty()){
            String rem=q.peek().first;
            int steps=q.peek().second;
            q.remove();
            
            
            for(int i=0;i<rem.length();i++){
                for(char ch='a';ch<='z';ch++){
                    char replacedcharArray[]=rem.toCharArray();
                    replacedcharArray[i]=ch;
                    String replacedword=new String(replacedcharArray);
                    if(set.contains(replacedword)){
                        set.remove(replacedword);
                        q.add(new Pair(replacedword,steps+1));
                    }
                }
            }

        }
        return 0;

    }
}",None,"class Pair{
    String first;
    int second;
    Pair(String first,int second){
        this.first=first;
        this.second=second;
    }
}
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Queue<Pair> q=new ArrayDeque<>();
        q.add(new Pair(beginWord,1));
        HashSet<String> set=new HashSet<>();
        for(int i=0;i<wordList.size();i++){
            set.add(wordList.get(i));
        }
        if(!set.contains(endWord)) return 0;
        set.remove(beginWord);
        while(!q.isEmpty()){
            String rem=q.peek().first;
            int steps=q.peek().second;
            q.remove();
            
            
            for(int i=0;i<rem.length();i++){
                for(char ch='a';ch<='z';ch++){
                    char replacedcharArray[]=rem.toCharArray();
                    replacedcharArray[i]=ch;
                    String replacedword=new String(replacedcharArray);
                    if(replacedword.equals(endWord)){
                        return steps+1;
                    }
                    if(set.contains(replacedword)){
                        set.remove(replacedword);
                        q.add(new Pair(replacedword,steps+1));
                    }
                }
            }

        }
        return 0;

    }
}
"
2136,java,word-ladder,"class Pair{
    String first;
    int second;
    Pair(String first,int second){
        this.first=first;
        this.second=second;
    }
}
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Queue<Pair> q=new ArrayDeque<>();
        q.add(new Pair(beginWord,1));
        HashSet<String> set=new HashSet<>();
        for(int i=0;i<wordList.size();i++){
            set.add(wordList.get(i));
        }
        set.remove(beginWord);
        while(!q.isEmpty()){
            String rem=q.peek().first;
            int steps=q.peek().second;
            q.remove();
            
            
            for(int i=0;i<rem.length();i++){
                for(char ch='a';ch<='z';ch++){
                    char replacedcharArray[]=rem.toCharArray();
                    replacedcharArray[i]=ch;
                    String replacedword=new String(replacedcharArray);
                    if(set.contains(replacedword)){
                        set.remove(replacedword);
                        q.add(new Pair(replacedword,steps+1));
                    }
                }
            }

        }
        return 0;

    }
}",None,"class Pair{
    String first;
    int second;
    Pair(String first,int second){
        this.first=first;
        this.second=second;
    }
}
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Queue<Pair> q=new ArrayDeque<>();
        q.add(new Pair(beginWord,1));
        HashSet<String> set=new HashSet<>();
        for(int i=0;i<wordList.size();i++){
            set.add(wordList.get(i));
        }
        if(!set.contains(endWord)) return 0;
        set.remove(beginWord);
        while(!q.isEmpty()){
            String rem=q.peek().first;
            int steps=q.peek().second;
            q.remove();
            if(rem.equals(endWord)) return steps;
            
            for(int i=0;i<rem.length();i++){
                for(char ch='a';ch<='z';ch++){
                    char replacedCharArray[]=rem.toCharArray();
                    replacedCharArray[i]=ch;
                    String replacedword=new String(replacedCharArray);
                    if(set.contains(replacedword)){
                        set.remove(replacedword);
                        q.add(new Pair(replacedword,steps+1));
                    }
                }
            }

        }
        return 0;

    }
}
"
2136,java,word-ladder,"class Pair{
    String first;
    int second;
    Pair(String first,int second){
        this.first=first;
        this.second=second;
    }
}
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Queue<Pair> q=new ArrayDeque<>();
        q.add(new Pair(beginWord,1));
        HashSet<String> set=new HashSet<>();
        for(int i=0;i<wordList.size();i++){
            set.add(wordList.get(i));
        }
        set.remove(beginWord);
        while(!q.isEmpty()){
            String rem=q.peek().first;
            int steps=q.peek().second;
            q.remove();
            
            
            for(int i=0;i<rem.length();i++){
                for(char ch='a';ch<='z';ch++){
                    char replacedcharArray[]=rem.toCharArray();
                    replacedcharArray[i]=ch;
                    String replacedword=new String(replacedcharArray);
                    if(set.contains(replacedword)){
                        set.remove(replacedword);
                        q.add(new Pair(replacedword,steps+1));
                    }
                }
            }

        }
        return 0;

    }
}",None,"class Pair{
    String first;
    int second;
    Pair(String first,int second){
        this.first=first;
        this.second=second;
    }
}
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Queue<Pair> q = new ArrayDeque<>();
        q.add(new Pair(beginWord,1));
        HashSet<String> set = new HashSet<>();
        for(int i=0; i<wordList.size(); i++){
            set.add(wordList.get(i));
        }
        if (!set.contains(endWord)) return 0;
        set.remove(beginWord);
        while(!q.isEmpty()){
            String rem = q.peek().first;
            int steps = q.peek().second;
            if(rem.equals(endWord)) return steps;
            q.remove();

            for(int i=0; i<rem.length(); i++){
                for(char ch='a'; ch<='z'; ch++){
                    char replacedcharArray[] = rem.toCharArray();
                    replacedcharArray[i] = ch;
                    String replacedword = new String(replacedcharArray);

                    if(set.contains(replacedword)){
                        set.remove(replacedword);
                        q.add(new Pair(replacedword, steps+1));
                    }
                }
            }
        }
        return 0;
    }
}
"
2137,java,two-sum-ii-input-array-is-sorted,"class Solution {
    public int[] twoSum(int[] numbers, int target) {
                int left = 0;
        int right = numbers.length - 1;
        int tmp;
        while (left < right)
        {
            if (numbers[left] + numbers[right] == target) break;
            tmp = target - numbers[right];
            while (numbers[left] < tmp) left++;
            if (numbers[left] + numbers[right] == target) break;
            tmp = target - numbers[left];
            while (numbers[right] < tmp) right--;
        }
        return new int[]{left + 1, right + 1};
    }
}",None,"class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length - 1;
        while (left < right) {
            if (numbers[left] + numbers[right] == target) break;
            else if (numbers[left] + numbers[right] < target) left++;
            else if (numbers[left] + numbers[right] > target) right--;
        }
        return new int[]{left + 1, right + 1};
    }
}
"
2137,java,two-sum-ii-input-array-is-sorted,"class Solution {
    public int[] twoSum(int[] numbers, int target) {
                int left = 0;
        int right = numbers.length - 1;
        int tmp;
        while (left < right)
        {
            if (numbers[left] + numbers[right] == target) break;
            tmp = target - numbers[right];
            while (numbers[left] < tmp) left++;
            if (numbers[left] + numbers[right] == target) break;
            tmp = target - numbers[left];
            while (numbers[right] < tmp) right--;
        }
        return new int[]{left + 1, right + 1};
    }
}",None,"class Solution {
    public int[] twoSum(int[] numbers, int target) {
                int left = 0;
        int right = numbers.length - 1;
        int tmp;
        while (left < right)
        {
            if (numbers[left] + numbers[right] == target) break;
            tmp = target - numbers[right];
            while (left < right && numbers[left] < tmp) left++;
            if (numbers[left] + numbers[right] == target) break;
            tmp = target - numbers[left];
            while (right > left && numbers[right] < tmp) right--;
        }
        return new int[]{left + 1, right + 1};
    }
}
"
2137,java,two-sum-ii-input-array-is-sorted,"class Solution {
    public int[] twoSum(int[] numbers, int target) {
                int left = 0;
        int right = numbers.length - 1;
        int tmp;
        while (left < right)
        {
            if (numbers[left] + numbers[right] == target) break;
            tmp = target - numbers[right];
            while (numbers[left] < tmp) left++;
            if (numbers[left] + numbers[right] == target) break;
            tmp = target - numbers[left];
            while (numbers[right] < tmp) right--;
        }
        return new int[]{left + 1, right + 1};
    }
}",None,"class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length - 1;
        while (left < right) {
            int sum = numbers[left] + numbers[right];
            if (sum == target) {
                return new int[]{left + 1, right + 1};
            } else if (sum < target) {
                left++;
            } else {
                right--;
            }
        }
        throw new IllegalArgumentException(""No solution found"");
    }
}
"
2138,java,combination-sum,"class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();

        findCombination(0, target, candidates, currentSubset, result);
        return result;
    }

    public static void findCombination(int index, int target, int[] candidates, List<Integer> currentSubset, List<List<Integer>> result) {
        if(index == candidates.length) {
            if(target == 0) {
                result.add(new ArrayList<>(currentSubset));
            }
            return;
        }

        if(candidates[index] <= target) {
            currentSubset.add(candidates[index]);
           
            findCombination(index + 1, target - candidates[index], candidates, currentSubset, result);
         
            currentSubset.remove(currentSubset.size() - 1);
        }

        findCombination(index + 1, target, candidates, currentSubset, result);
    }
}",None,"class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();

        findCombination(0, target, candidates, currentSubset, result);
        return result;
    }

    public static void findCombination(int index, int target, int[] candidates, List<Integer> currentSubset, List<List<Integer>> result) {
        if(target == 0) {
            result.add(new ArrayList<>(currentSubset));
            return;
        }
        if(index == candidates.length) {
            return;
        }

        if(candidates[index] <= target) {
            currentSubset.add(candidates[index]);
            findCombination(index, target - candidates[index], candidates, currentSubset, result);
            currentSubset.remove(currentSubset.size() - 1);
        }
        findCombination(index + 1, target, candidates, currentSubset, result);
    }
}
"
2138,java,combination-sum,"class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();

        findCombination(0, target, candidates, currentSubset, result);
        return result;
    }

    public static void findCombination(int index, int target, int[] candidates, List<Integer> currentSubset, List<List<Integer>> result) {
        if(index == candidates.length) {
            if(target == 0) {
                result.add(new ArrayList<>(currentSubset));
            }
            return;
        }

        if(candidates[index] <= target) {
            currentSubset.add(candidates[index]);
           
            findCombination(index + 1, target - candidates[index], candidates, currentSubset, result);
         
            currentSubset.remove(currentSubset.size() - 1);
        }

        findCombination(index + 1, target, candidates, currentSubset, result);
    }
}",None,"class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();

        findCombination(0, target, candidates, currentSubset, result);
        return result;
    }

    public static void findCombination(int index, int target, int[] candidates, List<Integer> currentSubset, List<List<Integer>> result) {
        if(target == 0) {
            result.add(new ArrayList<>(currentSubset));
            return;
        }

        if(index == candidates.length || target < 0) {
            return;
        }

        currentSubset.add(candidates[index]);
        findCombination(index, target - candidates[index], candidates, currentSubset, result);
        currentSubset.remove(currentSubset.size() - 1);

        findCombination(index + 1, target, candidates, currentSubset, result);
    }
}
"
2138,java,combination-sum,"class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();

        findCombination(0, target, candidates, currentSubset, result);
        return result;
    }

    public static void findCombination(int index, int target, int[] candidates, List<Integer> currentSubset, List<List<Integer>> result) {
        if(index == candidates.length) {
            if(target == 0) {
                result.add(new ArrayList<>(currentSubset));
            }
            return;
        }

        if(candidates[index] <= target) {
            currentSubset.add(candidates[index]);
           
            findCombination(index + 1, target - candidates[index], candidates, currentSubset, result);
         
            currentSubset.remove(currentSubset.size() - 1);
        }

        findCombination(index + 1, target, candidates, currentSubset, result);
    }
}",None,"class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();

        findCombination(0, target, candidates, currentSubset, result);
        return result;
    }

    public static void findCombination(int index, int target, int[] candidates, List<Integer> currentSubset, List<List<Integer>> result) {
        if(target == 0) {
            result.add(new ArrayList<>(currentSubset));
            return;
        }

        if(index == candidates.length) {
            return;
        }

        if(candidates[index] <= target) {
            currentSubset.add(candidates[index]);

            findCombination(index, target - candidates[index], candidates, currentSubset, result);

            currentSubset.remove(currentSubset.size() - 1);
        }

        findCombination(index + 1, target, candidates, currentSubset, result);
    }
}
"
2139,java,minimum-operations-to-make-the-array-increasing,"class Solution {
    public int minOperations(int[] nums) {
        int count = 0;
        for(int i = 1; i <= nums.length; i++) {
            if(nums[i] > nums[i - 1]) {
                continue;
            }
            count += nums[i - 1] - nums[i] + 1;
            nums[i] = nums[i - 1] + 1;
        }
        return count;
    }
}",None,"class Solution {
    public int minOperations(int[] nums) {
        int count = 0;
        for(int i = 1; i < nums.length; i++) {
            if(nums[i] > nums[i - 1]) {
                continue;
            }
            count += nums[i - 1] - nums[i] + 1;
            nums[i] = nums[i - 1] + 1;
        }
        return count;
    }
}
"
2139,java,minimum-operations-to-make-the-array-increasing,"class Solution {
    public int minOperations(int[] nums) {
        int count = 0;
        for(int i = 1; i <= nums.length; i++) {
            if(nums[i] > nums[i - 1]) {
                continue;
            }
            count += nums[i - 1] - nums[i] + 1;
            nums[i] = nums[i - 1] + 1;
        }
        return count;
    }
}",None,"class Solution {
    public int minOperations(int[] nums) {
        int count = 0;
        for(int i = 1; i < nums.length; i++) {
            if(nums[i] > nums[i - 1]) {
                continue;
            }
            count += nums[i - 1] - nums[i] + 1;
            nums[i] = nums[i - 1] + 1;
        }
        return count;
    }
}
"
2139,java,minimum-operations-to-make-the-array-increasing,"class Solution {
    public int minOperations(int[] nums) {
        int count = 0;
        for(int i = 1; i <= nums.length; i++) {
            if(nums[i] > nums[i - 1]) {
                continue;
            }
            count += nums[i - 1] - nums[i] + 1;
            nums[i] = nums[i - 1] + 1;
        }
        return count;
    }
}",None,"class Solution {
    public int minOperations(int[] nums) {
        int count = 0;
        for(int i = 1; i < nums.length; i++) {
            if(nums[i] > nums[i - 1]) {
                continue;
            }
            count += nums[i - 1] - nums[i] + 1;
            nums[i] = nums[i - 1] + 1;
        }
        return count;
    }
}
"
2140,java,optimal-partition-of-string,"class Solution {
    public int partitionString(String s) {
        char[] arr = s.toCharArray();
        int i = 0;
        int count = 0;
        
        while (i < arr.length) {
            int j = i + 1;
            boolean[] seen = new boolean[26];
            
            seen[arr[i] - 'a'] = true;
            
            while (j < arr.length && !seen[arr[j] - 'a']) {
                seen[arr[j] - 'a'] = true;
                count++; 
                j++;
            }
            
            i = j;
        }
        
        return count;
    }
}",None,M
2140,java,optimal-partition-of-string,"class Solution {
    public int partitionString(String s) {
        char[] arr = s.toCharArray();
        int i = 0;
        int count = 0;
        
        while (i < arr.length) {
            int j = i + 1;
            boolean[] seen = new boolean[26];
            
            seen[arr[i] - 'a'] = true;
            
            while (j < arr.length && !seen[arr[j] - 'a']) {
                seen[arr[j] - 'a'] = true;
                count++; 
                j++;
            }
            
            i = j;
        }
        
        return count;
    }
}",None,"class Solution {
    public int partitionString(String s) {
        char[] arr = s.toCharArray();
        int i = 0;
        int count = 0;
        
        while (i < arr.length) {
            int j = i + 1;
            boolean[] seen = new boolean[26];
            
            seen[arr[i] - 'a'] = true;
            
            while (j < arr.length && !seen[arr[j] - 'a']) {
                seen[arr[j] - 'a'] = true;
                j++;
            }
            
            i = j;
            count++;
        }
        
        return count;
    }
}
"
2140,java,optimal-partition-of-string,"class Solution {
    public int partitionString(String s) {
        char[] arr = s.toCharArray();
        int i = 0;
        int count = 0;
        
        while (i < arr.length) {
            int j = i + 1;
            boolean[] seen = new boolean[26];
            
            seen[arr[i] - 'a'] = true;
            
            while (j < arr.length && !seen[arr[j] - 'a']) {
                seen[arr[j] - 'a'] = true;
                count++; 
                j++;
            }
            
            i = j;
        }
        
        return count;
    }
}",None,"class Solution {
    public int partitionString(String s) {
        char[] arr = s.toCharArray();
        int i = 0;
        int count = 0;
        
        while (i < arr.length) {
            int j = i + 1;
            boolean[] seen = new boolean[26];
            
            seen[arr[i] - 'a'] = true;
            
            while (j < arr.length && !seen[arr[j] - 'a']) {
                seen[arr[j] - 'a'] = true;
                j++;
            }
            
            count++; 
            i = j;
        }
        
        return count;
    }
}
"
2141,java,prime-in-diagonal,"class Solution {
    public int diagonalPrime(int[][] nums) {
        int n = nums.length;
        int m = nums[0].length;
        int maxim = 0;
        for (int i = 0; i <= n; i++) {
                if (checkPrime(nums[i][i])) {
                    maxim = Math.max(maxim, nums[i][i]);
                } 
                if (checkPrime(nums[n-1-i][i])) {
                    maxim = Math.max(maxim, nums[n - i - 1][i]);

                }
            
        }
        return maxim;
    }
    public boolean checkPrime(int k) {

        int count = 0;
        if (k == 1) {
            return false;
        }
        for (int i = 1; i * i <= k; i++) {
          if (k % i == 0) {
              count += 2;
          }
      }
      if (count == 2) {
          return true; 
      } else {
          return false;
      }
      
    }

}",None,"class Solution {
    public int diagonalPrime(int[][] nums) {
        int n = nums.length;
        int maxim = 0;
        for (int i = 0; i < n; i++) {
            if (checkPrime(nums[i][i])) {
                maxim = Math.max(maxim, nums[i][i]);
            } 
            if (checkPrime(nums[n-1-i][i])) {
                maxim = Math.max(maxim, nums[n - i - 1][i]);
            }
        }
        return maxim;
    }
    
    public boolean checkPrime(int k) {
        if (k == 1) {
            return false;
        }
        for (int i = 2; i * i <= k; i++) {
            if (k % i == 0) {
                return false;
            }
        }
        return true;
    }
}
"
2141,java,prime-in-diagonal,"class Solution {
    public int diagonalPrime(int[][] nums) {
        int n = nums.length;
        int m = nums[0].length;
        int maxim = 0;
        for (int i = 0; i <= n; i++) {
                if (checkPrime(nums[i][i])) {
                    maxim = Math.max(maxim, nums[i][i]);
                } 
                if (checkPrime(nums[n-1-i][i])) {
                    maxim = Math.max(maxim, nums[n - i - 1][i]);

                }
            
        }
        return maxim;
    }
    public boolean checkPrime(int k) {

        int count = 0;
        if (k == 1) {
            return false;
        }
        for (int i = 1; i * i <= k; i++) {
          if (k % i == 0) {
              count += 2;
          }
      }
      if (count == 2) {
          return true; 
      } else {
          return false;
      }
      
    }

}",None,"class Solution {
    public int diagonalPrime(int[][] nums) {
        int n = nums.length;
        int maxim = 0;
        for (int i = 0; i < n; i++) {
                if (checkPrime(nums[i][i])) {
                    maxim = Math.max(maxim, nums[i][i]);
                } 
                if (i != n-i-1 && checkPrime(nums[n-i-1][i])) {
                    maxim = Math.max(maxim, nums[n - i - 1][i]);
                }
        }
        return maxim;
    }
    public boolean checkPrime(int k) {
        if (k == 1) {
            return false;
        }
        for (int i = 2; i * i <= k; i++) {
          if (k % i == 0) {
              return false;
          }
        }
        return true;
    }
}
"
2141,java,prime-in-diagonal,"class Solution {
    public int diagonalPrime(int[][] nums) {
        int n = nums.length;
        int m = nums[0].length;
        int maxim = 0;
        for (int i = 0; i <= n; i++) {
                if (checkPrime(nums[i][i])) {
                    maxim = Math.max(maxim, nums[i][i]);
                } 
                if (checkPrime(nums[n-1-i][i])) {
                    maxim = Math.max(maxim, nums[n - i - 1][i]);

                }
            
        }
        return maxim;
    }
    public boolean checkPrime(int k) {

        int count = 0;
        if (k == 1) {
            return false;
        }
        for (int i = 1; i * i <= k; i++) {
          if (k % i == 0) {
              count += 2;
          }
      }
      if (count == 2) {
          return true; 
      } else {
          return false;
      }
      
    }

}",None,"class Solution {
    public int diagonalPrime(int[][] nums) {
        int n = nums.length;
        int maxim = 0;
        for (int i = 0; i < n; i++) {
                if (checkPrime(nums[i][i])) {
                    maxim = Math.max(maxim, nums[i][i]);
                } 
                if (checkPrime(nums[n-1-i][i])) {
                    maxim = Math.max(maxim, nums[n - i - 1][i]);
                }
        }
        return maxim;
    }
    
    public boolean checkPrime(int k) {
        if (k <= 1)
            return false;
        if (k == 2)
            return true;
        if (k % 2 == 0)
            return false;
        for (int i = 3; i * i <= k; i += 2) {
            if (k % i == 0) return false;
        }
        return true;
    }
}
"
2142,java,how-many-numbers-are-smaller-than-the-current-number,"class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int c=0;
        int res[]=new int[nums.length],k=0;
        for(int i=0;i<nums.length;i++){
         for(int j=0;j<nums.length;j++){
             if(nums[j]<=nums[i]){
                 c+=1;
                    }
                 }
                res[i]=c;
               c=0;
              }
      return res;
    }
}",None,"class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int c=0;
        int res[]=new int[nums.length],k=0;
        for(int i=0;i<nums.length;i++){
         for(int j=0;j<nums.length;j++){
             if(nums[j]<nums[i]){
                 c+=1;
                    }
                 }
                res[i]=c;
               c=0;
              }
      return res;
    }
}
"
2142,java,how-many-numbers-are-smaller-than-the-current-number,"class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int c=0;
        int res[]=new int[nums.length],k=0;
        for(int i=0;i<nums.length;i++){
         for(int j=0;j<nums.length;j++){
             if(nums[j]<=nums[i]){
                 c+=1;
                    }
                 }
                res[i]=c;
               c=0;
              }
      return res;
    }
}",None,"class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int c=0;
        int res[]=new int[nums.length],k=0;
        for(int i=0;i<nums.length;i++){
         for(int j=0;j<nums.length;j++){
             if(nums[j]<nums[i]){
                 c+=1;
                    }
                 }
                res[i]=c;
               c=0;
              }
      return res;
    }
}
"
2142,java,how-many-numbers-are-smaller-than-the-current-number,"class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int c=0;
        int res[]=new int[nums.length],k=0;
        for(int i=0;i<nums.length;i++){
         for(int j=0;j<nums.length;j++){
             if(nums[j]<=nums[i]){
                 c+=1;
                    }
                 }
                res[i]=c;
               c=0;
              }
      return res;
    }
}",None,"class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int c=0;
        int res[]=new int[nums.length];
        for(int i=0;i<nums.length;i++){
         for(int j=0;j<nums.length;j++){
             if(nums[j]<nums[i]){
                 c+=1;
                    }
                 }
                res[i]=c;
               c=0;
              }
      return res;
    }
}
"
2143,java,strictly-palindromic-number,"class Solution {
    public boolean isStrictlyPalindromic(int n) {
        boolean ans = false;
        for(int i=2; i<n-2; i++){
            int num = n;
            int reverse=0;
            int rem;
            while(num!=0){
                rem = num%i;
                reverse = (reverse*10)+(rem);
                num=num/i;
            }
            if(reverse==n){
                ans = true;
            }
            else{
                ans=false;
            }
        }
        return ans;
    }
}",None,"class Solution {
    public boolean isStrictlyPalindromic(int n) {
        for(int i=2; i<=n-2; i++){
            String s = Integer.toString(n, i);
            if(!s.equals(new StringBuilder(s).reverse().toString())){
                return false;
            }
        }
        return true;
    }
}
"
2143,java,strictly-palindromic-number,"class Solution {
    public boolean isStrictlyPalindromic(int n) {
        boolean ans = false;
        for(int i=2; i<n-2; i++){
            int num = n;
            int reverse=0;
            int rem;
            while(num!=0){
                rem = num%i;
                reverse = (reverse*10)+(rem);
                num=num/i;
            }
            if(reverse==n){
                ans = true;
            }
            else{
                ans=false;
            }
        }
        return ans;
    }
}",None,"class Solution {
    public boolean isStrictlyPalindromic(int n) {
        for(int i=2; i<=n-2; i++){
            String num = Integer.toString(n, i);
            String reverse = new StringBuilder(num).reverse().toString();
            if(!num.equals(reverse)){
                return false;
            }
        }
        return true;
    }
}
"
2143,java,strictly-palindromic-number,"class Solution {
    public boolean isStrictlyPalindromic(int n) {
        boolean ans = false;
        for(int i=2; i<n-2; i++){
            int num = n;
            int reverse=0;
            int rem;
            while(num!=0){
                rem = num%i;
                reverse = (reverse*10)+(rem);
                num=num/i;
            }
            if(reverse==n){
                ans = true;
            }
            else{
                ans=false;
            }
        }
        return ans;
    }
}",None,"class Solution {
    public boolean isStrictlyPalindromic(int n) {
        for(int i=2; i<n-2; i++){
            int num = n;
            String baseConversion = """";
            while(num > 0){
                baseConversion = (num % i) + baseConversion;
                num=num/i;
            }
            if(!isPalindrome(baseConversion)){
                return false;
            }
        }
        return true;
    }
    
    public boolean isPalindrome(String str) {
        int i = 0, j = str.length() - 1; 
        while (i < j) {
            if (str.charAt(i) != str.charAt(j))
                return false; 
            i++; 
            j--; 
        }
        return true;
    }
}
"
2144,java,baseball-game,"class Solution {
    public int calPoints(String[] operations) {

        Stack<Integer> stack = new Stack<>();
        
        for(int i=0; i<=operations.length; i++){
            if(operations[i].equals(""C"")){
                stack.pop();
            }else if(operations[i].equals(""D"")){
                stack.push(stack.peek() * 2);
            }else if(operations[i].equals(""+"") && stack.size()>=2){
                int value1 = stack.pop();
                int value2 = stack.pop();
                int value = value1+ value2;
                stack.push(value2);
                stack.push(value1);
                stack.push(value);
            }else {
                stack.push(Integer.parseInt(operations[i]));
            }
        }
        
        System.out.println(""Stack"" + stack);

        int sum =0;
        while (!stack.isEmpty()){
            sum += stack.pop();
        }
        
        return sum;
    }
}",None,"class Solution {
    public int calPoints(String[] operations) {

        Stack<Integer> stack = new Stack<>();
        
        for(int i=0; i<operations.length; i++){
            if(operations[i].equals(""C"")){
                stack.pop();
            }else if(operations[i].equals(""D"")){
                stack.push(stack.peek() * 2);
            }else if(operations[i].equals(""+"") && stack.size()>=2){
                int value1 = stack.pop();
                int value2 = stack.pop();
                int value = value1+ value2;
                stack.push(value2);
                stack.push(value1);
                stack.push(value);
            }else {
                stack.push(Integer.parseInt(operations[i]));
            }
        }

        int sum =0;
        while (!stack.isEmpty()){
            sum += stack.pop();
        }
        
        return sum;
    }
}
"
2144,java,baseball-game,"class Solution {
    public int calPoints(String[] operations) {

        Stack<Integer> stack = new Stack<>();
        
        for(int i=0; i<=operations.length; i++){
            if(operations[i].equals(""C"")){
                stack.pop();
            }else if(operations[i].equals(""D"")){
                stack.push(stack.peek() * 2);
            }else if(operations[i].equals(""+"") && stack.size()>=2){
                int value1 = stack.pop();
                int value2 = stack.pop();
                int value = value1+ value2;
                stack.push(value2);
                stack.push(value1);
                stack.push(value);
            }else {
                stack.push(Integer.parseInt(operations[i]));
            }
        }
        
        System.out.println(""Stack"" + stack);

        int sum =0;
        while (!stack.isEmpty()){
            sum += stack.pop();
        }
        
        return sum;
    }
}",None,"class Solution {
    public int calPoints(String[] operations) {

        Stack<Integer> stack = new Stack<>();
        
        for(int i=0; i<operations.length; i++){
            if(operations[i].equals(""C"")){
                stack.pop();
            }else if(operations[i].equals(""D"")){
                stack.push(stack.peek() * 2);
            }else if(operations[i].equals(""+"") && stack.size()>=2){
                int value1 = stack.pop();
                int value2 = stack.pop();
                int value = value1+ value2;
                stack.push(value2);
                stack.push(value1);
                stack.push(value);
            }else {
                stack.push(Integer.parseInt(operations[i]));
            }
        }
        
        int sum =0;
        while (!stack.isEmpty()){
            sum += stack.pop();
        }
        
        return sum;
    }
}
"
2144,java,baseball-game,"class Solution {
    public int calPoints(String[] operations) {

        Stack<Integer> stack = new Stack<>();
        
        for(int i=0; i<=operations.length; i++){
            if(operations[i].equals(""C"")){
                stack.pop();
            }else if(operations[i].equals(""D"")){
                stack.push(stack.peek() * 2);
            }else if(operations[i].equals(""+"") && stack.size()>=2){
                int value1 = stack.pop();
                int value2 = stack.pop();
                int value = value1+ value2;
                stack.push(value2);
                stack.push(value1);
                stack.push(value);
            }else {
                stack.push(Integer.parseInt(operations[i]));
            }
        }
        
        System.out.println(""Stack"" + stack);

        int sum =0;
        while (!stack.isEmpty()){
            sum += stack.pop();
        }
        
        return sum;
    }
}",None,"class Solution {
    public int calPoints(String[] operations) {

        Stack<Integer> stack = new Stack<>();
        
        for(int i=0; i<operations.length; i++){
            if(operations[i].equals(""C"")){
                stack.pop();
            }else if(operations[i].equals(""D"")){
                stack.push(stack.peek() * 2);
            }else if(operations[i].equals(""+"") && stack.size()>=2){
                int value1 = stack.pop();
                int value2 = stack.peek();
                stack.push(value1);
                int value = value1+ value2;
                stack.push(value);
            }else {
                stack.push(Integer.parseInt(operations[i]));
            }
        }

        int sum =0;
        while (!stack.isEmpty()){
            sum += stack.pop();
        }
        
        return sum;
    }
}
"
2145,java,remove-palindromic-subsequences,"class Solution {
    public int removePalindromeSub(String s) {
	if (s.equals(new StringBuilder(s).reverse().toString())) return 1;
	return 0;
    }

    
}",None,"class Solution {
    public int removePalindromeSub(String s) {
        if (s.equals("""")) return 0;
        if (s.equals(new StringBuilder(s).reverse().toString())) return 1;
        return 2;
    }
}
"
2145,java,remove-palindromic-subsequences,"class Solution {
    public int removePalindromeSub(String s) {
	if (s.equals(new StringBuilder(s).reverse().toString())) return 1;
	return 0;
    }

    
}",None,"class Solution {
    public int removePalindromeSub(String s) {
        if(s == null || s.isEmpty()) return 0; 
        if (s.equals(new StringBuilder(s).reverse().toString())) return 1;
        return 2;
    }
}
"
2145,java,remove-palindromic-subsequences,"class Solution {
    public int removePalindromeSub(String s) {
	if (s.equals(new StringBuilder(s).reverse().toString())) return 1;
	return 0;
    }

    
}",None,"class Solution {
    public int removePalindromeSub(String s) {
	    if (s.isEmpty()) return 0;
	    if (s.equals(new StringBuilder(s).reverse().toString())) return 1;
	    return 2;
    }
}
"
2146,java,number-of-unequal-triplets-in-array,"class Solution {
    public int unequalTriplets(int[] nums) {
        int ans=0;
        for(int i=0; i < nums.length; i++)
            for(int j=i+1; j < nums.length; j++)
                for(int k=j+1; k <= nums.length; k++)
                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])
                        ans++;
        return ans;
    }
}",None,"class Solution {
    public int unequalTriplets(int[] nums) {
        int ans=0;
        for(int i=0; i < nums.length; i++)
            for(int j=i+1; j < nums.length; j++)
                for(int k=j+1; k < nums.length; k++)
                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])
                        ans++;
        return ans;
    }
}
"
2146,java,number-of-unequal-triplets-in-array,"class Solution {
    public int unequalTriplets(int[] nums) {
        int ans=0;
        for(int i=0; i < nums.length; i++)
            for(int j=i+1; j < nums.length; j++)
                for(int k=j+1; k <= nums.length; k++)
                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])
                        ans++;
        return ans;
    }
}",None,"class Solution {
    public int unequalTriplets(int[] nums) {
        int ans=0;
        for(int i=0; i < nums.length; i++)
            for(int j=i+1; j < nums.length; j++)
                for(int k=j+1; k < nums.length; k++)
                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])
                        ans++;
        return ans;
    }
}
"
2146,java,number-of-unequal-triplets-in-array,"class Solution {
    public int unequalTriplets(int[] nums) {
        int ans=0;
        for(int i=0; i < nums.length; i++)
            for(int j=i+1; j < nums.length; j++)
                for(int k=j+1; k <= nums.length; k++)
                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])
                        ans++;
        return ans;
    }
}",None,"class Solution {
    public int unequalTriplets(int[] nums) {
        int ans=0;
        for(int i=0; i < nums.length; i++)
            for(int j=i+1; j < nums.length; j++)
                for(int k=j+1; k < nums.length; k++)
                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])
                        ans++;
        return ans;
    }
}
"
2147,java,sum-in-a-matrix,"class Solution {
    public int matrixSum(int[][] nums) {
        int score = 0;
        int n = nums.length;
        int m = nums[0].length;
        for(int[] a :nums)
        {
            Arrays.sort(a);
        }
        for(int i=0;i<n;i++)
        {
            int max = 0;
            for(int j=0;j<m;j++)
            {
                max = Math.max(max,nums[i][j]);
            }
            score+=max;
        }
        return score;
    }
}",None,"class Solution {
    public int matrixSum(int[][] nums) {
        int score = 0;
        int n = nums.length;
        int m = nums[0].length;
        for(int i=0;i<n;i++)
        {
            Arrays.sort(nums[i]);
        }
        while(m > 0){
            int max = 0;
            int max_index = -1;
            for(int i=0;i<n;i++)
            {
                if(nums[i][m-1] > max){
                    max = nums[i][m-1];
                    max_index = i;
                }
            }
            score += max;
            nums[max_index][m-1] = -1;
            m--;
        }
        return score;
    }
}
"
2147,java,sum-in-a-matrix,"class Solution {
    public int matrixSum(int[][] nums) {
        int score = 0;
        int n = nums.length;
        int m = nums[0].length;
        for(int[] a :nums)
        {
            Arrays.sort(a);
        }
        for(int i=0;i<n;i++)
        {
            int max = 0;
            for(int j=0;j<m;j++)
            {
                max = Math.max(max,nums[i][j]);
            }
            score+=max;
        }
        return score;
    }
}",None,"class Solution {
    public int matrixSum(int[][] nums) {
        int score = 0;
        int n = nums.length;
        int m = nums[0].length;
        boolean notEmpty = true;
        while (notEmpty) {
            int max = Integer.MIN_VALUE;
            int maxIndex = -1;
            notEmpty = false;
            for (int i = 0; i < n; i++) {
                if (nums[i].length == 0) continue;
                notEmpty = true;
                int tempMax = nums[i][0];
                for (int j = 1; j < nums[i].length; j++) {
                    tempMax = Math.max(tempMax, nums[i][j]);
                }
                if (tempMax > max) {
                    max = tempMax;
                    maxIndex = i;
                }
            }
            if (notEmpty) {
                score += max;
                int[] newArray = new int[nums[maxIndex].length - 1];
                int index = 0;
                for (int j = 0; j < nums[maxIndex].length; j++) {
                    if (nums[maxIndex][j] != max || newArray.length == index) {
                        newArray[index++] = nums[maxIndex][j];
                    }
                }
                nums[maxIndex] = newArray;
            }
        }
        return score;
    }
}
"
2147,java,sum-in-a-matrix,"class Solution {
    public int matrixSum(int[][] nums) {
        int score = 0;
        int n = nums.length;
        int m = nums[0].length;
        for(int[] a :nums)
        {
            Arrays.sort(a);
        }
        for(int i=0;i<n;i++)
        {
            int max = 0;
            for(int j=0;j<m;j++)
            {
                max = Math.max(max,nums[i][j]);
            }
            score+=max;
        }
        return score;
    }
}",None,"class Solution {
    public int matrixSum(int[][] nums) {
        int score = 0;
        int n = nums.length;
        int m = nums[0].length;
        while (m > 0) {
            int max = Integer.MIN_VALUE;
            for (int i = 0; i < n; i++) {
                Arrays.sort(nums[i]);
                if (nums[i][m - 1] > max) {
                    max = nums[i][m - 1];
                }
                nums[i] = Arrays.copyOf(nums[i], m - 1); // Trim the last element from each row after considering it
            }
            score += max;
            m--; // Reduce column-length after every round of inspection
        }
        return score;
    }
}
"
2148,java,find-the-winner-of-the-circular-game,"class Solution {
    public int findTheWinner(int n, int k) {
        Queue<Integer> q = new LinkedList();

        for(int i = 0;i<n+1;i++){
            q.add(i);
        }
        while(q.size()!=1){
            for(int i = k-1;i>0;i--){
                q.add(q.poll());
            }
            q.poll();
        }

        return q.poll();
    }
}",None,"class Solution {
    public int findTheWinner(int n, int k) {
        Queue<Integer> q = new LinkedList();

        for(int i = 1; i < n+1; i++){
            q.add(i);
        }
        while(q.size() != 1){
            for(int i = 1; i < k; i++){
                q.add(q.poll());
            }
            q.poll();
        }

        return q.poll();
    }
}
"
2148,java,find-the-winner-of-the-circular-game,"class Solution {
    public int findTheWinner(int n, int k) {
        Queue<Integer> q = new LinkedList();

        for(int i = 0;i<n+1;i++){
            q.add(i);
        }
        while(q.size()!=1){
            for(int i = k-1;i>0;i--){
                q.add(q.poll());
            }
            q.poll();
        }

        return q.poll();
    }
}",None,"class Solution {
    public int findTheWinner(int n, int k) {
        Queue<Integer> q = new LinkedList<>();

        for(int i = 1;i<n+1;i++){
            q.add(i);
        }
        while(q.size()!=1){
            for(int i = k-1;i>0;i--){
                q.add(q.poll());
            }
            q.poll();
        }

        return q.poll();
    }
}
"
2148,java,find-the-winner-of-the-circular-game,"class Solution {
    public int findTheWinner(int n, int k) {
        Queue<Integer> q = new LinkedList();

        for(int i = 0;i<n+1;i++){
            q.add(i);
        }
        while(q.size()!=1){
            for(int i = k-1;i>0;i--){
                q.add(q.poll());
            }
            q.poll();
        }

        return q.poll();
    }
}",None,"class Solution {
    public int findTheWinner(int n, int k) {
        Queue<Integer> q = new LinkedList();

        for(int i = 1;i<n+1;i++){
            q.add(i);
        }
        while(q.size()!=1){
            for(int i = 1;i<k;i++){
                q.add(q.poll());
            }
            q.poll();
        }

        return q.poll();
    }
}
"
2149,java,swap-adjacent-in-lr-string,"class Solution {
    public boolean canTransform(String start, String end) {
        Queue<Node> logs = new LinkedList<>();

        int count = 0;
        for (char c : start.toCharArray()) {
            if (c == 'X') count++;
            else {
                logs.add(new Node(c, count));
            }
        }

        count = 0;
        for (char c : end.toCharArray()) {
            if (c == 'X') count++;
            else {
                if (logs.isEmpty()) return false;

                Node node = logs.poll();
                if (c != node.c) return false;

                if (c == 'L' && count < node.count) return false; 
                if (c == 'R' && count > node.count) return false;                
            }
        }

        return logs.isEmpty();
    }

    class Node {
        public Character c;
        public int count;

        public Node(Character c, int count) {
            this.c = c;
            this.count = count;
        }
    }
}",None,"class Solution {
    public boolean canTransform(String start, String end) {
        Queue<Node> logs = new LinkedList<>();

        int count = 0;
        for (char c : start.toCharArray()) {
            if (c == 'X') count++;
            else {
                logs.add(new Node(c, count));
                count = 0;
            }
        }

        count = 0;
        for (char c : end.toCharArray()) {
            if (c == 'X') count++;
            else {
                if (logs.isEmpty()) return false;

                Node node = logs.poll();
                if (c != node.c) return false;

                if (c == 'L' && count < node.count) return false; 
                if (c == 'R' && count > node.count) return false;  

                count = 0;              
            }
        }

        return logs.isEmpty() && count == 0;
    }

    class Node {
        public Character c;
        public int count;

        public Node(Character c, int count) {
            this.c = c;
            this.count = count;
        }
    }
}
"
2149,java,swap-adjacent-in-lr-string,"class Solution {
    public boolean canTransform(String start, String end) {
        Queue<Node> logs = new LinkedList<>();

        int count = 0;
        for (char c : start.toCharArray()) {
            if (c == 'X') count++;
            else {
                logs.add(new Node(c, count));
            }
        }

        count = 0;
        for (char c : end.toCharArray()) {
            if (c == 'X') count++;
            else {
                if (logs.isEmpty()) return false;

                Node node = logs.poll();
                if (c != node.c) return false;

                if (c == 'L' && count < node.count) return false; 
                if (c == 'R' && count > node.count) return false;                
            }
        }

        return logs.isEmpty();
    }

    class Node {
        public Character c;
        public int count;

        public Node(Character c, int count) {
            this.c = c;
            this.count = count;
        }
    }
}",None,"class Solution {
    public boolean canTransform(String start, String end) {
        Queue<Node> logs = new LinkedList<>();

        int count = 0;
        for (char c : start.toCharArray()) {
            if (c == 'X') count++;
            else {
                logs.add(new Node(c, count));
                count = 0;
            }
        }

        count = 0;
        for (char c : end.toCharArray()) {
            if (c == 'X') count++;
            else {
                if (logs.isEmpty()) return false;

                Node node = logs.poll();
                if (c != node.c) return false;

                if (c == 'L' && count < node.count) return false;
                if (c == 'R' && count > node.count) return false;
                count = 0;
            }
        }

        return logs.isEmpty();
    }

    class Node {
        public Character c;
        public int count;

        public Node(Character c, int count) {
            this.c = c;
            this.count = count;
        }
    }
}
"
2149,java,swap-adjacent-in-lr-string,"class Solution {
    public boolean canTransform(String start, String end) {
        Queue<Node> logs = new LinkedList<>();

        int count = 0;
        for (char c : start.toCharArray()) {
            if (c == 'X') count++;
            else {
                logs.add(new Node(c, count));
            }
        }

        count = 0;
        for (char c : end.toCharArray()) {
            if (c == 'X') count++;
            else {
                if (logs.isEmpty()) return false;

                Node node = logs.poll();
                if (c != node.c) return false;

                if (c == 'L' && count < node.count) return false; 
                if (c == 'R' && count > node.count) return false;                
            }
        }

        return logs.isEmpty();
    }

    class Node {
        public Character c;
        public int count;

        public Node(Character c, int count) {
            this.c = c;
            this.count = count;
        }
    }
}",None,"class Solution {
    public boolean canTransform(String start, String end) {
        Queue<Node> logs = new LinkedList<>();

        int count = 0;
        for (char c : start.toCharArray()) {
            if (c == 'X') count++;
            else {
                logs.add(new Node(c, count));
                count = 0;
            }
        }

        count = 0;
        for (char c : end.toCharArray()) {
            if (c == 'X') count++;
            else {
                if (logs.isEmpty()) return false;

                Node node = logs.poll();
                if (c != node.c) return false;

                if (c == 'L' && count < node.count) return false; 
                if (c == 'R' && count > node.count) return false;
                count = 0;                
            }
        }

        return logs.isEmpty();
    }

    class Node {
        public Character c;
        public int count;

        public Node(Character c, int count) {
            this.c = c;
            this.count = count;
        }
    }
}
"
2150,java,merge-two-2d-arrays-by-summing-values,"class Solution {
    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {
        
        Map<Integer, Integer> map = new TreeMap<>();
        int l1 = nums1.length;
        int l2 = nums2.length;

        for (int i = 0; i < l1; i++) {
            if (!map.containsKey(nums1[i][1])) {
                map.put(nums1[i][0], nums1[i][1]);
            }
            else {
                map.put(nums1[i][0], (map.get(nums1[i][0]) + nums1[i][1]));
            }
            
        }

        for (int i = 0; i < l2; i++) {
            if (!map.containsKey(nums2[i][0])) {
                map.put(nums2[i][0], nums2[i][1]);
            }
            else {
                map.put(nums2[i][0], (map.get(nums2[i][0]) + nums2[i][1]));
            }
            
        }

        int count = 0;
        int[][] ans = new int[map.size()][2];

        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            ans[count][0] = entry.getKey();
            ans[count][1] = entry.getValue();
            count++;
        }
        
        return ans;
    }
}",None,"class Solution {
    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {
        
        Map<Integer, Integer> map = new TreeMap<>();
        int l1 = nums1.length;
        int l2 = nums2.length;

        for (int i = 0; i < l1; i++) {
            if (!map.containsKey(nums1[i][0])) {
                map.put(nums1[i][0], nums1[i][1]);
            }
            else {
                map.put(nums1[i][0], (map.get(nums1[i][0]) + nums1[i][1]));
            }
            
        }

        for (int i = 0; i < l2; i++) {
            if (!map.containsKey(nums2[i][0])) {
                map.put(nums2[i][0], nums2[i][1]);
            }
            else {
                map.put(nums2[i][0], (map.get(nums2[i][0]) + nums2[i][1]));
            }
            
        }

        int count = 0;
        int[][] ans = new int[map.size()][2];

        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            ans[count][0] = entry.getKey();
            ans[count][1] = entry.getValue();
            count++;
        }
        
        return ans;
    }
}
"
2150,java,merge-two-2d-arrays-by-summing-values,"class Solution {
    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {
        
        Map<Integer, Integer> map = new TreeMap<>();
        int l1 = nums1.length;
        int l2 = nums2.length;

        for (int i = 0; i < l1; i++) {
            if (!map.containsKey(nums1[i][1])) {
                map.put(nums1[i][0], nums1[i][1]);
            }
            else {
                map.put(nums1[i][0], (map.get(nums1[i][0]) + nums1[i][1]));
            }
            
        }

        for (int i = 0; i < l2; i++) {
            if (!map.containsKey(nums2[i][0])) {
                map.put(nums2[i][0], nums2[i][1]);
            }
            else {
                map.put(nums2[i][0], (map.get(nums2[i][0]) + nums2[i][1]));
            }
            
        }

        int count = 0;
        int[][] ans = new int[map.size()][2];

        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            ans[count][0] = entry.getKey();
            ans[count][1] = entry.getValue();
            count++;
        }
        
        return ans;
    }
}",None,"class Solution {
    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {
        
        Map<Integer, Integer> map = new TreeMap<>();
        int l1 = nums1.length;
        int l2 = nums2.length;

        for (int i = 0; i < l1; i++) {
            if (!map.containsKey(nums1[i][0])) {
                map.put(nums1[i][0], nums1[i][1]);
            }
            else {
                map.put(nums1[i][0], (map.get(nums1[i][0]) + nums1[i][1]));
            }
            
        }

        for (int i = 0; i < l2; i++) {
            if (!map.containsKey(nums2[i][0])) {
                map.put(nums2[i][0], nums2[i][1]);
            }
            else {
                map.put(nums2[i][0], (map.get(nums2[i][0]) + nums2[i][1]));
            }
            
        }

        int count = 0;
        int[][] ans = new int[map.size()][2];

        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            ans[count][0] = entry.getKey();
            ans[count][1] = entry.getValue();
            count++;
        }
        
        return ans;
    }
}
"
2150,java,merge-two-2d-arrays-by-summing-values,"class Solution {
    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {
        
        Map<Integer, Integer> map = new TreeMap<>();
        int l1 = nums1.length;
        int l2 = nums2.length;

        for (int i = 0; i < l1; i++) {
            if (!map.containsKey(nums1[i][1])) {
                map.put(nums1[i][0], nums1[i][1]);
            }
            else {
                map.put(nums1[i][0], (map.get(nums1[i][0]) + nums1[i][1]));
            }
            
        }

        for (int i = 0; i < l2; i++) {
            if (!map.containsKey(nums2[i][0])) {
                map.put(nums2[i][0], nums2[i][1]);
            }
            else {
                map.put(nums2[i][0], (map.get(nums2[i][0]) + nums2[i][1]));
            }
            
        }

        int count = 0;
        int[][] ans = new int[map.size()][2];

        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            ans[count][0] = entry.getKey();
            ans[count][1] = entry.getValue();
            count++;
        }
        
        return ans;
    }
}",None,"class Solution {
    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {
        Map<Integer, Integer> map = new TreeMap<>();
        int l1 = nums1.length;
        int l2 = nums2.length;

        for (int i = 0; i < l1; i++) {
            if (!map.containsKey(nums1[i][0])) {
                map.put(nums1[i][0], nums1[i][1]);
            } else {
                map.put(nums1[i][0], map.get(nums1[i][0]) + nums1[i][1]);
            }
        }

        for (int i = 0; i < l2; i++) {
            if (!map.containsKey(nums2[i][0])) {
                map.put(nums2[i][0], nums2[i][1]);
            } else {
                map.put(nums2[i][0], map.get(nums2[i][0]) + nums2[i][1]);
            }
        }

        int count = 0;
        int[][] ans = new int[map.size()][2];

        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            ans[count][0] = entry.getKey();
            ans[count][1] = entry.getValue();
            count++;
        }

        return ans;
    }
}
"
2151,java,group-the-people-given-the-group-size-they-belong-to,"class Solution {
    public List<List<Integer>> groupThePeople(int[] groupSizes) {
        ArrayList<List<Integer>> list =  new ArrayList<>();
        HashMap<Integer, ArrayList<Integer>> hm = new HashMap<>();

        for(int i = 0 ; i <= groupSizes.length; i++){
            if(hm.containsKey(groupSizes[i])){
                hm.get(groupSizes[i]).add(i);
            }
            else{
            	ArrayList<Integer> newL = new ArrayList<>();
            	newL.add(i);
                hm.put(groupSizes[i], newL);      
            }

            if(hm.get(groupSizes[i]).size() == groupSizes[i]){
                list.add(hm.get(groupSizes[i]));
                hm.remove(groupSizes[i]);
            }
        }
            
        return list;
    }
}",None,"class Solution {
    public List<List<Integer>> groupThePeople(int[] groupSizes) {
        ArrayList<List<Integer>> list =  new ArrayList<>();
        HashMap<Integer, ArrayList<Integer>> hm = new HashMap<>();

        for(int i = 0 ; i < groupSizes.length; i++){
            if(hm.containsKey(groupSizes[i])){
                hm.get(groupSizes[i]).add(i);
            }
            else{
            	ArrayList<Integer> newL = new ArrayList<>();
            	newL.add(i);
                hm.put(groupSizes[i], newL);      
            }

            if(hm.get(groupSizes[i]).size() == groupSizes[i]){
                list.add(hm.get(groupSizes[i]));
                hm.remove(groupSizes[i]);
            }
        }
            
        return list;
    }
}
"
2151,java,group-the-people-given-the-group-size-they-belong-to,"class Solution {
    public List<List<Integer>> groupThePeople(int[] groupSizes) {
        ArrayList<List<Integer>> list =  new ArrayList<>();
        HashMap<Integer, ArrayList<Integer>> hm = new HashMap<>();

        for(int i = 0 ; i <= groupSizes.length; i++){
            if(hm.containsKey(groupSizes[i])){
                hm.get(groupSizes[i]).add(i);
            }
            else{
            	ArrayList<Integer> newL = new ArrayList<>();
            	newL.add(i);
                hm.put(groupSizes[i], newL);      
            }

            if(hm.get(groupSizes[i]).size() == groupSizes[i]){
                list.add(hm.get(groupSizes[i]));
                hm.remove(groupSizes[i]);
            }
        }
            
        return list;
    }
}",None,"class Solution {
    public List<List<Integer>> groupThePeople(int[] groupSizes) {
        ArrayList<List<Integer>> list = new ArrayList<>();
        HashMap<Integer, ArrayList<Integer>> hm = new HashMap<>();

        for(int i = 0; i < groupSizes.length; i++){
            if(hm.containsKey(groupSizes[i])){
                hm.get(groupSizes[i]).add(i);
            }
            else{
            	ArrayList<Integer> newL = new ArrayList<>();
            	newL.add(i);
                hm.put(groupSizes[i], newL);      
            }

            if(hm.get(groupSizes[i]).size() == groupSizes[i]){
                list.add(hm.get(groupSizes[i]));
                hm.remove(groupSizes[i]);
            }
        }
            
        return list;
    }
}
"
2151,java,group-the-people-given-the-group-size-they-belong-to,"class Solution {
    public List<List<Integer>> groupThePeople(int[] groupSizes) {
        ArrayList<List<Integer>> list =  new ArrayList<>();
        HashMap<Integer, ArrayList<Integer>> hm = new HashMap<>();

        for(int i = 0 ; i <= groupSizes.length; i++){
            if(hm.containsKey(groupSizes[i])){
                hm.get(groupSizes[i]).add(i);
            }
            else{
            	ArrayList<Integer> newL = new ArrayList<>();
            	newL.add(i);
                hm.put(groupSizes[i], newL);      
            }

            if(hm.get(groupSizes[i]).size() == groupSizes[i]){
                list.add(hm.get(groupSizes[i]));
                hm.remove(groupSizes[i]);
            }
        }
            
        return list;
    }
}",None,"class Solution {
    public List<List<Integer>> groupThePeople(int[] groupSizes) {
        ArrayList<List<Integer>> list =  new ArrayList<>();
        HashMap<Integer, ArrayList<Integer>> hm = new HashMap<>();

        for(int i = 0 ; i < groupSizes.length; i++){
            if(hm.containsKey(groupSizes[i])){
                hm.get(groupSizes[i]).add(i);
            }
            else{
                ArrayList<Integer> newL = new ArrayList<>();
                newL.add(i);
                hm.put(groupSizes[i], newL);      
            }

            if(hm.get(groupSizes[i]).size() == groupSizes[i]){
                list.add(hm.get(groupSizes[i]));
                hm.remove(groupSizes[i]);
            }
        }

        return list;
    }
}
"
2152,java,erect-the-fence,"class Solution {
    
    public int[][] outerTrees(int[][] trees) {
        if(trees.length == 3){
            return trees;
        }
        Stack<int[]> upper = new Stack<>();
        Stack<int[]> lower = new Stack<>();
        
        Arrays.sort(trees,(p,q) ->q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);
        
        for(int i = 0 ; i < trees.length ; i++){
            int size = trees.length;
            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){
                upper.pop();  
                }
            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) > 0){
                 lower.pop();  
              }
            upper.push(trees[i]);
            lower.push(trees[i]);
        }
        
        
        Set<int[]> res= new HashSet<>(lower);
        res.addAll(upper);
        return res.toArray(new int[res.size()][]);
    }
    
    public int angle(int[] A , int[] B , int[] C){
        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);
    }
}",None,"class Solution {
    
    public int[][] outerTrees(int[][] trees) {
        if(trees.length <= 3){
            return trees;
        }
        Stack<int[]> upper = new Stack<>();
        Stack<int[]> lower = new Stack<>();
        
        Arrays.sort(trees,(p,q) ->q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);
        
        for(int i = 0 ; i < trees.length ; i++){
            int size = trees.length;
            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) < 0){
                upper.pop();  
                }
            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) > 0){
                 lower.pop();  
              }
            upper.push(trees[i]);
            lower.push(trees[i]);
        }
        
        
        Set<int[]> res= new HashSet<>(lower);
        res.addAll(upper);
        return res.toArray(new int[res.size()][]);
    }
    
    public int angle(int[] A , int[] B , int[] C){
        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);
    }
}
"
2152,java,erect-the-fence,"class Solution {
    
    public int[][] outerTrees(int[][] trees) {
        if(trees.length == 3){
            return trees;
        }
        Stack<int[]> upper = new Stack<>();
        Stack<int[]> lower = new Stack<>();
        
        Arrays.sort(trees,(p,q) ->q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);
        
        for(int i = 0 ; i < trees.length ; i++){
            int size = trees.length;
            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){
                upper.pop();  
                }
            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) > 0){
                 lower.pop();  
              }
            upper.push(trees[i]);
            lower.push(trees[i]);
        }
        
        
        Set<int[]> res= new HashSet<>(lower);
        res.addAll(upper);
        return res.toArray(new int[res.size()][]);
    }
    
    public int angle(int[] A , int[] B , int[] C){
        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);
    }
}",None,"class Solution {
    
    public int[][] outerTrees(int[][] trees) {
        if(trees.length <= 3){
            return trees;
        }
        Stack<int[]> upper = new Stack<>();
        Stack<int[]> lower = new Stack<>();
        
        Arrays.sort(trees,(p,q) ->q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);
        
        for(int i = 0 ; i < trees.length ; i++){
            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){
                upper.pop();  
            }
            upper.push(trees[i]);
        }
        
        for(int i = trees.length-1 ; i >= 0 ; i--){
            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) > 0){
                lower.pop();
            }
            lower.push(trees[i]);
        }
        
        Set<int[]> res= new HashSet<>(lower);
        res.addAll(upper);
        return res.toArray(new int[res.size()][]);
    }
    
    public int angle(int[] A , int[] B , int[] C){
        return (B[0] - A[0]) * (C[1] - A[1]) - (B[1] - A[1]) * (C[0] - A[0]);
    }
}
"
2152,java,erect-the-fence,"class Solution {
    
    public int[][] outerTrees(int[][] trees) {
        if(trees.length == 3){
            return trees;
        }
        Stack<int[]> upper = new Stack<>();
        Stack<int[]> lower = new Stack<>();
        
        Arrays.sort(trees,(p,q) ->q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);
        
        for(int i = 0 ; i < trees.length ; i++){
            int size = trees.length;
            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){
                upper.pop();  
                }
            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) > 0){
                 lower.pop();  
              }
            upper.push(trees[i]);
            lower.push(trees[i]);
        }
        
        
        Set<int[]> res= new HashSet<>(lower);
        res.addAll(upper);
        return res.toArray(new int[res.size()][]);
    }
    
    public int angle(int[] A , int[] B , int[] C){
        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);
    }
}",None,"class Solution {
    
    public int[][] outerTrees(int[][] trees) {
        if(trees.length <= 3){
            return trees;
        }
        Stack<int[]> upper = new Stack<>();
        Stack<int[]> lower = new Stack<>();
        
        Arrays.sort(trees,(p,q) ->q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);
        
        for(int i = 0 ; i < trees.length ; i++){
            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){
                upper.pop();  
                }
            upper.push(trees[i]);
        }
        
        for(int i = trees.length-1 ; i >=0 ; i--){
            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) > 0){
                 lower.pop();  
              }
            lower.push(trees[i]);
        }
        
        Set<int[]> res= new HashSet<>(lower);
        res.addAll(upper);
        return res.toArray(new int[res.size()][]);
    }
    
    public int angle(int[] A , int[] B , int[] C){
        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);
    }
}
"
2153,java,valid-triangle-number,"class Solution {
    public int triangleNumber(int[] nums) {
        int n=nums.length;
        Arrays.sort(nums);
        int count=0;
        for(int c=n-1;c>=2;c--){
            int a=0;
            int b=c-1;
            while(a<b){
                if(nums[a]+nums[b]>=nums[c]){ 
                    count+=(b-a);
                    b--;
                }
                else{
                    a++;
                }
            }
        }
        return count;
        
    }
}",None,"class Solution {
    public int triangleNumber(int[] nums) {
        int n=nums.length;
        Arrays.sort(nums);
        int count=0;
        for(int c=n-1;c>=2;c--){
            int a=0;
            int b=c-1;
            while(a<b){
                if(nums[a]+nums[b]>nums[c]){ 
                    count+=(b-a);
                    b--;
                }
                else{
                    a++;
                }
            }
        }
        return count;
    }
}
"
2153,java,valid-triangle-number,"class Solution {
    public int triangleNumber(int[] nums) {
        int n=nums.length;
        Arrays.sort(nums);
        int count=0;
        for(int c=n-1;c>=2;c--){
            int a=0;
            int b=c-1;
            while(a<b){
                if(nums[a]+nums[b]>=nums[c]){ 
                    count+=(b-a);
                    b--;
                }
                else{
                    a++;
                }
            }
        }
        return count;
        
    }
}",None,"class Solution {
    public int triangleNumber(int[] nums) {
        int n=nums.length;
        Arrays.sort(nums);
        int count=0;
        for(int c=n-1;c>=2;c--){
            int a=0;
            int b=c-1;
            while(a<b){
                if(nums[a]+nums[b]>nums[c]){ 
                    count+=(b-a);
                    b--;
                }
                else{
                    a++;
                }
            }
        }
        return count;
    }
}
"
2153,java,valid-triangle-number,"class Solution {
    public int triangleNumber(int[] nums) {
        int n=nums.length;
        Arrays.sort(nums);
        int count=0;
        for(int c=n-1;c>=2;c--){
            int a=0;
            int b=c-1;
            while(a<b){
                if(nums[a]+nums[b]>=nums[c]){ 
                    count+=(b-a);
                    b--;
                }
                else{
                    a++;
                }
            }
        }
        return count;
        
    }
}",None,"class Solution {
    public int triangleNumber(int[] nums) {
        int n=nums.length;
        Arrays.sort(nums);
        int count=0;
        for(int c=n-1;c>=2;c--){
            int a=0;
            int b=c-1;
            while(a<b){
                if(nums[a]+nums[b]>nums[c]){ 
                    count+=(b-a);
                    b--;
                }
                else{
                    a++;
                }
            }
        }
        return count;
    }
}
"
2154,java,add-edges-to-make-degrees-of-all-nodes-even,"class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        graph = defaultdict(set)
        for a, b in edges:
            graph[a].add(b)
            graph[b].add(a)
        odds = [a for a in graph if len(graph[a]) % 2 == 1]
        if not odds:
            return True
        elif len(odds) > 4 or len(odds) == 1 or len(odds) == 3:
            return False
        elif len(odds) == 2:
            a, b = odds[0], odds[1]
            if a in graph[b]:
                return True
            for i in range(1, n + 1):
                if i not in graph[a] and i not in graph[b]:
                    return True
            return False
        else:
            a, b, c, d = odds[0], odds[1], odds[2], odds[3]
            if a not in graph[b] and c not in graph[d]:
                return True
            if a not in graph[c] and b not in graph[d]:
                return True
            if a not in graph[d] and b not in graph[c]:
                return True
            return False",None,"class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        degree = [0] * (n+1)
        for edge in edges:
            degree[edge[0]] += 1
            degree[edge[1]] += 1
        odds = sum(degree[i] % 2 == 1 for i in range(1,n+1))
        return odds in [0,2,4]
"
2154,java,add-edges-to-make-degrees-of-all-nodes-even,"class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        graph = defaultdict(set)
        for a, b in edges:
            graph[a].add(b)
            graph[b].add(a)
        odds = [a for a in graph if len(graph[a]) % 2 == 1]
        if not odds:
            return True
        elif len(odds) > 4 or len(odds) == 1 or len(odds) == 3:
            return False
        elif len(odds) == 2:
            a, b = odds[0], odds[1]
            if a in graph[b]:
                return True
            for i in range(1, n + 1):
                if i not in graph[a] and i not in graph[b]:
                    return True
            return False
        else:
            a, b, c, d = odds[0], odds[1], odds[2], odds[3]
            if a not in graph[b] and c not in graph[d]:
                return True
            if a not in graph[c] and b not in graph[d]:
                return True
            if a not in graph[d] and b not in graph[c]:
                return True
            return False",None,"class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        graph = defaultdict(set)
        for a, b in edges:
            graph[a].add(b)
            graph[b].add(a)
        odds = [a for a in graph if len(graph[a]) % 2 == 1]
        if not odds:
            return True
        elif len(odds) > 4 or len(odds) == 1 or len(odds) == 3:
            return False
        elif len(odds) == 2:
            a, b = odds[0], odds[1]
            if a in graph[b] or b in graph[a]:
                return True
            return False
        else:
            a, b, c, d = odds[0], odds[1], odds[2], odds[3]
            if (a in graph[b] and c in graph[d]) or \
               (a in graph[c] and b in graph[d]) or \
               (a in graph[d] and b in graph[c]):
                return True
            return False
"
2154,java,add-edges-to-make-degrees-of-all-nodes-even,"class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        graph = defaultdict(set)
        for a, b in edges:
            graph[a].add(b)
            graph[b].add(a)
        odds = [a for a in graph if len(graph[a]) % 2 == 1]
        if not odds:
            return True
        elif len(odds) > 4 or len(odds) == 1 or len(odds) == 3:
            return False
        elif len(odds) == 2:
            a, b = odds[0], odds[1]
            if a in graph[b]:
                return True
            for i in range(1, n + 1):
                if i not in graph[a] and i not in graph[b]:
                    return True
            return False
        else:
            a, b, c, d = odds[0], odds[1], odds[2], odds[3]
            if a not in graph[b] and c not in graph[d]:
                return True
            if a not in graph[c] and b not in graph[d]:
                return True
            if a not in graph[d] and b not in graph[c]:
                return True
            return False",None,"class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        graph = defaultdict(set)
        for a, b in edges:
            graph[a].add(b)
            graph[b].add(a)
        odds = [a for a in graph if len(graph[a]) % 2 == 1]
        if not odds:
            return True
        elif len(odds) > 4 or len(odds) == 1 or len(odds) == 3:
            return False
        elif len(odds) == 2:
            a, b = odds
            if a not in graph[b] and b not in graph[a]:
                return True
            for i in range(1, n + 1):
                if i not in graph[a] and i not in graph[b]:
                    return True
            return False
        else:
            a, b, c, d = odds
            if a not in graph[b] and c not in graph[d]:
                return True
            if a not in graph[c] and b not in graph[d]:
                return True
            if a not in graph[d] and b not in graph[c]:
                return True
            return False
"
2155,java,same-tree,"class Solution {
   
    public boolean isSameTree(TreeNode p, TreeNode q) {
     if (p == null && q == null) {
            return true;
        }
        
        if (p == null || q == null) {
            return false;
        }
        
        if (p.val == q.val) {
            return false;
        }
        
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);

        
    }
}",None,"class Solution {
   
    public boolean isSameTree(TreeNode p, TreeNode q) {
     if (p == null && q == null) {
            return true;
        }
        
        if (p == null || q == null) {
            return false;
        }
        
        if (p.val != q.val) {
            return false;
        }
        
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);

        
    }
}
"
2155,java,same-tree,"class Solution {
   
    public boolean isSameTree(TreeNode p, TreeNode q) {
     if (p == null && q == null) {
            return true;
        }
        
        if (p == null || q == null) {
            return false;
        }
        
        if (p.val == q.val) {
            return false;
        }
        
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);

        
    }
}",None,"class Solution {
   
    public boolean isSameTree(TreeNode p, TreeNode q) {
     if (p == null && q == null) {
            return true;
        }
        
        if (p == null || q == null) {
            return false;
        }
        
        if (p.val != q.val) {
            return false;
        }
        
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);

        
    }
}
"
2155,java,same-tree,"class Solution {
   
    public boolean isSameTree(TreeNode p, TreeNode q) {
     if (p == null && q == null) {
            return true;
        }
        
        if (p == null || q == null) {
            return false;
        }
        
        if (p.val == q.val) {
            return false;
        }
        
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);

        
    }
}",None,"class Solution {
   
    public boolean isSameTree(TreeNode p, TreeNode q) {
     if (p == null && q == null) {
            return true;
        }
        
        if (p == null || q == null) {
            return false;
        }
        
        if (p.val != q.val) {
            return false;
        }
        
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}
"
2156,java,minimum-falling-path-sum-ii,"class Solution {
    int m;
    int n;
    Integer memo[][];

    public int minFallingPathSum(int[][] grid) {   
         m=grid.length;
         n=grid[0].length;
         memo=new Integer[m][n];

         int recRes=Integer.MAX_VALUE;

         for(int col=0;col<n;col++)
                    recRes=Math.min(recRes,minFallingPathSum_Rec(grid,0,col));

        return recRes;

         int Tabulation_Ans=minFallingPathSum_Tabulation(grid);
         return Tabulation_Ans;
    }

    public int minFallingPathSum_Rec(int[][] grid,int i,int j){
            
            if(j<0 || j>=n || i<0 || i>=m)
                           return Integer.MAX_VALUE;

            if(i==m-1)
                     return grid[i][j];

            if(memo[i][j]!=null)
                        return memo[i][j];

            int lowerLeftSum=Integer.MAX_VALUE;
            int lowerRightSum=Integer.MAX_VALUE;

            for(int col=0;col<=j-1;col++)
                    lowerLeftSum=Math.min(lowerLeftSum,minFallingPathSum_Rec(grid,i+1,col));

            for(int col=j+1;col<=n-1;col++)
                    lowerRightSum=Math.min(lowerRightSum,minFallingPathSum_Rec(grid,i+1,col));

          return memo[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];

     }

     int minFallingPathSum_Tabulation(int[][] grid){
          int dp[][]=new int[m][n];

          for(int i=m-1;i>=0;i--){
              for(int j=n-1;j>=0;j--){
                    
                    if(i==m-1)
                     {
                         dp[i][j]=grid[i][j];
                         continue;
                     }
                
                int lowerLeftSum=Integer.MAX_VALUE;
                int lowerRightSum=Integer.MAX_VALUE;
                
                for(int col=0;col<=j-1;col++){
                    lowerLeftSum=Math.min(lowerLeftSum,((col<0)?Integer.MAX_VALUE:dp[i+1][col]));
                }
                
                for(int col=j+1;col<=n-1;col++){
                    lowerRightSum=Math.min(lowerRightSum,((col>=n)?Integer.MAX_VALUE:dp[i+1][col]));
                
                }
                
                dp[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];
              
              }
          }
           
          int Ans=Integer.MAX_VALUE;

          for(int COL=0;COL<n;COL++){
              Ans=Math.min(Ans,dp[0][COL]);
          }
          
          return Ans;
     }
}",None,"class Solution {
    int m;
    int n;
    Integer memo[][];

    public int minFallingPathSum(int[][] grid) {   
         m=grid.length;
         n=grid[0].length;
         memo=new Integer[m][n];

         int recRes=Integer.MAX_VALUE;

         for(int col=0;col<n;col++)
                    recRes=Math.min(recRes,minFallingPathSum_Rec(grid,0,col));

        return recRes;
    }

    public int minFallingPathSum_Rec(int[][] grid,int i,int j){
            
            if(j<0 || j>=n || i<0 || i>=m)
                           return Integer.MAX_VALUE;

            if(i==m-1)
                     return grid[i][j];

            if(memo[i][j]!=null)
                        return memo[i][j];

            int lowerLeftSum=Integer.MAX_VALUE;
            int lowerRightSum=Integer.MAX_VALUE;

            for(int col=0;col<=j-1;col++)
                    lowerLeftSum=Math.min(lowerLeftSum,minFallingPathSum_Rec(grid,i+1,col));

            for(int col=j+1;col<=n-1;col++)
                    lowerRightSum=Math.min(lowerRightSum,minFallingPathSum_Rec(grid,i+1,col));

          return memo[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];
     }
}
"
2156,java,minimum-falling-path-sum-ii,"class Solution {
    int m;
    int n;
    Integer memo[][];

    public int minFallingPathSum(int[][] grid) {   
         m=grid.length;
         n=grid[0].length;
         memo=new Integer[m][n];

         int recRes=Integer.MAX_VALUE;

         for(int col=0;col<n;col++)
                    recRes=Math.min(recRes,minFallingPathSum_Rec(grid,0,col));

        return recRes;

         int Tabulation_Ans=minFallingPathSum_Tabulation(grid);
         return Tabulation_Ans;
    }

    public int minFallingPathSum_Rec(int[][] grid,int i,int j){
            
            if(j<0 || j>=n || i<0 || i>=m)
                           return Integer.MAX_VALUE;

            if(i==m-1)
                     return grid[i][j];

            if(memo[i][j]!=null)
                        return memo[i][j];

            int lowerLeftSum=Integer.MAX_VALUE;
            int lowerRightSum=Integer.MAX_VALUE;

            for(int col=0;col<=j-1;col++)
                    lowerLeftSum=Math.min(lowerLeftSum,minFallingPathSum_Rec(grid,i+1,col));

            for(int col=j+1;col<=n-1;col++)
                    lowerRightSum=Math.min(lowerRightSum,minFallingPathSum_Rec(grid,i+1,col));

          return memo[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];

     }

     int minFallingPathSum_Tabulation(int[][] grid){
          int dp[][]=new int[m][n];

          for(int i=m-1;i>=0;i--){
              for(int j=n-1;j>=0;j--){
                    
                    if(i==m-1)
                     {
                         dp[i][j]=grid[i][j];
                         continue;
                     }
                
                int lowerLeftSum=Integer.MAX_VALUE;
                int lowerRightSum=Integer.MAX_VALUE;
                
                for(int col=0;col<=j-1;col++){
                    lowerLeftSum=Math.min(lowerLeftSum,((col<0)?Integer.MAX_VALUE:dp[i+1][col]));
                }
                
                for(int col=j+1;col<=n-1;col++){
                    lowerRightSum=Math.min(lowerRightSum,((col>=n)?Integer.MAX_VALUE:dp[i+1][col]));
                
                }
                
                dp[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];
              
              }
          }
           
          int Ans=Integer.MAX_VALUE;

          for(int COL=0;COL<n;COL++){
              Ans=Math.min(Ans,dp[0][COL]);
          }
          
          return Ans;
     }
}",None,"class Solution {
    int m;
    int n;
    Integer memo[][];

    public int minFallingPathSum(int[][] grid) {   
         m=grid.length;
         n=grid[0].length;
         memo=new Integer[m][n];

         int recRes=Integer.MAX_VALUE;

         for(int col=0;col<n;col++)
                    recRes=Math.min(recRes,minFallingPathSum_Rec(grid,0,col));

        return recRes;
    }

    public int minFallingPathSum_Rec(int[][] grid,int i,int j){
            
            if(j<0 || j>=n || i<0 || i>=m)
                           return Integer.MAX_VALUE;

            if(i==m-1)
                     return grid[i][j];

            if(memo[i][j]!=null)
                        return memo[i][j];

            int lowerLeftSum=Integer.MAX_VALUE;
            int lowerRightSum=Integer.MAX_VALUE;

            for(int col=0;col<=j-1;col++)
                    lowerLeftSum=Math.min(lowerLeftSum,minFallingPathSum_Rec(grid,i+1,col));

            for(int col=j+1;col<=n-1;col++)
                    lowerRightSum=Math.min(lowerRightSum,minFallingPathSum_Rec(grid,i+1,col));

          return memo[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];

     }
}
"
2156,java,minimum-falling-path-sum-ii,"class Solution {
    int m;
    int n;
    Integer memo[][];

    public int minFallingPathSum(int[][] grid) {   
         m=grid.length;
         n=grid[0].length;
         memo=new Integer[m][n];

         int recRes=Integer.MAX_VALUE;

         for(int col=0;col<n;col++)
                    recRes=Math.min(recRes,minFallingPathSum_Rec(grid,0,col));

        return recRes;

         int Tabulation_Ans=minFallingPathSum_Tabulation(grid);
         return Tabulation_Ans;
    }

    public int minFallingPathSum_Rec(int[][] grid,int i,int j){
            
            if(j<0 || j>=n || i<0 || i>=m)
                           return Integer.MAX_VALUE;

            if(i==m-1)
                     return grid[i][j];

            if(memo[i][j]!=null)
                        return memo[i][j];

            int lowerLeftSum=Integer.MAX_VALUE;
            int lowerRightSum=Integer.MAX_VALUE;

            for(int col=0;col<=j-1;col++)
                    lowerLeftSum=Math.min(lowerLeftSum,minFallingPathSum_Rec(grid,i+1,col));

            for(int col=j+1;col<=n-1;col++)
                    lowerRightSum=Math.min(lowerRightSum,minFallingPathSum_Rec(grid,i+1,col));

          return memo[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];

     }

     int minFallingPathSum_Tabulation(int[][] grid){
          int dp[][]=new int[m][n];

          for(int i=m-1;i>=0;i--){
              for(int j=n-1;j>=0;j--){
                    
                    if(i==m-1)
                     {
                         dp[i][j]=grid[i][j];
                         continue;
                     }
                
                int lowerLeftSum=Integer.MAX_VALUE;
                int lowerRightSum=Integer.MAX_VALUE;
                
                for(int col=0;col<=j-1;col++){
                    lowerLeftSum=Math.min(lowerLeftSum,((col<0)?Integer.MAX_VALUE:dp[i+1][col]));
                }
                
                for(int col=j+1;col<=n-1;col++){
                    lowerRightSum=Math.min(lowerRightSum,((col>=n)?Integer.MAX_VALUE:dp[i+1][col]));
                
                }
                
                dp[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];
              
              }
          }
           
          int Ans=Integer.MAX_VALUE;

          for(int COL=0;COL<n;COL++){
              Ans=Math.min(Ans,dp[0][COL]);
          }
          
          return Ans;
     }
}",None,"class Solution {
    int m;
    int n;
    Integer memo[][];

    public int minFallingPathSum(int[][] grid) {   
         m=grid.length;
         n=grid[0].length;
         memo=new Integer[m][n];

         int recRes=Integer.MAX_VALUE;

         for(int col=0;col<n;col++)
                    recRes=Math.min(recRes,minFallingPathSum_Rec(grid,0,col));

        return recRes;

    }

    public int minFallingPathSum_Rec(int[][] grid,int i,int j){
            
            if(j<0 || j>=n || i<0 || i>=m)
                           return Integer.MAX_VALUE;

            if(i==m-1)
                     return grid[i][j];

            if(memo[i][j]!=null)
                        return memo[i][j];

            int lowerLeftSum=Integer.MAX_VALUE;
            int lowerRightSum=Integer.MAX_VALUE;

            for(int col=0;col<=j-1;col++)
                    lowerLeftSum=Math.min(lowerLeftSum,minFallingPathSum_Rec(grid,i+1,col));

            for(int col=j+1;col<=n-1;col++)
                    lowerRightSum=Math.min(lowerRightSum,minFallingPathSum_Rec(grid,i+1,col));

          return memo[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];
     }
}
"
2157,java,largest-number-after-digit-swaps-by-parity,"class Solution {
    public int largestInteger(int num) {
        String numString = """"+ num;
        List<Integer> even = new ArrayList<>();
        List<Integer> odd = new ArrayList<>();
        for(Character c : numString.toCharArray()){
            int n = Character.getNumericValue(c);
            if(n%2==0){
                even.add(n);
            }else{
                odd.add(n);
            }
        }
        Collections.sort(even, Collections.reverseOrder());
        Collections.sort(odd, Collections.reverseOrder());
        String res ="""";

        
        for(int i=0; i<numString.length()+5; i++){
            int n = Character.getNumericValue(numString.charAt(i));
            if(n%2==0){
                res += even.get(one);
                one++;
            }else{
                res += odd.get(two);
                two++;
            }
        }
        return Integer.parseInt(res);
    }
}",None,"class Solution {
    public int largestInteger(int num) {
        String numString = """"+ num;
        List<Integer> even = new ArrayList<>();
        List<Integer> odd = new ArrayList<>();
        for(Character c : numString.toCharArray()){
            int n = Character.getNumericValue(c);
            if(n%2==0){
                even.add(n);
            }else{
                odd.add(n);
            }
        }
        Collections.sort(even, Collections.reverseOrder());
        Collections.sort(odd, Collections.reverseOrder());
        String res ="""";
        
        int one = 0;
        int two = 0;
        for(int i=0; i<numString.length(); i++){
            int n = Character.getNumericValue(numString.charAt(i));
            if(n%2==0){
                res += even.get(one);
                one++;
            }else{
                res += odd.get(two);
                two++;
            }
        }
        return Integer.parseInt(res);
    }
}
"
2157,java,largest-number-after-digit-swaps-by-parity,"class Solution {
    public int largestInteger(int num) {
        String numString = """"+ num;
        List<Integer> even = new ArrayList<>();
        List<Integer> odd = new ArrayList<>();
        for(Character c : numString.toCharArray()){
            int n = Character.getNumericValue(c);
            if(n%2==0){
                even.add(n);
            }else{
                odd.add(n);
            }
        }
        Collections.sort(even, Collections.reverseOrder());
        Collections.sort(odd, Collections.reverseOrder());
        String res ="""";

        
        for(int i=0; i<numString.length()+5; i++){
            int n = Character.getNumericValue(numString.charAt(i));
            if(n%2==0){
                res += even.get(one);
                one++;
            }else{
                res += odd.get(two);
                two++;
            }
        }
        return Integer.parseInt(res);
    }
}",None,"class Solution {
    public int largestInteger(int num) {
        String numString = """"+ num;
        List<Integer> even = new ArrayList<>();
        List<Integer> odd = new ArrayList<>();
        for(Character c : numString.toCharArray()){
            int n = Character.getNumericValue(c);
            if(n%2==0){
                even.add(n);
            }else{
                odd.add(n);
            }
        }
        Collections.sort(even, Collections.reverseOrder());
        Collections.sort(odd, Collections.reverseOrder());
        String res ="""";
        int one=0, two=0;

        for(int i=0; i<numString.length(); i++){
            int n = Character.getNumericValue(numString.charAt(i));
            if(n%2==0){
                res += even.get(one);
                one++;
            }else{
                res += odd.get(two);
                two++;
            }
        }
        return Integer.parseInt(res);
    }
}
"
2157,java,largest-number-after-digit-swaps-by-parity,"class Solution {
    public int largestInteger(int num) {
        String numString = """"+ num;
        List<Integer> even = new ArrayList<>();
        List<Integer> odd = new ArrayList<>();
        for(Character c : numString.toCharArray()){
            int n = Character.getNumericValue(c);
            if(n%2==0){
                even.add(n);
            }else{
                odd.add(n);
            }
        }
        Collections.sort(even, Collections.reverseOrder());
        Collections.sort(odd, Collections.reverseOrder());
        String res ="""";

        
        for(int i=0; i<numString.length()+5; i++){
            int n = Character.getNumericValue(numString.charAt(i));
            if(n%2==0){
                res += even.get(one);
                one++;
            }else{
                res += odd.get(two);
                two++;
            }
        }
        return Integer.parseInt(res);
    }
}",None,"class Solution {
    public int largestInteger(int num) {
        String numString = """"+ num;
        List<Integer> even = new ArrayList<>();
        List<Integer> odd = new ArrayList<>();
        for(Character c : numString.toCharArray()){
            int n = Character.getNumericValue(c);
            if(n%2==0){
                even.add(n);
            }else{
                odd.add(n);
            }
        }
        Collections.sort(even, Collections.reverseOrder());
        Collections.sort(odd, Collections.reverseOrder());
        String res ="""";
        int one=0;
        int two=0;

        for(int i=0; i<numString.length(); i++){
            int n = Character.getNumericValue(numString.charAt(i));
            if(n%2==0){
                res += even.get(one);
                one++;
            }else{
                res += odd.get(two);
                two++;
            }
        }
        return Integer.parseInt(res);
    }
}
"
2158,java,sort-even-and-odd-indices-independently,"class Solution {
    public int[] sortEvenOdd(int[] nums) {
        int n = nums.length;
        int[] even = new int[(n + 1) / 2];
        int[] odd = new int[n / 2];
        int iE = 0;
        int iO = 0;

        for(int i = 0; i < n; i++) {
            if(nums[i] % 2 == 0) {
                even[iE++] = nums[i];
            } else {
                odd[iO++] = nums[i];
            }
        }

        Arrays.sort(even);
        Arrays.sort(odd);
        iE = 0;
        iO = n / 2 - 1;

        for(int i = 0; i < n; i++) {
            if(i % 2 == 0) {
                nums[i] = even[iE++];
            } else {
                nums[i] = odd[iO--];
            }
        }

        return nums;
    }
}",None,"class Solution {
    public int[] sortEvenOdd(int[] nums) {
        int n = nums.length;
        int[] even = new int[(n + 1) / 2];
        int[] odd = new int[n / 2];
        int iE = 0;
        int iO = 0;

        for (int i = 0; i < n; i++) {
            if(i % 2 == 0) {
                even[iE++] = nums[i];
            } else {
                odd[iO++] = nums[i];
            }
        }

        Arrays.sort(even);
        Arrays.sort(odd);
        iE = 0;
        iO = odd.length - 1;

        for(int i = 0; i < n; i++) {
            if(i % 2 == 0) {
                nums[i] = even[iE++];
            } else {
                nums[i] = odd[iO--];
            }
        }

        return nums;
    }
}
"
2158,java,sort-even-and-odd-indices-independently,"class Solution {
    public int[] sortEvenOdd(int[] nums) {
        int n = nums.length;
        int[] even = new int[(n + 1) / 2];
        int[] odd = new int[n / 2];
        int iE = 0;
        int iO = 0;

        for(int i = 0; i < n; i++) {
            if(nums[i] % 2 == 0) {
                even[iE++] = nums[i];
            } else {
                odd[iO++] = nums[i];
            }
        }

        Arrays.sort(even);
        Arrays.sort(odd);
        iE = 0;
        iO = n / 2 - 1;

        for(int i = 0; i < n; i++) {
            if(i % 2 == 0) {
                nums[i] = even[iE++];
            } else {
                nums[i] = odd[iO--];
            }
        }

        return nums;
    }
}",None,"class Solution {
    public int[] sortEvenOdd(int[] nums) {
        int n = nums.length;
        int[] even = new int[n / 2 + n % 2];
        int[] odd = new int[n / 2];
        int iE = 0;
        int iO = 0;

        for(int i = 0; i < n; i++) {
            if(i % 2 == 0) {
                even[iE++] = nums[i];
            } else {
                odd[iO++] = nums[i];
            }
        }

        Arrays.sort(even);
        Arrays.sort(odd);
        for(int i=0; i<odd.length/2; i++){ 
            int temp = odd[i]; 
            odd[i] = odd[odd.length -i -1]; 
            odd[odd.length -i -1] = temp; 
        }

        iE = 0;
        iO = 0;

        for(int i = 0; i < n; i++) {
            if(i % 2 == 0) {
                nums[i] = even[iE++];
            } else {
                nums[i] = odd[iO++];
            }
        }

        return nums;
    }
}
"
2158,java,sort-even-and-odd-indices-independently,"class Solution {
    public int[] sortEvenOdd(int[] nums) {
        int n = nums.length;
        int[] even = new int[(n + 1) / 2];
        int[] odd = new int[n / 2];
        int iE = 0;
        int iO = 0;

        for(int i = 0; i < n; i++) {
            if(nums[i] % 2 == 0) {
                even[iE++] = nums[i];
            } else {
                odd[iO++] = nums[i];
            }
        }

        Arrays.sort(even);
        Arrays.sort(odd);
        iE = 0;
        iO = n / 2 - 1;

        for(int i = 0; i < n; i++) {
            if(i % 2 == 0) {
                nums[i] = even[iE++];
            } else {
                nums[i] = odd[iO--];
            }
        }

        return nums;
    }
}",None,"class Solution {
    public int[] sortEvenOdd(int[] nums) {
        int n = nums.length;
        int[] even = new int[(n + 1) / 2];
        int[] odd = new int[n / 2];
        int iE = 0;
        int iO = 0;

        for(int i = 0; i < n; i++) {
            if(i % 2 == 0) {
                even[iE++] = nums[i];
            } else {
                odd[iO++] = nums[i];
            }
        }

        Arrays.sort(even);
        Arrays.sort(odd);
        iE = 0;
        iO = n / 2 - 1;

        for(int i = 0; i < n; i++) {
            if(i % 2 == 0) {
                nums[i] = even[iE++];
            } else {
                nums[i] = odd[iO--];
            }
        }

        return nums;
    }
}
"
2159,java,path-sum-ii,"class Solution {
     List<List<Integer>> al = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
       
        helper( new ArrayList<>(), root, targetSum);
        return al;
    }
    void helper(List<Integer> li, TreeNode root, int targetSum)
    {
        if(root == null)
        return;
        li.add(root.val);
        if(root.left == null && root.right == null)
        {
            int sum = 0;
            for(int i: li)
            sum+= i;
            if(sum != targetSum)
            al.add(li);
        }
        helper(new ArrayList<>(li), root.left, targetSum);
        helper(new ArrayList<>(li), root.right, targetSum);
    }
}",None,"class Solution {
     List<List<Integer>> al = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
       
        helper( new ArrayList<>(), root, targetSum);
        return al;
    }
    void helper(List<Integer> li, TreeNode root, int targetSum)
    {
        if(root == null)
        return;
        li.add(root.val);
        if(root.left == null && root.right == null)
        {
            int sum = 0;
            for(int i: li)
            sum+= i;
            if(sum == targetSum)
            al.add(li);
        }
        helper(new ArrayList<>(li), root.left, targetSum);
        helper(new ArrayList<>(li), root.right, targetSum);
    }
}
"
2159,java,path-sum-ii,"class Solution {
     List<List<Integer>> al = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
       
        helper( new ArrayList<>(), root, targetSum);
        return al;
    }
    void helper(List<Integer> li, TreeNode root, int targetSum)
    {
        if(root == null)
        return;
        li.add(root.val);
        if(root.left == null && root.right == null)
        {
            int sum = 0;
            for(int i: li)
            sum+= i;
            if(sum != targetSum)
            al.add(li);
        }
        helper(new ArrayList<>(li), root.left, targetSum);
        helper(new ArrayList<>(li), root.right, targetSum);
    }
}",None,"class Solution {
     List<List<Integer>> al = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
       
        helper(new ArrayList<>(), root, targetSum);
        return al;
    }
    void helper(List<Integer> li, TreeNode root, int targetSum)
    {
        if(root == null)
        return;
        li.add(root.val);
        if(root.left == null && root.right == null)
        {
            int sum = 0;
            for(int i: li)
            sum += i;
            if(sum == targetSum)
            al.add(li);
        }
        helper(new ArrayList<>(li), root.left, targetSum);
        helper(new ArrayList<>(li), root.right, targetSum);
    }
}
"
2159,java,path-sum-ii,"class Solution {
     List<List<Integer>> al = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
       
        helper( new ArrayList<>(), root, targetSum);
        return al;
    }
    void helper(List<Integer> li, TreeNode root, int targetSum)
    {
        if(root == null)
        return;
        li.add(root.val);
        if(root.left == null && root.right == null)
        {
            int sum = 0;
            for(int i: li)
            sum+= i;
            if(sum != targetSum)
            al.add(li);
        }
        helper(new ArrayList<>(li), root.left, targetSum);
        helper(new ArrayList<>(li), root.right, targetSum);
    }
}",None,"class Solution {
    List<List<Integer>> al = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        helper(new ArrayList<>(), root, targetSum);
        return al;
    }
    void helper(List<Integer> li, TreeNode root, int targetSum) {
        if(root == null)
            return;
        li.add(root.val);
        if(root.left == null && root.right == null) {
            int sum = 0;
            for(int i: li)
                sum+= i;
            if(sum == targetSum)
                al.add(li);
        }
        helper(new ArrayList<>(li), root.left, targetSum);
        helper(new ArrayList<>(li), root.right, targetSum);
    }
}
"
2160,java,remove-k-digits,"class Solution {
    public String removeKdigits(String num, int k) {
        Stack<Character> st = new Stack<>();
        for(Character ch : num.toCharArray()) {
            while(!st.isEmpty() && k > 0 && ch < st.peek()) {
                st.pop();
                
                k--;
            }

            if(!st.isEmpty() || ch != '1') { 
                st.push(ch);
            }
        }

        while(!st.isEmpty() && k-- > 0) {
            st.pop();
        }
        if(st.isEmpty()) return ""0"";

        String ans = """";
        while(!st.isEmpty()) {
            ans = st.peek() + ans;
            st.pop();
        }
        return ans;
    }
}",None,"class Solution {
    public String removeKdigits(String num, int k) {
        Stack<Character> st = new Stack<>();
        for(Character ch : num.toCharArray()) {
            while(!st.isEmpty() && k > 0 && ch < st.peek()) {
                st.pop();

                k--;
            }

            if(!st.isEmpty() || ch != '0') {
                st.push(ch);
            }
        }

        while(!st.isEmpty() && k-- > 0) {
            st.pop();
        }
        if(st.isEmpty()) return ""0"";

        String ans = """";
        while(!st.isEmpty()) {
            ans = st.peek() + ans;
            st.pop();
        }
        return ans;
    }
}
"
2160,java,remove-k-digits,"class Solution {
    public String removeKdigits(String num, int k) {
        Stack<Character> st = new Stack<>();
        for(Character ch : num.toCharArray()) {
            while(!st.isEmpty() && k > 0 && ch < st.peek()) {
                st.pop();
                
                k--;
            }

            if(!st.isEmpty() || ch != '1') { 
                st.push(ch);
            }
        }

        while(!st.isEmpty() && k-- > 0) {
            st.pop();
        }
        if(st.isEmpty()) return ""0"";

        String ans = """";
        while(!st.isEmpty()) {
            ans = st.peek() + ans;
            st.pop();
        }
        return ans;
    }
}",None,"class Solution {
    public String removeKdigits(String num, int k) {
        Stack<Character> st = new Stack<>();
        for(Character ch : num.toCharArray()) {
            while(!st.isEmpty() && k > 0 && ch < st.peek()) {
                st.pop(); 
                k--;
            }

            if(!st.isEmpty() || ch != '0') { 
                st.push(ch);
            }
        }

        while(!st.isEmpty() && k-- > 0) {
            st.pop();
        }
        
        if(st.isEmpty()) return ""0"";

        StringBuilder ans = new StringBuilder();
        while(!st.isEmpty()) {
            ans.insert(0, st.pop());
        }
        
        while(ans.length() > 1 && ans.charAt(0) == '0') 
            ans.deleteCharAt(0);
        
        return ans.toString();
    }
}
"
2160,java,remove-k-digits,"class Solution {
    public String removeKdigits(String num, int k) {
        Stack<Character> st = new Stack<>();
        for(Character ch : num.toCharArray()) {
            while(!st.isEmpty() && k > 0 && ch < st.peek()) {
                st.pop();
                
                k--;
            }

            if(!st.isEmpty() || ch != '1') { 
                st.push(ch);
            }
        }

        while(!st.isEmpty() && k-- > 0) {
            st.pop();
        }
        if(st.isEmpty()) return ""0"";

        String ans = """";
        while(!st.isEmpty()) {
            ans = st.peek() + ans;
            st.pop();
        }
        return ans;
    }
}",None,"class Solution {
    public String removeKdigits(String num, int k) {
        Stack<Character> st = new Stack<>();
        for(Character ch : num.toCharArray()) {
            while(!st.isEmpty() && k > 0 && ch < st.peek()) {
                st.pop();
                
                k--;
            }

            if(!st.isEmpty() || ch != '0') {
                st.push(ch);
            }
        }

        while(!st.isEmpty() && k-- > 0) {
            st.pop();
        }
        
        StringBuilder sb = new StringBuilder();
        while(!st.isEmpty()) {
            sb.append(st.pop());
        }
        sb.reverse();

        while (sb.length() > 1 && sb.charAt(0) == '0')
            sb.deleteCharAt(0);
        
        return sb.toString();
    }
}
"
2411,java,subtract-the-product-and-sum-of-digits-of-an-integer,"class Solution {
    public int subtractProductAndSum(int n) {
        
        int multi=1, sum=0;
        while(n!=0){
            int rem=n%10;
            sum+=rem;
            multi+=rem; 
            n=n/10;
        }
        return multi - sum;
    }
}",None,"class Solution {
    public int subtractProductAndSum(int n) {
        
        int multi=1, sum=0;
        while(n!=0){
            int rem=n%10;
            sum+=rem;
            multi*=rem; 
            n=n/10;
        }
        return multi - sum;
    }
}
"
2411,java,subtract-the-product-and-sum-of-digits-of-an-integer,"class Solution {
    public int subtractProductAndSum(int n) {
        
        int multi=1, sum=0;
        while(n!=0){
            int rem=n%10;
            sum+=rem;
            multi+=rem; 
            n=n/10;
        }
        return multi - sum;
    }
}",None,"class Solution {
    public int subtractProductAndSum(int n) {
        int multi=1, sum=0;
        while(n!=0){
            int rem=n%10;
            sum+=rem;
            multi*=rem; 
            n=n/10;
        }
        return multi - sum;
    }
}
"
2411,java,subtract-the-product-and-sum-of-digits-of-an-integer,"class Solution {
    public int subtractProductAndSum(int n) {
        
        int multi=1, sum=0;
        while(n!=0){
            int rem=n%10;
            sum+=rem;
            multi+=rem; 
            n=n/10;
        }
        return multi - sum;
    }
}",None,"class Solution {
    public int subtractProductAndSum(int n) {

        int multi=1, sum=0;
        while(n!=0){
            int rem=n%10;
            sum+=rem;
            multi*=rem; 
            n=n/10;
        }
        return multi - sum;
    }
}
"
2412,java,count-good-nodes-in-binary-tree,"class Solution {
    int count = 0;
    
    public void countGoodNodes(TreeNode root, int maximum) {
            if(root!=null) {
                if (maximum <= root.val) {
                    maximum = root.val;
                    count++;
                }
            countGoodNodes(root.left,maximum);
        } 
            countGoodNodes(root.right, maximum);
    }

    public int goodNodes(TreeNode root) {
        int maximum = root.val;
        countGoodNodes(root,  maximum);
        return count;
    }
}",None,"class Solution {
    int count = 0;
    
    public void countGoodNodes(TreeNode root, int maximum) {
        if (root != null) {
            if (maximum <= root.val) {
                maximum = root.val;
                count++;
            }
            countGoodNodes(root.left, maximum);
            countGoodNodes(root.right, maximum);
        }
    }

    public int goodNodes(TreeNode root) {
        if (root == null) return 0;
        int maximum = root.val;
        countGoodNodes(root,  maximum);
        return count;
    }
}
"
2412,java,count-good-nodes-in-binary-tree,"class Solution {
    int count = 0;
    
    public void countGoodNodes(TreeNode root, int maximum) {
            if(root!=null) {
                if (maximum <= root.val) {
                    maximum = root.val;
                    count++;
                }
            countGoodNodes(root.left,maximum);
        } 
            countGoodNodes(root.right, maximum);
    }

    public int goodNodes(TreeNode root) {
        int maximum = root.val;
        countGoodNodes(root,  maximum);
        return count;
    }
}",None,"class Solution {
    int count = 0;

    public void countGoodNodes(TreeNode root, int maximum) {
        if (root != null) {
            if (maximum <= root.val) {
                maximum = root.val;
                count++;
            }
            countGoodNodes(root.left, maximum);
            countGoodNodes(root.right, maximum);
        }
    }

    public int goodNodes(TreeNode root) {
        int maximum = root.val;
        countGoodNodes(root, maximum);
        return count;
    }
}
"
2412,java,count-good-nodes-in-binary-tree,"class Solution {
    int count = 0;
    
    public void countGoodNodes(TreeNode root, int maximum) {
            if(root!=null) {
                if (maximum <= root.val) {
                    maximum = root.val;
                    count++;
                }
            countGoodNodes(root.left,maximum);
        } 
            countGoodNodes(root.right, maximum);
    }

    public int goodNodes(TreeNode root) {
        int maximum = root.val;
        countGoodNodes(root,  maximum);
        return count;
    }
}",None,"class Solution {
    int count = 0;
    
    public void countGoodNodes(TreeNode root, int maximum) {
        if(root!=null) {
            if (maximum <= root.val) {
                maximum = root.val;
                count++;
            }
            countGoodNodes(root.left,maximum);
            countGoodNodes(root.right, maximum);
        } 
    }

    public int goodNodes(TreeNode root) {
        int maximum = -10000; // Initialize maximum value to the minimum possible integer value in binary tree
        countGoodNodes(root,  maximum);
        return count;
    }
}
"
2413,java,smallest-range-covering-elements-from-k-lists,"class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        int k = nums.size();
        List<Pair<Integer,Integer>> list = new ArrayList<>();
        for(int i = 0;i<k;i++){
            List<Integer> l = nums.get(i);
            for(int nu : l){
                list.add(new Pair(nu,i));
            }
        }
        
        Collections.sort(list,(a,b)-> a.getKey()-b.getKey());
        int[] ans = new int[2];
        ans[1] = ans[0] = Integer.MAX_VALUE; 
        int i = 0,j=0;
        List<Integer> store = new ArrayList<>();
        HashMap<Integer,Integer> mp = new HashMap<>();
        int totalType = 0;
        
        while(j<list.size()){
            int nu = list.get(j).getKey();
            int type = list.get(j).getValue();
            store.add(nu);
            int val = mp.getOrDefault(type,0);
            mp.put(type,val+1);
            totalType++;
            if(mp.size()<k){
                j++;
            }else if(mp.size()==k){
                if(ans[0]==ans[1] && ans[1] == Integer.MAX_VALUE){
                    ans[0] = store.get(0);
                    ans[1] = store.get(store.size()-1);
                }
                int dif = store.get(store.size()-1)-store.get(0);
                if(dif<ans[1]-ans[0]){
                    ans[0] = store.get(0);
                    ans[1] = store.get(store.size()-1);
                }  
                
                while(mp.size()==k){
                    dif = store.get(store.size()-1)-store.get(0);
                    if(dif<ans[1]-ans[0]){
                        ans[0] = store.get(0);
                        ans[1] = store.get(store.size()-1);
                    }
                    store.remove(0);
                    int t = list.get(i).getValue();
                    int vv = (int) mp.get(t);
                    if(vv==1){
                        mp.remove(t);
                    }
                    i++;
                }
                
                j++;
                
            }
   
        }
        
        
        return ans;
    }
}",None,"class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        int k = nums.size();
        List<Pair<Integer, Integer>> list = new ArrayList<>();
        for (int i = 0; i < k; i++) {
            List<Integer> l = nums.get(i);
            for (int nu : l) {
                list.add(new Pair(nu, i));
            }
        }

        Collections.sort(list, (a, b) -> a.getKey() - b.getKey());
        int[] ans = new int[2];
        
        int i = 0, left = 0, min = Integer.MAX_VALUE;
        int[] count = new int[k];
        for (Pair<Integer, Integer> p : list) {
            if (count[p.getValue()]++ == 0) i++;
            if (i == k) {
                while (count[list.get(left).getValue()] > 1) {
                    count[list.get(left++).getValue()]--;
                }
                if (p.getKey() - list.get(left).getKey() < min) {
                    min = p.getKey() - list.get(left).getKey();
                    ans[0] = list.get(left).getKey();
                    ans[1] = p.getKey();
                }
            }
        }
        return ans;
    }
}
"
2413,java,smallest-range-covering-elements-from-k-lists,"class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        int k = nums.size();
        List<Pair<Integer,Integer>> list = new ArrayList<>();
        for(int i = 0;i<k;i++){
            List<Integer> l = nums.get(i);
            for(int nu : l){
                list.add(new Pair(nu,i));
            }
        }
        
        Collections.sort(list,(a,b)-> a.getKey()-b.getKey());
        int[] ans = new int[2];
        ans[1] = ans[0] = Integer.MAX_VALUE; 
        int i = 0,j=0;
        List<Integer> store = new ArrayList<>();
        HashMap<Integer,Integer> mp = new HashMap<>();
        int totalType = 0;
        
        while(j<list.size()){
            int nu = list.get(j).getKey();
            int type = list.get(j).getValue();
            store.add(nu);
            int val = mp.getOrDefault(type,0);
            mp.put(type,val+1);
            totalType++;
            if(mp.size()<k){
                j++;
            }else if(mp.size()==k){
                if(ans[0]==ans[1] && ans[1] == Integer.MAX_VALUE){
                    ans[0] = store.get(0);
                    ans[1] = store.get(store.size()-1);
                }
                int dif = store.get(store.size()-1)-store.get(0);
                if(dif<ans[1]-ans[0]){
                    ans[0] = store.get(0);
                    ans[1] = store.get(store.size()-1);
                }  
                
                while(mp.size()==k){
                    dif = store.get(store.size()-1)-store.get(0);
                    if(dif<ans[1]-ans[0]){
                        ans[0] = store.get(0);
                        ans[1] = store.get(store.size()-1);
                    }
                    store.remove(0);
                    int t = list.get(i).getValue();
                    int vv = (int) mp.get(t);
                    if(vv==1){
                        mp.remove(t);
                    }
                    i++;
                }
                
                j++;
                
            }
   
        }
        
        
        return ans;
    }
}",None,"class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        int k = nums.size();
        List<Pair<Integer,Integer>> list = new ArrayList<>();
        for(int i = 0;i<k;i++){
            List<Integer> l = nums.get(i);
            for(int nu : l){
                list.add(new Pair(nu,i));
            }
        }
        
        Collections.sort(list,(a,b)-> a.getKey()-b.getKey());
        int[] ans = new int[2];
        ans[1] = Integer.MAX_VALUE; 
        ans[0] = Integer.MIN_VALUE; 
        int i = 0,j=0;
        List<Integer> store = new ArrayList<>();
        HashMap<Integer,Integer> mp = new HashMap<>();
        
        while(j<list.size()){
            int nu = list.get(j).getKey();
            int type = list.get(j).getValue();
            store.add(nu);
            int val = mp.getOrDefault(type,0);
            mp.put(type,val+1);
            
            if(mp.size()==k){
                if(ans[1] - ans[0] > store.get(store.size()-1)-store.get(0)){
                    ans[0] = store.get(0);
                    ans[1] = store.get(store.size()-1);
                }
                while(mp.size()==k){
                    int t = list.get(i).getValue();
                    int vv = (int) mp.get(t);
                    if(vv==1){
                        mp.remove(t);
                    } else {
                        mp.put(t, vv-1);
                    }
                    store.remove(0);
                    ++i;
                }
            }
            ++j;
        }
        return ans;
    }
}
"
2413,java,smallest-range-covering-elements-from-k-lists,"class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        int k = nums.size();
        List<Pair<Integer,Integer>> list = new ArrayList<>();
        for(int i = 0;i<k;i++){
            List<Integer> l = nums.get(i);
            for(int nu : l){
                list.add(new Pair(nu,i));
            }
        }
        
        Collections.sort(list,(a,b)-> a.getKey()-b.getKey());
        int[] ans = new int[2];
        ans[1] = ans[0] = Integer.MAX_VALUE; 
        int i = 0,j=0;
        List<Integer> store = new ArrayList<>();
        HashMap<Integer,Integer> mp = new HashMap<>();
        int totalType = 0;
        
        while(j<list.size()){
            int nu = list.get(j).getKey();
            int type = list.get(j).getValue();
            store.add(nu);
            int val = mp.getOrDefault(type,0);
            mp.put(type,val+1);
            totalType++;
            if(mp.size()<k){
                j++;
            }else if(mp.size()==k){
                if(ans[0]==ans[1] && ans[1] == Integer.MAX_VALUE){
                    ans[0] = store.get(0);
                    ans[1] = store.get(store.size()-1);
                }
                int dif = store.get(store.size()-1)-store.get(0);
                if(dif<ans[1]-ans[0]){
                    ans[0] = store.get(0);
                    ans[1] = store.get(store.size()-1);
                }  
                
                while(mp.size()==k){
                    dif = store.get(store.size()-1)-store.get(0);
                    if(dif<ans[1]-ans[0]){
                        ans[0] = store.get(0);
                        ans[1] = store.get(store.size()-1);
                    }
                    store.remove(0);
                    int t = list.get(i).getValue();
                    int vv = (int) mp.get(t);
                    if(vv==1){
                        mp.remove(t);
                    }
                    i++;
                }
                
                j++;
                
            }
   
        }
        
        
        return ans;
    }
}",None,"class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        int k = nums.size();
        List<Pair<Integer,Integer>> list = new ArrayList<>();
        for(int i = 0;i<k;i++){
            List<Integer> l = nums.get(i);
            for(int nu : l){
                list.add(new Pair(nu,i));
            }
        }
        
        Collections.sort(list,(a,b)-> a.getKey()-b.getKey());
        int[] ans = new int[2];
        ans[1] = Integer.MAX_VALUE; 
        ans[0] = Integer.MIN_VALUE; 
        int i = 0,j=0;
        List<Integer> store = new ArrayList<>();
        HashMap<Integer,Integer> mp = new HashMap<>();
        
        while(j<list.size()){
            int nu = list.get(j).getKey();
            int type = list.get(j).getValue();
            store.add(nu);
            int val = mp.getOrDefault(type,0);
            mp.put(type,val+1);
            if(mp.size()<k){
                j++;
            }else if(mp.size()==k){
                while(mp.size()==k){
                    int dif = store.get(store.size()-1)-store.get(0);
                    if(dif<ans[1]-ans[0]){
                        ans[0] = store.get(0);
                        ans[1] = store.get(store.size()-1);
                    }
                    int t = list.get(i++).getValue();
                    if(mp.get(t) == 1)
                        mp.remove(t);
                    else
                        mp.put(t, mp.get(t) - 1);
                    store.remove(0);
                }
                j++;
            }
        }
        return ans;
    }
}
"
2414,java,longest-string-chain,"class Solution {
    public int longestStrChain(String[] words) {
        Arrays.sort(words, (a, b) -> a.length() - b.length());
        
        Map<String, Integer> dp = new HashMap<>();
        int maxChainLength = 1;
        
        for (String word : words) {
            int longestChain = 0;
            for (int i = 0; i < word.length(); i++) {
                StringBuilder sb = new StringBuilder(word);
                sb.deleteCharAt(i);
                String predecessor = sb.toString();
                if (dp.containsKey(predecessor)) {
                    longestChain = Math.max(longestChain, dp.get(predecessor) + 1);
                }
            }
            dp.put(word, longestChain);
            maxChainLength = Math.max(maxChainLength, longestChain);
        }
        
        return maxChainLength;
    }
}",None,"class Solution {
    public int longestStrChain(String[] words) {
        Arrays.sort(words, (a, b) -> a.length() - b.length());

        Map<String, Integer> dp = new HashMap<>();
        int maxChainLength = 0;

        for (String word : words) {
            int longestChain = 0;
            for (int i = 0; i < word.length(); i++) {
                StringBuilder sb = new StringBuilder(word);
                sb.deleteCharAt(i);
                String predecessor = sb.toString();
                longestChain = Math.max(longestChain, dp.getOrDefault(predecessor, 0) + 1);
            }
            dp.put(word, longestChain);
            maxChainLength = Math.max(maxChainLength, longestChain);
        }

        return maxChainLength;
    }
}
"
2414,java,longest-string-chain,"class Solution {
    public int longestStrChain(String[] words) {
        Arrays.sort(words, (a, b) -> a.length() - b.length());
        
        Map<String, Integer> dp = new HashMap<>();
        int maxChainLength = 1;
        
        for (String word : words) {
            int longestChain = 0;
            for (int i = 0; i < word.length(); i++) {
                StringBuilder sb = new StringBuilder(word);
                sb.deleteCharAt(i);
                String predecessor = sb.toString();
                if (dp.containsKey(predecessor)) {
                    longestChain = Math.max(longestChain, dp.get(predecessor) + 1);
                }
            }
            dp.put(word, longestChain);
            maxChainLength = Math.max(maxChainLength, longestChain);
        }
        
        return maxChainLength;
    }
}",None,"class Solution {
    public int longestStrChain(String[] words) {
        Arrays.sort(words, (a, b) -> a.length() - b.length());
        
        Map<String, Integer> dp = new HashMap<>();
        int maxChainLength = 1;
        
        for (String word : words) {
            int longestChain = 1;
            for (int i = 0; i < word.length(); i++) {
                StringBuilder sb = new StringBuilder(word);
                sb.deleteCharAt(i);
                String predecessor = sb.toString();
                if (dp.containsKey(predecessor)) {
                    longestChain = Math.max(longestChain, dp.get(predecessor) + 1);
                }
            }
            dp.put(word, longestChain);
            maxChainLength = Math.max(maxChainLength, longestChain);
        }
        
        return maxChainLength;
    }
}
"
2414,java,longest-string-chain,"class Solution {
    public int longestStrChain(String[] words) {
        Arrays.sort(words, (a, b) -> a.length() - b.length());
        
        Map<String, Integer> dp = new HashMap<>();
        int maxChainLength = 1;
        
        for (String word : words) {
            int longestChain = 0;
            for (int i = 0; i < word.length(); i++) {
                StringBuilder sb = new StringBuilder(word);
                sb.deleteCharAt(i);
                String predecessor = sb.toString();
                if (dp.containsKey(predecessor)) {
                    longestChain = Math.max(longestChain, dp.get(predecessor) + 1);
                }
            }
            dp.put(word, longestChain);
            maxChainLength = Math.max(maxChainLength, longestChain);
        }
        
        return maxChainLength;
    }
}",None,"class Solution {
    public int longestStrChain(String[] words) {
        Arrays.sort(words, (a, b) -> a.length() - b.length());
        
        Map<String, Integer> dp = new HashMap<>();
        int maxChainLength = 0;
        
        for (String word : words) {
            int longestChain = 0;
            for (int i = 0; i < word.length(); i++) {
                StringBuilder sb = new StringBuilder(word);
                sb.deleteCharAt(i);
                String predecessor = sb.toString();
                if (dp.containsKey(predecessor)) {
                    longestChain = Math.max(longestChain, dp.get(predecessor) + 1);
                }
            }
            dp.put(word, 1 + longestChain);
            maxChainLength = Math.max(maxChainLength, 1 + longestChain);
        }
        
        return maxChainLength;
    }
}
"
2415,java,maximum-ice-cream-bars,"class Solution {
    public int maxIceCream(int[] costs, int coins) {
        int [] arr = new int [100001];
        for(int x : costs)arr[x]++;
        int count = 0;
        int index = 1;
        while(index<100001 && coins>=index*arr[index]){
            coins-=index*arr[index];
            count+=arr[index];
            index++;
        }

        while(index<100001 && coins>=index){
            coins-=index;
            index++;
            count++;
        }
        return count;
    }
}",None,"class Solution {
    public int maxIceCream(int[] costs, int coins) {
        int [] arr = new int [100001];
        for(int x : costs) arr[x]++;
        int count = 0;
        int index = 1;
        while(index<100001 && coins>=index){
            while(arr[index]>0 && coins>=index){
                coins-=index;
                arr[index]--;
                count++;
            }
            index++;
        }
        return count;
    }
}
"
2415,java,maximum-ice-cream-bars,"class Solution {
    public int maxIceCream(int[] costs, int coins) {
        int [] arr = new int [100001];
        for(int x : costs)arr[x]++;
        int count = 0;
        int index = 1;
        while(index<100001 && coins>=index*arr[index]){
            coins-=index*arr[index];
            count+=arr[index];
            index++;
        }

        while(index<100001 && coins>=index){
            coins-=index;
            index++;
            count++;
        }
        return count;
    }
}",None,"class Solution {
    public int maxIceCream(int[] costs, int coins) {
        int [] arr = new int [100001];
        for(int x : costs) arr[x]++;
        int count = 0;
        int index = 1;
        while(index<100001 && coins>=index*arr[index]){
            coins-=index*arr[index];
            count+=arr[index];
            index++;
        }

        if(index<100001 && coins>=index){
            count += coins/index;
        }
        return count;
    }
}
"
2415,java,maximum-ice-cream-bars,"class Solution {
    public int maxIceCream(int[] costs, int coins) {
        int [] arr = new int [100001];
        for(int x : costs)arr[x]++;
        int count = 0;
        int index = 1;
        while(index<100001 && coins>=index*arr[index]){
            coins-=index*arr[index];
            count+=arr[index];
            index++;
        }

        while(index<100001 && coins>=index){
            coins-=index;
            index++;
            count++;
        }
        return count;
    }
}",None,"class Solution {
    public int maxIceCream(int[] costs, int coins) {
        int [] arr = new int [100001];
        for(int x : costs) arr[x]++;
        int count = 0;
        int index = 1;
        while(index < 100001 && coins >= index * arr[index]){
            coins -= index * arr[index];
            count += arr[index++];
        }
        if(index < 100001) {
            count += coins / index;
        }     
        return count;
    }
}
"
2416,java,sort-even-and-odd-indices-independently,"class Solution {
    public int[] sortEvenOdd(int[] nums) {
        PriorityQueue<Integer> queue = new PriorityQueue<>();
        for(int i=0;i<nums.length;i++){
            queue.add(nums[i]);
        }
        for(int i=0;i<nums.length;i+=2){
            nums[i]=queue.poll();
        }
        queue = new PriorityQueue<>(new MaxHeap());
        for(int i=1;i<nums.length;i++){
            queue.add(nums[i]);
        }
        for(int i=1;i<nums.length;i+=2){
            nums[i]=queue.poll();
        }
        return nums;
    }
}
class MaxHeap implements Comparator<Integer>{
    public int compare(Integer ca,Integer cb){
        return cb-ca;
    }
}",None,"class Solution {
    public int[] sortEvenOdd(int[] nums) {
        PriorityQueue<Integer> queue = new PriorityQueue<>();
        for(int i=0;i<nums.length;i+=2){
            queue.add(nums[i]);
        }
        for(int i=0;i<nums.length;i+=2){
            nums[i]=queue.poll();
        }
        queue = new PriorityQueue<>(new MaxHeap());
        for(int i=1;i<nums.length;i+=2){
            queue.add(nums[i]);
        }
        for(int i=1;i<nums.length;i+=2){
            nums[i]=queue.poll();
        }
        return nums;
    }
}

class MaxHeap implements Comparator<Integer> {
    public int compare(Integer ca,Integer cb){
        return cb-ca;
    }
}
"
2416,java,sort-even-and-odd-indices-independently,"class Solution {
    public int[] sortEvenOdd(int[] nums) {
        PriorityQueue<Integer> queue = new PriorityQueue<>();
        for(int i=0;i<nums.length;i++){
            queue.add(nums[i]);
        }
        for(int i=0;i<nums.length;i+=2){
            nums[i]=queue.poll();
        }
        queue = new PriorityQueue<>(new MaxHeap());
        for(int i=1;i<nums.length;i++){
            queue.add(nums[i]);
        }
        for(int i=1;i<nums.length;i+=2){
            nums[i]=queue.poll();
        }
        return nums;
    }
}
class MaxHeap implements Comparator<Integer>{
    public int compare(Integer ca,Integer cb){
        return cb-ca;
    }
}",None,"class Solution {
    public int[] sortEvenOdd(int[] nums) {
        PriorityQueue<Integer> minQueue = new PriorityQueue<>();
        for(int i = 0; i < nums.length; i+=2) {
            minQueue.add(nums[i]);
        }
        for(int i = 0; i < nums.length; i+=2) {
            nums[i] = minQueue.poll();
        }

        PriorityQueue<Integer> maxQueue = new PriorityQueue<>(Collections.reverseOrder());
        for(int i = 1; i < nums.length; i+=2){
            maxQueue.add(nums[i]);
        }
        for(int i = 1; i < nums.length; i+=2){
            nums[i] = maxQueue.poll();
        }
        return nums;
    }
}
"
2416,java,sort-even-and-odd-indices-independently,"class Solution {
    public int[] sortEvenOdd(int[] nums) {
        PriorityQueue<Integer> queue = new PriorityQueue<>();
        for(int i=0;i<nums.length;i++){
            queue.add(nums[i]);
        }
        for(int i=0;i<nums.length;i+=2){
            nums[i]=queue.poll();
        }
        queue = new PriorityQueue<>(new MaxHeap());
        for(int i=1;i<nums.length;i++){
            queue.add(nums[i]);
        }
        for(int i=1;i<nums.length;i+=2){
            nums[i]=queue.poll();
        }
        return nums;
    }
}
class MaxHeap implements Comparator<Integer>{
    public int compare(Integer ca,Integer cb){
        return cb-ca;
    }
}",None,"class Solution {
    public int[] sortEvenOdd(int[] nums) {
        // Priority queue for even elements (non-decreasing order)
        PriorityQueue<Integer> evenQueue = new PriorityQueue<>();
        
        // Priority queue for odd elements (non-increasing order)
        PriorityQueue<Integer> oddQueue = new PriorityQueue<>(new MaxHeapComparator());
        
        // Adding even indexed elements to evenQueue and odd indexed elements to oddQueue
        for(int i = 0; i < nums.length; i++) {
            if(i % 2 == 0) {
                evenQueue.add(nums[i]);
            } else {
                oddQueue.add(nums[i]);
            }
        }
        
        // Polling from the queues to fill the nums array again
        for(int i = 0; i < nums.length; i += 2) {
            if(!evenQueue.isEmpty()) {
                nums[i] = evenQueue.poll();
            }
        }
        for(int i = 1; i < nums.length; i += 2) {
            if(!oddQueue.isEmpty()) {
                nums[i] = oddQueue.poll();
            }
        }
        
        return nums;
    }
}

class MaxHeapComparator implements Comparator<Integer> {
    public int compare(Integer a, Integer b) {
        return b - a;
    }
}
"
2417,java,longest-common-prefix,"class Solution {
    public String longestCommonPrefix(String[] strs) {
        Arrays.sort(strs);
        String start = strs[0];
        String end = strs[strs.length];
        int count = 0;
        for (int i = 0; i < start.length(); i++) {
            if (start.charAt(i) == end.charAt(i)) {
                count++;
            } else {
                break;
            }
        }
        return end.substring(0, count);
    }
}",None,"class Solution {
    public String longestCommonPrefix(String[] strs) {
        Arrays.sort(strs);
        String start = strs[0];
        String end = strs[strs.length-1];
        int count = 0;
        for (int i = 0; i < start.length(); i++) {
            if (start.charAt(i) == end.charAt(i)) {
                count++;
            } else {
                break;
            }
        }
        return start.substring(0, count);
    }
}
"
2417,java,longest-common-prefix,"class Solution {
    public String longestCommonPrefix(String[] strs) {
        Arrays.sort(strs);
        String start = strs[0];
        String end = strs[strs.length];
        int count = 0;
        for (int i = 0; i < start.length(); i++) {
            if (start.charAt(i) == end.charAt(i)) {
                count++;
            } else {
                break;
            }
        }
        return end.substring(0, count);
    }
}",None,"class Solution {
    public String longestCommonPrefix(String[] strs) {
        Arrays.sort(strs);
        String start = strs[0];
        String end = strs[strs.length-1];
        int count = 0;
        for (int i = 0; i < start.length(); i++) {
            if (start.charAt(i) == end.charAt(i)) {
                count++;
            } else {
                break;
            }
        }
        return start.substring(0, count);
    }
}
"
2417,java,longest-common-prefix,"class Solution {
    public String longestCommonPrefix(String[] strs) {
        Arrays.sort(strs);
        String start = strs[0];
        String end = strs[strs.length];
        int count = 0;
        for (int i = 0; i < start.length(); i++) {
            if (start.charAt(i) == end.charAt(i)) {
                count++;
            } else {
                break;
            }
        }
        return end.substring(0, count);
    }
}",None,"class Solution {
    public String longestCommonPrefix(String[] strs) {
        Arrays.sort(strs);
        String start = strs[0];
        String end = strs[strs.length - 1];
        int count = 0;
        for (int i = 0; i < start.length(); i++) {
            if (start.charAt(i) == end.charAt(i)) {
                count++;
            } else {
                break;
            }
        }
        return start.substring(0, count);
    }
}
"
2418,java,minimum-operations-to-make-array-equal,"class Solution {
    public int minOperations(int n) {
        int result = 0;
        
        if (n % 2 == 0) {
            result = (n / 2) * (n / 2);
        } else {
            result = ((n + 1) / 2) * ((n + 1) / 2);
        }
        
        return result;
    }
}",None,"class Solution {
    public int minOperations(int n) {
        int result = 0;
        
        if (n % 2 == 0) {
            result = (n / 2) * (n / 2);
        } else {
            result = ((n - 1) / 2) * ((n + 1) / 2);
        }
        
        return result;
    }
}
"
2418,java,minimum-operations-to-make-array-equal,"class Solution {
    public int minOperations(int n) {
        int result = 0;
        
        if (n % 2 == 0) {
            result = (n / 2) * (n / 2);
        } else {
            result = ((n + 1) / 2) * ((n + 1) / 2);
        }
        
        return result;
    }
}",None,"class Solution {
    public int minOperations(int n) {
        int result = 0;
        
        if (n % 2 == 0) {
            result = (n / 2) * (n / 2);
        } else {
            result = ((n - 1) / 2) * ((n + 1) / 2);
        }
        
        return result;
    }
}
"
2418,java,minimum-operations-to-make-array-equal,"class Solution {
    public int minOperations(int n) {
        int result = 0;
        
        if (n % 2 == 0) {
            result = (n / 2) * (n / 2);
        } else {
            result = ((n + 1) / 2) * ((n + 1) / 2);
        }
        
        return result;
    }
}",None,"class Solution {
    public int minOperations(int n) {
        int result = 0;
        
        if (n % 2 == 0) {
            result = n * n / 4;
        } else {
            result = (n * n - 1) / 4;
        }
        
        return result;
    }
}
"
2419,java,count-the-number-of-good-subarrays,"class Solution {
        public long countGood(int[] nums, int k) {
        long ans = 0;
        HashMap<Integer, Integer> map = new HashMap<>();
        int j = 0;
        long countPairs = 0;

        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(nums[i])) {

                int val = map.get(nums[i]);
                countPairs -= ((long) val * (val - 1) / 2);
                map.put(nums[i], map.get(nums[i]) + 1);
                val = map.get(nums[i]);
                countPairs += ((long) val * (val - 1) / 2);

            } else{
                map.put(nums[i], 0);
            }
            
            while (j <= i && countPairs >= k) {
                int cur = map.get(nums[j]);
                countPairs -= (long) cur * (cur - 1) / 2;
                map.put(nums[j], cur - 1);
                cur = map.get(nums[j]);
                countPairs += (long) (cur ) * (cur -1) / 2;
                j++;
                ans += (nums.length - i);
            }

        }
        return ans;

    }
}",None,"class Solution {
        public long countGood(int[] nums, int k) {
        long ans = 0;
        HashMap<Integer, Integer> map = new HashMap<>();
        int j = 0;
        long countPairs = 0;

        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(nums[i])) {

                int val = map.get(nums[i]);
                countPairs -= ((long) val * (val - 1) / 2);
                map.put(nums[i], map.get(nums[i]) + 1);
                val = map.get(nums[i]);
                countPairs += ((long) val * (val - 1) / 2);

            } else{
                map.put(nums[i], 1);
            }
            
            while (j <= i && countPairs >= k) {
                int cur = map.get(nums[j]);
                countPairs -= (long) cur * (cur - 1) / 2;
                map.put(nums[j], cur - 1);
                cur = map.get(nums[j]);
                countPairs += (long) (cur ) * (cur -1) / 2;
                j++;
                ans += (nums.length - i);
            }

        }
        return ans;

    }
}
"
2419,java,count-the-number-of-good-subarrays,"class Solution {
        public long countGood(int[] nums, int k) {
        long ans = 0;
        HashMap<Integer, Integer> map = new HashMap<>();
        int j = 0;
        long countPairs = 0;

        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(nums[i])) {

                int val = map.get(nums[i]);
                countPairs -= ((long) val * (val - 1) / 2);
                map.put(nums[i], map.get(nums[i]) + 1);
                val = map.get(nums[i]);
                countPairs += ((long) val * (val - 1) / 2);

            } else{
                map.put(nums[i], 0);
            }
            
            while (j <= i && countPairs >= k) {
                int cur = map.get(nums[j]);
                countPairs -= (long) cur * (cur - 1) / 2;
                map.put(nums[j], cur - 1);
                cur = map.get(nums[j]);
                countPairs += (long) (cur ) * (cur -1) / 2;
                j++;
                ans += (nums.length - i);
            }

        }
        return ans;

    }
}",None,"class Solution {
    public long countGood(int[] nums, int k) {
        long ans = 0;
        HashMap<Integer, Integer> map = new HashMap<>();
        int j = 0;
        long countPairs = 0;

        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(nums[i])) {
                int val = map.get(nums[i]);
                countPairs -= ((long) val * (val - 1) / 2);
                map.put(nums[i], map.get(nums[i]) + 1);
                val = map.get(nums[i]);
                countPairs += ((long) val * (val - 1) / 2);

            } else{
                map.put(nums[i], 1);
            }
            
            while (j <= i && countPairs >= k) {
                int cur = map.get(nums[j]);
                countPairs -= (long) cur * (cur - 1) / 2;
                map.put(nums[j], cur - 1);
                cur = map.get(nums[j]);
                countPairs += (long) (cur) * (cur -1) / 2;
                j++;
                ans += (nums.length - i);
            }

        }
        return ans;

    }
}
"
2419,java,count-the-number-of-good-subarrays,"class Solution {
        public long countGood(int[] nums, int k) {
        long ans = 0;
        HashMap<Integer, Integer> map = new HashMap<>();
        int j = 0;
        long countPairs = 0;

        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(nums[i])) {

                int val = map.get(nums[i]);
                countPairs -= ((long) val * (val - 1) / 2);
                map.put(nums[i], map.get(nums[i]) + 1);
                val = map.get(nums[i]);
                countPairs += ((long) val * (val - 1) / 2);

            } else{
                map.put(nums[i], 0);
            }
            
            while (j <= i && countPairs >= k) {
                int cur = map.get(nums[j]);
                countPairs -= (long) cur * (cur - 1) / 2;
                map.put(nums[j], cur - 1);
                cur = map.get(nums[j]);
                countPairs += (long) (cur ) * (cur -1) / 2;
                j++;
                ans += (nums.length - i);
            }

        }
        return ans;

    }
}",None,"class Solution {
        public long countGood(int[] nums, int k) {
        long ans = 0;
        HashMap<Integer, Integer> map = new HashMap<>();
        int j = 0;
        long countPairs = 0;

        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(nums[i])) {

                int val = map.get(nums[i]);
                countPairs -= ((long) val * (val - 1) / 2);
                map.put(nums[i], map.get(nums[i]) + 1);
                val = map.get(nums[i]);
                countPairs += ((long) val * (val - 1) / 2);
                
            } else {
                map.put(nums[i], 1);
            }
            
            while (j <= i && countPairs >= k) {
                int cur = map.get(nums[j]);
                countPairs -= (long) cur * (cur - 1) / 2;
                map.put(nums[j], cur - 1);
                cur = map.get(nums[j]);
                countPairs += (long) (cur ) * (cur -1) / 2;
                j++;
                ans += (nums.length - i);
            }

        }
        return ans;

    }
}
"
2420,java,minimum-amount-of-time-to-fill-cups,"class Solution {
    public int fillCups(int[] amount) {
        Arrays.sort(amount);
        int ans = 0;
        int lo=0, hi=2;
        if(amount[0] == 0) lo++;
        if(lo==1 && amount[1]==0) return amount[2];

        else if(lo==1){
            ans += amount[hi];
            return ans;
        }
        while(amount[lo] != 0){
            ans++;
            amount[lo]--;
            amount[hi]--;
            if(amount[hi-1] > amount[hi]){
                int temp = amount[hi-1];
                amount[hi-1] = amount[hi];
                amount[hi] = temp;
            }
        }

        ans += amount[3];
        return ans;
    }
}",None,"class Solution {
    public int fillCups(int[] amount) {
        Arrays.sort(amount);
        int ans = 0;
        int lo=0, hi=2;

        if(amount[0] == 0) lo++;
        if(lo==1 && amount[1]==0) return amount[2];

        else if(lo==1){
            ans += amount[hi];
            return ans;
        }
        while(amount[lo] != 0){
            ans++;
            amount[lo]--;
            amount[hi]--;
            if(amount[hi-1] > amount[hi]){
                int temp = amount[hi-1];
                amount[hi-1] = amount[hi];
                amount[hi] = temp;
            }
        }
        if(hi < amount.length)
           ans += amount[hi];
        return ans;
    }
}
"
2420,java,minimum-amount-of-time-to-fill-cups,"class Solution {
    public int fillCups(int[] amount) {
        Arrays.sort(amount);
        int ans = 0;
        int lo=0, hi=2;
        if(amount[0] == 0) lo++;
        if(lo==1 && amount[1]==0) return amount[2];

        else if(lo==1){
            ans += amount[hi];
            return ans;
        }
        while(amount[lo] != 0){
            ans++;
            amount[lo]--;
            amount[hi]--;
            if(amount[hi-1] > amount[hi]){
                int temp = amount[hi-1];
                amount[hi-1] = amount[hi];
                amount[hi] = temp;
            }
        }

        ans += amount[3];
        return ans;
    }
}",None,"class Solution {
    public int fillCups(int[] amount) {
        Arrays.sort(amount);
        int ans = 0;
        int lo=0, hi=2;
        if(amount[0] == 0) lo++;
        if(lo==1 && amount[1]==0) return amount[2];

        else if(lo==1){
            ans += amount[hi];
            return ans;
        }
        while(amount[lo] != 0){
            ans++;
            amount[lo]--;
            amount[hi]--;
            if(amount[hi-1] > amount[hi]){
                int temp = amount[hi-1];
                amount[hi-1] = amount[hi];
                amount[hi] = temp;
            }
        }

        ans += amount[2];
        return ans;
    }
}
"
2420,java,minimum-amount-of-time-to-fill-cups,"class Solution {
    public int fillCups(int[] amount) {
        Arrays.sort(amount);
        int ans = 0;
        int lo=0, hi=2;
        if(amount[0] == 0) lo++;
        if(lo==1 && amount[1]==0) return amount[2];

        else if(lo==1){
            ans += amount[hi];
            return ans;
        }
        while(amount[lo] != 0){
            ans++;
            amount[lo]--;
            amount[hi]--;
            if(amount[hi-1] > amount[hi]){
                int temp = amount[hi-1];
                amount[hi-1] = amount[hi];
                amount[hi] = temp;
            }
        }

        ans += amount[3];
        return ans;
    }
}",None,"class Solution {
    public int fillCups(int[] amount) {
        Arrays.sort(amount);
        int ans = 0;
        int lo=0, hi=2;
        if(amount[0] == 0) lo++;
        if(lo==1 && amount[1]==0) return amount[2];

        else if(lo==1){
            ans += amount[1] + (amount[2] + 1) / 2;
            return ans;
        }
        while(amount[lo] != 0){
            ans++;
            amount[lo]--;
            amount[hi]--;
            if(hi != 1 && amount[hi-1] > amount[hi]){
                int temp = amount[hi-1];
                amount[hi-1] = amount[hi];
                amount[hi] = temp;
            }
        }

        ans += (amount[hi] + 1) / 2;
        return ans;
    }
}
"
2421,java,knight-probability-in-chessboard,"class Solution {
    public double knightProbability(int n, int k, int row, int column) {
        int[][] dir = {{-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}};
        double[][][] dp = new double[k + 1][n][n];
        dp[0][row][column] = 1.0;
        for (int i = 1; i <= k; i++) {
            for (int r = 0; r < n; r++) {
                for (int c = 0; c < n; c++) {
                    for (int[] d : dir) {
                        int newRow = r + d[0];
                        int newCol = c + d[1];
                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {
                            dp[i][r][c] += dp[i][newRow][newCol] / 8.0;
                        }
                    }
                }
            }
        }
        double output = 0.0;
        for (int r = 0; r < n; r++) {
            for (int c = 0; c < n; c++) {
                output += dp[k][r][c];
            }
        }
        return output;
    }
}",None,"class Solution {
    public double knightProbability(int n, int k, int row, int column) {
        int[][] dir = {{-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}};
        double[][][] dp = new double[k + 1][n][n];
        dp[0][row][column] = 1.0;
        for (int i = 1; i <= k; i++) {
            for (int r = 0; r < n; r++) {
                for (int c = 0; c < n; c++) {
                    for (int[] d : dir) {
                        int newRow = r + d[0];
                        int newCol = c + d[1];
                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {
                            dp[i][r][c] += dp[i-1][newRow][newCol] / 8.0;
                        }
                    }
                }
            }
        }
        double output = 0.0;
        for (int r = 0; r < n; r++) {
            for (int c = 0; c < n; c++) {
                output += dp[k][r][c];
            }
        }
        return output;
    }
}
"
2421,java,knight-probability-in-chessboard,"class Solution {
    public double knightProbability(int n, int k, int row, int column) {
        int[][] dir = {{-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}};
        double[][][] dp = new double[k + 1][n][n];
        dp[0][row][column] = 1.0;
        for (int i = 1; i <= k; i++) {
            for (int r = 0; r < n; r++) {
                for (int c = 0; c < n; c++) {
                    for (int[] d : dir) {
                        int newRow = r + d[0];
                        int newCol = c + d[1];
                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {
                            dp[i][r][c] += dp[i][newRow][newCol] / 8.0;
                        }
                    }
                }
            }
        }
        double output = 0.0;
        for (int r = 0; r < n; r++) {
            for (int c = 0; c < n; c++) {
                output += dp[k][r][c];
            }
        }
        return output;
    }
}",None,"class Solution {
    public double knightProbability(int n, int k, int row, int column) {
        int[][] dir = {{-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}};
        double[][][] dp = new double[k + 1][n][n];
        dp[0][row][column] = 1.0;
        for (int i = 1; i <= k; i++) {
            for (int r = 0; r < n; r++) {
                for (int c = 0; c < n; c++) {
                    for (int[] d : dir) {
                        int newRow = r + d[0];
                        int newCol = c + d[1];
                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {
                            dp[i][r][c] += dp[i-1][newRow][newCol] / 8.0;
                        }
                    }
                }
            }
        }
        double output = 0.0;
        for (int r = 0; r < n; r++) {
            for (int c = 0; c < n; c++) {
                output += dp[k][r][c];
            }
        }
        return output;
    }
}
"
2421,java,knight-probability-in-chessboard,"class Solution {
    public double knightProbability(int n, int k, int row, int column) {
        int[][] dir = {{-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}};
        double[][][] dp = new double[k + 1][n][n];
        dp[0][row][column] = 1.0;
        for (int i = 1; i <= k; i++) {
            for (int r = 0; r < n; r++) {
                for (int c = 0; c < n; c++) {
                    for (int[] d : dir) {
                        int newRow = r + d[0];
                        int newCol = c + d[1];
                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {
                            dp[i][r][c] += dp[i][newRow][newCol] / 8.0;
                        }
                    }
                }
            }
        }
        double output = 0.0;
        for (int r = 0; r < n; r++) {
            for (int c = 0; c < n; c++) {
                output += dp[k][r][c];
            }
        }
        return output;
    }
}",None,"class Solution {
    public double knightProbability(int n, int k, int row, int column) {
        int[][] dir = {{-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}};
        double[][][] dp = new double[k + 1][n][n];
        dp[0][row][column] = 1.0;
        for (int i = 0; i < k; i++) {
            for (int r = 0; r < n; r++) {
                for (int c = 0; c < n; c++) {
                    for (int[] d : dir) {
                        int newRow = r + d[0];
                        int newCol = c + d[1];
                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {
                            dp[i+1][newRow][newCol] += dp[i][r][c] / 8.0;
                        }
                    }
                }
            }
        }
        double output = 0.0;
        for (int r = 0; r < n; r++) {
            for (int c = 0; c < n; c++) {
                output += dp[k][r][c];
            }
        }
        return output;
    }
}
"
2422,java,airplane-seat-assignment-probability,"class Solution {
    public double nthPersonGetsNthSeat(int n) {
        if(n==1)
        return 1.00000;
        else
        return 1.50000;
    }
}",None,"class Solution {
    public double nthPersonGetsNthSeat(int n) {
        if(n==1)
        return 1.00000;
        else
        return 0.50000;
    }
}
"
2422,java,airplane-seat-assignment-probability,"class Solution {
    public double nthPersonGetsNthSeat(int n) {
        if(n==1)
        return 1.00000;
        else
        return 1.50000;
    }
}",None,"class Solution {
    public double nthPersonGetsNthSeat(int n) {
        if(n == 1)
            return 1.00000;
        else
            return 0.50000;
    }
}
"
2422,java,airplane-seat-assignment-probability,"class Solution {
    public double nthPersonGetsNthSeat(int n) {
        if(n==1)
        return 1.00000;
        else
        return 1.50000;
    }
}",None,"class Solution {
    public double nthPersonGetsNthSeat(int n) {
        if(n == 1)
            return 1.00000;
        else
            return 0.50000;
    }
}
"
2423,java,intersection-of-two-linked-lists,"class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int ac = 0;
        int bc = 0;
        ListNode a = headA;
        ListNode b = headB;
        while(a != null){
            ac++;
            a = a.next;
        }
        while(b != null){
            bc++;
            b = b.next;
        }
        while(ac > bc){
            ac--;
            headA = headA.next;
        }
        while(bc > ac){
            bc--;
            headB = headB.next;
        }
        
        while(headA != headB){
            headA = headA.next;
            headB = headB.next;
        }
        
        return b;  
    }
}",None,"class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int ac = 0;
        int bc = 0;
        ListNode a = headA;
        ListNode b = headB;
        while(a != null){
            ac++;
            a = a.next;
        }
        while(b != null){
            bc++;
            b = b.next;
        }
        a = headA;
        b = headB;
        while(ac > bc){
            ac--;
            a = a.next;
        }
        while(bc > ac){
            bc--;
            b = b.next;
        }

        while(a != b){
            a = a.next;
            b = b.next;
        }

        return a;  
    }
}
"
2423,java,intersection-of-two-linked-lists,"class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int ac = 0;
        int bc = 0;
        ListNode a = headA;
        ListNode b = headB;
        while(a != null){
            ac++;
            a = a.next;
        }
        while(b != null){
            bc++;
            b = b.next;
        }
        while(ac > bc){
            ac--;
            headA = headA.next;
        }
        while(bc > ac){
            bc--;
            headB = headB.next;
        }
        
        while(headA != headB){
            headA = headA.next;
            headB = headB.next;
        }
        
        return b;  
    }
}",None,"class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int ac = 0;
        int bc = 0;
        ListNode a = headA;
        ListNode b = headB;
        while(a != null){
            ac++;
            a = a.next;
        }
        while(b != null){
            bc++;
            b = b.next;
        }
        while(ac > bc){
            ac--;
            headA = headA.next;
        }
        while(bc > ac){
            bc--;
            headB = headB.next;
        }
        
        while(headA != headB){
            headA = headA.next;
            headB = headB.next;
        }
        
        return headA;  
    }
}
"
2423,java,intersection-of-two-linked-lists,"class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int ac = 0;
        int bc = 0;
        ListNode a = headA;
        ListNode b = headB;
        while(a != null){
            ac++;
            a = a.next;
        }
        while(b != null){
            bc++;
            b = b.next;
        }
        while(ac > bc){
            ac--;
            headA = headA.next;
        }
        while(bc > ac){
            bc--;
            headB = headB.next;
        }
        
        while(headA != headB){
            headA = headA.next;
            headB = headB.next;
        }
        
        return b;  
    }
}",None,"class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int ac = 0;
        int bc = 0;
        ListNode a = headA;
        ListNode b = headB;
        while(a != null){
            ac++;
            a = a.next;
        }
        while(b != null){
            bc++;
            b = b.next;
        }
        while(ac > bc){
            ac--;
            headA = headA.next;
        }
        while(bc > ac){
            bc--;
            headB = headB.next;
        }
        
        while(headA != headB){
            headA = headA.next;
            headB = headB.next;
        }
        
        return headA;  
    }
}
"
2424,java,maximum-average-pass-ratio,"class Solution {
    public double maxAverageRatio(int[][] classes, int extraStudents) {
        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());
        for(int[] cl : classes){
            pq.add(new Class(cl));
        }
        while(extraStudents > 0){
            Class c = pq.remove();
            c.addExtraStudent();
            extraStudents--;
        }
        double sum = 0;
        while(!pq.isEmpty()){
            Class c = pq.remove();
            sum += c.pass / c.total;
        }
        return sum / classes.length;
    }
}
class Class{
    double pass;
    double total;
    double inc;
    public Class(int[] cl){
        pass = cl[0];
        total = cl[1];
        inc = (pass + 1) / (total + 1) - pass / total;
    }
    public void addExtraStudent(){
        pass += 1;
        total += 1;
        inc = (pass + 1) / (total + 1) - pass / total;
    }
}
class Compare implements Comparator<Class>{
    public int compare(Class c1, Class c2){
        if(c1.inc < c2.inc){
            return 1;
        }else if(c1.inc > c2.inc){
            return -1;
        }else{
            return 0;
        }
    }
}",None,"class Solution {
    public double maxAverageRatio(int[][] classes, int extraStudents) {
        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());
        for(int[] cl : classes){
            pq.add(new Class(cl));
        }
        while(extraStudents > 0){
            Class c = pq.poll();
            c.addExtraStudent();
            pq.offer(c);
            extraStudents--;
        }
        double sum = 0;
        while(!pq.isEmpty()){
            Class c = pq.poll();
            sum += c.pass / c.total;
        }
        return sum / classes.length;
    }
}
class Class{
    double pass;
    double total;
    double inc;
    public Class(int[] cl){
        pass = cl[0];
        total = cl[1];
        inc = increaseWithExtraStudent();
    }
    public void addExtraStudent(){
        pass += 1;
        total += 1;
        inc = increaseWithExtraStudent();
    }

    public double increaseWithExtraStudent()
    {
        return (pass + 1) / (total + 1) - pass / total;
    }
}
class Compare implements Comparator<Class>{
    public int compare(Class c1, Class c2){
        if(c1.inc < c2.inc){
            return 1;
        }else if(c1.inc > c2.inc){
            return -1;
        }else{
            return 0;
        }
    }
}
"
2424,java,maximum-average-pass-ratio,"class Solution {
    public double maxAverageRatio(int[][] classes, int extraStudents) {
        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());
        for(int[] cl : classes){
            pq.add(new Class(cl));
        }
        while(extraStudents > 0){
            Class c = pq.remove();
            c.addExtraStudent();
            extraStudents--;
        }
        double sum = 0;
        while(!pq.isEmpty()){
            Class c = pq.remove();
            sum += c.pass / c.total;
        }
        return sum / classes.length;
    }
}
class Class{
    double pass;
    double total;
    double inc;
    public Class(int[] cl){
        pass = cl[0];
        total = cl[1];
        inc = (pass + 1) / (total + 1) - pass / total;
    }
    public void addExtraStudent(){
        pass += 1;
        total += 1;
        inc = (pass + 1) / (total + 1) - pass / total;
    }
}
class Compare implements Comparator<Class>{
    public int compare(Class c1, Class c2){
        if(c1.inc < c2.inc){
            return 1;
        }else if(c1.inc > c2.inc){
            return -1;
        }else{
            return 0;
        }
    }
}",None,"class Solution {
    public double maxAverageRatio(int[][] classes, int extraStudents) {
        PriorityQueue<Class> pq = new PriorityQueue<>((c1, c2) -> Double.compare(c2.inc, c1.inc));
        for(int[] cl : classes){
            pq.add(new Class(cl));
        }
        while(extraStudents-- > 0){
            Class c = pq.poll();
            c.addExtraStudent();
            pq.add(c);
        }
        double sum = 0;
        while(!pq.isEmpty()){
            Class c = pq.poll();
            sum += c.getRatio();
        }
        return sum / classes.length;
    }
}
class Class {
    double pass;
    double total;
    double inc;
    public Class(int[] cl){
        pass = cl[0];
        total = cl[1];
        calculateInc();
    }
    public void addExtraStudent(){
        pass += 1;
        total += 1;
        calculateInc();
    }
    void calculateInc() {
        inc = ((pass + 1) / (total + 1)) - (pass / total);
    }
    double getRatio() {
        return pass / total;
    }
}
"
2424,java,maximum-average-pass-ratio,"class Solution {
    public double maxAverageRatio(int[][] classes, int extraStudents) {
        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());
        for(int[] cl : classes){
            pq.add(new Class(cl));
        }
        while(extraStudents > 0){
            Class c = pq.remove();
            c.addExtraStudent();
            extraStudents--;
        }
        double sum = 0;
        while(!pq.isEmpty()){
            Class c = pq.remove();
            sum += c.pass / c.total;
        }
        return sum / classes.length;
    }
}
class Class{
    double pass;
    double total;
    double inc;
    public Class(int[] cl){
        pass = cl[0];
        total = cl[1];
        inc = (pass + 1) / (total + 1) - pass / total;
    }
    public void addExtraStudent(){
        pass += 1;
        total += 1;
        inc = (pass + 1) / (total + 1) - pass / total;
    }
}
class Compare implements Comparator<Class>{
    public int compare(Class c1, Class c2){
        if(c1.inc < c2.inc){
            return 1;
        }else if(c1.inc > c2.inc){
            return -1;
        }else{
            return 0;
        }
    }
}",None,"class Solution {
    public double maxAverageRatio(int[][] classes, int extraStudents) {
        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());
        for(int[] cl : classes){
            Class c = new Class(cl);
            pq.add(c);
        }
        while(extraStudents > 0){
            Class c = pq.remove();
            c.addExtraStudent();
            pq.add(c);
            extraStudents--;
        }
        double sum = 0;
        while(!pq.isEmpty()){
            Class c = pq.remove();
            sum += c.pass / c.total;
        }
        return sum / classes.length;
    }
}
class Class{
    double pass;
    double total;
    double inc;
    public Class(int[] cl){
        pass = cl[0];
        total = cl[1];
        inc = (pass + 1) / (total + 1) - pass / total;
    }
    public void addExtraStudent(){
        pass += 1;
        total += 1;
        inc = (pass + 1) / (total + 1) - pass / total;
    }
}
class Compare implements Comparator<Class>{
    public int compare(Class c1, Class c2){
        if(c1.inc < c2.inc){
            return 1;
        }else if(c1.inc > c2.inc){
            return -1;
        }else{
            return 0;
        }
    }
}
"
2757,java,set-matrix-zeroes,"class Solution {
    public void setZeroes(int[][] A) 
    {
       
       int row=A.length;
        int col=A[0].length;
        int x=1,y=1;
        for(int i=0;i<col;i++){
            if(A[0][i]==0){
                x=0;
               break;}
        } 
        for(int i=0;i<row;i++){
            if(A[i][0]==0){
                y=1;
               break;}
        } 
        for(int i=1;i<row;i++)
            for(int j=1;j<col;j++)
            {
                if(A[i][j]==0)
                {
                    A[i][0]=0;
                    A[0][j]=0;
                }
            }
        
       for(int j=1;j<col;j++)
        {
           if(A[0][j]==0)
           {
               for(int i=1;i<row;i++)
                   A[i][j]=0;
           }
        }
        
        for(int i=1;i<row;i++)
        {
            if(A[i][0]==0)
            {
                for(int j=0;j<col;j++)
                    A[i][j]=0;
            }
        }
        if(x==0)
        for(int i=0;i<col;i++)
            A[0][i]=0;
               
        if(y==0)
        for(int i=0;i<row;i++)
            A[i][0]=0;

        System.gc();
    }
}",None,"class Solution {
    public void setZeroes(int[][] A) 
    {
       
       int row=A.length;
        int col=A[0].length;
        int x=1,y=1;
        for(int i=0;i<col;i++){
            if(A[0][i]==0){
                x=0;
               break;}
        } 
        for(int i=0;i<row;i++){
            if(A[i][0]==0){
                y=0;
               break;}
        } 
        for(int i=1;i<row;i++)
            for(int j=1;j<col;j++)
            {
                if(A[i][j]==0)
                {
                    A[i][0]=0;
                    A[0][j]=0;
                }
            }
        
       for(int j=1;j<col;j++)
        {
           if(A[0][j]==0)
           {
               for(int i=1;i<row;i++)
                   A[i][j]=0;
           }
        }
        
        for(int i=1;i<row;i++)
        {
            if(A[i][0]==0)
            {
                for(int j=0;j<col;j++)
                    A[i][j]=0;
            }
        }
        if(x==0)
        for(int i=0;i<col;i++)
            A[0][i]=0;
               
        if(y==0)
        for(int i=0;i<row;i++)
            A[i][0]=0;
    }
}
"
2757,java,set-matrix-zeroes,"class Solution {
    public void setZeroes(int[][] A) 
    {
       
       int row=A.length;
        int col=A[0].length;
        int x=1,y=1;
        for(int i=0;i<col;i++){
            if(A[0][i]==0){
                x=0;
               break;}
        } 
        for(int i=0;i<row;i++){
            if(A[i][0]==0){
                y=1;
               break;}
        } 
        for(int i=1;i<row;i++)
            for(int j=1;j<col;j++)
            {
                if(A[i][j]==0)
                {
                    A[i][0]=0;
                    A[0][j]=0;
                }
            }
        
       for(int j=1;j<col;j++)
        {
           if(A[0][j]==0)
           {
               for(int i=1;i<row;i++)
                   A[i][j]=0;
           }
        }
        
        for(int i=1;i<row;i++)
        {
            if(A[i][0]==0)
            {
                for(int j=0;j<col;j++)
                    A[i][j]=0;
            }
        }
        if(x==0)
        for(int i=0;i<col;i++)
            A[0][i]=0;
               
        if(y==0)
        for(int i=0;i<row;i++)
            A[i][0]=0;

        System.gc();
    }
}",None,"class Solution {
    public void setZeroes(int[][] A) 
    {
       
       int row=A.length;
        int col=A[0].length;
        int x=1,y=1;
        for(int i=0;i<col;i++){
            if(A[0][i]==0){
                x=0;
               break;}
        } 
        for(int i=0;i<row;i++){
            if(A[i][0]==0){
                y=0;
               break;}
        } 
        for(int i=1;i<row;i++)
            for(int j=1;j<col;j++)
            {
                if(A[i][j]==0)
                {
                    A[i][0]=0;
                    A[0][j]=0;
                }
            }
        
       for(int j=1;j<col;j++)
        {
           if(A[0][j]==0)
           {
               for(int i=1;i<row;i++)
                   A[i][j]=0;
           }
        }
        
        for(int i=1;i<row;i++)
        {
            if(A[i][0]==0)
            {
                for(int j=0;j<col;j++)
                    A[i][j]=0;
            }
        }
        if(x==0)
        for(int i=0;i<col;i++)
            A[0][i]=0;
               
        if(y==0)
        for(int i=0;i<row;i++)
            A[i][0]=0;

        System.gc();
    }
}
"
2757,java,set-matrix-zeroes,"class Solution {
    public void setZeroes(int[][] A) 
    {
       
       int row=A.length;
        int col=A[0].length;
        int x=1,y=1;
        for(int i=0;i<col;i++){
            if(A[0][i]==0){
                x=0;
               break;}
        } 
        for(int i=0;i<row;i++){
            if(A[i][0]==0){
                y=1;
               break;}
        } 
        for(int i=1;i<row;i++)
            for(int j=1;j<col;j++)
            {
                if(A[i][j]==0)
                {
                    A[i][0]=0;
                    A[0][j]=0;
                }
            }
        
       for(int j=1;j<col;j++)
        {
           if(A[0][j]==0)
           {
               for(int i=1;i<row;i++)
                   A[i][j]=0;
           }
        }
        
        for(int i=1;i<row;i++)
        {
            if(A[i][0]==0)
            {
                for(int j=0;j<col;j++)
                    A[i][j]=0;
            }
        }
        if(x==0)
        for(int i=0;i<col;i++)
            A[0][i]=0;
               
        if(y==0)
        for(int i=0;i<row;i++)
            A[i][0]=0;

        System.gc();
    }
}",None,"class Solution {
    public void setZeroes(int[][] A) 
    {
       
       int row=A.length;
        int col=A[0].length;
        int x=1,y=1;
        for(int i=0;i<col;i++){
            if(A[0][i]==0){
                x=0;
               break;}
        } 
        for(int i=0;i<row;i++){
            if(A[i][0]==0){
                y=0;
               break;}
        } 
        for(int i=1;i<row;i++)
            for(int j=1;j<col;j++)
            {
                if(A[i][j]==0)
                {
                    A[i][0]=0;
                    A[0][j]=0;
                }
            }
        
       for(int j=1;j<col;j++)
        {
           if(A[0][j]==0)
           {
               for(int i=1;i<row;i++)
                   A[i][j]=0;
           }
        }
        
        for(int i=1;i<row;i++)
        {
            if(A[i][0]==0)
            {
                for(int j=0;j<col;j++)
                    A[i][j]=0;
            }
        }
        if(x==0)
        for(int i=0;i<col;i++)
            A[0][i]=0;
               
        if(y==0)
        for(int i=0;i<row;i++)
            A[i][0]=0;
    }
}
"
2758,java,maximum-number-of-points-from-grid-queries,"class Solution {
    public int[] maxPoints(int[][] a, int[] q) {
        
        int n = a.length;
        int m = a[0].length;
        
        int l = q.length;
        int[][] p = new int[l][2];
        
        for(int i = 0 ; i < l ; i++) {
            
            p[i][0] = i;
            p[i][1] = q[i];
        }
        
        Arrays.sort(p, (o1,o2)-> {
            
            if(o1[1] == o2[1]) {
                
                return Integer.compare(o1[0],o2[0]);
            }
            
            return Integer.compare(o1[1],o2[1]);
        });
        
        PriorityQueue<int[]> qu = new PriorityQueue<>((o1,o2)->{
            
            return Integer.compare(a[o1[0]][o1[1]],a[o2[0]][o2[1]]);
        });
        
        qu.add(new int[]{0,1}); 
        
        boolean[][] v = new boolean[n][m];
        int cnt = 0;
        int idx = 0;
        
        while(qu.size() > 0 && idx < l) {
            
            int[] f = qu.remove();
            int r = f[0] , c = f[1];
            
            if(v[r][c]) continue;
            
            v[r][c] = true;
            
            if(a[r][c] < p[idx][1]) {
                
                cnt++;
            }
            else{
                
                q[p[idx][0]] = cnt;
                idx++;
                qu.add(f);
                v[r][c] = false;
                continue;
            }
            
            if(c+1 < m && v[r][c+1] == false) qu.add(new int[]{r,c+1});
            if(r+1 < n && v[r+1][c] == false) qu.add(new int[]{r+1,c});
            if(r-1 >=0 && v[r-1][c] == false) qu.add(new int[]{r-1,c});
            if(c-1 >= 0 && v[r][c-1] == false) qu.add(new int[]{r,c-1});
        }
        
        while(idx < l) {
            
            q[p[idx][0]] = cnt;
            idx++;
        }
        
        return q;
    }
}",None,"class Solution {
    public int[] maxPoints(int[][] a, int[] q) {
        
        int n = a.length;
        int m = a[0].length;
        
        int l = q.length;
        int[][] p = new int[l][2];
        
        for(int i = 0 ; i < l ; i++) {
            
            p[i][0] = i;
            p[i][1] = q[i];
        }
        
        Arrays.sort(p, (o1,o2)-> {
            
            if(o1[1] == o2[1]) {
                
                return Integer.compare(o1[0],o2[0]);
            }
            
            return Integer.compare(o1[1],o2[1]);
        });
        
        PriorityQueue<int[]> qu = new PriorityQueue<>((o1,o2)->{
            
            return Integer.compare(a[o1[0]][o1[1]],a[o2[0]][o2[1]]);
        });
        
        qu.add(new int[]{0,0}); // Bug Fix: The top-left cell is grid[0][0], not grid[0][1].
        
        boolean[][] v = new boolean[n][m];
        int cnt = 0;
        int idx = 0;
        
        while(qu.size() > 0 && idx < l) {
            
            int[] f = qu.poll(); // Bug Fix: Use poll instead of remove.
            int r = f[0] , c = f[1];
            
            if(v[r][c]) continue;
            
            v[r][c] = true;
            
            if(a[r][c] < p[idx][1]) {
                
                cnt++;
            }
            else{
                
                q[p[idx][0]] = cnt;
                cnt = 0; // Bug Fix: The count should be reset for the next query.
                idx++;
                if(idx < l && a[r][c] < p[idx][1]) qu.add(f); // Add f back only if the current cell value is smaller than the next query.
                v[r][c] = false;
                continue;
            }
            
            if(c+1 < m && v[r][c+1] == false) qu.add(new int[]{r,c+1});
            if(r+1 < n && v[r+1][c] == false) qu.add(new int[]{r+1,c});
            if(r-1 >=0 && v[r-1][c] == false) qu.add(new int[]{r-1,c});
            if(c-1 >= 0 && v[r][c-1] == false) qu.add(new int[]{r,c-1});
        }
        
        while(idx < l) {
            
            q[p[idx][0]] = cnt;
            idx++;
        }
        
        return q;
    }
}
"
2758,java,maximum-number-of-points-from-grid-queries,"class Solution {
    public int[] maxPoints(int[][] a, int[] q) {
        
        int n = a.length;
        int m = a[0].length;
        
        int l = q.length;
        int[][] p = new int[l][2];
        
        for(int i = 0 ; i < l ; i++) {
            
            p[i][0] = i;
            p[i][1] = q[i];
        }
        
        Arrays.sort(p, (o1,o2)-> {
            
            if(o1[1] == o2[1]) {
                
                return Integer.compare(o1[0],o2[0]);
            }
            
            return Integer.compare(o1[1],o2[1]);
        });
        
        PriorityQueue<int[]> qu = new PriorityQueue<>((o1,o2)->{
            
            return Integer.compare(a[o1[0]][o1[1]],a[o2[0]][o2[1]]);
        });
        
        qu.add(new int[]{0,1}); 
        
        boolean[][] v = new boolean[n][m];
        int cnt = 0;
        int idx = 0;
        
        while(qu.size() > 0 && idx < l) {
            
            int[] f = qu.remove();
            int r = f[0] , c = f[1];
            
            if(v[r][c]) continue;
            
            v[r][c] = true;
            
            if(a[r][c] < p[idx][1]) {
                
                cnt++;
            }
            else{
                
                q[p[idx][0]] = cnt;
                idx++;
                qu.add(f);
                v[r][c] = false;
                continue;
            }
            
            if(c+1 < m && v[r][c+1] == false) qu.add(new int[]{r,c+1});
            if(r+1 < n && v[r+1][c] == false) qu.add(new int[]{r+1,c});
            if(r-1 >=0 && v[r-1][c] == false) qu.add(new int[]{r-1,c});
            if(c-1 >= 0 && v[r][c-1] == false) qu.add(new int[]{r,c-1});
        }
        
        while(idx < l) {
            
            q[p[idx][0]] = cnt;
            idx++;
        }
        
        return q;
    }
}",None,"class Solution {
    public int[] maxPoints(int[][] a, int[] q) {
        
        int n = a.length;
        int m = a[0].length;
        
        int l = q.length;
        int[][] p = new int[l][2];
        
        for(int i = 0 ; i < l ; i++) {
            
            p[i][0] = i;
            p[i][1] = q[i];
        }
        
        Arrays.sort(p, (o1,o2)-> {
            
            if(o1[1] == o2[1]) {
                
                return Integer.compare(o1[0],o2[0]);
            }
            
            return Integer.compare(o1[1],o2[1]);
        });
        
        PriorityQueue<int[]> qu = new PriorityQueue<>((o1,o2)->{
            
            return Integer.compare(a[o2[0]][o2[1]],a[o1[0]][o1[1]]);
        });
        
        qu.add(new int[]{0,0}); 
        
        boolean[][] v = new boolean[n][m];
        int cnt = 0;
        int idx = 0;
        
        while(qu.size() > 0 && idx < l) {
            
            int[] f = qu.remove();
            int r = f[0] , c = f[1];
            
            if(v[r][c]) continue;
            
            v[r][c] = true;
            
            if(a[r][c] < p[idx][1]) {
                
                cnt++;
            }
            else{
                
                q[p[idx][0]] = cnt;
                cnt = 0;
                idx++;
                qu.add(f);
                v[r][c] = false;
                continue;
            }
            
            if(c+1 < m && v[r][c+1] == false) qu.add(new int[]{r,c+1});
            if(r+1 < n && v[r+1][c] == false) qu.add(new int[]{r+1,c});
            if(r-1 >=0 && v[r-1][c] == false) qu.add(new int[]{r-1,c});
            if(c-1 >= 0 && v[r][c-1] == false) qu.add(new int[]{r,c-1});
        }
        
        while(idx < l) {
            
            q[p[idx][0]] = cnt;
            idx++;
        }
        
        return q;
    }
}
"
2758,java,maximum-number-of-points-from-grid-queries,"class Solution {
    public int[] maxPoints(int[][] a, int[] q) {
        
        int n = a.length;
        int m = a[0].length;
        
        int l = q.length;
        int[][] p = new int[l][2];
        
        for(int i = 0 ; i < l ; i++) {
            
            p[i][0] = i;
            p[i][1] = q[i];
        }
        
        Arrays.sort(p, (o1,o2)-> {
            
            if(o1[1] == o2[1]) {
                
                return Integer.compare(o1[0],o2[0]);
            }
            
            return Integer.compare(o1[1],o2[1]);
        });
        
        PriorityQueue<int[]> qu = new PriorityQueue<>((o1,o2)->{
            
            return Integer.compare(a[o1[0]][o1[1]],a[o2[0]][o2[1]]);
        });
        
        qu.add(new int[]{0,1}); 
        
        boolean[][] v = new boolean[n][m];
        int cnt = 0;
        int idx = 0;
        
        while(qu.size() > 0 && idx < l) {
            
            int[] f = qu.remove();
            int r = f[0] , c = f[1];
            
            if(v[r][c]) continue;
            
            v[r][c] = true;
            
            if(a[r][c] < p[idx][1]) {
                
                cnt++;
            }
            else{
                
                q[p[idx][0]] = cnt;
                idx++;
                qu.add(f);
                v[r][c] = false;
                continue;
            }
            
            if(c+1 < m && v[r][c+1] == false) qu.add(new int[]{r,c+1});
            if(r+1 < n && v[r+1][c] == false) qu.add(new int[]{r+1,c});
            if(r-1 >=0 && v[r-1][c] == false) qu.add(new int[]{r-1,c});
            if(c-1 >= 0 && v[r][c-1] == false) qu.add(new int[]{r,c-1});
        }
        
        while(idx < l) {
            
            q[p[idx][0]] = cnt;
            idx++;
        }
        
        return q;
    }
}",None,"class Solution {
    public int[] maxPoints(int[][] a, int[] q) {
        int n = a.length;
        int m = a[0].length;
        
        int l = q.length;
        int[][] p = new int[l][2];
        
        for(int i = 0 ; i < l ; i++) {
            p[i][0] = i;
            p[i][1] = q[i];  
        }
        
        Arrays.sort(p, (o1,o2) -> Integer.compare(o2[1],o1[1]));
        
        PriorityQueue<int[]> qu = new PriorityQueue<>((o1,o2)-> Integer.compare(a[o2[0]][o2[1]],a[o1[0]][o1[1]]));
        
        qu.add(new int[]{0,0}); 
        
        boolean[][] v = new boolean[n][m];
        int cnt = 0;
        int idx = 0;
        
        while(qu.size() > 0 && idx < l) {
            int[] f = qu.remove();
            int r = f[0] , c = f[1];
            
            if(v[r][c]) continue;
            
            v[r][c] = true;
            
            if(a[r][c] < p[idx][1]) {
                
                cnt++;
            }
            else{
                
                q[p[idx][0]] = cnt;
                idx++;
                qu.add(f);
                v[r][c] = false;
                continue;
            }
            
            if(c+1 < m && !v[r][c+1]) qu.add(new int[]{r,c+1});
            if(r+1 < n && !v[r+1][c]) qu.add(new int[]{r+1,c});
            if(r-1 >=0 && !v[r-1][c]) qu.add(new int[]{r-1,c});
            if(c-1 >= 0 && !v[r][c-1]) qu.add(new int[]{r,c-1});
        }
        
        while(idx < l) {
            
            q[p[idx][0]] = cnt;
            idx++;
        }
        
        return q;
    }
}
"
2759,java,minimum-time-to-visit-a-cell-in-a-grid,"class Solution {
    private static final int[][] DIRS = new int[][] { { 1, 0 }, { -1, 0}, { 0, 1 }, { 0, -1 } };
    public int minimumTime(int[][] grid) {
        if (grid[0][1] > 1 && grid[1][0] > 1) {
            return -1;
        }
        
        int m = grid.length;
        int n = grid[0].length;
        
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        heap.offer(new int[] { 0, 0, 0 });
        
        boolean[][] visited = new boolean[m][n];
        
        while (!heap.isEmpty()) {
            int[] entry = heap.poll();
            int row = entry[0];
            int col = entry[1];
            int time = entry[2];
            if (row == m - 1 && col == n - 1) {
                return time;
            }
            if (visited[row][col]) {
                continue;
            }
            visited[row][col] = false;
                
            for (int[] dir : DIRS) {
                int r = row + dir[0];
                int c = col + dir[1];
                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) {
                    continue;
                }
                
                if (grid[r][c] <= time + 1) {
                    heap.offer(new int[] { r, c, time + 1 });
                } else {
                    int diff = grid[r][c] - time;
                    if (diff % 2 == 1) {
                        heap.offer(new int[] { r, c, grid[r][c] });
                    } else {
                        heap.offer(new int[] { r, c, grid[r][c] + 1 });
                    }
                }
            }
        }
        return -1;
    }
}",None,"class Solution {
    private static final int[][] DIRS = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

    public int minimumTime(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        heap.offer(new int[]{0, 0, 0});

        boolean[][] visited = new boolean[m][n];

        while (!heap.isEmpty()) {
            int[] entry = heap.poll();
            int row = entry[0];
            int col = entry[1];
            int time = entry[2];
            if (row == m - 1 && col == n - 1) {
                return time;
            }
            if (visited[row][col]) {
                continue;
            }
            visited[row][col] = true;

            for (int[] dir : DIRS) {
                int r = row + dir[0];
                int c = col + dir[1];
                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) {
                    continue;
                }

                if (grid[r][c] <= time + 1) {
                    heap.offer(new int[]{r, c, time + 1});
                } else {
                    int diff = grid[r][c] - time;
                    if (diff % 2 == 1) {
                        heap.offer(new int[]{r, c, grid[r][c]});
                    } else {
                        heap.offer(new int[]{r, c, grid[r][c] + 1});
                    }
                }
            }
        }
        return -1;
    }
}
"
2759,java,minimum-time-to-visit-a-cell-in-a-grid,"class Solution {
    private static final int[][] DIRS = new int[][] { { 1, 0 }, { -1, 0}, { 0, 1 }, { 0, -1 } };
    public int minimumTime(int[][] grid) {
        if (grid[0][1] > 1 && grid[1][0] > 1) {
            return -1;
        }
        
        int m = grid.length;
        int n = grid[0].length;
        
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        heap.offer(new int[] { 0, 0, 0 });
        
        boolean[][] visited = new boolean[m][n];
        
        while (!heap.isEmpty()) {
            int[] entry = heap.poll();
            int row = entry[0];
            int col = entry[1];
            int time = entry[2];
            if (row == m - 1 && col == n - 1) {
                return time;
            }
            if (visited[row][col]) {
                continue;
            }
            visited[row][col] = false;
                
            for (int[] dir : DIRS) {
                int r = row + dir[0];
                int c = col + dir[1];
                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) {
                    continue;
                }
                
                if (grid[r][c] <= time + 1) {
                    heap.offer(new int[] { r, c, time + 1 });
                } else {
                    int diff = grid[r][c] - time;
                    if (diff % 2 == 1) {
                        heap.offer(new int[] { r, c, grid[r][c] });
                    } else {
                        heap.offer(new int[] { r, c, grid[r][c] + 1 });
                    }
                }
            }
        }
        return -1;
    }
}",None,"class Solution {
    private static final int[][] DIRS = new int[][] { { 1, 0 }, { -1, 0}, { 0, 1 }, { 0, -1 } };
    public int minimumTime(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        heap.offer(new int[] { 0, 0, 0 });
        
        boolean[][] visited = new boolean[m][n];
        
        while (!heap.isEmpty()) {
            int[] entry = heap.poll();
            int row = entry[0];
            int col = entry[1];
            int time = entry[2];
            if (row == m - 1 && col == n - 1) {
                return time;
            }
            if (visited[row][col]) {
                continue;
            }
            visited[row][col] = true;
                
            for (int[] dir : DIRS) {
                int r = row + dir[0];
                int c = col + dir[1];
                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) {
                    continue;
                }
                
                int nextTime = Math.max(time+1, grid[r][c]);
                heap.offer(new int[] { r, c, nextTime });
            }
        }
        return -1;
    }
}
"
2759,java,minimum-time-to-visit-a-cell-in-a-grid,"class Solution {
    private static final int[][] DIRS = new int[][] { { 1, 0 }, { -1, 0}, { 0, 1 }, { 0, -1 } };
    public int minimumTime(int[][] grid) {
        if (grid[0][1] > 1 && grid[1][0] > 1) {
            return -1;
        }
        
        int m = grid.length;
        int n = grid[0].length;
        
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        heap.offer(new int[] { 0, 0, 0 });
        
        boolean[][] visited = new boolean[m][n];
        
        while (!heap.isEmpty()) {
            int[] entry = heap.poll();
            int row = entry[0];
            int col = entry[1];
            int time = entry[2];
            if (row == m - 1 && col == n - 1) {
                return time;
            }
            if (visited[row][col]) {
                continue;
            }
            visited[row][col] = false;
                
            for (int[] dir : DIRS) {
                int r = row + dir[0];
                int c = col + dir[1];
                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) {
                    continue;
                }
                
                if (grid[r][c] <= time + 1) {
                    heap.offer(new int[] { r, c, time + 1 });
                } else {
                    int diff = grid[r][c] - time;
                    if (diff % 2 == 1) {
                        heap.offer(new int[] { r, c, grid[r][c] });
                    } else {
                        heap.offer(new int[] { r, c, grid[r][c] + 1 });
                    }
                }
            }
        }
        return -1;
    }
}",None,"class Solution {
    private static final int[][] DIRS = new int[][] { { 1, 0 }, { -1, 0}, { 0, 1 }, { 0, -1 } };
    public int minimumTime(int[][] grid) {
        if (grid[0][1] > 1 && grid[1][0] > 1) {
            return -1;
        }
        
        int m = grid.length;
        int n = grid[0].length;
        
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        heap.offer(new int[] { 0, 0, 0 });
        
        boolean[][] visited = new boolean[m][n];
        
        while (!heap.isEmpty()) {
            int[] entry = heap.poll();
            int row = entry[0];
            int col = entry[1];
            int time = entry[2];
            if (row == m - 1 && col == n - 1) {
                return time;
            }
            if (visited[row][col]) {
                continue;
            }
            visited[row][col] = true;
                
            for (int[] dir : DIRS) {
                int r = row + dir[0];
                int c = col + dir[1];
                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) {
                    continue;
                }
                
                if (grid[r][c] <= time + 1) {
                    heap.offer(new int[] { r, c, time + 1 });
                } else {
                    int diff = grid[r][c] - time;
                    if (diff % 2 == 1) {
                        heap.offer(new int[] { r, c, grid[r][c] });
                    } else {
                        heap.offer(new int[] { r, c, grid[r][c] + 1 });
                    }
                }
            }
        }
        return -1;
    }
}
"
2760,java,minimum-score-triangulation-of-polygon,"class Solution {
    int[][] dp;
    public int minScoreTriangulation(int[] values) {
        int l=values.length;
        dp = new int[l][l];
        for(int[] i : dp) Arrays.fill(i,-1);
        return solve(values,0,l-1); 
    }

    public int solve(int[] values, int i,int j)
    {
        if(i>=j) return 0;
        if(dp[i][j]!=-1) return dp[i][j];
        int min=Integer.MAX_VALUE;
        for(int k=i;k<j;k++)
        {
            int temp=solve(values,i,k)+solve(values,k+1,j)+
                        values[i-1]*values[k]*values[j];
            min=Math.min(min,temp);
        }

        return dp[i][j]=min;
    }
}",None,"class Solution {
    int[][] dp;
    public int minScoreTriangulation(int[] values) {
        int l=values.length;
        dp = new int[l][l];
        for(int[] i : dp) Arrays.fill(i,-1);
        return solve(values,0,l-1); 
    }

    public int solve(int[] values, int i,int j)
    {
        if(j<=i+1) return 0;
        if(dp[i][j]!=-1) return dp[i][j];
        int min=Integer.MAX_VALUE;
        for(int k=i+1;k<j;k++)
        {
            int temp=solve(values,i,k)+solve(values,k,j)+
                        values[i]*values[k]*values[j];
            min=Math.min(min,temp);
        }

        return dp[i][j]=min;
    }
}
"
2760,java,minimum-score-triangulation-of-polygon,"class Solution {
    int[][] dp;
    public int minScoreTriangulation(int[] values) {
        int l=values.length;
        dp = new int[l][l];
        for(int[] i : dp) Arrays.fill(i,-1);
        return solve(values,0,l-1); 
    }

    public int solve(int[] values, int i,int j)
    {
        if(i>=j) return 0;
        if(dp[i][j]!=-1) return dp[i][j];
        int min=Integer.MAX_VALUE;
        for(int k=i;k<j;k++)
        {
            int temp=solve(values,i,k)+solve(values,k+1,j)+
                        values[i-1]*values[k]*values[j];
            min=Math.min(min,temp);
        }

        return dp[i][j]=min;
    }
}",None,"class Solution {
    int[][] dp;
    public int minScoreTriangulation(int[] values) {
        int l=values.length;
        dp = new int[l][l];
        for(int[] i : dp) Arrays.fill(i,-1);
        return solve(values,0,l-1); 
    }

    public int solve(int[] values, int i,int j)
    {
        if(j-i<2) return 0;
        if(dp[i][j]!=-1) return dp[i][j];
        int min=Integer.MAX_VALUE;
        for(int k=i+1;k<j;k++)
        {
            int temp=solve(values,i,k)+solve(values,k,j)+
                        values[i]*values[k]*values[j];
            min=Math.min(min,temp);
        }

        return dp[i][j]=min;
    }
}
"
2760,java,minimum-score-triangulation-of-polygon,"class Solution {
    int[][] dp;
    public int minScoreTriangulation(int[] values) {
        int l=values.length;
        dp = new int[l][l];
        for(int[] i : dp) Arrays.fill(i,-1);
        return solve(values,0,l-1); 
    }

    public int solve(int[] values, int i,int j)
    {
        if(i>=j) return 0;
        if(dp[i][j]!=-1) return dp[i][j];
        int min=Integer.MAX_VALUE;
        for(int k=i;k<j;k++)
        {
            int temp=solve(values,i,k)+solve(values,k+1,j)+
                        values[i-1]*values[k]*values[j];
            min=Math.min(min,temp);
        }

        return dp[i][j]=min;
    }
}",None,"class Solution {
    int[][] dp;
    public int minScoreTriangulation(int[] values) {
        int l=values.length;
        dp = new int[l][l];
        for(int[] i : dp) Arrays.fill(i,-1);
        return solve(values,0,l-1); 
    }

    public int solve(int[] values, int i,int j)
    {
        if(j - i < 2) return 0;
        if(dp[i][j]!=-1) return dp[i][j];
        int min=Integer.MAX_VALUE;
        for(int k=i+1;k<j;k++)
        {
            int temp=solve(values,i,k)+solve(values,k,j)+
                        values[i]*values[k]*values[j];
            min=Math.min(min,temp);
        }

        return dp[i][j]=min;
    }
}
"
2761,java,max-consecutive-ones,"class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int count=0;
        int max=0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==1){
                count++;
            }else{
                max=0;
            }
            max=Math.max(count,max);
        }
        return max;
    }
}",None,"class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int count=0;
        int max=0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==1){
                count++;
            }else{
                count=0;
            }
            max=Math.max(count,max);
        }
        return max;
    }
}
"
2761,java,max-consecutive-ones,"class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int count=0;
        int max=0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==1){
                count++;
            }else{
                max=0;
            }
            max=Math.max(count,max);
        }
        return max;
    }
}",None,"class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int count=0;
        int max=0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==1){
                count++;
            }else{
                count=0;
            }
            max=Math.max(count,max);
        }
        return max;
    }
}
"
2761,java,max-consecutive-ones,"class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int count=0;
        int max=0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==1){
                count++;
            }else{
                max=0;
            }
            max=Math.max(count,max);
        }
        return max;
    }
}",None,"class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int count=0;
        int max=0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==1){
                count++;
            }else{
                count=0;
            }
            max=Math.max(count,max);
        }
        return max;
    }
}
"
2762,java,corporate-flight-bookings,"class Solution:
    def increment(self, arr, start, end, val):
        arr[start] += val
        if end + 1 < len(arr):
            arr[end+1] -= val
        

    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
        arr = [0 for _ in range(n)]
        for book in bookings:
            start, end ,seat = book
            self.increment(arr, start, end, seat)
            # print(arr)
        res = [0 for _ in range(n)]
        res[0] = arr[0]
        for i in range(1, n):
            res[i] = res[i-1] + arr[i]
        # print(res)
        return res",None,"class Solution:
    def increment(self, arr, start, end, val):
        arr[start-1] += val
        if end < len(arr):
            arr[end] -= val
        

    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
        arr = [0] * (n+1)
        for book in bookings:
            start, end, seat = book
            self.increment(arr, start, end, seat)
        for i in range(1, n):
            arr[i] += arr[i-1]
        return arr[:-1]
"
2762,java,corporate-flight-bookings,"class Solution:
    def increment(self, arr, start, end, val):
        arr[start] += val
        if end + 1 < len(arr):
            arr[end+1] -= val
        

    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
        arr = [0 for _ in range(n)]
        for book in bookings:
            start, end ,seat = book
            self.increment(arr, start, end, seat)
            # print(arr)
        res = [0 for _ in range(n)]
        res[0] = arr[0]
        for i in range(1, n):
            res[i] = res[i-1] + arr[i]
        # print(res)
        return res",None,"class Solution:
    def increment(self, arr, start, end, val):
        arr[start-1] += val
        if end < len(arr):
            arr[end] -= val
        

    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
        arr = [0 for _ in range(n+1)]
        for book in bookings:
            start, end ,seat = book
            self.increment(arr, start, end, seat)
        res = [0 for _ in range(n)]
        res[0] = arr[0]
        for i in range(1, n):
            res[i] = res[i-1] + arr[i]
        return res
"
2762,java,corporate-flight-bookings,"class Solution:
    def increment(self, arr, start, end, val):
        arr[start] += val
        if end + 1 < len(arr):
            arr[end+1] -= val
        

    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
        arr = [0 for _ in range(n)]
        for book in bookings:
            start, end ,seat = book
            self.increment(arr, start, end, seat)
            # print(arr)
        res = [0 for _ in range(n)]
        res[0] = arr[0]
        for i in range(1, n):
            res[i] = res[i-1] + arr[i]
        # print(res)
        return res",None,"class Solution:
    def increment(self, arr, start, end, val):
        arr[start-1] += val
        if end < len(arr):
            arr[end] -= val
        
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
        arr = [0 for _ in range(n+1)]
        for book in bookings:
            start, end ,seat = book
            self.increment(arr, start, end, seat)
        res = [0 for _ in range(n)]
        res[0] = arr[0]
        for i in range(1, n):
            res[i] = res[i-1] + arr[i]
        return res
"
2763,java,can-make-arithmetic-progression-from-sequence,"class Solution {
    public boolean canMakeArithmeticProgression(int[] arr) {
        Arrays.sort(arr);
        int diff=arr[1]-arr[0];
        boolean temp=true;
        for(int i=1;i<arr.length-1;i++){
            if(arr[i+1]-arr[i]==diff){
                temp=false;
                continue;
            }else{
                temp=true;
            }
        }
        if(temp==true){
            return true;
        }else{
            return false;
        }
    }
}",None,"class Solution {
    public boolean canMakeArithmeticProgression(int[] arr) {
        Arrays.sort(arr);
        int diff=arr[1]-arr[0];
        for(int i=1;i<arr.length-1;i++){
            if(arr[i+1]-arr[i]!=diff){
                return false;
            }
        }
        return true;
    }
}
"
2763,java,can-make-arithmetic-progression-from-sequence,"class Solution {
    public boolean canMakeArithmeticProgression(int[] arr) {
        Arrays.sort(arr);
        int diff=arr[1]-arr[0];
        boolean temp=true;
        for(int i=1;i<arr.length-1;i++){
            if(arr[i+1]-arr[i]==diff){
                temp=false;
                continue;
            }else{
                temp=true;
            }
        }
        if(temp==true){
            return true;
        }else{
            return false;
        }
    }
}",None,"class Solution {
    public boolean canMakeArithmeticProgression(int[] arr) {
        Arrays.sort(arr);
        int diff = arr[1] - arr[0];

        for (int i = 2; i < arr.length; i++) {
            if (arr[i] - arr[i - 1] != diff) {
                return false;
            }
        }
        return true;
    }
}
"
2763,java,can-make-arithmetic-progression-from-sequence,"class Solution {
    public boolean canMakeArithmeticProgression(int[] arr) {
        Arrays.sort(arr);
        int diff=arr[1]-arr[0];
        boolean temp=true;
        for(int i=1;i<arr.length-1;i++){
            if(arr[i+1]-arr[i]==diff){
                temp=false;
                continue;
            }else{
                temp=true;
            }
        }
        if(temp==true){
            return true;
        }else{
            return false;
        }
    }
}",None,"class Solution {
    public boolean canMakeArithmeticProgression(int[] arr) {
        Arrays.sort(arr);
        int diff=arr[1]-arr[0];
        for(int i=1;i<arr.length-1;i++){
            if(arr[i+1]-arr[i] != diff){
                return false;
            }
        }
        return true;
    }
}
"
2764,java,design-authentication-manager,"class AuthenticationManager {

    int timeToLive;
    TreeSet<Integer> treeSet;
    Map<String, Integer> map;
    public AuthenticationManager(int timeToLive) {
        this.timeToLive = timeToLive;
        treeSet = new TreeSet<>();
        map = new HashMap<>();
    }
    
    public void generate(String tokenId, int currentTime) {
        map.put(tokenId, currentTime + timeToLive);
        treeSet.add(currentTime + timeToLive);
    }
    
    public void renew(String tokenId, int currentTime) {
        
        Integer time = map.get(tokenId);
        if (time == null || time <= currentTime) return;
       
	   
        map.put(tokenId, currentTime + time);
        treeSet.remove(time);
        treeSet.add(currentTime + time);
        
        while (!treeSet.isEmpty() && treeSet.lower(currentTime) != null) {
            treeSet.remove(treeSet.lower(currentTime));
        }
    }
    
    public int countUnexpiredTokens(int currentTime) {
        return treeSet.tailSet(currentTime, false).size();
    }
}",None,"class AuthenticationManager {

    int timeToLive;
    HashMap<String, Integer> map;
    public AuthenticationManager(int timeToLive) {
        this.timeToLive = timeToLive;
        map = new HashMap<>();
    }
    
    public void generate(String tokenId, int currentTime) {
        map.put(tokenId, currentTime + timeToLive);
    }
    
    public void renew(String tokenId, int currentTime) {
        
        Integer time = map.get(tokenId);
        if (time == null || time <= currentTime) return;
        map.put(tokenId, currentTime + timeToLive);
    }
    
    public int countUnexpiredTokens(int currentTime) {
        int count = 0;
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            if (entry.getValue() > currentTime) {
                count++;
            }
        }
        return count;
    }
}
"
2764,java,design-authentication-manager,"class AuthenticationManager {

    int timeToLive;
    TreeSet<Integer> treeSet;
    Map<String, Integer> map;
    public AuthenticationManager(int timeToLive) {
        this.timeToLive = timeToLive;
        treeSet = new TreeSet<>();
        map = new HashMap<>();
    }
    
    public void generate(String tokenId, int currentTime) {
        map.put(tokenId, currentTime + timeToLive);
        treeSet.add(currentTime + timeToLive);
    }
    
    public void renew(String tokenId, int currentTime) {
        
        Integer time = map.get(tokenId);
        if (time == null || time <= currentTime) return;
       
	   
        map.put(tokenId, currentTime + time);
        treeSet.remove(time);
        treeSet.add(currentTime + time);
        
        while (!treeSet.isEmpty() && treeSet.lower(currentTime) != null) {
            treeSet.remove(treeSet.lower(currentTime));
        }
    }
    
    public int countUnexpiredTokens(int currentTime) {
        return treeSet.tailSet(currentTime, false).size();
    }
}",None,"class AuthenticationManager {

    int timeToLive;
    Map<String, Integer> map;

    public AuthenticationManager(int timeToLive) {
        this.timeToLive = timeToLive;
        map = new HashMap<>();
    }
    
    public void generate(String tokenId, int currentTime) {
        map.put(tokenId, currentTime + timeToLive);
    }
    
    public void renew(String tokenId, int currentTime) {
        Integer expireTime = map.get(tokenId);
        if (expireTime != null && currentTime < expireTime) map.put(tokenId, currentTime + timeToLive);
    }
    
    public int countUnexpiredTokens(int currentTime) {
        int count = 0;
        for (Integer value: map.values()) {
            if (value > currentTime) count++;
        }
        return count;
    }
}
"
2764,java,design-authentication-manager,"class AuthenticationManager {

    int timeToLive;
    TreeSet<Integer> treeSet;
    Map<String, Integer> map;
    public AuthenticationManager(int timeToLive) {
        this.timeToLive = timeToLive;
        treeSet = new TreeSet<>();
        map = new HashMap<>();
    }
    
    public void generate(String tokenId, int currentTime) {
        map.put(tokenId, currentTime + timeToLive);
        treeSet.add(currentTime + timeToLive);
    }
    
    public void renew(String tokenId, int currentTime) {
        
        Integer time = map.get(tokenId);
        if (time == null || time <= currentTime) return;
       
	   
        map.put(tokenId, currentTime + time);
        treeSet.remove(time);
        treeSet.add(currentTime + time);
        
        while (!treeSet.isEmpty() && treeSet.lower(currentTime) != null) {
            treeSet.remove(treeSet.lower(currentTime));
        }
    }
    
    public int countUnexpiredTokens(int currentTime) {
        return treeSet.tailSet(currentTime, false).size();
    }
}",None,"class AuthenticationManager {

    int timeToLive;
    HashMap<String, Integer> map;

    public AuthenticationManager(int timeToLive) {
        this.timeToLive = timeToLive;
        map = new HashMap<>();
    }
    
    public void generate(String tokenId, int currentTime) {
        map.put(tokenId, currentTime + timeToLive);
    }
    
    public void renew(String tokenId, int currentTime) {
        if (map.containsKey(tokenId) && map.get(tokenId) > currentTime) {
            map.put(tokenId, currentTime + timeToLive);
        }
    }
    
    public int countUnexpiredTokens(int currentTime) {
        int count = 0;
        for (int time : map.values()) {
            if (time > currentTime) {
                count++;
            }
        }
        return count;
    }
}
"
2765,java,reduction-operations-to-make-the-array-elements-equal,"class Solution {
    public int reductionOperations(int[] nums) {
        Arrays.sort(nums);
        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();
        int x = 1; 
        for(Integer num : nums){
            if(map.containsKey(num)){
                continue;
            }
            map.put(num,x++);
        }
        
        int count = 0;
        for(int i = 1;i<nums.length;i++){
            if(nums[i]>nums[0]){
                count+=map.get(nums[i]);
            }
        }
        return count;
    }
}",None,"class Solution {
    public int reductionOperations(int[] nums) {
        Arrays.sort(nums);
        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();
        int x = 1; 
        for(int i = nums.length - 1; i >= 0; i--){
            if(map.containsKey(nums[i])){
                continue;
            }
            map.put(nums[i],x++);
        }
        
        int count = 0;
        for(int i = 0; i < nums.length; i++){
            if(nums[i] != nums[0]){
                count += map.get(nums[i]);
            }
        }
        return count;
    }
}
"
2765,java,reduction-operations-to-make-the-array-elements-equal,"class Solution {
    public int reductionOperations(int[] nums) {
        Arrays.sort(nums);
        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();
        int x = 1; 
        for(Integer num : nums){
            if(map.containsKey(num)){
                continue;
            }
            map.put(num,x++);
        }
        
        int count = 0;
        for(int i = 1;i<nums.length;i++){
            if(nums[i]>nums[0]){
                count+=map.get(nums[i]);
            }
        }
        return count;
    }
}",None,"class Solution {
    public int reductionOperations(int[] nums) {
        Arrays.sort(nums);
        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();
        int x = 1; 
        for(int i=nums.length-1; i>=0; i--){
            if(map.containsKey(nums[i])){
                continue;
            }
        map.put(nums[i],x++);
        }

        int count = 0;
        for(int i = 0; i<nums.length; i++){
            if(nums[i]>nums[0]){
                count+=map.get(nums[i]);
            }
        }
        return count;
    }
}
"
2765,java,reduction-operations-to-make-the-array-elements-equal,"class Solution {
    public int reductionOperations(int[] nums) {
        Arrays.sort(nums);
        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();
        int x = 1; 
        for(Integer num : nums){
            if(map.containsKey(num)){
                continue;
            }
            map.put(num,x++);
        }
        
        int count = 0;
        for(int i = 1;i<nums.length;i++){
            if(nums[i]>nums[0]){
                count+=map.get(nums[i]);
            }
        }
        return count;
    }
}",None,"class Solution {
    public int reductionOperations(int[] nums) {
        Arrays.sort(nums);
        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();
        int x = 1; 
        for(int i = nums.length - 1; i >= 0; i--){
            if(!map.containsKey(nums[i])){
                map.put(nums[i], x++);
            }
        }
        
        int count = 0;
        for(int i = nums.length - 1; i > 0; i--){
            if(nums[i]>nums[i-1]){
                count+=map.get(nums[i]);
            }
        }

        return count;
    }
}
"
2766,java,loud-and-rich,"class Solution {
    int ans[];
    Map<Integer,List<Integer>> map=new HashMap<>();
    int temp[]=new int[0];
    int curr_node=0;
    List<Integer> vis=new ArrayList<Integer>();
    public int[] loudAndRich(int[][] richer, int[] quiet) {
        
        ans=new int[quiet.length];
        for(int i=0;i<=richer.length;i++){
            
            if(!map.containsKey(i)){
                map.put(i,new ArrayList());
            }
            if(i<richer.length && !map.containsKey(richer[i][0])){
                map.put(richer[i][0],new ArrayList());
                map.get(richer[i][0]).add(richer[i][1]);
            }
            else if(i<richer.length){
                map.get(richer[i][0]).add(richer[i][0]);
            }
        }
        
        Comparator<pair> comp=new Comparator<pair>(){
            public int compare(pair p1,pair p2){
                if(p1.cost>p2.cost){
                    return 1;
                }
                else{
                    return -1;
                }

            }
        };
        PriorityQueue<pair> pq=new PriorityQueue<>(comp);
        for(int i=0;i<quiet.length;i++){
            ans[i]=-1;
            pq.add(new pair(i,quiet[i]));
        }
        
        while(!pq.isEmpty()){
            pair top=pq.poll();
            curr_node=top.node;
            if(!vis.contains(top.node)){
            dfs(top.node);
            }
        }
        return ans;
       
    }
    public void dfs(int node){
        if(ans[node]==-1){
            ans[node]=curr_node;
        }
        if(!vis.contains(node) && map.containsKey(node)){
            vis.add(node);
             
            for(int i : map.get(node)){
            dfs(i);
        
        }
        }
            
    }
}

class pair{
    int node,cost;
    pair(int node,int cost){
        this.node=node;
        this.cost=cost;
    }
}",None,"class Solution {
    int ans[];
    Map<Integer,List<Integer>> map=new HashMap<>();
    int temp[]=new int[0];
    int curr_node=0;
    List<Integer> vis=new ArrayList<Integer>();
    public int[] loudAndRich(int[][] richer, int[] quiet) {
        
        ans=new int[quiet.length];
        for(int i=0;i<=richer.length;i++){
            
            if(!map.containsKey(i)){
                map.put(i,new ArrayList());
            }
            if(i<richer.length && !map.containsKey(richer[i][0])){
                map.put(richer[i][0],new ArrayList());
                map.get(richer[i][0]).add(richer[i][1]);
            }
            else if(i<richer.length){
                map.get(richer[i][0]).add(richer[i][1]);
            }
        }
        
        Comparator<pair> comp=new Comparator<pair>(){
            public int compare(pair p1,pair p2){
                if(p1.cost>p2.cost){
                    return 1;
                }
                else{
                    return -1;
                }

            }
        };
        PriorityQueue<pair> pq=new PriorityQueue<>(comp);
        for(int i=0;i<quiet.length;i++){
            ans[i]=-1;
            pq.add(new pair(i,quiet[i]));
        }
        
        while(!pq.isEmpty()){
            pair top=pq.poll();
            curr_node=top.node;
            if(!vis.contains(top.node)){
            dfs(top.node);
            }
        }
        return ans;
       
    }
    public void dfs(int node){
        if(ans[node]==-1){
            ans[node]=curr_node;
        }
        
        if(vis.contains(node) || !map.containsKey(node)){
            return ;
        }
        
        vis.add(node);
        for(int i : map.get(node)){
            dfs(i);
        }
    }
}

class pair{
    int node,cost;
    pair(int node,int cost){
        this.node=node;
        this.cost=cost;
    }
}
"
2766,java,loud-and-rich,"class Solution {
    int ans[];
    Map<Integer,List<Integer>> map=new HashMap<>();
    int temp[]=new int[0];
    int curr_node=0;
    List<Integer> vis=new ArrayList<Integer>();
    public int[] loudAndRich(int[][] richer, int[] quiet) {
        
        ans=new int[quiet.length];
        for(int i=0;i<=richer.length;i++){
            
            if(!map.containsKey(i)){
                map.put(i,new ArrayList());
            }
            if(i<richer.length && !map.containsKey(richer[i][0])){
                map.put(richer[i][0],new ArrayList());
                map.get(richer[i][0]).add(richer[i][1]);
            }
            else if(i<richer.length){
                map.get(richer[i][0]).add(richer[i][0]);
            }
        }
        
        Comparator<pair> comp=new Comparator<pair>(){
            public int compare(pair p1,pair p2){
                if(p1.cost>p2.cost){
                    return 1;
                }
                else{
                    return -1;
                }

            }
        };
        PriorityQueue<pair> pq=new PriorityQueue<>(comp);
        for(int i=0;i<quiet.length;i++){
            ans[i]=-1;
            pq.add(new pair(i,quiet[i]));
        }
        
        while(!pq.isEmpty()){
            pair top=pq.poll();
            curr_node=top.node;
            if(!vis.contains(top.node)){
            dfs(top.node);
            }
        }
        return ans;
       
    }
    public void dfs(int node){
        if(ans[node]==-1){
            ans[node]=curr_node;
        }
        if(!vis.contains(node) && map.containsKey(node)){
            vis.add(node);
             
            for(int i : map.get(node)){
            dfs(i);
        
        }
        }
            
    }
}

class pair{
    int node,cost;
    pair(int node,int cost){
        this.node=node;
        this.cost=cost;
    }
}",None,"class Solution {

    ArrayList<Integer>[] graph;
    int[] res;
    int[] quiet;

    public int[] loudAndRich(int[][] richer, int[] quiet) {
        int N = quiet.length;
        graph = new ArrayList[N];
        res = new int[N];
        this.quiet = quiet;

        for (int node = 0; node < N; ++node) {
            graph[node] = new ArrayList<>();
        }
        
        for (int[] concat: richer) {
            graph[concat[1]].add(concat[0]);
        }

        Arrays.fill(res, -1);

        for (int node = 0; node < N; ++node) {
            dfs(node);
        }
        return res;
    }

    public int dfs(int node) {
        if (res[node] == -1) {
            res[node] = node;
            for (int child: graph[node]) {
                int candidate = dfs(child);
                if (quiet[candidate] < quiet[res[node]]) {
                    res[node] = candidate;
                }
            }
        }
        return res[node];
    }
}
"
2766,java,loud-and-rich,"class Solution {
    int ans[];
    Map<Integer,List<Integer>> map=new HashMap<>();
    int temp[]=new int[0];
    int curr_node=0;
    List<Integer> vis=new ArrayList<Integer>();
    public int[] loudAndRich(int[][] richer, int[] quiet) {
        
        ans=new int[quiet.length];
        for(int i=0;i<=richer.length;i++){
            
            if(!map.containsKey(i)){
                map.put(i,new ArrayList());
            }
            if(i<richer.length && !map.containsKey(richer[i][0])){
                map.put(richer[i][0],new ArrayList());
                map.get(richer[i][0]).add(richer[i][1]);
            }
            else if(i<richer.length){
                map.get(richer[i][0]).add(richer[i][0]);
            }
        }
        
        Comparator<pair> comp=new Comparator<pair>(){
            public int compare(pair p1,pair p2){
                if(p1.cost>p2.cost){
                    return 1;
                }
                else{
                    return -1;
                }

            }
        };
        PriorityQueue<pair> pq=new PriorityQueue<>(comp);
        for(int i=0;i<quiet.length;i++){
            ans[i]=-1;
            pq.add(new pair(i,quiet[i]));
        }
        
        while(!pq.isEmpty()){
            pair top=pq.poll();
            curr_node=top.node;
            if(!vis.contains(top.node)){
            dfs(top.node);
            }
        }
        return ans;
       
    }
    public void dfs(int node){
        if(ans[node]==-1){
            ans[node]=curr_node;
        }
        if(!vis.contains(node) && map.containsKey(node)){
            vis.add(node);
             
            for(int i : map.get(node)){
            dfs(i);
        
        }
        }
            
    }
}

class pair{
    int node,cost;
    pair(int node,int cost){
        this.node=node;
        this.cost=cost;
    }
}",None,"class Solution {
    int[] ans;
    List<Integer>[] g;
    int[] quiet;

    public int[] loudAndRich(int[][] richer, int[] quiet) {
        int N = quiet.length;
        ans = new int[N]; 
        g = new ArrayList[N];
        this.quiet = quiet;

        for (int i = 0; i < N; ++i) g[i] = new ArrayList<Integer>();
        for (int[] r: richer) g[r[1]].add(r[0]);

        Arrays.fill(ans, -1);

        for (int i = 0; i < N; ++i) dfs(i);
        return ans;
    }

    public int dfs(int node) {
        if (ans[node] == -1) {
            ans[node] = node;
            for (int child: g[node]) {
                int cand = dfs(child);
                if (quiet[cand] < quiet[ans[node]]) ans[node] = cand;
            }
        }
        return ans[node];
    }
}
"
2767,java,add-strings,"class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        sys.set_int_max_str_digits(10000)
        nattu = int(num1)
        babu = int(num1)
        result = str(nattu+babu)
        return result",None,"class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        i, j, carry, res = len(num1)-1, len(num2)-1, 0, []
        while i >= 0 or j >= 0 or carry:
            n1 = int(num1[i]) if i >= 0 else 0
            n2 = int(num2[j]) if j >= 0 else 0
            carry, curr = divmod(n1+n2+carry, 10)
            res.append(str(curr))
            i, j = i-1, j-1
        return ''.join(res[::-1])
"
2767,java,add-strings,"class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        sys.set_int_max_str_digits(10000)
        nattu = int(num1)
        babu = int(num1)
        result = str(nattu+babu)
        return result",None,"class Solution {
    public String addStrings(String num1, String num2) {
        StringBuilder sb = new StringBuilder();

        int carry = 0;
        int p1 = num1.length() - 1, p2 = num2.length() - 1;

        while (p1 >= 0 || p2 >= 0) {
            int x1 = p1 >= 0 ? num1.charAt(p1) - '0' : 0;
            int x2 = p2 >= 0 ? num2.charAt(p2) - '0' : 0;
            int sum = x1 + x2 + carry;

            carry = sum / 10;
            sb.append(sum % 10);

            p1--;
            p2--;
        }

        if (carry != 0) {
            sb.append(carry);
        }

        return sb.reverse().toString();
    }
}
"
2767,java,add-strings,"class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        sys.set_int_max_str_digits(10000)
        nattu = int(num1)
        babu = int(num1)
        result = str(nattu+babu)
        return result",None,"class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        i, j, carry, res = len(num1) - 1, len(num2) - 1, 0, []
        while i >= 0 or j >= 0 or carry:
            n1 = int(num1[i]) if i >= 0 else 0
            n2 = int(num2[j]) if j >= 0 else 0
            carry, curr = divmod(n1+n2+carry, 10)
            res.append(str(curr))
            i, j = i - 1, j - 1
        return ''.join(res[::-1])
"
2768,java,maximum-number-of-fish-in-a-grid,"class Solution {
    public int findMaxFish(int[][] grid) {
        int sum=0;
        for(int i=0;i<grid.length;i++)
        {
            for(int j=0;j<grid[0].length;j++)
            {
                if(grid[i][j]!=0)
                {
                    int a[]=new int[1];
                    task(grid,i,j,a);
                    sum=Math.max(sum,a[0]);
                }
            }
        }
        return sum;
    }
    public void task(int grid[][], int i, int j, int a[])
    {
        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)
        {
            return;
        }
        a[0]+=grid[i][j];
        grid[i][j]=0;
        task(grid,i+1,j,a);
        task(grid,i-1,j,a);
        task(grid,i,j+1,a);
        task(grid,i,j-1,a);
        a[0] = 0; 
    }
}",None,"class Solution {
    public int findMaxFish(int[][] grid) {
        int maxFish = 0;
        for(int i=0; i < grid.length; i++) {
            for(int j=0; j < grid[0].length; j++) {
                if(grid[i][j] > 0) {
                    int fishCount = calculateFish(grid, i, j);
                    maxFish = Math.max(maxFish, fishCount);
                }
            }
        }
        return maxFish;
    }

    public int calculateFish(int[][] grid, int i, int j) {
        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0) {
            return 0;
        }

        int fishCount = grid[i][j]; //counting fish for removed it from that cell
        grid[i][j] = 0; //remove fish from current cell

        int upFish = calculateFish(grid, i-1, j);
        int downFish = calculateFish(grid, i+1, j);
        int leftFish = calculateFish(grid, i, j-1);
        int rightFish = calculateFish(grid, i, j+1);

        //restore fish to the cell
        grid[i][j] = fishCount;

        return fishCount + Math.max(Math.max(upFish, downFish), Math.max(leftFish, rightFish));
    }
}
"
2768,java,maximum-number-of-fish-in-a-grid,"class Solution {
    public int findMaxFish(int[][] grid) {
        int sum=0;
        for(int i=0;i<grid.length;i++)
        {
            for(int j=0;j<grid[0].length;j++)
            {
                if(grid[i][j]!=0)
                {
                    int a[]=new int[1];
                    task(grid,i,j,a);
                    sum=Math.max(sum,a[0]);
                }
            }
        }
        return sum;
    }
    public void task(int grid[][], int i, int j, int a[])
    {
        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)
        {
            return;
        }
        a[0]+=grid[i][j];
        grid[i][j]=0;
        task(grid,i+1,j,a);
        task(grid,i-1,j,a);
        task(grid,i,j+1,a);
        task(grid,i,j-1,a);
        a[0] = 0; 
    }
}",None,"class Solution {
    public int findMaxFish(int[][] grid) {
        int sum=0;
        for(int i=0;i<grid.length;i++)
        {
            for(int j=0;j<grid[0].length;j++)
            {
                if(grid[i][j]!=0)
                {
                    int a[]=new int[1];
                    task(grid,i,j,a);
                    sum=Math.max(sum,a[0]);
                }
            }
        }
        return sum;
    }
    public void task(int grid[][], int i, int j, int a[])
    {
        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)
        {
            return;
        }
        a[0]+=grid[i][j];
        grid[i][j]=0;
        task(grid,i+1,j,a);
        task(grid,i-1,j,a);
        task(grid,i,j+1,a);
        task(grid,i,j-1,a);
        grid[i][j] = a[0]; 
    }
}
"
2768,java,maximum-number-of-fish-in-a-grid,"class Solution {
    public int findMaxFish(int[][] grid) {
        int sum=0;
        for(int i=0;i<grid.length;i++)
        {
            for(int j=0;j<grid[0].length;j++)
            {
                if(grid[i][j]!=0)
                {
                    int a[]=new int[1];
                    task(grid,i,j,a);
                    sum=Math.max(sum,a[0]);
                }
            }
        }
        return sum;
    }
    public void task(int grid[][], int i, int j, int a[])
    {
        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)
        {
            return;
        }
        a[0]+=grid[i][j];
        grid[i][j]=0;
        task(grid,i+1,j,a);
        task(grid,i-1,j,a);
        task(grid,i,j+1,a);
        task(grid,i,j-1,a);
        a[0] = 0; 
    }
}",None,"class Solution {
    public int findMaxFish(int[][] grid) {
        int sum=0;
        for(int i=0;i<grid.length;i++) {
            for(int j=0;j<grid[0].length;j++) {
                if(grid[i][j]!=0) {
                    int a[]=new int[1];
                    task(grid,i,j,a);
                    sum=Math.max(sum,a[0]);
                }
            }
        }
        return sum;
    }
    
    public void task(int grid[][], int i, int j, int a[]) {
        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0) {
            return;
        }
        a[0]+=grid[i][j];
        int temp=grid[i][j];
        grid[i][j]=0;
        task(grid,i+1,j,a);
        task(grid,i-1,j,a);
        task(grid,i,j+1,a);
        task(grid,i,j-1,a);
        grid[i][j]=temp;
    }
}
"
2769,java,find-all-people-with-secret,"class DisjointSet {
    int[] root;
    Long[] rank;
    DisjointSet(int size, Set<Integer> secretKeepers) {
        root = new int[size];
        rank = new Long[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;
        }
    }

    public int find(int vertex) {
        if(root[vertex] == vertex) return vertex;
        return root[vertex] = find(root[vertex]);
    }

    public void union(int vertex1, int vertex2) {
        int root1 = find(vertex1);
        int root2 = find(vertex2);
        if(root1 != root2) {
            if(rank[root1] > rank[root2]) {
                root[root2] = root1;
            } else if (rank[root2] > rank[root1]) {
                root[root1] = root2;
            } else {
                root[root2] = root1;
                rank[root1]++;
            }
        }
    }

    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {
        for (int vertex: visited) {
            if(secretKeepers.contains(find(vertex)))
                secretKeepers.add(vertex);
            else 
                root[vertex] = vertex;
        }
        return secretKeepers;
    }
}

class Solution {
    private int maxTime = Integer.MIN_VALUE;
    private int minTime = Integer.MAX_VALUE;
    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {
        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));
        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);
        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);
        for (int time = minTime; time <= maxTime; time++) {
            if(!timeToMeetings.containsKey(time)) continue;
            Set<Integer> visited = new HashSet<>();
            for (Integer[] meeting: timeToMeetings.get(time)) {
                int person1 = meeting[0], person2 = meeting[1];
                disjointSet.union(person1, meeting[2]);
                visited.add(person1);
                visited.add(person2);
            }
            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);
        }
        return new ArrayList<>(secretKeepers);
    }

    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {
        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();
        for (int[] meeting: meetings) {
            maxTime = Math.max(maxTime, meeting[2]);
            minTime = Math.min(minTime, meeting[2]);
            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});
        }
        return timeToMeetings;
    }
}",None,"class DisjointSet {
    int[] root;
    Long[] rank;
    DisjointSet(int size, Set<Integer> secretKeepers) {
        root = new int[size];
        rank = new Long[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;
        }
    }

    public int find(int vertex) {
        if(root[vertex] == vertex) return vertex;
        return root[vertex] = find(root[vertex]);
    }

    public void union(int vertex1, int vertex2) {
        int root1 = find(vertex1);
        int root2 = find(vertex2);
        if(root1 != root2) {
            if(rank[root1] > rank[root2]) {
                root[root2] = root1;
            } else if (rank[root2] > rank[root1]) {
                root[root1] = root2;
            } else {
                root[root2] = root1;
                rank[root1]++;
            }
        }
    }

    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {
        for (int vertex: visited) {
            if(secretKeepers.contains(find(vertex)))
                secretKeepers.add(vertex);
            else 
                root[vertex] = vertex;
        }
        return secretKeepers;
    }
}

class Solution {
    private int maxTime = Integer.MIN_VALUE;
    private int minTime = Integer.MAX_VALUE;
    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {
        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));
        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);
        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);
        for (int time = minTime; time <= maxTime; time++) {
            if(!timeToMeetings.containsKey(time)) continue;
            Set<Integer> visited = new HashSet<>();
            for (Integer[] meeting: timeToMeetings.get(time)) {
                int person1 = meeting[0], person2 = meeting[1];
                disjointSet.union(person1, person2);
                visited.add(person1);
                visited.add(person2);
            }
            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);
        }
        return new ArrayList<>(secretKeepers);
    }

    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {
        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();
        for (int[] meeting: meetings) {
            maxTime = Math.max(maxTime, meeting[2]);
            minTime = Math.min(minTime, meeting[2]);
            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});
        }
        return timeToMeetings;
    }
}
"
2769,java,find-all-people-with-secret,"class DisjointSet {
    int[] root;
    Long[] rank;
    DisjointSet(int size, Set<Integer> secretKeepers) {
        root = new int[size];
        rank = new Long[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;
        }
    }

    public int find(int vertex) {
        if(root[vertex] == vertex) return vertex;
        return root[vertex] = find(root[vertex]);
    }

    public void union(int vertex1, int vertex2) {
        int root1 = find(vertex1);
        int root2 = find(vertex2);
        if(root1 != root2) {
            if(rank[root1] > rank[root2]) {
                root[root2] = root1;
            } else if (rank[root2] > rank[root1]) {
                root[root1] = root2;
            } else {
                root[root2] = root1;
                rank[root1]++;
            }
        }
    }

    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {
        for (int vertex: visited) {
            if(secretKeepers.contains(find(vertex)))
                secretKeepers.add(vertex);
            else 
                root[vertex] = vertex;
        }
        return secretKeepers;
    }
}

class Solution {
    private int maxTime = Integer.MIN_VALUE;
    private int minTime = Integer.MAX_VALUE;
    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {
        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));
        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);
        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);
        for (int time = minTime; time <= maxTime; time++) {
            if(!timeToMeetings.containsKey(time)) continue;
            Set<Integer> visited = new HashSet<>();
            for (Integer[] meeting: timeToMeetings.get(time)) {
                int person1 = meeting[0], person2 = meeting[1];
                disjointSet.union(person1, meeting[2]);
                visited.add(person1);
                visited.add(person2);
            }
            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);
        }
        return new ArrayList<>(secretKeepers);
    }

    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {
        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();
        for (int[] meeting: meetings) {
            maxTime = Math.max(maxTime, meeting[2]);
            minTime = Math.min(minTime, meeting[2]);
            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});
        }
        return timeToMeetings;
    }
}",None,"class DisjointSet {
    int[] root;
    Long[] rank;
    DisjointSet(int size, Set<Integer> secretKeepers) {
        root = new int[size];
        rank = new Long[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;
        }
    }

    public int find(int vertex) {
        if(root[vertex] == vertex) return vertex;
        return root[vertex] = find(root[vertex]);
    }

    public void union(int vertex1, int vertex2) {
        int root1 = find(vertex1);
        int root2 = find(vertex2);
        if(root1 != root2) {
            if(rank[root1] > rank[root2]) {
                root[root2] = root1;
            } else if (rank[root2] > rank[root1]) {
                root[root1] = root2;
            } else {
                root[root2] = root1;
                rank[root1]++;
            }
        }
    }

    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {
        for (int vertex: visited) {
            if(secretKeepers.contains(find(vertex)))
                secretKeepers.add(vertex);
            else 
                root[vertex] = vertex;
        }
        return secretKeepers;
    }
}

class Solution {
    private int maxTime = Integer.MIN_VALUE;
    private int minTime = Integer.MAX_VALUE;
    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {
        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));
        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);
        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);
        for (int time = minTime; time <= maxTime; time++) {
            if(!timeToMeetings.containsKey(time)) continue;
            Set<Integer> visited = new HashSet<>();
            for (Integer[] meeting: timeToMeetings.get(time)) {
                int person1 = meeting[0], person2 = meeting[1];
                disjointSet.union(person1, person2);
                visited.add(person1);
                visited.add(person2);
            }
            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);
        }
        return new ArrayList<>(secretKeepers);
    }

    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {
        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();
        for (int[] meeting: meetings) {
            maxTime = Math.max(maxTime, meeting[2]);
            minTime = Math.min(minTime, meeting[2]);
            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});
        }
        return timeToMeetings;
    }
}
"
2769,java,find-all-people-with-secret,"class DisjointSet {
    int[] root;
    Long[] rank;
    DisjointSet(int size, Set<Integer> secretKeepers) {
        root = new int[size];
        rank = new Long[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;
        }
    }

    public int find(int vertex) {
        if(root[vertex] == vertex) return vertex;
        return root[vertex] = find(root[vertex]);
    }

    public void union(int vertex1, int vertex2) {
        int root1 = find(vertex1);
        int root2 = find(vertex2);
        if(root1 != root2) {
            if(rank[root1] > rank[root2]) {
                root[root2] = root1;
            } else if (rank[root2] > rank[root1]) {
                root[root1] = root2;
            } else {
                root[root2] = root1;
                rank[root1]++;
            }
        }
    }

    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {
        for (int vertex: visited) {
            if(secretKeepers.contains(find(vertex)))
                secretKeepers.add(vertex);
            else 
                root[vertex] = vertex;
        }
        return secretKeepers;
    }
}

class Solution {
    private int maxTime = Integer.MIN_VALUE;
    private int minTime = Integer.MAX_VALUE;
    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {
        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));
        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);
        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);
        for (int time = minTime; time <= maxTime; time++) {
            if(!timeToMeetings.containsKey(time)) continue;
            Set<Integer> visited = new HashSet<>();
            for (Integer[] meeting: timeToMeetings.get(time)) {
                int person1 = meeting[0], person2 = meeting[1];
                disjointSet.union(person1, meeting[2]);
                visited.add(person1);
                visited.add(person2);
            }
            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);
        }
        return new ArrayList<>(secretKeepers);
    }

    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {
        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();
        for (int[] meeting: meetings) {
            maxTime = Math.max(maxTime, meeting[2]);
            minTime = Math.min(minTime, meeting[2]);
            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});
        }
        return timeToMeetings;
    }
}",None,"class DisjointSet {
    int[] root;
    Long[] rank;
    DisjointSet(int size, Set<Integer> secretKeepers) {
        root = new int[size];
        rank = new Long[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;
        }
    }

    public int find(int vertex) {
        if(root[vertex] == vertex) return vertex;
        return root[vertex] = find(root[vertex]);
    }

    public void union(int vertex1, int vertex2) {
        int root1 = find(vertex1);
        int root2 = find(vertex2);
        if(root1 != root2) {
            if(rank[root1] > rank[root2]) {
                root[root2] = root1;
            } else if (rank[root2] > rank[root1]) {
                root[root1] = root2;
            } else {
                root[root2] = root1;
                rank[root1]++;
            }
        }
    }

    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {
        for (int vertex: visited) {
            if(secretKeepers.contains(find(vertex)))
                secretKeepers.add(vertex);
            else 
                root[vertex] = vertex;
        }
        return secretKeepers;
    }
}

class Solution {
    private int maxTime = Integer.MIN_VALUE;
    private int minTime = Integer.MAX_VALUE;
    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {
        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));
        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);
        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);
        for (int time = minTime; time <= maxTime; time++) {
            if(!timeToMeetings.containsKey(time)) continue;
            Set<Integer> visited = new HashSet<>();
            for (Integer[] meeting: timeToMeetings.get(time)) {
                int person1 = meeting[0], person2 = meeting[1];
                disjointSet.union(person1, person2);
                visited.add(person1);
                visited.add(person2);
            }
            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);
        }
        return new ArrayList<>(secretKeepers);
    }

    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {
        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();
        for (int[] meeting: meetings) {
            maxTime = Math.max(maxTime, meeting[2]);
            minTime = Math.min(minTime, meeting[2]);
            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});
        }
        return timeToMeetings;
    }
}
"
2770,java,subtract-the-product-and-sum-of-digits-of-an-integer,"class Solution {
    public int subtractProductAndSum(int n) {
        int prod=0; 
        int sum=0;
        while(n>0) {
            int rem=n%10;
            sum+=rem;
            prod*=rem;
            n/=10;
        }
        return prod-sum;
    }
}",None,"class Solution {
    public int subtractProductAndSum(int n) {
        int prod=1; 
        int sum=0;
        while(n>0) {
            int rem=n%10;
            sum+=rem;
            prod*=rem;
            n/=10;
        }
        return prod-sum;
    }
}
"
2770,java,subtract-the-product-and-sum-of-digits-of-an-integer,"class Solution {
    public int subtractProductAndSum(int n) {
        int prod=0; 
        int sum=0;
        while(n>0) {
            int rem=n%10;
            sum+=rem;
            prod*=rem;
            n/=10;
        }
        return prod-sum;
    }
}",None,"class Solution {
    public int subtractProductAndSum(int n) {
        int prod = 1; 
        int sum = 0;
        while(n > 0) {
            int rem = n % 10;
            sum += rem;
            prod *= rem;
            n /= 10;
        }
        return prod - sum;
    }
}
"
2770,java,subtract-the-product-and-sum-of-digits-of-an-integer,"class Solution {
    public int subtractProductAndSum(int n) {
        int prod=0; 
        int sum=0;
        while(n>0) {
            int rem=n%10;
            sum+=rem;
            prod*=rem;
            n/=10;
        }
        return prod-sum;
    }
}",None,"class Solution {
    public int subtractProductAndSum(int n) {
        int prod=1; 
        int sum=0;
        while(n>0) {
            int rem=n%10;
            sum+=rem;
            prod*=rem;
            n/=10;
        }
        return prod-sum;
    }
}
"
2771,java,merge-strings-alternately,"class Solution {
    public String mergeAlternately(String word1, String word2) {
     char [] arr1=word1.toCharArray();
     char [] arr2=word2.toCharArray();
     char [] merge = new char[arr1.length+arr2.length];
    int i=0,j=0;
    while( i< merge.length){
        if(j<arr1.length){
            merge[i]=arr2[j];
            i++;
        }
        if( j< arr2.length){
            merge[i]=arr1[j];
            i++;
        }
        j++;
    }
    return new String(merge);
    }
}",None,"class Solution {
    public String mergeAlternately(String word1, String word2) {
     char [] arr1=word1.toCharArray();
     char [] arr2=word2.toCharArray();
     char [] merge = new char[arr1.length+arr2.length];
    int i=0,j=0;
    while( i< merge.length){
        if(j<arr1.length){
            merge[i]=arr1[j];
            i++;
        }
        if( j< arr2.length){
            merge[i]=arr2[j];
            i++;
        }
        j++;
    }
    return new String(merge);
    }
}
"
2771,java,merge-strings-alternately,"class Solution {
    public String mergeAlternately(String word1, String word2) {
     char [] arr1=word1.toCharArray();
     char [] arr2=word2.toCharArray();
     char [] merge = new char[arr1.length+arr2.length];
    int i=0,j=0;
    while( i< merge.length){
        if(j<arr1.length){
            merge[i]=arr2[j];
            i++;
        }
        if( j< arr2.length){
            merge[i]=arr1[j];
            i++;
        }
        j++;
    }
    return new String(merge);
    }
}",None,"class Solution {
    public String mergeAlternately(String word1, String word2) {
     char [] arr1=word1.toCharArray();
     char [] arr2=word2.toCharArray();
     char [] merge = new char[arr1.length+arr2.length];
    int i=0,j=0;
    while( i< merge.length){
        if(j<arr1.length){
            merge[i]=arr1[j];
            i++;
        }
        if( j< arr2.length){
            merge[i]=arr2[j];
            i++;
        }
        j++;
    }
    return new String(merge);
    }
}
"
2771,java,merge-strings-alternately,"class Solution {
    public String mergeAlternately(String word1, String word2) {
     char [] arr1=word1.toCharArray();
     char [] arr2=word2.toCharArray();
     char [] merge = new char[arr1.length+arr2.length];
    int i=0,j=0;
    while( i< merge.length){
        if(j<arr1.length){
            merge[i]=arr2[j];
            i++;
        }
        if( j< arr2.length){
            merge[i]=arr1[j];
            i++;
        }
        j++;
    }
    return new String(merge);
    }
}",None,"class Solution {
    public String mergeAlternately(String word1, String word2) {
        char [] arr1 = word1.toCharArray();
        char [] arr2 = word2.toCharArray();
        char [] merge = new char[arr1.length + arr2.length];
        int i = 0, j = 0, k = 0;
        while (k < merge.length) {
            if (j < arr1.length) {
                merge[k] = arr1[j];
                k++;
            }
            if (j < arr2.length) {
                merge[k] = arr2[j];
                k++;
            }
            j++;
        }
        return new String(merge);
    }
}
"
2772,java,ways-to-split-array-into-good-subarrays,"class Solution {
    public int numberOfGoodSubarraySplits(int[] nums) {
        
       List<Integer> list = new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            if(nums[i]==1) list.add(i);
        }
        if(list.size()==0) return 0;
        if(list.size()==1) return 1;
        int mod =(int)1e9+7;
        long res = 0;
        for(int i=0;i<list.size()-1;i++){
                long index1 = (long)list.get(i);
                long index2 = (long)list.get(i+1);
                res =  ( res%mod * (index2-index1)%mod)%mod;
                
            
        }
        return (int)res;
    }
}",None,"class Solution {
    public int numberOfGoodSubarraySplits(int[] nums) {
       long res = 1, count = 1;
       int mod =(int)1e9+7;
       for (int i = 1; i < nums.length; ++i) {
            if (nums[i] == 1) {
                res = (res * count) % mod;
                count = 1;
            } else {
                count++;
            }
        }
        return (int)res;
    }
}
"
2772,java,ways-to-split-array-into-good-subarrays,"class Solution {
    public int numberOfGoodSubarraySplits(int[] nums) {
        
       List<Integer> list = new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            if(nums[i]==1) list.add(i);
        }
        if(list.size()==0) return 0;
        if(list.size()==1) return 1;
        int mod =(int)1e9+7;
        long res = 0;
        for(int i=0;i<list.size()-1;i++){
                long index1 = (long)list.get(i);
                long index2 = (long)list.get(i+1);
                res =  ( res%mod * (index2-index1)%mod)%mod;
                
            
        }
        return (int)res;
    }
}",None,"class Solution {
    public int numberOfGoodSubarraySplits(int[] nums) {
       List<Integer> indexList = new ArrayList<>();
       indexList.add(-1);
       for(int i = 0; i < nums.length; i++){
            if(nums[i] == 1) indexList.add(i);
       }
       indexList.add(nums.length);
       long res = 1;
       int mod =(int)1e9+7;
       for(int i = 1; i < indexList.size() - 1; i++){
           res = (res * (indexList.get(i) - indexList.get(i - 1))) % mod;
       }
       return (int)res;
    }
}
"
2772,java,ways-to-split-array-into-good-subarrays,"class Solution {
    public int numberOfGoodSubarraySplits(int[] nums) {
        
       List<Integer> list = new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            if(nums[i]==1) list.add(i);
        }
        if(list.size()==0) return 0;
        if(list.size()==1) return 1;
        int mod =(int)1e9+7;
        long res = 0;
        for(int i=0;i<list.size()-1;i++){
                long index1 = (long)list.get(i);
                long index2 = (long)list.get(i+1);
                res =  ( res%mod * (index2-index1)%mod)%mod;
                
            
        }
        return (int)res;
    }
}",None,"class Solution {
    public int numberOfSubarrays(int[] nums) {
        int mod = (int)(Math.pow(10, 9) + 7);
        List<Integer> list = new ArrayList<Integer>();
        for(int i = 0; i < nums.length; i++) {
            if(nums[i] == 1) {
                list.add(i);
            }
        }
        int size = list.size();
        if(size == 0) return 0;
        if(size == 1) return 1;
        long[] prefix = new long[size];
        prefix[0] = list.get(0) + 1;
        for(int i = 1; i < size; i++) {
            prefix[i] = prefix[i - 1] * (list.get(i) - list.get(i - 1));
            prefix[i] %= mod;
        }
        long[] suffix = new long[size];
        suffix[size - 1] = nums.length - list.get(size - 1);
        for(int i = size - 2; i >= 0; i--) {
            suffix[i] = suffix[i + 1] * (list.get(i + 1) - list.get(i));
            suffix[i] %= mod;
        }
        long result = (prefix[size - 1] + suffix[0] - size) % mod;
        return (int)result;
    }
}
"
2773,java,trapping-rain-water,"class Solution 
{
    public int trap(int[] height) 
    {
        int result = 0;
        if(height==null || height.length<=2)
            return result;
        int left[] = new int[height.length];
        int right[]= new int[height.length];
        int max = height[0];
        left[0] = height[0];
        for(int i=1; i<height.length; i++)
        {
            if(height[i]<max)
            {
                left[i]=height[i];
            }
            else
            {
                left[i]=height[i];
                max = height[i];
            }
        }
        max = height[height.length-1];
        right[height.length-1]=height[height.length-1];
        for(int i=height.length-2; i>=0; i--)
        {
            if(height[i]<max)
            {
                right[i]=max;  
            }
            else
            {  
                right[i]=height[i];
                max = height[i];
            }
        }
    
        for(int i=0; i<height.length; i++)
        {
            result+= Math.min(left[i],right[i])-height[i];
        }
        return result;
    }
}",None,"class Solution 
{
    public int trap(int[] height) 
    {
        int result = 0;
        if(height==null || height.length<=2)
            return result;
        int left[] = new int[height.length];
        int right[]= new int[height.length];
        int max = height[0];
        left[0] = height[0];
        for(int i=1; i<height.length; i++)
        {
            if(height[i]<max)
            {
                left[i]=max;
            }
            else
            {
                left[i]=height[i];
                max = height[i];
            }
        }
        max = height[height.length-1];
        right[height.length-1]=height[height.length-1];
        for(int i=height.length-2; i>=0; i--)
        {
            if(height[i]<max)
            {
                right[i]=max;  
            }
            else
            {  
                right[i]=height[i];
                max = height[i];
            }
        }
    
        for(int i=0; i<height.length; i++)
        {
            result+= Math.min(left[i],right[i])-height[i];
        }
        return result;
    }
}
"
2773,java,trapping-rain-water,"class Solution 
{
    public int trap(int[] height) 
    {
        int result = 0;
        if(height==null || height.length<=2)
            return result;
        int left[] = new int[height.length];
        int right[]= new int[height.length];
        int max = height[0];
        left[0] = height[0];
        for(int i=1; i<height.length; i++)
        {
            if(height[i]<max)
            {
                left[i]=height[i];
            }
            else
            {
                left[i]=height[i];
                max = height[i];
            }
        }
        max = height[height.length-1];
        right[height.length-1]=height[height.length-1];
        for(int i=height.length-2; i>=0; i--)
        {
            if(height[i]<max)
            {
                right[i]=max;  
            }
            else
            {  
                right[i]=height[i];
                max = height[i];
            }
        }
    
        for(int i=0; i<height.length; i++)
        {
            result+= Math.min(left[i],right[i])-height[i];
        }
        return result;
    }
}",None,"class Solution 
{
    public int trap(int[] height) 
    {
        int result = 0;
        if(height==null || height.length<=2)
            return result;
        int left[] = new int[height.length];
        int right[]= new int[height.length];
        int max = height[0];
        left[0] = height[0];
        for(int i=1; i<height.length; i++)
        {
            if(height[i]<max)
            {
                left[i]=max;
            }
            else
            {
                left[i]=height[i];
                max = height[i];
            }
        }
        max = height[height.length-1];
        right[height.length-1]=height[height.length-1];
        for(int i=height.length-2; i>=0; i--)
        {
            if(height[i]<max)
            {
                right[i]=max;  
            }
            else
            {  
                right[i]=height[i];
                max = height[i];
            }
        }
    
        for(int i=0; i<height.length; i++)
        {
            result+= Math.min(left[i],right[i])-height[i];
        }
        return result;
    }
}
"
2773,java,trapping-rain-water,"class Solution 
{
    public int trap(int[] height) 
    {
        int result = 0;
        if(height==null || height.length<=2)
            return result;
        int left[] = new int[height.length];
        int right[]= new int[height.length];
        int max = height[0];
        left[0] = height[0];
        for(int i=1; i<height.length; i++)
        {
            if(height[i]<max)
            {
                left[i]=height[i];
            }
            else
            {
                left[i]=height[i];
                max = height[i];
            }
        }
        max = height[height.length-1];
        right[height.length-1]=height[height.length-1];
        for(int i=height.length-2; i>=0; i--)
        {
            if(height[i]<max)
            {
                right[i]=max;  
            }
            else
            {  
                right[i]=height[i];
                max = height[i];
            }
        }
    
        for(int i=0; i<height.length; i++)
        {
            result+= Math.min(left[i],right[i])-height[i];
        }
        return result;
    }
}",None,"class Solution 
{
    public int trap(int[] height) 
    {
        int result = 0;
        if(height==null || height.length<=2)
            return result;
        int left[] = new int[height.length];
        int right[]= new int[height.length];
        int max = height[0];
        left[0] = height[0];
        for(int i=1; i<height.length; i++)
        {
            if(height[i]<max)
            {
                left[i]=max;
            }
            else
            {
                left[i]=height[i];
                max = height[i];
            }
        }
        max = height[height.length-1];
        right[height.length-1]=height[height.length-1];
        for(int i=height.length-2; i>=0; i--)
        {
            if(height[i]<max)
            {
                right[i]=max;  
            }
            else
            {  
                right[i]=height[i];
                max = height[i];
            }
        }
    
        for(int i=0; i<height.length; i++)
        {
            result+= Math.min(left[i],right[i])-height[i];
        }
        return result;
    }
}
"
2774,java,move-zeroes,"class Solution {
    public void moveZeroes(int[] nums) {
        int m=-1;
        for(int i=0; i<nums.length; i++)
        {
            if(nums[i]==0)
            {
                if(m==-1 || nums[m]!=0)
                {
                    m=i;
                }
            }
            else
            {
                if(m!=-1)
                {
                    int temp = nums[m];
                    nums[i]=nums[m];
                    nums[m]=temp;
                    m++;
                }
            }
        }
    }
}",None,"class Solution {
    public void moveZeroes(int[] nums) {
        int m=-1;
        for(int i=0; i<nums.length; i++)
        {
            if(nums[i]==0)
            {
                if(m==-1 || nums[m]!=0)
                {
                    m=i;
                }
            }
            else
            {
                if(m!=-1)
                {
                    int temp = nums[i];
                    nums[i]=nums[m];
                    nums[m]=temp;
                    m++;
                }
            }
        }
    }
}
"
2774,java,move-zeroes,"class Solution {
    public void moveZeroes(int[] nums) {
        int m=-1;
        for(int i=0; i<nums.length; i++)
        {
            if(nums[i]==0)
            {
                if(m==-1 || nums[m]!=0)
                {
                    m=i;
                }
            }
            else
            {
                if(m!=-1)
                {
                    int temp = nums[m];
                    nums[i]=nums[m];
                    nums[m]=temp;
                    m++;
                }
            }
        }
    }
}",None,"class Solution {
    public void moveZeroes(int[] nums) {
        int m = -1;
        for(int i = 0; i < nums.length; i++) {
            if(nums[i] == 0) {
                if(m == -1 || nums[m] != 0) {
                    m = i;
                }
            } else {
                if(m != -1) {
                    nums[m] = nums[i];
                    nums[i] = 0;
                    m++;
                }
            }
        }
    }
}
"
2774,java,move-zeroes,"class Solution {
    public void moveZeroes(int[] nums) {
        int m=-1;
        for(int i=0; i<nums.length; i++)
        {
            if(nums[i]==0)
            {
                if(m==-1 || nums[m]!=0)
                {
                    m=i;
                }
            }
            else
            {
                if(m!=-1)
                {
                    int temp = nums[m];
                    nums[i]=nums[m];
                    nums[m]=temp;
                    m++;
                }
            }
        }
    }
}",None,"class Solution {
    public void moveZeroes(int[] nums) {
        int m=-1;
        for(int i=0; i<nums.length; i++)
        {
            if(nums[i]==0)
            {
                if(m==-1 || nums[m]!=0)
                {
                    m=i;
                }
            }
            else
            {
                if(m!=-1)
                {
                    int temp = nums[m];
                    nums[m]=nums[i];
                    nums[i]=temp;
                    m++;
                }
            }
        }
    }
}
"
2775,java,largest-element-in-an-array-after-merge-operations,"class Solution {
    public long maxArrayValue(int[] nums) {
        if(nums.length==1)
        {
            return (long)nums[0];
        }
        if(nums.length==2)
        {
            return nums[0] <= nums[1] ? (long)(nums[0]+nums[1]) : (long)(Math.max(nums[0],nums[1]));
        }
        int size=nums.length;
        long ans=0,dat=(long)nums[size-1];
        for(int i=size-2;i>=0;i--)
        {
            long val=(long)nums[i];
            if(val<=dat)
            {
                dat=dat+val;
                if(dat>ans)
                {
                    ans=dat;
                }
            }
            else
            {
                if(dat>ans)
                {
                    ans=dat;
                }
                dat=val;
            }
        }
        return ans;
    }
}",None,"class Solution {
    public long maxArrayValue(int[] nums) {
        if(nums.length==1)
        {
            return (long)nums[0];
        }
        if(nums.length==2)
        {
            return nums[0] <= nums[1] ? (long)(nums[0]+nums[1]) : (long)(Math.max(nums[0],nums[1]));
        }
        int size=nums.length;
        long ans=0,dat=(long)nums[size-1];
        for(int i=size-2;i>=0;i--)
        {
            long val=(long)nums[i];
            if(val<=dat)
            {
                dat=val+dat;
                if(dat>ans)
                {
                    ans=dat;
                }
            }
            else
            {
                if(dat>ans)
                {
                    ans=dat;
                }
                dat=val;
            }
        }
        if(dat>ans)
        {
            ans=dat;
        }
        return ans;
    }
}
"
2775,java,largest-element-in-an-array-after-merge-operations,"class Solution {
    public long maxArrayValue(int[] nums) {
        if(nums.length==1)
        {
            return (long)nums[0];
        }
        if(nums.length==2)
        {
            return nums[0] <= nums[1] ? (long)(nums[0]+nums[1]) : (long)(Math.max(nums[0],nums[1]));
        }
        int size=nums.length;
        long ans=0,dat=(long)nums[size-1];
        for(int i=size-2;i>=0;i--)
        {
            long val=(long)nums[i];
            if(val<=dat)
            {
                dat=dat+val;
                if(dat>ans)
                {
                    ans=dat;
                }
            }
            else
            {
                if(dat>ans)
                {
                    ans=dat;
                }
                dat=val;
            }
        }
        return ans;
    }
}",None,"class Solution {
    public long maxArrayValue(int[] nums) {
        if(nums.length==1)
        {
            return (long)nums[0];
        }
        if(nums.length==2)
        {
            return nums[0] <= nums[1] ? (long)(nums[0]+nums[1]) : (long)(Math.max(nums[0],nums[1]));
        }
        int size=nums.length;
        long ans=0,dat=(long)nums[size-1];
        for(int i=size-2;i>=0;i--)
        {
            long val=(long)nums[i];
            if(val<=dat)
            {
                dat=dat+val;
            }
            if(dat>ans)
            {
                ans=dat;
            }
            else
            {
                dat=val;
            }
        }
        return Math.max(ans, dat);
    }
}
"
2775,java,largest-element-in-an-array-after-merge-operations,"class Solution {
    public long maxArrayValue(int[] nums) {
        if(nums.length==1)
        {
            return (long)nums[0];
        }
        if(nums.length==2)
        {
            return nums[0] <= nums[1] ? (long)(nums[0]+nums[1]) : (long)(Math.max(nums[0],nums[1]));
        }
        int size=nums.length;
        long ans=0,dat=(long)nums[size-1];
        for(int i=size-2;i>=0;i--)
        {
            long val=(long)nums[i];
            if(val<=dat)
            {
                dat=dat+val;
                if(dat>ans)
                {
                    ans=dat;
                }
            }
            else
            {
                if(dat>ans)
                {
                    ans=dat;
                }
                dat=val;
            }
        }
        return ans;
    }
}",None,"class Solution {
    public long maxArrayValue(int[] nums) {
        if(nums.length==1)
        {
            return (long)nums[0];
        }
        if(nums.length==2)
        {
            return nums[0] <= nums[1] ? (long)(nums[0]+nums[1]) : (long)(Math.max(nums[0],nums[1]));
        }
        int size=nums.length;
        long ans=0,dat=(long)nums[size-1];
        for(int i=size-2;i>=0;i--)
        {
            long val=(long)nums[i];
            if(val<=dat)
            {
                dat=dat+val;
                if(dat>ans)
                {
                    ans=dat;
                }
            }
            else
            {
                if(dat>ans)
                {
                    ans=dat;
                }
                dat=val;
            }
        }
        if(dat > ans) // check if the last calculated value is higher than the current maximum
        {
            ans = dat;
        }
        return ans;
    }
}
"
2776,java,robot-return-to-origin,"class Solution {
    public boolean judgeCircle(String moves) {
        int point[] = {0,0};
        int move[][] = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        for (Character m: moves.toCharArray()) {
            int ind = 0;
            switch (m)
            {
                case 'U': {
                    ind = 0;
                    break;
                }
                case 'D': {
                    ind = 1;
                    break;
                }
                case 'L': {
                    ind = 2;
                    break;
                }
                case 'R': {
                    ind = 4;
                    break;
                }
            }
            point[0] += move[ind][0];
            point[1] += move[ind][1];
        }
        return point[0] == 0 && point[1] == 0;
    }
}",None,"class Solution {
    public boolean judgeCircle(String moves) {
        int point[] = {0,0};
        int move[][] = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        for (Character m: moves.toCharArray()) {
            int ind = 0;
            switch (m)
            {
                case 'U': {
                    ind = 0;
                    break;
                }
                case 'D': {
                    ind = 1;
                    break;
                }
                case 'L': {
                    ind = 2;
                    break;
                }
                case 'R': {
                    ind = 3;
                    break;
                }
            }
            point[0] += move[ind][0];
            point[1] += move[ind][1];
        }
        return point[0] == 0 && point[1] == 0;
    }
}
"
2776,java,robot-return-to-origin,"class Solution {
    public boolean judgeCircle(String moves) {
        int point[] = {0,0};
        int move[][] = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        for (Character m: moves.toCharArray()) {
            int ind = 0;
            switch (m)
            {
                case 'U': {
                    ind = 0;
                    break;
                }
                case 'D': {
                    ind = 1;
                    break;
                }
                case 'L': {
                    ind = 2;
                    break;
                }
                case 'R': {
                    ind = 4;
                    break;
                }
            }
            point[0] += move[ind][0];
            point[1] += move[ind][1];
        }
        return point[0] == 0 && point[1] == 0;
    }
}",None,"class Solution {
    public boolean judgeCircle(String moves) {
        int point[] = {0,0};
        int move[][] = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        for (Character m: moves.toCharArray()) {
            int ind = 0;
            switch (m)
            {
                case 'U': {
                    ind = 0;
                    break;
                }
                case 'D': {
                    ind = 1;
                    break;
                }
                case 'L': {
                    ind = 2;
                    break;
                }
                case 'R': {
                    ind = 3;
                    break;
                }
            }
            point[0] += move[ind][0];
            point[1] += move[ind][1];
        }
        return point[0] == 0 && point[1] == 0;
    }
}
"
2776,java,robot-return-to-origin,"class Solution {
    public boolean judgeCircle(String moves) {
        int point[] = {0,0};
        int move[][] = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        for (Character m: moves.toCharArray()) {
            int ind = 0;
            switch (m)
            {
                case 'U': {
                    ind = 0;
                    break;
                }
                case 'D': {
                    ind = 1;
                    break;
                }
                case 'L': {
                    ind = 2;
                    break;
                }
                case 'R': {
                    ind = 4;
                    break;
                }
            }
            point[0] += move[ind][0];
            point[1] += move[ind][1];
        }
        return point[0] == 0 && point[1] == 0;
    }
}",None,"class Solution {
    public boolean judgeCircle(String moves) {
        int point[] = {0,0};
        int move[][] = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        for (Character m: moves.toCharArray()) {
            int ind = 0;
            switch (m)
            {
                case 'U': {
                    ind = 0;
                    break;
                }
                case 'D': {
                    ind = 1;
                    break;
                }
                case 'L': {
                    ind = 2;
                    break;
                }
                case 'R': {
                    ind = 3;
                    break;
                }
            }
            point[0] += move[ind][0];
            point[1] += move[ind][1];
        }
        return point[0] == 0 && point[1] == 0;
    }
}
"
2777,java,random-point-in-non-overlapping-rectangles,"class Solution {
    
    int[][] rects;
    TreeMap<Integer, Integer> weightedRectIndex = new TreeMap<>();
    int nPoints = 0;
    
    Random rng = new Random();

    public Solution(int[][] rects) {
        this.rects = rects;
        int index = 0;
        for (int[] rect : rects) {
            
            weightedRectIndex.put(nPoints++, index);
            nPoints += width(rect) * height(rect);
        }
    }

    public int[] pick() {
        
        int point = rng.nextInt(nPoints);
        
        var entry = weightedRectIndex.floorEntry(point);
        
        int rectPoint = point - entry.getKey();
        int[] rect = rects[entry.getValue()];
        return new int[]{
            rect[0] + rectPoint % width(rect), 
            rect[1] + rectPoint / width(rect)};
    }

    private int width(int[] rect) {
        return rect[2] - rect[0] + 1;
    }

    private int height(int[] rect) {
        return rect[3] - rect[1] + 1;
    }
}",None,"class Solution {
    
    int[][] rects;
    TreeMap<Integer, Integer> weightedRectIndex = new TreeMap<>();
    int nPoints = 0;
    
    Random rng = new Random();

    public Solution(int[][] rects) {
        this.rects = rects;
        int index = 0;
        for (int[] rect : rects) {
            nPoints += width(rect) * height(rect);
            weightedRectIndex.put(nPoints, index++);
        }
    }

    public int[] pick() {
        
        int point = rng.nextInt(nPoints) + 1;
        
        var entry = weightedRectIndex.floorEntry(point);
        
        int rectPoint = point - entry.getKey() + entry.getValue();
        int[] rect = rects[entry.getValue()];
        return new int[]{
            rect[0] + rectPoint % width(rect), 
            rect[1] + rectPoint / width(rect)};
    }

    private int width(int[] rect) {
        return rect[2] - rect[0] + 1;
    }

    private int height(int[] rect) {
        return rect[3] - rect[1] + 1;
    }
}
"
2777,java,random-point-in-non-overlapping-rectangles,"class Solution {
    
    int[][] rects;
    TreeMap<Integer, Integer> weightedRectIndex = new TreeMap<>();
    int nPoints = 0;
    
    Random rng = new Random();

    public Solution(int[][] rects) {
        this.rects = rects;
        int index = 0;
        for (int[] rect : rects) {
            
            weightedRectIndex.put(nPoints++, index);
            nPoints += width(rect) * height(rect);
        }
    }

    public int[] pick() {
        
        int point = rng.nextInt(nPoints);
        
        var entry = weightedRectIndex.floorEntry(point);
        
        int rectPoint = point - entry.getKey();
        int[] rect = rects[entry.getValue()];
        return new int[]{
            rect[0] + rectPoint % width(rect), 
            rect[1] + rectPoint / width(rect)};
    }

    private int width(int[] rect) {
        return rect[2] - rect[0] + 1;
    }

    private int height(int[] rect) {
        return rect[3] - rect[1] + 1;
    }
}",None,"class Solution {
    
    int[][] rects;
    TreeMap<Integer, Integer> weightedRectIndex = new TreeMap<>();
    int nPoints = 0;
    
    Random rng = new Random();

    public Solution(int[][] rects) {
        this.rects = rects;
        int index = 0;
        for (int[] rect : rects) {
            
            nPoints += width(rect) * height(rect);
            weightedRectIndex.put(nPoints, index++);
        }
    }

    public int[] pick() {
        
        int point = rng.nextInt(nPoints);
        
        var entry = weightedRectIndex.higherEntry(point);
        
        int rectPoint = point - entry.getKey();
        int[] rect = rects[entry.getValue()];
        return new int[]{
            rect[0] + rectPoint % width(rect), 
            rect[1] + rectPoint / width(rect)};
    }

    private int width(int[] rect) {
        return rect[2] - rect[0] + 1;
    }

    private int height(int[] rect) {
        return rect[3] - rect[1] + 1;
    }
}
"
2777,java,random-point-in-non-overlapping-rectangles,"class Solution {
    
    int[][] rects;
    TreeMap<Integer, Integer> weightedRectIndex = new TreeMap<>();
    int nPoints = 0;
    
    Random rng = new Random();

    public Solution(int[][] rects) {
        this.rects = rects;
        int index = 0;
        for (int[] rect : rects) {
            
            weightedRectIndex.put(nPoints++, index);
            nPoints += width(rect) * height(rect);
        }
    }

    public int[] pick() {
        
        int point = rng.nextInt(nPoints);
        
        var entry = weightedRectIndex.floorEntry(point);
        
        int rectPoint = point - entry.getKey();
        int[] rect = rects[entry.getValue()];
        return new int[]{
            rect[0] + rectPoint % width(rect), 
            rect[1] + rectPoint / width(rect)};
    }

    private int width(int[] rect) {
        return rect[2] - rect[0] + 1;
    }

    private int height(int[] rect) {
        return rect[3] - rect[1] + 1;
    }
}",None,"class Solution {

    int[][] rects;
    TreeMap<Integer, Integer> weightedRectIndex = new TreeMap<>();
    int nPoints = 0;

    Random rng = new Random();

    public Solution(int[][] rects) {
        this.rects = rects;
        int index = 0;
        for (int[] rect : rects) {
            nPoints += width(rect) * height(rect);
            weightedRectIndex.put(nPoints, index++);
        }
    }

    public int[] pick() {

        int point = rng.nextInt(nPoints) + 1;

        var entry = weightedRectIndex.floorEntry(point);

        int rectPoint = point - entry.getKey();

        int[] rect = rects[entry.getValue()];
        return new int[]{rect[0] + rectPoint % width(rect), rect[1] + rectPoint / width(rect)};
    }

    private int width(int[] rect) {
        return rect[2] - rect[0] + 1;
    }

    private int height(int[] rect) {
        return rect[3] - rect[1] + 1;
    }
}
"
2778,java,daily-temperatures,"class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        
        int[] arr = new int[temperatures.length]; 
        
        ArrayDeque<int[]> st = new ArrayDeque<>(); 
        
        int i=0, j=temperatures.length ; 
        
        while( j >= 0){
            
            if(st.size()==0){
                arr[i++] = 0;
            }
            else  if (st.size()>0 && st.peek()[0]>temperatures[j])
            {
                arr[i++]=1;
            } 
            else if (st.size()>0 && st.peek()[0]<=temperatures[j])
            
            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){
                    st.pop();
                    
                }
            if(st.size()==0){
                arr[i++]=0;
            }
            else{
                arr[i++]=st.peek()[1]-j;
            }
            } 
        st.push(new int[]{temperatures[j],j}); 
        j--;
        }
        
      
        int[] ans = new int[temperatures.length]; int k=0;
        for(i=arr.length-1; i>=0; i--){
            ans[k++]=arr[i];
        }
        return ans;
    }
}",None,"class Solution {
    public int[] dailyTemperatures(int[] temperatures) {

        int[] arr = new int[temperatures.length]; 

        ArrayDeque<int[]> st = new ArrayDeque<>(); 

        int i=0, j=temperatures.length - 1;

        while( j >= 0){

            // If stack is empty, push current element to stack and continue
            if(st.isEmpty()){
                st.push(new int[]{temperatures[j],j}); 
                j--;
                continue;
            }
           
            if (st.size()>0 && st.peek()[0]> temperatures[j]) {
                arr[j] = st.peek()[1]-j;
            } 
            else {
                // Pop elements from stack till a number greater than temperatures[j] is found
                while(st.size()>0 && st.peek()[0] <= temperatures[j]){
                    st.pop();
                }

                if(st.isEmpty()){
                    arr[j] = 0;
                }
                else {
                    arr[j] = st.peek()[1]-j;
                }
            } 

            st.push(new int[]{temperatures[j],j}); 
            j--;
        }

        return arr;
     }
}
"
2778,java,daily-temperatures,"class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        
        int[] arr = new int[temperatures.length]; 
        
        ArrayDeque<int[]> st = new ArrayDeque<>(); 
        
        int i=0, j=temperatures.length ; 
        
        while( j >= 0){
            
            if(st.size()==0){
                arr[i++] = 0;
            }
            else  if (st.size()>0 && st.peek()[0]>temperatures[j])
            {
                arr[i++]=1;
            } 
            else if (st.size()>0 && st.peek()[0]<=temperatures[j])
            
            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){
                    st.pop();
                    
                }
            if(st.size()==0){
                arr[i++]=0;
            }
            else{
                arr[i++]=st.peek()[1]-j;
            }
            } 
        st.push(new int[]{temperatures[j],j}); 
        j--;
        }
        
      
        int[] ans = new int[temperatures.length]; int k=0;
        for(i=arr.length-1; i>=0; i--){
            ans[k++]=arr[i];
        }
        return ans;
    }
}",None,"class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        
        int[] ans = new int[temperatures.length]; 
        Stack<Integer> stack = new Stack<>(); 
        
        for(int i=temperatures.length-1; i >= 0; i--){
            
            while(!stack.isEmpty() && temperatures[i] >= temperatures[stack.peek()]) {
                stack.pop();
            }

            ans[i] = stack.isEmpty() ? 0 : stack.peek() - i;
            stack.push(i);
        }
  
        return ans;
    }
}
"
2778,java,daily-temperatures,"class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        
        int[] arr = new int[temperatures.length]; 
        
        ArrayDeque<int[]> st = new ArrayDeque<>(); 
        
        int i=0, j=temperatures.length ; 
        
        while( j >= 0){
            
            if(st.size()==0){
                arr[i++] = 0;
            }
            else  if (st.size()>0 && st.peek()[0]>temperatures[j])
            {
                arr[i++]=1;
            } 
            else if (st.size()>0 && st.peek()[0]<=temperatures[j])
            
            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){
                    st.pop();
                    
                }
            if(st.size()==0){
                arr[i++]=0;
            }
            else{
                arr[i++]=st.peek()[1]-j;
            }
            } 
        st.push(new int[]{temperatures[j],j}); 
        j--;
        }
        
      
        int[] ans = new int[temperatures.length]; int k=0;
        for(i=arr.length-1; i>=0; i--){
            ans[k++]=arr[i];
        }
        return ans;
    }
}",None,"class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        
        int[] arr = new int[temperatures.length]; 

        ArrayDeque<Integer> st = new ArrayDeque<>(); 

        int i=0, j=temperatures.length - 1 ; 

        while( j >= 0){

            while(!st.isEmpty() && temperatures[j] >= temperatures[st.peek()]){
                st.pop();
            } 

            if(st.isEmpty()){
                arr[i++] = 0;
            }
            else{
                arr[i++] = st.peek() - j;
            }

        st.push(j); 
        j--;
        }

        int[] ans = new int[temperatures.length]; int k=0;
        for(i=arr.length-1; i>=0; i--){
            ans[k++]=arr[i];
        }
        
        return ans;
    }
}
"
2779,java,number-of-laser-beams-in-a-bank,"class Solution {
    public int numberOfBeams(String[] bank) {
        int prevLazer =0;
        int ans =0;
        for(String s:bank){
            int curLazer = 0;
            for(char c: s.toCharArray()){
                if(c=='1'){
                    curLazer++;
                }
            }
            if(curLazer >0){
                ans += (curLazer * prevLazer);
                prevLazer = curLazer;
            } else {
                prevLazer = 0;
            }
        }
        return ans;
    }
}",None,"class Solution {
    public int numberOfBeams(String[] bank) {
        int prevLazer =0;
        int ans =0;
        for(String s:bank){
            int curLazer = 0;
            for(char c: s.toCharArray()){
                if(c=='1'){
                    curLazer++;
                }
            }
            if(prevLazer >0 && curLazer >0){
                ans += (curLazer * prevLazer);
            }
            if(curLazer >0){
                prevLazer = curLazer;
            } else {
                prevLazer = 0;
            }
        }
        return ans;
    }
}
"
2779,java,number-of-laser-beams-in-a-bank,"class Solution {
    public int numberOfBeams(String[] bank) {
        int prevLazer =0;
        int ans =0;
        for(String s:bank){
            int curLazer = 0;
            for(char c: s.toCharArray()){
                if(c=='1'){
                    curLazer++;
                }
            }
            if(curLazer >0){
                ans += (curLazer * prevLazer);
                prevLazer = curLazer;
            } else {
                prevLazer = 0;
            }
        }
        return ans;
    }
}",None,"class Solution {
    public int numberOfBeams(String[] bank) {
        int prevLaser = 0;
        int ans = 0;
        for (String s : bank) {
            int curLaser = 0;
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    curLaser++;
                }
            }
            if (curLaser > 0) {
                if(prevLaser > 0) {
                    ans += (curLaser * prevLaser);
                }
                prevLaser = curLaser;
            } else {
                prevLaser = 0;
            }
        }
        return ans;
    }
}
"
2779,java,number-of-laser-beams-in-a-bank,"class Solution {
    public int numberOfBeams(String[] bank) {
        int prevLazer =0;
        int ans =0;
        for(String s:bank){
            int curLazer = 0;
            for(char c: s.toCharArray()){
                if(c=='1'){
                    curLazer++;
                }
            }
            if(curLazer >0){
                ans += (curLazer * prevLazer);
                prevLazer = curLazer;
            } else {
                prevLazer = 0;
            }
        }
        return ans;
    }
}",None,"class Solution {
    public int numberOfBeams(String[] bank) {
        int prevLazer =0;
        int ans =0;
        boolean metDevice = false;
        for(String s:bank){
            int curLazer = 0;
            for(char c: s.toCharArray()){
                if(c=='1'){
                    curLazer++;
                }
            }
            if(curLazer >0 && metDevice){
                ans += (curLazer * prevLazer);
                prevLazer = curLazer;
            } else if(curLazer > 0){
                prevLazer = curLazer;
                metDevice = true;
            } else {
                prevLazer = 0;
            }
        }
        return ans;
    }
}
"
2780,java,maximum-strength-of-a-group,"class Solution {
    private long maxStrength;

    public long maxStrength(int[] nums) {
        maxStrength = 0; 
        helper(nums, 0, 1, 0);
        return maxStrength;
    }

    private void helper(int[] nums, int index, long product, int size) {
        if (index >= nums.length) {
            if(size != 0) maxStrength = Math.max(maxStrength, product);
            return;
        }

        helper(nums, index + 1, product * nums[index], size + 1);
        helper(nums, index + 1, product, size);
    }
}",None,"class Solution {
    private long maxStrength = Long.MIN_VALUE;

    public long maxStrength(int[] nums) { 
        helper(nums, 0, 1, 0);
        return maxStrength;
    }

    private void helper(int[] nums, int index, long product, int size) {
        if (index >= nums.length) {
            if(size != 0) maxStrength = Math.max(maxStrength, product);
            return;
        }

        helper(nums, index + 1, product * nums[index], size + 1);
        helper(nums, index + 1, product, size);
    }
}
"
2780,java,maximum-strength-of-a-group,"class Solution {
    private long maxStrength;

    public long maxStrength(int[] nums) {
        maxStrength = 0; 
        helper(nums, 0, 1, 0);
        return maxStrength;
    }

    private void helper(int[] nums, int index, long product, int size) {
        if (index >= nums.length) {
            if(size != 0) maxStrength = Math.max(maxStrength, product);
            return;
        }

        helper(nums, index + 1, product * nums[index], size + 1);
        helper(nums, index + 1, product, size);
    }
}",None,"class Solution {
    private long maxStrength;

    public long maxStrength(int[] nums) {
        maxStrength = Integer.MIN_VALUE; 
        helper(nums, 0, 1, 0);
        return maxStrength;
    }

    private void helper(int[] nums, int index, long product, int size) {
        if (index >= nums.length) {
            if(size != 0) maxStrength = Math.max(maxStrength, product);
            return;
        }

        helper(nums, index + 1, product * nums[index], size + 1);
        helper(nums, index + 1, product, size);
    }
}
"
2780,java,maximum-strength-of-a-group,"class Solution {
    private long maxStrength;

    public long maxStrength(int[] nums) {
        maxStrength = 0; 
        helper(nums, 0, 1, 0);
        return maxStrength;
    }

    private void helper(int[] nums, int index, long product, int size) {
        if (index >= nums.length) {
            if(size != 0) maxStrength = Math.max(maxStrength, product);
            return;
        }

        helper(nums, index + 1, product * nums[index], size + 1);
        helper(nums, index + 1, product, size);
    }
}",None,"class Solution {
    private long maxStrength;

    public long maxStrength(int[] nums) {
        maxStrength = Long.MIN_VALUE; 
        helper(nums, 0, 1, 0);
        return maxStrength;
    }

    private void helper(int[] nums, int index, long product, int size) {
        if (index >= nums.length) {
            if(size != 0) maxStrength = Math.max(maxStrength, product);
            return;
        }

        helper(nums, index + 1, product * nums[index], size + 1);
        helper(nums, index + 1, product, size);
    }
}
"
2781,java,spiral-matrix-iv,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:
        mat=[[-1 for i in range(n)] for i in range(m)]
        temp=head
        d=1
        rowi,colj=0,0
        while temp!=None:
            mat[rowi][colj]=temp.val
            if d==1:
                if colj+1<n and mat[rowi][colj+1]==-1:
                    colj+=1
                    d=2 # Bug is here
                elif rowi+1<m and mat[rowi+1][colj]==-1:
                    rowi+=1
                    d=2
            elif d==2:
                if rowi+1<m and mat[rowi+1][colj]==-1:
                    rowi+=1
                    d=2
                elif colj-1>=0 and mat[rowi][colj-1]==-1:
                    colj-=1
                    d=3
            elif d==3:
                if colj-1>=0 and mat[rowi][colj-1]==-1:
                    colj-=1
                    d=3
                elif rowi-1>=0 and mat[rowi-1][colj]==-1:
                    rowi-=1
                    d=4
            elif d==4:
                if rowi-1>=0 and mat[rowi-1][colj]==-1:
                    rowi-=1
                    d=4
                elif colj+1<n and mat[rowi][colj+1]==-1:
                    colj+=1
                    d=1
            temp=temp.next
        return mat",None,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:
        mat=[[-1 for i in range(n)] for i in range(m)]
        temp=head
        d=1
        rowi,colj=0,0
        while temp!=None:
            mat[rowi][colj]=temp.val
            if d==1:
                if colj+1<n and mat[rowi][colj+1]==-1:
                    colj+=1
                elif rowi+1<m and mat[rowi+1][colj]==-1:
                    rowi+=1
                    d=2
            elif d==2:
                if rowi+1<m and mat[rowi+1][colj]==-1:
                    rowi+=1
                elif colj-1>=0 and mat[rowi][colj-1]==-1:
                    colj-=1
                    d=3
            elif d==3:
                if colj-1>=0 and mat[rowi][colj-1]==-1:
                    colj-=1
                elif rowi-1>=0 and mat[rowi-1][colj]==-1:
                    rowi-=1
                    d=4
            elif d==4:
                if rowi-1>=0 and mat[rowi-1][colj]==-1:
                    rowi-=1
                elif colj+1<n and mat[rowi][colj+1]==-1:
                    colj+=1
                    d=1
            temp=temp.next
        return mat
"
2781,java,spiral-matrix-iv,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:
        mat=[[-1 for i in range(n)] for i in range(m)]
        temp=head
        d=1
        rowi,colj=0,0
        while temp!=None:
            mat[rowi][colj]=temp.val
            if d==1:
                if colj+1<n and mat[rowi][colj+1]==-1:
                    colj+=1
                    d=2 # Bug is here
                elif rowi+1<m and mat[rowi+1][colj]==-1:
                    rowi+=1
                    d=2
            elif d==2:
                if rowi+1<m and mat[rowi+1][colj]==-1:
                    rowi+=1
                    d=2
                elif colj-1>=0 and mat[rowi][colj-1]==-1:
                    colj-=1
                    d=3
            elif d==3:
                if colj-1>=0 and mat[rowi][colj-1]==-1:
                    colj-=1
                    d=3
                elif rowi-1>=0 and mat[rowi-1][colj]==-1:
                    rowi-=1
                    d=4
            elif d==4:
                if rowi-1>=0 and mat[rowi-1][colj]==-1:
                    rowi-=1
                    d=4
                elif colj+1<n and mat[rowi][colj+1]==-1:
                    colj+=1
                    d=1
            temp=temp.next
        return mat",None,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:
        mat=[[-1 for i in range(n)] for i in range(m)]
        temp=head
        d=1
        rowi,colj=0,0
        while temp!=None:
            mat[rowi][colj]=temp.val
            if d==1:
                if colj+1<n and mat[rowi][colj+1]==-1:
                    colj+=1
                elif rowi+1<m and mat[rowi+1][colj]==-1:
                    rowi+=1
                    d=2
            elif d==2:
                if rowi+1<m and mat[rowi+1][colj]==-1:
                    rowi+=1
                elif colj-1>=0 and mat[rowi][colj-1]==-1:
                    colj-=1
                    d=3
            elif d==3:
                if colj-1>=0 and mat[rowi][colj-1]==-1:
                    colj-=1
                elif rowi-1>=0 and mat[rowi-1][colj]==-1:
                    rowi-=1
                    d=4
            elif d==4:
                if rowi-1>=0 and mat[rowi-1][colj]==-1:
                    rowi-=1
                elif colj+1<n and mat[rowi][colj+1]==-1:
                    colj+=1
                    d=1
            temp=temp.next
        return mat
"
2781,java,spiral-matrix-iv,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:
        mat=[[-1 for i in range(n)] for i in range(m)]
        temp=head
        d=1
        rowi,colj=0,0
        while temp!=None:
            mat[rowi][colj]=temp.val
            if d==1:
                if colj+1<n and mat[rowi][colj+1]==-1:
                    colj+=1
                    d=2 # Bug is here
                elif rowi+1<m and mat[rowi+1][colj]==-1:
                    rowi+=1
                    d=2
            elif d==2:
                if rowi+1<m and mat[rowi+1][colj]==-1:
                    rowi+=1
                    d=2
                elif colj-1>=0 and mat[rowi][colj-1]==-1:
                    colj-=1
                    d=3
            elif d==3:
                if colj-1>=0 and mat[rowi][colj-1]==-1:
                    colj-=1
                    d=3
                elif rowi-1>=0 and mat[rowi-1][colj]==-1:
                    rowi-=1
                    d=4
            elif d==4:
                if rowi-1>=0 and mat[rowi-1][colj]==-1:
                    rowi-=1
                    d=4
                elif colj+1<n and mat[rowi][colj+1]==-1:
                    colj+=1
                    d=1
            temp=temp.next
        return mat",None,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:
        mat=[[-1 for i in range(n)] for i in range(m)]
        temp=head
        d=1
        rowi,colj=0,0
        while temp!=None:
            mat[rowi][colj]=temp.val
            if d==1:
                if colj+1<n and mat[rowi][colj+1]==-1:
                    colj+=1
                elif rowi+1<m and mat[rowi+1][colj]==-1:
                    rowi+=1
                    d=2
            elif d==2:
                if rowi+1<m and mat[rowi+1][colj]==-1:
                    rowi+=1
                elif colj-1>=0 and mat[rowi][colj-1]==-1:
                    colj-=1
                    d=3
            elif d==3:
                if colj-1>=0 and mat[rowi][colj-1]==-1:
                    colj-=1
                elif rowi-1>=0 and mat[rowi-1][colj]==-1:
                    rowi-=1
                    d=4
            elif d==4:
                if rowi-1>=0 and mat[rowi-1][colj]==-1:
                    rowi-=1
                elif colj+1<n and mat[rowi][colj+1]==-1:
                    colj+=1
                    d=1
            temp=temp.next
        return mat
"
2782,java,maximum-number-of-balloons,"class Solution {
    public int maxNumberOfBalloons(String text) {
        final int[][] cache = new int[2][5];
        cache[0][0] = 97;
        cache[0][1] = 99;  
        cache[0][2] = 108;
        cache[0][3] = 110;
        cache[0][4] = 111;
        
        for (char ch : text.toCharArray()) {
            final int intValue = ch;
            for (int i = 0; i < 5; i++) {
                if (intValue == cache[0][i]) {
                    cache[1][i]++;
                    break;
                }
            }
        }

        cache[1][2] /= 2;
        cache[1][4] /= 2;

        int min = Integer.MAX_VALUE;
        for (int frequency: cache[1]) {
            min = Math.min(min, frequency);
        }

        return min;
    }
}",None,"class Solution {
    public int maxNumberOfBalloons(String text) {
        final int[][] cache = new int[2][5];
        cache[0][0] = 98; //b
        cache[0][1] = 97; //a
        cache[0][2] = 108;//l
        cache[0][3] = 108;//o
        cache[0][4] = 110;//n
        
        for (char ch : text.toCharArray()) {
            for (int i = 0; i < 5; i++) {
                if ((int)ch == cache[0][i]) {
                    cache[1][i]++;
                    break;
                }
            }
        }

        cache[1][2] /= 2;
        cache[1][3] /= 2;

        int min = Integer.MAX_VALUE;
        for (int frequency: cache[1]) {
            min = Math.min(min, frequency);
        }

        return min;
    }
}
"
2782,java,maximum-number-of-balloons,"class Solution {
    public int maxNumberOfBalloons(String text) {
        final int[][] cache = new int[2][5];
        cache[0][0] = 97;
        cache[0][1] = 99;  
        cache[0][2] = 108;
        cache[0][3] = 110;
        cache[0][4] = 111;
        
        for (char ch : text.toCharArray()) {
            final int intValue = ch;
            for (int i = 0; i < 5; i++) {
                if (intValue == cache[0][i]) {
                    cache[1][i]++;
                    break;
                }
            }
        }

        cache[1][2] /= 2;
        cache[1][4] /= 2;

        int min = Integer.MAX_VALUE;
        for (int frequency: cache[1]) {
            min = Math.min(min, frequency);
        }

        return min;
    }
}",None,"class Solution {
    public int maxNumberOfBalloons(String text) {
        final int[][] cache = new int[2][5];
        cache[0][0] = 98; // 'b'
        cache[0][1] = 97; // 'a'
        cache[0][2] = 108; // 'l'
        cache[0][3] = 111; // 'o'
        cache[0][4] = 110; // 'n'
        
        for (char ch : text.toCharArray()) {
            final int intValue = ch;
            for (int i = 0; i < 5; i++) {
                if (intValue == cache[0][i]) {
                    cache[1][i]++;
                    break;
                }
            }
        }

        cache[1][2] /= 2;
        cache[1][3] /= 2;

        int min = Integer.MAX_VALUE;
        for (int frequency: cache[1]) {
            min = Math.min(min, frequency);
        }

        return min;
    }
}
"
2782,java,maximum-number-of-balloons,"class Solution {
    public int maxNumberOfBalloons(String text) {
        final int[][] cache = new int[2][5];
        cache[0][0] = 97;
        cache[0][1] = 99;  
        cache[0][2] = 108;
        cache[0][3] = 110;
        cache[0][4] = 111;
        
        for (char ch : text.toCharArray()) {
            final int intValue = ch;
            for (int i = 0; i < 5; i++) {
                if (intValue == cache[0][i]) {
                    cache[1][i]++;
                    break;
                }
            }
        }

        cache[1][2] /= 2;
        cache[1][4] /= 2;

        int min = Integer.MAX_VALUE;
        for (int frequency: cache[1]) {
            min = Math.min(min, frequency);
        }

        return min;
    }
}",None,"class Solution {
    public int maxNumberOfBalloons(String text) {
        final int[][] cache = new int[2][5];
        cache[0][0] = 98; // ASCII value of 'b'
        cache[0][1] = 97; // ASCII value of 'a'
        cache[0][2] = 108; // ASCII value of 'l'
        cache[0][3] = 111; // ASCII value of 'o'
        cache[0][4] = 110; // ASCII value of 'n'
        
        for (char ch : text.toCharArray()) {
            final int intValue = ch;
            for (int i = 0; i < 5; i++) {
                if (intValue == cache[0][i]) {
                    cache[1][i]++;
                    break;
                }
            }
        }

        cache[1][2] /= 2;  // assuming 2 l's in ""balloon""
        cache[1][3] /= 2;  // assuming 2 o's in ""balloon""

        int min = Integer.MAX_VALUE;
        for (int frequency: cache[1]) {
            min = Math.min(min, frequency);
        }

        return min;
    }
}
"
2783,java,convert-sorted-array-to-binary-search-tree,"class Solution {
    public TreeNode createBST(int arr[], int st, int end){
        if(st>end){
            return null;
        }

        int mid = (st+end)/2+1;
        TreeNode root = new TreeNode(arr[mid]);
        root.left = createBST(arr,st,mid-1);
        root.right = createBST(arr,mid+1,end);

        return root;
    }
    public TreeNode sortedArrayToBST(int[] nums) {
        int st = 0;
        int end = nums.length-1;
        return createBST(nums,st,end);
    }
}",None,"class Solution {
    public TreeNode createBST(int arr[], int st, int end){
        if(st>end){
            return null;
        }

        int mid = (st+end)/2;
        TreeNode root = new TreeNode(arr[mid]);
        root.left = createBST(arr,st,mid-1);
        root.right = createBST(arr,mid+1,end);

        return root;
    }
    public TreeNode sortedArrayToBST(int[] nums) {
        int st = 0;
        int end = nums.length-1;
        return createBST(nums,st,end);
    }
}
"
2783,java,convert-sorted-array-to-binary-search-tree,"class Solution {
    public TreeNode createBST(int arr[], int st, int end){
        if(st>end){
            return null;
        }

        int mid = (st+end)/2+1;
        TreeNode root = new TreeNode(arr[mid]);
        root.left = createBST(arr,st,mid-1);
        root.right = createBST(arr,mid+1,end);

        return root;
    }
    public TreeNode sortedArrayToBST(int[] nums) {
        int st = 0;
        int end = nums.length-1;
        return createBST(nums,st,end);
    }
}",None,"class Solution {
    public TreeNode createBST(int arr[], int st, int end){
        if(st > end){
            return null;
        }

        int mid = (st + end) / 2;
        TreeNode root = new TreeNode(arr[mid]);
        root.left = createBST(arr, st, mid - 1);
        root.right = createBST(arr, mid + 1, end);

        return root;
    }
    public TreeNode sortedArrayToBST(int[] nums) {
        int st = 0;
        int end = nums.length - 1;
        return createBST(nums, st, end);
    }
}
"
2783,java,convert-sorted-array-to-binary-search-tree,"class Solution {
    public TreeNode createBST(int arr[], int st, int end){
        if(st>end){
            return null;
        }

        int mid = (st+end)/2+1;
        TreeNode root = new TreeNode(arr[mid]);
        root.left = createBST(arr,st,mid-1);
        root.right = createBST(arr,mid+1,end);

        return root;
    }
    public TreeNode sortedArrayToBST(int[] nums) {
        int st = 0;
        int end = nums.length-1;
        return createBST(nums,st,end);
    }
}",None,"class Solution {
    public TreeNode createBST(int arr[], int st, int end){
        if(st>end){
            return null;
        }

        int mid = (st+end)/2;
        TreeNode root = new TreeNode(arr[mid]);
        root.left = createBST(arr,st,mid-1);
        root.right = createBST(arr,mid+1,end);

        return root;
    }
    public TreeNode sortedArrayToBST(int[] nums) {
        int st = 0;
        int end = nums.length-1;
        return createBST(nums,st,end);
    }
}
"
2784,java,intersection-of-two-linked-lists,"public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {

        ListNode a = headA;
        ListNode b = headB;

        while(a != b) {
            a = a==null ? headB : a.next;
            b = b==null ? headA : a.next;
        }
        return a;
    }
}",None,"public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {

        ListNode a = headA;
        ListNode b = headB;

        while(a != b) {
            a = a==null ? headB : a.next;
            b = b==null ? headA : b.next;
        }
        return a;
    }
}
"
2784,java,intersection-of-two-linked-lists,"public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {

        ListNode a = headA;
        ListNode b = headB;

        while(a != b) {
            a = a==null ? headB : a.next;
            b = b==null ? headA : a.next;
        }
        return a;
    }
}",None,"public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {

        ListNode a = headA;
        ListNode b = headB;

        while(a != b) {
            a = a==null ? headB : a.next;
            b = b==null ? headA : b.next;
        }
        return a;
    }
}
"
2784,java,intersection-of-two-linked-lists,"public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {

        ListNode a = headA;
        ListNode b = headB;

        while(a != b) {
            a = a==null ? headB : a.next;
            b = b==null ? headA : a.next;
        }
        return a;
    }
}",None,"public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {

        ListNode a = headA;
        ListNode b = headB;

        while(a != b) {
            a = a==null ? headB : a.next;
            b = b==null ? headA : b.next;
        }
        return a;
    }
}
"
2785,java,make-array-strictly-increasing,"class Solution {
    
    HashMap<Integer, Integer> dp[];
    TreeSet<Integer> ts;
    
    int makeArrayIncr(int i, int prev, int[] arr1) {
        
        if(i == arr1.length) return 0;

        if(dp[i].containsKey(prev)) return dp[i].get(prev);

        int notswap = 5000;

        if(arr1[i] > prev) notswap = makeArrayIncr(i + 1, arr1[i], arr1);

        int swap = 5000;

        Integer curr = ts.higher(prev);

        if(curr != null) swap = 1 + makeArrayIncr(i, curr, arr1);

        dp[i].put(prev, Math.min(swap, notswap));

        return Math.min(swap, notswap);
        
    }
    
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        
        ts = new TreeSet<>();
        for(int i : arr2) ts.add(i);
        
        dp = new HashMap[arr1.length];
        for(int i = 0; i < dp.length; i++) dp[i] = new HashMap<>();
        
        int ans = makeArrayIncr(0, Integer.MIN_VALUE, arr1);
        
        return ans < 5000 ? ans : -1; 
    }
}",None,"class Solution {
    
    HashMap<Integer, Integer> dp[];
    TreeSet<Integer> ts;
    
    int makeArrayIncr(int i, int prev, int[] arr1) {
        
        if(i == arr1.length) return 0;

        if(dp[i].containsKey(prev)) return dp[i].get(prev);

        int notswap = 5000;

        if(arr1[i] > prev) notswap = makeArrayIncr(i + 1, arr1[i], arr1);

        int swap = 5000;

        Integer curr = ts.higher(prev);

        if(curr != null) swap = 1 + makeArrayIncr(i + 1, curr, arr1);

        dp[i].put(prev, Math.min(swap, notswap));

        return Math.min(swap, notswap);
        
    }
    
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        
        ts = new TreeSet<>();
        for(int i : arr2) ts.add(i);
        
        dp = new HashMap[arr1.length];
        for(int i = 0; i < dp.length; i++) dp[i] = new HashMap<>();
        
        int ans = makeArrayIncr(0, Integer.MIN_VALUE, arr1);
        
        return ans < 5000 ? ans : -1; 
    }
}
"
2785,java,make-array-strictly-increasing,"class Solution {
    
    HashMap<Integer, Integer> dp[];
    TreeSet<Integer> ts;
    
    int makeArrayIncr(int i, int prev, int[] arr1) {
        
        if(i == arr1.length) return 0;

        if(dp[i].containsKey(prev)) return dp[i].get(prev);

        int notswap = 5000;

        if(arr1[i] > prev) notswap = makeArrayIncr(i + 1, arr1[i], arr1);

        int swap = 5000;

        Integer curr = ts.higher(prev);

        if(curr != null) swap = 1 + makeArrayIncr(i, curr, arr1);

        dp[i].put(prev, Math.min(swap, notswap));

        return Math.min(swap, notswap);
        
    }
    
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        
        ts = new TreeSet<>();
        for(int i : arr2) ts.add(i);
        
        dp = new HashMap[arr1.length];
        for(int i = 0; i < dp.length; i++) dp[i] = new HashMap<>();
        
        int ans = makeArrayIncr(0, Integer.MIN_VALUE, arr1);
        
        return ans < 5000 ? ans : -1; 
    }
}",None,"class Solution {
    
    HashMap<Integer, Integer> dp[];
    TreeSet<Integer> ts;
    
    int makeArrayIncr(int i, int prev, int[] arr1) {
        
        if(i == arr1.length) return 0;

        if(dp[i].containsKey(prev)) return dp[i].get(prev);

        int notswap = 5000;

        if(arr1[i] > prev) notswap = makeArrayIncr(i + 1, arr1[i], arr1);

        int swap = 5000;

        Integer curr = ts.higher(prev);

        if(curr != null) swap = 1 + makeArrayIncr(i + 1, curr, arr1);

        dp[i].put(prev, Math.min(swap, notswap));

        return Math.min(swap, notswap);
        
    }
    
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        
        ts = new TreeSet<>();
        for(int i : arr2) ts.add(i);
        
        dp = new HashMap[arr1.length];
        for(int i = 0; i < dp.length; i++) dp[i] = new HashMap<>();
        
        int ans = makeArrayIncr(0, Integer.MIN_VALUE, arr1);
        
        return ans < 5000 ? ans : -1; 
    }
}
"
2785,java,make-array-strictly-increasing,"class Solution {
    
    HashMap<Integer, Integer> dp[];
    TreeSet<Integer> ts;
    
    int makeArrayIncr(int i, int prev, int[] arr1) {
        
        if(i == arr1.length) return 0;

        if(dp[i].containsKey(prev)) return dp[i].get(prev);

        int notswap = 5000;

        if(arr1[i] > prev) notswap = makeArrayIncr(i + 1, arr1[i], arr1);

        int swap = 5000;

        Integer curr = ts.higher(prev);

        if(curr != null) swap = 1 + makeArrayIncr(i, curr, arr1);

        dp[i].put(prev, Math.min(swap, notswap));

        return Math.min(swap, notswap);
        
    }
    
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        
        ts = new TreeSet<>();
        for(int i : arr2) ts.add(i);
        
        dp = new HashMap[arr1.length];
        for(int i = 0; i < dp.length; i++) dp[i] = new HashMap<>();
        
        int ans = makeArrayIncr(0, Integer.MIN_VALUE, arr1);
        
        return ans < 5000 ? ans : -1; 
    }
}",None,"class Solution {
    
    HashMap<Integer, Integer> dp[];
    TreeSet<Integer> ts;
    
    int makeArrayIncr(int i, int prev, int[] arr1) {
        
        if(i == arr1.length) return 0;

        if(dp[i].containsKey(prev)) return dp[i].get(prev);

        int notswap = 5000;

        if(arr1[i] > prev) notswap = makeArrayIncr(i + 1, arr1[i], arr1);

        int swap = 5000;

        Integer curr = ts.higher(prev);

        if(curr != null) swap = 1 + makeArrayIncr(i + 1, curr, arr1);

        dp[i].put(prev, Math.min(swap, notswap));

        return Math.min(swap, notswap);
        
    }
    
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        
        ts = new TreeSet<>();
        for(int i : arr2) ts.add(i);
        
        dp = new HashMap[arr1.length];
        for(int i = 0; i < dp.length; i++) dp[i] = new HashMap<>();
        
        int ans = makeArrayIncr(0, Integer.MIN_VALUE, arr1);
        
        return ans < 5000 ? ans : -1; 
    }
}
"
2786,java,count-items-matching-a-rule,"class Solution {
    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {
        int count = 0;

        String type = ""type"";
        int i = 0;

        if (ruleKey.equals(type)) {
            i = 2;  
        }
        String color = ""color"";
        if (ruleKey.equals(color)) {
            i = 1;
        }
        String name = ""name"";
        if (ruleKey.equals(name)) {
            i = 2;
        }

        for (int j = 0; j < items.size(); j++) {
            if (items.get(j).get(i).equals(ruleValue)) {
                count++;
            }
        }
        
        return count;
    }
}",None,"class Solution {
    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {
        int count = 0;
        
        int i = 0;
        if (ruleKey.equals(""color"")) {
            i = 1;  
        } else if (ruleKey.equals(""name"")) {
            i = 2;
        }

        for (int j = 0; j < items.size(); j++) {
            if (items.get(j).get(i).equals(ruleValue)) {
                count++;
            }
        }
        
        return count;
    }
}
"
2786,java,count-items-matching-a-rule,"class Solution {
    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {
        int count = 0;

        String type = ""type"";
        int i = 0;

        if (ruleKey.equals(type)) {
            i = 2;  
        }
        String color = ""color"";
        if (ruleKey.equals(color)) {
            i = 1;
        }
        String name = ""name"";
        if (ruleKey.equals(name)) {
            i = 2;
        }

        for (int j = 0; j < items.size(); j++) {
            if (items.get(j).get(i).equals(ruleValue)) {
                count++;
            }
        }
        
        return count;
    }
}",None,"class Solution {
    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {
        int count = 0;

        String type = ""type"";
        int i = 0;

        if (ruleKey.equals(type)) {
            i = 0;  
        }
        String color = ""color"";
        if (ruleKey.equals(color)) {
            i = 1;
        }
        String name = ""name"";
        if (ruleKey.equals(name)) {
            i = 2;
        }

        for (int j = 0; j < items.size(); j++) {
            if (items.get(j).get(i).equals(ruleValue)) {
                count++;
            }
        }
        
        return count;
    }
}
"
2786,java,count-items-matching-a-rule,"class Solution {
    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {
        int count = 0;

        String type = ""type"";
        int i = 0;

        if (ruleKey.equals(type)) {
            i = 2;  
        }
        String color = ""color"";
        if (ruleKey.equals(color)) {
            i = 1;
        }
        String name = ""name"";
        if (ruleKey.equals(name)) {
            i = 2;
        }

        for (int j = 0; j < items.size(); j++) {
            if (items.get(j).get(i).equals(ruleValue)) {
                count++;
            }
        }
        
        return count;
    }
}",None,"class Solution {
    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {
        int count = 0;

        String type = ""type"";
        int i = 0;

        if (ruleKey.equals(type)) {
            i = 0;  
        }
        String color = ""color"";
        if (ruleKey.equals(color)) {
            i = 1;
        }
        String name = ""name"";
        if (ruleKey.equals(name)) {
            i = 2;
        }

        for (int j = 0; j < items.size(); j++) {
            if (items.get(j).get(i).equals(ruleValue)) {
                count++;
            }
        }
        
        return count;
    }
}
"
2884,python3,minimize-the-total-price-of-the-trips,"class Solution:
    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:
        g = [[] for _ in range(n)]
        for i, j in edges:
            g[i].append(j)
            g[j].append(i)
            
        freq = [0] * n
        level = [0] * n
        parent = [0] * n
        
        def dfs(i, l, p):
            level[i] = l
            parent[i] = p
            for j in g[i]:
                if j != p:
                    dfs(j, l + 1, i)
        
        def LCA(a, b):
            if level[a] > level[b]:
                a, b = b, a
            d = level[b] - level[a]
            while d:
                b = parent[b]
                d -= 1
            if a == b:
                return a
            while a != b:
                a = parent[a]
                b = parent[b]
            return a
        
        dfs(0, 0, -1)
        for i, j in trips:
            lca = LCA(i, j)
            path = []
            while i != lca:
                freq[i] += 2
                i = parent[i]
            freq[i] += 1
            while j != lca:
                freq[j] += 1
                j = parent[j]
        
        def dp(i, p):
            res0 = 0
            res1 = price[i] // 2 * freq[i]
            for j in g[i]:
                if j != p:
                    curr = dp(j, i)
                    res0 += max(curr)
                    res1 += curr[0]
            return [res0, res1]
        ans = 0
        for i in range(n):
            ans += freq[i] * price[i]
        return ans - max(dp(0, -1))",None,"class Solution:
    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:
        g = [[] for _ in range(n)]
        for i, j in edges:
            g[i].append(j)
            g[j].append(i)
            
        freq = [0] * n
        level = [0] * n
        parent = [0] * n
        
        def dfs(i, l, p):
            level[i] = l
            parent[i] = p
            for j in g[i]:
                if j != p:
                    dfs(j, l + 1, i)
        
        def LCA(a, b):
            if level[a] > level[b]:
                a, b = b, a
            d = level[b] - level[a]
            while d:
                b = parent[b]
                d -= 1
            if a == b:
                return a
            while a != b:
                a = parent[a]
                b = parent[b]
            return a
        
        dfs(0, 0, -1)
        for i, j in trips:
            lca = LCA(i, j)
            path = []
            while i != lca:
                freq[i] += 2
                i = parent[i]
            freq[i] += 1
            while j != lca:
                freq[j] += 1
                j = parent[j]
        
        def dp(i, p):
            res0 = res1 = 0
            for j in g[i]:
                if j != p:
                    curr = dp(j, i)
                    res0 += max(curr)
                    res1 += curr[0]
            res1 += price[i] // 2 * freq[i]
            return [res0, res1]
        
        ans = 0
        for i in range(n):
            ans += freq[i] * price[i]
        return ans - max(dp(0, -1))
"
2884,python3,minimize-the-total-price-of-the-trips,"class Solution:
    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:
        g = [[] for _ in range(n)]
        for i, j in edges:
            g[i].append(j)
            g[j].append(i)
            
        freq = [0] * n
        level = [0] * n
        parent = [0] * n
        
        def dfs(i, l, p):
            level[i] = l
            parent[i] = p
            for j in g[i]:
                if j != p:
                    dfs(j, l + 1, i)
        
        def LCA(a, b):
            if level[a] > level[b]:
                a, b = b, a
            d = level[b] - level[a]
            while d:
                b = parent[b]
                d -= 1
            if a == b:
                return a
            while a != b:
                a = parent[a]
                b = parent[b]
            return a
        
        dfs(0, 0, -1)
        for i, j in trips:
            lca = LCA(i, j)
            path = []
            while i != lca:
                freq[i] += 2
                i = parent[i]
            freq[i] += 1
            while j != lca:
                freq[j] += 1
                j = parent[j]
        
        def dp(i, p):
            res0 = 0
            res1 = price[i] // 2 * freq[i]
            for j in g[i]:
                if j != p:
                    curr = dp(j, i)
                    res0 += max(curr)
                    res1 += curr[0]
            return [res0, res1]
        ans = 0
        for i in range(n):
            ans += freq[i] * price[i]
        return ans - max(dp(0, -1))",None,"class Solution:
    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:
        g = [[] for _ in range(n)]
        for i, j in edges:
            g[i].append(j)
            g[j].append(i)

        freq = [0] * n
        level = [0] * n
        parent = [0] * n

        def dfs(i, l, p):
            level[i] = l
            parent[i] = p
            for j in g[i]:
                if j != p:
                    dfs(j, l + 1, i)

        def LCA(a, b):
            if level[a] > level[b]:
                a, b = b, a
            d = level[b] - level[a]
            while d:
                b = parent[b]
                d -= 1
            if a == b:
                return a
            while a != b:
                a = parent[a]
                b = parent[b]
            return a

        dfs(0, 0, -1)
        cnt = [[0, 0] for _ in range(n)]
        for st, ed in trips:
            lca = LCA(st, ed)
            cnt[ed][1] += 1
            while ed != lca:
                cnt[ed][0] += 1
                ed = parent[ed]
            cnt[st][1] += 1
            while st != lca:
                cnt[st][0] += 1
                st = parent[st]
            cnt[lca][0] -= 1
            cnt[lca][1] -= 2

        self.res = [0] * n

        def dfs2(x: int, par: int) -> Tuple[int, int]:
            opt0, opt1 = 0, price[x] * (cnt[x][0] + cnt[x][1])
            for y in g[x]:
                if y == par:
                    continue
                v0, v1 = dfs2(y, x)
                self.res[x] += v1
                opt0, opt1 = max(opt0 + v0, self.res[x]), max(opt1 + v0, self.res[x] + v1)
            return opt0, opt1

        return dfs2(0, -1)[1]
"
2884,python3,minimize-the-total-price-of-the-trips,"class Solution:
    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:
        g = [[] for _ in range(n)]
        for i, j in edges:
            g[i].append(j)
            g[j].append(i)
            
        freq = [0] * n
        level = [0] * n
        parent = [0] * n
        
        def dfs(i, l, p):
            level[i] = l
            parent[i] = p
            for j in g[i]:
                if j != p:
                    dfs(j, l + 1, i)
        
        def LCA(a, b):
            if level[a] > level[b]:
                a, b = b, a
            d = level[b] - level[a]
            while d:
                b = parent[b]
                d -= 1
            if a == b:
                return a
            while a != b:
                a = parent[a]
                b = parent[b]
            return a
        
        dfs(0, 0, -1)
        for i, j in trips:
            lca = LCA(i, j)
            path = []
            while i != lca:
                freq[i] += 2
                i = parent[i]
            freq[i] += 1
            while j != lca:
                freq[j] += 1
                j = parent[j]
        
        def dp(i, p):
            res0 = 0
            res1 = price[i] // 2 * freq[i]
            for j in g[i]:
                if j != p:
                    curr = dp(j, i)
                    res0 += max(curr)
                    res1 += curr[0]
            return [res0, res1]
        ans = 0
        for i in range(n):
            ans += freq[i] * price[i]
        return ans - max(dp(0, -1))",None,"class Solution:
    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:
        g = [[] for _ in range(n)]
        for i, j in edges:
            g[i].append(j)
            g[j].append(i)

        freq = [0] * n
        level = [0] * n
        parent = [0] * n

        def dfs(i, l, p):
            level[i] = l
            parent[i] = p
            for j in g[i]:
                if j != p:
                    dfs(j, l + 1, i)
        
        def LCA(a, b):
            if level[a] > level[b]:
                a, b = b, a
            d = level[b] - level[a]
            while d:
                b = parent[b]
                d -= 1
            if a == b:
                return a
            while a != b:
                a = parent[a]
                b = parent[b]
            return a

        dfs(0, 0, -1)
        for i, j in trips:
            lca = LCA(i, j)
            path = []
            while i != lca:
                freq[i] += 2
                i = parent[i]
            freq[i] += 1
            while j != lca:
                freq[j] += 1
                j = parent[j]

        def dp(i, p):
            res0 = 0
            res1 = price[i] // 2 * freq[i]
            for j in g[i]:
                if j != p:
                    curr = dp(j, i)
                    res0 += max(curr)
                    res1 += curr[0]
            return [res0, res1]

        ans = dp(0, -1)
        return min(ans)
"
2885,python3,increasing-decreasing-string,"class Solution:
    def sortString(self, s: str) -> str:
        freq = {}
        letters = sorted(set(s))
        res = """"
        for i in s:
            if i in freq:
                freq[i]+=1
            else:
                freq[i] = 1
        while freq:
            for i in letters:
                if i in freq:
                    if freq[i]>0:
                        res+=i
                        freq[i]-=1
                    else:
                        del freq[i]
                    
            for i in letters[::-1]:
                if i  in freq:
                    if freq[i]>0:
                        res+=i
                        freq[i]-=1
                        
                        del freq[i]


        return res",None,"class Solution:
    def sortString(self, s: str) -> str:
        freq = {}
        letters = sorted(set(s))
        res = """"
        for i in s:
            if i in freq:
                freq[i]+=1
            else:
                freq[i] = 1
        while freq:
            for i in letters:
                if i in freq:
                    if freq[i]>0:
                        res+=i
                        freq[i]-=1
                        if freq[i]==0:
                            del freq[i]
                    
            for i in letters[::-1]:
                if i  in freq:
                    if freq[i]>0:
                        res+=i
                        freq[i]-=1
                        if freq[i]==0:
                            del freq[i]


        return res
"
2885,python3,increasing-decreasing-string,"class Solution:
    def sortString(self, s: str) -> str:
        freq = {}
        letters = sorted(set(s))
        res = """"
        for i in s:
            if i in freq:
                freq[i]+=1
            else:
                freq[i] = 1
        while freq:
            for i in letters:
                if i in freq:
                    if freq[i]>0:
                        res+=i
                        freq[i]-=1
                    else:
                        del freq[i]
                    
            for i in letters[::-1]:
                if i  in freq:
                    if freq[i]>0:
                        res+=i
                        freq[i]-=1
                        
                        del freq[i]


        return res",None,"class Solution:
    def sortString(self, s: str) -> str:
        freq = {}
        letters = sorted(set(s))
        res = """"
        for i in s:
            if i in freq:
                freq[i]+=1
            else:
                freq[i] = 1
        while freq:
            for i in letters:
                if i in freq:
                    if freq[i]>0:
                        res+=i
                        freq[i]-=1
                        if freq[i] == 0:
                            del freq[i]
                    
            for i in letters[::-1]:
                if i  in freq:
                    if freq[i]>0:
                        res+=i
                        freq[i]-=1
                        if freq[i] == 0:
                            del freq[i]


        return res
"
2885,python3,increasing-decreasing-string,"class Solution:
    def sortString(self, s: str) -> str:
        freq = {}
        letters = sorted(set(s))
        res = """"
        for i in s:
            if i in freq:
                freq[i]+=1
            else:
                freq[i] = 1
        while freq:
            for i in letters:
                if i in freq:
                    if freq[i]>0:
                        res+=i
                        freq[i]-=1
                    else:
                        del freq[i]
                    
            for i in letters[::-1]:
                if i  in freq:
                    if freq[i]>0:
                        res+=i
                        freq[i]-=1
                        
                        del freq[i]


        return res",None,"class Solution:
    def sortString(self, s: str) -> str:
        freq = {}
        letters = sorted(set(s))
        res = """"
        for i in s:
            if i in freq:
                freq[i]+=1
            else:
                freq[i] = 1
        while freq:
            for i in letters:
                if i in freq:
                    if freq[i]>1:
                        res+=i
                        freq[i]-=1
                    elif freq[i]==1:
                        res+=i
                        del freq[i]
                    
            for i in letters[::-1]:
                if i in freq:
                    if freq[i]>1:
                        res+=i
                        freq[i]-=1
                    elif freq[i]==1:
                        res+=i
                        del freq[i]

        return res
"
2886,python3,binary-tree-inorder-traversal,"class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans=[]
        def inorder(root,ans):
            if not root:
                return None
            ans.append(root.val)
            inorder(root.left,ans)
            inorder(root.right,ans)
        inorder(root,ans)
        return ans",None,"class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans=[]
        def inorder(root,ans):
            if not root:
                return None
            inorder(root.left,ans)
            ans.append(root.val)
            inorder(root.right,ans)
        inorder(root,ans)
        return ans
"
2886,python3,binary-tree-inorder-traversal,"class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans=[]
        def inorder(root,ans):
            if not root:
                return None
            ans.append(root.val)
            inorder(root.left,ans)
            inorder(root.right,ans)
        inorder(root,ans)
        return ans",None,"class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans=[]
        def inorder(root,ans):
            if not root:
                return None
            inorder(root.left,ans)
            ans.append(root.val)
            inorder(root.right,ans)
        inorder(root,ans)
        return ans
"
2886,python3,binary-tree-inorder-traversal,"class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans=[]
        def inorder(root,ans):
            if not root:
                return None
            ans.append(root.val)
            inorder(root.left,ans)
            inorder(root.right,ans)
        inorder(root,ans)
        return ans",None,"class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans=[]
        def inorder(root,ans):
            if not root:
                return None
            inorder(root.left,ans)
            ans.append(root.val)
            inorder(root.right,ans)
        inorder(root,ans)
        return ans
"
2887,python3,minimum-time-to-complete-all-tasks,"class Solution:
    def findMinimumTime(self, tasks: List[List[int]]) -> int:
        tasks.sort(key=lambda x:x[1])
        on=[0]*2001
        for s,e,d in tasks:
            cr=sum(on[s:e+1])
            while cr<d:
                if on[e]!=1:on[e]=2; cr+=1
                e-=1
        return sum(on)",None,"class Solution:
    def findMinimumTime(self, tasks: List[List[int]]) -> int:
        tasks.sort(key=lambda x:x[1])
        on=[0]*2001
        for s,e,d in tasks:
            cr=sum(on[s:e+1])
            while cr<d:
                if on[e] < 1: 
                    on[e]=1
                    cr+=1
                e-=1
        return sum(on)
"
2887,python3,minimum-time-to-complete-all-tasks,"class Solution:
    def findMinimumTime(self, tasks: List[List[int]]) -> int:
        tasks.sort(key=lambda x:x[1])
        on=[0]*2001
        for s,e,d in tasks:
            cr=sum(on[s:e+1])
            while cr<d:
                if on[e]!=1:on[e]=2; cr+=1
                e-=1
        return sum(on)",None,"class Solution:
    def findMinimumTime(self, tasks: List[List[int]]) -> int:
        tasks.sort(key=lambda x:x[1])
        on=[0]*2001
        for s,e,d in tasks:
            cr=sum(on[s:e+1])
            while cr<d:
                if on[e] != 2: 
                    on[e]=1; 
                    cr+=1
                e-=1
        return sum(on)
"
2887,python3,minimum-time-to-complete-all-tasks,"class Solution:
    def findMinimumTime(self, tasks: List[List[int]]) -> int:
        tasks.sort(key=lambda x:x[1])
        on=[0]*2001
        for s,e,d in tasks:
            cr=sum(on[s:e+1])
            while cr<d:
                if on[e]!=1:on[e]=2; cr+=1
                e-=1
        return sum(on)",None,"class Solution:
    def findMinimumTime(self, tasks: List[List[int]]) -> int:
        tasks.sort(key=lambda x:x[1])
        on=[0]*2001
        for s,e,d in tasks:
            cr=sum(on[s:e+1])
            while cr<d:
                if on[e]==0:  
                    on[e]=1
                    cr+=1
                e-=1
        return sum(on)
"
2888,python3,lexicographical-numbers,"class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        lst=[str(i) for i in range(1,n)]
        lst.sort()
        return [int(i) for i in lst]",None,"class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        lst = [str(i) for i in range(1, n+1)]
        lst.sort()
        return [int(i) for i in lst]
"
2888,python3,lexicographical-numbers,"class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        lst=[str(i) for i in range(1,n)]
        lst.sort()
        return [int(i) for i in lst]",None,"class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        lst=[str(i) for i in range(1, n+1)]
        lst.sort()
        return [int(i) for i in lst]
"
2888,python3,lexicographical-numbers,"class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        lst=[str(i) for i in range(1,n)]
        lst.sort()
        return [int(i) for i in lst]",None,"class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        lst=[str(i) for i in range(1, n+1)]
        lst.sort()
        return [int(i) for i in lst]
"
2889,python3,maximum-performance-of-a-team,"class Solution:
    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
        MOD = 10**9 + 7

        top_k_speeds = []
        res, top_k_sum = 0, 0

        pairs = [(e, s) for e, s in zip(efficiency, speed)]
        for e, s in sorted(pairs):
            heapq.heappush(top_k_speeds, s)
            top_k_sum += s

            if len(top_k_speeds) > k:
                top_k_sum -= heapq.heappop(top_k_speeds)

            res = max(res, e * top_k_sum)
        
        return res % MOD",None,"class Solution:
    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
        MOD = 10**9 + 7

        top_k_speeds = []
        res, top_k_sum = 0, 0

        pairs = [(e, s) for e, s in zip(efficiency, speed)]
        for e, s in sorted(pairs, reverse=True):
            heapq.heappush(top_k_speeds, s)
            top_k_sum += s

            if len(top_k_speeds) > k:
                top_k_sum -= heapq.heappop(top_k_speeds)

            res = max(res, e * top_k_sum)
        
        return res % MOD
"
2889,python3,maximum-performance-of-a-team,"class Solution:
    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
        MOD = 10**9 + 7

        top_k_speeds = []
        res, top_k_sum = 0, 0

        pairs = [(e, s) for e, s in zip(efficiency, speed)]
        for e, s in sorted(pairs):
            heapq.heappush(top_k_speeds, s)
            top_k_sum += s

            if len(top_k_speeds) > k:
                top_k_sum -= heapq.heappop(top_k_speeds)

            res = max(res, e * top_k_sum)
        
        return res % MOD",None,"class Solution:
    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
        MOD = 10**9 + 7

        top_k_speeds = []
        res, top_k_sum = 0, 0

        pairs = [(e, s) for e, s in zip(efficiency, speed)]
        # The pairs should be sorted by efficiency in descending order
        for e, s in sorted(pairs, reverse=True):
            heapq.heappush(top_k_speeds, s)
            top_k_sum += s

            if len(top_k_speeds) > k:
                top_k_sum -= heapq.heappop(top_k_speeds)

            res = max(res, e * top_k_sum)
        
        return res % MOD
"
2889,python3,maximum-performance-of-a-team,"class Solution:
    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
        MOD = 10**9 + 7

        top_k_speeds = []
        res, top_k_sum = 0, 0

        pairs = [(e, s) for e, s in zip(efficiency, speed)]
        for e, s in sorted(pairs):
            heapq.heappush(top_k_speeds, s)
            top_k_sum += s

            if len(top_k_speeds) > k:
                top_k_sum -= heapq.heappop(top_k_speeds)

            res = max(res, e * top_k_sum)
        
        return res % MOD",None,"class Solution:
    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
        MOD = 10**9 + 7

        top_k_speeds = []
        res, top_k_sum = 0, 0

        pairs = [(e, s) for e, s in zip(efficiency, speed)]
        for e, s in sorted(pairs, reverse=True):
            heapq.heappush(top_k_speeds, s)
            top_k_sum += s

            if len(top_k_speeds) > k:
                top_k_sum -= heapq.heappop(top_k_speeds)

            res = max(res, e * top_k_sum)
        
        return res % MOD
"
2890,python3,range-sum-query-immutable,"class NumArray:

    def __init__(self, nums: List[int]):
        self.nums=[0]+list(accumulate(nums))
        print(self.nums)

    def sumRange(self, left: int, right: int) -> int:
        return self.nums[right]-self.nums[left]
",None,"class NumArray:

    def __init__(self, nums: List[int]):
        self.nums=[0]+list(accumulate(nums))

    def sumRange(self, left: int, right: int) -> int:
        return self.nums[right+1]-self.nums[left]
"
2890,python3,range-sum-query-immutable,"class NumArray:

    def __init__(self, nums: List[int]):
        self.nums=[0]+list(accumulate(nums))
        print(self.nums)

    def sumRange(self, left: int, right: int) -> int:
        return self.nums[right]-self.nums[left]
",None,"class NumArray:

    def __init__(self, nums: List[int]):
        self.nums=[0]+list(accumulate(nums))

    def sumRange(self, left: int, right: int) -> int:
        return self.nums[right+1]-self.nums[left]
"
2890,python3,range-sum-query-immutable,"class NumArray:

    def __init__(self, nums: List[int]):
        self.nums=[0]+list(accumulate(nums))
        print(self.nums)

    def sumRange(self, left: int, right: int) -> int:
        return self.nums[right]-self.nums[left]
",None,"class NumArray:

    def __init__(self, nums: List[int]):
        self.nums=[0]+list(accumulate(nums))

    def sumRange(self, left: int, right: int) -> int:
        return self.nums[right + 1] - self.nums[left]
"
2891,python3,merge-k-sorted-lists,"class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:

        head = temp = ListNode()
        arr = []

        for ls in lists:
            while ls:
                arr.append(ls.val)
                ls = ls.next

        for val in sorted(arr, reverse=True):   
            temp.next = ListNode()
            temp = temp.next
            temp.val = val

        return head.next",None,"class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:

        head = temp = ListNode()
        arr = []

        for ls in lists:
            while ls:
                arr.append(ls.val)
                ls = ls.next

        for val in sorted(arr):   
            temp.next = ListNode(val)
            temp = temp.next

        return head.next
"
2891,python3,merge-k-sorted-lists,"class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:

        head = temp = ListNode()
        arr = []

        for ls in lists:
            while ls:
                arr.append(ls.val)
                ls = ls.next

        for val in sorted(arr, reverse=True):   
            temp.next = ListNode()
            temp = temp.next
            temp.val = val

        return head.next",None,"class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:

        head = temp = ListNode()
        arr = []

        for ls in lists:
            while ls:
                arr.append(ls.val)
                ls = ls.next

        for val in sorted(arr):   
            temp.next = ListNode(val)
            temp = temp.next

        return head.next
"
2891,python3,merge-k-sorted-lists,"class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:

        head = temp = ListNode()
        arr = []

        for ls in lists:
            while ls:
                arr.append(ls.val)
                ls = ls.next

        for val in sorted(arr, reverse=True):   
            temp.next = ListNode()
            temp = temp.next
            temp.val = val

        return head.next",None,"class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:

        head = temp = ListNode()
        arr = []

        for ls in lists:
            while ls:
                arr.append(ls.val)
                ls = ls.next

        for val in sorted(arr):   
            temp.next = ListNode(val)
            temp = temp.next

        return head.next
"
2892,python3,moving-stones-until-consecutive-ii,"class Solution:
    def numMovesStonesII(self, stones: List[int]) -> List[int]:
        stones.sort()
        stone_length = len(stones)
        move_penultimate = stones[-2] - stones[0] - stone_length + 2
        move_final = stones[-1] - stones[1] - stone_length + 2 
        most_moves = min(move_penultimate, move_final)
        if move_penultimate == 0 or move_final == 0 : 
            min_legal_moves = min(2, most_moves)
            return [min_legal_moves, most_moves]
        max_legal_moves = 0 
        starting_index = 0
        for index, stone in enumerate(stones) :
            while stones[starting_index] <= stone - stone_length : 
                starting_index += 1
            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) 
        return [stone_length - max_legal_moves, most_moves]",None,"class Solution:
    def numMovesStonesII(self, stones: List[int]) -> List[int]:
        stones.sort()
        stone_length = len(stones)
        move_penultimate = stones[-2] - stones[0] - stone_length + 2
        move_final = stones[-1] - stones[1] - stone_length + 2 
        most_moves = max(move_penultimate, move_final)
        if move_penultimate == 0 or move_final == 0:
            min_legal_moves = min(2, most_moves)
            return [min_legal_moves, most_moves]
        min_legal_moves = most_moves
        starting_index = 0
        for index, stone in enumerate(stones):
            while stone - stones[starting_index] >= stone_length:
                starting_index += 1
            if index - starting_index + 1 == stone_length - 1 and stones[index] - stones[starting_index] + 1 == stone_length - 1:
                min_legal_moves = min(min_legal_moves, 2)
            else:
                min_legal_moves = min(min_legal_moves, stone_length - (index - starting_index + 1))
        return [min_legal_moves, most_moves]
"
2892,python3,moving-stones-until-consecutive-ii,"class Solution:
    def numMovesStonesII(self, stones: List[int]) -> List[int]:
        stones.sort()
        stone_length = len(stones)
        move_penultimate = stones[-2] - stones[0] - stone_length + 2
        move_final = stones[-1] - stones[1] - stone_length + 2 
        most_moves = min(move_penultimate, move_final)
        if move_penultimate == 0 or move_final == 0 : 
            min_legal_moves = min(2, most_moves)
            return [min_legal_moves, most_moves]
        max_legal_moves = 0 
        starting_index = 0
        for index, stone in enumerate(stones) :
            while stones[starting_index] <= stone - stone_length : 
                starting_index += 1
            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) 
        return [stone_length - max_legal_moves, most_moves]",None,"class Solution:
    def numMovesStonesII(self, stones):
        stones.sort()
        stone_length = len(stones)
        move_penultimate = stones[-2] - stones[0] - stone_length + 2
        move_final = stones[-1] - stones[1] - stone_length + 2 
        most_moves = max(move_penultimate, move_final)
        if move_penultimate == 0 or move_final == 0 : 
            min_legal_moves = min(2, most_moves)
            return [min_legal_moves, most_moves]
        max_legal_moves = 0 
        starting_index = 0
        for index, stone in enumerate(stones) :
            while stone - stones[starting_index] >= stone_length : 
                starting_index += 1
            max_legal_moves = max(max_legal_moves, index - starting_index + 1) 
        return [stone_length - max_legal_moves, most_moves]
"
2892,python3,moving-stones-until-consecutive-ii,"class Solution:
    def numMovesStonesII(self, stones: List[int]) -> List[int]:
        stones.sort()
        stone_length = len(stones)
        move_penultimate = stones[-2] - stones[0] - stone_length + 2
        move_final = stones[-1] - stones[1] - stone_length + 2 
        most_moves = min(move_penultimate, move_final)
        if move_penultimate == 0 or move_final == 0 : 
            min_legal_moves = min(2, most_moves)
            return [min_legal_moves, most_moves]
        max_legal_moves = 0 
        starting_index = 0
        for index, stone in enumerate(stones) :
            while stones[starting_index] <= stone - stone_length : 
                starting_index += 1
            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) 
        return [stone_length - max_legal_moves, most_moves]",None,"class Solution:
    def numMovesStonesII(self, stones: List[int]) -> List[int]:
        stones.sort()
        stone_length = len(stones)
        move_penultimate = stones[-2] - stones[0] - stone_length + 2
        move_final = stones[-1] - stones[1] - stone_length + 2 
        most_moves = max(move_penultimate, move_final)
        if move_penultimate == stone_length - 1 or move_final == stone_length - 1 : 
            min_legal_moves = min(2, most_moves)
        else:
            min_legal_moves = float('inf')
            for i in range(stone_length):
                j = bisect_right(stones, stones[i] + stone_length - 1)
                cost = stone_length - (j - i)
                if j < stone_length and stones[j] == stones[i] + stone_length - 1 and cost == 1:
                    cost = 2
                min_legal_moves = min(min_legal_moves, cost)
        return [min_legal_moves, most_moves]
"
2893,python3,binary-tree-level-order-traversal-ii,"class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        queue=deque()
        queue.append(root)
        lst=[]
        while queue:
            levels=[]
            for i in range(len(queue)):
                tmp=queue.popleft()
                if tmp:
                    levels.append(tmp.val)
                    queue.append(tmp.right)  
                    queue.append(tmp.left)   

            if levels:
                lst.append(levels)
        return lst[::-1]",None,"class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        queue=deque()
        queue.append(root)
        lst=[]
        while queue:
            levels=[]
            for i in range(len(queue)):
                tmp=queue.popleft()
                if tmp:
                    levels.append(tmp.val)
                    queue.append(tmp.left)   
                    queue.append(tmp.right)  

            if levels:
                lst.append(levels)
        return lst[::-1]
"
2893,python3,binary-tree-level-order-traversal-ii,"class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        queue=deque()
        queue.append(root)
        lst=[]
        while queue:
            levels=[]
            for i in range(len(queue)):
                tmp=queue.popleft()
                if tmp:
                    levels.append(tmp.val)
                    queue.append(tmp.right)  
                    queue.append(tmp.left)   

            if levels:
                lst.append(levels)
        return lst[::-1]",None,"class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        queue=deque()
        queue.append(root)
        lst=[]
        while queue:
            levels=[]
            for i in range(len(queue)):
                tmp=queue.popleft()
                levels.append(tmp.val)
                if tmp.left:
                    queue.append(tmp.left)
                if tmp.right:
                    queue.append(tmp.right)
            lst.append(levels)
        return lst[::-1]
"
2893,python3,binary-tree-level-order-traversal-ii,"class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        queue=deque()
        queue.append(root)
        lst=[]
        while queue:
            levels=[]
            for i in range(len(queue)):
                tmp=queue.popleft()
                if tmp:
                    levels.append(tmp.val)
                    queue.append(tmp.right)  
                    queue.append(tmp.left)   

            if levels:
                lst.append(levels)
        return lst[::-1]",None,"class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []

        queue=deque()
        queue.append(root)
        lst=[]
        while queue:
            levels=[]
            for i in range(len(queue)):
                tmp=queue.popleft()
                levels.append(tmp.val)
                if tmp.left:
                    queue.append(tmp.left)
                if tmp.right:
                    queue.append(tmp.right)

            if levels:
                lst.append(levels)
        return lst[::-1]
"
2894,python3,find-positive-integer-solution-for-a-given-equation,"""""""
   This is the custom function interface.
   You should not implement it, or speculate about its implementation
   class CustomFunction:
       def f(self, x, y):
  
""""""

class Solution:
    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:
        ans=[]
        y=1000
        for x in range(1,1001):
            while y>1 and customfunction.f(x,y)>z:
                y-=1
            if customfunction.f(x,y)==z:
                ans.append([x,y])
        return ans.append([x,y])",None,"""""""
   This is the custom function interface.
   You should not implement it, or speculate about its implementation
   class CustomFunction:
       def f(self, x, y):
  
""""""

class Solution:
    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:
        ans=[]
        y=1000
        for x in range(1,1001):
            while y>1 and customfunction.f(x,y)>z:
                y-=1
            if customfunction.f(x,y)==z:
                ans.append([x,y])
        return ans
"
2894,python3,find-positive-integer-solution-for-a-given-equation,"""""""
   This is the custom function interface.
   You should not implement it, or speculate about its implementation
   class CustomFunction:
       def f(self, x, y):
  
""""""

class Solution:
    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:
        ans=[]
        y=1000
        for x in range(1,1001):
            while y>1 and customfunction.f(x,y)>z:
                y-=1
            if customfunction.f(x,y)==z:
                ans.append([x,y])
        return ans.append([x,y])",None,"""""""
   This is the custom function interface.
   You should not implement it, or speculate about its implementation
   class CustomFunction:
       def f(self, x, y):
  
""""""

class Solution:
    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:
        ans=[]
        y=1000
        for x in range(1,1001):
            while y>1 and customfunction.f(x,y)>z:
                y-=1
            if customfunction.f(x,y)==z:
                ans.append([x,y])
        return ans
"
2894,python3,find-positive-integer-solution-for-a-given-equation,"""""""
   This is the custom function interface.
   You should not implement it, or speculate about its implementation
   class CustomFunction:
       def f(self, x, y):
  
""""""

class Solution:
    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:
        ans=[]
        y=1000
        for x in range(1,1001):
            while y>1 and customfunction.f(x,y)>z:
                y-=1
            if customfunction.f(x,y)==z:
                ans.append([x,y])
        return ans.append([x,y])",None,"""""""
   This is the custom function interface.
   You should not implement it, or speculate about its implementation
   class CustomFunction:
       def f(self, x, y):
  
""""""

class Solution:
    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:
        ans=[]
        y=1000
        for x in range(1,1001):
            while y>1 and customfunction.f(x,y)>z:
                y-=1
            if customfunction.f(x,y)==z:
                ans.append([x,y])
        return ans
"
2895,python3,removing-minimum-and-maximum-from-array,"class Solution:
    def minimumDeletions(self, nums: List[int]) -> int:
        nums = sorted(nums)
        return min((min(nums.index(min(nums))+1,len(nums)-nums.index(min(nums)))+min(nums.index(max(nums))+1,len(nums)-nums.index(max(nums)))),max(nums.index(min(nums))+1,nums.index(max(nums))+1),max(len(nums)-nums.index(min(nums)),len(nums)-nums.index(max(nums))))",None,"class Solution:
    def minimumDeletions(self, nums: List[int]) -> int:
        min_num = min(nums)
        max_num = max(nums)
        min_index = nums.index(min_num)
        max_index = nums.index(max_num)
        min_del = min(min_index+1, len(nums)-min_index)
        max_del = min(max_index+1, len(nums)-max_index)
        return min(min_del + max_del, max(min_index+1, len(nums)-min_index), max(max_index+1, len(nums)-max_index))
"
2895,python3,removing-minimum-and-maximum-from-array,"class Solution:
    def minimumDeletions(self, nums: List[int]) -> int:
        nums = sorted(nums)
        return min((min(nums.index(min(nums))+1,len(nums)-nums.index(min(nums)))+min(nums.index(max(nums))+1,len(nums)-nums.index(max(nums)))),max(nums.index(min(nums))+1,nums.index(max(nums))+1),max(len(nums)-nums.index(min(nums)),len(nums)-nums.index(max(nums))))",None,"class Solution:
    def minimumDeletions(self, nums: List[int]) -> int:
        max_value = max(nums)
        min_value = min(nums)
        max_index = nums.index(max_value)
        min_index = nums.index(min_value)
        return min(max(max_index, min_index) + 1, len(nums) - min(max_index, min_index))
"
2895,python3,removing-minimum-and-maximum-from-array,"class Solution:
    def minimumDeletions(self, nums: List[int]) -> int:
        nums = sorted(nums)
        return min((min(nums.index(min(nums))+1,len(nums)-nums.index(min(nums)))+min(nums.index(max(nums))+1,len(nums)-nums.index(max(nums)))),max(nums.index(min(nums))+1,nums.index(max(nums))+1),max(len(nums)-nums.index(min(nums)),len(nums)-nums.index(max(nums))))",None,"class Solution:
    def minimumDeletions(self, nums: List[int]) -> int:
        min_index = nums.index(min(nums))
        max_index = nums.index(max(nums))
        return min(max(min_index+1, len(nums)-min_index), max(max_index+1, len(nums)-max_index))
"
2896,python3,maximum-number-of-consecutive-values-you-can-make,"class Solution:
  def getMaximumConsecutive(self, coins: List[int]) -> int:
    ans = 1

    for coin in sorted(coins):
      if coin > ans:
        return ans
      ans += coin

  return ans",None,"class Solution:
    def getMaximumConsecutive(self, coins: List[int]) -> int:
        ans = 1

        for coin in sorted(coins):
            if coin > ans:
                break
            ans += coin

        return ans
"
2896,python3,maximum-number-of-consecutive-values-you-can-make,"class Solution:
  def getMaximumConsecutive(self, coins: List[int]) -> int:
    ans = 1

    for coin in sorted(coins):
      if coin > ans:
        return ans
      ans += coin

  return ans",None,"class Solution:
    def getMaximumConsecutive(self, coins: List[int]) -> int:
        ans = 1

        for coin in sorted(coins):
            if coin > ans:
                break
            ans += coin

        return ans
"
2896,python3,maximum-number-of-consecutive-values-you-can-make,"class Solution:
  def getMaximumConsecutive(self, coins: List[int]) -> int:
    ans = 1

    for coin in sorted(coins):
      if coin > ans:
        return ans
      ans += coin

  return ans",None,"class Solution:
    def getMaximumConsecutive(self, coins: List[int]) -> int:
        ans = 1
        for coin in sorted(coins):
            if coin > ans:
                break
            ans += coin
        return ans
"
2897,python3,sum-of-subarray-minimums,"class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        stack = []
        res = 0
        arr = [float('-inf')] + arr + [float('-inf')]
        for i, num in enumerate(arr):
            while stack and arr[stack[-1]] > num:
                cur = stack.pop()
                res += arr[cur] * (cur - i) * (cur - stack[-1])
            stack.append(i)
        return res % (10**9 + 7)",None,"class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        stack = []
        res = 0
        arr = [float('-inf')] + arr + [float('-inf')]
        for i, num in enumerate(arr):
            while stack and arr[stack[-1]] > num:
                cur = stack.pop()
                res += arr[cur] * (i - stack[-1] - 1) * (cur - stack[-1])
            stack.append(i)
        return res % (10**9 + 7)
"
2897,python3,sum-of-subarray-minimums,"class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        stack = []
        res = 0
        arr = [float('-inf')] + arr + [float('-inf')]
        for i, num in enumerate(arr):
            while stack and arr[stack[-1]] > num:
                cur = stack.pop()
                res += arr[cur] * (cur - i) * (cur - stack[-1])
            stack.append(i)
        return res % (10**9 + 7)",None,"class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        stack = []
        res = 0
        arr = [float('-inf')] + arr + [float('-inf')]
        for i, num in enumerate(arr):
            while stack and arr[stack[-1]] > num:
                cur = stack.pop()
                res += arr[cur] * (i - stack[-1] - 1) * (cur - stack[-1])
            stack.append(i)
        return res % (10**9 + 7)
"
2897,python3,sum-of-subarray-minimums,"class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        stack = []
        res = 0
        arr = [float('-inf')] + arr + [float('-inf')]
        for i, num in enumerate(arr):
            while stack and arr[stack[-1]] > num:
                cur = stack.pop()
                res += arr[cur] * (cur - i) * (cur - stack[-1])
            stack.append(i)
        return res % (10**9 + 7)",None,"class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        stack = []
        res = 0
        arr = [float('-inf')] + arr + [float('-inf')]
        for i, num in enumerate(arr):
            while stack and arr[stack[-1]] > num:
                cur = stack.pop()
                res += arr[cur] * (i - stack[-1] - 1) * (cur - stack[-1])
            stack.append(i)
        return res % (10**9 + 7)
"
2898,python3,can-you-eat-your-favorite-candy-on-your-favorite-day,"class Solution:
    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:
        prefix = [0]
        for x in candiesCount: prefix.append(prefix[-1] + x)
        return [prefix[t-1] < (day+1)*cap and day < prefix[t+1] for t, day, cap in queries]",None,"class Solution:
    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:
        prefix = [0]
        for x in candiesCount: prefix.append(prefix[-1] + x)
        return [prefix[t-1]//cap < day+1 and day+1 <= prefix[t] for t, day, cap in queries]
"
2898,python3,can-you-eat-your-favorite-candy-on-your-favorite-day,"class Solution:
    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:
        prefix = [0]
        for x in candiesCount: prefix.append(prefix[-1] + x)
        return [prefix[t-1] < (day+1)*cap and day < prefix[t+1] for t, day, cap in queries]",None,"class Solution:
    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:
        prefix = [0]
        for x in candiesCount: prefix.append(prefix[-1] + x)
        return [(prefix[t]//cap) <= day and day < prefix[t+1] for t, day, cap in queries]
"
2898,python3,can-you-eat-your-favorite-candy-on-your-favorite-day,"class Solution:
    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:
        prefix = [0]
        for x in candiesCount: prefix.append(prefix[-1] + x)
        return [prefix[t-1] < (day+1)*cap and day < prefix[t+1] for t, day, cap in queries]",None,"class Solution:
    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:
        prefix = [0]
        for x in candiesCount: prefix.append(prefix[-1] + x)
        return [(prefix[t]//cap) <= day < prefix[t+1] for t, day, cap in queries]
"
2899,python3,sliding-window-median,"class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        tree = None
        ans = []
        for i, x in enumerate(nums):
            tree = insert(tree, x)
            if size(tree) > k:
                tree = remove(tree, nums[i - k])
            if size(tree) == k:
                if k % 2 == 1:
                    ans.append(get(tree, k // 2 + 1))
                else:
                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)
        return ans



class Node:
    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']
    def __init__(self, val):
        self.val = val
        self.count = 1
        self.weight = random.random()
        self.size = 1
        self.left = self.right = None


def touch(root):
    if not root:
        return
    root.size = root.count + size(root.left) + size(root.right)


def size(root):
    if not root:
        return 0
    return root.size


def insert(root, val):
    t1, r, t2 = split(root, val)
    if not r:
        r = Node(val)
    else:
        r.count += 1
        touch(r)
    t2 = join(r, t2)
    return join(t1, t2)


def remove(root, val):
    t1, r, t2 = split(root, val)
    if r.count > 1:
        r.count -= 1
        touch(r)
        t2 = join(r, t2)
    return join(t1, t2)


def split(root, val):
    if not root:
        return None, None, None
    elif root.val < val:
        a, b, c = split(root.right, val)
        root.right = a
        touch(root)
        return root, b, c
    elif root.val > val:
        a, b, c = split(root.left, val)
        root.left = c
        touch(root)
        return a, b, root
    else:
        a, c = root.left, root.right
        root.left = root.right = None
        touch(root)
        return a, root, c


def join(t1, t2):
    if not t1:
        return t2
    elif not t2:
        return t1
    elif t1.weight < t2.weight:
        t1.right = join(t1.right, t2)
        touch(t1)
        return t1
    else:
        t2.left = join(t1, t2.left)
        touch(t2)
        return t2


def get(root, index):
    if size(root.left) < index <= size(root.left) + root.count:
        return root.val
    elif size(root.left) + root.count < index:
        return get(root.right, index - root.count)
    else:
        return get(root.left, index)",None,"class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        tree = None
        ans = []
        for i, x in enumerate(nums):
            tree = insert(tree, x)
            if size(tree) > k:
                tree = remove(tree, nums[i - k])
            if size(tree) == k:
                if k % 2 == 1:
                    ans.append(get(tree, k // 2 + 1))
                else:
                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)
        return ans


class Node:
    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']
    def __init__(self, val):
        self.val = val
        self.count = 1
        self.weight = random.random()
        self.size = 1
        self.left = self.right = None

def touch(root):
    if not root:
        return
    root.size = root.count + size(root.left) + size(root.right)

def size(root):
    if not root:
        return 0
    return root.size

def insert(root, val):
    t1, r, t2 = split(root, val)
    if not r:
        r = Node(val)
    else:
        r.count += 1
    touch(r)
    t2 = join(r, t2)
    return join(t1, t2)

def remove(root, val):
    t1, r, t2 = split(root, val)
    if r.count > 1:
        r.count -= 1
        touch(r)
        t2 = join(r, t2)
    return join(t1, t2)

def split(root, val):
    if not root:
        return None, None, None
    if root.val < val:
        a, b, c = split(root.right, val)
        root.right = a
        touch(root)
        return root, b, c
    elif root.val > val:
        a, b, c = split(root.left, val)
        root.left = c
        touch(root)
        return a, b, root
    else:
        a, c = root.left, root.right
        root.left = root.right = None
        touch(root)
        return a, root, c

def join(t1, t2):
    if not t1:
        return t2
    elif not t2:
        return t1
    elif t1.weight < t2.weight:
        t1.right = join(t1.right, t2)
        touch(t1)
        return t1
    else:
        t2.left = join(t1, t2.left)
        touch(t2)
        return t2

def get(root, index):
    if size(root.left) < index <= size(root.left) + root.count:
        return root.val
    elif size(root.left) + root.count < index:
        return get(root.right, index - size(root.left) - root.count)
    else:
        return get(root.left, index)
"
2899,python3,sliding-window-median,"class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        tree = None
        ans = []
        for i, x in enumerate(nums):
            tree = insert(tree, x)
            if size(tree) > k:
                tree = remove(tree, nums[i - k])
            if size(tree) == k:
                if k % 2 == 1:
                    ans.append(get(tree, k // 2 + 1))
                else:
                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)
        return ans



class Node:
    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']
    def __init__(self, val):
        self.val = val
        self.count = 1
        self.weight = random.random()
        self.size = 1
        self.left = self.right = None


def touch(root):
    if not root:
        return
    root.size = root.count + size(root.left) + size(root.right)


def size(root):
    if not root:
        return 0
    return root.size


def insert(root, val):
    t1, r, t2 = split(root, val)
    if not r:
        r = Node(val)
    else:
        r.count += 1
        touch(r)
    t2 = join(r, t2)
    return join(t1, t2)


def remove(root, val):
    t1, r, t2 = split(root, val)
    if r.count > 1:
        r.count -= 1
        touch(r)
        t2 = join(r, t2)
    return join(t1, t2)


def split(root, val):
    if not root:
        return None, None, None
    elif root.val < val:
        a, b, c = split(root.right, val)
        root.right = a
        touch(root)
        return root, b, c
    elif root.val > val:
        a, b, c = split(root.left, val)
        root.left = c
        touch(root)
        return a, b, root
    else:
        a, c = root.left, root.right
        root.left = root.right = None
        touch(root)
        return a, root, c


def join(t1, t2):
    if not t1:
        return t2
    elif not t2:
        return t1
    elif t1.weight < t2.weight:
        t1.right = join(t1.right, t2)
        touch(t1)
        return t1
    else:
        t2.left = join(t1, t2.left)
        touch(t2)
        return t2


def get(root, index):
    if size(root.left) < index <= size(root.left) + root.count:
        return root.val
    elif size(root.left) + root.count < index:
        return get(root.right, index - root.count)
    else:
        return get(root.left, index)",None,"class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        tree = None
        ans = []
        for i, x in enumerate(nums):
            tree = insert(tree, x)
            if size(tree) > k:
                tree = remove(tree, nums[i - k])
            if size(tree) == k:
                if k % 2 == 1:
                    ans.append(get(tree, k // 2 + 1))
                else:
                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)
        return ans



class Node:
    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']
    def __init__(self, val):
        self.val = val
        self.count = 1
        self.weight = random.random()
        self.size = 1
        self.left = self.right = None


def touch(root):
    if not root:
        return
    root.size = root.count + size(root.left) + size(root.right)


def size(root):
    if not root:
        return 0
    return root.size


def insert(root, val):
    t1, r, t2 = split(root, val)
    if not r:
        r = Node(val)
    else:
        r.count += 1
    touch(r)
    t2 = join(r, t2)
    return join(t1, t2)


def remove(root, val):
    t1, r, t2 = split(root, val)
    if r.count > 1:
        r.count -= 1
        touch(r)
        t2 = join(r, t2)
    return join(t1, t2)


def split(root, val):
    if not root:
        return None, None, None
    if root.val < val:
        a, b, c = split(root.right, val)
        root.right = a
        touch(root)
        return root, b, c
    elif root.val > val:
        a, b, c = split(root.left, val)
        root.left = c
        touch(root)
        return a, b, root
    else:
        a, c = root.left, root.right
        root.left = root.right = None
        touch(root)
        return a, root, c


def join(t1, t2):
    if not t1:
        return t2
    elif not t2:
        return t1
    elif t1.weight < t2.weight:
        t1.right = join(t1.right, t2)
        touch(t1)
        return t1
    else:
        t2.left = join(t1, t2.left)
        touch(t2)
        return t2


def get(root, index):
    if size(root.left) < index <= size(root.left) + root.count:
        return root.val
    elif size(root.left) + root.count < index:
        return get(root.right, index - size(root.left) - root.count)
    else:
        return get(root.left, index)
"
2899,python3,sliding-window-median,"class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        tree = None
        ans = []
        for i, x in enumerate(nums):
            tree = insert(tree, x)
            if size(tree) > k:
                tree = remove(tree, nums[i - k])
            if size(tree) == k:
                if k % 2 == 1:
                    ans.append(get(tree, k // 2 + 1))
                else:
                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)
        return ans



class Node:
    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']
    def __init__(self, val):
        self.val = val
        self.count = 1
        self.weight = random.random()
        self.size = 1
        self.left = self.right = None


def touch(root):
    if not root:
        return
    root.size = root.count + size(root.left) + size(root.right)


def size(root):
    if not root:
        return 0
    return root.size


def insert(root, val):
    t1, r, t2 = split(root, val)
    if not r:
        r = Node(val)
    else:
        r.count += 1
        touch(r)
    t2 = join(r, t2)
    return join(t1, t2)


def remove(root, val):
    t1, r, t2 = split(root, val)
    if r.count > 1:
        r.count -= 1
        touch(r)
        t2 = join(r, t2)
    return join(t1, t2)


def split(root, val):
    if not root:
        return None, None, None
    elif root.val < val:
        a, b, c = split(root.right, val)
        root.right = a
        touch(root)
        return root, b, c
    elif root.val > val:
        a, b, c = split(root.left, val)
        root.left = c
        touch(root)
        return a, b, root
    else:
        a, c = root.left, root.right
        root.left = root.right = None
        touch(root)
        return a, root, c


def join(t1, t2):
    if not t1:
        return t2
    elif not t2:
        return t1
    elif t1.weight < t2.weight:
        t1.right = join(t1.right, t2)
        touch(t1)
        return t1
    else:
        t2.left = join(t1, t2.left)
        touch(t2)
        return t2


def get(root, index):
    if size(root.left) < index <= size(root.left) + root.count:
        return root.val
    elif size(root.left) + root.count < index:
        return get(root.right, index - root.count)
    else:
        return get(root.left, index)",None,"class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        tree = None
        ans = []
        for i, x in enumerate(nums):
            tree = insert(tree, x)
            if size(tree) > k:
                tree = remove(tree, nums[i - k])
            if size(tree) == k:
                if k % 2 == 1:
                    ans.append(get(tree, k // 2 + 1))
                else:
                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)
        return ans



class Node:
    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']
    def __init__(self, val):
        self.val = val
        self.count = 1
        self.weight = random.random()
        self.size = 1
        self.left = self.right = None


def touch(root):
    if not root:
        return
    root.size = root.count + size(root.left) + size(root.right)


def size(root):
    if not root:
        return 0
    return root.size


def insert(root, val):
    t1, r, t2 = split(root, val)
    if not r:
        r = Node(val)
    else:
        r.count += 1
    touch(r)
    t2 = join(r, t2)
    return join(t1, t2)


def remove(root, val):
    t1, r, t2 = split(root, val)
    if r.count > 1:
        r.count -= 1
        touch(r)
        t2 = join(r, t2)
    return join(t1, t2)


def split(root, val):
    if not root:
        return None, None, None
    elif root.val < val:
        a, b, c = split(root.right, val)
        root.right = a
        touch(root)
        return root, b, c
    elif root.val > val:
        a, b, c = split(root.left, val)
        root.left = c
        touch(root)
        return a, b, root
    else:
        a, c = root.left, root.right
        root.left = root.right = None
        touch(root)
        return a, root, c


def join(t1, t2):
    if not t1:
        return t2
    elif not t2:
        return t1
    elif t1.weight < t2.weight:
        t1.right = join(t1.right, t2)
        touch(t1)
        return t1
    else:
        t2.left = join(t1, t2.left)
        touch(t2)
        return t2


def get(root, index):
    if size(root.left) < index <= size(root.left) + root.count:
        return root.val
    elif size(root.left) + root.count < index:
        return get(root.right, index - size(root.left) - root.count)
    else:
        return get(root.left, index)
"
2900,python3,kth-largest-sum-in-a-binary-tree,"class Solution:
    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:
        dq = collections.deque([root])
        a = []
        lvl = 1
        while dq:
            lvlsum = 0
            for i in range(len(dq)):
               n = dq.popleft()
               lvlsum += n.val
               if n.left: dq.append(n.left)
               if n.right: dq.append(n.right)
            a.append(lvlsum)
            lvl += 1
        a.sort(reverse=False)
        return a[k-1] if len(a) >= k else -1",None,"class Solution:
    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:
        dq = collections.deque([root])
        a = []
        lvl = 1
        while dq:
            lvlsum = 0
            for i in range(len(dq)):
               n = dq.popleft()
               lvlsum += n.val
               if n.left: dq.append(n.left)
               if n.right: dq.append(n.right)
            a.append(lvlsum)
            lvl += 1
        a.sort(reverse=True)
        return a[k-1] if len(a) >= k else -1
"
2900,python3,kth-largest-sum-in-a-binary-tree,"class Solution:
    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:
        dq = collections.deque([root])
        a = []
        lvl = 1
        while dq:
            lvlsum = 0
            for i in range(len(dq)):
               n = dq.popleft()
               lvlsum += n.val
               if n.left: dq.append(n.left)
               if n.right: dq.append(n.right)
            a.append(lvlsum)
            lvl += 1
        a.sort(reverse=False)
        return a[k-1] if len(a) >= k else -1",None,"class Solution:
    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:
        dq = collections.deque([root])
        a = []
        lvl = 1
        while dq:
            lvlsum = 0
            for i in range(len(dq)):
               n = dq.popleft()
               lvlsum += n.val
               if n.left: dq.append(n.left)
               if n.right: dq.append(n.right)
            a.append(lvlsum)
            lvl += 1
        a.sort(reverse=True)
        return a[k-1] if len(a) >= k else -1
"
2900,python3,kth-largest-sum-in-a-binary-tree,"class Solution:
    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:
        dq = collections.deque([root])
        a = []
        lvl = 1
        while dq:
            lvlsum = 0
            for i in range(len(dq)):
               n = dq.popleft()
               lvlsum += n.val
               if n.left: dq.append(n.left)
               if n.right: dq.append(n.right)
            a.append(lvlsum)
            lvl += 1
        a.sort(reverse=False)
        return a[k-1] if len(a) >= k else -1",None,"class Solution:
    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:
        dq = collections.deque([root])
        a = []
        while dq:
            lvlsum = 0
            for i in range(len(dq)):
                n = dq.popleft()
                lvlsum += n.val
                if n.left: dq.append(n.left)
                if n.right: dq.append(n.right)
            a.append(lvlsum)
        a.sort(reverse=True)
        return a[k-1] if len(a) >= k else -1
"
2901,python3,isomorphic-strings,"class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        return len(set(s))==len(set(t))==len(set(zip(s,t[:len(s)-1])))",None,"class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        return len(set(zip(s, t))) == len(set(s)) == len(set(t))
"
2901,python3,isomorphic-strings,"class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        return len(set(s))==len(set(t))==len(set(zip(s,t[:len(s)-1])))",None,"class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        return len(set(zip(s, t))) == len(set(s)) == len(set(t))
"
2901,python3,isomorphic-strings,"class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        return len(set(s))==len(set(t))==len(set(zip(s,t[:len(s)-1])))",None,"class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        return len(set(zip(s, t))) == len(set(s)) == len(set(t))
"
2902,python3,construct-binary-tree-from-preorder-and-inorder-traversal,"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        inorder_map={val:idx for idx, val in enumerate(inorder)}
        preorder_idx=0

        def treeHelper(left, right):
            nonlocal preorder_idx
            if left>right:
                return None

            node_val = preorder[preorder_idx]
            root=TreeNode(node_val)
            preorder_idx+=1

            inorder_index=inorder_map[node_val]

            root.left = treeHelper(inorder_index+1, right)
            root.right = treeHelper(left, inorder_index-1 )

            return root

        return treeHelper(0, len(inorder)-1)",None,"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        inorder_map={val:idx for idx, val in enumerate(inorder)}
        preorder_idx=0

        def treeHelper(left, right):
            nonlocal preorder_idx
            if left>right:
                return None

            node_val = preorder[preorder_idx]
            root=TreeNode(node_val)
            preorder_idx+=1

            inorder_index=inorder_map[node_val]

            root.left = treeHelper(left, inorder_index-1)
            root.right = treeHelper(inorder_index+1, right)

            return root

        return treeHelper(0, len(inorder)-1)
"
2902,python3,construct-binary-tree-from-preorder-and-inorder-traversal,"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        inorder_map={val:idx for idx, val in enumerate(inorder)}
        preorder_idx=0

        def treeHelper(left, right):
            nonlocal preorder_idx
            if left>right:
                return None

            node_val = preorder[preorder_idx]
            root=TreeNode(node_val)
            preorder_idx+=1

            inorder_index=inorder_map[node_val]

            root.left = treeHelper(inorder_index+1, right)
            root.right = treeHelper(left, inorder_index-1 )

            return root

        return treeHelper(0, len(inorder)-1)",None,"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        inorder_map={val:idx for idx, val in enumerate(inorder)}
        preorder_idx=0

        def treeHelper(left, right):
            nonlocal preorder_idx
            if left>right:
                return None

            node_val = preorder[preorder_idx]
            root=TreeNode(node_val)
            preorder_idx+=1

            inorder_index=inorder_map[node_val]

            root.left = treeHelper(left, inorder_index-1)
            root.right = treeHelper(inorder_index+1, right)

            return root

        return treeHelper(0, len(inorder)-1)
"
2902,python3,construct-binary-tree-from-preorder-and-inorder-traversal,"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        inorder_map={val:idx for idx, val in enumerate(inorder)}
        preorder_idx=0

        def treeHelper(left, right):
            nonlocal preorder_idx
            if left>right:
                return None

            node_val = preorder[preorder_idx]
            root=TreeNode(node_val)
            preorder_idx+=1

            inorder_index=inorder_map[node_val]

            root.left = treeHelper(inorder_index+1, right)
            root.right = treeHelper(left, inorder_index-1 )

            return root

        return treeHelper(0, len(inorder)-1)",None,"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        inorder_map={val: idx for idx, val in enumerate(inorder)}
        preorder_idx=0

        def treeHelper(left, right):
            nonlocal preorder_idx
            if left > right:
                return None

            node_val = preorder[preorder_idx]
            root = TreeNode(node_val)
            preorder_idx += 1

            inorder_index = inorder_map[node_val]

            root.left = treeHelper(left, inorder_index-1)
            root.right = treeHelper(inorder_index+1, right)

            return root

        return treeHelper(0, len(inorder)-1)
"
2903,python3,design-a-text-editor,"class TextEditor:
    def __init__(self):
        self.stack = []
        self.q = deque([])
        
    def addText(self, text: str) -> None:
        for c in text:
            self.q.append(c)

        
    def deleteText(self, k: int) -> int:
        i = 0
        while self.stack and i < k:
            self.stack.pop()
            i += 1
        return i
        
    def cursorLeft(self, k: int) -> str:
        i = 0
        while self.stack and i < k:
            self.q.appendleft(self.stack.pop())
            i += 1
        return """".join(self.stack[-10:]) if len(self.stack) >= 10 else """".join(self.stack)
        
    def cursorRight(self, k: int) -> str:
        i = 0
        while self.q and i < k:
            self.stack.append(self.q.popleft())
            i += 1
        return """".join(self.stack[-10:]) if len(self.stack) >= 10 else """".join(self.stack)",None,"class TextEditor:
    def __init__(self):
        self.stack = []
        self.q = deque([])
        
    def addText(self, text: str) -> None:
        for c in text:
            self.stack.append(c)

        
    def deleteText(self, k: int) -> int:
        i = 0
        while self.stack and i < k:
            self.stack.pop()
            i += 1
        return i
        
    def cursorLeft(self, k: int) -> str:
        i = 0
        while self.stack and i < k:
            self.q.appendleft(self.stack.pop())
            i += 1
        return """".join(list(self.stack[-10:]) + list(self.q)) if len(self.stack) >= 10 else """".join(self.stack + list(self.q))
        
    def cursorRight(self, k: int) -> str:
        i = 0
        while self.q and i < k:
            self.stack.append(self.q.popleft())
            i += 1
        return """".join(list(self.stack[-10:]) + list(self.q)) if len(self.stack) >= 10 else """".join(self.stack + list(self.q))
"
2903,python3,design-a-text-editor,"class TextEditor:
    def __init__(self):
        self.stack = []
        self.q = deque([])
        
    def addText(self, text: str) -> None:
        for c in text:
            self.q.append(c)

        
    def deleteText(self, k: int) -> int:
        i = 0
        while self.stack and i < k:
            self.stack.pop()
            i += 1
        return i
        
    def cursorLeft(self, k: int) -> str:
        i = 0
        while self.stack and i < k:
            self.q.appendleft(self.stack.pop())
            i += 1
        return """".join(self.stack[-10:]) if len(self.stack) >= 10 else """".join(self.stack)
        
    def cursorRight(self, k: int) -> str:
        i = 0
        while self.q and i < k:
            self.stack.append(self.q.popleft())
            i += 1
        return """".join(self.stack[-10:]) if len(self.stack) >= 10 else """".join(self.stack)",None,"class TextEditor:
    def __init__(self):
        self.left_stack = []
        self.right_stack = []
        
    def addText(self, text: str) -> None:
        for c in text:
            self.left_stack.append(c)
        
    def deleteText(self, k: int) -> int:
        i = 0
        while self.left_stack and i < k:
            self.left_stack.pop()
            i += 1
        return i
        
    def cursorLeft(self, k: int) -> str:
        i = 0
        while self.left_stack and i < k:
            self.right_stack.append(self.left_stack.pop())
            i += 1
        return """".join(self.left_stack[-10:]) if len(self.left_stack) >= 10 else """".join(self.left_stack)
        
    def cursorRight(self, k: int) -> str:
        i = 0
        while self.right_stack and i < k:
            self.left_stack.append(self.right_stack.pop())
            i += 1
        return """".join(self.left_stack[-10:]) if len(self.left_stack) >= 10 else """".join(self.left_stack)
"
2903,python3,design-a-text-editor,"class TextEditor:
    def __init__(self):
        self.stack = []
        self.q = deque([])
        
    def addText(self, text: str) -> None:
        for c in text:
            self.q.append(c)

        
    def deleteText(self, k: int) -> int:
        i = 0
        while self.stack and i < k:
            self.stack.pop()
            i += 1
        return i
        
    def cursorLeft(self, k: int) -> str:
        i = 0
        while self.stack and i < k:
            self.q.appendleft(self.stack.pop())
            i += 1
        return """".join(self.stack[-10:]) if len(self.stack) >= 10 else """".join(self.stack)
        
    def cursorRight(self, k: int) -> str:
        i = 0
        while self.q and i < k:
            self.stack.append(self.q.popleft())
            i += 1
        return """".join(self.stack[-10:]) if len(self.stack) >= 10 else """".join(self.stack)",None,"class TextEditor:
    def __init__(self):
        self.stack = []
        self.q = deque([])
        
    def addText(self, text: str) -> None:
        for c in text:
            self.stack.append(c)

        
    def deleteText(self, k: int) -> int:
        i = 0
        while self.stack and i < k:
            self.stack.pop()
            i += 1
        return i
        
    def cursorLeft(self, k: int) -> str:
        i = 0
        while self.stack and i < k:
            self.q.appendleft(self.stack.pop())
            i += 1
        return """".join(self.stack[-10:]) if len(self.stack) >= 10 else """".join(self.stack)
        
    def cursorRight(self, k: int) -> str:
        i = 0
        while self.q and i < k:
            self.stack.append(self.q.popleft())
            i += 1
        return """".join(self.stack[-10:]) if len(self.stack) >= 10 else """".join(self.stack)
"
3039,python3,the-kth-factor-of-n,"class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        j = 0
        for i in range(1, n + 1):
            if n % i == 0:
                num = i
                j += 1
            if j == k:
                break
        return num if j == k+1 else -1",None,"class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        j = 0
        for i in range(1, n + 1):
            if n % i == 0:
                num = i
                j += 1
            if j == k:
                break
        return num if j == k else -1
"
3039,python3,the-kth-factor-of-n,"class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        j = 0
        for i in range(1, n + 1):
            if n % i == 0:
                num = i
                j += 1
            if j == k:
                break
        return num if j == k+1 else -1",None,"class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        j = 0
        for i in range(1, n + 1):
            if n % i == 0:
                num = i
                j += 1
            if j == k:
                return num
        return -1
"
3039,python3,the-kth-factor-of-n,"class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        j = 0
        for i in range(1, n + 1):
            if n % i == 0:
                num = i
                j += 1
            if j == k:
                break
        return num if j == k+1 else -1",None,"class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        j = 0
        for i in range(1, n + 1):
            if n % i == 0:
                num = i
                j += 1
            if j == k:
                break
        return num if j == k else -1
"
3040,python3,check-if-string-is-transformable-with-substring-sort-operations,"class Solution:
    def isTransformable(self, s: str, t: str) -> bool :
        indexes = collections.defaultdict(collections.deque)
        for index, character in enumerate(s) :
            indexes[int(character)].append(index)

        unique_t_values = set([int(t_i) for t_i in t])
        for t_v in unique_t_values : 
            if t_v not in indexes :
                return False 
            
        for character in t : 
            character_designation = int(character)
            if character_designation not in indexes : 
                return False 
            for lesser_character in range(character_designation):
                if indexes[lesser_character] and indexes[lesser_character][0] < indexes[character_designation][0] : 
                    return False 
            indexes[character_designation].popleft()
            if len(indexes[character_designation]) == 0 : 
                indexes.pop(character_designation)
        
        return False",None,"class Solution:
    def isTransformable(self, s: str, t: str) -> bool :
        indexes = collections.defaultdict(collections.deque)
        for index, character in enumerate(s) :
            indexes[int(character)].append(index)

        for character in t : 
            character_designation = int(character)
            if character_designation not in indexes : 
                return False 
            for lesser_character in range(character_designation):
                if indexes[lesser_character] and indexes[lesser_character][0] < indexes[character_designation][0] : 
                    return False 
            indexes[character_designation].popleft()
            if len(indexes[character_designation]) == 0 : 
                indexes.pop(character_designation)
        
        return True
"
3040,python3,check-if-string-is-transformable-with-substring-sort-operations,"class Solution:
    def isTransformable(self, s: str, t: str) -> bool :
        indexes = collections.defaultdict(collections.deque)
        for index, character in enumerate(s) :
            indexes[int(character)].append(index)

        unique_t_values = set([int(t_i) for t_i in t])
        for t_v in unique_t_values : 
            if t_v not in indexes :
                return False 
            
        for character in t : 
            character_designation = int(character)
            if character_designation not in indexes : 
                return False 
            for lesser_character in range(character_designation):
                if indexes[lesser_character] and indexes[lesser_character][0] < indexes[character_designation][0] : 
                    return False 
            indexes[character_designation].popleft()
            if len(indexes[character_designation]) == 0 : 
                indexes.pop(character_designation)
        
        return False",None,"class Solution:
    def isTransformable(self, s: str, t: str) -> bool :
        indexes = collections.defaultdict(collections.deque)
        for index, character in enumerate(s) :
            indexes[int(character)].append(index)

        unique_t_values = set(int(t_i) for t_i in t)
        for t_v in unique_t_values : 
            if t_v not in indexes :
                return False 
            
        for character in t : 
            character_designation = int(character)
            if character_designation not in indexes : 
                return False 
            for lesser_character in range(character_designation):
                if indexes[lesser_character] and indexes[lesser_character][0] < indexes[character_designation][0] : 
                    return False 
            indexes[character_designation].popleft()
            if len(indexes[character_designation]) == 0 : 
                indexes.pop(character_designation)

        return True
"
3040,python3,check-if-string-is-transformable-with-substring-sort-operations,"class Solution:
    def isTransformable(self, s: str, t: str) -> bool :
        indexes = collections.defaultdict(collections.deque)
        for index, character in enumerate(s) :
            indexes[int(character)].append(index)

        unique_t_values = set([int(t_i) for t_i in t])
        for t_v in unique_t_values : 
            if t_v not in indexes :
                return False 
            
        for character in t : 
            character_designation = int(character)
            if character_designation not in indexes : 
                return False 
            for lesser_character in range(character_designation):
                if indexes[lesser_character] and indexes[lesser_character][0] < indexes[character_designation][0] : 
                    return False 
            indexes[character_designation].popleft()
            if len(indexes[character_designation]) == 0 : 
                indexes.pop(character_designation)
        
        return False",None,"class Solution:
    def isTransformable(self, s: str, t: str) -> bool :
        indexes = collections.defaultdict(collections.deque)
        for index, character in enumerate(s) :
            indexes[int(character)].append(index)

        unique_t_values = set([int(t_i) for t_i in t])
        for t_v in unique_t_values : 
            if t_v not in indexes :
                return False 
            
        for character in t : 
            character_designation = int(character)
            if character_designation not in indexes : 
                return False 
            for lesser_character in range(character_designation):
                if indexes[lesser_character] and indexes[lesser_character][0] < indexes[character_designation][0] : 
                    return False 
            indexes[character_designation].popleft()
            if len(indexes[character_designation]) == 0 : 
                indexes.pop(character_designation)
        
        return True
"
3041,python3,restore-ip-addresses,"class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res=[]
        cur=[]
        def backtrack(i):
            if i==len(s) and len(cur)==4:
                res.append(""."".join(cur))
                return
            if len(cur)>4 or i>len(s):
                return
            if s[i]=='0':
                cur.append(s[i])
                backtrack(i+1)
                cur.pop()
                return
            j=0
            while j<4 and i+j<len(s):
                if int(s[i:i+j+1])<256:
                    cur.append(s[i:i+j+1])
                    backtrack(i+j+1)
                    cur.pop()
                j+=1
        backtrack(0)
        return res",None,"class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res=[]
        cur=[]
        def backtrack(i):
            if i==len(s) and len(cur)==4:
                res.append(""."".join(cur))
                return
            if len(cur)>=4 or i>=len(s):
                return
            if s[i]=='0':
                cur.append(s[i])
                backtrack(i+1)
                cur.pop()
                return
            j=0
            while j<3 and i+j<len(s):
                if int(s[i:i+j+1])<256:
                    cur.append(s[i:i+j+1])
                    backtrack(i+j+1)
                    cur.pop()
                j+=1
        backtrack(0)
        return res
"
3041,python3,restore-ip-addresses,"class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res=[]
        cur=[]
        def backtrack(i):
            if i==len(s) and len(cur)==4:
                res.append(""."".join(cur))
                return
            if len(cur)>4 or i>len(s):
                return
            if s[i]=='0':
                cur.append(s[i])
                backtrack(i+1)
                cur.pop()
                return
            j=0
            while j<4 and i+j<len(s):
                if int(s[i:i+j+1])<256:
                    cur.append(s[i:i+j+1])
                    backtrack(i+j+1)
                    cur.pop()
                j+=1
        backtrack(0)
        return res",None,"class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res=[]
        cur=[]
        def backtrack(i):
            if len(cur) == 4:
                if i == len(s):
                    res.append(""."".join(cur))
                return
            if len(cur) > 4 or i >= len(s):
                return
            if s[i]=='0':
                cur.append(s[i])
                backtrack(i+1)
                cur.pop()
                return
            for j in range(1, 4):
                if i+j <= len(s) and int(s[i:i+j])<256:
                    cur.append(s[i:i+j])
                    backtrack(i+j)
                    cur.pop()
        backtrack(0)
        return res
"
3041,python3,restore-ip-addresses,"class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res=[]
        cur=[]
        def backtrack(i):
            if i==len(s) and len(cur)==4:
                res.append(""."".join(cur))
                return
            if len(cur)>4 or i>len(s):
                return
            if s[i]=='0':
                cur.append(s[i])
                backtrack(i+1)
                cur.pop()
                return
            j=0
            while j<4 and i+j<len(s):
                if int(s[i:i+j+1])<256:
                    cur.append(s[i:i+j+1])
                    backtrack(i+j+1)
                    cur.pop()
                j+=1
        backtrack(0)
        return res",None,"class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res=[]
        cur=[]
        def backtrack(i):
            if len(cur)==4 and i==len(s):
                res.append(""."".join(cur))
                return
            if len(cur)>4 or i>=len(s):
                return
            if s[i]=='0':
                cur.append(s[i])
                backtrack(i+1)
                cur.pop()
                return
            j=0
            while j<3 and i+j<len(s):
                if int(s[i:i+j+1])<256:
                    cur.append(s[i:i+j+1])
                    backtrack(i+j+1)
                    cur.pop()
                j+=1
        backtrack(0)
        return res
"
3042,python3,find-players-with-zero-or-one-losses,"class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:

        winners, losers = defaultdict(int), defaultdict(int)

        for match in matches:

            winners[match[0]] += 1
            losers[match[1]] += 1

        res_1, res_2 = [], []

        for k, v in winners.items():
            if k not in losers:
                res_1.append(k)

        for k, v in winners.items(): 
            if v == 1:
                res_2.append(k)

        res_1.sort()
        res_2.sort()
        
        return [ res_1, res_2 ]",None,"class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:

        winners, losers = defaultdict(int), defaultdict(int)

        for match in matches:

            winners[match[0]] += 1
            losers[match[1]] += 1

        res_1, res_2 = [], []

        for k, v in winners.items():
            if k not in losers:
                res_1.append(k)

        for k, v in losers.items(): 
            if v == 1:
                res_2.append(k)

        res_1.sort()
        res_2.sort()

        return [ res_1, res_2 ]
"
3042,python3,find-players-with-zero-or-one-losses,"class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:

        winners, losers = defaultdict(int), defaultdict(int)

        for match in matches:

            winners[match[0]] += 1
            losers[match[1]] += 1

        res_1, res_2 = [], []

        for k, v in winners.items():
            if k not in losers:
                res_1.append(k)

        for k, v in winners.items(): 
            if v == 1:
                res_2.append(k)

        res_1.sort()
        res_2.sort()
        
        return [ res_1, res_2 ]",None,"class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:

        winners, losers = defaultdict(int), defaultdict(int)

        for match in matches:

            winners[match[0]] += 1
            losers[match[1]] += 1

        res_1, res_2 = [], []

        for k, v in winners.items():
            if k not in losers:
                res_1.append(k)

        for k, v in losers.items(): 
            if v == 1:
                res_2.append(k)

        res_1.sort()
        res_2.sort()
        
        return [ res_1, res_2 ]
"
3042,python3,find-players-with-zero-or-one-losses,"class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:

        winners, losers = defaultdict(int), defaultdict(int)

        for match in matches:

            winners[match[0]] += 1
            losers[match[1]] += 1

        res_1, res_2 = [], []

        for k, v in winners.items():
            if k not in losers:
                res_1.append(k)

        for k, v in winners.items(): 
            if v == 1:
                res_2.append(k)

        res_1.sort()
        res_2.sort()
        
        return [ res_1, res_2 ]",None,"class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:

        winners, losers = defaultdict(int), defaultdict(int)

        for match in matches:

            winners[match[0]] += 1
            losers[match[1]] += 1

        res_1, res_2 = [], []

        for k, v in winners.items():
            if k not in losers:
                res_1.append(k)

        for k, v in losers.items(): 
            if v == 1:
                res_2.append(k)

        res_1.sort()
        res_2.sort()
        
        return [ res_1, res_2 ]
"
3043,python3,invalid-transactions,"class Solution:
    def invalidTransactions(self, transactions: List[str]) -> List[str]:
        invalid = []
        txn = collections.defaultdict(list)
        
        for trn in transactions:
            name, time, amount, city = trn.split("","")
            txn[name].append([time,amount,city])
        
        for trans in range(len(transactions)):
            name, time, amount, city = transactions[trans].split("","")
            if int(amount) > 10000:
                invalid.append(transactions[trans])
            else:
                for trn in txn[name]:
                    time_i, _, city_i = trn
                    if city != city_i and abs(int(time) - int(time_i)) <= 60:
                        invalid.append(transactions[trans])
                        break

        return invalid",None,"class Solution:
    def invalidTransactions(self, transactions: List[str]) -> List[str]:
        invalid = set()
        transactions = [trn.split("","") for trn in transactions]
        transactions.sort(key = lambda x: int(x[1]))
        for i, (name1, time1, amount1, city1) in enumerate(transactions):
            if int(amount1) > 1000:
                invalid.add(','.join(transactions[i]))
            for j in range(i):
                name2, time2, amount2, city2 = transactions[j]
                if name1 == name2 and city1 != city2 and int(time1) - int(time2) <= 60:
                    invalid.add(','.join(transactions[i]))
        return list(invalid)
"
3043,python3,invalid-transactions,"class Solution:
    def invalidTransactions(self, transactions: List[str]) -> List[str]:
        invalid = []
        txn = collections.defaultdict(list)
        
        for trn in transactions:
            name, time, amount, city = trn.split("","")
            txn[name].append([time,amount,city])
        
        for trans in range(len(transactions)):
            name, time, amount, city = transactions[trans].split("","")
            if int(amount) > 10000:
                invalid.append(transactions[trans])
            else:
                for trn in txn[name]:
                    time_i, _, city_i = trn
                    if city != city_i and abs(int(time) - int(time_i)) <= 60:
                        invalid.append(transactions[trans])
                        break

        return invalid",None,"class Solution:
    def invalidTransactions(self, transactions: List[str]) -> List[str]:
        invalid = []
        txn = collections.defaultdict(list)
        
        for trn in transactions:
            name, time, amount, city = trn.split("","")
            txn[name].append([time,amount,city])
        
        for trans in range(len(transactions)):
            name, time, amount, city = transactions[trans].split("","")
            if int(amount) > 1000:
                invalid.append(transactions[trans])
            else:
                for trn in txn[name]:
                    time_i, _, city_i = trn
                    if city != city_i and abs(int(time) - int(time_i)) <= 60:
                        invalid.append(transactions[trans])
                        break

        return invalid
"
3043,python3,invalid-transactions,"class Solution:
    def invalidTransactions(self, transactions: List[str]) -> List[str]:
        invalid = []
        txn = collections.defaultdict(list)
        
        for trn in transactions:
            name, time, amount, city = trn.split("","")
            txn[name].append([time,amount,city])
        
        for trans in range(len(transactions)):
            name, time, amount, city = transactions[trans].split("","")
            if int(amount) > 10000:
                invalid.append(transactions[trans])
            else:
                for trn in txn[name]:
                    time_i, _, city_i = trn
                    if city != city_i and abs(int(time) - int(time_i)) <= 60:
                        invalid.append(transactions[trans])
                        break

        return invalid",None,"class Solution:
    def invalidTransactions(self, transactions: List[str]) -> List[str]:
        invalid = []
        txn = collections.defaultdict(list)

        for trn in transactions:
            name, time, amount, city = trn.split("","")
            txn[name].append([time,amount,city])

        for trans in range(len(transactions)):
            name, time, amount, city = transactions[trans].split("","")
            if int(amount) > 1000:
                invalid.append(transactions[trans])
            else:
                for trn in txn[name]:
                    time_i, _, city_i = trn
                    if city != city_i and abs(int(time) - int(time_i)) <= 60:
                        invalid.append(transactions[trans])
                        break

        return invalid
"
3044,python3,binary-search,"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if target not in nums:
            return -1
        
        left, right = 0, len(nums)
        
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        
        return left",None,"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if target not in nums:
            return -1
        
        left, right = 0, len(nums) - 1
        
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            elif nums[mid] > target:
                right = mid - 1
            else:
                return mid
        
        return -1
"
3044,python3,binary-search,"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if target not in nums:
            return -1
        
        left, right = 0, len(nums)
        
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        
        return left",None,"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1 
        
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return -1
"
3044,python3,binary-search,"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if target not in nums:
            return -1
        
        left, right = 0, len(nums)
        
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        
        return left",None,"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        
        return -1
"
3045,python3,sliding-puzzle,"class Solution:
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        def get_neighbors(board):
            neighbors = []
            r, c = 0, 0
            for i in range(2):
                for j in range(3):
                    if board[i][j] == 0:
                        r, c = i, j
            for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                new_r, new_c = r + i, c + j
                if 0 <= new_r < 2 and 0 <= new_c < 3:
                    new_board = [row[:] for row in board]
                    new_board[r][c] = new_board[new_r][new_c]
                    new_board[new_r][new_c] = 0
                    neighbors.append(new_board)
            return neighbors

        queue = deque()
        queue.append((board, 0))
        seen = set()
        seen.add(tuple(tuple(row) for row in board))

        while queue:
            board, moves = queue.popleft()
            if board == [[1, 2, 3], [5, 4, 0]]:      
                return moves
            for neighbor in get_neighbors(board):
                if tuple(tuple(row) for row in neighbor) not in seen:
                    queue.append((neighbor, moves + 1))
                    seen.add(tuple(tuple(row) for row in neighbor))
        return -1",None,"class Solution:
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        def get_neighbors(board):
            neighbors = []
            r, c = 0, 0
            for i in range(2):
                for j in range(3):
                    if board[i][j] == 0:
                        r, c = i, j
            for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                new_r, new_c = r + i, c + j
                if 0 <= new_r < 2 and 0 <= new_c < 3:
                    new_board = [row[:] for row in board]
                    new_board[r][c] = new_board[new_r][new_c]
                    new_board[new_r][new_c] = 0
                    neighbors.append(new_board)
            return neighbors

        queue = deque()
        queue.append((board, 0))
        seen = set()
        seen.add(tuple(tuple(row) for row in board))

        while queue:
            board, moves = queue.popleft()
            if board == [[1, 2, 3], [4, 5, 0]]:      
                return moves
            for neighbor in get_neighbors(board):
                if tuple(tuple(row) for row in neighbor) not in seen:
                    queue.append((neighbor, moves + 1))
                    seen.add(tuple(tuple(row) for row in neighbor))
        return -1
"
3045,python3,sliding-puzzle,"class Solution:
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        def get_neighbors(board):
            neighbors = []
            r, c = 0, 0
            for i in range(2):
                for j in range(3):
                    if board[i][j] == 0:
                        r, c = i, j
            for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                new_r, new_c = r + i, c + j
                if 0 <= new_r < 2 and 0 <= new_c < 3:
                    new_board = [row[:] for row in board]
                    new_board[r][c] = new_board[new_r][new_c]
                    new_board[new_r][new_c] = 0
                    neighbors.append(new_board)
            return neighbors

        queue = deque()
        queue.append((board, 0))
        seen = set()
        seen.add(tuple(tuple(row) for row in board))

        while queue:
            board, moves = queue.popleft()
            if board == [[1, 2, 3], [5, 4, 0]]:      
                return moves
            for neighbor in get_neighbors(board):
                if tuple(tuple(row) for row in neighbor) not in seen:
                    queue.append((neighbor, moves + 1))
                    seen.add(tuple(tuple(row) for row in neighbor))
        return -1",None,"class Solution:
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        def get_neighbors(board):
            neighbors = []
            r, c = 0, 0
            for i in range(2):
                for j in range(3):
                    if board[i][j] == 0:
                        r, c = i, j
            for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                new_r, new_c = r + i, c + j
                if 0 <= new_r < 2 and 0 <= new_c < 3:
                    new_board = [row[:] for row in board]
                    new_board[r][c] = new_board[new_r][new_c]
                    new_board[new_r][new_c] = 0
                    neighbors.append(new_board)
            return neighbors

        queue = deque()
        queue.append((board, 0))
        seen = set()
        seen.add(tuple(tuple(row) for row in board))

        while queue:
            board, moves = queue.popleft()
            if board == [[1, 2, 3], [4, 5, 0]]:      
                return moves
            for neighbor in get_neighbors(board):
                if tuple(tuple(row) for row in neighbor) not in seen:
                    queue.append((neighbor, moves + 1))
                    seen.add(tuple(tuple(row) for row in neighbor))
        return -1
"
3045,python3,sliding-puzzle,"class Solution:
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        def get_neighbors(board):
            neighbors = []
            r, c = 0, 0
            for i in range(2):
                for j in range(3):
                    if board[i][j] == 0:
                        r, c = i, j
            for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                new_r, new_c = r + i, c + j
                if 0 <= new_r < 2 and 0 <= new_c < 3:
                    new_board = [row[:] for row in board]
                    new_board[r][c] = new_board[new_r][new_c]
                    new_board[new_r][new_c] = 0
                    neighbors.append(new_board)
            return neighbors

        queue = deque()
        queue.append((board, 0))
        seen = set()
        seen.add(tuple(tuple(row) for row in board))

        while queue:
            board, moves = queue.popleft()
            if board == [[1, 2, 3], [5, 4, 0]]:      
                return moves
            for neighbor in get_neighbors(board):
                if tuple(tuple(row) for row in neighbor) not in seen:
                    queue.append((neighbor, moves + 1))
                    seen.add(tuple(tuple(row) for row in neighbor))
        return -1",None,"class Solution:
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        def get_neighbors(board):
            neighbors = []
            r, c = 0, 0
            for i in range(2):
                for j in range(3):
                    if board[i][j] == 0:
                        r, c = i, j
            for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                new_r, new_c = r + i, c + j
                if 0 <= new_r < 2 and 0 <= new_c < 3:
                    new_board = [row[:] for row in board]
                    new_board[r][c] = new_board[new_r][new_c]
                    new_board[new_r][new_c] = 0
                    neighbors.append(new_board)
            return neighbors

        queue = deque()
        queue.append((board, 0))
        seen = set()
        seen.add(tuple(tuple(row) for row in board))

        while queue:
            board, moves = queue.popleft()
            if board == [[1, 2, 3], [4, 5, 0]]:      
                return moves
            for neighbor in get_neighbors(board):
                if tuple(tuple(row) for row in neighbor) not in seen:
                    queue.append((neighbor, moves + 1))
                    seen.add(tuple(tuple(row) for row in neighbor))
        return -1
"
3046,python3,partition-array-into-three-parts-with-equal-sum,"class Solution:
    def canThreePartsEqualSum(self, arr: List[int]) -> bool:
        total = sum(arr)
        each_sum = total//3
        if total % 3 != 0: return False
        sumi = count = 0
        for x in arr:
            sumi += x
            if sumi == each_sum:
                sumi = 0
                count += 1
            if count == 2:
                return True
        return False",None,"class Solution:
    def canThreePartsEqualSum(self, arr: List[int]) -> bool:
        total = sum(arr)
        each_sum = total//3
        if total % 3 != 0: return False
        sumi = count = 0
        for x in arr:
            sumi += x
            if sumi == each_sum:
                sumi = 0
                count += 1
        if count >= 3:
            return True
        return False
"
3046,python3,partition-array-into-three-parts-with-equal-sum,"class Solution:
    def canThreePartsEqualSum(self, arr: List[int]) -> bool:
        total = sum(arr)
        each_sum = total//3
        if total % 3 != 0: return False
        sumi = count = 0
        for x in arr:
            sumi += x
            if sumi == each_sum:
                sumi = 0
                count += 1
            if count == 2:
                return True
        return False",None,"class Solution:
    def canThreePartsEqualSum(self, arr: List[int]) -> bool:
        total = sum(arr)
        each_sum = total//3
        if total % 3 != 0: return False
        sumi = count = 0
        for x in arr:
            sumi += x
            if sumi == each_sum:
                sumi = 0
                count += 1
        return count >= 3
"
3046,python3,partition-array-into-three-parts-with-equal-sum,"class Solution:
    def canThreePartsEqualSum(self, arr: List[int]) -> bool:
        total = sum(arr)
        each_sum = total//3
        if total % 3 != 0: return False
        sumi = count = 0
        for x in arr:
            sumi += x
            if sumi == each_sum:
                sumi = 0
                count += 1
            if count == 2:
                return True
        return False",None,"class Solution:
    def canThreePartsEqualSum(self, arr: List[int]) -> bool:
        total = sum(arr)
        each_sum = total//3
        if total % 3 != 0: return False
        sumi = count = 0
        for x in arr:
            sumi += x
            if sumi == each_sum:
                sumi = 0
                count += 1
        if count >= 3:
            return True
        return False
"
3047,python3,palindrome-pairs,"class Solution:
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        backward, res = {}, []
        for i, word in enumerate(words):
            backward[word[::-1]] = i

        for i, word in enumerate(words):
            
            if word in backward and backward[word] != i:
                res.append([i, backward[word]])
                
            if word != """" and """" in backward and word == word[::-1]:
                res.append([i, backward[""""]])
                res.append([backward[""""], i])
                
            for j in range(len(word)):
                if word[j:] in backward and word[:j] == word[j::-1]:
                    res.append([backward[word[j:]], i])
                if word[:j] in backward and word[j:] == word[:j-1:-1]:
                    res.append([i, backward[word[:j]]])
                    
        return res",None,"class Solution:
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        backward, res = {}, []
        for i, word in enumerate(words):
            backward[word[::-1]] = i

        for i, word in enumerate(words):
            
            if word in backward and backward[word] != i:
                res.append([i, backward[word]])
                
            if word != """" and """" in backward and word == word[::-1]:
                res.append([i, backward[""""]])
                res.append([backward[""""], i])
                
            for j in range(1, len(word)):
                if word[j:] in backward and word[:j] == word[j::-1]:
                    res.append([i, backward[word[j:]]])
                if word[:j] in backward and word[j:] == word[:j:-1]:
                    res.append([i, backward[word[:j]]])
                    
        return res
"
3047,python3,palindrome-pairs,"class Solution:
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        backward, res = {}, []
        for i, word in enumerate(words):
            backward[word[::-1]] = i

        for i, word in enumerate(words):
            
            if word in backward and backward[word] != i:
                res.append([i, backward[word]])
                
            if word != """" and """" in backward and word == word[::-1]:
                res.append([i, backward[""""]])
                res.append([backward[""""], i])
                
            for j in range(len(word)):
                if word[j:] in backward and word[:j] == word[j::-1]:
                    res.append([backward[word[j:]], i])
                if word[:j] in backward and word[j:] == word[:j-1:-1]:
                    res.append([i, backward[word[:j]]])
                    
        return res",None,"class Solution:
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        def is_palindrome(check):
            return check == check[::-1]

        words_by_revert = {word[::-1]: i for i, word in enumerate(words)}
        valid_pairs = []

        for i, word in enumerate(words):
            for j in range(len(word) + 1):
                prefix, suffix = word[:j], word[j:]
                if is_palindrome(prefix):
                    back = words_by_revert.get(suffix)
                    if back is not None and back != i:
                        valid_pairs.append([back, i])
                if j != len(word) and is_palindrome(suffix):
                    back = words_by_revert.get(prefix)
                    if back is not None and back != i:
                        valid_pairs.append([i, back])
        return valid_pairs
"
3047,python3,palindrome-pairs,"class Solution:
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        backward, res = {}, []
        for i, word in enumerate(words):
            backward[word[::-1]] = i

        for i, word in enumerate(words):
            
            if word in backward and backward[word] != i:
                res.append([i, backward[word]])
                
            if word != """" and """" in backward and word == word[::-1]:
                res.append([i, backward[""""]])
                res.append([backward[""""], i])
                
            for j in range(len(word)):
                if word[j:] in backward and word[:j] == word[j::-1]:
                    res.append([backward[word[j:]], i])
                if word[:j] in backward and word[j:] == word[:j-1:-1]:
                    res.append([i, backward[word[:j]]])
                    
        return res",None,"class Solution:
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        backward, res = {}, []
        for i, word in enumerate(words):
            backward[word[::-1]] = i
        
        for i, word in enumerate(words):
            
            if word != """" and """" in backward:
                if word == word[::-1]:
                    res.append([i, backward[""""]])
                    res.append([backward[""""], i])
            
            for j in range(1,len(word)):
                if word[:j] in backward and word[j:] == word[j:][::-1]:
                    res.append([backward[word[:j]], i])
                if word[j:] in backward and word[:j] == word[:j][::-1]:
                    res.append([i, backward[word[j:]]])
                    
        return res
"
3048,python3,minimum-bit-flips-to-convert-number,"class Solution:
    def minBitFlips(self, start: int, goal: int) -> int:
        s=bin(start)[2:].zfill(50)
        g=bin(goal)[2:].zfill(50)
        count=0
        for i in range(51):
            if s[i]!=g[i]:
                count+=1
        return count",None,"class Solution:
    def minBitFlips(self, start: int, goal: int) -> int:
        s=bin(start)[2:].zfill(32)
        g=bin(goal)[2:].zfill(32)
        count=0
        for i in range(32):
            if s[i]!=g[i]:
                count+=1
        return count
"
3048,python3,minimum-bit-flips-to-convert-number,"class Solution:
    def minBitFlips(self, start: int, goal: int) -> int:
        s=bin(start)[2:].zfill(50)
        g=bin(goal)[2:].zfill(50)
        count=0
        for i in range(51):
            if s[i]!=g[i]:
                count+=1
        return count",None,"class Solution:
    def minBitFlips(self, start: int, goal: int) -> int:
        s=bin(start)[2:].zfill(32)
        g=bin(goal)[2:].zfill(32)
        count=0
        for i in range(32):
            if s[i]!=g[i]:
                count+=1
        return count
"
3048,python3,minimum-bit-flips-to-convert-number,"class Solution:
    def minBitFlips(self, start: int, goal: int) -> int:
        s=bin(start)[2:].zfill(50)
        g=bin(goal)[2:].zfill(50)
        count=0
        for i in range(51):
            if s[i]!=g[i]:
                count+=1
        return count",None,"class Solution:
    def minBitFlips(self, start: int, goal: int) -> int:
        s=bin(start)[2:].zfill(32)
        g=bin(goal)[2:].zfill(32)
        count=0
        for i in range(32):
            if s[i]!=g[i]:
                count+=1
        return count
"
3049,python3,maximum-profit-of-operating-a-centennial-wheel,"class Solution:
    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
        maxProfit=-1
        ans=i=curRounds=curCustomers=rem=0
        while i<len(customers) or rem:
            if i<len(customers):
                rem+=customers[i]
                i+=1
            curRounds+=1
            if rem-4>=0:
                rem-=4
                curCustomers+=4
            else:
                curCustomers+=rem
                rem=0
            curProfit=(curCustomers*boardingCost)-(curRounds*runningCost)
            if curProfit>=maxProfit:
                maxProfit=curProfit
                ans=curRounds
        return -1 if maxProfit<=0 else ans",None,"class Solution:
    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
        maxProfit=-1
        ans=i=curRounds=curCustomers=rem=0
        while i<len(customers) or rem>0:
            if i<len(customers):
                rem+=customers[i]
                i+=1
            curRounds+=1
            if rem-4>=0:
                rem-=4
                curCustomers+=4
            else:
                curCustomers+=rem
                rem=0
            curProfit=(curCustomers*boardingCost)-(curRounds*runningCost)
            if curProfit>maxProfit:
                maxProfit=curProfit
                ans=curRounds
        return -1 if maxProfit<=0 else ans
"
3049,python3,maximum-profit-of-operating-a-centennial-wheel,"class Solution:
    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
        maxProfit=-1
        ans=i=curRounds=curCustomers=rem=0
        while i<len(customers) or rem:
            if i<len(customers):
                rem+=customers[i]
                i+=1
            curRounds+=1
            if rem-4>=0:
                rem-=4
                curCustomers+=4
            else:
                curCustomers+=rem
                rem=0
            curProfit=(curCustomers*boardingCost)-(curRounds*runningCost)
            if curProfit>=maxProfit:
                maxProfit=curProfit
                ans=curRounds
        return -1 if maxProfit<=0 else ans",None,"class Solution:
    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
        maxProfit=-1
        ans=i=curRounds=curCustomers=rem=0
        while i<len(customers) or rem:
            if i<len(customers):
                rem+=customers[i]
                i+=1
            curRounds+=1
            if rem-4>=0:
                rem-=4
                curCustomers+=4
            else:
                curCustomers+=rem
                rem=0
            curProfit=(curCustomers*boardingCost)-(curRounds*runningCost)
            if curProfit>maxProfit:
                maxProfit=curProfit
                ans=curRounds
        return -1 if maxProfit<=0 else ans
"
3049,python3,maximum-profit-of-operating-a-centennial-wheel,"class Solution:
    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
        maxProfit=-1
        ans=i=curRounds=curCustomers=rem=0
        while i<len(customers) or rem:
            if i<len(customers):
                rem+=customers[i]
                i+=1
            curRounds+=1
            if rem-4>=0:
                rem-=4
                curCustomers+=4
            else:
                curCustomers+=rem
                rem=0
            curProfit=(curCustomers*boardingCost)-(curRounds*runningCost)
            if curProfit>=maxProfit:
                maxProfit=curProfit
                ans=curRounds
        return -1 if maxProfit<=0 else ans",None,"class Solution:
    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
        maxProfit=-1
        ans=i=curRounds=curCustomers=rem=0
        while i<len(customers) or rem:
            if i<len(customers):
                rem+=customers[i]
                i+=1
            curRounds+=1
            if rem-4>=0:
                rem-=4
                curCustomers+=4
            else:
                curCustomers+=rem
                rem=0
            curProfit=(curCustomers*boardingCost)-(curRounds*runningCost)
            if curProfit>maxProfit:
                maxProfit=curProfit
                ans=curRounds
        return -1 if maxProfit<0 else ans
"
3050,python3,make-array-zero-by-subtracting-equal-amounts,"class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        uniq_non_zero = set()
        for num in nums:
            if num != 0:
                continue
            uniq_non_zero.add(num)
        return len(uniq_non_zero)",None,"class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        uniq_non_zero = set()
        for num in nums:
            if num != 0:
                uniq_non_zero.add(num)
        return len(uniq_non_zero)
"
3050,python3,make-array-zero-by-subtracting-equal-amounts,"class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        uniq_non_zero = set()
        for num in nums:
            if num != 0:
                continue
            uniq_non_zero.add(num)
        return len(uniq_non_zero)",None,"class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        uniq_non_zero = set()
        for num in nums:
            if num != 0:
                uniq_non_zero.add(num)
        return len(uniq_non_zero)
"
3050,python3,make-array-zero-by-subtracting-equal-amounts,"class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        uniq_non_zero = set()
        for num in nums:
            if num != 0:
                continue
            uniq_non_zero.add(num)
        return len(uniq_non_zero)",None,"class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        uniq_non_zero = set()
        for num in nums:
            if num != 0:
                uniq_non_zero.add(num)
        return len(uniq_non_zero)
"
3051,python3,next-greater-element-i,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        out=[]
        for i in range(0,len(nums1)):
            if(nums2.index(nums1[i])==len(nums2)-1):
                out.append(-1)
            else:
                j=nums2.index(nums1[i])+1
                while(1):
                    if(nums1[i]<nums2[j]):
                        out.append(nums2[j])
                        break
                    if(j==len(nums2)):
                        out.append(-1)
                        break
                    j+=1
        return out",None,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        out=[]
        for i in range(0,len(nums1)):
            if(nums2.index(nums1[i])==len(nums2)-1):
                out.append(-1)
            else:
                j=nums2.index(nums1[i])+1
                while(1):
                    if(nums1[i]<nums2[j]):
                        out.append(nums2[j])
                        break
                    if(j==len(nums2)-1):
                        out.append(-1)
                        break
                    j+=1
        return out
"
3051,python3,next-greater-element-i,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        out=[]
        for i in range(0,len(nums1)):
            if(nums2.index(nums1[i])==len(nums2)-1):
                out.append(-1)
            else:
                j=nums2.index(nums1[i])+1
                while(1):
                    if(nums1[i]<nums2[j]):
                        out.append(nums2[j])
                        break
                    if(j==len(nums2)):
                        out.append(-1)
                        break
                    j+=1
        return out",None,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        out=[]
        for i in range(0,len(nums1)):
            if(nums2.index(nums1[i])==len(nums2)-1):
                out.append(-1)
            else:
                j=nums2.index(nums1[i])+1
                while(1):
                    if(j==len(nums2)):
                        out.append(-1)
                        break
                    if(nums1[i]<nums2[j]):
                        out.append(nums2[j])
                        break
                    j+=1
        return out
"
3051,python3,next-greater-element-i,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        out=[]
        for i in range(0,len(nums1)):
            if(nums2.index(nums1[i])==len(nums2)-1):
                out.append(-1)
            else:
                j=nums2.index(nums1[i])+1
                while(1):
                    if(nums1[i]<nums2[j]):
                        out.append(nums2[j])
                        break
                    if(j==len(nums2)):
                        out.append(-1)
                        break
                    j+=1
        return out",None,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        out = []
        for i in range(0, len(nums1)):
            if(nums2.index(nums1[i]) == len(nums2) - 1):
                out.append(-1)
            else:
                j = nums2.index(nums1[i]) + 1
                while(1):
                    if(nums1[i] < nums2[j]):
                        out.append(nums2[j])
                        break
                    if(j == len(nums2) - 1):
                        out.append(-1)
                        break
                    j += 1
        return out
"
3052,python3,binary-tree-level-order-traversal-ii,"class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        def checkReverse(ans):
            l,r = 0,len(ans)-1
            while l<=r:
                ans[l],ans[r] = ans[r],ans[l]
                l+=1
                r-=1
            return ans

        if not root: return None
        q,ans = [root],[]
        while q:
            n,l = len(q),[]
            for i in range(n):
                curr = q.pop(0)
                l.append(curr.val)
                q.append(curr.left)
                q.append(curr.right)

            ans.append(l)
        return checkReverse(ans)",None,"class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        def checkReverse(ans):
            l,r = 0,len(ans)-1
            while l<=r:
                ans[l],ans[r] = ans[r],ans[l]
                l+=1
                r-=1
            return ans

        if not root: return []
        q,ans = [root],[]
        while q:
            n,l = len(q),[]
            for i in range(n):
                curr = q.pop(0)
                if curr: 
                    l.append(curr.val)
                    q.append(curr.left)
                    q.append(curr.right)

            if l:
                ans.append(l)
        return checkReverse(ans)
"
3052,python3,binary-tree-level-order-traversal-ii,"class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        def checkReverse(ans):
            l,r = 0,len(ans)-1
            while l<=r:
                ans[l],ans[r] = ans[r],ans[l]
                l+=1
                r-=1
            return ans

        if not root: return None
        q,ans = [root],[]
        while q:
            n,l = len(q),[]
            for i in range(n):
                curr = q.pop(0)
                l.append(curr.val)
                q.append(curr.left)
                q.append(curr.right)

            ans.append(l)
        return checkReverse(ans)",None,"class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        def checkReverse(ans):
            l,r = 0,len(ans)-1
            while l<=r:
                ans[l],ans[r] = ans[r],ans[l]
                l+=1
                r-=1
            return ans

        if not root: return []
        q,ans = [root],[]
        while q:
            n,l = len(q),[]
            for i in range(n):
                curr = q.pop(0)
                l.append(curr.val)
                if curr.left:
                    q.append(curr.left)
                if curr.right:
                    q.append(curr.right)

            ans.append(l)
        return checkReverse(ans)
"
3052,python3,binary-tree-level-order-traversal-ii,"class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        def checkReverse(ans):
            l,r = 0,len(ans)-1
            while l<=r:
                ans[l],ans[r] = ans[r],ans[l]
                l+=1
                r-=1
            return ans

        if not root: return None
        q,ans = [root],[]
        while q:
            n,l = len(q),[]
            for i in range(n):
                curr = q.pop(0)
                l.append(curr.val)
                q.append(curr.left)
                q.append(curr.right)

            ans.append(l)
        return checkReverse(ans)",None,"class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        def checkReverse(ans):
            return ans[::-1]
           
        if not root: return []
        q,ans = [root],[]
        while q:
            n,l = len(q),[]
            for i in range(n):
                curr = q.pop(0)
                if curr is not None:
                    l.append(curr.val)
                    q.append(curr.left)
                    q.append(curr.right)
                    
            if l:
                ans.append(l)
        return checkReverse(ans)
"
3053,python3,make-k-subarray-sums-equal,"class Solution:
    def makeSubKSumEqual(self, A: List[int], K: int) -> int:
        lA = len(A)
        g = gcd(lA, K)
        retV = 0
        for i in range(g):
            med = int(median(A[i:g]))
            retV += sum(abs(a-med) for a in A[i:g])
            
        return retV",None,"class Solution:
    def makeSubKSumEqual(self, A: List[int], K: int) -> int:
        lA = len(A)
        g = gcd(lA, K)
        retV = 0
        for i in range(g):
            med = int(median([A[i+j*g] for j in range(K)]))
            retV += sum(abs(A[i+j*g]-med) for j in range(K))
        return retV
"
3053,python3,make-k-subarray-sums-equal,"class Solution:
    def makeSubKSumEqual(self, A: List[int], K: int) -> int:
        lA = len(A)
        g = gcd(lA, K)
        retV = 0
        for i in range(g):
            med = int(median(A[i:g]))
            retV += sum(abs(a-med) for a in A[i:g])
            
        return retV",None,"class Solution:
    def makeSubKSumEqual(self, A: List[int], K: int) -> int:
        from math import gcd
        from statistics import median
        
        lA = len(A)
        g = gcd(lA, K)
        retV = 0
        for i in range(g):
            med = median(A[i::g])
            retV += sum(abs(a-med) for a in A[i::g])
            
        return int(retV)
"
3053,python3,make-k-subarray-sums-equal,"class Solution:
    def makeSubKSumEqual(self, A: List[int], K: int) -> int:
        lA = len(A)
        g = gcd(lA, K)
        retV = 0
        for i in range(g):
            med = int(median(A[i:g]))
            retV += sum(abs(a-med) for a in A[i:g])
            
        return retV",None,"class Solution:
    def makeSubKSumEqual(self, A: List[int], K: int) -> int:
        lA = len(A)
        g = math.gcd(lA, K)
        retV = 0
        groups = [sorted(A[i::g]) for i in range(g)]
        for group in groups:
            med = group[len(group) // 2]
            retV += sum(abs(a-med) for a in group)
        return retV
"
3054,python3,node-with-highest-edge-score,"class Solution:
    def edgeScore(self, edges: List[int]) -> int:
        n=len(edges)
        sc=[0]*n
        mx=0
        ans=0
        for i in range(n):
            sc[edges[i]]+=i
            if sc[edges[i]]>mx and i != n-1: 
                mx=sc[edges[i]]
                ans=edges[i]
            elif sc[edges[i]]==mx:
                if ans>edges[i]:
                    ans=edges[i]
        return ans",None,"class Solution:
    def edgeScore(self, edges: List[int]) -> int:
        n = len(edges)
        sc = [0] * n
        mx = 0
        ans = 0
        for i in range(n):
            sc[edges[i]] += i
            if sc[edges[i]] > mx or (sc[edges[i]] == mx and ans > edges[i]):
                mx = sc[edges[i]]
                ans = edges[i]
        return ans
"
3054,python3,node-with-highest-edge-score,"class Solution:
    def edgeScore(self, edges: List[int]) -> int:
        n=len(edges)
        sc=[0]*n
        mx=0
        ans=0
        for i in range(n):
            sc[edges[i]]+=i
            if sc[edges[i]]>mx and i != n-1: 
                mx=sc[edges[i]]
                ans=edges[i]
            elif sc[edges[i]]==mx:
                if ans>edges[i]:
                    ans=edges[i]
        return ans",None,"class Solution:
    def edgeScore(self, edges: List[int]) -> int:
        n=len(edges)
        sc=[0]*n
        mx=0
        ans=0
        for i in range(n):
            sc[edges[i]]+=i
        for i in range(n):
            if sc[i] > mx:
                mx = sc[i]
                ans = i
            elif sc[i] == mx and i < ans:
                ans = i
        return ans
"
3054,python3,node-with-highest-edge-score,"class Solution:
    def edgeScore(self, edges: List[int]) -> int:
        n=len(edges)
        sc=[0]*n
        mx=0
        ans=0
        for i in range(n):
            sc[edges[i]]+=i
            if sc[edges[i]]>mx and i != n-1: 
                mx=sc[edges[i]]
                ans=edges[i]
            elif sc[edges[i]]==mx:
                if ans>edges[i]:
                    ans=edges[i]
        return ans",None,"class Solution:
    def edgeScore(self, edges: List[int]) -> int:
        n=len(edges)
        sc=[0]*n
        mx=-1
        ans=-1
        for i in range(n):
            sc[edges[i]]+=i
            if sc[edges[i]]>mx: 
                mx=sc[edges[i]]
                ans=edges[i]
            elif sc[edges[i]]==mx:
                if ans>edges[i]:
                    ans=edges[i]
        return ans
"
3055,python3,minimum-cost-to-make-at-least-one-valid-path-in-a-grid,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:

        m, n, cost, queue = len(grid), len(grid[0]), 0, deque()
        M, N = range(m), range(n)

        seen = lambda x,y : not x in M or y not in N or not grid[x][y]
        dir = ((),(0,1), (0,-1), (1,0), (-1,0))

        def dfs(x: int,y: int)->None:
            while not seen(x,y):
                (dx,dy), grid[x][y] = dir[grid[x][y]], None
                queue.append((x,y))
                x,y = x+dx, y+dy
            return

        dfs(0, 0)
        cost += 1

        while queue:
            if (m-1, n-1) in queue: return cost
            cost +=1 
            q = len(queue)

            for _ in range(q):
                x, y = queue.popleft()
                for dx,dy in dir[1:]:
                    dfs(x+dx, y+dy)",None,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:

        m, n, cost, queue = len(grid), len(grid[0]), 0, deque()
        M, N = range(m), range(n)

        seen = lambda x,y : x not in M or y not in N or not grid[x][y]
        dir = ((),(0,1), (0,-1), (1,0), (-1,0))

        def dfs(x: int,y: int)->None:
            while not seen(x,y):
                (dx,dy), grid[x][y] = dir[grid[x][y]], None
                queue.append((x,y))
                x,y = x+dx, y+dy
            return

        dfs(0, 0)

        while queue:
            if (m-1, n-1) in queue: return cost
            cost +=1 
            q = len(queue)

            for _ in range(q):
                x, y = queue.popleft()
                for dx,dy in dir[1:]:
                    dfs(x+dx, y+dy)
        
        return cost
"
3055,python3,minimum-cost-to-make-at-least-one-valid-path-in-a-grid,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:

        m, n, cost, queue = len(grid), len(grid[0]), 0, deque()
        M, N = range(m), range(n)

        seen = lambda x,y : not x in M or y not in N or not grid[x][y]
        dir = ((),(0,1), (0,-1), (1,0), (-1,0))

        def dfs(x: int,y: int)->None:
            while not seen(x,y):
                (dx,dy), grid[x][y] = dir[grid[x][y]], None
                queue.append((x,y))
                x,y = x+dx, y+dy
            return

        dfs(0, 0)
        cost += 1

        while queue:
            if (m-1, n-1) in queue: return cost
            cost +=1 
            q = len(queue)

            for _ in range(q):
                x, y = queue.popleft()
                for dx,dy in dir[1:]:
                    dfs(x+dx, y+dy)",None,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:

        m, n, cost, queue = len(grid), len(grid[0]), 0, deque()
        M, N = range(m), range(n)

        seen = lambda x,y : not (x in M and y in N and grid[x][y])
        dir = ((),(0,1), (0,-1), (1,0), (-1,0))

        def dfs(x: int,y: int)->None:
            while not seen(x,y):
                (dx,dy), grid[x][y] = dir[grid[x][y]], None
                queue.append((x,y))
                x, y = x + dx, y + dy
            return

        dfs(0, 0)

        while queue:
            if (m-1, n-1) in queue: return cost
            cost +=1 
            q = len(queue)

            for _ in range(q):
                x, y = queue.popleft()
                for dx,dy in dir[1:]:
                    dfs(x+dx, y+dy)
        return cost
"
3055,python3,minimum-cost-to-make-at-least-one-valid-path-in-a-grid,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:

        m, n, cost, queue = len(grid), len(grid[0]), 0, deque()
        M, N = range(m), range(n)

        seen = lambda x,y : not x in M or y not in N or not grid[x][y]
        dir = ((),(0,1), (0,-1), (1,0), (-1,0))

        def dfs(x: int,y: int)->None:
            while not seen(x,y):
                (dx,dy), grid[x][y] = dir[grid[x][y]], None
                queue.append((x,y))
                x,y = x+dx, y+dy
            return

        dfs(0, 0)
        cost += 1

        while queue:
            if (m-1, n-1) in queue: return cost
            cost +=1 
            q = len(queue)

            for _ in range(q):
                x, y = queue.popleft()
                for dx,dy in dir[1:]:
                    dfs(x+dx, y+dy)",None,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:

        m, n, cost, queue = len(grid), len(grid[0]), 0, deque()
        M, N = range(m), range(n)

        seen = lambda x,y : x not in M or y not in N or not grid[x][y]
        dir = ((),(0,1), (0,-1), (1,0), (-1,0))

        def dfs(x: int,y: int)->None:
            while not seen(x,y):
                (dx,dy), grid[x][y] = dir[grid[x][y]], None
                queue.append((x,y))
                x,y = x+dx, y+dy
            return

        dfs(0, 0)

        while queue:
            if (m-1, n-1) in queue: return cost
            cost +=1 
            q = len(queue)

            for _ in range(q):
                x, y = queue.popleft()
                for dx,dy in dir[1:]:
                    dfs(x+dx, y+dy)

        return cost
"
3056,python3,grid-game,"class Solution:
    def gridGame(self, grid: List[List[int]]) -> int: 
        result = float(""inf"")
        left,right = 0,sum(grid[0])

        for a,b in zip(grid[1],grid[0]):
            right-=a

            result = min(result,max(left,right))
            left+=b
        
        return result",None,"class Solution:
    def gridGame(self, grid: List[List[int]]) -> int: 
        result = float(""inf"")
        left,right = 0,sum(grid[1])

        for a,b in zip(grid[1],grid[0]):
            right-=b

            result = min(result,max(left,right))
            left+=a
        
        return result
"
3056,python3,grid-game,"class Solution:
    def gridGame(self, grid: List[List[int]]) -> int: 
        result = float(""inf"")
        left,right = 0,sum(grid[0])

        for a,b in zip(grid[1],grid[0]):
            right-=a

            result = min(result,max(left,right))
            left+=b
        
        return result",None,"class Solution:
    def gridGame(self, grid: List[List[int]]) -> int: 
        result = float(""inf"")
        left,right = 0,sum(grid[1])

        for a,b in zip(grid[1],grid[0]):
            right -= b

            result = min(result,max(left,right))  
            left += a

        return result
"
3056,python3,grid-game,"class Solution:
    def gridGame(self, grid: List[List[int]]) -> int: 
        result = float(""inf"")
        left,right = 0,sum(grid[0])

        for a,b in zip(grid[1],grid[0]):
            right-=a

            result = min(result,max(left,right))
            left+=b
        
        return result",None,"class Solution:
    def gridGame(self, grid: List[List[int]]) -> int:
        result = float(""inf"")
        left,right = 0,sum(grid[1])

        for a,b in zip(grid[1],grid[0]):
            right-=b

            result = min(result,max(left,right))
            left+=a
        
        return result
"
3057,python3,check-if-point-is-reachable,"class Solution:
    def isReachable(self, targetX: int, targetY: int) -> bool:
        def gcd(a, b):
            while b:
                a, b=b, a%b
            return a
        d=gcd(targetX, targetY)
        while d!=0:
            if d&1:
                return False
            d>>=1
        return True",None,"class Solution:
    def isReachable(self, targetX: int, targetY: int) -> bool:
        while targetX > 1 and targetY > 1:
            if targetX > targetY:
                targetX %= targetY
            else:
                targetY %= targetX
        return targetX == 1 or targetY == 1
"
3057,python3,check-if-point-is-reachable,"class Solution:
    def isReachable(self, targetX: int, targetY: int) -> bool:
        def gcd(a, b):
            while b:
                a, b=b, a%b
            return a
        d=gcd(targetX, targetY)
        while d!=0:
            if d&1:
                return False
            d>>=1
        return True",None,"class Solution:
    def isReachable(self, targetX: int, targetY: int) -> bool:
        while targetX != targetY:
            if targetX > targetY:
                if targetY > 1:
                    targetX %= targetY
                else:
                    return targetX == 1
            else:
                if targetX > 1:
                    targetY %= targetX
                else:
                    return targetY == 1
        return targetX == 1 and targetY == 1
"
3057,python3,check-if-point-is-reachable,"class Solution:
    def isReachable(self, targetX: int, targetY: int) -> bool:
        def gcd(a, b):
            while b:
                a, b=b, a%b
            return a
        d=gcd(targetX, targetY)
        while d!=0:
            if d&1:
                return False
            d>>=1
        return True",None,"class Solution:
    def isReachable(self, targetX: int, targetY: int) -> bool:
        while targetX > 1 and targetY > 1:
            if targetX > targetY:
                targetX %= targetY
            else:
                targetY %= targetX
        return targetX == 1 and targetY > 1 or targetY == 1 and targetX > 1
"
3058,python3,average-value-of-even-numbers-that-are-divisible-by-three,"class Solution:
    def averageValue(self, nums: List[int]) -> int:
        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 == 0]) > 1 else 0",None,"class Solution:
    def averageValue(self, nums: List[int]) -> int:
        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 == 0]) > 0 else 0
"
3058,python3,average-value-of-even-numbers-that-are-divisible-by-three,"class Solution:
    def averageValue(self, nums: List[int]) -> int:
        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 == 0]) > 1 else 0",None,"class Solution:
    def averageValue(self, nums: List[int]) -> int:
        lst = [num for num in nums if num % 6 == 0]
        return int(sum(lst) / len(lst)) if len(lst) > 0 else 0
"
3058,python3,average-value-of-even-numbers-that-are-divisible-by-three,"class Solution:
    def averageValue(self, nums: List[int]) -> int:
        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 == 0]) > 1 else 0",None,"class Solution:
    def averageValue(self, nums: List[int]) -> int:
        lst = [num for num in nums if num % 6 == 0]
        return int(sum(lst) / len(lst)) if len(lst) > 0 else 0
"
3059,python3,delete-greatest-value-in-each-row,"class Solution:
    def deleteGreatestValue(self, grid: List[List[int]]) -> int:
        for i in range(0, len(grid)):
            grid[i].sort()
        n = len(grid[0])
        res = 0
        for j in range(0, n+1):
            ans = 0
            for i in range(0, len(grid)):
                ans = max(ans, grid[i].pop())
            res += ans
            
        return res",None,"class Solution:
    def deleteGreatestValue(self, grid: List[List[int]]) -> int:
        for i in range(len(grid)):
            grid[i].sort()
        n = len(grid[0])
        res = 0
        for _ in range(n):
            ans = 0
            for i in range(len(grid)):
                if grid[i]:
                    ans = max(ans, grid[i].pop())
            res += ans
        return res
"
3059,python3,delete-greatest-value-in-each-row,"class Solution:
    def deleteGreatestValue(self, grid: List[List[int]]) -> int:
        for i in range(0, len(grid)):
            grid[i].sort()
        n = len(grid[0])
        res = 0
        for j in range(0, n+1):
            ans = 0
            for i in range(0, len(grid)):
                ans = max(ans, grid[i].pop())
            res += ans
            
        return res",None,"class Solution:
    def deleteGreatestValue(self, grid: List[List[int]]) -> int:
        for i in range(0, len(grid)):
            grid[i].sort()
        n = len(grid[0])
        res = 0
        for j in range(n, 0, -1):
            ans = 0
            for i in range(0, len(grid)):
                ans = max(ans, grid[i].pop())
            res += ans
            
        return res
"
3059,python3,delete-greatest-value-in-each-row,"class Solution:
    def deleteGreatestValue(self, grid: List[List[int]]) -> int:
        for i in range(0, len(grid)):
            grid[i].sort()
        n = len(grid[0])
        res = 0
        for j in range(0, n+1):
            ans = 0
            for i in range(0, len(grid)):
                ans = max(ans, grid[i].pop())
            res += ans
            
        return res",None,"class Solution:
    def deleteGreatestValue(self, grid: List[List[int]]) -> int:
        for i in range(0, len(grid)):
            grid[i].sort()
        n = len(grid[0])
        res = 0
        for j in range(0, n):
            ans = 0
            for i in range(0, len(grid)):
                if grid[i]:  # only pop if list is not empty
                    ans = max(ans, grid[i].pop())
            res += ans
            
        return res
"
3060,python3,minimum-time-to-complete-trips,"class Solution:
    def satisfiesTrip(self,mid, time, totalTrip):
        trip = 0
        for t in time:
            trip += mid//t
            if trip >= totalTrip:
                return False
        return True

    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        time.sort(reverse=True)
        minimum = min(time)
        left = minimum
        right = minimum*totalTrips
        while left < right:
            mid = (left+ right)//2

            if self.satisfiesTrip(mid, time, totalTrips):
                right = mid
            else:
                left = mid + 1
        return right",None,"class Solution:
    def satisfiesTrip(self,mid, time, totalTrip):
        trip = 0
        for t in time:
            trip += mid//t
            if trip >= totalTrip:
                return True
        return False

    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        time.sort(reverse=True)
        minimum = min(time)
        left = minimum
        right = minimum*totalTrips
        while left < right:
            mid = (left+ right)//2

            if self.satisfiesTrip(mid, time, totalTrips):
                right = mid
            else:
                left = mid + 1
        return left
"
3060,python3,minimum-time-to-complete-trips,"class Solution:
    def satisfiesTrip(self,mid, time, totalTrip):
        trip = 0
        for t in time:
            trip += mid//t
            if trip >= totalTrip:
                return False
        return True

    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        time.sort(reverse=True)
        minimum = min(time)
        left = minimum
        right = minimum*totalTrips
        while left < right:
            mid = (left+ right)//2

            if self.satisfiesTrip(mid, time, totalTrips):
                right = mid
            else:
                left = mid + 1
        return right",None,"class Solution:
    def satisfiesTrip(self,mid, time, totalTrip):
        trip = 0
        for t in time:
            trip += mid//t
            if trip >= totalTrip:
                return True
        return False

    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        time.sort(reverse=True)
        minimum = min(time)
        left = minimum
        right = minimum*totalTrips
        while left < right:
            mid = (left+ right)//2

            if self.satisfiesTrip(mid, time, totalTrips):
                right = mid
            else:
                left = mid + 1
        return left
"
3060,python3,minimum-time-to-complete-trips,"class Solution:
    def satisfiesTrip(self,mid, time, totalTrip):
        trip = 0
        for t in time:
            trip += mid//t
            if trip >= totalTrip:
                return False
        return True

    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        time.sort(reverse=True)
        minimum = min(time)
        left = minimum
        right = minimum*totalTrips
        while left < right:
            mid = (left+ right)//2

            if self.satisfiesTrip(mid, time, totalTrips):
                right = mid
            else:
                left = mid + 1
        return right",None,"class Solution:
    def satisfiesTrip(self,mid, time, totalTrip):
        trip = 0
        for t in time:
            trip += mid//t
            if trip >= totalTrip:
                return True
        return False

    def minimumTime(self, time, totalTrips):
        time.sort(reverse=True)
        minimum = min(time)
        left = minimum
        right = minimum*totalTrips
        while left < right:
            mid = (left+ right)//2

            if self.satisfiesTrip(mid, time, totalTrips):
                right = mid
            else:
                left = mid + 1
        return right
"
3061,python3,minimum-speed-to-arrive-on-time,"class Solution:
    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:
        if len(dist) >= hour - 1  : return -1
        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))
        while left<right:
            mid=(left+right)//2
            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :
                right=mid
            else:
                left=mid+1
        return left",None,"class Solution:
    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:
        if len(dist) > hour: return -1
        left,right = 1, max(max(dist),(dist[-1]//(1 if hour.is_integer() else hour-int(hour))))
        while left<right:
            mid=(left+right)//2
            if sum([i-1//mid + 1 for i in dist[:-1]])+(dist[-1]/mid) <= hour :
                right=mid
            else:
                left=mid+1
        return left
"
3061,python3,minimum-speed-to-arrive-on-time,"class Solution:
    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:
        if len(dist) >= hour - 1  : return -1
        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))
        while left<right:
            mid=(left+right)//2
            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :
                right=mid
            else:
                left=mid+1
        return left",None,"class Solution:
    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:
        if len(dist) > ceil(hour) : return -1
        left,right = 1, max(max(dist), ceil(dist[-1]/(1 if hour.is_integer() else hour-int(hour))))
        while left<right:
            mid=(left+right)//2
            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :
                right=mid
            else:
                left=mid+1
        return left
"
3061,python3,minimum-speed-to-arrive-on-time,"class Solution:
    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:
        if len(dist) >= hour - 1  : return -1
        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))
        while left<right:
            mid=(left+right)//2
            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :
                right=mid
            else:
                left=mid+1
        return left",None,"class Solution:
    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:
        if len(dist) > hour  : return -1
        left,right = 1, max(dist[-1]*10**6, max(dist)*10**6)
        while left < right:
            mid=(left+right)//2
            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :
                right=mid
            else:
                left=mid+1
        return left
"
3062,python3,count-the-repetitions,"class Solution:
    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:

        rec, track = [0], defaultdict(int) 
        ct = start = ptr1 = ptr2 = 0

        if not set(s2).issubset(set(s1)): return 0

        s1 = ''.join(char for char in s1 if char in set(s2))
        
        while True:
            for char in s2:
                ptr = s1.find(char, start)
                if ptr == -1:
                    ct += 1
                    ptr = s1.find(char)
                start = ptr+1
            rec.append(ct + 1)

            if rec[-1] >= n1: return (len(rec)-2)//n2

            if ptr not in track: track[ptr] = len(rec)-1
            else: break
        
        cycleStart = rec[track[ptr]]
        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]
        rest = n1 - cycleStart
        
        rem = cycleStart + rest%cycle1

        while rec[ptr2] <= rem: ptr2+= 1

        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",None,"class Solution:
    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:

        rec, track = [0], {}
        ct = start = ptr1 = ptr2 = 0

        if not set(s2).issubset(set(s1)): return 0

        s1 = ''.join(char for char in s1 if char in set(s2))
        
        while True:
            for char in s2:
                ptr = s1.find(char, start)
                if ptr == -1:
                    ct += 1
                    ptr = s1.find(char)
                start = (ptr+1)%len(s1)
            rec.append(ct + 1)

            if rec[-1] >= n1: return (len(rec)-2)//n2

            if start in track: break
            track[start] = len(rec)-1
        
        cycleStart = rec[track[start]]
        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[start]
        rest = n1 - cycleStart
        
        rem = cycleStart + rest%cycle1

        while rec[ptr2] <= rem: ptr2+= 1

        return (cycle2 * (rest//cycle1) + ptr2-1)//n2
"
3062,python3,count-the-repetitions,"class Solution:
    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:

        rec, track = [0], defaultdict(int) 
        ct = start = ptr1 = ptr2 = 0

        if not set(s2).issubset(set(s1)): return 0

        s1 = ''.join(char for char in s1 if char in set(s2))
        
        while True:
            for char in s2:
                ptr = s1.find(char, start)
                if ptr == -1:
                    ct += 1
                    ptr = s1.find(char)
                start = ptr+1
            rec.append(ct + 1)

            if rec[-1] >= n1: return (len(rec)-2)//n2

            if ptr not in track: track[ptr] = len(rec)-1
            else: break
        
        cycleStart = rec[track[ptr]]
        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]
        rest = n1 - cycleStart
        
        rem = cycleStart + rest%cycle1

        while rec[ptr2] <= rem: ptr2+= 1

        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",None,"class Solution:
    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:

        rec, track = [0], {}
        ct = start = ptr1 = ptr2 = 0

        if not set(s2).issubset(set(s1)): return 0

        s1 = ''.join(char for char in s1 if char in set(s2))
        
        while True:
            for char in s2:
                ptr = s1.find(char, start)
                if ptr == -1:
                    ct += 1
                    ptr = s1.find(char)
                start = ptr+1
            rec.append(ct + 1)

            if rec[-1] >= n1: return (len(rec)-2)//n2

            if start not in track: track[start] = len(rec)-1
            else: break
        
        cycleStart = rec[track[start]]
        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[start]
        rest = n1 - cycleStart
        
        rem = cycleStart + rest%cycle1

        while rec[ptr2] <= rem: ptr2+= 1

        return (cycle2 * (rest//cycle1) + ptr2-1)//n2
"
3062,python3,count-the-repetitions,"class Solution:
    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:

        rec, track = [0], defaultdict(int) 
        ct = start = ptr1 = ptr2 = 0

        if not set(s2).issubset(set(s1)): return 0

        s1 = ''.join(char for char in s1 if char in set(s2))
        
        while True:
            for char in s2:
                ptr = s1.find(char, start)
                if ptr == -1:
                    ct += 1
                    ptr = s1.find(char)
                start = ptr+1
            rec.append(ct + 1)

            if rec[-1] >= n1: return (len(rec)-2)//n2

            if ptr not in track: track[ptr] = len(rec)-1
            else: break
        
        cycleStart = rec[track[ptr]]
        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]
        rest = n1 - cycleStart
        
        rem = cycleStart + rest%cycle1

        while rec[ptr2] <= rem: ptr2+= 1

        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",None,"class Solution:
    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:
        
        rec, track = [0], {} 
        ct = start = ptr1 = ptr2 = 0

        if not set(s2).issubset(set(s1)): return 0

        s1 = ''.join(char for char in s1 if char in set(s2))
        
        while True:
            for char in s2:
                ptr = s1.find(char, start)
                if ptr == -1:
                    ct += 1
                    ptr = s1.find(char)
                start = ptr+1
            rec.append(ct + 1)

            if rec[-1] >= n1: return (len(rec)-2)//n2

            if start not in track: 
                track[start] = len(rec)-1
            else: 
                break

        cycleStart = track[start]
        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[start]
        rest = n1 - cycleStart

        rem = cycleStart + rest%cycle1

        while rec[ptr2] <= rem: 
            ptr2+= 1

        return (cycle2 * (rest//cycle1) + ptr2-1)//n2
"
3063,python3,fizz-buzz,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        arr=[]
        for i in range(0,n+1):
            if i % 3==0 and  i % 5==0 :
                arr.append(""FizzBuzz"")
            elif i % 3==0:
                arr.append(""Fizz"")
            elif i % 5==0 :
                arr.append(""Buzz"")
  
            else:
                arr.append(str(i))
        return(arr)",None,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        arr=[]
        for i in range(1,n+1):
            if i % 3==0 and  i % 5==0 :
                arr.append(""FizzBuzz"")
            elif i % 3==0:
                arr.append(""Fizz"")
            elif i % 5==0 :
                arr.append(""Buzz"")  
            else:
                arr.append(str(i))
        return(arr)
"
3063,python3,fizz-buzz,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        arr=[]
        for i in range(0,n+1):
            if i % 3==0 and  i % 5==0 :
                arr.append(""FizzBuzz"")
            elif i % 3==0:
                arr.append(""Fizz"")
            elif i % 5==0 :
                arr.append(""Buzz"")
  
            else:
                arr.append(str(i))
        return(arr)",None,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        arr=[]
        for i in range(1,n+1):
            if i % 3==0 and  i % 5==0 :
                arr.append(""FizzBuzz"")
            elif i % 3==0:
                arr.append(""Fizz"")
            elif i % 5==0 :
                arr.append(""Buzz"")
            else:
                arr.append(str(i))
        return(arr)
"
3063,python3,fizz-buzz,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        arr=[]
        for i in range(0,n+1):
            if i % 3==0 and  i % 5==0 :
                arr.append(""FizzBuzz"")
            elif i % 3==0:
                arr.append(""Fizz"")
            elif i % 5==0 :
                arr.append(""Buzz"")
  
            else:
                arr.append(str(i))
        return(arr)",None,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        arr=[]
        for i in range(1,n+1):
            if i % 3==0 and  i % 5==0 :
                arr.append(""FizzBuzz"")
            elif i % 3==0:
                arr.append(""Fizz"")
            elif i % 5==0 :
                arr.append(""Buzz"")
            else:
                arr.append(str(i))
        return(arr)
"
3064,python3,plus-one,"class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        s= ''.join(map(str,digits))
        i=int(s)+1
        if i<10:
            li=[]
        else:
            li=list(map(int,str(i)))  
        return li",None,"class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        s= ''.join(map(str,digits))
        i=int(s)+1
        li = list(map(int,str(i)))
        return li
"
3064,python3,plus-one,"class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        s= ''.join(map(str,digits))
        i=int(s)+1
        if i<10:
            li=[]
        else:
            li=list(map(int,str(i)))  
        return li",None,"class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        s= ''.join(map(str,digits))
        i=int(s)+1
        li=list(map(int,str(i)))  
        return li
"
3064,python3,plus-one,"class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        s= ''.join(map(str,digits))
        i=int(s)+1
        if i<10:
            li=[]
        else:
            li=list(map(int,str(i)))  
        return li",None,"class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        s = ''.join(map(str,digits))
        i = int(s) + 1
        li = list(map(int,str(i)))
        return li
"
3065,python3,number-of-ways-to-split-array,"class Solution:
    def waysToSplitArray(self, nums: List[int]) -> int:
        cnt=0
        left=nums[0]
        right=sum(nums[0:])
        if left>=right:
            cnt+=1
        for i in range(1,len(nums)-1):
            left+=nums[i]
            right-=nums[i]
            if left>=right:
                cnt+=1
        return cnt",None,"class Solution:
    def waysToSplitArray(self, nums: List[int]) -> int:
        cnt=0
        left=nums[0]
        right=sum(nums[1:])
        if left<=right:
            cnt+=1
        for i in range(1,len(nums)-1):
            left+=nums[i]
            right-=nums[i]
            if left<=right:
                cnt+=1
        return cnt
"
3065,python3,number-of-ways-to-split-array,"class Solution:
    def waysToSplitArray(self, nums: List[int]) -> int:
        cnt=0
        left=nums[0]
        right=sum(nums[0:])
        if left>=right:
            cnt+=1
        for i in range(1,len(nums)-1):
            left+=nums[i]
            right-=nums[i]
            if left>=right:
                cnt+=1
        return cnt",None,"class Solution:
    def waysToSplitArray(self, nums: List[int]) -> int:
        cnt = 0
        left = nums[0]
        right = sum(nums[1:])
        for i in range(1, len(nums) - 1):
            if left <= right:
                cnt += 1
            left += nums[i]
            right -= nums[i]
        return cnt
"
3065,python3,number-of-ways-to-split-array,"class Solution:
    def waysToSplitArray(self, nums: List[int]) -> int:
        cnt=0
        left=nums[0]
        right=sum(nums[0:])
        if left>=right:
            cnt+=1
        for i in range(1,len(nums)-1):
            left+=nums[i]
            right-=nums[i]
            if left>=right:
                cnt+=1
        return cnt",None,"class Solution:
    def waysToSplitArray(self, nums: List[int]) -> int:
        cnt=0
        left=nums[0]
        right=sum(nums[1:])
        if left<=right:
            cnt+=1
        for i in range(1,len(nums)-1):
            left+=nums[i]
            right-=nums[i]
            if left<=right:
                cnt+=1
        return cnt
"
3066,python3,remove-duplicates-from-sorted-array-ii,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) < 3:
            return len(nums)

        p1, p2 = 1, 2

        while p2 < len(nums):
            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p1-2]:
                while p2 < len(nums) and nums[p2] == nums[p2-1]:
                    p2 += 1
                if p2 == len(nums):
                    break
            p1 += 1
            nums[p1] = nums[p2]
            p2 += 1

        return p1 + 1",None,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) < 3:
            return len(nums)

        p1, p2 = 1, 1

        for idx in range(2, len(nums)):
            if nums[idx] != nums[p2] or nums[idx] != nums[p2-1]:
                p1 += 1
                nums[p1] = nums[idx]
                p2 += 1

        return p1 + 1
"
3066,python3,remove-duplicates-from-sorted-array-ii,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) < 3:
            return len(nums)

        p1, p2 = 1, 2

        while p2 < len(nums):
            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p1-2]:
                while p2 < len(nums) and nums[p2] == nums[p2-1]:
                    p2 += 1
                if p2 == len(nums):
                    break
            p1 += 1
            nums[p1] = nums[p2]
            p2 += 1

        return p1 + 1",None,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) < 3:
            return len(nums)

        p1, p2 = 1, 2

        while p2 < len(nums):
            if nums[p1] == nums[p1-1] and nums[p2] == nums[p1]:
                while p2 < len(nums) and nums[p2] == nums[p1]:
                    p2 += 1
                if p2 == len(nums):
                    break
            else:
                p1 += 1
                nums[p1] = nums[p2]
                p2 += 1

        return p1 + 1
"
3066,python3,remove-duplicates-from-sorted-array-ii,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) < 3:
            return len(nums)

        p1, p2 = 1, 2

        while p2 < len(nums):
            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p1-2]:
                while p2 < len(nums) and nums[p2] == nums[p2-1]:
                    p2 += 1
                if p2 == len(nums):
                    break
            p1 += 1
            nums[p1] = nums[p2]
            p2 += 1

        return p1 + 1",None,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) < 3:
            return len(nums)

        p1, p2 = 1, 2

        while p2 < len(nums):
            if nums[p1] == nums[p1-1] and nums[p2] == nums[p1]:
                p2 += 1
            else:
                p1 += 1
                nums[p1] = nums[p2]
                p2 += 1

        return p1 + 1
"
3067,python3,frog-position-after-t-seconds,"from queue import Queue

class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        if edges == []:
            if target == 1:return 1
            return 0

        d = {}
        for i in edges:
            d[i[0]] = d.get(i[0] , []) + [i[1]]
            d[i[1]] = d.get(i[1] , []) + [i[0]]
        
        visit = [0]*(n+1)

        q = Queue()     
        q.put([1 , 1])

        for dur in range(t+1):
            
            l = q.qsize()
            for i in range(l):
                temp = q.get()

                count = 0
                for ele in d[temp[0]]:
                    if visit[ele] == 0: count += 1
            
                if temp[0] == target and count == 0:     
                    return temp[1]
                
                if visit[temp[0]] != 0:
                    continue
                
                visit[temp[0]] = 1

                for ele in d[temp[0]]:
                    if visit[ele] == 0: q.put([ele , temp[1]*(1/count)])
                
        
        l = q.qsize()
        for i in range(l):
            temp = q.get()
            if temp[0] == target:
                return temp[1]

        return 0",None,"from collections import deque

class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        if edges == []:
            if target == 1:
                return 1
            return 0
        
        graph = {i: [] for i in range(1, n+1)}
        for i, j in edges:
            graph[i].append(j)
            graph[j].append(i)
        
        visited = [0]*(n+1)
        queue = deque([[1, 1.0]])
        
        while queue:
            for _ in range(len(queue)):
                node, prob = queue.popleft()
                not_visited = [n for n in graph[node] if not visited[n]] 
                if not_visited:
                    for nei in not_visited:
                        visited[nei] = 1
                        queue.append([nei, prob/len(not_visited)])
                elif node == target:
                    return prob if t == 0 else 0
            if t==0:
                return 0
            t -= 1
        
        return 0
"
3067,python3,frog-position-after-t-seconds,"from queue import Queue

class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        if edges == []:
            if target == 1:return 1
            return 0

        d = {}
        for i in edges:
            d[i[0]] = d.get(i[0] , []) + [i[1]]
            d[i[1]] = d.get(i[1] , []) + [i[0]]
        
        visit = [0]*(n+1)

        q = Queue()     
        q.put([1 , 1])

        for dur in range(t+1):
            
            l = q.qsize()
            for i in range(l):
                temp = q.get()

                count = 0
                for ele in d[temp[0]]:
                    if visit[ele] == 0: count += 1
            
                if temp[0] == target and count == 0:     
                    return temp[1]
                
                if visit[temp[0]] != 0:
                    continue
                
                visit[temp[0]] = 1

                for ele in d[temp[0]]:
                    if visit[ele] == 0: q.put([ele , temp[1]*(1/count)])
                
        
        l = q.qsize()
        for i in range(l):
            temp = q.get()
            if temp[0] == target:
                return temp[1]

        return 0",None,"from queue import Queue

class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        if edges == []:
            if target == 1:return 1
            return 0

        d = {}
        for i in edges:
            if i[0] not in d: 
                d[i[0]] =  []
            if i[1] not in d: 
                d[i[1]] =  []
                
            d[i[0]].append(i[1]) 
            d[i[1]].append(i[0])
        
        visit = [0]*(n+1)

        q = Queue()
        q.put([1 , 1 , 0]) 

        while not q.empty():
            temp = q.get()

            if temp[2] > t:    
                break
                
            count = 0
            for ele in d[temp[0]]:
                if visit[ele] == 0: 
                    count += 1
            
            if temp[0] == target and (temp[2] == t or (temp[2] < t and count == 0)):
                return temp[1]
                
            visit[temp[0]] = 1

            for ele in d[temp[0]]:
                if visit[ele] == 0:
                    q.put([ele , temp[1]*(1/count) , temp[2]+1])
                
        return 0
"
3067,python3,frog-position-after-t-seconds,"from queue import Queue

class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        if edges == []:
            if target == 1:return 1
            return 0

        d = {}
        for i in edges:
            d[i[0]] = d.get(i[0] , []) + [i[1]]
            d[i[1]] = d.get(i[1] , []) + [i[0]]
        
        visit = [0]*(n+1)

        q = Queue()     
        q.put([1 , 1])

        for dur in range(t+1):
            
            l = q.qsize()
            for i in range(l):
                temp = q.get()

                count = 0
                for ele in d[temp[0]]:
                    if visit[ele] == 0: count += 1
            
                if temp[0] == target and count == 0:     
                    return temp[1]
                
                if visit[temp[0]] != 0:
                    continue
                
                visit[temp[0]] = 1

                for ele in d[temp[0]]:
                    if visit[ele] == 0: q.put([ele , temp[1]*(1/count)])
                
        
        l = q.qsize()
        for i in range(l):
            temp = q.get()
            if temp[0] == target:
                return temp[1]

        return 0",None,"from collections import deque

class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        if edges == []:
            if target == 1:return 1
            return 0

        d = {}
        for i in edges:
            d[i[0]] = d.get(i[0] , []) + [i[1]]
            d[i[1]] = d.get(i[1] , []) + [i[0]]
        
        visit = [0]*(n+1)

        q = deque()     
        q.append([1 , 1])

        for dur in range(t):
            
            l = len(q)
            for i in range(l):
                temp = q.popleft()

                count = 0
                for ele in d[temp[0]]:
                    if visit[ele] == 0: count += 1
            
                if visit[temp[0]] != 0:
                    continue
                
                visit[temp[0]] = 1

                for ele in d[temp[0]]:
                    if visit[ele] == 0:
                        if ele == target and dur == t - 1: return temp[1]*(1/count) 
                        elif dur < t - 1: q.append([ele , temp[1]*(1/count)])

        if target == 1 and t >= 1: return 0
        return 1.0 if target != 1 and t == 0 else 0.0
"
3068,python3,minimum-difference-between-highest-and-lowest-of-k-scores,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        res = 100000
        
        for i in range(len(nums) - k):
            arr = nums[i:i + k]
            res = min(res, arr[-1] - arr[0])
            
        return res",None,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        res = 100000
        
        for i in range(len(nums) - k + 1):
            arr = nums[i:i + k]
            res = min(res, arr[-1] - arr[0])
            
        return res
"
3068,python3,minimum-difference-between-highest-and-lowest-of-k-scores,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        res = 100000
        
        for i in range(len(nums) - k):
            arr = nums[i:i + k]
            res = min(res, arr[-1] - arr[0])
            
        return res",None,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        res = 100000
        
        for i in range(len(nums) - k + 1):
            arr = nums[i:i + k]
            res = min(res, arr[-1] - arr[0])
            
        return res
"
3068,python3,minimum-difference-between-highest-and-lowest-of-k-scores,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        res = 100000
        
        for i in range(len(nums) - k):
            arr = nums[i:i + k]
            res = min(res, arr[-1] - arr[0])
            
        return res",None,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        res = float('inf')
        
        for i in range(len(nums) - k + 1):
            arr = nums[i:i + k]
            res = min(res, arr[-1] - arr[0])
            
        return res
"
3069,python3,valid-parenthesis-string,"class Solution:
    def checkValidString(self, s):
        st=[]
        sr=[]
        for i in range(len(s)):
            if s[i]=='(':
                st.append(i)
            elif s[i]== '*':
                sr.append(i)
            else:
                if st:
                    st.pop()
                elif sr:
                    sr.pop()
                else:
                    return False
        while st:
            if len(sr)==0:
                return False
            elif st[-1] > sr[-1]:
                st.pop()
                sr.pop()
            else:
                return False
        return True",None,"class Solution:
    def checkValidString(self, s):
        st=[]
        sr=[]
        for i in range(len(s)):
            if s[i]=='(':
                st.append(i)
            elif s[i]== '*':
                sr.append(i)
            else:
                if st:
                    st.pop()
                elif sr:
                    sr.pop()
                else:
                    return False
        while st:
            if len(sr)==0:
                return False
            elif st[-1] < sr[-1]:
                st.pop()
                sr.pop()
            else:
                return False
        return True
"
3069,python3,valid-parenthesis-string,"class Solution:
    def checkValidString(self, s):
        st=[]
        sr=[]
        for i in range(len(s)):
            if s[i]=='(':
                st.append(i)
            elif s[i]== '*':
                sr.append(i)
            else:
                if st:
                    st.pop()
                elif sr:
                    sr.pop()
                else:
                    return False
        while st:
            if len(sr)==0:
                return False
            elif st[-1] > sr[-1]:
                st.pop()
                sr.pop()
            else:
                return False
        return True",None,"class Solution:
    def checkValidString(self, s):
        st=[]
        sr=[]
        for i in range(len(s)):
            if s[i]=='(':
                st.append(i)
            elif s[i]=='*':
                sr.append(i)
            else:
                if st:
                    st.pop()
                elif sr:
                    sr.pop()
                else:
                    return False
        while st and sr:
            if st[-1] > sr[-1]:
                return False
            st.pop()
            sr.pop()
        return len(st) == 0
"
3069,python3,valid-parenthesis-string,"class Solution:
    def checkValidString(self, s):
        st=[]
        sr=[]
        for i in range(len(s)):
            if s[i]=='(':
                st.append(i)
            elif s[i]== '*':
                sr.append(i)
            else:
                if st:
                    st.pop()
                elif sr:
                    sr.pop()
                else:
                    return False
        while st:
            if len(sr)==0:
                return False
            elif st[-1] > sr[-1]:
                st.pop()
                sr.pop()
            else:
                return False
        return True",None,"class Solution:
    def checkValidString(self, s):
        st=[]
        sr=[]
        for i in range(len(s)):
            if s[i]=='(':
                st.append(i)
            elif s[i]== '*':
                sr.append(i)
            else:
                if st:
                    st.pop()
                elif sr:
                    sr.pop()
                else:
                    return False
        while st:
            if not sr:
                return False
            elif st[-1] < sr[-1]:
                st.pop()
                sr.pop()
            else:
                return False
        return True
"
3070,python3,minimum-total-cost-to-make-arrays-unequal,"class Solution:
    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:
        n=len(nums1)
        z=Counter(nums1)
        z1=Counter(nums2)
        for i in z:
            if(n-z1[i]<z[i]):
                return -1
            if(z[i]>=n//2+1 and z1[i]>=n//2+1):
                return -1
        for i in z1:
            if(n-z[i]<z1[i]):
                return -1
            if(z[i]>=n//2+1 and z1[i]>=n//2+1):
                return -1
        z=Counter([])
        ans=0
        flag=0
        d=defaultdict(list)
        vis=[0 for i in range(n)]
        for i in range(n):
            if(nums1[i]==nums2[i]):
                z[nums2[i]]+=1
                ans+=i
                flag=1
                d[nums2[i]].append(i)
        t=0
        l=z.most_common(len(z))
        a=0
        for i in range(1,len(l)):
            a+=l[i][1]
            for j in d[l[i][0]]:
                vis[j]=1
            z[l[i][0]]=0
        if(l and a>=l[0][1]):
            return ans
        x=0
        if(l):
            x=l[0][1]-a
            z[l[0][0]]=x
        print(z,ans)
        for j in z:
            if(z[j]):
                for i in range(n):
                    if(vis[i]==0 and nums1[i]==j and nums2[i]==j and x): 
                        if(flag):
                            ans+=i
                            x-=1
        return ans",None,"class Solution:
    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:
        n=len(nums1)
        z=Counter(nums1)
        z1=Counter(nums2)
        for i in z:
            if(n-z1[i]<z[i]):
                return -1
            if(z[i]>=n//2+1 and z1[i]>=n//2+1):
                return -1
        for i in z1:
            if(n-z[i]<z1[i]):
                return -1
            if(z[i]>=n//2+1 and z1[i]>=n//2+1):
                return -1
        z=Counter([])
        ans=0
        flag=0
        d=defaultdict(list)
        vis=[0 for i in range(n)]
        for i in range(n):
            if(nums1[i]==nums2[i]):
                z[nums2[i]]+=1
                ans+=i
                flag=1
                d[nums2[i]].append(i)
        t=0
        l=z.most_common(len(z))
        a=0
        for i in range(1,len(l)):
            a+=l[i][1]
            for j in d[l[i][0]]:
                vis[j]=1
            z[l[i][0]]=0
        if(l and a>=l[0][1]):
            return ans
        x=0
        if(l):
            x=l[0][1]-a
            z[l[0][0]]=x
        for j in z:
            if(z[j]):
                for i in range(n):
                    if(vis[i]==0 and nums1[i]!=nums2[i] and x): 
                        if(flag):
                            ans+=i
                            x-=1
        return ans
"
3070,python3,minimum-total-cost-to-make-arrays-unequal,"class Solution:
    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:
        n=len(nums1)
        z=Counter(nums1)
        z1=Counter(nums2)
        for i in z:
            if(n-z1[i]<z[i]):
                return -1
            if(z[i]>=n//2+1 and z1[i]>=n//2+1):
                return -1
        for i in z1:
            if(n-z[i]<z1[i]):
                return -1
            if(z[i]>=n//2+1 and z1[i]>=n//2+1):
                return -1
        z=Counter([])
        ans=0
        flag=0
        d=defaultdict(list)
        vis=[0 for i in range(n)]
        for i in range(n):
            if(nums1[i]==nums2[i]):
                z[nums2[i]]+=1
                ans+=i
                flag=1
                d[nums2[i]].append(i)
        t=0
        l=z.most_common(len(z))
        a=0
        for i in range(1,len(l)):
            a+=l[i][1]
            for j in d[l[i][0]]:
                vis[j]=1
            z[l[i][0]]=0
        if(l and a>=l[0][1]):
            return ans
        x=0
        if(l):
            x=l[0][1]-a
            z[l[0][0]]=x
        print(z,ans)
        for j in z:
            if(z[j]):
                for i in range(n):
                    if(vis[i]==0 and nums1[i]==j and nums2[i]==j and x): 
                        if(flag):
                            ans+=i
                            x-=1
        return ans",None,"class Solution:
    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:
        n=len(nums1)
        z=Counter(nums1)
        z1=Counter(nums2)
        for i in z:
            if(n-z1[i]<z[i]):
                return -1
        for i in z1:
            if(n-z[i]<z1[i]):
                return -1
        z=Counter([])
        ans=0
        flag=0
        d=defaultdict(list)
        vis=[0 for i in range(n)]
        for i in range(n):
            if(nums1[i]==nums2[i]):
                z[nums2[i]]+=1
                ans+=i
                flag=1
                d[nums2[i]].append(i)
        t=0
        l=z.most_common(len(z))
        a=0
        for i in range(1,len(l)):
            a+=l[i][1]
            for j in d[l[i][0]]:
                vis[j]=1
            z[l[i][0]]=0
        if(l and a>=l[0][1]):
            return ans
        x=0
        if(l):
            x=l[0][1]-a
            z[l[0][0]]=x
        for j in z:
            if(z[j]):
                for i in range(n):
                    if(vis[i]==0 and nums1[i]!=j and nums2[i]!=j and x): 
                        if(flag):
                            ans+=i
                            x-=1
        return ans
"
3070,python3,minimum-total-cost-to-make-arrays-unequal,"class Solution:
    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:
        n=len(nums1)
        z=Counter(nums1)
        z1=Counter(nums2)
        for i in z:
            if(n-z1[i]<z[i]):
                return -1
            if(z[i]>=n//2+1 and z1[i]>=n//2+1):
                return -1
        for i in z1:
            if(n-z[i]<z1[i]):
                return -1
            if(z[i]>=n//2+1 and z1[i]>=n//2+1):
                return -1
        z=Counter([])
        ans=0
        flag=0
        d=defaultdict(list)
        vis=[0 for i in range(n)]
        for i in range(n):
            if(nums1[i]==nums2[i]):
                z[nums2[i]]+=1
                ans+=i
                flag=1
                d[nums2[i]].append(i)
        t=0
        l=z.most_common(len(z))
        a=0
        for i in range(1,len(l)):
            a+=l[i][1]
            for j in d[l[i][0]]:
                vis[j]=1
            z[l[i][0]]=0
        if(l and a>=l[0][1]):
            return ans
        x=0
        if(l):
            x=l[0][1]-a
            z[l[0][0]]=x
        print(z,ans)
        for j in z:
            if(z[j]):
                for i in range(n):
                    if(vis[i]==0 and nums1[i]==j and nums2[i]==j and x): 
                        if(flag):
                            ans+=i
                            x-=1
        return ans",None,"class Solution:
    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:
        n=len(nums1)
        z=Counter(nums1)
        z1=Counter(nums2)
        for i in z:
            if(n-z1[i]<z[i]):
                return -1
            if(z[i]>=n//2+1 and z1[i]>=n//2+1):
                return -1
        for i in z1:
            if(n-z[i]<z1[i]):
                return -1
            if(z[i]>=n//2+1 and z1[i]>=n//2+1):
                return -1
        z=Counter([])
        ans=0
        flag=0
        d=defaultdict(list)
        vis=[0 for i in range(n)]
        for i in range(n):
            if(nums1[i]==nums2[i]):
                z[nums2[i]]+=1
                ans+=i
                flag=1
                d[nums2[i]].append(i)
        t=0
        l=z.most_common(len(z))
        a=0
        for i in range(1,len(l)):
            a+=l[i][1]
            for j in d[l[i][0]]:
                vis[j]=1
            z[l[i][0]]=0
        if(l and a>=l[0][1]):
            return ans
        x=0
        if(l):
            x=l[0][1]-a
            z[l[0][0]]=x
        for j in z:
            if(z[j]):
                for i in range(n):
                    if(vis[i]==0 and nums1[i]==j and nums2[i]!=j and x): 
                        if(flag):
                            ans+=i
                            x-=1
        return ans
"
3071,python3,find-the-array-concatenation-value,"class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        left=0
        right=len(nums)-1
        total=0
        while left<=right:
            if left>right:
                total+=int(str(nums[left])+str(nums[right]))
            else:
                total+=nums[left]
            left+=1
            right-=1
        return total",None,"class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        left=0
        right=len(nums)-1
        total=0
        while left<=right:
            if left<right:
                total+=int(str(nums[left])+str(nums[right]))
            else:
                total+=nums[left]
            left+=1
            right-=1
        return total
"
3071,python3,find-the-array-concatenation-value,"class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        left=0
        right=len(nums)-1
        total=0
        while left<=right:
            if left>right:
                total+=int(str(nums[left])+str(nums[right]))
            else:
                total+=nums[left]
            left+=1
            right-=1
        return total",None,"class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        left = 0
        right = len(nums) - 1
        total = 0
        while left <= right:
            if left != right:
                total += int(str(nums[left]) + str(nums[right]))
            else:
                total += nums[left]
            left += 1
            right -= 1
        return total
"
3071,python3,find-the-array-concatenation-value,"class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        left=0
        right=len(nums)-1
        total=0
        while left<=right:
            if left>right:
                total+=int(str(nums[left])+str(nums[right]))
            else:
                total+=nums[left]
            left+=1
            right-=1
        return total",None,"class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        left=0
        right=len(nums)-1
        total=0
        while left<=right:
            if left!=right:
                total+=int(str(nums[left])+str(nums[right]))
            else:
                total+=nums[left]
            left+=1
            right-=1
        return total
"
3072,python3,construct-binary-tree-from-inorder-and-postorder-traversal,"class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        inorder_map={val:idx for idx, val in enumerate(inorder)}
        postorder_idx=len(postorder)-1

        def treeHelper(left, right):
            nonlocal postorder_idx
            if left>right:
                return None

            node_val = postorder[postorder_idx]
            root=TreeNode(node_val)
            postorder_idx-=1

            inorder_index=inorder_map[node_val]

            root.left = treeHelper(inorder_index+1, right)
            root.right = treeHelper(left, inorder_index-1 )

            return root

        return treeHelper(0, len(inorder)-1)",None,"class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        inorder_map={val:idx for idx, val in enumerate(inorder)}
        postorder_idx=len(postorder)-1

        def treeHelper(left, right):
            nonlocal postorder_idx
            if left>right:
                return None

            node_val = postorder[postorder_idx]
            root=TreeNode(node_val)
            postorder_idx-=1

            inorder_index=inorder_map[node_val]

            root.right = treeHelper(inorder_index+1, right)
            root.left = treeHelper(left, inorder_index-1 )

            return root

        return treeHelper(0, len(inorder)-1)
"
3072,python3,construct-binary-tree-from-inorder-and-postorder-traversal,"class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        inorder_map={val:idx for idx, val in enumerate(inorder)}
        postorder_idx=len(postorder)-1

        def treeHelper(left, right):
            nonlocal postorder_idx
            if left>right:
                return None

            node_val = postorder[postorder_idx]
            root=TreeNode(node_val)
            postorder_idx-=1

            inorder_index=inorder_map[node_val]

            root.left = treeHelper(inorder_index+1, right)
            root.right = treeHelper(left, inorder_index-1 )

            return root

        return treeHelper(0, len(inorder)-1)",None,"class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        inorder_map={val:idx for idx, val in enumerate(inorder)}
        postorder_idx=len(postorder)-1

        def treeHelper(left, right):
            nonlocal postorder_idx
            if left>right:
                return None

            node_val = postorder[postorder_idx]
            root=TreeNode(node_val)
            postorder_idx-=1

            inorder_index=inorder_map[node_val]
            
            root.right = treeHelper(inorder_index+1, right)
            root.left = treeHelper(left, inorder_index-1 )

            return root

        return treeHelper(0, len(inorder)-1)
"
3072,python3,construct-binary-tree-from-inorder-and-postorder-traversal,"class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        inorder_map={val:idx for idx, val in enumerate(inorder)}
        postorder_idx=len(postorder)-1

        def treeHelper(left, right):
            nonlocal postorder_idx
            if left>right:
                return None

            node_val = postorder[postorder_idx]
            root=TreeNode(node_val)
            postorder_idx-=1

            inorder_index=inorder_map[node_val]

            root.left = treeHelper(inorder_index+1, right)
            root.right = treeHelper(left, inorder_index-1 )

            return root

        return treeHelper(0, len(inorder)-1)",None,"class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        inorder_map={val:idx for idx, val in enumerate(inorder)}
        postorder_idx=len(postorder)-1

        def treeHelper(left, right):
            nonlocal postorder_idx
            if left>right:
                return None

            node_val = postorder[postorder_idx]
            root=TreeNode(node_val)
            postorder_idx-=1

            inorder_index=inorder_map[node_val]

            root.right = treeHelper(inorder_index+1, right)
            root.left = treeHelper(left, inorder_index-1 )

            return root

        return treeHelper(0, len(inorder)-1)
"
3073,python3,determine-the-winner-of-a-bowling-game,"class Solution:
    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:
        res1=0
        res2=0
        if 10 in nums1 and len(nums1)>1:
            res1+=nums1[0]
            for i in range(1,len(nums1)):
                res1+=nums1[i]
                if nums1[i-1]==10 or i>=2 and nums1[i-3]==10:
                    res1+=nums1[i]
                else:
                    pass
        else:
            res1=sum(nums1)
        if 10 in nums2 and len(nums2)>1:
            res2+=nums2[0]
            for i in range(1,len(nums2)):
                res2+=nums2[i]
                if nums2[i-1]==10 or i>=2 and nums2[i-3]==10:
                    res2+=nums2[i]
                else:
                    pass
        else:
            res2=sum(nums2)

        if res1>res2:
            return(1)
        elif res1<res2:
            return(2)
        else:
            return(0)",None,"class Solution:
    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:
        res1, res2 = 0, 0
        for i in range(len(nums1)):
            res1 += nums1[i]
            if i >= 1 and nums1[i - 1] == 10 or i >= 2 and nums1[i - 2] == 10:
                res1 += nums1[i]
        for i in range(len(nums2)):
            res2 += nums2[i]
            if i >= 1 and nums2[i - 1] == 10 or i >= 2 and nums2[i - 2] == 10:
                res2 += nums2[i]

        if res1 > res2:
            return 1
        elif res1 < res2:
            return 2
        else:
            return 0
"
3073,python3,determine-the-winner-of-a-bowling-game,"class Solution:
    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:
        res1=0
        res2=0
        if 10 in nums1 and len(nums1)>1:
            res1+=nums1[0]
            for i in range(1,len(nums1)):
                res1+=nums1[i]
                if nums1[i-1]==10 or i>=2 and nums1[i-3]==10:
                    res1+=nums1[i]
                else:
                    pass
        else:
            res1=sum(nums1)
        if 10 in nums2 and len(nums2)>1:
            res2+=nums2[0]
            for i in range(1,len(nums2)):
                res2+=nums2[i]
                if nums2[i-1]==10 or i>=2 and nums2[i-3]==10:
                    res2+=nums2[i]
                else:
                    pass
        else:
            res2=sum(nums2)

        if res1>res2:
            return(1)
        elif res1<res2:
            return(2)
        else:
            return(0)",None,"class Solution:
    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:
        res1 = 0
        res2 = 0

        for i in range(len(nums1)):
            if i>1 and (nums1[i-1] == 10 or nums1[i-2] == 10):
                res1 += 2*nums1[i]
            else:
                res1 += nums1[i]
                
        for i in range(len(nums2)):
            if i>1 and (nums2[i-1] == 10 or nums2[i-2] == 10):
                res2 += 2*nums2[i]
            else:
                res2 += nums2[i]

        if res1 > res2:
            return 1
        elif res1 < res2:
            return 2
        else:
            return 0
"
3073,python3,determine-the-winner-of-a-bowling-game,"class Solution:
    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:
        res1=0
        res2=0
        if 10 in nums1 and len(nums1)>1:
            res1+=nums1[0]
            for i in range(1,len(nums1)):
                res1+=nums1[i]
                if nums1[i-1]==10 or i>=2 and nums1[i-3]==10:
                    res1+=nums1[i]
                else:
                    pass
        else:
            res1=sum(nums1)
        if 10 in nums2 and len(nums2)>1:
            res2+=nums2[0]
            for i in range(1,len(nums2)):
                res2+=nums2[i]
                if nums2[i-1]==10 or i>=2 and nums2[i-3]==10:
                    res2+=nums2[i]
                else:
                    pass
        else:
            res2=sum(nums2)

        if res1>res2:
            return(1)
        elif res1<res2:
            return(2)
        else:
            return(0)",None,"class Solution:
    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:
        res1=0
        res2=0
        for i in range(len(nums1)):
            bonus1 = 2 if i > 0 and nums1[i-1] == 10 or i > 1 and nums1[i-2] == 10 else 1
            bonus2 = 2 if i > 0 and nums2[i-1] == 10 or i > 1 and nums2[i-2] == 10 else 1
            res1 += nums1[i] * bonus1
            res2 += nums2[i] * bonus2

        if res1>res2:
            return 1
        elif res1<res2:
            return 2
        else:
            return 0
"
3074,python3,powerful-integers,"class Solution:
    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:
        if bound == 0:
            return []
        
        def get(v):
            yield 1
            if v == 1:
                return
            vi = v
            while vi <= bound:
                yield vi
                vi *= v
        
        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi < bound})",None,"class Solution:
    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:
        if bound == 0:
            return []
        
        def get(v):
            yield 1
            if v == 1:
                return
            vi = v
            while vi <= bound:
                yield vi
                vi *= v
        
        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi <= bound})
"
3074,python3,powerful-integers,"class Solution:
    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:
        if bound == 0:
            return []
        
        def get(v):
            yield 1
            if v == 1:
                return
            vi = v
            while vi <= bound:
                yield vi
                vi *= v
        
        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi < bound})",None,"class Solution:
    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:
        if bound == 0:
            return []
        
        def get(v):
            yield 1
            if v == 1:
                return
            vi = v
            while vi <= bound:
                yield vi
                vi *= v
        
        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi <= bound})
"
3074,python3,powerful-integers,"class Solution:
    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:
        if bound == 0:
            return []
        
        def get(v):
            yield 1
            if v == 1:
                return
            vi = v
            while vi <= bound:
                yield vi
                vi *= v
        
        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi < bound})",None,"class Solution:
    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:
        if bound == 0:
            return []
        
        def get(v):
            yield 1
            if v == 1:
                return
            vi = v
            while vi <= bound:
                yield vi
                vi *= v
        
        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi <= bound})
"
3075,python3,partition-array-according-to-given-pivot,"class Solution:
    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:
        lst,val,tmp=[],[],[]
        for i in nums:
            if i<pivot:val.append(i)
            elif i==pivot:lst.append(i)
            else:tmp.append(i)
        return lst+val+tmp",None,"class Solution:
    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:
        lst, val, tmp = [], [], []
        for i in nums:
            if i < pivot:
                val.append(i)
            elif i == pivot:
                lst.append(i)
            else:
                tmp.append(i)
        return val + lst + tmp
"
3075,python3,partition-array-according-to-given-pivot,"class Solution:
    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:
        lst,val,tmp=[],[],[]
        for i in nums:
            if i<pivot:val.append(i)
            elif i==pivot:lst.append(i)
            else:tmp.append(i)
        return lst+val+tmp",None,"class Solution:
    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:
        lst,val,tmp=[],[],[]
        for i in nums:
            if i<pivot: val.append(i)
            elif i==pivot: lst.append(i)
            else: tmp.append(i)
        return val + lst + tmp
"
3075,python3,partition-array-according-to-given-pivot,"class Solution:
    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:
        lst,val,tmp=[],[],[]
        for i in nums:
            if i<pivot:val.append(i)
            elif i==pivot:lst.append(i)
            else:tmp.append(i)
        return lst+val+tmp",None,"class Solution:
    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:
        lst,val,tmp=[],[],[]
        for i in nums:
            if i<pivot:val.append(i)
            elif i==pivot:lst.append(i)
            else:tmp.append(i)
        return val+lst+tmp
"
3076,python3,find-kth-bit-in-nth-binary-string,"class Solution:
    def findKthBit(self, N, K, R = True):
        if K == 1: return '0' if R else '1'
        mid = (1 << (N - 1))
        if K <= mid: return self.findKthBit(N - 1, K, R)
        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)
        return '1' if R else '0'",None,"class Solution:
    def findKthBit(self, N, K):
        if K == 1: return '0'
        mid = (1 << (N - 1))
        if K == mid: return '1'
        if K < mid: return self.findKthBit(N - 1, K)
        return '0' if self.findKthBit(N - 1, 2 * mid - K) == '1' else '1'
"
3076,python3,find-kth-bit-in-nth-binary-string,"class Solution:
    def findKthBit(self, N, K, R = True):
        if K == 1: return '0' if R else '1'
        mid = (1 << (N - 1))
        if K <= mid: return self.findKthBit(N - 1, K, R)
        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)
        return '1' if R else '0'",None,"class Solution:
    def findKthBit(self, N, K, R = True):
        if N == 1: return '0' if R else '1'
        mid = (1 << (N - 1))
        if K < mid: return self.findKthBit(N - 1, K, R)
        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)
        return '1' if R else '0'
"
3076,python3,find-kth-bit-in-nth-binary-string,"class Solution:
    def findKthBit(self, N, K, R = True):
        if K == 1: return '0' if R else '1'
        mid = (1 << (N - 1))
        if K <= mid: return self.findKthBit(N - 1, K, R)
        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)
        return '1' if R else '0'",None,"class Solution:
    def findKthBit(self, N, K):
        if N == 1: return '0'
        mid = (1 << (N - 1))
        if K <= mid: return self.findKthBit(N - 1, K)
        if K == mid + 1: return '1'
        if K > mid + 1: return '1' if self.findKthBit(N - 1, 2 * mid - K) == '0' else '0'
"
3077,python3,rings-and-rods,"class Solution:
    def countPoints(self, rings: str) -> int:
        lst=[]
        rgb=[]
        count=0
        for i in range(1,len(rings),2):
            rgb=[]
            if rings[i] not in lst:
                lst.append(rings[i])
                for j in range(1,len(rings),2):
                    if rings[j]==rings[i]:
                        if rings[j-1]=='R':
                            rgb.append(rings[j-1])
                        if rings[j-1]=='G':
                            rgb.append(rings[j-1])
                        if rings[j-1]=='B':
                            rgb.append(rings[j-1])
                if len(set(rgb))==2:
                    count+=1
        return count",None,"class Solution:
    def countPoints(self, rings: str) -> int:
        rods = [set() for _ in range(10)]  # Define a set for each rod
        for i in range(0, len(rings), 2):
            # Add each ring's color to its corresponding rod
            rods[int(rings[i+1])].add(rings[i])
        count = 0
        for rod in rods:  
            if len(rod) == 3:  # Count rods holding all 3 colors
                count += 1
        return count
"
3077,python3,rings-and-rods,"class Solution:
    def countPoints(self, rings: str) -> int:
        lst=[]
        rgb=[]
        count=0
        for i in range(1,len(rings),2):
            rgb=[]
            if rings[i] not in lst:
                lst.append(rings[i])
                for j in range(1,len(rings),2):
                    if rings[j]==rings[i]:
                        if rings[j-1]=='R':
                            rgb.append(rings[j-1])
                        if rings[j-1]=='G':
                            rgb.append(rings[j-1])
                        if rings[j-1]=='B':
                            rgb.append(rings[j-1])
                if len(set(rgb))==2:
                    count+=1
        return count",None,"class Solution:
    def countPoints(self, rings: str) -> int:
        lst=[]
        rgb=[]
        count=0
        for i in range(1,len(rings),2):
            rgb=[]
            if rings[i] not in lst:
                lst.append(rings[i])
                for j in range(1,len(rings),2):
                    if rings[j]==rings[i]:
                        if rings[j-1]=='R':
                            rgb.append(rings[j-1])
                        if rings[j-1]=='G':
                            rgb.append(rings[j-1])
                        if rings[j-1]=='B':
                            rgb.append(rings[j-1])
                if len(set(rgb))==3:
                    count+=1
        return count
"
3077,python3,rings-and-rods,"class Solution:
    def countPoints(self, rings: str) -> int:
        lst=[]
        rgb=[]
        count=0
        for i in range(1,len(rings),2):
            rgb=[]
            if rings[i] not in lst:
                lst.append(rings[i])
                for j in range(1,len(rings),2):
                    if rings[j]==rings[i]:
                        if rings[j-1]=='R':
                            rgb.append(rings[j-1])
                        if rings[j-1]=='G':
                            rgb.append(rings[j-1])
                        if rings[j-1]=='B':
                            rgb.append(rings[j-1])
                if len(set(rgb))==2:
                    count+=1
        return count",None,"class Solution:
    def countPoints(self, rings: str) -> int:
        lst=[]
        rgb=[]
        count=0
        for i in range(1,len(rings),2):
            rgb=[]
            if rings[i] not in lst:
                lst.append(rings[i])
                for j in range(1,len(rings),2):
                    if rings[j]==rings[i]:
                        if rings[j-1]=='R':
                            rgb.append(rings[j-1])
                        if rings[j-1]=='G':
                            rgb.append(rings[j-1])
                        if rings[j-1]=='B':
                            rgb.append(rings[j-1])
                if len(set(rgb))==3:
                    count+=1
        return count
"
3078,python3,corporate-flight-bookings,"class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:

        arr = [0]*(n+1)
        for lv, ar, seats in bookings:
            arr[lv-1]+= seats
            arr[ar+1]-= seats

        return list(accumulate(arr[:-1]))",None,"class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:

        arr = [0]*(n+2) # Increase the size of arr for handling edge cases
        for lv, ar, seats in bookings:
            arr[lv-1]+= seats
            arr[ar]-= seats  # use arr[ar] instead of arr[ar+1]

        return list(accumulate(arr[:-2]))  # calculate accumulated sum of arr[:-2]
"
3078,python3,corporate-flight-bookings,"class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:

        arr = [0]*(n+1)
        for lv, ar, seats in bookings:
            arr[lv-1]+= seats
            arr[ar+1]-= seats

        return list(accumulate(arr[:-1]))",None,"class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:

        arr = [0]*(n+1)
        for lv, ar, seats in bookings:
            arr[lv-1]+= seats
            if ar < n:
                arr[ar]-= seats

        return list(accumulate(arr[:-1]))
"
3078,python3,corporate-flight-bookings,"class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:

        arr = [0]*(n+1)
        for lv, ar, seats in bookings:
            arr[lv-1]+= seats
            arr[ar+1]-= seats

        return list(accumulate(arr[:-1]))",None,"class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:

        arr = [0]*(n+1)
        for lv, ar, seats in bookings:
            arr[lv-1]+= seats
            if ar < n:
                arr[ar]-= seats

        return list(accumulate(arr[:-1]))
"
3079,python3,fizz-buzz,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        arr=[]
        for i in range(1,n+1):
            if i%3==0 and i%5==0:
                arr.append(""FizzBuzz"")
            elif i%3==0:
                arr.append(""Buzz"")
            elif i%5==0:
                arr.append(""Fizz"")
            else:
                arr.append(str(i))
        return arr",None,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        arr=[]
        for i in range(1,n+1):
            if i%3==0 and i%5==0:
                arr.append(""FizzBuzz"")
            elif i%3==0:
                arr.append(""Fizz"")
            elif i%5==0:
                arr.append(""Buzz"")
            else:
                arr.append(str(i))
        return arr
"
3079,python3,fizz-buzz,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        arr=[]
        for i in range(1,n+1):
            if i%3==0 and i%5==0:
                arr.append(""FizzBuzz"")
            elif i%3==0:
                arr.append(""Buzz"")
            elif i%5==0:
                arr.append(""Fizz"")
            else:
                arr.append(str(i))
        return arr",None,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        arr=[]
        for i in range(1,n+1):
            if i%3==0 and i%5==0:
                arr.append(""FizzBuzz"")
            elif i%3==0:
                arr.append(""Fizz"")
            elif i%5==0:
                arr.append(""Buzz"")
            else:
                arr.append(str(i))
        return arr
"
3079,python3,fizz-buzz,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        arr=[]
        for i in range(1,n+1):
            if i%3==0 and i%5==0:
                arr.append(""FizzBuzz"")
            elif i%3==0:
                arr.append(""Buzz"")
            elif i%5==0:
                arr.append(""Fizz"")
            else:
                arr.append(str(i))
        return arr",None,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        arr=[]
        for i in range(1,n+1):
            if i%3==0 and i%5==0:
                arr.append(""FizzBuzz"")
            elif i%3==0:
                arr.append(""Fizz"")
            elif i%5==0:
                arr.append(""Buzz"")
            else:
                arr.append(str(i))
        return arr
"
3080,python3,ransom-note,"class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        ransomNote = list(ransomNote)
        magazine = list(magazine)
        for char in magazine:
            if char in ransomNote:
                ransomNote.remove(char)
            else:
                return False
        return True",None,"class Solution:
    def canConstruct(self, ransomNote, magazine):
        for char in ransomNote:
            if char in magazine:
                magazine = magazine.replace(char, '', 1)
            else:
                return False
        return True
"
3080,python3,ransom-note,"class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        ransomNote = list(ransomNote)
        magazine = list(magazine)
        for char in magazine:
            if char in ransomNote:
                ransomNote.remove(char)
            else:
                return False
        return True",None,"class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        ransomNote = list(ransomNote)
        magazine = list(magazine)
        for char in ransomNote:
            if char in magazine:
                magazine.remove(char)
            else:
                return False
        return True
"
3080,python3,ransom-note,"class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        ransomNote = list(ransomNote)
        magazine = list(magazine)
        for char in magazine:
            if char in ransomNote:
                ransomNote.remove(char)
            else:
                return False
        return True",None,"class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        ransomNote = list(ransomNote)
        magazine = list(magazine)
        for char in ransomNote:
            if char in magazine:
                magazine.remove(char)
            else:
                return False
        return True
"
3081,python3,k-similar-strings,"class Solution:
    def kSimilarity(self, s1: str, s2: str) -> int:
        deque = collections.deque([s1])
        
        seen = set() 
        answ=0 
        
        
        while deque:
            for _ in range(len(deque)): 
                
                string = deque.popleft() 
                if string ==s2: return answ
                
                
                i=0
                while string[i]==s2[i]:
                    i+=1
                
                
                for j in range(i+1, len(string)):
                    if string[i]==s2[j] and s2[j]==s1[j]:  
                        
                        
                        new = string[:i] + string[j] + string[i+1:j] + string[i] + string[j+1:]
                        
                        if new not in seen:
                            seen.add(new)
                            deque.append(new)
            
            answ+=1",None,"class Solution:
    def kSimilarity(self, s1: str, s2: str) -> int:
        deque = collections.deque([s1])
        
        seen = {s1} 
        answ=0 
        
        while deque:
            for _ in range(len(deque)): 

                string = deque.popleft() 
                if string ==s2: return answ

                i=0
                while string[i]==s2[i]:
                    i+=1

                for j in range(i+1, len(string)):
                    if string[j]==s2[i]:  

                        new = string[:i] + string[j] + string[i+1:j] + string[i] + string[j+1:]

                        if new not in seen:
                            seen.add(new)
                            deque.append(new)
            
            answ+=1
"
3081,python3,k-similar-strings,"class Solution:
    def kSimilarity(self, s1: str, s2: str) -> int:
        deque = collections.deque([s1])
        
        seen = set() 
        answ=0 
        
        
        while deque:
            for _ in range(len(deque)): 
                
                string = deque.popleft() 
                if string ==s2: return answ
                
                
                i=0
                while string[i]==s2[i]:
                    i+=1
                
                
                for j in range(i+1, len(string)):
                    if string[i]==s2[j] and s2[j]==s1[j]:  
                        
                        
                        new = string[:i] + string[j] + string[i+1:j] + string[i] + string[j+1:]
                        
                        if new not in seen:
                            seen.add(new)
                            deque.append(new)
            
            answ+=1",None,"import collections

class Solution:
    def kSimilarity(self, s1: str, s2: str) -> int:
        deque = collections.deque([s1])
        
        seen = {s1} 
        answ = 0 
        
        
        while deque:
            for _ in range(len(deque)): 
                
                string = deque.popleft() 
                if string == s2: 
                    return answ
                
                
                i = 0
                while string[i] == s2[i]:
                    i += 1
                
                
                for j in range(i+1, len(string)):
                    if string[j] == s2[i] and s2[j] != s1[j]: 
                        
                        
                        new = string[:i] + string[j] + string[i+1:j] + string[i] + string[j+1:]
                        
                        if new not in seen:
                            seen.add(new)
                            deque.append(new)
            
            answ += 1
"
3081,python3,k-similar-strings,"class Solution:
    def kSimilarity(self, s1: str, s2: str) -> int:
        deque = collections.deque([s1])
        
        seen = set() 
        answ=0 
        
        
        while deque:
            for _ in range(len(deque)): 
                
                string = deque.popleft() 
                if string ==s2: return answ
                
                
                i=0
                while string[i]==s2[i]:
                    i+=1
                
                
                for j in range(i+1, len(string)):
                    if string[i]==s2[j] and s2[j]==s1[j]:  
                        
                        
                        new = string[:i] + string[j] + string[i+1:j] + string[i] + string[j+1:]
                        
                        if new not in seen:
                            seen.add(new)
                            deque.append(new)
            
            answ+=1",None,"class Solution:
    def kSimilarity(self, s1: str, s2: str) -> int:
        deque = collections.deque([s1])
        
        seen = {s1} 
        answ=0 
        
        
        while deque:
            for _ in range(len(deque)): 
                
                string = deque.popleft() 
                if string ==s2: return answ
                
                
                i=0
                while string[i]==s2[i]:
                    i+=1
                
                
                for j in range(i+1, len(string)):
                    if string[j] == s2[i]:   
                        
                        
                        new = string[:i] + string[j] + string[i+1:j] + string[i] + string[j+1:]
                        
                        if new not in seen:
                            seen.add(new)
                            deque.append(new)
            
            answ+=1 "
3082,python3,linked-list-cycle,"
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        a=b=head
        while(a!=None and a.next!=None):
            b=b.next
            a=a.next
            if(a==b):
                return True
        return False",None,"class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        a = b = head
        while a is not None and a.next is not None:
            a = a.next.next
            b = b.next
            if a == b:
                return True
        return False
"
3082,python3,linked-list-cycle,"
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        a=b=head
        while(a!=None and a.next!=None):
            b=b.next
            a=a.next
            if(a==b):
                return True
        return False",None,"class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        a = b = head
        while b is not None and b.next is not None:
            a = a.next
            b = b.next.next
            if a == b:
                return True
        return False
"
3082,python3,linked-list-cycle,"
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        a=b=head
        while(a!=None and a.next!=None):
            b=b.next
            a=a.next
            if(a==b):
                return True
        return False",None,"class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        a=b=head
        while(a!=None and a.next!=None):
            a=a.next.next
            b=b.next
            if(a==b):
                return True
        return False
"
3083,python3,minimum-cost-to-split-an-array,"class Solution:
    def minCost(self, A, K):
        n = len(A)
        dp = [0] + [float('inf')] * n
        for i in range(n):
            C = [0] * n
            val = K
            for j in range(i, -1, -1):
                val += (C[A[j]] >= 1) + (C[A[j]] == 0)
                C[A[j]] += 1
                dp[i + 1] = min(dp[i + 1], dp[j] + val)
        return dp[-1]",None,"class Solution:
    def minCost(self, A, K):
        n = len(A)
        dp = [0] + [float('inf')] * n
        for i in range(1, n + 1):
            C = [0] * (n + 1)
            val = 0
            for j in range(i - 1, -1, -1):
                val -= 2 * (C[A[j]] == 1)
                val += 1
                C[A[j]] += 1
                dp[i] = min(dp[i], dp[j] + val + K)
        return dp[-1]
"
3083,python3,minimum-cost-to-split-an-array,"class Solution:
    def minCost(self, A, K):
        n = len(A)
        dp = [0] + [float('inf')] * n
        for i in range(n):
            C = [0] * n
            val = K
            for j in range(i, -1, -1):
                val += (C[A[j]] >= 1) + (C[A[j]] == 0)
                C[A[j]] += 1
                dp[i + 1] = min(dp[i + 1], dp[j] + val)
        return dp[-1]",None,"class Solution:
    def minCost(self, A, K):
        n = len(A)
        dp = [0] + [float('inf')] * n
        for i in range(n):
            C = [0] * n
            val = 0
            for j in range(i, -1, -1):
                val += (C[A[j]] >= 1) - (C[A[j]] == 0)
                C[A[j]] += 1
                dp[i + 1] = min(dp[i + 1], dp[j] + val + K)
        return dp[-1]
"
3083,python3,minimum-cost-to-split-an-array,"class Solution:
    def minCost(self, A, K):
        n = len(A)
        dp = [0] + [float('inf')] * n
        for i in range(n):
            C = [0] * n
            val = K
            for j in range(i, -1, -1):
                val += (C[A[j]] >= 1) + (C[A[j]] == 0)
                C[A[j]] += 1
                dp[i + 1] = min(dp[i + 1], dp[j] + val)
        return dp[-1]",None,"class Solution:
    def minCost(self, A, K):
        n = len(A)
        dp = [0] + [float('inf')] * n
        for i in range(n):
            C = [0] * n
            val = K
            for j in range(i, -1, -1):
                val -= (C[A[j]] == 1) 
                val += (C[A[j]] == 0) 
                C[A[j]] += 1
                dp[i + 1] = min(dp[i + 1], dp[j] + val)
        return dp[-1]
"
3084,python3,minimum-deletions-to-make-array-divisible,"class Solution:
    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
        gc=0
        for i in numsDivide:
            gc=int(math.gcd(gc,i))
        nums.sort()
        for i in range(len(nums)):
            if nums[i]%gc==0:
                return i
        return -1",None,"class Solution:
    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
        gc = 0
        for i in numsDivide:
            gc = math.gcd(gc,i)
        nums.sort()
        for i in range(len(nums)):
            if gc % nums[i] == 0:
                return i
        return -1
"
3084,python3,minimum-deletions-to-make-array-divisible,"class Solution:
    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
        gc=0
        for i in numsDivide:
            gc=int(math.gcd(gc,i))
        nums.sort()
        for i in range(len(nums)):
            if nums[i]%gc==0:
                return i
        return -1",None,"class Solution:
    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
        gc = 0
        for i in numsDivide:
            gc = math.gcd(gc,i)
        nums.sort()
        for i in range(len(nums)):
            if gc % nums[i] == 0:
                return i
        return -1
"
3084,python3,minimum-deletions-to-make-array-divisible,"class Solution:
    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
        gc=0
        for i in numsDivide:
            gc=int(math.gcd(gc,i))
        nums.sort()
        for i in range(len(nums)):
            if nums[i]%gc==0:
                return i
        return -1",None,"class Solution:
    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
        nums.sort()
        for i in range(len(nums)):
            if all(x % nums[i] == 0 for x in numsDivide):
                return i
        return -1
"
3085,python3,x-of-a-kind-in-a-deck-of-cards,"class Solution:
    def hasGroupsSizeX(self, deck: List[int]) -> bool:
        count = collections.Counter(deck)
        val = count.values()
        import math
        m = math.gcd(*val)
        if m > 2:
            return True 
        else:
            return False",None,"class Solution:
    def hasGroupsSizeX(self, deck: List[int]) -> bool:
        count = collections.Counter(deck)
        val = count.values()
        import math
        m = math.gcd(*val)
        if m >= 2:
            return True 
        else:
            return False
"
3085,python3,x-of-a-kind-in-a-deck-of-cards,"class Solution:
    def hasGroupsSizeX(self, deck: List[int]) -> bool:
        count = collections.Counter(deck)
        val = count.values()
        import math
        m = math.gcd(*val)
        if m > 2:
            return True 
        else:
            return False",None,"class Solution:
    def hasGroupsSizeX(self, deck: List[int]) -> bool:
        count = collections.Counter(deck)
        val = count.values()
        import math
        m = math.gcd(*val)
        if m >= 2:
            return True 
        else:
            return False
"
3085,python3,x-of-a-kind-in-a-deck-of-cards,"class Solution:
    def hasGroupsSizeX(self, deck: List[int]) -> bool:
        count = collections.Counter(deck)
        val = count.values()
        import math
        m = math.gcd(*val)
        if m > 2:
            return True 
        else:
            return False",None,"class Solution:
    def hasGroupsSizeX(self, deck: List[int]) -> bool:
        count = collections.Counter(deck)
        val = count.values()
        import math
        m = math.gcd(*val)
        if m >= 2:
            return True 
        else:
            return False
"
3086,python3,plates-between-candles,"class Solution:
    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:
        candies = [i for i, c in enumerate(s) if c == ""|""]
        
        def bns(x: int) -> int:
            l, r = 0, len(candies) - 1
            while l <= r:
                m = (l + r) // 2
                if candies[m] < x: l = m + 1
                else: r = m + 1
            return l

        ans = []
        for a, b in queries:
            l, r = bns(a), bns(b + 1) - 1
            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)
        return ans",None,"class Solution:
    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:
        plates = [0]*(len(s)+1)
        candles = [i for i, c in enumerate(s) if c == '|']
        
        if len(candles) > 1:
            for i in range(1, len(candles)):
                plates[i] = plates[i-1] + s[candles[i-1]:candles[i]].count('*')     

        def bns(x: int) -> int:
            l, r = 0, len(candles) - 1
            while l <= r:
                m = (l + r) // 2
                if candles[m] < x: l = m + 1
                else: r = m - 1 # Corrected binary search logic
            return l

        ans = []
        for a, b in queries:
            l, r = bns(a), bns(b + 1) - 1
            ans.append(plates[r] - plates[l] if l <= r else 0) # Corrected condition
        return ans
"
3086,python3,plates-between-candles,"class Solution:
    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:
        candies = [i for i, c in enumerate(s) if c == ""|""]
        
        def bns(x: int) -> int:
            l, r = 0, len(candies) - 1
            while l <= r:
                m = (l + r) // 2
                if candies[m] < x: l = m + 1
                else: r = m + 1
            return l

        ans = []
        for a, b in queries:
            l, r = bns(a), bns(b + 1) - 1
            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)
        return ans",None,"class Solution:
    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:
        candies = [i for i, c in enumerate(s) if c == ""|""]
        
        def bns(x: int) -> int:
            l, r = 0, len(candies) - 1
            while l <= r:
                m = (l + r) // 2
                if candies[m] < x: l = m + 1
                else: r = m - 1
            return l

        ans = []
        for a, b in queries:
            l, r = bns(a), bns(b + 1) - 1
            ans.append(candies[r] - candies[l] - (r - l) if l <= r else 0)
        return ans
"
3086,python3,plates-between-candles,"class Solution:
    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:
        candies = [i for i, c in enumerate(s) if c == ""|""]
        
        def bns(x: int) -> int:
            l, r = 0, len(candies) - 1
            while l <= r:
                m = (l + r) // 2
                if candies[m] < x: l = m + 1
                else: r = m + 1
            return l

        ans = []
        for a, b in queries:
            l, r = bns(a), bns(b + 1) - 1
            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)
        return ans",None,"class Solution:
    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:
        candies = [i for i, c in enumerate(s) if c == ""|""]
        
        def bns(x: int) -> int:
            l, r = 0, len(candies) - 1
            while l <= r:
                m = (l + r) // 2
                if candies[m] < x: l = m + 1
                else: r = m - 1
            return l

        ans = []
        for a, b in queries:
            l, r = bns(a), bns(b + 1) - 1
            ans.append(candies[r] - candies[l] - (r - l) if l <= r else 0)
        return ans
"
3087,python3,create-components-with-same-value,"class Solution:
    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:
        tree = [[] for _ in nums]
        for u, v in edges: 
            tree[u].append(v)
            tree[v].append(u)
        
        def fn(u, p):
            """"""Post-order dfs.""""""
            ans = nums[u]
            for v in tree[u]: 
                if v != p: ans += fn(v, u)
            return 0 if ans == cand else ans
        
        total = sum(nums)
        for cand in range(1, total//2+1): 
            if total % cand != 0 and fn(0, -1) == 0: return total//cand-1
        return 0",None,"class Solution:
    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:
        tree = [[] for _ in nums]
        for u, v in edges: 
            tree[u].append(v)
            tree[v].append(u)
        
        def fn(u, p):
            """"""Post-order dfs.""""""
            res = nums[u]
            for v in tree[u]: 
                if v != p: res += fn(v, u)
                    
            if res == target_comp_val: 
                self.possible = True
                return 0
            return res
        
        total = sum(nums)
        self.possible = False
        target_comp_val = total // 2
        
        if total % 2 == 0 and fn(0, -1) == 0: 
            return total // target_comp_val - 1
        
        return 0
"
3087,python3,create-components-with-same-value,"class Solution:
    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:
        tree = [[] for _ in nums]
        for u, v in edges: 
            tree[u].append(v)
            tree[v].append(u)
        
        def fn(u, p):
            """"""Post-order dfs.""""""
            ans = nums[u]
            for v in tree[u]: 
                if v != p: ans += fn(v, u)
            return 0 if ans == cand else ans
        
        total = sum(nums)
        for cand in range(1, total//2+1): 
            if total % cand != 0 and fn(0, -1) == 0: return total//cand-1
        return 0",None,"class Solution:
    def deleteEqualTrees(self, nums: List[int], edges: List[List[int]]) -> int:
        g = collections.defaultdict(list)
        for u, v in edges:
            g[u].append(v)
            g[v].append(u)

        counter = collections.Counter(nums)
        sum_val = sum(nums)
        self.ans = self.checked = 0

        def dfs(node, parent):
            total = nums[node]
            for child in g[node]:
                if child == parent:
                    continue
                value = dfs(child, node)
                if value * 2 == sum_val:
                    self.ans += 1
                    value = 0
                total += value
            return total

        dfs(0, -1)
        return self.ans if dfs(0, -1) * 2 == sum_val else -1
"
3087,python3,create-components-with-same-value,"class Solution:
    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:
        tree = [[] for _ in nums]
        for u, v in edges: 
            tree[u].append(v)
            tree[v].append(u)
        
        def fn(u, p):
            """"""Post-order dfs.""""""
            ans = nums[u]
            for v in tree[u]: 
                if v != p: ans += fn(v, u)
            return 0 if ans == cand else ans
        
        total = sum(nums)
        for cand in range(1, total//2+1): 
            if total % cand != 0 and fn(0, -1) == 0: return total//cand-1
        return 0",None,"class Solution:
    def deleteTreeEdges(self, nums: List[int], edges: List[List[int]]) -> int:
        total, n = sum(nums), len(nums)
        tree = [[] for _ in range(n)]
        for u, v in edges:
            tree[u].append(v)
            tree[v].append(u)
        visited, dp = [0]*n, [0]*n
        
        def dfs(u: int) -> None:
            visited[u] = 1
            for v in tree[u]:
                if visited[v] == 0:
                    dfs(v)
                    dp[u] += dp[v]
            dp[u] += nums[u]
        
        dfs(0)
        answer = 0
        for num in dp[:-1]:
            if num * 2 == total:
                 answer += 1
        if total % 2: 
            return -1
        return answer if dp[0] != 0 else -1
"
3088,python3,scramble-string,"class Solution:
    @cache
    def isScramble(self, s1: str, s2: str) -> bool:
        if Counter(s1) != Counter(s2):
            return False
        if s1 == s2:
            return True
        for k in range(1, len(s1)):
            if (
                self.isScramble(s1[:-k], s2[:-k]) and self.isScramble(s1[k:], s2[k:])
            ) or (
                self.isScramble(s1[:-k], s2[k:]) and self.isScramble(s1[k:], s2[:-k])
            ): return True
        return False",None,"class Solution:
    @cache
    def isScramble(self, s1: str, s2: str) -> bool:
        if Counter(s1) != Counter(s2):
            return False
        if s1 == s2:
            return True
        for k in range(1, len(s1)):
            if (
                self.isScramble(s1[:k], s2[:k]) and self.isScramble(s1[k:], s2[k:])
            ) or (
                self.isScramble(s1[:k], s2[-k:]) and self.isScramble(s1[k:], s2[:-k])
            ): return True
        return False
"
3088,python3,scramble-string,"class Solution:
    @cache
    def isScramble(self, s1: str, s2: str) -> bool:
        if Counter(s1) != Counter(s2):
            return False
        if s1 == s2:
            return True
        for k in range(1, len(s1)):
            if (
                self.isScramble(s1[:-k], s2[:-k]) and self.isScramble(s1[k:], s2[k:])
            ) or (
                self.isScramble(s1[:-k], s2[k:]) and self.isScramble(s1[k:], s2[:-k])
            ): return True
        return False",None,"class Solution:
    @cache
    def isScramble(self, s1: str, s2: str) -> bool:
        if Counter(s1) != Counter(s2):
            return False
        if s1 == s2:
            return True
        for k in range(1, len(s1)):
            if (
                self.isScramble(s1[:k], s2[:k]) and self.isScramble(s1[k:], s2[k:])
            ) or (
                self.isScramble(s1[:k], s2[-k:]) and self.isScramble(s1[k:], s2[:-k])
            ): 
                return True
        return False
"
3088,python3,scramble-string,"class Solution:
    @cache
    def isScramble(self, s1: str, s2: str) -> bool:
        if Counter(s1) != Counter(s2):
            return False
        if s1 == s2:
            return True
        for k in range(1, len(s1)):
            if (
                self.isScramble(s1[:-k], s2[:-k]) and self.isScramble(s1[k:], s2[k:])
            ) or (
                self.isScramble(s1[:-k], s2[k:]) and self.isScramble(s1[k:], s2[:-k])
            ): return True
        return False",None,"class Solution:
    @cache
    def isScramble(self, s1: str, s2: str) -> bool:
        if Counter(s1) != Counter(s2):
            return False
        if s1 == s2:
            return True
        for k in range(1, len(s1)):
            if (
                self.isScramble(s1[:k], s2[:k]) and self.isScramble(s1[k:], s2[k:])
            ) or (
                self.isScramble(s1[:k], s2[-k:]) and self.isScramble(s1[k:], s2[:-k])
            ): return True
        return False
"
3089,python3,valid-permutations-for-di-sequence,"class Solution:
    def numPermsDISequence(self, s: str) -> int:
        mem=defaultdict(int)
        def dfs(i,val=0):
            if i==len(s):
                return 1
            if (i,val) in mem:
                return mem[i,val]
            p=0
            if s[i]==""D"":
                for ind in range(0,val+1):
                    p+=dfs(i+1,ind)%(10**9+7)
            else:
                for ind in range(val+1,i+1):
                    p+=dfs(i+1,ind)%(10**9+7)
            mem[i,val]=p
            return p
        return dfs(0)",None,"class Solution:
    def numPermsDISequence(self, s: str) -> int:
        mem = dict()
        def dfs(i,val=0):
            if i == len(s):
                return 1
            if (i,val) in mem:
                return mem[i,val]
            p = 0
            if s[i] == ""D"":
                for ind in range(val, i+2):
                    p += dfs(i+1, ind) % (10**9 + 7)
            else:
                for ind in range(0, val+1):
                    p += dfs(i+1, ind) % (10**9 + 7)
            mem[i,val] = p
            return p
        result = 0
        for i in range(len(s) + 1):
            result += dfs(0, i)
        return result % (10**9 + 7)
"
3089,python3,valid-permutations-for-di-sequence,"class Solution:
    def numPermsDISequence(self, s: str) -> int:
        mem=defaultdict(int)
        def dfs(i,val=0):
            if i==len(s):
                return 1
            if (i,val) in mem:
                return mem[i,val]
            p=0
            if s[i]==""D"":
                for ind in range(0,val+1):
                    p+=dfs(i+1,ind)%(10**9+7)
            else:
                for ind in range(val+1,i+1):
                    p+=dfs(i+1,ind)%(10**9+7)
            mem[i,val]=p
            return p
        return dfs(0)",None,"class Solution:
    def numPermsDISequence(self, s: str) -> int:
        mem=defaultdict(int)
        def dfs(i,val=0):
            if i==len(s):
                return 1
            if (i,val) in mem:
                return mem[(i,val)]
            p=0
            if s[i]==""D"":
                for ind in range(0,val+1):
                    p+=dfs(i+1,ind)%(10**9+7)
            else:
                for ind in range(val+1,i+2):
                    p+=dfs(i+1,ind)%(10**9+7)
            mem[(i,val)]=p
            return p
        return dfs(0)%(10**9+7)
"
3089,python3,valid-permutations-for-di-sequence,"class Solution:
    def numPermsDISequence(self, s: str) -> int:
        mem=defaultdict(int)
        def dfs(i,val=0):
            if i==len(s):
                return 1
            if (i,val) in mem:
                return mem[i,val]
            p=0
            if s[i]==""D"":
                for ind in range(0,val+1):
                    p+=dfs(i+1,ind)%(10**9+7)
            else:
                for ind in range(val+1,i+1):
                    p+=dfs(i+1,ind)%(10**9+7)
            mem[i,val]=p
            return p
        return dfs(0)",None,"class Solution:
    def numPermsDISequence(self, s: str) -> int:
        mem = defaultdict(int)
        def dfs(i, val=0):
            if i == len(s):
                return 1
            if (i,val) in mem:
                return mem[(i,val)]
            p = 0
            if s[i] == ""D"":
                for ind in range(0, val+1):
                    p += dfs(i+1, ind) % (10**9+7)
            else:
                for ind in range(val+1, i+2):
                    p += dfs(i+1, ind) % (10**9+7)
            mem[(i,val)] = p
            return p
        return dfs(0)
"
3090,python3,check-if-string-is-transformable-with-substring-sort-operations,"class Solution:
  def isTransformable(self, s: str, t: str) -> bool:
    idx = defaultdict(deque)
    for i, c in enumerate(s):
      idx[int(c)].append(i)
    for c in t:
      d = int(c)
      if not idx[d]: return False
    idx[d].popleft()
    return True",None,"from collections import deque, defaultdict

class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        idx = defaultdict(deque)
        for i, c in enumerate(s):
            idx[int(c)].append(i)
        for c in t:
            d = int(c)
            if not idx[d]:
                return False
            for i in range(d):
                if idx[i] and idx[i][0] < idx[d][0]:
                    return False
            idx[d].popleft()
        return True
"
3090,python3,check-if-string-is-transformable-with-substring-sort-operations,"class Solution:
  def isTransformable(self, s: str, t: str) -> bool:
    idx = defaultdict(deque)
    for i, c in enumerate(s):
      idx[int(c)].append(i)
    for c in t:
      d = int(c)
      if not idx[d]: return False
    idx[d].popleft()
    return True",None,"class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        idx = defaultdict(deque)
        for i, c in enumerate(s):
            idx[int(c)].append(i)
        for c in t:
            d = int(c)
            if not idx[d]: return False
            for i in range(d):
                if idx[i] and idx[i][0] < idx[d][0]:
                    return False
            idx[d].popleft()
        return True
"
3090,python3,check-if-string-is-transformable-with-substring-sort-operations,"class Solution:
  def isTransformable(self, s: str, t: str) -> bool:
    idx = defaultdict(deque)
    for i, c in enumerate(s):
      idx[int(c)].append(i)
    for c in t:
      d = int(c)
      if not idx[d]: return False
    idx[d].popleft()
    return True",None,"class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        idx = defaultdict(deque)
        for i, c in enumerate(s):
            idx[int(c)].append(i)
        for c in t:
            d = int(c)
            
            if not idx[d]: return False
            
            for i in range(d):
                if idx[i] and idx[i][0] < idx[d][0]:
                    return False
            idx[d].popleft()
        return True
"
3091,python3,maximum-elegance-of-a-k-length-subsequence,"class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        dico=defaultdict(list)
        for profit,category in items:
            dico[category].append(profit)
        categories=[]
        for category in dico:
            categories.append(sorted(dico[category]))
        categories.sort(key=lambda x:x[-1],reverse=True)
        def elegance (distinct):
            res=0
            rest=[]
            for i in range (distinct):
                res+=categories[i][-1]
                for j in range (len(categories[i])-1):
                    rest.append(categories[i][j])
            rest.sort(reverse=True)
            if len(rest)<k-distinct:
                return -1
            return res+sum(rest[:k-distinct])+distinct**2
        l,r=1,min(len(categories)-1,k-1)
        mid=(l+r)//2
        while l<=r: 
            if elegance(mid+1)>elegance(mid) or elegance(mid+1)==-1:
                l=mid+1
            else:
                r=mid
            mid=(l+r)//2
        return max(elegance(mid),elegance(mid+1))",None,"class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        dico = defaultdict(list)
        for profit, category in items:
            dico[category].append(profit)
        categories = []
        for category in dico:
            categories.append(sorted(dico[category]))
        categories.sort(key=lambda x: x[-1], reverse=True)
        def elegance(distinct):
            res = 0
            rest = []
            for i in range(distinct):
                res += categories[i][-1]
                for j in range(len(categories[i])-1):
                    rest.append(categories[i][j])
            rest.sort(reverse=True)
            if len(rest) < (k - distinct):
                return -1
            return res + sum(rest[:k - distinct]) + distinct ** 2
        l, r = 1, min(len(categories), k)
        mid = (l + r) // 2
        while l < r: 
            if elegance(mid + 1) > elegance(mid) or elegance(mid + 1) == -1:
                l = mid + 1
            else:
                r = mid
            mid = (l + r) // 2
        return max(elegance(mid), elegance(mid + 1))
"
3091,python3,maximum-elegance-of-a-k-length-subsequence,"class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        dico=defaultdict(list)
        for profit,category in items:
            dico[category].append(profit)
        categories=[]
        for category in dico:
            categories.append(sorted(dico[category]))
        categories.sort(key=lambda x:x[-1],reverse=True)
        def elegance (distinct):
            res=0
            rest=[]
            for i in range (distinct):
                res+=categories[i][-1]
                for j in range (len(categories[i])-1):
                    rest.append(categories[i][j])
            rest.sort(reverse=True)
            if len(rest)<k-distinct:
                return -1
            return res+sum(rest[:k-distinct])+distinct**2
        l,r=1,min(len(categories)-1,k-1)
        mid=(l+r)//2
        while l<=r: 
            if elegance(mid+1)>elegance(mid) or elegance(mid+1)==-1:
                l=mid+1
            else:
                r=mid
            mid=(l+r)//2
        return max(elegance(mid),elegance(mid+1))",None,"class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        dico=defaultdict(list)
        for profit,category in items:
            dico[category].append(profit)
        categories=[]
        for category in dico:
            categories.append(sorted(dico[category]))
        categories.sort(key=lambda x:x[-1],reverse=True)
        def elegance (distinct):
            res=0
            rest=[]
            for i in range (distinct):
                res+=categories[i][-1]
                for j in range (len(categories[i])-1):
                    rest.append(categories[i][j])
            rest.sort(reverse=True)
            if len(rest)<k-distinct:
                return -1
            return res+sum(rest[:k-distinct])+distinct**2
        l,r=1,min(len(categories),k)
        mid=(l+r)//2
        while l<r: 
            if elegance(mid+1)>elegance(mid):
                l=mid+1
            else:
                r=mid
            mid=(l+r)//2
        return max(elegance(mid),elegance(mid+1))
"
3091,python3,maximum-elegance-of-a-k-length-subsequence,"class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        dico=defaultdict(list)
        for profit,category in items:
            dico[category].append(profit)
        categories=[]
        for category in dico:
            categories.append(sorted(dico[category]))
        categories.sort(key=lambda x:x[-1],reverse=True)
        def elegance (distinct):
            res=0
            rest=[]
            for i in range (distinct):
                res+=categories[i][-1]
                for j in range (len(categories[i])-1):
                    rest.append(categories[i][j])
            rest.sort(reverse=True)
            if len(rest)<k-distinct:
                return -1
            return res+sum(rest[:k-distinct])+distinct**2
        l,r=1,min(len(categories)-1,k-1)
        mid=(l+r)//2
        while l<=r: 
            if elegance(mid+1)>elegance(mid) or elegance(mid+1)==-1:
                l=mid+1
            else:
                r=mid
            mid=(l+r)//2
        return max(elegance(mid),elegance(mid+1))",None,"class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        dico=defaultdict(list)
        for profit,category in items:
            dico[category].append(profit)
        categories=[]
        for category in dico:
            categories.append(sorted(dico[category]))
        categories.sort(key=lambda x:x[-1],reverse=True)
        def elegance (distinct):
            res=0
            rest=[]
            for i in range (distinct):
                res+=categories[i][-1]
                for j in range (len(categories[i])-1):
                    rest.append(categories[i][j])
            rest.sort(reverse=True)
            if len(rest)<k-distinct:
                return -1
            return res+sum(rest[:k-distinct])+distinct**2
        l,r=1,min(len(categories),k)
        mid=(l+r)//2
        while l<r: 
            if elegance(mid+1)>elegance(mid) or elegance(mid+1)==-1:
                l=mid+1
            else:
                r=mid
            mid=(l+r)//2
        return max(elegance(mid),elegance(mid+1)) if mid+1 <= k else elegance(mid)
"
3092,python3,add-edges-to-make-degrees-of-all-nodes-even,"class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        neighbors = [set() for _ in range(n)]
        for edge in edges:
            a, b = edge
            a -=1
            b -=1
            neighbors[a].add(b)
            neighbors[b].add(a)
        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]
        numOdd = len(oddDegreesNodes)
        if numOdd == 0:
            return True
        elif numOdd == 4:
            o1, o2, o3, o4 = oddDegreesNodes
            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])
        elif numOdd == 2:
            o1, o2 = oddDegreesNodes
            if o1 in neighbors[o2]:
                return True
            bothConnectedTo = neighbors[o1] | neighbors[o2]
            return len(bothConnectedTo) != n
        return False",None,"class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        neighbors = [set() for _ in range(n)]
        for edge in edges:
            a, b = edge
            a -=1
            b -=1
            neighbors[a].add(b)
            neighbors[b].add(a)
        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]
        numOdd = len(oddDegreesNodes)
        if numOdd == 0:
            return True
        elif numOdd == 4:
            o1, o2, o3, o4 = oddDegreesNodes
            return (o2 not in neighbors[o1] and o4 not in neighbors[o3]) or (o3 not in neighbors[o1] and o4 not in neighbors[o2]) or (o4 not in neighbors[o1] and o3 not in neighbors[o2])
        elif numOdd == 2:
            o1, o2 = oddDegreesNodes
            if o2 in neighbors[o1]:
                return True
            bothConnectedTo = neighbors[o1] & neighbors[o2]
            return len(bothConnectedTo) > 0
        return False
"
3092,python3,add-edges-to-make-degrees-of-all-nodes-even,"class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        neighbors = [set() for _ in range(n)]
        for edge in edges:
            a, b = edge
            a -=1
            b -=1
            neighbors[a].add(b)
            neighbors[b].add(a)
        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]
        numOdd = len(oddDegreesNodes)
        if numOdd == 0:
            return True
        elif numOdd == 4:
            o1, o2, o3, o4 = oddDegreesNodes
            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])
        elif numOdd == 2:
            o1, o2 = oddDegreesNodes
            if o1 in neighbors[o2]:
                return True
            bothConnectedTo = neighbors[o1] | neighbors[o2]
            return len(bothConnectedTo) != n
        return False",None,"class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        neighbors = [set() for _ in range(n)]
        for edge in edges:
            a, b = edge
            a -=1
            b -=1
            neighbors[a].add(b)
            neighbors[b].add(a)
        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]
        numOdd = len(oddDegreesNodes)
        if numOdd == 0:
            return True
        elif numOdd == 2:
            return True
        elif numOdd == 4:
            o1, o2, o3, o4 = oddDegreesNodes
            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])
        else:
            return False
"
3092,python3,add-edges-to-make-degrees-of-all-nodes-even,"class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        neighbors = [set() for _ in range(n)]
        for edge in edges:
            a, b = edge
            a -=1
            b -=1
            neighbors[a].add(b)
            neighbors[b].add(a)
        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]
        numOdd = len(oddDegreesNodes)
        if numOdd == 0:
            return True
        elif numOdd == 4:
            o1, o2, o3, o4 = oddDegreesNodes
            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])
        elif numOdd == 2:
            o1, o2 = oddDegreesNodes
            if o1 in neighbors[o2]:
                return True
            bothConnectedTo = neighbors[o1] | neighbors[o2]
            return len(bothConnectedTo) != n
        return False",None,"class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        neighbors = [set() for _ in range(n)]
        for edge in edges:
            a, b = edge
            a -=1
            b -=1
            neighbors[a].add(b)
            neighbors[b].add(a)
        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]
        numOdd = len(oddDegreesNodes)
        if numOdd == 0:
            return True
        elif numOdd == 4:
            o1, o2, o3, o4 = oddDegreesNodes
            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])
        elif numOdd == 2:
            o1, o2 = oddDegreesNodes
            if o1 in neighbors[o2]:
                return False
            bothConnectedTo = neighbors[o1] | neighbors[o2]
            return len(bothConnectedTo) != n
        return False
"
3093,python3,excel-sheet-column-title,"class Solution:
    def convertToTitle(self, n: int) -> str:
        if n<27:
            return chr(ord('A')+(n-1)%26)
        ans=""""
        if n>0:
            if n%26==0:
                ans+=chr(ord('A')+25)
                n-=1
            else:
                ans+=chr(ord('A')+n%26-1)
            n//=26
        return ans[::-1]",None,"class Solution:
    def convertToTitle(self, n: int) -> str:
        ans = """"      
        while n:
            n, remainder = divmod(n - 1, 26)
            ans += chr(65 + remainder)
        return ans[::-1]
"
3093,python3,excel-sheet-column-title,"class Solution:
    def convertToTitle(self, n: int) -> str:
        if n<27:
            return chr(ord('A')+(n-1)%26)
        ans=""""
        if n>0:
            if n%26==0:
                ans+=chr(ord('A')+25)
                n-=1
            else:
                ans+=chr(ord('A')+n%26-1)
            n//=26
        return ans[::-1]",None,"class Solution:
    def convertToTitle(self, n: int) -> str:
        ans = """"
        while n > 0:
            n -= 1  # handle 26 -> Z
            ans += chr(ord('A') + n % 26)
            n //= 26
        return ans[::-1]         
"
3093,python3,excel-sheet-column-title,"class Solution:
    def convertToTitle(self, n: int) -> str:
        if n<27:
            return chr(ord('A')+(n-1)%26)
        ans=""""
        if n>0:
            if n%26==0:
                ans+=chr(ord('A')+25)
                n-=1
            else:
                ans+=chr(ord('A')+n%26-1)
            n//=26
        return ans[::-1]",None,"class Solution:
    def convertToTitle(self, n: int) -> str:
        ans=""""
        while n>0:
            n-=1
            if n%26==0:
                ans+=chr(ord('A')+25)
            else:
                ans+=chr(ord('A')+n%26)
            n//=26
        return ans[::-1]
"
3094,python3,sum-of-absolute-differences-in-a-sorted-array,"class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:

        n=len(nums)
        total=sum(nums)
        s1=0
        s2=total
        arr=[]
        for i in range(n):
            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i+1])*(n-i))) )
            s1=s1+nums[i]
            s2=total-s1

        return arr",None,"class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:

        n=len(nums)
        total=sum(nums)
        s1=0
        s2=total
        arr=[]
        for i in range(n):
            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i])*(n-i-1))) )
            s1=s1+nums[i]
            s2=total-s1

        return arr
"
3094,python3,sum-of-absolute-differences-in-a-sorted-array,"class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:

        n=len(nums)
        total=sum(nums)
        s1=0
        s2=total
        arr=[]
        for i in range(n):
            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i+1])*(n-i))) )
            s1=s1+nums[i]
            s2=total-s1

        return arr",None,"class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:

        n=len(nums)
        total=sum(nums)
        s1=0
        s2=total
        arr=[]
        for i in range(n):
            arr.append(abs(s1-(nums[i]*i))+abs(s2-(nums[i]*(n-i))))
            s1=s1+nums[i]
            s2=total-s1

        return arr
"
3094,python3,sum-of-absolute-differences-in-a-sorted-array,"class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:

        n=len(nums)
        total=sum(nums)
        s1=0
        s2=total
        arr=[]
        for i in range(n):
            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i+1])*(n-i))) )
            s1=s1+nums[i]
            s2=total-s1

        return arr",None,"class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:

        n=len(nums)
        total=sum(nums)
        s1=0
        s2=total
        arr=[]
        for i in range(n):
            arr.append(abs(s1-(nums[i]*i))+abs((s2-nums[i])*(n-i-1)) )
            s1=s1+nums[i]
            s2=s2-nums[i]

        return arr
"
3095,python3,find-all-lonely-numbers-in-the-array,"class Solution:
    def findLonely(self, nums: List[int]) -> List[int]:
        dic={}
        res=[]
        for i in nums:
            if i in dic:
                dic[i]+=1
            else:
                dic[i]=1
        for i in nums:
            if dic[i]==1:
                if (i not in dic) and (i+1 not in dic):  
                    res.append(i)
        return res",None,"class Solution:
    def findLonely(self, nums: List[int]) -> List[int]:
        dic = {}
        res = []
        for i in nums:
            if i in dic:
                dic[i] += 1
            else:
                dic[i] = 1
        for i in nums:
            if dic[i] == 1:
                if (i-1 not in dic) and (i+1 not in dic):  
                    res.append(i)
        return res
"
3095,python3,find-all-lonely-numbers-in-the-array,"class Solution:
    def findLonely(self, nums: List[int]) -> List[int]:
        dic={}
        res=[]
        for i in nums:
            if i in dic:
                dic[i]+=1
            else:
                dic[i]=1
        for i in nums:
            if dic[i]==1:
                if (i not in dic) and (i+1 not in dic):  
                    res.append(i)
        return res",None,"class Solution:
    def findLonely(self, nums: List[int]) -> List[int]:
        dic = {}
        res = []

        for i in nums:
            if i in dic:
                dic[i] += 1
            else:
                dic[i] = 1

        for i in nums:
            if dic[i] == 1:
                if (i-1 not in dic) and (i+1 not in dic):
                    res.append(i)
                    
        return res
"
3095,python3,find-all-lonely-numbers-in-the-array,"class Solution:
    def findLonely(self, nums: List[int]) -> List[int]:
        dic={}
        res=[]
        for i in nums:
            if i in dic:
                dic[i]+=1
            else:
                dic[i]=1
        for i in nums:
            if dic[i]==1:
                if (i not in dic) and (i+1 not in dic):  
                    res.append(i)
        return res",None,"class Solution:
    def findLonely(self, nums: List[int]) -> List[int]:
        dic={}
        res=[]
        for i in nums:
            if i in dic:
                dic[i]+=1
            else:
                dic[i]=1
        for i in nums:
            if dic[i]==1:
                if (i-1 not in dic) and (i+1 not in dic):  
                    res.append(i)
        return res
"
3096,python3,nim-game,"class Solution:
    def canWinNim(self, n: int) -> bool:
        return n % 4 == 0",None,"class Solution:
    def canWinNim(self, n: int) -> bool:
        return n % 4 != 0
"
3096,python3,nim-game,"class Solution:
    def canWinNim(self, n: int) -> bool:
        return n % 4 == 0",None,"class Solution:
    def canWinNim(self, n: int) -> bool:
        return n % 4 != 0
"
3096,python3,nim-game,"class Solution:
    def canWinNim(self, n: int) -> bool:
        return n % 4 == 0",None,"class Solution:
    def canWinNim(self, n: int) -> bool:
        return n % 4 != 0
"
3097,python3,minimize-maximum-pair-sum-in-array,"class Solution:
    def minPairSum(self, nums: List[int]) -> int:
        nums.sort()
        list2=[]
        right=0,len(nums)-1
        while right>0:
            list2.append(nums[right]+nums[0])
            right-=1
        return max(list2)",None,"class Solution:
    def minPairSum(self, nums: List[int]) -> int:
        nums.sort()
        list2=[]
        left=0
        right=len(nums)-1
        while left<right:
            list2.append(nums[left]+nums[right])
            left+=1
            right-=1
        return max(list2)
"
3097,python3,minimize-maximum-pair-sum-in-array,"class Solution:
    def minPairSum(self, nums: List[int]) -> int:
        nums.sort()
        list2=[]
        right=0,len(nums)-1
        while right>0:
            list2.append(nums[right]+nums[0])
            right-=1
        return max(list2)",None,"class Solution:
    def minPairSum(self, nums: List[int]) -> int:
        nums.sort()
        list2=[]
        left, right = 0, len(nums)-1
        while left < right:
            list2.append(nums[right]+nums[left])
            left+=1
            right-=1
        return max(list2)
"
3097,python3,minimize-maximum-pair-sum-in-array,"class Solution:
    def minPairSum(self, nums: List[int]) -> int:
        nums.sort()
        list2=[]
        right=0,len(nums)-1
        while right>0:
            list2.append(nums[right]+nums[0])
            right-=1
        return max(list2)",None,"class Solution:
    def minPairSum(self, nums: List[int]) -> int:
        nums.sort()
        left, right = 0, len(nums)-1
        max_sum = 0
        while left<right:
            max_sum = max(max_sum, nums[left] + nums[right])
            left += 1
            right -= 1
        return max_sum
"
3098,python3,restore-the-array,"class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:

        n = len(s)
        mod = 10**9+7

        @lru_cache(None)
        def rec(i=0):

            if i==n :
                return 1
            
            if s[i]==""0"":
                return 0
            
            res = 0
            curr = """"
            for x in range(i, n):
                curr += s[x]
                if int(curr)<=k:
                    res += (rec(x)%mod) 
                    res %= mod
                else:
                    break

            return res
        
        return rec()",None,"from functools import lru_cache

class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:

        n = len(s)
        mod = 10**9+7

        @lru_cache(None)
        def rec(i=0):

            if i==n:
                return 1
            
            if s[i]==""0"":
                return 0
            
            res = 0
            curr = """"
            for x in range(i, n):
                curr += s[x]
                if int(curr)<=k:
                    res += (rec(x+1)%mod) 
                    res %= mod
                else:
                    break

            return res
        
        return rec()
"
3098,python3,restore-the-array,"class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:

        n = len(s)
        mod = 10**9+7

        @lru_cache(None)
        def rec(i=0):

            if i==n :
                return 1
            
            if s[i]==""0"":
                return 0
            
            res = 0
            curr = """"
            for x in range(i, n):
                curr += s[x]
                if int(curr)<=k:
                    res += (rec(x)%mod) 
                    res %= mod
                else:
                    break

            return res
        
        return rec()",None,"class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:

        n = len(s)
        mod = 10**9+7

        @lru_cache(None)
        def rec(i=0):

            if i==n :
                return 1
            
            if s[i]==""0"":
                return 0
            
            res = 0
            curr = """"
            for x in range(i, n):
                curr += s[x]
                if int(curr)<=k:
                    res += (rec(x + 1)%mod) 
                    res %= mod
                else:
                    break

            return res
        
        return rec()
"
3098,python3,restore-the-array,"class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:

        n = len(s)
        mod = 10**9+7

        @lru_cache(None)
        def rec(i=0):

            if i==n :
                return 1
            
            if s[i]==""0"":
                return 0
            
            res = 0
            curr = """"
            for x in range(i, n):
                curr += s[x]
                if int(curr)<=k:
                    res += (rec(x)%mod) 
                    res %= mod
                else:
                    break

            return res
        
        return rec()",None,"class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:

        n = len(s)
        mod = 10**9+7

        @lru_cache(None)
        def rec(i=0):

            if i==n :
                return 1
            
            if s[i]==""0"":
                return 0
            
            res = 0
            curr = """"
            for x in range(i, n):
                curr += s[x]
                if int(curr)<=k:
                    res += (rec(x+1)%mod) 
                    res %= mod
                else:
                    break

            return res
        
        return rec()
"
3099,python3,minimum-flips-to-make-a-or-b-equal-to-c,"class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        if a | b == c: return 0
        c = ('0' * 32 + bin(c)[2:])[-32:]
        a = ('0' * 32 + bin(a)[2:])[-32:]
        b = ('0' * 32 + bin(b)[2:])[-32:]
        
        
        cnt = 0
        for i in range(len(c)):
            if c[i] == '0':
                if not (a[i] == c[i] or b[i] == c[i]):
                    cnt += 1
            else:
                if a[i] != c[i]:
                    cnt += 1
                if b[i] != c[i]:
                    cnt += 1
        return cnt",None,"class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        if a | b == c: return 0
        c = ('0' * 32 + bin(c)[2:])[-32:]
        a = ('0' * 32 + bin(a)[2:])[-32:]
        b = ('0' * 32 + bin(b)[2:])[-32:]

        cnt = 0
        for i in range(len(c)):
            if c[i] == '0':
                if a[i] == '1':
                    cnt += 1
                if b[i] == '1':
                    cnt += 1
            else:
                if a[i] != '1' and b[i] != '1':
                    cnt += 1                                                    
        return cnt
"
3099,python3,minimum-flips-to-make-a-or-b-equal-to-c,"class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        if a | b == c: return 0
        c = ('0' * 32 + bin(c)[2:])[-32:]
        a = ('0' * 32 + bin(a)[2:])[-32:]
        b = ('0' * 32 + bin(b)[2:])[-32:]
        
        
        cnt = 0
        for i in range(len(c)):
            if c[i] == '0':
                if not (a[i] == c[i] or b[i] == c[i]):
                    cnt += 1
            else:
                if a[i] != c[i]:
                    cnt += 1
                if b[i] != c[i]:
                    cnt += 1
        return cnt",None,"class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        a = ('0' * 32 + bin(a)[2:])[-32:]
        b = ('0' * 32 + bin(b)[2:])[-32:]
        c = ('0' * 32 + bin(c)[2:])[-32:]
        
        cnt = 0
        for i in range(len(c)):
            if c[i] == '0':
                if a[i] == '1':
                    cnt += 1
                if b[i] == '1':
                    cnt += 1
            else:
                if a[i] == '0' and b[i] == '0':
                    cnt += 1
        return cnt
"
3099,python3,minimum-flips-to-make-a-or-b-equal-to-c,"class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        if a | b == c: return 0
        c = ('0' * 32 + bin(c)[2:])[-32:]
        a = ('0' * 32 + bin(a)[2:])[-32:]
        b = ('0' * 32 + bin(b)[2:])[-32:]
        
        
        cnt = 0
        for i in range(len(c)):
            if c[i] == '0':
                if not (a[i] == c[i] or b[i] == c[i]):
                    cnt += 1
            else:
                if a[i] != c[i]:
                    cnt += 1
                if b[i] != c[i]:
                    cnt += 1
        return cnt",None,"class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        if a | b == c: return 0
        c = ('0' * 32 + bin(c)[2:])[-32:]
        a = ('0' * 32 + bin(a)[2:])[-32:]
        b = ('0' * 32 + bin(b)[2:])[-32:]
        
        
        cnt = 0
        for i in range(len(c)):
            if c[i] == '0':
                if a[i] == '1':
                    cnt += 1
                if b[i] == '1':
                    cnt += 1
            else:
                if a[i] == '0' and b[i] == '0':
                    cnt += 1
        return cnt
"
3100,python3,number-of-ways-to-split-a-string,"class Solution:
    def numWays(self, s: str) -> int:
        MOD = 10 ** 9 + 7
        N = len(s)
        c1 = s.count('1')
        if not c1:
            return (((N-1)*(N-2))//2) % MOD
        if c1 % 3:
            return 0
        idx1, idx2, idx3, idx4 = 0, 0, 0, 0
        cnt = 0
        for i in range(N):
            if s[i] == '1':
                cnt += 1
            if cnt == c1//3:
                idx1 = i
                break
        for i in range(idx1+1,N):
            if s[i] == '0':
                idx2 = i
                break
        for i in range(N-1,-1,-1):
            if s[i] == '1':
                cnt += 1
            if cnt == c1//3:
                idx4 = i
                break
        for i in range(idx4-1,-1,-1):
            if s[i] == '1':
                idx3 = i
                break
        return ((idx2-idx1) * (idx4-idx3)) % MOD",None,"class Solution:
    def numWays(self, s: str) -> int:
        MOD = 10 ** 9 + 7
        N = len(s)
        c1 = s.count('1')
        if not c1:
            return (((N-1)*(N-2))//2) % MOD
        if c1 % 3:
            return 0
        c1 //= 3
        idx1, idx2, idx3, idx4 = 0, 0, 0, 0
        cnt = 0
        for i in range(N):
            if s[i] == '1':
                cnt += 1
            if cnt == c1:
                idx1 = i
                break
        for i in range(idx1+1,N):
            if s[i] == '0':
                idx2 = i
                break
        cnt = 0
        for i in range(N-1,-1,-1):
            if s[i] == '1':
                cnt += 1
            if cnt == c1:
                idx4 = i
                break
        for i in range(idx4-1,-1,-1):
            if s[i] == '0':
                idx3 = i
                break
        return ((idx2-idx1+1) * (idx4-idx3+1)) % MOD
"
3100,python3,number-of-ways-to-split-a-string,"class Solution:
    def numWays(self, s: str) -> int:
        MOD = 10 ** 9 + 7
        N = len(s)
        c1 = s.count('1')
        if not c1:
            return (((N-1)*(N-2))//2) % MOD
        if c1 % 3:
            return 0
        idx1, idx2, idx3, idx4 = 0, 0, 0, 0
        cnt = 0
        for i in range(N):
            if s[i] == '1':
                cnt += 1
            if cnt == c1//3:
                idx1 = i
                break
        for i in range(idx1+1,N):
            if s[i] == '0':
                idx2 = i
                break
        for i in range(N-1,-1,-1):
            if s[i] == '1':
                cnt += 1
            if cnt == c1//3:
                idx4 = i
                break
        for i in range(idx4-1,-1,-1):
            if s[i] == '1':
                idx3 = i
                break
        return ((idx2-idx1) * (idx4-idx3)) % MOD",None,"class Solution:
    def numWays(self, s: str) -> int:
        MOD = 10 ** 9 + 7
        N = len(s)
        c1 = s.count('1')
        if not c1:
            return (((N-1)*(N-2))//2) % MOD
        if c1 % 3:
            return 0
        cnt = 0
        c1 //= 3
        idx1, idx2, idx3, idx4 = 0, 0, 0, 0
        for i in range(N):
            if s[i] == '1':
                cnt += 1
            if cnt == c1:
                idx1 = i
                break
        for i in range(idx1+1,N):
            if s[i] == '0':
                idx2 = i
                break
        cnt = 0
        for i in range(N-1,-1,-1):
            if s[i] == '1':
                cnt += 1
            if cnt == c1:
                idx4 = i
                break
        for i in range(idx4-1,-1,-1):
            if s[i] == '0':
                idx3 = i
                break
        return ((idx2-idx1+1) * (idx4-idx3+1)) % MOD
"
3100,python3,number-of-ways-to-split-a-string,"class Solution:
    def numWays(self, s: str) -> int:
        MOD = 10 ** 9 + 7
        N = len(s)
        c1 = s.count('1')
        if not c1:
            return (((N-1)*(N-2))//2) % MOD
        if c1 % 3:
            return 0
        idx1, idx2, idx3, idx4 = 0, 0, 0, 0
        cnt = 0
        for i in range(N):
            if s[i] == '1':
                cnt += 1
            if cnt == c1//3:
                idx1 = i
                break
        for i in range(idx1+1,N):
            if s[i] == '0':
                idx2 = i
                break
        for i in range(N-1,-1,-1):
            if s[i] == '1':
                cnt += 1
            if cnt == c1//3:
                idx4 = i
                break
        for i in range(idx4-1,-1,-1):
            if s[i] == '1':
                idx3 = i
                break
        return ((idx2-idx1) * (idx4-idx3)) % MOD",None,"class Solution:
    def numWays(self, s: str) -> int:
        MOD = 10 ** 9 + 7
        N = len(s)
        c1 = s.count('1')
        if not c1:
            return (((N-1)*(N-2))//2) % MOD
        if c1 % 3:
            return 0
        idx1, idx2, idx3, idx4 = 0, 0, 0, 0
        cnt = 0
        for i in range(N):
            if s[i] == '1':
                cnt += 1
            if cnt == c1//3:
                idx1 = i
                break
        for i in range(idx1+1,N):
            if s[i] == '1':
                idx2 = i
                break
        cnt = 0
        for i in range(N-1,-1,-1):
            if s[i] == '1':
                cnt += 1
            if cnt == c1//3:
                idx4 = i
                break
        for i in range(idx4-1,-1,-1):
            if s[i] == '1':
                idx3 = i
                break
        return ((idx2-idx1) * (idx4-idx3)) % MOD
"
3101,python3,sequential-digits,"class Solution:
    def sequentialDigits(self, low, high):
        out = []
        queue = deque(range(1,10))
        while queue:
            elem = queue.popleft()
            if low <= elem <= high:
                out.append(elem)
            last = elem % 10
            if last > 9: queue.append(elem*10 + last + 1)
                    
        return out",None,"class Solution:
    def sequentialDigits(self, low, high):
        out = []
        queue = deque(range(1,10))
        while queue:
            elem = queue.popleft()
            if low <= elem <= high:
                out.append(elem)
            last = elem % 10
            if last < 9: queue.append(elem*10 + last + 1)
                    
        return out
"
3101,python3,sequential-digits,"class Solution:
    def sequentialDigits(self, low, high):
        out = []
        queue = deque(range(1,10))
        while queue:
            elem = queue.popleft()
            if low <= elem <= high:
                out.append(elem)
            last = elem % 10
            if last > 9: queue.append(elem*10 + last + 1)
                    
        return out",None,"class Solution:
    def sequentialDigits(self, low, high):
        out = []
        queue = deque(range(1,10))
        while queue:
            elem = queue.popleft()
            if low <= elem <= high:
                out.append(elem)
            last = elem % 10
            if last < 9: queue.append(elem*10 + last + 1)
                    
        return out
"
3101,python3,sequential-digits,"class Solution:
    def sequentialDigits(self, low, high):
        out = []
        queue = deque(range(1,10))
        while queue:
            elem = queue.popleft()
            if low <= elem <= high:
                out.append(elem)
            last = elem % 10
            if last > 9: queue.append(elem*10 + last + 1)
                    
        return out",None,"class Solution:
    def sequentialDigits(self, low, high):
        out = []
        queue = deque(range(1,10))
        while queue:
            elem = queue.popleft()
            if low <= elem <= high:
                out.append(elem)
            last = elem % 10
            if last < 9: queue.append(elem*10 + last + 1)
                    
        return out
"
3102,python3,construct-quad-tree,"class Solution:
    def construct(self, grid: List[List[int]]) -> 'Node':
        level = len(grid)
        root = None
        if level >= 1:
            root = self.buildTree(grid, 0, level, 0, level, level)
        return root
        
        
    def buildTree(self, grid, rs, re, cs, ce, level):
        if level == 1:
            return Node(grid[rs][cs], True, None, None, None, None)
        
        next_level = level // 2
        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)
        tr = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)
        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)
        br = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)
        
        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:
            if tl.val == tr.val == bl.val == br.val:
                new_node = Node(tl.val, True, None, None, None, None)
            else:
                new_node = Node(tl.val, False, tl, tr, bl, br)
            else:
                new_node = Node(tl.val, False, tl, tr, bl, br)
            
        return new_node",None,"class Solution:
    def construct(self, grid: List[List[int]]) -> 'Node':
        size = len(grid)
        root = None
        if size >= 1:
            root = self.buildTree(grid, 0, size, 0, size)
        return root
        
    def buildTree(self, grid, rs, re, cs, ce):
        isLeaf = True
        for i in range(rs, re):
            for j in range(cs, ce):
                if grid[i][j] != grid[rs][cs]:
                    isLeaf = False
        if isLeaf:
            return Node(grid[rs][cs] == 1, True, None, None, None, None)
 
        midRow, midCol = (rs + re) // 2, (cs + ce) // 2
        topLeft = self.buildTree(grid, rs, midRow, cs, midCol)
        topRight = self.buildTree(grid, rs, midRow, midCol, ce)
        bottomLeft = self.buildTree(grid, midRow, re, cs, midCol)
        bottomRight = self.buildTree(grid, midRow, re, midCol, ce)
        return Node(True, False, topLeft, topRight, bottomLeft, bottomRight)
"
3102,python3,construct-quad-tree,"class Solution:
    def construct(self, grid: List[List[int]]) -> 'Node':
        level = len(grid)
        root = None
        if level >= 1:
            root = self.buildTree(grid, 0, level, 0, level, level)
        return root
        
        
    def buildTree(self, grid, rs, re, cs, ce, level):
        if level == 1:
            return Node(grid[rs][cs], True, None, None, None, None)
        
        next_level = level // 2
        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)
        tr = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)
        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)
        br = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)
        
        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:
            if tl.val == tr.val == bl.val == br.val:
                new_node = Node(tl.val, True, None, None, None, None)
            else:
                new_node = Node(tl.val, False, tl, tr, bl, br)
            else:
                new_node = Node(tl.val, False, tl, tr, bl, br)
            
        return new_node",None,"class Solution:
    def construct(self, grid: List[List[int]]) -> 'Node':
        level = len(grid)
        root = None
        if level >= 1:
            root = self.buildTree(grid, 0, level, 0, level, level)
        return root
        
        
    def buildTree(self, grid, rs, re, cs, ce, level):
        if level == 1:
            return Node(grid[rs][cs], True, None, None, None, None)
        
        next_level = level // 2
        tl = self.buildTree(grid, rs, rs + next_level, cs, cs + next_level, next_level)
        tr = self.buildTree(grid, rs, rs + next_level, cs + next_level, ce, next_level)
        bl = self.buildTree(grid, rs + next_level, re, cs, cs + next_level, next_level)
        br = self.buildTree(grid, rs + next_level, re, cs + next_level, ce, next_level)
        
        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val == bl.val == br.val:
            return Node(tl.val, True, None, None, None, None)
        else:
            return Node(False, False, tl, tr, bl, br)
"
3102,python3,construct-quad-tree,"class Solution:
    def construct(self, grid: List[List[int]]) -> 'Node':
        level = len(grid)
        root = None
        if level >= 1:
            root = self.buildTree(grid, 0, level, 0, level, level)
        return root
        
        
    def buildTree(self, grid, rs, re, cs, ce, level):
        if level == 1:
            return Node(grid[rs][cs], True, None, None, None, None)
        
        next_level = level // 2
        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)
        tr = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)
        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)
        br = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)
        
        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:
            if tl.val == tr.val == bl.val == br.val:
                new_node = Node(tl.val, True, None, None, None, None)
            else:
                new_node = Node(tl.val, False, tl, tr, bl, br)
            else:
                new_node = Node(tl.val, False, tl, tr, bl, br)
            
        return new_node",None,"class Solution:
    def construct(self, grid: List[List[int]]) -> 'Node':
        level = len(grid)
        root = None
        if level >= 1:
            root = self.buildTree(grid, 0, level, 0, level, level)
        return root
        
        
    def buildTree(self, grid, rs, re, cs, ce, level):
        if level == 1:
            return Node(grid[rs][cs], True, None, None, None, None)
        
        next_level = level // 2
        tl = self.buildTree(grid, rs, rs + next_level, cs, cs + next_level, next_level)
        tr = self.buildTree(grid, rs, rs + next_level, cs + next_level, ce, next_level)
        bl = self.buildTree(grid, rs + next_level, re, cs, cs + next_level, next_level)
        br = self.buildTree(grid, rs + next_level, re, cs + next_level, ce, next_level)
        
        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:
            if tl.val == tr.val == bl.val == br.val:
                return Node(tl.val, True, None, None, None, None)
            else:
                return Node(True, False, tl, tr, bl, br)
        else:
            return Node(True, False, tl, tr, bl, br)
"
3103,python3,remove-duplicates-from-sorted-array-ii,"from collections import Counter

class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        counter = Counter(nums)
        index = 0

        for num, count in counter.items():
            nums[index] = num
            index += 1
            if count > 2:
                nums[index] = num
                index += 1

        return index",None,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        index = 0

        for num in nums:
            if index < 2 or num != nums[index - 2]:
                nums[index] = num
                index += 1

        return index
"
3103,python3,remove-duplicates-from-sorted-array-ii,"from collections import Counter

class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        counter = Counter(nums)
        index = 0

        for num, count in counter.items():
            nums[index] = num
            index += 1
            if count > 2:
                nums[index] = num
                index += 1

        return index",None,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        index = 0
        for num in nums:
            if index < 2 or num != nums[index - 2]:
                nums[index] = num
                index += 1
        return index
"
3103,python3,remove-duplicates-from-sorted-array-ii,"from collections import Counter

class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        counter = Counter(nums)
        index = 0

        for num, count in counter.items():
            nums[index] = num
            index += 1
            if count > 2:
                nums[index] = num
                index += 1

        return index",None,"class Solution:
    def removeDuplicates(self, nums):
        count = 0
        for i in range(2, len(nums)):
            if nums[i] != nums[count]:
                count += 1
                nums[count + 1] = nums[i]
        return count + 2 if count + 2 <= len(nums) else len(nums)
"
3104,python3,remove-linked-list-elements,"class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        result = ListNode(0)
        result.next = head
        cur = result
        while cur.next:
            if cur.next.val == val:
                cur.next = cur.next.next
            cur = cur.next
        return result.next",None,"class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        result = ListNode(0)
        result.next = head
        cur = result
        while cur and cur.next:
            if cur.next.val == val:
                cur.next = cur.next.next
            else:
                cur = cur.next
        return result.next
"
3104,python3,remove-linked-list-elements,"class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        result = ListNode(0)
        result.next = head
        cur = result
        while cur.next:
            if cur.next.val == val:
                cur.next = cur.next.next
            cur = cur.next
        return result.next",None,"class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        result = ListNode(0)
        result.next = head
        cur = result
        while cur.next:
            if cur.next.val == val:
                cur.next = cur.next.next
            else:
                cur = cur.next
        return result.next
"
3104,python3,remove-linked-list-elements,"class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        result = ListNode(0)
        result.next = head
        cur = result
        while cur.next:
            if cur.next.val == val:
                cur.next = cur.next.next
            cur = cur.next
        return result.next",None,"class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        result = ListNode(0)
        result.next = head
        cur = result
        while cur.next:
            if cur.next.val == val:
                cur.next = cur.next.next
            else:
                cur = cur.next
        return result.next
"
3105,python3,delete-operation-for-two-strings,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m=len(word1)
        n=len(word2)
        dp=[]
        for i in range (m+1):
            dp.append([0]*(n+1))
        for i in range (m+1):
            dp[i][0]=i
        for i in range (n+1):
            dp[0][i]=i
        for i in range (1,m+1):
            for j in range (1,n+1):
                if word1[i]==word2[j]:
                    dp[i][j]=dp[i-1][j-1]
                else:
                    dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1
        return dp[-1][-1]",None,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m=len(word1)
        n=len(word2)
        dp=[]
        for i in range (m+1):
            dp.append([0]*(n+1))
        for i in range (m+1):
            dp[i][0]=i
        for i in range (n+1):
            dp[0][i]=i
        for i in range (1,m+1):
            for j in range (1,n+1):
                if word1[i-1]==word2[j-1]:  # indices should be one less index
                    dp[i][j]=dp[i-1][j-1]
                else:
                    dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1
        return dp[-1][-1]
"
3105,python3,delete-operation-for-two-strings,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m=len(word1)
        n=len(word2)
        dp=[]
        for i in range (m+1):
            dp.append([0]*(n+1))
        for i in range (m+1):
            dp[i][0]=i
        for i in range (n+1):
            dp[0][i]=i
        for i in range (1,m+1):
            for j in range (1,n+1):
                if word1[i]==word2[j]:
                    dp[i][j]=dp[i-1][j-1]
                else:
                    dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1
        return dp[-1][-1]",None,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m=len(word1)
        n=len(word2)
        dp=[]
        for i in range (m+1):
            dp.append([0]*(n+1))
        for i in range (m+1):
            dp[i][0]=i
        for i in range (n+1):
            dp[0][i]=i
        for i in range (1,m+1):
            for j in range (1,n+1):
                if word1[i-1]==word2[j-1]:
                    dp[i][j]=dp[i-1][j-1]
                else:
                    dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1
        return dp[-1][-1]
"
3105,python3,delete-operation-for-two-strings,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m=len(word1)
        n=len(word2)
        dp=[]
        for i in range (m+1):
            dp.append([0]*(n+1))
        for i in range (m+1):
            dp[i][0]=i
        for i in range (n+1):
            dp[0][i]=i
        for i in range (1,m+1):
            for j in range (1,n+1):
                if word1[i]==word2[j]:
                    dp[i][j]=dp[i-1][j-1]
                else:
                    dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1
        return dp[-1][-1]",None,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m=len(word1)
        n=len(word2)
        dp=[]
        for i in range (m+1):
            dp.append([0]*(n+1))
        for i in range (m+1):
            dp[i][0]=i
        for i in range (n+1):
            dp[0][i]=i
        for i in range (1,m+1):
            for j in range (1,n+1):
                if word1[i-1]==word2[j-1]:
                    dp[i][j]=dp[i-1][j-1]
                else:
                    dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1
        return dp[-1][-1]
"
3106,python3,third-maximum-number,"class Solution:
    def thirdMax(self, nums: List[int]) -> int:
        return max(list(set(nums))) if len(list(set(nums)))>3 else sorted(list(set(nums)))[-3]",None,"class Solution:
    def thirdMax(self, nums: List[int]) -> int:
        distinct_nums = list(set(nums))
        if len(distinct_nums)<3:
            return max(distinct_nums)
        else:
            distinct_nums.sort()
            return distinct_nums[-3]
"
3106,python3,third-maximum-number,"class Solution:
    def thirdMax(self, nums: List[int]) -> int:
        return max(list(set(nums))) if len(list(set(nums)))>3 else sorted(list(set(nums)))[-3]",None,"class Solution:
    def thirdMax(self, nums: List[int]) -> int:
        nums = list(set(nums))
        if len(nums) < 3:
            return max(nums)
        nums.remove(max(nums))
        nums.remove(max(nums))
        return max(nums)
"
3106,python3,third-maximum-number,"class Solution:
    def thirdMax(self, nums: List[int]) -> int:
        return max(list(set(nums))) if len(list(set(nums)))>3 else sorted(list(set(nums)))[-3]",None,"class Solution:
    def thirdMax(self, nums: List[int]) -> int:
        distinct_nums = list(set(nums))
        if len(distinct_nums) < 3:
            return max(distinct_nums)
        else:
            distinct_nums.sort()
            return distinct_nums[-3]
"
3107,python3,verifying-an-alien-dictionary,"class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        mapper = {chr(i):-1 for i in range(97,97+26)}
        def map_value():
            nonlocal order
            nonlocal mapper
            for i in range(len(order)):
                mapper[order[i]] = i
        map_value()
        def helper():
            for i in range(len(words)-1):
                if len(words[i+1])<len(words[i]) and mapper[words[i+1][0]] <= mapper[words[i][0]] and words[i+1] not in words[i]:
                    return False
                else:
                    for j in range(min(len(words[i]), len(words[i+1]))):
                        if words[i][j] != words[i+1][j]:
                            if mapper[words[i+1][j]] < mapper[words[i][j]]:
                                return False
                            break
            return True
        return helper()",None,"class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        mapper = {}
        def map_value():
            nonlocal order
            nonlocal mapper
            for i in range(len(order)):
                mapper[order[i]] = i
        map_value()
        def helper():
            for i in range(len(words)-1):
                for j in range(min(len(words[i]), len(words[i+1]))):
                    if words[i][j] != words[i+1][j]:
                        if mapper[words[i][j]] > mapper[words[i+1][j]]:
                            return False
                        break
                    elif j == len(words[i+1]) - 1 and len(words[i]) > len(words[i+1]):
                        return False
            return True
        return helper()
"
3107,python3,verifying-an-alien-dictionary,"class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        mapper = {chr(i):-1 for i in range(97,97+26)}
        def map_value():
            nonlocal order
            nonlocal mapper
            for i in range(len(order)):
                mapper[order[i]] = i
        map_value()
        def helper():
            for i in range(len(words)-1):
                if len(words[i+1])<len(words[i]) and mapper[words[i+1][0]] <= mapper[words[i][0]] and words[i+1] not in words[i]:
                    return False
                else:
                    for j in range(min(len(words[i]), len(words[i+1]))):
                        if words[i][j] != words[i+1][j]:
                            if mapper[words[i+1][j]] < mapper[words[i][j]]:
                                return False
                            break
            return True
        return helper()",None,"class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        
        order_index = {char: i for i, char in enumerate(order)}
        
        for i in range(len(words) - 1):
            word1 = words[i]
            word2 = words[i+1]
            
            for j in range(min(len(word1), len(word2))):
                if word1[j] != word2[j]:
                    if order_index[word1[j]] > order_index[word2[j]]:
                        return False
                    break
                else:
                    if len(word1) > len(word2):
                        return False
                    
        return True
"
3107,python3,verifying-an-alien-dictionary,"class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        mapper = {chr(i):-1 for i in range(97,97+26)}
        def map_value():
            nonlocal order
            nonlocal mapper
            for i in range(len(order)):
                mapper[order[i]] = i
        map_value()
        def helper():
            for i in range(len(words)-1):
                if len(words[i+1])<len(words[i]) and mapper[words[i+1][0]] <= mapper[words[i][0]] and words[i+1] not in words[i]:
                    return False
                else:
                    for j in range(min(len(words[i]), len(words[i+1]))):
                        if words[i][j] != words[i+1][j]:
                            if mapper[words[i+1][j]] < mapper[words[i][j]]:
                                return False
                            break
            return True
        return helper()",None,"class Solution:
    def isAlienSorted(self, words, order):
        order_index = {char: i for i, char in enumerate(order)}

        for i in range(len(words) - 1):
            word1 = words[i]
            word2 = words[i+1]

            for k in range(min(len(word1), len(word2))):
                if word1[k] != word2[k]:
                    if order_index[word1[k]] > order_index[word2[k]]:
                        return False
                    break
            else:
                if len(word1) > len(word2):
                    return False

        return True
"
3108,python3,pascals-triangle,"class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows == 0:
            return [[1]]
        prev = self.generate(numRows - 1)
        fin = prev[-1]
        now = [1]
        for i in range(len(fin)-1):
            now.append(fin[i] + fin[i+1])
        now.append(1)
        prev.append(now)
        return prev",None,"class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows == 0:
            return []
        elif numRows == 1:
            return [[1]]
        prev = self.generate(numRows - 1)
        fin = prev[-1]
        now = [1]
        for i in range(len(fin)-1):
            now.append(fin[i] + fin[i+1])
        now.append(1)
        prev.append(now)
        return prev
"
3108,python3,pascals-triangle,"class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows == 0:
            return [[1]]
        prev = self.generate(numRows - 1)
        fin = prev[-1]
        now = [1]
        for i in range(len(fin)-1):
            now.append(fin[i] + fin[i+1])
        now.append(1)
        prev.append(now)
        return prev",None,"class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows == 1:
            return [[1]]
        prev = self.generate(numRows - 1)
        fin = prev[-1]
        now = [1]
        for i in range(len(fin)-1):
            now.append(fin[i] + fin[i+1])
        now.append(1)
        prev.append(now)
        return prev
"
3108,python3,pascals-triangle,"class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows == 0:
            return [[1]]
        prev = self.generate(numRows - 1)
        fin = prev[-1]
        now = [1]
        for i in range(len(fin)-1):
            now.append(fin[i] + fin[i+1])
        now.append(1)
        prev.append(now)
        return prev",None,"class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows == 1:
            return [[1]]
        prev = self.generate(numRows - 1)
        fin = prev[-1]
        now = [1]
        for i in range(len(fin)-1):
            now.append(fin[i] + fin[i+1])
        now.append(1)
        prev.append(now)
        return prev
"
3109,python3,split-linked-list-in-parts,"class Solution:
    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:

    
        l = []
        length = 0
        ptr = head
        while(ptr) :
            length += 1
            ptr = ptr.next

        arrange = []
        maxi = length//k 
        remain = length%k

        for i in range(k) :
            if remain :
                arrange.append(maxi + 1)
                remain -= 1
            else:
                arrange.append(maxi)

        j = 0
        ptr = head 
        i = 0
        while(ptr) :
            q = ptr 
            i += 1
            ptr = ptr.next 
            if i == arrange[j] :
                q.next = None
                l.append(head)
                head = ptr 
                i = 0
                j += 1

        for i in range(j,k+1):
            l.append(None)
        return l",None,"class Solution:
    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:
        l = []
        length = 0
        ptr = head
        while(ptr) :
            length += 1
            ptr = ptr.next

        arrange = []
        maxi = length//k 
        remain = length%k

        for i in range(k) :
            if remain :
                arrange.append(maxi + 1)
                remain -= 1
            else:
                arrange.append(maxi)

        j = 0
        ptr = head 
        i = 0
        while(ptr) :
            q = ptr 
            i += 1
            ptr = ptr.next 
            if i == arrange[j] :
                q.next = None
                l.append(head)
                head = ptr 
                i = 0
                j += 1

        for i in range(j,k):
            l.append(None)
        return l
"
3109,python3,split-linked-list-in-parts,"class Solution:
    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:

    
        l = []
        length = 0
        ptr = head
        while(ptr) :
            length += 1
            ptr = ptr.next

        arrange = []
        maxi = length//k 
        remain = length%k

        for i in range(k) :
            if remain :
                arrange.append(maxi + 1)
                remain -= 1
            else:
                arrange.append(maxi)

        j = 0
        ptr = head 
        i = 0
        while(ptr) :
            q = ptr 
            i += 1
            ptr = ptr.next 
            if i == arrange[j] :
                q.next = None
                l.append(head)
                head = ptr 
                i = 0
                j += 1

        for i in range(j,k+1):
            l.append(None)
        return l",None,"class Solution:
    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:
        l = []
        length = 0
        ptr = head
        while(ptr) :
            length += 1
            ptr = ptr.next

        arrange = []
        maxi = length//k 
        remain = length%k

        for i in range(k) :
            if remain :
                arrange.append(maxi + 1)
                remain -= 1
            else:
                arrange.append(maxi)

        j = 0
        ptr = head 
        i = 0
        while(ptr) :
            q = ptr 
            i += 1
            ptr = ptr.next 
            if i == arrange[j] :
                q.next = None
                l.append(head)
                head = ptr 
                i = 0
                j += 1

        while j < k :
            l.append(None)
            j += 1

        return l
"
3109,python3,split-linked-list-in-parts,"class Solution:
    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:

    
        l = []
        length = 0
        ptr = head
        while(ptr) :
            length += 1
            ptr = ptr.next

        arrange = []
        maxi = length//k 
        remain = length%k

        for i in range(k) :
            if remain :
                arrange.append(maxi + 1)
                remain -= 1
            else:
                arrange.append(maxi)

        j = 0
        ptr = head 
        i = 0
        while(ptr) :
            q = ptr 
            i += 1
            ptr = ptr.next 
            if i == arrange[j] :
                q.next = None
                l.append(head)
                head = ptr 
                i = 0
                j += 1

        for i in range(j,k+1):
            l.append(None)
        return l",None,"class Solution:
    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:
        l = []
        length = 0
        ptr = head
        while(ptr) :
            length += 1
            ptr = ptr.next

        arrange = []
        maxi = length//k 
        remain = length%k

        for i in range(k) :
            if remain :
                arrange.append(maxi + 1)
                remain -= 1
            else:
                arrange.append(maxi)
    
        ptr = head 
        for j in range(k) :
            if ptr:
                q = ptr
                for i in range(arrange[j] - 1):
                    if ptr:
                        ptr = ptr.next
                if ptr:
                    temp = ptr
                    ptr = ptr.next
                    temp.next = None
                l.append(q)
            else:
                 l.append(None)
        return l
"
3110,python3,check-if-one-string-swap-can-make-strings-equal,"class Solution:
    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        if len(s1)!=len(s2):
            return False
        if s1==s2:
            return True
        diff=[]
        for i in range(len(s1)):
            if s1[i]!=s2[i]:
                diff.append([s1[i],s2[i]])
        if len(diff)==1 and diff[0]==diff[-1][::-1]:
            return True
        else:
            return False",None,"class Solution:
    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        if len(s1)!=len(s2):
            return False
        if s1==s2:
            return True
        diff=[]
        for i in range(len(s1)):
            if s1[i]!=s2[i]:
                diff.append([s1[i],s2[i]])
        if len(diff)==2 and diff[0]==diff[1][::-1]:
            return True
        else:
            return False
"
3110,python3,check-if-one-string-swap-can-make-strings-equal,"class Solution:
    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        if len(s1)!=len(s2):
            return False
        if s1==s2:
            return True
        diff=[]
        for i in range(len(s1)):
            if s1[i]!=s2[i]:
                diff.append([s1[i],s2[i]])
        if len(diff)==1 and diff[0]==diff[-1][::-1]:
            return True
        else:
            return False",None,"class Solution:
    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        if len(s1)!=len(s2):
            return False
        if s1==s2:
            return True
        diff=[]
        for i in range(len(s1)):
            if s1[i]!=s2[i]:
                diff.append([s1[i],s2[i]])
        if len(diff)==2 and diff[0]==diff[-1][::-1]:
            return True
        else:
            return False
"
3110,python3,check-if-one-string-swap-can-make-strings-equal,"class Solution:
    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        if len(s1)!=len(s2):
            return False
        if s1==s2:
            return True
        diff=[]
        for i in range(len(s1)):
            if s1[i]!=s2[i]:
                diff.append([s1[i],s2[i]])
        if len(diff)==1 and diff[0]==diff[-1][::-1]:
            return True
        else:
            return False",None,"class Solution:
    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        if len(s1)!=len(s2):
            return False
        if s1==s2:
            return True
        diff=[]
        for i in range(len(s1)):
            if s1[i]!=s2[i]:
                diff.append([s1[i],s2[i]])
        if len(diff)==2 and diff[0]==diff[-1][::-1]:
            return True
        else:
            return False
"
3111,python3,disconnect-path-in-a-binary-matrix-by-at-most-one-flip,"class Solution:
    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])
        dirs = [(-1, 0), (0, -1)]
        def dfs(i: int, j: int) -> None:
            grid[i][j] = 2
            for di, dj in dirs:
                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)
        
        dfs(m - 1, n - 1)
    
        dq = collections.deque([(0, 0)])
        grid[0][0] = 0
        dirs = [(1, 0), (0, 1)]
        while dq:
            l = len(dq)
            for _ in range(l):
                i, j = dq.popleft()
                if i == m - 1 and j == n - 1: return True
                for di, dj in dirs:
                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: 
                        dq.append((i + di, j + dj))
                        grid[i + di][j + dj] = 0


            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return False

        return False",None,"class Solution:
    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])
        dirs = [(-1, 0), (0, -1), (1, 0), (0, 1)]
        visited = [[False]*n for _ in range(m)]
        
        def dfs(i: int, j: int) -> None:
            visited[i][j] = True
            for di, dj in dirs:
                ni, nj = i+di, j+dj
                if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == 1 and not visited[ni][nj]: 
                    dfs(ni, nj)
        
        dfs(0, 0)
    
        if not visited[m-1][n-1]: return True
        
        for i in range(m):
            for j in range(n):
                if (i == 0 and j == 0) or (i == m-1 and j == n-1): continue
                if grid[i][j] == 1 and visited[i][j]:
                    grid[i][j] = 0
                    visited = [[False]*n for _ in range(m)]
                    dfs(0, 0)
                    if not visited[m-1][n-1]: return True
                    grid[i][j] = 1
                    
        return False
"
3111,python3,disconnect-path-in-a-binary-matrix-by-at-most-one-flip,"class Solution:
    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])
        dirs = [(-1, 0), (0, -1)]
        def dfs(i: int, j: int) -> None:
            grid[i][j] = 2
            for di, dj in dirs:
                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)
        
        dfs(m - 1, n - 1)
    
        dq = collections.deque([(0, 0)])
        grid[0][0] = 0
        dirs = [(1, 0), (0, 1)]
        while dq:
            l = len(dq)
            for _ in range(l):
                i, j = dq.popleft()
                if i == m - 1 and j == n - 1: return True
                for di, dj in dirs:
                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: 
                        dq.append((i + di, j + dj))
                        grid[i + di][j + dj] = 0


            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return False

        return False",None,"class Solution:
    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])
        dirs = [(0,1), (1,0)]
        def dfs(i: int, j: int) -> None:
            grid[i][j] = 2
            for di, dj in dirs:
                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)

        dfs(0, 0)
        
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 2:
                    store, grid[i][j] = grid[i][j], 0
                    if not self.reachable(grid): return True
                    grid[i][j] = store
                    
        return False
                
    def reachable(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])
        visited = [[0]*n for _ in range(m)]
        que = [(0,0)]
        visited[0][0] = 1
        while que:
            x, y = que.pop(0)
            for dx, dy in [(-1,0), (1,0), (0,-1), (0,1)]:
                nx, ny = x+dx, y+dy
                if nx>=0 and nx<m and ny>=0 and ny<n and not visited[nx][ny] and grid[nx][ny]:
                    if nx == m-1 and ny == n-1: return True
                    visited[nx][ny] = 1
                    que.append((nx,ny))
        return False
"
3111,python3,disconnect-path-in-a-binary-matrix-by-at-most-one-flip,"class Solution:
    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])
        dirs = [(-1, 0), (0, -1)]
        def dfs(i: int, j: int) -> None:
            grid[i][j] = 2
            for di, dj in dirs:
                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)
        
        dfs(m - 1, n - 1)
    
        dq = collections.deque([(0, 0)])
        grid[0][0] = 0
        dirs = [(1, 0), (0, 1)]
        while dq:
            l = len(dq)
            for _ in range(l):
                i, j = dq.popleft()
                if i == m - 1 and j == n - 1: return True
                for di, dj in dirs:
                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: 
                        dq.append((i + di, j + dj))
                        grid[i + di][j + dj] = 0


            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return False

        return False",None,"class Solution:
    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])
        dirs = [(-1, 0), (0, -1)]
        def dfs(i: int, j: int) -> None:
            grid[i][j] = 2
            for di, dj in dirs:
                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)
        
        dfs(m - 1, n - 1)
    
        dq = collections.deque([(0, 0)])
        grid[0][0] = 0
        dirs = [(1, 0), (0, 1)]
        while dq:
            l = len(dq)
            for _ in range(l):
                i, j = dq.popleft()
                if i == m - 1 and j == n - 1 and len(dq) == 0: return True
                for di, dj in dirs:
                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: 
                        dq.append((i + di, j + dj))
                        grid[i + di][j + dj] = 0

            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True

        return False
"
3112,python3,find-bottom-left-tree-value,"class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        depth = 0
        stack = collections.deque([(root)])
        d = {}
        a = 0
        while stack:
            lvl = []
            for i in range(len(stack)):
                n = stack.popleft()
                lvl.append(n.val)
                if n.left: stack.append(n.left)
                if n.right: stack.append(n.right)
            return lvl[0]",None,"class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        depth = 0
        stack = collections.deque([(root)])
        d = {}
        a = 0
        left_most_val = None
        while stack:
            lvl = []
            for i in range(len(stack)):
                n = stack.popleft()
                lvl.append(n.val)
                if n.left: stack.append(n.left)
                if n.right: stack.append(n.right)
            left_most_val = lvl[0]
        return left_most_val
"
3112,python3,find-bottom-left-tree-value,"class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        depth = 0
        stack = collections.deque([(root)])
        d = {}
        a = 0
        while stack:
            lvl = []
            for i in range(len(stack)):
                n = stack.popleft()
                lvl.append(n.val)
                if n.left: stack.append(n.left)
                if n.right: stack.append(n.right)
            return lvl[0]",None,"class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        stack = collections.deque([(root)])
        while stack:
            lvl = []
            for i in range(len(stack)):
                n = stack.popleft()
                lvl.append(n.val)
                if n.left: stack.append(n.left)
                if n.right: stack.append(n.right)
        return lvl[0]
"
3112,python3,find-bottom-left-tree-value,"class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        depth = 0
        stack = collections.deque([(root)])
        d = {}
        a = 0
        while stack:
            lvl = []
            for i in range(len(stack)):
                n = stack.popleft()
                lvl.append(n.val)
                if n.left: stack.append(n.left)
                if n.right: stack.append(n.right)
            return lvl[0]",None,"class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        stack = collections.deque([(root)])
        while stack:
            lvl = []
            for i in range(len(stack)):
                n = stack.popleft()
                lvl.append(n.val)
                if n.left: stack.append(n.left)
                if n.right: stack.append(n.right)
        return lvl[0]
"
3113,python3,increasing-order-search-tree,"class Solution:
    def increasingBST(self, root: TreeNode) -> TreeNode:
        newRoot = TreeNode(0)
        self.temp = newRoot
        def inorder(root):
            if root is None: return None
            inorder(root.left)
            new = TreeNode(root.val)
            self.temp.right = new
            self.temp = self.temp.left
            inorder(root.right)
        inorder(root)
        return newRoot.right",None,"class Solution:
    def increasingBST(self, root: TreeNode) -> TreeNode:
        newRoot = TreeNode(0)
        self.temp = newRoot
        def inorder(root):
            if root is None: return None
            inorder(root.left)
            new = TreeNode(root.val)
            self.temp.right = new
            self.temp = self.temp.right
            inorder(root.right)
        inorder(root)
        return newRoot.right
"
3113,python3,increasing-order-search-tree,"class Solution:
    def increasingBST(self, root: TreeNode) -> TreeNode:
        newRoot = TreeNode(0)
        self.temp = newRoot
        def inorder(root):
            if root is None: return None
            inorder(root.left)
            new = TreeNode(root.val)
            self.temp.right = new
            self.temp = self.temp.left
            inorder(root.right)
        inorder(root)
        return newRoot.right",None,"class Solution:
    def increasingBST(self, root: TreeNode) -> TreeNode:
        newRoot = TreeNode(0)
        self.temp = newRoot
        def inorder(root):
            if root is None: return None
            inorder(root.left)
            new = TreeNode(root.val)
            self.temp.right = new
            self.temp = self.temp.right
            inorder(root.right)
        inorder(root)
        return newRoot.right
"
3113,python3,increasing-order-search-tree,"class Solution:
    def increasingBST(self, root: TreeNode) -> TreeNode:
        newRoot = TreeNode(0)
        self.temp = newRoot
        def inorder(root):
            if root is None: return None
            inorder(root.left)
            new = TreeNode(root.val)
            self.temp.right = new
            self.temp = self.temp.left
            inorder(root.right)
        inorder(root)
        return newRoot.right",None,"class Solution:
    def increasingBST(self, root: TreeNode) -> TreeNode:
        newRoot = TreeNode(0)
        self.temp = newRoot
        def inorder(root):
            if root is None: return None
            inorder(root.left)
            new = TreeNode(root.val)
            self.temp.right = new
            self.temp = self.temp.right
            inorder(root.right)
        inorder(root)
        return newRoot.right
"
3114,python3,check-if-there-is-a-valid-partition-for-the-array,"class Solution:
    def validPartition(self, nums: List[int]) -> bool:

        checks = (True, False, nums[0] == nums[1])

        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):

            checks  = (checks[1], checks[2],
                      (checks[1] and curr == prev1) or
                      (checks[0] and curr == prev1 == prev2) or
                      (checks[0] and prev1 == prev2+1 == curr+2))   

        return checks[2]",None,"class Solution:
    def validPartition(self, nums: List[int]) -> bool:

        checks = (False, False, nums[0] == nums[1])

        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):

            checks  = (checks[1], checks[2],
                      (checks[1] and curr == prev1) or
                      (checks[0] and curr == prev1 == prev2) or
                      (checks[0] and prev1 == prev2+1 and curr == prev1+1))   

        return checks[2]
"
3114,python3,check-if-there-is-a-valid-partition-for-the-array,"class Solution:
    def validPartition(self, nums: List[int]) -> bool:

        checks = (True, False, nums[0] == nums[1])

        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):

            checks  = (checks[1], checks[2],
                      (checks[1] and curr == prev1) or
                      (checks[0] and curr == prev1 == prev2) or
                      (checks[0] and prev1 == prev2+1 == curr+2))   

        return checks[2]",None,"class Solution:
    def validPartition(self, nums: List[int]) -> bool:

        checks = (True, False, nums[0] == nums[1])

        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):

            checks = (checks[1], checks[2],
                      (checks[1] and curr == prev1) or 
                      (checks[0] and curr == prev1 == prev2) or 
                      (checks[0] and prev2+1 == prev1 == curr-1))

        return checks[2]
"
3114,python3,check-if-there-is-a-valid-partition-for-the-array,"class Solution:
    def validPartition(self, nums: List[int]) -> bool:

        checks = (True, False, nums[0] == nums[1])

        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):

            checks  = (checks[1], checks[2],
                      (checks[1] and curr == prev1) or
                      (checks[0] and curr == prev1 == prev2) or
                      (checks[0] and prev1 == prev2+1 == curr+2))   

        return checks[2]",None,"class Solution:
    def validPartition(self, nums: List[int]) -> bool:

        checks = (True, False, nums[0] == nums[1])

        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):

            checks  = (checks[1], checks[2],
                      (checks[1] and curr == prev1) or
                      (checks[0] and curr == prev1 == prev2) or
                      (checks[0] and prev1 == prev2+1 == curr-1)) 

        return checks[2]
"
3115,python3,lexicographically-smallest-palindrome,"class Solution:
    def makeSmallestPalindrome(self, s: str) -> str:
        before = 0
        after = len(s)-1
        l = [i for i in s]
        while before <= len(s):
            l[before] = min(l[before], l[after])
            l[after] = l[before]
            before+=1
            after-=1
        return """".join(l)",None,"class Solution:
    def makeSmallestPalindrome(self, s: str) -> str:
        before = 0
        after = len(s)-1
        l = [i for i in s]
        while before <= after:
            l[before] = min(l[before], l[after])
            l[after] = l[before]
            before+=1
            after-=1
        return """".join(l)
"
3115,python3,lexicographically-smallest-palindrome,"class Solution:
    def makeSmallestPalindrome(self, s: str) -> str:
        before = 0
        after = len(s)-1
        l = [i for i in s]
        while before <= len(s):
            l[before] = min(l[before], l[after])
            l[after] = l[before]
            before+=1
            after-=1
        return """".join(l)",None,"class Solution:
    def makeSmallestPalindrome(self, s: str) -> str:
        before = 0
        after = len(s)-1
        l = [i for i in s]
        while before <= after:
            l[before] = min(l[before], l[after])
            l[after] = l[before]
            before+=1
            after-=1
        return """".join(l)
"
3115,python3,lexicographically-smallest-palindrome,"class Solution:
    def makeSmallestPalindrome(self, s: str) -> str:
        before = 0
        after = len(s)-1
        l = [i for i in s]
        while before <= len(s):
            l[before] = min(l[before], l[after])
            l[after] = l[before]
            before+=1
            after-=1
        return """".join(l)",None,"class Solution:
    def makeSmallestPalindrome(self, s: str) -> str:
        before = 0
        after = len(s)-1
        l = [i for i in s]
        while before <= after:
            l[before] = min(l[before], l[after])
            l[after] = l[before]
            before += 1
            after -= 1
        return """".join(l)
"
3116,python3,can-place-flowers,"class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        flowerbed=[0]+flowerbed+[0]
        for i in range(1,len(flowerbed)-1):
            if flowerbed[i]==0 and flowerbed[i+2]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1
        if n<=0:return True
        return False",None,"class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        flowerbed = [0] + flowerbed + [0]
        for i in range(1, len(flowerbed)-1):
            if flowerbed[i-1] == 0 and flowerbed[i] == 0 and flowerbed[i+1] == 0:
                flowerbed[i] = 1
                n -= 1
        return n <= 0
"
3116,python3,can-place-flowers,"class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        flowerbed=[0]+flowerbed+[0]
        for i in range(1,len(flowerbed)-1):
            if flowerbed[i]==0 and flowerbed[i+2]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1
        if n<=0:return True
        return False",None,"class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        flowerbed=[0]+flowerbed+[0]
        for i in range(1,len(flowerbed)-1):
            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:
                flowerbed[i]=1
                n-=1
        return n <= 0
"
3116,python3,can-place-flowers,"class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        flowerbed=[0]+flowerbed+[0]
        for i in range(1,len(flowerbed)-1):
            if flowerbed[i]==0 and flowerbed[i+2]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1
        if n<=0:return True
        return False",None,"class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        flowerbed=[0]+flowerbed+[0]
        for i in range(1,len(flowerbed)-1):
            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:
                flowerbed[i]=1
                n-=1
        if n<=0:return True
        return False
"
3117,python3,remove-duplicates-from-sorted-array-ii,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        ans=2
        for i in range(2,len(nums)):
            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1
        return ans if len(nums) > 2 else len(nums) - 1",None,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return len(nums)
        ans=2
        for i in range(2,len(nums)):
            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1
        return ans
"
3117,python3,remove-duplicates-from-sorted-array-ii,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        ans=2
        for i in range(2,len(nums)):
            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1
        return ans if len(nums) > 2 else len(nums) - 1",None,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) < 3:
            return len(nums)
        else:
            ans = 2
            for i in range(2, len(nums)):
                if nums[i] != nums[ans-2] :
                    nums[ans] = nums[i]
                    ans += 1
            return ans
"
3117,python3,remove-duplicates-from-sorted-array-ii,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        ans=2
        for i in range(2,len(nums)):
            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1
        return ans if len(nums) > 2 else len(nums) - 1",None,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return len(nums)
        
        ans=2
        for i in range(2,len(nums)):
            if nums[i]!=nums[ans-2]:
                nums[ans]=nums[i]
                ans+=1
                
        return ans
"
3118,python3,edit-distance,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        n ,m = len(word1),len(word2)
        @lru_cache(None)
        def rec(i,j):
            if(i==n and j==m): return 0;
            elif(i==n):        return m-j
            elif(j==m):        return n-i
            elif(word1[i]==word2[j]):
                 return rec(i,j+1)
            else:
                res = 1+ rec(i,j+1)
                res = min(res,1+ rec(i+1,j))
                res = min( res, 1+ rec(i+1,j+1))
            return res
        return rec(0,0)",None,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        n, m = len(word1), len(word2)

        @lru_cache(None)
        def rec(i, j):
            if i == n and j == m: return 0
            elif i == n: return m - j
            elif j == m: return n - i
            elif word1[i] == word2[j]:
                return rec(i + 1, j + 1)
            else:
                res = 1 + rec(i, j + 1)  # insert operation
                res = min(res, 1 + rec(i + 1, j))  # delete operation
                res = min(res, 1 + rec(i + 1, j + 1))  # replace operation
            return res

        return rec(0, 0)
"
3118,python3,edit-distance,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        n ,m = len(word1),len(word2)
        @lru_cache(None)
        def rec(i,j):
            if(i==n and j==m): return 0;
            elif(i==n):        return m-j
            elif(j==m):        return n-i
            elif(word1[i]==word2[j]):
                 return rec(i,j+1)
            else:
                res = 1+ rec(i,j+1)
                res = min(res,1+ rec(i+1,j))
                res = min( res, 1+ rec(i+1,j+1))
            return res
        return rec(0,0)",None,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        n ,m = len(word1),len(word2)
        @lru_cache(None)
        def rec(i,j):
            if(i==n and j==m): return 0;
            elif(i==n):        return m-j
            elif(j==m):        return n-i
            elif(word1[i]==word2[j]):
                 return rec(i+1,j+1)
            else:
                res = 1+ rec(i,j+1)
                res = min(res,1+ rec(i+1,j))
                res = min( res, 1+ rec(i+1,j+1))
            return res
        return rec(0,0)
"
3118,python3,edit-distance,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        n ,m = len(word1),len(word2)
        @lru_cache(None)
        def rec(i,j):
            if(i==n and j==m): return 0;
            elif(i==n):        return m-j
            elif(j==m):        return n-i
            elif(word1[i]==word2[j]):
                 return rec(i,j+1)
            else:
                res = 1+ rec(i,j+1)
                res = min(res,1+ rec(i+1,j))
                res = min( res, 1+ rec(i+1,j+1))
            return res
        return rec(0,0)",None,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        n, m = len(word1), len(word2)

        @lru_cache(None)
        def rec(i, j):
            if(i == n and j == m): return 0;
            elif(i == n):        return m-j
            elif(j == m):        return n-i
            elif(word1[i] == word2[j]):
                 return rec(i+1, j+1)
            else:
                res = 1 + rec(i, j+1)
                res = min(res, 1 + rec(i+1, j))
                res = min(res, 1 + rec(i+1, j+1))
            return res

        return rec(0, 0)
"
3119,python3,sort-colors,"class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        low=mid=0
        high=len(nums)-1
        while mid<=high:
            if nums[mid]==0:
                nums[low],nums[mid]=nums[mid],nums[low]
                low+=1
                mid+=1
            elif nums[mid]==1:
                mid+=1
            else:
                nums[mid],nums[high]=nums[high],nums[mid]
                mid+=1
                high-=1",None,"class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        low = mid = 0
        high = len(nums) - 1
        while mid <= high:
            if nums[mid] == 0:
                nums[low], nums[mid] = nums[mid], nums[low]
                low += 1
                mid += 1
            elif nums[mid] == 1:
                mid += 1
            else:
                nums[mid], nums[high] = nums[high], nums[mid]
                high -= 1
"
3119,python3,sort-colors,"class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        low=mid=0
        high=len(nums)-1
        while mid<=high:
            if nums[mid]==0:
                nums[low],nums[mid]=nums[mid],nums[low]
                low+=1
                mid+=1
            elif nums[mid]==1:
                mid+=1
            else:
                nums[mid],nums[high]=nums[high],nums[mid]
                mid+=1
                high-=1",None,"class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        low=mid=0
        high=len(nums)-1
        while mid<=high:
            if nums[mid]==0:
                nums[low],nums[mid]=nums[mid],nums[low]
                low+=1
                mid+=1
            elif nums[mid]==1:
                mid+=1
            else:
                nums[mid],nums[high]=nums[high],nums[mid]
                high-=1
"
3119,python3,sort-colors,"class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        low=mid=0
        high=len(nums)-1
        while mid<=high:
            if nums[mid]==0:
                nums[low],nums[mid]=nums[mid],nums[low]
                low+=1
                mid+=1
            elif nums[mid]==1:
                mid+=1
            else:
                nums[mid],nums[high]=nums[high],nums[mid]
                mid+=1
                high-=1",None,"class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        low=mid=0
        high=len(nums)-1
        while mid<=high:
            if nums[mid]==0:
                nums[low],nums[mid]=nums[mid],nums[low]
                low+=1
                mid+=1
            elif nums[mid]==1:
                mid+=1
            else:
                nums[mid],nums[high]=nums[high],nums[mid]
                high-=1
"
3120,python3,most-common-word,"import re
from collections import Counter

class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        paragraph = re.subn(""[.,!?;']"", ' ', paragraph.lower())[0].split(' ')
        
        paragraph = list(filter(lambda x: x in banned + [''], paragraph))
        
        return Counter(paragraph).most_common(1)[0][0]",None,"import re
from collections import Counter

class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        paragraph = re.subn(""[.,!?;']"", ' ', paragraph.lower())[0].split(' ')
        
        paragraph = list(filter(lambda x: x not in banned + [''], paragraph))
        
        return Counter(paragraph).most_common(1)[0][0]
"
3120,python3,most-common-word,"import re
from collections import Counter

class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        paragraph = re.subn(""[.,!?;']"", ' ', paragraph.lower())[0].split(' ')
        
        paragraph = list(filter(lambda x: x in banned + [''], paragraph))
        
        return Counter(paragraph).most_common(1)[0][0]",None,"import re
from collections import Counter

class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        paragraph = re.subn(""[.,!?;']"", ' ', paragraph.lower())[0].split(' ')
        
        paragraph = list(filter(lambda x: x not in banned + [''], paragraph))
        
        return Counter(paragraph).most_common(1)[0][0]
"
3120,python3,most-common-word,"import re
from collections import Counter

class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        paragraph = re.subn(""[.,!?;']"", ' ', paragraph.lower())[0].split(' ')
        
        paragraph = list(filter(lambda x: x in banned + [''], paragraph))
        
        return Counter(paragraph).most_common(1)[0][0]",None,"import re
from collections import Counter

class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        paragraph = re.subn(r""[^\w\s]"", ' ', paragraph.lower())[0].split()

        paragraph = [word for word in paragraph if word not in banned]

        return Counter(paragraph).most_common(1)[0][0]
"
3121,python3,longest-substring-with-at-least-k-repeating-characters,"from collections import defaultdict
class Solution:
    def longestSubstring(self, s: str, k: int) -> int:
        x=self.recursion(s,k)
        if k==0:
            return x
        else:
            
            return 0

    def recursion(self,s,k):
        if len(s)<=1 :
            return len(s)
        flag=True
        for i in range(len(s)):
            if s.count(s[i])<k:
                flag=False
                break
            
        if flag:
            return len(s)
        left=(self.recursion(s[:i],k))
        right=(self.recursion(s[i+1:],k))
        if left>right:
            return (left)
        return (right)",None,"from collections import defaultdict
class Solution:
    def longestSubstring(self, s: str, k: int) -> int:
        x=self.recursion(s,k)
        if x>=0:
            return x
        else:
            return 0

    def recursion(self,s,k):
        if len(s) < k:
            return 0
        for i in set(s):
            if s.count(i) < k:
                return max(self.recursion(substr, k) for substr in s.split(i))
        return len(s)
"
3121,python3,longest-substring-with-at-least-k-repeating-characters,"from collections import defaultdict
class Solution:
    def longestSubstring(self, s: str, k: int) -> int:
        x=self.recursion(s,k)
        if k==0:
            return x
        else:
            
            return 0

    def recursion(self,s,k):
        if len(s)<=1 :
            return len(s)
        flag=True
        for i in range(len(s)):
            if s.count(s[i])<k:
                flag=False
                break
            
        if flag:
            return len(s)
        left=(self.recursion(s[:i],k))
        right=(self.recursion(s[i+1:],k))
        if left>right:
            return (left)
        return (right)",None,"from collections import defaultdict
class Solution:
    def longestSubstring(self, s: str, k: int) -> int:
        return self.recursion(s,k)

    def recursion(self,s,k):
        if len(s)<k :
            return 0
        flag=True
        for i in range(len(s)):
            if s.count(s[i])<k:
                flag=False
                break
            
        if flag:
            return len(s)
        left=(self.recursion(s[:i],k))
        right=(self.recursion(s[i+1:],k))
        return max(left,right)
"
3121,python3,longest-substring-with-at-least-k-repeating-characters,"from collections import defaultdict
class Solution:
    def longestSubstring(self, s: str, k: int) -> int:
        x=self.recursion(s,k)
        if k==0:
            return x
        else:
            
            return 0

    def recursion(self,s,k):
        if len(s)<=1 :
            return len(s)
        flag=True
        for i in range(len(s)):
            if s.count(s[i])<k:
                flag=False
                break
            
        if flag:
            return len(s)
        left=(self.recursion(s[:i],k))
        right=(self.recursion(s[i+1:],k))
        if left>right:
            return (left)
        return (right)",None,"from collections import defaultdict
class Solution:
    def longestSubstring(self, s: str, k: int) -> int:
        return self.recursion(s,k)

    def recursion(self,s,k):
        if len(s)<k:
            return 0
        for char in set(s):
            if s.count(char)<k:
                s_left, s_right = s.split(char)
                return max(self.recursion(s_left,k), self.recursion(s_right,k))           
        return len(s)
"
3122,python3,find-the-middle-index-in-array,"class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        def dnc(l, r, lo, hi):
            if l == r - 1:
                return l if lo == hi else -1
            
            mid = (l + r) // 2
            right = sum(nums[mid:r])
            left = sum(nums[l:mid])

            left_ind = dnc(l, mid, lo, hi + left)
            return left_ind if left_ind != -1 else dnc(mid, r, lo + left, hi)
        return dnc(0, len(nums), 0, 0)",None,"class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        total_sum = sum(nums)
        left_sum = 0

        for i, num in enumerate(nums):
            if left_sum == (total_sum - left_sum - num):
                return i
            left_sum += num

        return -1
"
3122,python3,find-the-middle-index-in-array,"class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        def dnc(l, r, lo, hi):
            if l == r - 1:
                return l if lo == hi else -1
            
            mid = (l + r) // 2
            right = sum(nums[mid:r])
            left = sum(nums[l:mid])

            left_ind = dnc(l, mid, lo, hi + left)
            return left_ind if left_ind != -1 else dnc(mid, r, lo + left, hi)
        return dnc(0, len(nums), 0, 0)",None,"class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        total = sum(nums)
        leftsum = 0
        for i, x in enumerate(nums):
            if leftsum == (total - leftsum - x):
                return i
            leftsum += x
        return -1
"
3122,python3,find-the-middle-index-in-array,"class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        def dnc(l, r, lo, hi):
            if l == r - 1:
                return l if lo == hi else -1
            
            mid = (l + r) // 2
            right = sum(nums[mid:r])
            left = sum(nums[l:mid])

            left_ind = dnc(l, mid, lo, hi + left)
            return left_ind if left_ind != -1 else dnc(mid, r, lo + left, hi)
        return dnc(0, len(nums), 0, 0)",None,"class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        total_sum = sum(nums)
        left_sum = 0

        for i, num in enumerate(nums):
            if left_sum == (total_sum - left_sum - num):
                return i
            left_sum += num

        return -1
"
3123,python3,maximum-depth-of-n-ary-tree,"""""""
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children

class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if root == None:
            return 0
        else:
            depth = 0
            nodes_queue = [root]
            next_nodes_queue = []
            while(nodes_queue):
                node_out = nodes_queue.pop(0)
                for child in node_out.children:
                    nodes_queue.append(child)
                if nodes_queue == []:
                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue
                    depth += 1
            return depth
""""""",None,"class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children

class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if root == None:
            return 0
        else:
            depth = 0
            nodes_queue = [root]
            while nodes_queue:
                next_nodes_queue = []
                while nodes_queue:
                    node_out = nodes_queue.pop(0)
                    for child in node_out.children:
                        next_nodes_queue.append(child)
                nodes_queue = next_nodes_queue
                depth += 1
            return depth
"
3123,python3,maximum-depth-of-n-ary-tree,"""""""
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children

class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if root == None:
            return 0
        else:
            depth = 0
            nodes_queue = [root]
            next_nodes_queue = []
            while(nodes_queue):
                node_out = nodes_queue.pop(0)
                for child in node_out.children:
                    nodes_queue.append(child)
                if nodes_queue == []:
                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue
                    depth += 1
            return depth
""""""",None,"class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children

class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if root is None:
            return 0
        else:
            depth = 0
            nodes_queue = [root]
            next_nodes_queue = []
            while(nodes_queue):
                node_out = nodes_queue.pop(0)
                for child in node_out.children:
                    next_nodes_queue.append(child)
                if not nodes_queue:
                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue
                    depth += 1
            return depth
"
3123,python3,maximum-depth-of-n-ary-tree,"""""""
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children

class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if root == None:
            return 0
        else:
            depth = 0
            nodes_queue = [root]
            next_nodes_queue = []
            while(nodes_queue):
                node_out = nodes_queue.pop(0)
                for child in node_out.children:
                    nodes_queue.append(child)
                if nodes_queue == []:
                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue
                    depth += 1
            return depth
""""""",None,"class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children

class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if root == None:
            return 0
        else:
            depth = 0
            nodes_queue = [root]
            next_nodes_queue = []
            while(nodes_queue):
                node_out = nodes_queue.pop(0)
                for child in node_out.children:
                    next_nodes_queue.append(child)
                if not nodes_queue:
                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue
                    depth += 1
            return depth
"
3124,python3,minimum-cost-to-cut-a-stick,"class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        
        cuts = sorted(chain(cuts,[0,n]))
        
        @lru_cache(None)
        def dfs(l, r):
            length, M = cuts[r] - cuts[l], range(l+1, r)
            return min((dfs(l,i) + dfs(i,r) for i in M),
                       default = length) + length
        
        return dfs(0, len(cuts)-1)",None,"class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        
        cuts = sorted(cuts + [0,n])
        
        @lru_cache(None)
        def dfs(l, r):
            if l + 1 == r:
                return 0
            return cuts[r] - cuts[l] + min(dfs(l,i) + dfs(i,r) for i in range(l + 1, r))
        
        return dfs(0, len(cuts)-1)
"
3124,python3,minimum-cost-to-cut-a-stick,"class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        
        cuts = sorted(chain(cuts,[0,n]))
        
        @lru_cache(None)
        def dfs(l, r):
            length, M = cuts[r] - cuts[l], range(l+1, r)
            return min((dfs(l,i) + dfs(i,r) for i in M),
                       default = length) + length
        
        return dfs(0, len(cuts)-1)",None,"class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        cuts.sort()
        cuts = [0] + cuts + [n]
        
        dp = [[0] * len(cuts) for _ in range(len(cuts))]
        
        for l in range(len(cuts) - 2, -1, -1):
            for r in range(l+2, len(cuts)):
                dp[l][r] = min(dp[l][m] + dp[m][r] for m in range(l+1, r)) + cuts[r] - cuts[l]
                
        return dp[0][-1]
"
3124,python3,minimum-cost-to-cut-a-stick,"class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        
        cuts = sorted(chain(cuts,[0,n]))
        
        @lru_cache(None)
        def dfs(l, r):
            length, M = cuts[r] - cuts[l], range(l+1, r)
            return min((dfs(l,i) + dfs(i,r) for i in M),
                       default = length) + length
        
        return dfs(0, len(cuts)-1)",None,"class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        
        cuts = sorted(cuts + [0, n])
        dp = [[0] * (len(cuts)) for _ in range(len(cuts))]
        
        for d in range(2, len(cuts)):
            for i in range(len(cuts) - d):
                dp[i][i+d] = min(dp[i][m] + dp[m][i+d] for m in range(i+1, i+d)) + cuts[i+d] - cuts[i]
        
        return dp[0][-1]
"
3125,python3,calculate-money-in-leetcode-bank,"class Solution:
    def totalMoney(self, n: int) -> int:
        income=1;a=[1];ans=0
        for i in range(n):
            if i%7==0 and i!=0:income=(a[len(a)-8])
            ans+=income;income+=1;a.append(income)      
        return ans",None,"class Solution:
    def totalMoney(self, n: int) -> int:
        income = 1
        a = [1]
        ans = 0
        for i in range(n):
            if i % 7 == 0 and i != 0:
                income = a[len(a)-7]+1
            ans += income
            income += 1
            a.append(income)      
        return ans
"
3125,python3,calculate-money-in-leetcode-bank,"class Solution:
    def totalMoney(self, n: int) -> int:
        income=1;a=[1];ans=0
        for i in range(n):
            if i%7==0 and i!=0:income=(a[len(a)-8])
            ans+=income;income+=1;a.append(income)      
        return ans",None,"class Solution:
    def totalMoney(self, n: int) -> int:
        baseIncome = 1
        weeklyIncome = [baseIncome]
        totalMoney = 0
        for i in range(n):
            if i % 7 == 0 and i != 0:
                baseIncome += 1
                weeklyIncome.append(baseIncome)
            totalMoney += baseIncome
            baseIncome += 1
        return totalMoney
"
3125,python3,calculate-money-in-leetcode-bank,"class Solution:
    def totalMoney(self, n: int) -> int:
        income=1;a=[1];ans=0
        for i in range(n):
            if i%7==0 and i!=0:income=(a[len(a)-8])
            ans+=income;income+=1;a.append(income)      
        return ans",None,"class Solution:
    def totalMoney(self, n: int) -> int:
        income=1;a=[1];ans=0
        for i in range(n):
            if i%7==0 and i!=0:income=(a[len(a)-7]) + 1
            ans+=income;income+=1;a.append(income)      
        return ans
"
3126,python3,longest-subsequence-with-limited-sum,"class Solution:
  def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:
    nums, sums, res, n = sorted(nums), [0], [], len(queries)+1
    for num in nums:
      sums.append(sums[-1] + num)
    
    def bSearch(q, l=0, mid=n>>1, r=n):
      while l < mid < r:
        if sums[mid] > q:
          r = mid
        elif sums[mid] < q:
          l = mid
        else: break
        mid = (l+r)>>1
      return mid

    return [bSearch(q) for q in queries]",None,"class Solution:
  def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:
    nums, sums, res = sorted(nums, reverse=True), [0], []
    for num in nums:
      sums.append(sums[-1] + num)
    
    def binarySearch(query, left=0, right=len(sums)):
        while left < right:
            mid = (left + right) // 2
            if sums[mid] <= query:
                left = mid + 1
            else:
                right = mid
        return right - 1

    return [binarySearch(query) for query in queries]
"
3126,python3,longest-subsequence-with-limited-sum,"class Solution:
  def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:
    nums, sums, res, n = sorted(nums), [0], [], len(queries)+1
    for num in nums:
      sums.append(sums[-1] + num)
    
    def bSearch(q, l=0, mid=n>>1, r=n):
      while l < mid < r:
        if sums[mid] > q:
          r = mid
        elif sums[mid] < q:
          l = mid
        else: break
        mid = (l+r)>>1
      return mid

    return [bSearch(q) for q in queries]",None,"class Solution:
  def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:
    nums, sums, res = sorted(nums, reverse=True), [0], []
    for num in nums:
      sums.append(sums[-1] + num)
    n = len(sums)
    
    def bSearch(q, l=0, r=n):
        while l < r:
            mid = (l + r) // 2
            if sums[mid] > q:
                r = mid
            else:
                l = mid + 1
        return l - 1

    return [bSearch(q) for q in queries]
"
3126,python3,longest-subsequence-with-limited-sum,"class Solution:
  def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:
    nums, sums, res, n = sorted(nums), [0], [], len(queries)+1
    for num in nums:
      sums.append(sums[-1] + num)
    
    def bSearch(q, l=0, mid=n>>1, r=n):
      while l < mid < r:
        if sums[mid] > q:
          r = mid
        elif sums[mid] < q:
          l = mid
        else: break
        mid = (l+r)>>1
      return mid

    return [bSearch(q) for q in queries]",None,"class Solution:
    def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:
        nums.sort()
        n, prefixSum, res = len(nums), [0], []
        for num in nums:
            prefixSum.append(prefixSum[-1] + num)
        
        def bSearch(q):
            l, r = 0, n
            while l < r:
                mid = (l+r+1) >> 1
                if prefixSum[mid] <= q:
                    l = mid
                else:
                    r = mid - 1
            return l

        return [bSearch(q) for q in queries]
"
3127,python3,maximum-number-of-moves-in-a-grid,"class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        m,n = len(grid), len(grid)
        dq = deque(range(m))
        moves = 0
        while dq and moves < n-1:
            nxt = set()
            for _ in range(len(dq)):
                idx = dq.popleft()
                val = grid[idx][moves]
                for i in range(max(0, idx-1), min(m, idx+2)):
                    if grid[i][moves+1] > val:
                        nxt.add(i)
            if len(nxt) > 0:
                moves += 1
            dq.extend(nxt)
        return moves",None,"class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        m,n = len(grid), len(grid[0])
        dq = deque(range(m))
        moves = 0
        while dq and moves < n-1:
            nxt = set()
            for _ in range(len(dq)):
                idx = dq.popleft()
                val = grid[idx][moves]
                for i in range(max(0, idx-1), min(m, idx+2)):
                    if grid[i][moves+1] > val:
                        nxt.add(i)
            if len(nxt) > 0:
                moves += 1
            dq.extend(nxt)
        return moves
"
3127,python3,maximum-number-of-moves-in-a-grid,"class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        m,n = len(grid), len(grid)
        dq = deque(range(m))
        moves = 0
        while dq and moves < n-1:
            nxt = set()
            for _ in range(len(dq)):
                idx = dq.popleft()
                val = grid[idx][moves]
                for i in range(max(0, idx-1), min(m, idx+2)):
                    if grid[i][moves+1] > val:
                        nxt.add(i)
            if len(nxt) > 0:
                moves += 1
            dq.extend(nxt)
        return moves",None,"class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        m,n = len(grid), len(grid[0])
        dq = deque(range(m))
        moves = 0
        while dq and moves < n-1:
            nxt = set()
            for _ in range(len(dq)):
                idx = dq.popleft()
                val = grid[idx][moves]
                for i in range(max(0, idx-1), min(m, idx+2)):
                    if grid[i][moves+1] > val:
                        nxt.add(i)
            if len(nxt) > 0:
                moves += 1
            dq.extend(nxt)
        return moves
"
3127,python3,maximum-number-of-moves-in-a-grid,"class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        m,n = len(grid), len(grid)
        dq = deque(range(m))
        moves = 0
        while dq and moves < n-1:
            nxt = set()
            for _ in range(len(dq)):
                idx = dq.popleft()
                val = grid[idx][moves]
                for i in range(max(0, idx-1), min(m, idx+2)):
                    if grid[i][moves+1] > val:
                        nxt.add(i)
            if len(nxt) > 0:
                moves += 1
            dq.extend(nxt)
        return moves",None,"class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        m,n = len(grid), len(grid[0])
        dq = deque(range(m))
        moves = 0
        while dq and moves < n-1:
            nxt = set()
            for _ in range(len(dq)):
                idx = dq.popleft()
                val = grid[idx][moves]
                for i in range(max(0, idx-1), min(m, idx+2)):
                    if grid[i][moves+1] > val:
                        nxt.add(i)
            if len(nxt) > 0:
                moves += 1
            dq.extend(nxt)
        return moves
"
3128,python3,course-schedule,"class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:

        pre = defaultdict(list)

        for course, p in prerequisites:
            pre[course].append(p)
        
        taken = set()

        def dfs(course):
            if not pre[course]:
                return True
            
            if course in taken:
                return False
            
            taken.add(course)

            for p in pre[course]:
                if not dfs(p): return False
            
            taken.remove(course)
            return True
        
        for course in range(numCourses):
            if not dfs(course):
                return False

        return True",None,"class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:

        pre = defaultdict(list)
        
        for course, p in prerequisites:
            pre[course].append(p)
        
        taken = set()
        path = set()

        def dfs(course):
            if course in path:
                return False
            
            if course in taken:
                return True

            path.add(course)
            for p in pre[course]:
                if not dfs(p): 
                    return False
                
            path.remove(course)
            taken.add(course)
            return True
        
        for course in range(numCourses):
            if not dfs(course):
                return False

        return True
"
3128,python3,course-schedule,"class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:

        pre = defaultdict(list)

        for course, p in prerequisites:
            pre[course].append(p)
        
        taken = set()

        def dfs(course):
            if not pre[course]:
                return True
            
            if course in taken:
                return False
            
            taken.add(course)

            for p in pre[course]:
                if not dfs(p): return False
            
            taken.remove(course)
            return True
        
        for course in range(numCourses):
            if not dfs(course):
                return False

        return True",None,"class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:

        pre = defaultdict(list)
        for course, p in prerequisites:
            pre[course].append(p)
        
        visited = [0]*numCourses

        def dfs(course):
            if visited[course] == -1:
                return False
            
            if visited[course] == 1:
                return True

            visited[course] = -1

            for p in pre[course]:
                if not dfs(p): return False
            
            visited[course] = 1
            return True
        
        for course in range(numCourses):
            if not dfs(course):
                return False

        return True
"
3128,python3,course-schedule,"class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:

        pre = defaultdict(list)

        for course, p in prerequisites:
            pre[course].append(p)
        
        taken = set()

        def dfs(course):
            if not pre[course]:
                return True
            
            if course in taken:
                return False
            
            taken.add(course)

            for p in pre[course]:
                if not dfs(p): return False
            
            taken.remove(course)
            return True
        
        for course in range(numCourses):
            if not dfs(course):
                return False

        return True",None,"class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        pre = defaultdict(list)

        for course, p in prerequisites:
            pre[course].append(p)

        taken = set()
        visited = set()
        
        def dfs(course):
            if course not in pre:
                return True

            visited.add(course)

            for p in pre[course]:
                if p in visited or not dfs(p):
                    return False
                
            visited.remove(course)
            taken.add(course)
            
            return True

        for course in range(numCourses):
            if course not in taken and not dfs(course):
                return False

        return True
"
3129,python3,satisfiability-of-equality-equations,"class Disjoint:
    def __init__(self):
        self.rank=[0]*26
        self.parent=[i for i in range(26)]

    def finduPar(self,node):
        if self.parent[node]==node:
            return node
        self.parent[node]=self.finduPar(self.parent[node])
        return self.parent[node]

    def byrank(self,u,v):
        ulp_u=self.finduPar(node)
        ulp_v=self.finduPar(node)
        if ulp_u==ulp_v:
            return False
        if self.rank[ulp_u]>self.rank[ulp_v]:
            self.parent[ulp_v]=ulp_u
        elif self.rank[ulp_u]<self.rank[ulp_v]:
            self.parent[ulp_u]=ulp_v
        else:
            self.parent[ulp_v]=ulp_u
            self.rank[ulp_u]+=1


class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        disjoint=Disjoint()
        nq=[]
        n=len(equations)
        for i in range(n):
            if equations[i][1]=='!':
                if equations[i][0]==equations[i][-1]:
                    return False
                else:
                    nq.append(equations[i])
            else:
                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)
        for i in range(len(nq)):
            x=ord(nq[i][0])-97
            y=ord(nq[i][-1])-97
            if disjoint.finduPar(x)==disjoint.finduPar(y):
                return False
        return True",None,"class Disjoint:
    def __init__(self):
        self.rank=[0]*26
        self.parent=[i for i in range(26)]

    def finduPar(self,node):
        if self.parent[node]==node:
            return node
        self.parent[node]=self.finduPar(self.parent[node])
        return self.parent[node]

    def byrank(self,u,v):
        ulp_u=self.finduPar(u)
        ulp_v=self.finduPar(v)
        if ulp_u==ulp_v:
            return False
        if self.rank[ulp_u]>self.rank[ulp_v]:
            self.parent[ulp_v]=ulp_u
        elif self.rank[ulp_u]<self.rank[ulp_v]:
            self.parent[ulp_u]=ulp_v
        else:
            self.parent[ulp_v]=ulp_u
            self.rank[ulp_u]+=1


class Solution:
    def equationsPossible(self, equations) -> bool:
        disjoint=Disjoint()
        nq=[]
        n=len(equations)
        for i in range(n):
            if equations[i][1]=='!':
                if equations[i][0]==equations[i][-1]:
                    return False
                else:
                    nq.append(equations[i])
            else:
                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)
        for i in range(len(nq)):
            x=ord(nq[i][0])-97
            y=ord(nq[i][-1])-97
            if disjoint.finduPar(x)==disjoint.finduPar(y):
                return False
        return True
"
3129,python3,satisfiability-of-equality-equations,"class Disjoint:
    def __init__(self):
        self.rank=[0]*26
        self.parent=[i for i in range(26)]

    def finduPar(self,node):
        if self.parent[node]==node:
            return node
        self.parent[node]=self.finduPar(self.parent[node])
        return self.parent[node]

    def byrank(self,u,v):
        ulp_u=self.finduPar(node)
        ulp_v=self.finduPar(node)
        if ulp_u==ulp_v:
            return False
        if self.rank[ulp_u]>self.rank[ulp_v]:
            self.parent[ulp_v]=ulp_u
        elif self.rank[ulp_u]<self.rank[ulp_v]:
            self.parent[ulp_u]=ulp_v
        else:
            self.parent[ulp_v]=ulp_u
            self.rank[ulp_u]+=1


class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        disjoint=Disjoint()
        nq=[]
        n=len(equations)
        for i in range(n):
            if equations[i][1]=='!':
                if equations[i][0]==equations[i][-1]:
                    return False
                else:
                    nq.append(equations[i])
            else:
                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)
        for i in range(len(nq)):
            x=ord(nq[i][0])-97
            y=ord(nq[i][-1])-97
            if disjoint.finduPar(x)==disjoint.finduPar(y):
                return False
        return True",None,"class Disjoint:
    def __init__(self):
        self.rank=[0]*26
        self.parent=[i for i in range(26)]

    def finduPar(self, node):
        if self.parent[node] != node:
            self.parent[node] = self.finduPar(self.parent[node])
        return self.parent[node]

    def byrank(self, u, v):
        ulp_u = self.finduPar(u)
        ulp_v = self.finduPar(v)
        
        if ulp_u == ulp_v:
            return False
        if self.rank[ulp_u] > self.rank[ulp_v]:
            self.parent[ulp_v] = ulp_u
        elif self.rank[ulp_u] < self.rank[ulp_v]:
            self.parent[ulp_u] = ulp_v
        else:
            self.parent[ulp_v] = ulp_u
            self.rank[ulp_u] += 1


class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        disjoint = Disjoint()
        not_equal_queue = []
        
        for i in range(len(equations)):
            if equations[i][1] == '!':
                if equations[i][0] == equations[i][-1]:
                    return False
                else:
                    not_equal_queue.append(equations[i])
            else:
                disjoint.byrank(ord(equations[i][0])-97, ord(equations[i][-1])-97)
                
        for i in range(len(not_equal_queue)):
            x = ord(not_equal_queue[i][0]) - 97
            y = ord(not_equal_queue[i][-1]) - 97
            if disjoint.finduPar(x) == disjoint.finduPar(y):
                return False
        return True
"
3129,python3,satisfiability-of-equality-equations,"class Disjoint:
    def __init__(self):
        self.rank=[0]*26
        self.parent=[i for i in range(26)]

    def finduPar(self,node):
        if self.parent[node]==node:
            return node
        self.parent[node]=self.finduPar(self.parent[node])
        return self.parent[node]

    def byrank(self,u,v):
        ulp_u=self.finduPar(node)
        ulp_v=self.finduPar(node)
        if ulp_u==ulp_v:
            return False
        if self.rank[ulp_u]>self.rank[ulp_v]:
            self.parent[ulp_v]=ulp_u
        elif self.rank[ulp_u]<self.rank[ulp_v]:
            self.parent[ulp_u]=ulp_v
        else:
            self.parent[ulp_v]=ulp_u
            self.rank[ulp_u]+=1


class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        disjoint=Disjoint()
        nq=[]
        n=len(equations)
        for i in range(n):
            if equations[i][1]=='!':
                if equations[i][0]==equations[i][-1]:
                    return False
                else:
                    nq.append(equations[i])
            else:
                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)
        for i in range(len(nq)):
            x=ord(nq[i][0])-97
            y=ord(nq[i][-1])-97
            if disjoint.finduPar(x)==disjoint.finduPar(y):
                return False
        return True",None,"class Disjoint:
    def __init__(self):
        self.rank=[0]*26
        self.parent=[i for i in range(26)]

    def finduPar(self,node):
        if self.parent[node]==node:
            return node
        self.parent[node]=self.finduPar(self.parent[node])
        return self.parent[node]

    def byrank(self,u,v):
        ulp_u=self.finduPar(u)
        ulp_v=self.finduPar(v)
        if ulp_u==ulp_v:
            return False
        if self.rank[ulp_u]>self.rank[ulp_v]:
            self.parent[ulp_v]=ulp_u
        elif self.rank[ulp_u]<self.rank[ulp_v]:
            self.parent[ulp_u]=ulp_v
        else:
            self.parent[ulp_v]=ulp_u
            self.rank[ulp_u]+=1


class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        disjoint=Disjoint()
        nq=[]
        n=len(equations)
        for i in range(n):
            if equations[i][1]=='!':
                if equations[i][0]==equations[i][-1]:
                    return False
                else:
                    nq.append(equations[i])
            else:
                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)
        for i in range(len(nq)):
            x=ord(nq[i][0])-97
            y=ord(nq[i][-1])-97
            if disjoint.finduPar(x)==disjoint.finduPar(y):
                return False
        return True
"
3130,python3,convert-sorted-list-to-binary-search-tree,"class Solution:
    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:
        nums=[]
        curr=head
        while curr:
            nums.append(curr.val)
            curr=curr.next
        def helper(l,r):
            if l>r:
                return None
            mid=(l+r)//2
            root=TreeNode(nums[mid])
            root.left=helper(l,mid)
            root.right=helper(mid+1,r)
            return root
        return helper(0,len(nums)-1)",None,"class Solution:
    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:
        nums=[]
        curr=head
        while curr:
            nums.append(curr.val)
            curr=curr.next
        def helper(l,r):
            if l>r:
                return None
            mid=(l+r)//2
            root=TreeNode(nums[mid])
            root.left=helper(l,mid-1)
            root.right=helper(mid+1,r)
            return root
        return helper(0,len(nums)-1)
"
3130,python3,convert-sorted-list-to-binary-search-tree,"class Solution:
    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:
        nums=[]
        curr=head
        while curr:
            nums.append(curr.val)
            curr=curr.next
        def helper(l,r):
            if l>r:
                return None
            mid=(l+r)//2
            root=TreeNode(nums[mid])
            root.left=helper(l,mid)
            root.right=helper(mid+1,r)
            return root
        return helper(0,len(nums)-1)",None,"class Solution:
    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:
        nums=[]
        curr=head
        while curr:
            nums.append(curr.val)
            curr=curr.next
        def helper(l,r):
            if l>r:
                return None
            mid=(l+r)//2
            root=TreeNode(nums[mid])
            root.left=helper(l,mid-1)
            root.right=helper(mid+1,r)
            return root
        return helper(0,len(nums)-1)
"
3130,python3,convert-sorted-list-to-binary-search-tree,"class Solution:
    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:
        nums=[]
        curr=head
        while curr:
            nums.append(curr.val)
            curr=curr.next
        def helper(l,r):
            if l>r:
                return None
            mid=(l+r)//2
            root=TreeNode(nums[mid])
            root.left=helper(l,mid)
            root.right=helper(mid+1,r)
            return root
        return helper(0,len(nums)-1)",None,"class Solution:
    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:
        nums=[]
        curr=head
        while curr:
            nums.append(curr.val)
            curr=curr.next
        def helper(l,r):
            if l>r:
                return None
            mid=(l+r)//2
            root=TreeNode(nums[mid])
            root.left=helper(l,mid-1)
            root.right=helper(mid+1,r)
            return root
        return helper(0,len(nums)-1)
"
3131,python3,minimum-cost-to-make-at-least-one-valid-path-in-a-grid,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        distance = [[m * n + 1 for _ in range(n)] for _ in range(m)]
        distance[m - 1][n - 1] = 0 
        q = collections.deque([(0, 0, 0)])
        while q:
            c, i, j = q.popleft()
            if c > distance[i][j]: continue
            if i == m - 1 and j == n - 1: return c
            for di, dj, d in [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    if c + int(d != grid[i][j]) < distance[ci][cj]:
                        distance[ci][cj] = c + int(d != grid[i][j])
                        if d == grid[i][j]: q.appendleft((distance[ci][cj], ci, cj))
                        else: q.append((distance[ci][cj], ci, cj))
        
        return distance[m - 1][n - 1]",None,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        distance = [[m * n + 1 for _ in range(n)] for _ in range(m)]
        distance[0][0] = 0 
        q = collections.deque([(0, 0, 0)])
        while q:
            c, i, j = q.popleft()
            if c > distance[i][j]: continue
            for di, dj, d in [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    if c + int(d != grid[i][j]) < distance[ci][cj]:
                        distance[ci][cj] = c + int(d != grid[i][j])
                        if d == grid[i][j]: q.appendleft((distance[ci][cj], ci, cj))
                        else: q.append((distance[ci][cj], ci, cj))
        
        return distance[m - 1][n - 1]
"
3131,python3,minimum-cost-to-make-at-least-one-valid-path-in-a-grid,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        distance = [[m * n + 1 for _ in range(n)] for _ in range(m)]
        distance[m - 1][n - 1] = 0 
        q = collections.deque([(0, 0, 0)])
        while q:
            c, i, j = q.popleft()
            if c > distance[i][j]: continue
            if i == m - 1 and j == n - 1: return c
            for di, dj, d in [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    if c + int(d != grid[i][j]) < distance[ci][cj]:
                        distance[ci][cj] = c + int(d != grid[i][j])
                        if d == grid[i][j]: q.appendleft((distance[ci][cj], ci, cj))
                        else: q.append((distance[ci][cj], ci, cj))
        
        return distance[m - 1][n - 1]",None,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        distance = [[m * n + 1 for _ in range(n)] for _ in range(m)]
        distance[0][0] = 0 
        q = collections.deque([(0, 0, 0)])
        while q:
            c, i, j = q.popleft()
            if c > distance[i][j]: continue
            if i == m - 1 and j == n - 1: return c
            for di, dj, d in [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    if c + int(d != grid[i][j]) < distance[ci][cj]:
                        distance[ci][cj] = c + int(d != grid[i][j])
                        if d == grid[i][j]: q.appendleft((distance[ci][cj], ci, cj))
                        else: q.append((distance[ci][cj], ci, cj))
        
        return distance[m - 1][n - 1]
"
3131,python3,minimum-cost-to-make-at-least-one-valid-path-in-a-grid,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        distance = [[m * n + 1 for _ in range(n)] for _ in range(m)]
        distance[m - 1][n - 1] = 0 
        q = collections.deque([(0, 0, 0)])
        while q:
            c, i, j = q.popleft()
            if c > distance[i][j]: continue
            if i == m - 1 and j == n - 1: return c
            for di, dj, d in [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    if c + int(d != grid[i][j]) < distance[ci][cj]:
                        distance[ci][cj] = c + int(d != grid[i][j])
                        if d == grid[i][j]: q.appendleft((distance[ci][cj], ci, cj))
                        else: q.append((distance[ci][cj], ci, cj))
        
        return distance[m - 1][n - 1]",None,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        distance = [[m * n + 1 for _ in range(n)] for _ in range(m)]
        distance[0][0] = 0 
        q = collections.deque([(0, 0, 0)])
        while q:
            c, i, j = q.popleft()
            if c > distance[i][j]: continue
            if i == m - 1 and j == n - 1: return c
            for di, dj, d in [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    if c + int(d != grid[i][j]) < distance[ci][cj]:
                        distance[ci][cj] = c + int(d != grid[i][j])
                        if d == grid[i][j]: q.appendleft((distance[ci][cj], ci, cj))
                        else: q.append((distance[ci][cj], ci, cj))
        
        return distance[m - 1][n - 1]
"
3132,python3,count-equal-and-divisible-pairs-in-an-array,"class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        d={}
        for i,v in enumerate(nums):
            if v in d:
                d[v].append(i)
            else:
                d|={v:[i]}
        s=0
        def make(a,n):
            c=0
            for i in range(n-1):
                for j in range(i+1,n):
                    if a[i]*a[j]%k==0:
                        c+=1
            return c
        for i in d:
            if len(d[i])==1:
                continue
            s+=make(nums,d[i])
        return s",None,"class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        d={}
        for i,v in enumerate(nums):
            if v in d:
                d[v].append(i)
            else:
                d|={v:[i]}
        s=0
        def make(index_array,n):
            c=0
            for i in range(n-1):
                for j in range(i+1,n):
                    if index_array[i]*index_array[j]%k==0:
                        c+=1
            return c
        for i in d:
            if len(d[i])==1:
                continue
            s+=make(d[i], len(d[i]))
        return s
"
3132,python3,count-equal-and-divisible-pairs-in-an-array,"class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        d={}
        for i,v in enumerate(nums):
            if v in d:
                d[v].append(i)
            else:
                d|={v:[i]}
        s=0
        def make(a,n):
            c=0
            for i in range(n-1):
                for j in range(i+1,n):
                    if a[i]*a[j]%k==0:
                        c+=1
            return c
        for i in d:
            if len(d[i])==1:
                continue
            s+=make(nums,d[i])
        return s",None,"class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        d = {}
        for i, v in enumerate(nums):
            if v in d:
                d[v].append(i)
            else:
                d[v] = [i]
                
        s = 0
        def make(arr):
            c = 0
            n = len(arr)
            for i in range(n-1):
                for j in range(i+1, n):
                    if arr[i] * arr[j] % k == 0:
                        c += 1
            return c
        
        for v in d.values():
            if len(v) > 1:
                s += make(v)
                
        return s
"
3132,python3,count-equal-and-divisible-pairs-in-an-array,"class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        d={}
        for i,v in enumerate(nums):
            if v in d:
                d[v].append(i)
            else:
                d|={v:[i]}
        s=0
        def make(a,n):
            c=0
            for i in range(n-1):
                for j in range(i+1,n):
                    if a[i]*a[j]%k==0:
                        c+=1
            return c
        for i in d:
            if len(d[i])==1:
                continue
            s+=make(nums,d[i])
        return s",None,"class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        d={}
        for i,v in enumerate(nums):
            if v in d:
                d[v].append(i)
            else:
                d|={v:[i]}
        s=0
        def make(a,n):
            c=0
            for i in range(n-1):
                for j in range(i+1,n):
                    if a[i]*a[j]%k==0:
                        c+=1
            return c
        for i in d:
            if len(d[i])==1:
                continue
            s+=make(d[i],len(d[i]))
        return s
"
3133,python3,substrings-of-size-three-with-distinct-characters,"class Solution:
    def countGoodSubstrings(self, s: str) -> int:
        count = 0
        for i in range(len(s) - 2):
            x = s[i: i + 2]
            if x.count(x[0]) == 1 and x.count(x[1]) == 1 and x.count(x[2]) == 1:
                count += 1
        return count",None,"class Solution:
    def countGoodSubstrings(self, s: str) -> int:
        count = 0
        for i in range(len(s) - 2):
            x = s[i: i + 3]
            if x.count(x[0]) == 1 and x.count(x[1]) == 1 and x.count(x[2]) == 1:
                count += 1
        return count
"
3133,python3,substrings-of-size-three-with-distinct-characters,"class Solution:
    def countGoodSubstrings(self, s: str) -> int:
        count = 0
        for i in range(len(s) - 2):
            x = s[i: i + 2]
            if x.count(x[0]) == 1 and x.count(x[1]) == 1 and x.count(x[2]) == 1:
                count += 1
        return count",None,"class Solution:
    def countGoodSubstrings(self, s: str) -> int:
        count = 0
        for i in range(len(s) - 2):
            x = s[i: i + 3]
            if x.count(x[0]) == 1 and x.count(x[1]) == 1 and x.count(x[2]) == 1:
                count += 1
        return count
"
3133,python3,substrings-of-size-three-with-distinct-characters,"class Solution:
    def countGoodSubstrings(self, s: str) -> int:
        count = 0
        for i in range(len(s) - 2):
            x = s[i: i + 2]
            if x.count(x[0]) == 1 and x.count(x[1]) == 1 and x.count(x[2]) == 1:
                count += 1
        return count",None,"class Solution:
    def countGoodSubstrings(self, s: str) -> int:
        count = 0
        for i in range(len(s) - 2):
            x = s[i: i + 3]
            if x.count(x[0]) == 1 and x.count(x[1]) == 1 and x.count(x[2]) == 1:
                count += 1
        return count
"
3134,python3,count-subtrees-with-max-distance-between-cities,"class Solution:
    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:
        adj = [[] for i in range(n)]
        for u,v in edges:
            adj[u-1].append(v-1)
            adj[v-1].append(u-1)
        def comb(p,q):
            if len(q)<len(p): p,q = q,p
            res = [0]*len(q)
            res[0] = p[0]*q[0]
            for i in range(1,len(p)): p[i] += p[i-1]
            for i in range(1,len(q)): q[i] += q[i-1]
            for i in range(1,len(p)):
                res[i] = p[i]*q[i]-p[i-1]*q[i-1]
            for i in range(len(p),len(q)):
                res[i] = (q[i]-q[i-1])*p[-1]
            return res
            
        def dfs(r,p):
            d = [1]
            for v in adj[r]:
                if v==p: continue
                t = [0]+dfs(v,r) 
                d = comb(t,d)
            return d
        ans = [0]*n
        for u,v in edges:
            u -= 1; v-=1
            p = dfs(u,v)
            q = dfs(v,u)
            for i in range(min(len(p),len(q))):
                ans[i+i+1] += p[i]*q[i]
        for v in range(n): 
            if len(adj[v])==1: continue 
            tree = [1]+dfs(adj[v][0],v)
            curr = [0]*n
            for u in adj[v][1:]:
                q = [1]+dfs(u,v)
                j = 1; t = q[1]+1
                for i in range(4,n,2):
                    while j+1<min(i//2,len(q)):
                        j += 1; t += q[j]
                    curr[i] *= t
                for i in range(min(len(tree),len(q))):
                    curr[i+i] += tree[i]*q[i]
                tree = comb(tree,q)
            for i in range(2,n,2):
                ans[i] += curr[i]
        return ans[1:]",None,"class Solution:
    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:
        adj = [[] for i in range(n)]
        for u, v in edges:
            adj[u - 1].append(v - 1)
            adj[v - 1].append(u - 1)
            
        def comb(p, q):
            if len(q) < len(p): p, q = q, p
            res = [0]*len(q)
            res[0] = p[0]*q[0]
            for i in range(1, len(p)): p[i] += p[i - 1]
            for i in range(1, len(q)): q[i] += q[i - 1]
            for i in range(1, len(p)):
                res[i] = p[i]*q[i] - p[i - 1]*q[i - 1]
            for i in range(len(p), len(q)):
                res[i] = (q[i] - q[i - 1])*p[-1]
            return res
        
        def dfs(r, p):
            d = [1]
            for v in adj[r]:
                if v == p: continue
                t = [0] + dfs(v, r) 
                d = comb(t, d)
            return d

        ans = [0]*n
        for u, v in edges:
            u -= 1; v -= 1
            p = dfs(u, v)
            q = dfs(v, u)
            for i in range(min(len(p), len(q))):
                ans[i*2 + 1] += p[i]*q[i]
                
        for v in range(n): 
            if len(adj[v]) == 1: continue 
            tree = [1] + dfs(adj[v][0], v)
            curr = [0]*n
            for u in adj[v][1:]:
                q = [1] + dfs(u, v)
                j = 1; t = q[1] + 1
                for i in range(4, n, 2):
                    while j+1 < min(i//2, len(q)):
                        j += 1; t += q[j]
                    curr[i] = t if curr[i] else 1
                for i in range(min(len(tree), len(q))):
                    curr[i*2] += tree[i]*q[i]
                tree = comb(tree, q)
            for i in range(2, n, 2):
                ans[i] += curr[i]
        return ans[1:]
"
3134,python3,count-subtrees-with-max-distance-between-cities,"class Solution:
    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:
        adj = [[] for i in range(n)]
        for u,v in edges:
            adj[u-1].append(v-1)
            adj[v-1].append(u-1)
        def comb(p,q):
            if len(q)<len(p): p,q = q,p
            res = [0]*len(q)
            res[0] = p[0]*q[0]
            for i in range(1,len(p)): p[i] += p[i-1]
            for i in range(1,len(q)): q[i] += q[i-1]
            for i in range(1,len(p)):
                res[i] = p[i]*q[i]-p[i-1]*q[i-1]
            for i in range(len(p),len(q)):
                res[i] = (q[i]-q[i-1])*p[-1]
            return res
            
        def dfs(r,p):
            d = [1]
            for v in adj[r]:
                if v==p: continue
                t = [0]+dfs(v,r) 
                d = comb(t,d)
            return d
        ans = [0]*n
        for u,v in edges:
            u -= 1; v-=1
            p = dfs(u,v)
            q = dfs(v,u)
            for i in range(min(len(p),len(q))):
                ans[i+i+1] += p[i]*q[i]
        for v in range(n): 
            if len(adj[v])==1: continue 
            tree = [1]+dfs(adj[v][0],v)
            curr = [0]*n
            for u in adj[v][1:]:
                q = [1]+dfs(u,v)
                j = 1; t = q[1]+1
                for i in range(4,n,2):
                    while j+1<min(i//2,len(q)):
                        j += 1; t += q[j]
                    curr[i] *= t
                for i in range(min(len(tree),len(q))):
                    curr[i+i] += tree[i]*q[i]
                tree = comb(tree,q)
            for i in range(2,n,2):
                ans[i] += curr[i]
        return ans[1:]",None,"class Solution:
    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:
        adj = [[] for i in range(n)]
        for u,v in edges:
            adj[u-1].append(v-1)
            adj[v-1].append(u-1)
        def comb(p,q):
            if len(q)<len(p): p,q = q,p
            res = [0]*len(q)
            for i in range(1,len(p)): p[i] += p[i-1]
            for i in range(1,len(q)): q[i] += q[i-1]
            for i in range(1,len(p)):
                res[i] = p[i]*q[i]-p[i-1]*q[i-1]
            for i in range(len(p),len(q)):
                res[i] = (q[i]-q[i-1])*p[-1]
            return res
            
        def dfs(r,p):
            d = [1]
            for v in adj[r]:
                if v==p: continue
                t = [0]+dfs(v,r) 
                d = comb(t,d)
            return d
        ans = [0]*n
        for u,v in edges:
            u -= 1; v-=1
            p = dfs(u,v)
            q = dfs(v,u)
            for i in range(min(len(p),len(q))):
                ans[i+i+1] += p[i]*q[i]
        for v in range(n): 
            if len(adj[v])==1: continue 
            tree = [1]+dfs(adj[v][0],v)
            curr = [0]*n
            for u in adj[v][1:]:
                q = [1]+dfs(u,v)
                j = 1; t = q[1]+1
                for i in range(4,n,2):
                    while j+1<min(i//2,len(q)):
                        j += 1; t += q[j]
                    if i < len(curr):
                        curr[i] *= t
                for i in range(min(len(tree),len(q))):
                    if i + i < len(curr):
                        curr[i+i] += tree[i]*q[i]
                tree = comb(tree,q)
            for i in range(2,n,2):
                if i < len(curr) and i < len(ans):
                    ans[i] += curr[i]
        return ans[1:]
"
3134,python3,count-subtrees-with-max-distance-between-cities,"class Solution:
    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:
        adj = [[] for i in range(n)]
        for u,v in edges:
            adj[u-1].append(v-1)
            adj[v-1].append(u-1)
        def comb(p,q):
            if len(q)<len(p): p,q = q,p
            res = [0]*len(q)
            res[0] = p[0]*q[0]
            for i in range(1,len(p)): p[i] += p[i-1]
            for i in range(1,len(q)): q[i] += q[i-1]
            for i in range(1,len(p)):
                res[i] = p[i]*q[i]-p[i-1]*q[i-1]
            for i in range(len(p),len(q)):
                res[i] = (q[i]-q[i-1])*p[-1]
            return res
            
        def dfs(r,p):
            d = [1]
            for v in adj[r]:
                if v==p: continue
                t = [0]+dfs(v,r) 
                d = comb(t,d)
            return d
        ans = [0]*n
        for u,v in edges:
            u -= 1; v-=1
            p = dfs(u,v)
            q = dfs(v,u)
            for i in range(min(len(p),len(q))):
                ans[i+i+1] += p[i]*q[i]
        for v in range(n): 
            if len(adj[v])==1: continue 
            tree = [1]+dfs(adj[v][0],v)
            curr = [0]*n
            for u in adj[v][1:]:
                q = [1]+dfs(u,v)
                j = 1; t = q[1]+1
                for i in range(4,n,2):
                    while j+1<min(i//2,len(q)):
                        j += 1; t += q[j]
                    curr[i] *= t
                for i in range(min(len(tree),len(q))):
                    curr[i+i] += tree[i]*q[i]
                tree = comb(tree,q)
            for i in range(2,n,2):
                ans[i] += curr[i]
        return ans[1:]",None,"class Solution:
    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:
        G = [[] for _ in range(n)]
        for u, v in edges:
            u -= 1
            v -= 1
            G[u].append(v)
            G[v].append(u)

        dist = [[0]*n for _ in range(n)]
        for i in range(n):
            self.bfs(i, G, dist[i])

        dp = [0]*(1<<n)
        for mask in range(1, 1<<n):
            dp[mask] = max(dist[i][j] for j in range(n) for i in range(j) if ((mask>>i)&(mask>>j)&1))

        ans = [0]*n
        for mask in range(1, 1<<n):
            if bin(mask).count('1') < 2: continue
            for sub in range(mask, 0, (mask-1)&-mask):
                maxDist = max(dp[sub], dp[mask^sub])
                ans[maxDist-1] += self.isConnected(G, bin(mask)[::-1].index('1'), mask)

        return ans[:-1]

    def bfs(self, root, G, dist):
        q = collections.deque([(root, 0)])
        seen = {root}
        while q:
            node, d = q.popleft()
            dist[node] = d
            for nei in G[node]:
                if nei not in seen:
                    seen.add(nei)
                    q.append((nei, d+1))

    def isConnected(self, G, root, mask):
        q = [root]
        mask ^= (1 << root)
        while q:
            node = q.pop()
            for nei in G[node]:
                if mask & (1 << nei):
                    mask ^= (1 << nei)
                    q.append(nei)
        return mask == 0
"
3135,python3,next-greater-element-iv,"class Solution:
    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        ans = [-1] * len(nums)
        s, ss = [], []
        for i, x in enumerate(nums): 
            while ss and nums[ss[-1]] < x: ans[ss.pop()] = x
            buff = []
            while s and nums[s[-1]] < x: buff.append(s.pop())
            while buff: s.append(buff.pop())
            s.append(i)
        return ans",None,"class Solution:
    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        ans = [-1] * len(nums)
        s, ss = [], []
        for i, x in enumerate(nums): 
            while s and nums[s[-1]] < x:
                while ss and nums[ss[-1]] < x: 
                    ans[ss.pop()] = x
                s.append(i)
            s.append(i)
        return ans
"
3135,python3,next-greater-element-iv,"class Solution:
    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        ans = [-1] * len(nums)
        s, ss = [], []
        for i, x in enumerate(nums): 
            while ss and nums[ss[-1]] < x: ans[ss.pop()] = x
            buff = []
            while s and nums[s[-1]] < x: buff.append(s.pop())
            while buff: s.append(buff.pop())
            s.append(i)
        return ans",None,"class Solution:
    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        ans = [-1] * len(nums)
        s, ss = [], []
        for i, x in enumerate(nums): 
            while ss and nums[ss[-1]] < x: 
                ans[ss.pop()] = x
            while s and nums[s[-1]] < x: 
                ss.append(s.pop())
            s.append(i)
        return ans
"
3135,python3,next-greater-element-iv,"class Solution:
    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        ans = [-1] * len(nums)
        s, ss = [], []
        for i, x in enumerate(nums): 
            while ss and nums[ss[-1]] < x: ans[ss.pop()] = x
            buff = []
            while s and nums[s[-1]] < x: buff.append(s.pop())
            while buff: s.append(buff.pop())
            s.append(i)
        return ans",None,"class Solution:
    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        ans = [-1] * len(nums)
        s, ss = [], []
        for i, x in enumerate(nums): 
            while ss and nums[ss[-1]] < x: ans[ss.pop()] = x
            while s and nums[s[-1]] < x: 
                ss.append(s.pop())
            s.append(i)
        return ans
"
3136,python3,minimum-obstacle-removal-to-reach-corner,"class Solution:
    def minimumObstacles(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        distance = [[float('inf') for _ in range(n)] for _ in range(m)]
        distance[0][0] = 0
        q = collections.deque([(0, 0, 0)])
        while q:
            d, i, j = q.popleft()
            if i == m - 1 and j == n - 1: return d
            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    if d + grid[ci][cj] < distance[ci][cj]:
                        distance[ci][cj] = d + grid[ci][cj]
                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))
                        else: q.appendleft((distance[ci][cj], ci, cj))
                else: q.appendleft((distance[i][j], i, j))
        return distance[m - 1][n - 1]",None,"class Solution:
    def minimumObstacles(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        distance = [[float('inf') for _ in range(n)] for _ in range(m)]
        distance[0][0] = 0
        q = collections.deque([(0, 0, 0)])
        while q:
            d, i, j = q.popleft()
            if i == m - 1 and j == n - 1: return d
            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    if d + grid[ci][cj] < distance[ci][cj]:
                        distance[ci][cj] = d + grid[ci][cj]
                        if grid[ci][cj] == 1: 
                            q.append((distance[ci][cj], ci, cj))
                        else: 
                            q.appendleft((distance[ci][cj], ci, cj))
        return distance[m - 1][n - 1]
"
3136,python3,minimum-obstacle-removal-to-reach-corner,"class Solution:
    def minimumObstacles(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        distance = [[float('inf') for _ in range(n)] for _ in range(m)]
        distance[0][0] = 0
        q = collections.deque([(0, 0, 0)])
        while q:
            d, i, j = q.popleft()
            if i == m - 1 and j == n - 1: return d
            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    if d + grid[ci][cj] < distance[ci][cj]:
                        distance[ci][cj] = d + grid[ci][cj]
                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))
                        else: q.appendleft((distance[ci][cj], ci, cj))
                else: q.appendleft((distance[i][j], i, j))
        return distance[m - 1][n - 1]",None,"class Solution:
    def minimumObstacles(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        distance = [[float('inf') for _ in range(n)] for _ in range(m)]
        distance[0][0] = 0
        q = collections.deque([(0, 0, 0)])
        while q:
            d, i, j = q.popleft()
            if i == m - 1 and j == n - 1: return d
            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n and d + grid[ci][cj] < distance[ci][cj]:
                    distance[ci][cj] = d + grid[ci][cj]
                    if grid[ci][cj] == 1: 
                        q.append((distance[ci][cj], ci, cj))
                    else: 
                        q.appendleft((distance[ci][cj], ci, cj))
        return distance[m - 1][n - 1]
"
3136,python3,minimum-obstacle-removal-to-reach-corner,"class Solution:
    def minimumObstacles(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        distance = [[float('inf') for _ in range(n)] for _ in range(m)]
        distance[0][0] = 0
        q = collections.deque([(0, 0, 0)])
        while q:
            d, i, j = q.popleft()
            if i == m - 1 and j == n - 1: return d
            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    if d + grid[ci][cj] < distance[ci][cj]:
                        distance[ci][cj] = d + grid[ci][cj]
                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))
                        else: q.appendleft((distance[ci][cj], ci, cj))
                else: q.appendleft((distance[i][j], i, j))
        return distance[m - 1][n - 1]",None,"class Solution:
    def minimumObstacles(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        distance = [[float('inf') for _ in range(n)] for _ in range(m)]
        distance[0][0] = 0
        q = collections.deque([(0, 0, 0)])
        while q:
            d, i, j = q.popleft()
            if i == m - 1 and j == n - 1: return d
            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    if d + grid[ci][cj] < distance[ci][cj]:
                        distance[ci][cj] = d + grid[ci][cj]
                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))
                        else: q.appendleft((distance[ci][cj], ci, cj))
        return -1 if distance[m - 1][n - 1] == float('inf') else distance[m - 1][n - 1]
"
3137,python3,linked-list-in-binary-tree,"class Solution:
    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:

        if head is None:
            return True

        if root is None:
            return False

        if head.val == root.val:
            if self.isSame(head, root):
                return True
            
        return self.isSubPath(head.next, root.left) or self.isSubPath(head.next, root.right)

    
    def isSame(self, head, root):

        if head is None:
            return True
        
        if root is None:
            return False

        if head.val == root.val:
            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)
        
        return False",None,"class Solution:
    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:

        if head is None:
            return True

        if root is None:
            return False

        if head.val == root.val:
            if self.isSame(head, root):
                return True
            
        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)

    
    def isSame(self, head, root):

        if head is None:
            return True
        
        if root is None:
            return False

        if head.val == root.val:
            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)
        
        return False
"
3137,python3,linked-list-in-binary-tree,"class Solution:
    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:

        if head is None:
            return True

        if root is None:
            return False

        if head.val == root.val:
            if self.isSame(head, root):
                return True
            
        return self.isSubPath(head.next, root.left) or self.isSubPath(head.next, root.right)

    
    def isSame(self, head, root):

        if head is None:
            return True
        
        if root is None:
            return False

        if head.val == root.val:
            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)
        
        return False",None,"class Solution:
    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:

        if head is None:
            return True

        if root is None:
            return False

        if self.isSame(head, root):
            return True
            
        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)

    
    def isSame(self, head, root):

        if head is None:
            return True
        
        if root is None:
            return False

        if head.val == root.val:
            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)
        
        return False
"
3137,python3,linked-list-in-binary-tree,"class Solution:
    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:

        if head is None:
            return True

        if root is None:
            return False

        if head.val == root.val:
            if self.isSame(head, root):
                return True
            
        return self.isSubPath(head.next, root.left) or self.isSubPath(head.next, root.right)

    
    def isSame(self, head, root):

        if head is None:
            return True
        
        if root is None:
            return False

        if head.val == root.val:
            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)
        
        return False",None,"class Solution:
    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:

        if head is None:
            return True

        if root is None:
            return False

        return self.isSame(head, root) or self.isSubPath(head, root.left) or self.isSubPath(head, root.right)

    
    def isSame(self, head, root):

        if head is None:
            return True
        
        if root is None:
            return False

        if head.val != root.val:
            return False

        return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)
"
3138,python3,stone-game-vi,"class Solution:
    def stoneGameVI(self, a: List[int], b: List[int]) -> int:
        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]
        combines.sort(reverse=True)
        bobPoints = sum(b)
        alicePoints = 0
        for i in range(1, len(a), 2):
            alicePoints += combines[i][1]
            bobPoints -= combines[i][2]
        if alicePoints > bobPoints:
            return 1
        elif alicePoints < bobPoints:
            return -1
        return 0",None,"class Solution:
    def stoneGameVI(self, a: List[int], b: List[int]) -> int:
        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]
        combines.sort(reverse=True)
        alicePoints = 0
        bobPoints = 0
        for i in range(len(a)):
            if i % 2 == 0:
                alicePoints += combines[i][1]
            else:
                bobPoints += combines[i][2]
        if alicePoints > bobPoints:
            return 1
        elif alicePoints < bobPoints:
            return -1
        return 0
"
3138,python3,stone-game-vi,"class Solution:
    def stoneGameVI(self, a: List[int], b: List[int]) -> int:
        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]
        combines.sort(reverse=True)
        bobPoints = sum(b)
        alicePoints = 0
        for i in range(1, len(a), 2):
            alicePoints += combines[i][1]
            bobPoints -= combines[i][2]
        if alicePoints > bobPoints:
            return 1
        elif alicePoints < bobPoints:
            return -1
        return 0",None,"class Solution:
    def stoneGameVI(self, a: List[int], b: List[int]) -> int:
        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]
        combines.sort(reverse=True)
        bobPoints = sum(b)
        alicePoints = 0
        for i in range(0, len(a), 2):
            alicePoints += combines[i][1]
            bobPoints -= combines[i][2]
        if alicePoints > bobPoints:
            return 1
        elif alicePoints < bobPoints:
            return -1
        return 0
"
3138,python3,stone-game-vi,"class Solution:
    def stoneGameVI(self, a: List[int], b: List[int]) -> int:
        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]
        combines.sort(reverse=True)
        bobPoints = sum(b)
        alicePoints = 0
        for i in range(1, len(a), 2):
            alicePoints += combines[i][1]
            bobPoints -= combines[i][2]
        if alicePoints > bobPoints:
            return 1
        elif alicePoints < bobPoints:
            return -1
        return 0",None,"class Solution:
    def stoneGameVI(self, a: List[int], b: List[int]) -> int:
        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]
        combines.sort(reverse=True)
        alicePoints = 0
        bobPoints = 0
        for i in range(len(a)):
            if i % 2 == 0:
                alicePoints += combines[i][1]
            else:
                bobPoints += combines[i][2]
        if alicePoints > bobPoints:
            return 1
        elif alicePoints < bobPoints:
            return -1
        return 0
"
3139,python3,find-the-array-concatenation-value,"class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        i=0
        c=0
        j=len(nums)
        while(i<=j):
            if(i==j):
                c=c+nums[i]
                break
            s=str(nums[i])+str(nums[j])
            c=c+int(s)
            i=i+1
            j=j-1
        return c",None,"class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        i=0
        c=0
        j=len(nums) - 1
        while(i<=j):
            if(i==j):
                c=c+nums[i]
                break
            s=str(nums[i])+str(nums[j])
            c=c+int(s)
            i=i+1
            j=j-1
        return c
"
3139,python3,find-the-array-concatenation-value,"class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        i=0
        c=0
        j=len(nums)
        while(i<=j):
            if(i==j):
                c=c+nums[i]
                break
            s=str(nums[i])+str(nums[j])
            c=c+int(s)
            i=i+1
            j=j-1
        return c",None,"class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        i=0
        c=0
        j=len(nums)-1
        while(i<=j):
            if(i==j):
                c=c+nums[i]
                break
            s=str(nums[i])+str(nums[j])
            c=c+int(s)
            i=i+1
            j=j-1
        return c
"
3139,python3,find-the-array-concatenation-value,"class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        i=0
        c=0
        j=len(nums)
        while(i<=j):
            if(i==j):
                c=c+nums[i]
                break
            s=str(nums[i])+str(nums[j])
            c=c+int(s)
            i=i+1
            j=j-1
        return c",None,"class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        i=0
        c=0
        j=len(nums)-1
        while(i<=j):
            if(i==j):
                c=c+nums[i]
                break
            s=str(nums[i])+str(nums[j])
            c=c+int(s)
            i=i+1
            j=j-1
        return c
"
3140,python3,check-if-every-row-and-column-contains-all-numbers,"class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:

        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]
        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]

        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if dp_row[i][j] or dp_col[i][j]:
                    return False
                dp_row[i][j] = True
                dp_col[i][j] = True
        return True",None,"class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:
        n = len(matrix)

        for i in range(n):
            row_nums = set()
            col_nums = set()
            for j in range(n):
                # Check if the number is in the correct range and is not a duplicate
                if matrix[i][j] < 1 or matrix[i][j] > n or matrix[i][j] in row_nums:
                    return False
                if matrix[j][i] < 1 or matrix[j][i] > n or matrix[j][i] in col_nums:
                    return False
                row_nums.add(matrix[i][j])
                col_nums.add(matrix[j][i])
        return True
"
3140,python3,check-if-every-row-and-column-contains-all-numbers,"class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:

        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]
        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]

        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if dp_row[i][j] or dp_col[i][j]:
                    return False
                dp_row[i][j] = True
                dp_col[i][j] = True
        return True",None,"class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:

        n = len(matrix)
        
        for row in matrix:
            if sorted(row) != list(range(1, n + 1)):
                return False

        for col in zip(*matrix):
            if sorted(col) != list(range(1, n + 1)):
                return False
                
        return True
"
3140,python3,check-if-every-row-and-column-contains-all-numbers,"class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:

        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]
        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]

        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if dp_row[i][j] or dp_col[i][j]:
                    return False
                dp_row[i][j] = True
                dp_col[i][j] = True
        return True",None,"class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:

        n = len(matrix)
        for i in range(n):
            row = [0] * n
            col = [0] * n
            for j in range(n):
                if matrix[i][j] - 1 < n and matrix[j][i] - 1 < n:
                    row[matrix[i][j] - 1] += 1
                    col[matrix[j][i] - 1] += 1

            if row != [1]*n or col != [1]*n:
                return False
        return True
"
3141,python3,maximum-gap,"class Solution:
    def maximumGap(self, nums: List[int]) -> int:
        nums=sorted(nums)
        min=float(""inf"")
        if len(nums)<2:
            return 0
        for i in range(len(nums)-1):
            x=abs(nums[i]-nums[i+1])
            if min<x:
                min=x
        return min",None,"class Solution:
    def maximumGap(self, nums: List[int]) -> int:
        if len(nums) < 2:
            return 0
        nums.sort()
        max_diff = float(""-inf"")
        for i in range(len(nums)-1):
            diff = abs(nums[i+1]-nums[i])
            if diff > max_diff:
                max_diff = diff
        return max_diff
"
3141,python3,maximum-gap,"class Solution:
    def maximumGap(self, nums: List[int]) -> int:
        nums=sorted(nums)
        min=float(""inf"")
        if len(nums)<2:
            return 0
        for i in range(len(nums)-1):
            x=abs(nums[i]-nums[i+1])
            if min<x:
                min=x
        return min",None,"class Solution:
    def bucket_sort(self, nums, max_num, min_num, bucket_size):
        if max_num == min_num:
            return max_num - min_num

        buckets = [[] for _ in range(bucket_size + 1)]
        # Distribute number to bucket
        for num in nums:
            index = (num - min_num) // bucket_size
            if buckets[index]:
                buckets[index].append(num)
                buckets[index][0] = min(buckets[index][0], num)
                buckets[index][1] = max(buckets[index][1], num)
            else:
                buckets[index] = [num, num]

        # Calculate the max gap
        max_gap = 0
        prev_max = min_num
        for bucket in buckets:
            if not bucket:
                continue
            max_gap = max(max_gap, bucket[0] - prev_max)
            prev_max = bucket[1]

        return max_gap

    def maximumGap(self, nums: List[int]) -> int:
        if len(nums) < 2:
            return 0

        max_num = max(nums)
        min_num = min(nums)
        bucket_size = max(1, (max_num - min_num) // (len(nums) - 1))

        return self.bucket_sort(nums, max_num, min_num, bucket_size)
"
3141,python3,maximum-gap,"class Solution:
    def maximumGap(self, nums: List[int]) -> int:
        nums=sorted(nums)
        min=float(""inf"")
        if len(nums)<2:
            return 0
        for i in range(len(nums)-1):
            x=abs(nums[i]-nums[i+1])
            if min<x:
                min=x
        return min",None,"class Solution:
    def maximumGap(self, nums: List[int]) -> int:
        if len(nums)<2:
            return 0

        maxima, minima, N = max(nums), min(nums), len(nums)
        bucket_range = max(1, (maxima-minima)//(N-1))
        bucket_size = (maxima-minima)//bucket_range + 1
        buckets = [[None, None] for _ in range(bucket_size)]

        for num in nums:
            pos = (num-minima)//bucket_range
            if buckets[pos][0] is None:
                buckets[pos] = [num, num]
            else:
                buckets[pos][0] = min(buckets[pos][0], num)
                buckets[pos][1] = max(buckets[pos][1], num)

        max_gap = 0
        prev_bucket = minima
        for i in range(bucket_size):
            if buckets[i][0] is not None:
                max_gap = max(max_gap, buckets[i][0]-prev_bucket)
                prev_bucket = buckets[i][1]

        return max_gap
"
3142,python3,minimum-index-sum-of-two-lists,"class Solution:
    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
        d2={}
        l=[]
        for i in range(len(list2)):
            d2[list2[i]]=i
        for i in range(len(list1)):
            if list1[i] in d2:
                l.append([i+d2[list1[i]],list1[i]])
        l1=[]
        l.sort()
        l1.append(l[1][1]) 
        for i in range(1,len(l)):
            if l[i][0]==l[i-1][0]:
                l1.append(l[i][1])
            else:
                break
        return l1",None,"class Solution:
    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
        d2={}
        l=[]
        for i in range(len(list2)):
            d2[list2[i]]=i
        for i in range(len(list1)):
            if list1[i] in d2:
                l.append([i+d2[list1[i]],list1[i]])
        l1=[]
        l.sort()
        l1.append(l[0][1]) 
        for i in range(1,len(l)):
            if l[i][0]==l[i-1][0]:
                l1.append(l[i][1])
            else:
                break
        return l1
"
3142,python3,minimum-index-sum-of-two-lists,"class Solution:
    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
        d2={}
        l=[]
        for i in range(len(list2)):
            d2[list2[i]]=i
        for i in range(len(list1)):
            if list1[i] in d2:
                l.append([i+d2[list1[i]],list1[i]])
        l1=[]
        l.sort()
        l1.append(l[1][1]) 
        for i in range(1,len(l)):
            if l[i][0]==l[i-1][0]:
                l1.append(l[i][1])
            else:
                break
        return l1",None,"class Solution:
    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
        d2={}
        l=[]
        for i in range(len(list2)):
            d2[list2[i]]=i
        for i in range(len(list1)):
            if list1[i] in d2:
                l.append([i+d2[list1[i]],list1[i]])
        l1=[]
        l.sort()
        minSum = l[0][0]
        l1.append(l[0][1]) 
        for i in range(1,len(l)):
            if l[i][0]==minSum:
                l1.append(l[i][1])
            else:
                break
        return l1
"
3142,python3,minimum-index-sum-of-two-lists,"class Solution:
    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
        d2={}
        l=[]
        for i in range(len(list2)):
            d2[list2[i]]=i
        for i in range(len(list1)):
            if list1[i] in d2:
                l.append([i+d2[list1[i]],list1[i]])
        l1=[]
        l.sort()
        l1.append(l[1][1]) 
        for i in range(1,len(l)):
            if l[i][0]==l[i-1][0]:
                l1.append(l[i][1])
            else:
                break
        return l1",None,"class Solution:
    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
        d2={}
        l=[]
        for i in range(len(list2)):
            d2[list2[i]]=i
        for i in range(len(list1)):
            if list1[i] in d2:
                l.append([i+d2[list1[i]],list1[i]])
        l1=[]
        l.sort()
        l1.append(l[0][1])  # Change from l[1][1] to l[0][1]
        for i in range(1,len(l)):
            if l[i][0]==l[i-1][0]:
                l1.append(l[i][1])
            else:
                break
        return l1
"
3143,python3,median-of-two-sorted-arrays,"class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        p1 = 0
        p2 = 0
        new = []
        while p1 < len(nums1) and p2 < len(nums2):
            if nums1[p1] < nums2[p2]:
                new.append(nums1[p1])
                p1 += 1
            else:
                new.append(nums2[p2])
                p2 += 1
        while p1 < len(nums1):
            new.append(nums1[p1])
            p2 += 1
        while p2 < len(nums2):
            new.append(nums2[p2])
            p1 += 1

        if len(new) % 2 == 0:
            index = len(new) // 2
            median = (new[index] + new[index-1]) / 2
        else:
            median = float(new[len(new)//2])
        return median",None,"class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        p1 = 0
        p2 = 0
        new = []
        while p1 < len(nums1) and p2 < len(nums2):
            if nums1[p1] < nums2[p2]:
                new.append(nums1[p1])
                p1 += 1
            else:
                new.append(nums2[p2])
                p2 += 1
        while p1 < len(nums1):
            new.append(nums1[p1])
            p1 += 1
        while p2 < len(nums2):
            new.append(nums2[p2])
            p2 += 1

        if len(new) % 2 == 0:
            index = len(new) // 2
            median = (new[index] + new[index-1]) / 2
        else:
            median = float(new[len(new)//2])
        return median
"
3143,python3,median-of-two-sorted-arrays,"class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        p1 = 0
        p2 = 0
        new = []
        while p1 < len(nums1) and p2 < len(nums2):
            if nums1[p1] < nums2[p2]:
                new.append(nums1[p1])
                p1 += 1
            else:
                new.append(nums2[p2])
                p2 += 1
        while p1 < len(nums1):
            new.append(nums1[p1])
            p2 += 1
        while p2 < len(nums2):
            new.append(nums2[p2])
            p1 += 1

        if len(new) % 2 == 0:
            index = len(new) // 2
            median = (new[index] + new[index-1]) / 2
        else:
            median = float(new[len(new)//2])
        return median",None,"class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        p1 = 0
        p2 = 0
        new = []
        while p1 < len(nums1) and p2 < len(nums2):
            if nums1[p1] < nums2[p2]:
                new.append(nums1[p1])
                p1 += 1
            else:
                new.append(nums2[p2])
                p2 += 1
        while p1 < len(nums1):
            new.append(nums1[p1])
            p1 += 1
        while p2 < len(nums2):
            new.append(nums2[p2])
            p2 += 1

        if len(new) % 2 == 0:
            index = len(new) // 2
            median = (new[index] + new[index-1]) / 2
        else:
            median = float(new[len(new)//2])
        return median
"
3143,python3,median-of-two-sorted-arrays,"class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        p1 = 0
        p2 = 0
        new = []
        while p1 < len(nums1) and p2 < len(nums2):
            if nums1[p1] < nums2[p2]:
                new.append(nums1[p1])
                p1 += 1
            else:
                new.append(nums2[p2])
                p2 += 1
        while p1 < len(nums1):
            new.append(nums1[p1])
            p2 += 1
        while p2 < len(nums2):
            new.append(nums2[p2])
            p1 += 1

        if len(new) % 2 == 0:
            index = len(new) // 2
            median = (new[index] + new[index-1]) / 2
        else:
            median = float(new[len(new)//2])
        return median",None,"class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        p1 = 0
        p2 = 0
        new = []
        while p1 < len(nums1) and p2 < len(nums2):
            if nums1[p1] < nums2[p2]:
                new.append(nums1[p1])
                p1 += 1
            else:
                new.append(nums2[p2])
                p2 += 1
        while p1 < len(nums1):
            new.append(nums1[p1])
            p1 += 1
        while p2 < len(nums2):
            new.append(nums2[p2])
            p2 += 1

        if len(new) % 2 == 0:
            index = len(new) // 2
            median = (new[index] + new[index-1]) / 2
        else:
            median = float(new[len(new)//2])
        return median
"
3144,python3,reverse-subarray-to-maximize-array-value,"class Solution:
    def maxValueAfterReverse(self, nums: List[int]) -> int:
        originalValue, sz = 0, len(nums)
        for idx in range(sz - 1):
            originalValue += abs(nums[idx] - nums[idx + 1])
        finalValue = originalValue
        for idx in range(1, sz - 1):
            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx + 1]) + abs(nums[idx + 1] - nums[0]))
            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx - 1]) + abs(nums[idx - 1] - nums[sz - 1]))
        minimum, maximum = inf, -inf
        for idx in range(sz - 1):
            tempMin, tempMax = min(nums[idx], nums[idx + 1]), max(nums[idx], nums[idx + 1])
            if minimum < tempMin: finalValue = max(finalValue, originalValue + (tempMin - minimum) * 2)
            if tempMax < maximum: finalValue = max(finalValue, originalValue + (maximum - tempMax) * 2)
            minimum = min(minimum, tempMax)
            maximum = max(maximum, tempMax)
        return finalValue",None,"class Solution:
    def maxValueAfterReverse(self, nums: List[int]) -> int:
        originalValue, sz = 0, len(nums)
        for idx in range(sz - 1):
            originalValue += abs(nums[idx] - nums[idx + 1])
        finalValue = originalValue
        for idx in range(1, sz - 1):
            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx + 1]) + abs(nums[idx + 1] - nums[0]))
            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx - 1]) + abs(nums[0] - nums[idx - 1]))
        minimum, maximum = float('inf'), -float('inf')
        for idx in range(sz - 1):
            tempMin, tempMax = min(nums[idx], nums[idx + 1]), max(nums[idx], nums[idx + 1])
            if minimum < tempMin: finalValue = max(finalValue, originalValue + (tempMin - minimum) * 2)
            if tempMax < maximum: finalValue = max(finalValue, originalValue + (maximum - tempMax) * 2)
            minimum = min(minimum, tempMax)
            maximum = max(maximum, tempMax)
        return finalValue
"
3144,python3,reverse-subarray-to-maximize-array-value,"class Solution:
    def maxValueAfterReverse(self, nums: List[int]) -> int:
        originalValue, sz = 0, len(nums)
        for idx in range(sz - 1):
            originalValue += abs(nums[idx] - nums[idx + 1])
        finalValue = originalValue
        for idx in range(1, sz - 1):
            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx + 1]) + abs(nums[idx + 1] - nums[0]))
            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx - 1]) + abs(nums[idx - 1] - nums[sz - 1]))
        minimum, maximum = inf, -inf
        for idx in range(sz - 1):
            tempMin, tempMax = min(nums[idx], nums[idx + 1]), max(nums[idx], nums[idx + 1])
            if minimum < tempMin: finalValue = max(finalValue, originalValue + (tempMin - minimum) * 2)
            if tempMax < maximum: finalValue = max(finalValue, originalValue + (maximum - tempMax) * 2)
            minimum = min(minimum, tempMax)
            maximum = max(maximum, tempMax)
        return finalValue",None,"class Solution:
    def maxValueAfterReverse(self, nums: List[int]) -> int:
        originalValue, sz = 0, len(nums)
        for idx in range(sz - 1):
            originalValue += abs(nums[idx] - nums[idx + 1])
        finalValue = originalValue
        for idx in range(1, sz - 1):
            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx + 1]) + abs(nums[0] - nums[idx + 1]))
            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx - 1]) + abs(nums[sz - 1] - nums[idx - 1]))
        minimum, maximum = float('inf'), float('-inf')
        for idx in range(sz - 1):
            tempMin, tempMax = min(nums[idx], nums[idx + 1]), max(nums[idx], nums[idx + 1])
            if minimum < tempMin: finalValue = max(finalValue, originalValue + (tempMin - minimum) * 2)
            if tempMax < maximum: finalValue = max(finalValue, originalValue + (maximum - tempMax) * 2)
            minimum = min(minimum, tempMin)
            maximum = max(maximum, tempMax)
        return finalValue
"
3144,python3,reverse-subarray-to-maximize-array-value,"class Solution:
    def maxValueAfterReverse(self, nums: List[int]) -> int:
        originalValue, sz = 0, len(nums)
        for idx in range(sz - 1):
            originalValue += abs(nums[idx] - nums[idx + 1])
        finalValue = originalValue
        for idx in range(1, sz - 1):
            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx + 1]) + abs(nums[idx + 1] - nums[0]))
            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx - 1]) + abs(nums[idx - 1] - nums[sz - 1]))
        minimum, maximum = inf, -inf
        for idx in range(sz - 1):
            tempMin, tempMax = min(nums[idx], nums[idx + 1]), max(nums[idx], nums[idx + 1])
            if minimum < tempMin: finalValue = max(finalValue, originalValue + (tempMin - minimum) * 2)
            if tempMax < maximum: finalValue = max(finalValue, originalValue + (maximum - tempMax) * 2)
            minimum = min(minimum, tempMax)
            maximum = max(maximum, tempMax)
        return finalValue",None,"class Solution:
    def maxValueAfterReverse(self, nums: List[int]) -> int:
        originalValue, sz = 0, len(nums)
        for idx in range(sz - 1):
            originalValue += abs(nums[idx] - nums[idx + 1])
        finalValue = originalValue
        for idx in range(1, sz - 1):
            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx + 1]) + abs(nums[idx + 1] - nums[0]))
            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx - 1]) + abs(nums[0] - nums[sz - 1]))
        minimum, maximum = inf, -inf
        for idx in range(sz - 1):
            tempMin, tempMax = min(nums[idx], nums[idx + 1]), max(nums[idx], nums[idx + 1])
            if minimum < tempMin: finalValue = max(finalValue, originalValue + (tempMin - minimum) * 2)
            if tempMax < maximum: finalValue = max(finalValue, originalValue + (maximum - tempMax) * 2)
            minimum = min(minimum, tempMax)
            maximum = max(maximum, tempMax)
        return finalValue
"
3145,python3,make-costs-of-paths-equal-in-a-binary-tree,"class Solution:
    def minIncrements(self, n: int, cost: List[int]) -> int:

        ans = 0
        n//=2                                            

        for i in reversed(range(n)):
        
            mn, mx = sorted((cost[2*i+1], cost[2*i]))     

            ans+= mx - mn
            cost[i]+= mx

        return ans",None,"class Solution:
    def minIncrements(self, n: int, cost: List[int]) -> int:

        ans = 0
        n//=2                                            

        for i in reversed(range(n)):
        
            mn, mx = sorted((cost[2*i], cost[2*i+1]))     

            ans+= mx - mn
            cost[i]+= mx

        return ans
"
3145,python3,make-costs-of-paths-equal-in-a-binary-tree,"class Solution:
    def minIncrements(self, n: int, cost: List[int]) -> int:

        ans = 0
        n//=2                                            

        for i in reversed(range(n)):
        
            mn, mx = sorted((cost[2*i+1], cost[2*i]))     

            ans+= mx - mn
            cost[i]+= mx

        return ans",None,"class Solution:
    def minIncrements(self, n: int, cost: List[int]) -> int:

        ans = 0
        n//=2                                            

        for i in reversed(range(n)):
        
            mn, mx = sorted((cost[2*i], cost[2*i+1]))     

            ans+= mx - mn
            cost[i]+= mn

        return ans
"
3145,python3,make-costs-of-paths-equal-in-a-binary-tree,"class Solution:
    def minIncrements(self, n: int, cost: List[int]) -> int:

        ans = 0
        n//=2                                            

        for i in reversed(range(n)):
        
            mn, mx = sorted((cost[2*i+1], cost[2*i]))     

            ans+= mx - mn
            cost[i]+= mx

        return ans",None,"class Solution:
    def minIncrements(self, n: int, cost: List[int]) -> int:

        ans = 0
        n//=2                                            

        for i in reversed(range(n)):
        
            mn, mx = sorted((cost[2*i], cost[2*i+1]))     

            ans+= mx - mn
            cost[i]+= mx

        return ans
"
3146,python3,minimum-difference-between-highest-and-lowest-of-k-scores,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        l, r = 0, k
        res = float(""inf"")
        while r < len(nums):
            res = min(res, nums[r] - nums[l])
            r += 1
            l += 1
        return res",None,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        l, r = 0, k-1
        res = float(""inf"")
        while r < len(nums):
            res = min(res, nums[r] - nums[l])
            r += 1
            l += 1
        return res
"
3146,python3,minimum-difference-between-highest-and-lowest-of-k-scores,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        l, r = 0, k
        res = float(""inf"")
        while r < len(nums):
            res = min(res, nums[r] - nums[l])
            r += 1
            l += 1
        return res",None,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        l, r = 0, k - 1
        res = float(""inf"")
        while r < len(nums):
            res = min(res, nums[r] - nums[l])
            r += 1
            l += 1
        return res
"
3146,python3,minimum-difference-between-highest-and-lowest-of-k-scores,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        l, r = 0, k
        res = float(""inf"")
        while r < len(nums):
            res = min(res, nums[r] - nums[l])
            r += 1
            l += 1
        return res",None,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        l, r = 0, k - 1
        res = float(""inf"")
        while r < len(nums):
            res = min(res, nums[r] - nums[l])
            r += 1
            l += 1
        return res
"
3147,python3,partition-string-into-substrings-with-values-at-most-k,"class Solution:
    def minimumPartition(self, s: str, k: int) -> int:
        curr, ans = 0, 1
        for d in s:
            if int(d) > k:
                return -1
            curr = 10 * curr + int(d)
            if curr > k:
                ans += 1
                curr = int(d)
        return curr",None,"class Solution:
    def minimumPartition(self, s: str, k: int) -> int:
        curr, ans = 0, 1
        for d in s:
            if int(d) > k:
                return -1
            curr = 10 * curr + int(d)
            if curr > k:
                ans += 1
                curr = int(d)
        return ans
"
3147,python3,partition-string-into-substrings-with-values-at-most-k,"class Solution:
    def minimumPartition(self, s: str, k: int) -> int:
        curr, ans = 0, 1
        for d in s:
            if int(d) > k:
                return -1
            curr = 10 * curr + int(d)
            if curr > k:
                ans += 1
                curr = int(d)
        return curr",None,"class Solution:
    def minimumPartition(self, s: str, k: int) -> int:
        curr, ans = 0, 1
        for d in s:
            if int(d) > k:
                return -1
            curr = 10 * curr + int(d)
            if curr > k:
                ans += 1
                curr = int(d)
        return ans
"
3147,python3,partition-string-into-substrings-with-values-at-most-k,"class Solution:
    def minimumPartition(self, s: str, k: int) -> int:
        curr, ans = 0, 1
        for d in s:
            if int(d) > k:
                return -1
            curr = 10 * curr + int(d)
            if curr > k:
                ans += 1
                curr = int(d)
        return curr",None,"class Solution:
    def minimumPartition(self, s: str, k: int) -> int:
        curr, ans = 0, 1
        for d in s:
            if int(d) > k:
                return -1
            curr = 10 * curr + int(d)
            if curr > k:
                ans += 1
                curr = int(d)
        return ans
"
3148,python3,maximum-depth-of-binary-tree,"class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        stack = [[root, 1]]
        res = 0

        while stack:
            node, depth = stack.pop()

            if node:
                res = max(res, depth)
                stack.append([node.left, depth + 1])
                stack.append([node.right, depth])

        return res",None,"class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        stack = [[root, 1]]
        res = 0

        while stack:
            node, depth = stack.pop()

            if node:
                res = max(res, depth)
                stack.append([node.left, depth + 1])
                stack.append([node.right, depth + 1])

        return res
"
3148,python3,maximum-depth-of-binary-tree,"class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        stack = [[root, 1]]
        res = 0

        while stack:
            node, depth = stack.pop()

            if node:
                res = max(res, depth)
                stack.append([node.left, depth + 1])
                stack.append([node.right, depth])

        return res",None,"class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        stack = [[root, 1]]
        res = 0

        while stack:
            node, depth = stack.pop()

            if node:
                res = max(res, depth)
                stack.append([node.left, depth + 1])
                stack.append([node.right, depth + 1])

        return res
"
3148,python3,maximum-depth-of-binary-tree,"class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        stack = [[root, 1]]
        res = 0

        while stack:
            node, depth = stack.pop()

            if node:
                res = max(res, depth)
                stack.append([node.left, depth + 1])
                stack.append([node.right, depth])

        return res",None,"class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        stack = [[root, 1]]
        res = 0

        while stack:
            node, depth = stack.pop()

            if node:
                res = max(res, depth)
                stack.append([node.left, depth + 1])
                stack.append([node.right, depth + 1])  # Corrected node.right depth from 'depth' to 'depth + 1'

        return res
"
3149,python3,making-file-names-unique,"from typing import List

class Solution:
    def getFolderNames(self, names: List[str]) -> List[str]:
        ans = []  
        seen = {}

        for name in names:
            if name not in seen:
                ans.append(name)
                seen[name] = 0
            else:
                k = seen[name]
                while True:
                    new_name = name + '(' + str(k) + ')'
                    if new_name not in seen:
                        ans.append(new_name)
                        seen[new_name] = 1
                        break
                    else:
                        k += 1
                seen[name] = k
        return ans",None,"from typing import List

class Solution:
    def getFolderNames(self, names: List[str]) -> List[str]:
        ans = []  
        seen = {}

        for name in names:
            if name not in seen:
                ans.append(name)
                seen[name] = 1
            else:
                k = seen[name]
                while True:
                    new_name = name + '(' + str(k) + ')'
                    if new_name not in seen:
                        ans.append(new_name)
                        seen[new_name] = 1
                        break
                    else:
                        k += 1
                seen[name] = k
        return ans
"
3149,python3,making-file-names-unique,"from typing import List

class Solution:
    def getFolderNames(self, names: List[str]) -> List[str]:
        ans = []  
        seen = {}

        for name in names:
            if name not in seen:
                ans.append(name)
                seen[name] = 0
            else:
                k = seen[name]
                while True:
                    new_name = name + '(' + str(k) + ')'
                    if new_name not in seen:
                        ans.append(new_name)
                        seen[new_name] = 1
                        break
                    else:
                        k += 1
                seen[name] = k
        return ans",None,"from typing import List

class Solution:
    def getFolderNames(self, names: List[str]) -> List[str]:
        ans = []  
        seen = {}

        for name in names:
            if name not in seen:
                ans.append(name)
                seen[name] = 1
            else:
                k = seen[name]
                while True:
                    new_name = name + '(' + str(k) + ')'
                    if new_name not in seen:
                        ans.append(new_name)
                        seen[new_name] = 0
                        break
                    else:
                        k += 1
                seen[name] = k
        return ans
"
3149,python3,making-file-names-unique,"from typing import List

class Solution:
    def getFolderNames(self, names: List[str]) -> List[str]:
        ans = []  
        seen = {}

        for name in names:
            if name not in seen:
                ans.append(name)
                seen[name] = 0
            else:
                k = seen[name]
                while True:
                    new_name = name + '(' + str(k) + ')'
                    if new_name not in seen:
                        ans.append(new_name)
                        seen[new_name] = 1
                        break
                    else:
                        k += 1
                seen[name] = k
        return ans",None,"from typing import List

class Solution:
    def getFolderNames(self, names: List[str]) -> List[str]:
        ans = []  
        seen = {}

        for name in names:
            if name not in seen:
                ans.append(name)
                seen[name] = 1
            else:
                k = seen[name]
                while True:
                    new_name = name + '(' + str(k) + ')'
                    if new_name not in seen:
                        ans.append(new_name)
                        seen[new_name] = 1
                        break
                    else:
                        k += 1
                seen[name] = k
        return ans
"
3150,python3,find-peak-element,"class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        n=len(nums)
        low=0
        high=n
        if n==1:
            return 0
        
        while low<=high:
            mid=(low+high)//2
            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n-1 or nums[mid]>=nums[mid+1]) :
                return mid
            elif nums[mid]<=nums[mid+1]:
                high=mid+1
            else:
                low=mid-1
        return -1",None,"class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        n=len(nums)
        low=0
        high=n-1
        if n==1:
            return 0

        while low<=high:
            mid=(low+high)//2
            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n-1 or nums[mid]>=nums[mid+1]):
                return mid
            elif mid < n-1 and nums[mid]<=nums[mid+1]:
                low = mid + 1
            else:
                high = mid - 1
        return -1
"
3150,python3,find-peak-element,"class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        n=len(nums)
        low=0
        high=n
        if n==1:
            return 0
        
        while low<=high:
            mid=(low+high)//2
            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n-1 or nums[mid]>=nums[mid+1]) :
                return mid
            elif nums[mid]<=nums[mid+1]:
                high=mid+1
            else:
                low=mid-1
        return -1",None,"class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        n=len(nums)
        low=0
        high=n-1
        if n==1:
            return 0
        
        while low<=high:
            mid=(low+high)//2
            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n-1 or nums[mid]>=nums[mid+1]) :
                return mid
            elif nums[mid]<=nums[mid+1]:
                low=mid+1
            else:
                high=mid-1
        return -1
"
3150,python3,find-peak-element,"class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        n=len(nums)
        low=0
        high=n
        if n==1:
            return 0
        
        while low<=high:
            mid=(low+high)//2
            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n-1 or nums[mid]>=nums[mid+1]) :
                return mid
            elif nums[mid]<=nums[mid+1]:
                high=mid+1
            else:
                low=mid-1
        return -1",None,"class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        n=len(nums)
        low=0
        high=n-1
        if n==1:
            return 0
        
        while low<=high:
            mid=(low+high)//2
            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n-1 or nums[mid]>=nums[mid+1]) :
                return mid
            elif mid+1<n and nums[mid]<=nums[mid+1]:
                low=mid+1
            else:
                high=mid-1
        return -1
"
3151,python3,longest-cycle-in-a-graph,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        n=len(edges)
        bl=[0]*n
        mp=defaultdict(int)
        mx=-1
        for i in range(n):
            if(bl[i]==0):
                x=i
                l=0
                st=set()
                while x>-1 and bl[x]==0:
                    bl[x]=0
                    mp[x]=l
                    l+=1
                    st.add(x)
                    x=edges[x]
                if(x!=-1 and x in st): mx=max(mx,l-mp[x])
        return mx",None,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        n=len(edges)
        bl=[0]*n
        mp=defaultdict(int)
        mx=-1
        for i in range(n):
            if(bl[i]==0):
                x=i
                l=0
                st=set()
                while x>-1 and bl[x]==0:
                    bl[x]=1
                    mp[x]=l
                    l+=1
                    st.add(x)
                    x=edges[x]
                if(x!=-1 and x in st): mx=max(mx,l-mp[x])
        return mx
"
3151,python3,longest-cycle-in-a-graph,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        n=len(edges)
        bl=[0]*n
        mp=defaultdict(int)
        mx=-1
        for i in range(n):
            if(bl[i]==0):
                x=i
                l=0
                st=set()
                while x>-1 and bl[x]==0:
                    bl[x]=0
                    mp[x]=l
                    l+=1
                    st.add(x)
                    x=edges[x]
                if(x!=-1 and x in st): mx=max(mx,l-mp[x])
        return mx",None,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        n=len(edges)
        bl=[0]*n
        mp=defaultdict(int)
        mx=-1
        for i in range(n):
            if(bl[i]==0):
                x=i
                l=0
                st=set()
                while x>-1 and bl[x]==0:
                    bl[x]=1
                    mp[x]=l
                    l+=1
                    st.add(x)
                    x=edges[x]
                if(x!=-1 and x in st): mx=max(mx,l-mp[x])
        return mx
"
3151,python3,longest-cycle-in-a-graph,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        n=len(edges)
        bl=[0]*n
        mp=defaultdict(int)
        mx=-1
        for i in range(n):
            if(bl[i]==0):
                x=i
                l=0
                st=set()
                while x>-1 and bl[x]==0:
                    bl[x]=0
                    mp[x]=l
                    l+=1
                    st.add(x)
                    x=edges[x]
                if(x!=-1 and x in st): mx=max(mx,l-mp[x])
        return mx",None,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        n=len(edges)
        bl=[0]*n
        mp=defaultdict(int)
        mx=-1
        for i in range(n):
            if(bl[i]==0):
                x=i
                l=0
                st=set()
                while x>-1 and bl[x]==0:
                    bl[x]=1
                    mp[x]=l
                    l+=1
                    st.add(x)
                    x=edges[x]
                if(x!=-1 and x in st): mx=max(mx,l-mp[x])
        return mx
"
3152,python3,best-time-to-buy-and-sell-stock-ii,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) < 2:
            return 0
        if len(prices) == 2:
            output = prices[1] - prices[0]
            return output if output > 0 else 0
        i = 0
        j = 1
        stockBuy = prices[i]
        stockSell = prices[j]
        counter = 0
        profit = 0
        while counter < len(prices)-2:
            if stockSell - stockBuy < 0:
                i = counter + 1
                j = i + 1
            else:
                if prices[j+1] > prices[j]:
                    j += 1
                else:
                    profit = profit + (stockSell - stockBuy)
                    i = counter
                    j = i + 1

            stockSell = prices[j]
            stockBuy = prices[i]
            counter += 1
        if (stockSell - stockBuy) > 0:
            profit = profit + (stockSell - stockBuy)
        return profit",None,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) < 2:
            return 0
        profit = 0
        for i in range(1,len(prices)):
            if prices[i] > prices[i-1]:
                profit += prices[i] - prices[i-1]
        return profit
"
3152,python3,best-time-to-buy-and-sell-stock-ii,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) < 2:
            return 0
        if len(prices) == 2:
            output = prices[1] - prices[0]
            return output if output > 0 else 0
        i = 0
        j = 1
        stockBuy = prices[i]
        stockSell = prices[j]
        counter = 0
        profit = 0
        while counter < len(prices)-2:
            if stockSell - stockBuy < 0:
                i = counter + 1
                j = i + 1
            else:
                if prices[j+1] > prices[j]:
                    j += 1
                else:
                    profit = profit + (stockSell - stockBuy)
                    i = counter
                    j = i + 1

            stockSell = prices[j]
            stockBuy = prices[i]
            counter += 1
        if (stockSell - stockBuy) > 0:
            profit = profit + (stockSell - stockBuy)
        return profit",None,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) < 2:
            return 0
        
        profit = 0
        for i in range(1, len(prices)):
            if prices[i] > prices[i-1]:
                profit += prices[i] - prices[i-1]
        
        return profit
"
3152,python3,best-time-to-buy-and-sell-stock-ii,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) < 2:
            return 0
        if len(prices) == 2:
            output = prices[1] - prices[0]
            return output if output > 0 else 0
        i = 0
        j = 1
        stockBuy = prices[i]
        stockSell = prices[j]
        counter = 0
        profit = 0
        while counter < len(prices)-2:
            if stockSell - stockBuy < 0:
                i = counter + 1
                j = i + 1
            else:
                if prices[j+1] > prices[j]:
                    j += 1
                else:
                    profit = profit + (stockSell - stockBuy)
                    i = counter
                    j = i + 1

            stockSell = prices[j]
            stockBuy = prices[i]
            counter += 1
        if (stockSell - stockBuy) > 0:
            profit = profit + (stockSell - stockBuy)
        return profit",None,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        profit = 0
        for i in range(1, len(prices)):
            if prices[i] > prices[i-1]:
                profit += prices[i] - prices[i-1]
        return profit
"
3403,python3,last-moment-before-all-ants-fall-out-of-a-plank,"class Solution:
    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:
        return max(max(left, default=0), n - max(right, default=n))",None,"class Solution:
    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:
        return max(max(left, default=0), n - min(right, default=n))
"
3403,python3,last-moment-before-all-ants-fall-out-of-a-plank,"class Solution:
    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:
        return max(max(left, default=0), n - max(right, default=n))",None,"class Solution:
    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:
        return max(max(left, default=0), n - min(right, default=n))
"
3403,python3,last-moment-before-all-ants-fall-out-of-a-plank,"class Solution:
    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:
        return max(max(left, default=0), n - max(right, default=n))",None,"class Solution:
    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:
        return max(max(left, default=0), n - min(right, default=n))
"
3404,python3,n-th-tribonacci-number,"class Solution:
    def tribonacci(self, n: int) -> int:
        if n==0:return 0
        d=[0]*(3)
        d[0]=0
        d[1]=d[2]=1
        for i in range(3,n+1):
            d.append(sum(d[1:]))
            d.pop(0)
        return d[2]",None,"class Solution:
    def tribonacci(self, n: int) -> int:
        if n == 0: return 0
        if n <= 2: return 1
        d = [0, 1, 1]
        for i in range(3, n + 1):
            d.append(sum(d))
            d.pop(0)
        return d[-1]
"
3404,python3,n-th-tribonacci-number,"class Solution:
    def tribonacci(self, n: int) -> int:
        if n==0:return 0
        d=[0]*(3)
        d[0]=0
        d[1]=d[2]=1
        for i in range(3,n+1):
            d.append(sum(d[1:]))
            d.pop(0)
        return d[2]",None,"class Solution:
    def tribonacci(self, n: int) -> int:
        if n==0:
            return 0
        if n==1 or n==2:
            return 1
        d=[0]*(3)
        d[0]=0
        d[1]=d[2]=1
        for i in range(3,n+1):
            d.append(sum(d))
            d.pop(0)
        return d[-1]
"
3404,python3,n-th-tribonacci-number,"class Solution:
    def tribonacci(self, n: int) -> int:
        if n==0:return 0
        d=[0]*(3)
        d[0]=0
        d[1]=d[2]=1
        for i in range(3,n+1):
            d.append(sum(d[1:]))
            d.pop(0)
        return d[2]",None,"class Solution:
    def tribonacci(self, n: int) -> int:
        if n==0: return 0
        if n==1 or n==2: return 1
        d=[0]*(3)
        d[0]=0
        d[1]=d[2]=1
        for i in range(3,n+1):
            d.append(sum(d[:]))
            d.pop(0)
        return d[2]
"
3405,python3,sort-an-array,"class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        return nums+1",None,"class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        return nums
"
3405,python3,sort-an-array,"class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        return nums+1",None,"class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        return nums
"
3405,python3,sort-an-array,"class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        return nums+1",None,"class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        if len(nums)<=1:
            return nums       
        pivot = nums[len(nums) // 2]
        left = [x for x in nums if x < pivot]
        middle = [x for x in nums if x == pivot]
        right = [x for x in nums if x > pivot]
        return self.sortArray(left) + middle + self.sortArray(right)
"
3406,python3,online-election,"class TopVotedCandidate:

    def __init__(self, persons: List[int], times: List[int]):
        self.persons = []
        self.times = []
        self.dic = collections.defaultdict(int)
        self.m = 0
        self.idx = -1

        for i in range(len(times)):
            self.times.append(times[i])
            self.dic[persons[i]] += 1
            if self.dic[persons[i]] >= self.m:
                self.persons.append(persons[i])
                self.m = self.dic[persons[i]]
            else:
                self.persons.append(self.persons[-1])

    def q(self, t: int) -> int:
        idx = bisect.bisect_right(self.times,t)
        return self.persons[idx]",None,"class TopVotedCandidate:

    def __init__(self, persons: List[int], times: List[int]):
        self.persons = []
        self.times = []
        self.dic = collections.defaultdict(int)
        self.m = 0
        self.idx = -1

        for i in range(len(times)):
            self.times.append(times[i])
            self.dic[persons[i]] += 1
            if self.dic[persons[i]] >= self.m:
                self.persons.append(persons[i])
                self.m = self.dic[persons[i]]
            else:
                self.persons.append(self.persons[-1])

    def q(self, t: int) -> int:
        idx = bisect.bisect_right(self.times, t)
        return self.persons[idx - 1]  # We need to look at the person chosen at index idx - 1 because a leading person is determined by the votes cast at time t or earlier.
"
3406,python3,online-election,"class TopVotedCandidate:

    def __init__(self, persons: List[int], times: List[int]):
        self.persons = []
        self.times = []
        self.dic = collections.defaultdict(int)
        self.m = 0
        self.idx = -1

        for i in range(len(times)):
            self.times.append(times[i])
            self.dic[persons[i]] += 1
            if self.dic[persons[i]] >= self.m:
                self.persons.append(persons[i])
                self.m = self.dic[persons[i]]
            else:
                self.persons.append(self.persons[-1])

    def q(self, t: int) -> int:
        idx = bisect.bisect_right(self.times,t)
        return self.persons[idx]",None,"class TopVotedCandidate:

    def __init__(self, persons: List[int], times: List[int]):
        self.persons = []
        self.times = []
        self.dic = collections.defaultdict(int)
        self.m = 0
        self.idx = -1

        for i in range(len(times)):
            self.times.append(times[i])
            self.dic[persons[i]] += 1
            if self.dic[persons[i]] >= self.m:
                self.persons.append(persons[i])
                self.m = self.dic[persons[i]]
            else:
                self.persons.append(self.persons[-1])

    def q(self, t: int) -> int:
        idx = bisect.bisect_right(self.times,t)
        return self.persons[idx-1]
"
3406,python3,online-election,"class TopVotedCandidate:

    def __init__(self, persons: List[int], times: List[int]):
        self.persons = []
        self.times = []
        self.dic = collections.defaultdict(int)
        self.m = 0
        self.idx = -1

        for i in range(len(times)):
            self.times.append(times[i])
            self.dic[persons[i]] += 1
            if self.dic[persons[i]] >= self.m:
                self.persons.append(persons[i])
                self.m = self.dic[persons[i]]
            else:
                self.persons.append(self.persons[-1])

    def q(self, t: int) -> int:
        idx = bisect.bisect_right(self.times,t)
        return self.persons[idx]",None,"class TopVotedCandidate:

    def __init__(self, persons: List[int], times: List[int]):
        self.persons = []
        self.times = []
        self.dic = collections.defaultdict(int)
        self.m = 0
        self.idx = -1

        for i in range(len(times)):
            self.times.append(times[i])
            self.dic[persons[i]] += 1
            if self.dic[persons[i]] >= self.m:
                self.persons.append(persons[i])
                self.m = self.dic[persons[i]]
            else:
                self.persons.append(self.persons[-1])

    def q(self, t: int) -> int:
        idx = bisect.bisect_right(self.times,t)
        return self.persons[idx-1]
"
3407,python3,arithmetic-slices-ii-subsequence,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        total, n = 0, len(nums)
        dp = [defaultdict(int) for _ in nums]
        for i in range(1, n):
            for j in range(i):
                diff = nums[j] - nums[i]
                dp[i][diff] = dp[j][diff] + 1
                total += dp[j][diff]
        return total",None,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        total = 0
        n = len(nums)
        dp = [defaultdict(int) for _ in nums]
        for i in range(n):
            for j in range(i):
                diff = nums[i] - nums[j]
                dp[i][diff] += dp[j][diff] + 1
                if diff in dp[j]:
                    total += dp[j][diff]
        return total
"
3407,python3,arithmetic-slices-ii-subsequence,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        total, n = 0, len(nums)
        dp = [defaultdict(int) for _ in nums]
        for i in range(1, n):
            for j in range(i):
                diff = nums[j] - nums[i]
                dp[i][diff] = dp[j][diff] + 1
                total += dp[j][diff]
        return total",None,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        total, n = 0, len(nums)
        dp = [defaultdict(int) for _ in nums]
        for i in range(n):
            for j in range(i):
                diff = nums[i] - nums[j]
                dp[i][diff] += dp[j][diff] + 1
                total += dp[j][diff]
        return total
"
3407,python3,arithmetic-slices-ii-subsequence,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        total, n = 0, len(nums)
        dp = [defaultdict(int) for _ in nums]
        for i in range(1, n):
            for j in range(i):
                diff = nums[j] - nums[i]
                dp[i][diff] = dp[j][diff] + 1
                total += dp[j][diff]
        return total",None,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        total, n = 0, len(nums)
        dp = [defaultdict(int) for _ in nums]
        for i in range(n):
            for j in range(i):
                diff = nums[i] - nums[j]
                dp[i][diff] += dp[j][diff] + 1
                if diff in dp[j]:
                    total += dp[j][diff]
        return total
"
3408,python3,maximize-the-minimum-powered-city,"class Solution:
    def maxPower(self, stations: List[int], r: int, k: int) -> int:
        start, end = min(stations), sum(stations) + k
        while start + 1 < end:
            mid = (start + end) // 2
            if self.check(stations, r, k, mid):
                start = mid
            else:
                end = mid
        if self.check(stations, r, k, end):
            return end
        else:
            return start
    
    def check(self, stations, r, k, target):
            n = len(stations)
            ans = True
            newStations = defaultdict(int)
            power = sum(stations[ : r])
            for i in range(n):
                if i + r < n:
                    power += stations[i + r]
                if i - r - 1 >= 0:
                    power -= stations[i - r - 1]
                if power >= target:
                    continue
                elif power + k < target:
                    ans = False
                    break
                else:
                    diff = target - power
                    power = target
                    stations[min(i + r, n - 1)] -= diff
                    k -= diff
                    newStations[min(i + r, n - 1)] += diff
            for i in newStations:
                stations[i] -= newStations[i]
            return ans",None,"class Solution:
    def maxPower(self, stations: List[int], r: int, k: int) -> int:
        start, end = min(stations), sum(stations) + k
        while start + 1 < end:
            mid = (start + end) // 2
            if self.check(list(stations), r, k, mid):
                start = mid
            else:
                end = mid
        if self.check(stations, r, k, end):
            return end
        else:
            return start
    
    def check(self, stations, r, k, target):
        n = len(stations)
        ans = True
        newStations = defaultdict(int)
        power = sum(stations[ : r])
        for i in range(n):
            if i + r < n:
                power += stations[i + r]
            if i - r - 1 >= 0:
                power -= stations[i - r - 1]
            if power >= target:
                continue
            elif power + k < target:
                ans = False
                break
            else:
                diff = target - power
                power = target
                stations[min(i + r, n - 1)] -= diff
                k -= diff
                newStations[min(i + r, n - 1)] += diff
        for i in newStations:
            stations[i] -= newStations[i]
        return ans
"
3408,python3,maximize-the-minimum-powered-city,"class Solution:
    def maxPower(self, stations: List[int], r: int, k: int) -> int:
        start, end = min(stations), sum(stations) + k
        while start + 1 < end:
            mid = (start + end) // 2
            if self.check(stations, r, k, mid):
                start = mid
            else:
                end = mid
        if self.check(stations, r, k, end):
            return end
        else:
            return start
    
    def check(self, stations, r, k, target):
            n = len(stations)
            ans = True
            newStations = defaultdict(int)
            power = sum(stations[ : r])
            for i in range(n):
                if i + r < n:
                    power += stations[i + r]
                if i - r - 1 >= 0:
                    power -= stations[i - r - 1]
                if power >= target:
                    continue
                elif power + k < target:
                    ans = False
                    break
                else:
                    diff = target - power
                    power = target
                    stations[min(i + r, n - 1)] -= diff
                    k -= diff
                    newStations[min(i + r, n - 1)] += diff
            for i in newStations:
                stations[i] -= newStations[i]
            return ans",None,"class Solution:
    def maxPower(self, stations: List[int], r: int, k: int) -> int:
        start, end = min(stations), sum(stations) + k
        while start + 1 < end:
            mid = (start + end) // 2
            if self.check(stations[:], r, k, mid): # Ensure to make a copy of stations list
                start = mid
            else:
                end = mid
        if self.check(stations[:], r, k, end): # Ensure to make a copy of stations list
            return end
        else:
            return start
    
    def check(self, stations, r, k, target):
            n = len(stations)
            ans = True
            newStations = defaultdict(int)
            power = sum(stations[ : r])
            for i in range(n):
                if i + r < n:
                    power += stations[i + r]
                if i - r - 1 >= 0:
                    power -= stations[i - r - 1]
                if power >= target:
                    continue
                elif power + k < target:
                    ans = False
                    break
                else:
                    diff = target - power
                    power = target
                    stations[min(i + r, n - 1)] += diff # Here we should increase the power station
                    k -= diff
                    newStations[min(i + r, n - 1)] += diff
            for i in newStations:
                stations[i] -= newStations[i]
            return ans
"
3408,python3,maximize-the-minimum-powered-city,"class Solution:
    def maxPower(self, stations: List[int], r: int, k: int) -> int:
        start, end = min(stations), sum(stations) + k
        while start + 1 < end:
            mid = (start + end) // 2
            if self.check(stations, r, k, mid):
                start = mid
            else:
                end = mid
        if self.check(stations, r, k, end):
            return end
        else:
            return start
    
    def check(self, stations, r, k, target):
            n = len(stations)
            ans = True
            newStations = defaultdict(int)
            power = sum(stations[ : r])
            for i in range(n):
                if i + r < n:
                    power += stations[i + r]
                if i - r - 1 >= 0:
                    power -= stations[i - r - 1]
                if power >= target:
                    continue
                elif power + k < target:
                    ans = False
                    break
                else:
                    diff = target - power
                    power = target
                    stations[min(i + r, n - 1)] -= diff
                    k -= diff
                    newStations[min(i + r, n - 1)] += diff
            for i in newStations:
                stations[i] -= newStations[i]
            return ans",None,"class Solution:
    def maxPower(self, stations: List[int], r: int, k: int) -> int:
        start, end = min(stations), sum(stations) + k
        while start + 1 < end:
            mid = (start + end) // 2
            if self.check(stations.copy(), r, k, mid):
                start = mid
            else:
                end = mid
        if self.check(stations.copy(), r, k, end):
            return end
        else:
            return start

    def check(self, stations, r, k, target):
        n = len(stations)
        ans = True
        newStations = defaultdict(int)
        power = sum(stations[: r])
        for i in range(n):
            if i + r < n:
                power += stations[i + r]
            if i - r - 1 >= 0:
                power -= stations[i - r - 1]
            if power >= target:
                continue
            elif power + k < target:
                ans = False
                break
            else:
                diff = target - power
                power = target
                stations[min(i + r, n - 1)] += diff
                k -= diff
                newStations[min(i + r, n - 1)] += diff
        for i in newStations:
            stations[i] -= newStations[i]
        return ans
"
3409,python3,baseball-game,"class Solution:
    def calPoints(self, operations: List[str]) -> int:
        stack=[]
        for i in operations:
            if i =='D':
                stack.append(2*stack[-1])
            elif i=='C':
                stack.pop()
            elif i=='+':
                stack.append(stack[-1]+stack[-2])
            else:
                stack.append(int(i))
        return sum(stack[0])",None,"class Solution:
    def calPoints(self, operations: List[str]) -> int:
        stack=[]
        for i in operations:
            if i =='D':
                stack.append(2*stack[-1])
            elif i=='C':
                stack.pop()
            elif i=='+':
                stack.append(stack[-1]+stack[-2])
            else:
                stack.append(int(i))
        return sum(stack)
"
3409,python3,baseball-game,"class Solution:
    def calPoints(self, operations: List[str]) -> int:
        stack=[]
        for i in operations:
            if i =='D':
                stack.append(2*stack[-1])
            elif i=='C':
                stack.pop()
            elif i=='+':
                stack.append(stack[-1]+stack[-2])
            else:
                stack.append(int(i))
        return sum(stack[0])",None,"class Solution:
    def calPoints(self, operations: List[str]) -> int:
        stack=[]
        for i in operations:
            if i =='D':
                stack.append(2*stack[-1])
            elif i=='C':
                stack.pop()
            elif i=='+':
                stack.append(stack[-1]+stack[-2])
            else:
                stack.append(int(i))
        return sum(stack)
"
3409,python3,baseball-game,"class Solution:
    def calPoints(self, operations: List[str]) -> int:
        stack=[]
        for i in operations:
            if i =='D':
                stack.append(2*stack[-1])
            elif i=='C':
                stack.pop()
            elif i=='+':
                stack.append(stack[-1]+stack[-2])
            else:
                stack.append(int(i))
        return sum(stack[0])",None,"class Solution:
    def calPoints(self, operations):
        stack=[]
        for i in operations:
            if i =='D':
                stack.append(2*stack[-1])
            elif i=='C':
                stack.pop()
            elif i=='+':
                stack.append(stack[-1]+stack[-2])
            else:
                stack.append(int(i))
        return sum(stack)
"
3410,python3,count-anagrams,"mod = 10**9+7

class Solution:
    def countAnagrams(self, s: str) -> int:

        l = s.split()
        ans = 1

        for i in l:
            d = {}
            for j in i:
                if(d.get(j)):
                    d[j] += 2
                else:
                    d[j] = 1  
            
            duplicates = 1
            for j in d.values():
                duplicates *= math.factorial(j)
            curr = math.factorial(len(i))//duplicates

            ans *= curr
            ans = ans%mod

        return ans",None,"import math
mod = 10**9+7

class Solution:
    def countAnagrams(self, s: str) -> int:

        l = s.split()
        ans = 1

        for i in l:
            d = {}
            for j in i:
                if(d.get(j)):
                    d[j] += 1
                else:
                    d[j] = 1  
            
            duplicates = 1
            for j in d.values():
                duplicates *= math.factorial(j)
            curr = math.factorial(len(i)) // duplicates

            ans *= curr
            ans = ans % mod

        return ans
"
3410,python3,count-anagrams,"mod = 10**9+7

class Solution:
    def countAnagrams(self, s: str) -> int:

        l = s.split()
        ans = 1

        for i in l:
            d = {}
            for j in i:
                if(d.get(j)):
                    d[j] += 2
                else:
                    d[j] = 1  
            
            duplicates = 1
            for j in d.values():
                duplicates *= math.factorial(j)
            curr = math.factorial(len(i))//duplicates

            ans *= curr
            ans = ans%mod

        return ans",None,"import math

mod = 10**9+7

class Solution:
    def countAnagrams(self, s: str) -> int:

        l = s.split()
        ans = 1

        for i in l:
            d = {}
            for j in i:
                if j in d:
                    d[j] += 1
                else:
                    d[j] = 1  
            
            duplicates = 1
            for j in d.values():
                duplicates *= math.factorial(j)
            curr = math.factorial(len(i))//duplicates

            ans *= curr
            ans = ans%mod
            
        return ans
"
3410,python3,count-anagrams,"mod = 10**9+7

class Solution:
    def countAnagrams(self, s: str) -> int:

        l = s.split()
        ans = 1

        for i in l:
            d = {}
            for j in i:
                if(d.get(j)):
                    d[j] += 2
                else:
                    d[j] = 1  
            
            duplicates = 1
            for j in d.values():
                duplicates *= math.factorial(j)
            curr = math.factorial(len(i))//duplicates

            ans *= curr
            ans = ans%mod

        return ans",None,"import math
mod = 10**9+7

class Solution:
    def countAnagrams(self, s: str) -> int:

        l = s.split()
        ans = 1

        for i in l:
            d = {}
            for j in i:
                if(d.get(j)):
                    d[j] += 1
                else:
                    d[j] = 1  
            
            duplicates = 1
            for j in d.values():
                duplicates *= math.factorial(j)
            curr = math.factorial(len(i))//duplicates

            ans *= curr
            ans = ans%mod

        return ans
"
3411,python3,capitalize-the-title,"class Solution:
    def capitalizeTitle(self, title: str) -> str:
        li = title.split()
        for i,l in enumerate(li):
            if len(l) <= 2:
                li[i] = l.lower()
            else:
                li[i] = l[0].lower() + l[1:].lower()
        return ' '.join(li)",None,"class Solution:
    def capitalizeTitle(self, title: str) -> str:
        li = title.split()
        for i, l in enumerate(li):
            if len(l) <= 2:
                 li[i] = l.lower()
            else:
                 li[i] = l[0].upper() + l[1:].lower()
        return ' '.join(li)
"
3411,python3,capitalize-the-title,"class Solution:
    def capitalizeTitle(self, title: str) -> str:
        li = title.split()
        for i,l in enumerate(li):
            if len(l) <= 2:
                li[i] = l.lower()
            else:
                li[i] = l[0].lower() + l[1:].lower()
        return ' '.join(li)",None,"class Solution:
    def capitalizeTitle(self, title: str) -> str:
        li = title.split()
        for i,l in enumerate(li):
            if len(l) <= 2:
                li[i] = l.lower()
            else:
                li[i] = l[0].upper() + l[1:].lower()
        return ' '.join(li)
"
3411,python3,capitalize-the-title,"class Solution:
    def capitalizeTitle(self, title: str) -> str:
        li = title.split()
        for i,l in enumerate(li):
            if len(l) <= 2:
                li[i] = l.lower()
            else:
                li[i] = l[0].lower() + l[1:].lower()
        return ' '.join(li)",None,"class Solution:
    def capitalizeTitle(self, title: str) -> str:
        li = title.split()
        for i,l in enumerate(li):
            if len(l) <= 2:
                li[i] = l.lower()
            else:
                li[i] = l[0].upper() + l[1:].lower()
        return ' '.join(li)
"
3412,python3,find-all-possible-recipes-from-given-supplies,"class Solution:
    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:
        dct=defaultdict(lambda :[])
        indegree={}
        n=len(recepies)

        for i in recepies:
            indegree[i]=0

        for i in range(n):
            for j in ingredients[i]:
                indegree[j]=0

        for i in range(n):
            for j in ingredients[i]:
                dct[j].append(recepies[i])
                indegree[recepies[i]]+=1

        st=[]
        for i in indegree:
            if indegree[i]==0:
                st.append(i)
        flst=[]
        ans=defaultdict(lambda :[])
        while st:
            x=st.pop(0)
            for i in dct[x]:
                for j in ans[x]:
                    if j not in ans[i]:
                        ans[i].append(j)
                ans[i].append(x)
                indegree[i]-=1
                if indegree[i]==0:
                    st.append(i)
            if x in recepies:
                for k in ans[x]:
                    if k not in supplies:
                        break
                else:
                    flst.append(x)
                    supplies.append(i)

        return flst",None,"class Solution:
    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:
        dct=defaultdict(lambda :[])
        indegree={}
        n=len(recepies)

        for i in recepies:
            indegree[i]=0

        for i in range(n):
            for j in ingredients[i]:
                indegree[j]=0

        for i in range(n):
            for j in ingredients[i]:
                dct[j].append(recepies[i])
                indegree[recepies[i]]+=1

        st=[]
        for i in indegree:
            if indegree[i]==0:
                st.append(i)
        flst=[]
        ans=defaultdict(lambda :[])
        while st:
            x=st.pop(0)
            for i in dct[x]:
                for j in ans[x]:
                    if j not in ans[i]:
                        ans[i].append(j)
                ans[i].append(x)
                indegree[i]-=1
                if indegree[i]==0:
                    st.append(i)
            if x in recepies:
                for k in ans[x]:
                    if k not in supplies:
                        break
                else:
                    flst.append(x)
                    supplies.append(x)

        return flst
"
3412,python3,find-all-possible-recipes-from-given-supplies,"class Solution:
    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:
        dct=defaultdict(lambda :[])
        indegree={}
        n=len(recepies)

        for i in recepies:
            indegree[i]=0

        for i in range(n):
            for j in ingredients[i]:
                indegree[j]=0

        for i in range(n):
            for j in ingredients[i]:
                dct[j].append(recepies[i])
                indegree[recepies[i]]+=1

        st=[]
        for i in indegree:
            if indegree[i]==0:
                st.append(i)
        flst=[]
        ans=defaultdict(lambda :[])
        while st:
            x=st.pop(0)
            for i in dct[x]:
                for j in ans[x]:
                    if j not in ans[i]:
                        ans[i].append(j)
                ans[i].append(x)
                indegree[i]-=1
                if indegree[i]==0:
                    st.append(i)
            if x in recepies:
                for k in ans[x]:
                    if k not in supplies:
                        break
                else:
                    flst.append(x)
                    supplies.append(i)

        return flst",None,"class Solution:
    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:
        dct=defaultdict(lambda :[])
        indegree={}
        n=len(recepies)

        for i in recepies:
            indegree[i]=0

        for i in range(n):
            for j in ingredients[i]:
                indegree[j]=0

        for i in range(n):
            for j in ingredients[i]:
                dct[j].append(recepies[i])
                indegree[recepies[i]]+=1

        st=[]
        for i in indegree:
            if indegree[i]==0:
                st.append(i)
        flst=[]
        ans=defaultdict(lambda :[])
        while st:
            x=st.pop(0)
            for i in dct[x]:
                for j in ans[x]:
                    if j not in ans[i]:
                        ans[i].append(j)
                ans[i].append(x)
                indegree[i]-=1
                if indegree[i]==0:
                    st.append(i)
            if x in recepies:
                for k in ans[x]:
                    if k not in supplies:
                        break
                else:
                    flst.append(x)
                    supplies.append(x)

        return flst
"
3412,python3,find-all-possible-recipes-from-given-supplies,"class Solution:
    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:
        dct=defaultdict(lambda :[])
        indegree={}
        n=len(recepies)

        for i in recepies:
            indegree[i]=0

        for i in range(n):
            for j in ingredients[i]:
                indegree[j]=0

        for i in range(n):
            for j in ingredients[i]:
                dct[j].append(recepies[i])
                indegree[recepies[i]]+=1

        st=[]
        for i in indegree:
            if indegree[i]==0:
                st.append(i)
        flst=[]
        ans=defaultdict(lambda :[])
        while st:
            x=st.pop(0)
            for i in dct[x]:
                for j in ans[x]:
                    if j not in ans[i]:
                        ans[i].append(j)
                ans[i].append(x)
                indegree[i]-=1
                if indegree[i]==0:
                    st.append(i)
            if x in recepies:
                for k in ans[x]:
                    if k not in supplies:
                        break
                else:
                    flst.append(x)
                    supplies.append(i)

        return flst",None,"class Solution:
    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:
        dct=defaultdict(lambda :[])
        indegree={}
        n=len(recipes)

        for i in recipes:
            indegree[i]=0

        for i in range(n):
            for j in ingredients[i]:
                indegree[j]=0

        for i in range(n):
            for j in ingredients[i]:
                dct[j].append(recipes[i])
                indegree[recipes[i]]+=1

        st=[]
        for i in indegree:
            if indegree[i]==0:
                st.append(i)
        flst=[]
        ans=defaultdict(lambda :[])
        while st:
            x=st.pop(0)
            for i in dct[x]:
                for j in ans[x]:
                    if j not in ans[i]:
                        ans[i].append(j)
                ans[i].append(x)
                indegree[i]-=1
                if indegree[i]==0:
                    st.append(i)
            if x in recipes:
                for k in ans[x]:
                    if k not in supplies:
                        break
                else:
                    flst.append(x)
                    supplies.append(x)

        return flst
"
3413,python3,check-whether-two-strings-are-almost-equivalent,"class Solution:
    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:
        A = [0] * 26
        for char in word1: A[ord(char) - ord(""a"")] += 1
        for char in word2: A[ord(char) - ord(""b"")] -= 1
        return not any ([(f < -3 or f > 3) for f in A])",None,"class Solution:
    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:
        A = [0] * 26
        for char in word1: A[ord(char) - ord(""a"")] += 1
        for char in word2: A[ord(char) - ord(""a"")] -= 1
        return not any ([(f < -3 or f > 3) for f in A])
"
3413,python3,check-whether-two-strings-are-almost-equivalent,"class Solution:
    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:
        A = [0] * 26
        for char in word1: A[ord(char) - ord(""a"")] += 1
        for char in word2: A[ord(char) - ord(""b"")] -= 1
        return not any ([(f < -3 or f > 3) for f in A])",None,"class Solution:
    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:
        A = [0] * 26
        for char in word1: A[ord(char) - ord(""a"")] += 1
        for char in word2: A[ord(char) - ord(""a"")] -= 1
        return not any ([(f < -3 or f > 3) for f in A])
"
3413,python3,check-whether-two-strings-are-almost-equivalent,"class Solution:
    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:
        A = [0] * 26
        for char in word1: A[ord(char) - ord(""a"")] += 1
        for char in word2: A[ord(char) - ord(""b"")] -= 1
        return not any ([(f < -3 or f > 3) for f in A])",None,"class Solution:
    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:
        A = [0] * 26
        for char in word1: A[ord(char) - ord(""a"")] += 1
        for char in word2: A[ord(char) - ord(""a"")] -= 1
        return not any ([(f < -3 or f > 3) for f in A])
"
3414,python3,arithmetic-slices-ii-subsequence,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        n = len(nums);ans = 0
        dp = defaultdict(Counter)
        for i in range(1,n):
            for j in range(i):
                d = nums[i] - nums[j]
                dp[i][d] += dp[j][d]
            ans += sum(dp[i].values()) - i
        return ans",None,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        dp = defaultdict(Counter)
        for i in range(n):
            for j in range(i):
                d = nums[i] - nums[j]
                cnt = dp[j][d]
                dp[i][d] += cnt + 1
                ans += cnt
        return ans
"
3414,python3,arithmetic-slices-ii-subsequence,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        n = len(nums);ans = 0
        dp = defaultdict(Counter)
        for i in range(1,n):
            for j in range(i):
                d = nums[i] - nums[j]
                dp[i][d] += dp[j][d]
            ans += sum(dp[i].values()) - i
        return ans",None,"class Solution:
    def numberOfArithmeticSlices(self, nums):
        n = len(nums)
        ans = 0
        dp = [collections.defaultdict(int) for _ in nums]
        for i in range(n):
            for j in range(i):
                d = nums[i] - nums[j]
                dp[i][d] += dp[j][d]
                dp[i][d] += 1
            ans += sum(dp[i].values()) - i
        return ans
"
3414,python3,arithmetic-slices-ii-subsequence,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        n = len(nums);ans = 0
        dp = defaultdict(Counter)
        for i in range(1,n):
            for j in range(i):
                d = nums[i] - nums[j]
                dp[i][d] += dp[j][d]
            ans += sum(dp[i].values()) - i
        return ans",None,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        n = len(nums); ans = 0
        dp = defaultdict(Counter)
        for i in range(n):
            for j in range(i):
                d = nums[i] - nums[j]
                cnt = dp[j][d]
                dp[i][d] += cnt + 1
                ans += cnt
        return ans
"
3415,python3,maximum-distance-between-a-pair-of-values,"class Solution:
    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:
        def binary(left, right, num):
            farthestPos = 0
            while left < right:
                mid = (left + right) // 2
                if nums2[mid] < num:
                    right = mid
                else:
                    farthestPos = max(farthestPos, mid)
                    left = mid
            if nums2[left] >= num:
                farthestPos = max(farthestPos, left)
            return farthestPos
        maxDiff = 0
        for i in range(min(len(nums1), len(nums2))):
            if nums1[i] > nums2[i]:
                continue
            else:
                j = binary(i, len(nums2)-1, nums1[i])
                maxDiff = max(maxDiff, (j-i))
        return maxDiff",None,"class Solution:
    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:
        def binary(left, right, num):
            farthestPos = left
            while left <= right:
                mid = (left + right) // 2
                if nums2[mid] < num:
                    right = mid - 1
                else:
                    farthestPos = max(farthestPos, mid)
                    left = mid + 1
            return farthestPos

        maxDiff = 0
        for i in range(len(nums1)):
            if i >= len(nums2) or nums1[i] > nums2[i]:
                continue
            else:
                j = binary(i, len(nums2)-1, nums1[i])
                maxDiff = max(maxDiff, (j-i))
        return maxDiff
"
3415,python3,maximum-distance-between-a-pair-of-values,"class Solution:
    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:
        def binary(left, right, num):
            farthestPos = 0
            while left < right:
                mid = (left + right) // 2
                if nums2[mid] < num:
                    right = mid
                else:
                    farthestPos = max(farthestPos, mid)
                    left = mid
            if nums2[left] >= num:
                farthestPos = max(farthestPos, left)
            return farthestPos
        maxDiff = 0
        for i in range(min(len(nums1), len(nums2))):
            if nums1[i] > nums2[i]:
                continue
            else:
                j = binary(i, len(nums2)-1, nums1[i])
                maxDiff = max(maxDiff, (j-i))
        return maxDiff",None,"class Solution:
    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:
        def binary(left, right, num):
            farthestPos = 0
            while left <= right:
                mid = (left + right) // 2
                if nums2[mid] < num:
                    right = mid - 1
                else:
                    farthestPos = max(farthestPos, mid)
                    left = mid + 1
            if left < len(nums2) and nums2[left] >= num:
                farthestPos = max(farthestPos, left)
            return farthestPos
        maxDiff = 0
        for i in range(min(len(nums1), len(nums2))):
            if nums1[i] > nums2[i]:
                continue
            else:
                j = binary(i, len(nums2)-1, nums1[i])
                maxDiff = max(maxDiff, (j-i))
        return maxDiff
"
3415,python3,maximum-distance-between-a-pair-of-values,"class Solution:
    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:
        def binary(left, right, num):
            farthestPos = 0
            while left < right:
                mid = (left + right) // 2
                if nums2[mid] < num:
                    right = mid
                else:
                    farthestPos = max(farthestPos, mid)
                    left = mid
            if nums2[left] >= num:
                farthestPos = max(farthestPos, left)
            return farthestPos
        maxDiff = 0
        for i in range(min(len(nums1), len(nums2))):
            if nums1[i] > nums2[i]:
                continue
            else:
                j = binary(i, len(nums2)-1, nums1[i])
                maxDiff = max(maxDiff, (j-i))
        return maxDiff",None,"class Solution:
    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:
        def binary(left, right, num):
            farthestPos = 0
            while left <= right:
                mid = (left + right) // 2
                if nums2[mid] < num:
                    right = mid - 1
                else:
                    farthestPos = max(farthestPos, mid)
                    left = mid + 1
            if nums2[right] >= num:
                farthestPos = max(farthestPos, right)
            return farthestPos
        maxDiff = 0
        for i in range(min(len(nums1), len(nums2))):
            if nums1[i] > nums2[i]:
                continue
            else:
                j = binary(i, len(nums2)-1, nums1[i])
                maxDiff = max(maxDiff, (j-i))
        return maxDiff
"
3416,python3,longest-harmonious-subsequence,"class Solution:
    def findLHS(self, nums: List[int]) -> int:
        result = 0
        count_map = {}
        for num in nums:
            if num not in count_map:
                count_map[num] = 1
            else:
                count_map[num] -= 1
        for num, count in count_map.items():
            if num + 1 in count_map:
                result = max(count + count_map[num + 1], result)
        return result",None,"class Solution:
    def findLHS(self, nums: List[int]) -> int:
        result = 0
        count_map = {}
        for num in nums:
            if num not in count_map:
                count_map[num] = 1
            else:
                count_map[num] += 1
        for num, count in count_map.items():
            if num + 1 in count_map:
                result = max(count + count_map[num + 1], result)
        return result
"
3416,python3,longest-harmonious-subsequence,"class Solution:
    def findLHS(self, nums: List[int]) -> int:
        result = 0
        count_map = {}
        for num in nums:
            if num not in count_map:
                count_map[num] = 1
            else:
                count_map[num] -= 1
        for num, count in count_map.items():
            if num + 1 in count_map:
                result = max(count + count_map[num + 1], result)
        return result",None,"class Solution:
    def findLHS(self, nums: List[int]) -> int:
        result = 0
        count_map = {}
        for num in nums:
            if num not in count_map:
                count_map[num] = 1
            else:
                count_map[num] += 1
        for num, count in count_map.items():
            if num + 1 in count_map:
                result = max(count + count_map[num + 1], result)
        return result
"
3416,python3,longest-harmonious-subsequence,"class Solution:
    def findLHS(self, nums: List[int]) -> int:
        result = 0
        count_map = {}
        for num in nums:
            if num not in count_map:
                count_map[num] = 1
            else:
                count_map[num] -= 1
        for num, count in count_map.items():
            if num + 1 in count_map:
                result = max(count + count_map[num + 1], result)
        return result",None,"class Solution:
    def findLHS(self, nums: List[int]) -> int:
        result = 0
        count_map = {}
        for num in nums:
            if num not in count_map:
                count_map[num] = 1
            else:
                count_map[num] += 1
        for num, count in count_map.items():
            if num + 1 in count_map:
                result = max(count + count_map[num + 1], result)
        return result 
"
3417,python3,longest-repeating-character-replacement,"class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        left = right = 0
        max_len = 0
        count = collections.Counter()
        for right in range(1, len(s) + 1):
            count[s[right - 1]] += 1

            most = count.most_common()[0][1]

            remain = right - left - most
            
            if remain > k: 
                count[s[left]] -= 1
                left -= 1
                
            max_len = max(right - left, max_len)

        return max_len",None,"class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        left = right = 0
        max_len = 0
        count = collections.Counter()
        for right in range(1, len(s) + 1):
            count[s[right - 1]] += 1

            most = count.most_common()[0][1]

            remain = right - left - most
            
            if remain > k: 
                count[s[left]] -= 1
                left += 1
                
            max_len = max(right - left, max_len)

        return max_len
"
3417,python3,longest-repeating-character-replacement,"class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        left = right = 0
        max_len = 0
        count = collections.Counter()
        for right in range(1, len(s) + 1):
            count[s[right - 1]] += 1

            most = count.most_common()[0][1]

            remain = right - left - most
            
            if remain > k: 
                count[s[left]] -= 1
                left -= 1
                
            max_len = max(right - left, max_len)

        return max_len",None,"class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        left = right = 0
        max_len = 0
        count = collections.Counter()
        for right in range(1, len(s) + 1):
            count[s[right - 1]] += 1

            most = count.most_common()[0][1]

            remain = right - left - most
            
            if remain > k: 
                count[s[left]] -= 1
                left += 1
                
            max_len = max(right - left, max_len)

        return max_len
"
3417,python3,longest-repeating-character-replacement,"class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        left = right = 0
        max_len = 0
        count = collections.Counter()
        for right in range(1, len(s) + 1):
            count[s[right - 1]] += 1

            most = count.most_common()[0][1]

            remain = right - left - most
            
            if remain > k: 
                count[s[left]] -= 1
                left -= 1
                
            max_len = max(right - left, max_len)

        return max_len",None,"class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        left = right = 0
        max_len = 0
        count = collections.Counter()
        for right in range(1, len(s) + 1):
            count[s[right - 1]] += 1

            most = count.most_common(1)[0][1]

            remain = right - left - most
            
            if remain > k: 
                count[s[left]] -= 1
                left += 1
                
            max_len = max(right - left, max_len)

        return max_len
"
3418,python3,adding-two-negabinary-numbers,"class Solution:
    def addBinary(self, A, B):
        res = []
        carry = 0
        while A or B or carry:
            carry += (A or [0]).pop(0) + (B or [0]).pop(0)
            res.append(carry & 1)
            carry = carry >> 1
        return res[::-1]

    def addNegabinary(self, A, B):
        res = []
        carry = 0
        while A or B or carry:
            carry += (A or [0]).pop(0) + (B or [0]).pop(0)
            res.append(carry & 1)
            carry = -(carry >> 1)
        while len(res) > 1 and res[-1] == 0:
            res.pop()
        return res[::-1]",None,"class Solution:
    def addBinary(self, A, B):
        res = []
        carry = 0
        while A or B or carry:
            carry += (A or [0]).pop() + (B or [0]).pop()
            res.append(carry & 1)
            carry = carry >> 1
        return res[::-1]

    def addNegabinary(self, A, B):
        res = []
        carry = 0
        while A or B or carry:
            carry += (A or [0]).pop() + (B or [0]).pop()
            res.append(carry & 1)
            carry = -(carry >> 1)
        while len(res) > 1 and res[-1] == 0:
            res.pop()
        return res[::-1]
"
3418,python3,adding-two-negabinary-numbers,"class Solution:
    def addBinary(self, A, B):
        res = []
        carry = 0
        while A or B or carry:
            carry += (A or [0]).pop(0) + (B or [0]).pop(0)
            res.append(carry & 1)
            carry = carry >> 1
        return res[::-1]

    def addNegabinary(self, A, B):
        res = []
        carry = 0
        while A or B or carry:
            carry += (A or [0]).pop(0) + (B or [0]).pop(0)
            res.append(carry & 1)
            carry = -(carry >> 1)
        while len(res) > 1 and res[-1] == 0:
            res.pop()
        return res[::-1]",None,"class Solution:
    def addBinary(self, A, B):
        res = []
        carry = 0
        while A or B or carry:
            carry += (A or [0]).pop() + (B or [0]).pop()
            res.append(carry & 1)
            carry = carry >> 1
        return res[::-1]

    def addNegabinary(self, A, B):
        res = []
        carry = 0
        while A or B or carry:
            carry += (A or [0]).pop() + (B or [0]).pop()
            res.append(carry & 1)
            carry = -(carry >> 1)
        while len(res) > 1 and res[-1] == 0:
            res.pop()
        return res[::-1]
"
3418,python3,adding-two-negabinary-numbers,"class Solution:
    def addBinary(self, A, B):
        res = []
        carry = 0
        while A or B or carry:
            carry += (A or [0]).pop(0) + (B or [0]).pop(0)
            res.append(carry & 1)
            carry = carry >> 1
        return res[::-1]

    def addNegabinary(self, A, B):
        res = []
        carry = 0
        while A or B or carry:
            carry += (A or [0]).pop(0) + (B or [0]).pop(0)
            res.append(carry & 1)
            carry = -(carry >> 1)
        while len(res) > 1 and res[-1] == 0:
            res.pop()
        return res[::-1]",None,"class Solution:
    def addBinary(self, A, B):
        res = []
        carry = 0
        while A or B or carry:
            carry += (A or [0]).pop() + (B or [0]).pop()
            res.append(carry & 1)
            carry = carry >> 1
        return res[::-1]

    def addNegabinary(self, A, B):
        res = []
        carry = 0
        while A or B or carry:
            carry += (A or [0]).pop() + (B or [0]).pop()
            res.append(carry & 1)
            carry = -(carry >> 1)
        while len(res) > 1 and res[-1] == 0:
            res.pop()
        return res[::-1]
"
3419,python3,frog-position-after-t-seconds,"class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        nei = collections.defaultdict(set)
        for a, b in edges:
            nei[a].add(b)
            nei[b].add(a)
            
        visited, res = set(), 0.
        def dfs(leaf_id, p, time):
            nonlocal res
            if time >= t:
                if leaf_id == target: res = p
                return
            visited.add(leaf_id)
            neighbors = nei[leaf_id] - visited
            for n in neighbors or [leaf_id]:
                dfs(n, p / (len(neighbors) or 1), time + 1)
        dfs(1, 1, 0)
        return res*2",None,"class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        nei = collections.defaultdict(set)
        for a, b in edges:
            nei[a].add(b)
            nei[b].add(a)
            
        visited, res = set(), 0.
        def dfs(leaf_id, p, time):
            nonlocal res
            if time > t or (time < t and not nei[leaf_id] - visited):
                if leaf_id == target: 
                    res = p
                return
            visited.add(leaf_id)
            for n in nei[leaf_id]:
                dfs(n, p / len(nei[leaf_id]), time + 1)

        dfs(1, 1, 0)
        return res
"
3419,python3,frog-position-after-t-seconds,"class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        nei = collections.defaultdict(set)
        for a, b in edges:
            nei[a].add(b)
            nei[b].add(a)
            
        visited, res = set(), 0.
        def dfs(leaf_id, p, time):
            nonlocal res
            if time >= t:
                if leaf_id == target: res = p
                return
            visited.add(leaf_id)
            neighbors = nei[leaf_id] - visited
            for n in neighbors or [leaf_id]:
                dfs(n, p / (len(neighbors) or 1), time + 1)
        dfs(1, 1, 0)
        return res*2",None,"class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        nei = collections.defaultdict(set)
        for a, b in edges:
            nei[a].add(b)
            nei[b].add(a)
            
        visited, res = set(), 0.
        def dfs(leaf_id, p, time):
            nonlocal res
            if time >= t or (leaf_id == target and (time == t or not (nei[leaf_id] - visited))):
                if leaf_id == target: res = p
                return
            visited.add(leaf_id)
            neighbors = nei[leaf_id] - visited
            for n in neighbors:
                dfs(n, p / len(neighbors), time + 1)
        dfs(1, 1, 0)
        return res
"
3419,python3,frog-position-after-t-seconds,"class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        nei = collections.defaultdict(set)
        for a, b in edges:
            nei[a].add(b)
            nei[b].add(a)
            
        visited, res = set(), 0.
        def dfs(leaf_id, p, time):
            nonlocal res
            if time >= t:
                if leaf_id == target: res = p
                return
            visited.add(leaf_id)
            neighbors = nei[leaf_id] - visited
            for n in neighbors or [leaf_id]:
                dfs(n, p / (len(neighbors) or 1), time + 1)
        dfs(1, 1, 0)
        return res*2",None,"class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        nei = collections.defaultdict(set)
        for a, b in edges:
            nei[a].add(b)
            nei[b].add(a)
            
        visited, res = set(), 0.
        def dfs(leaf_id, p, time):
            nonlocal res
            if time >= t:
                if leaf_id == target: res = p
                return
            visited.add(leaf_id)
            neighbors = nei[leaf_id] - visited
            for n in neighbors or [leaf_id]:
                dfs(n, p / (len(neighbors) or 1), time + 1)
        dfs(1, 1, 0)
        return res
"
3420,python3,minimum-number-of-steps-to-make-two-strings-anagram-ii,"class Solution:
    def minSteps(self, s: str, t: str) -> int:
        cnt1=Counter(s)
        cnt2=Counter(t)
        sm=0
        cnt=cnt1+cnt2
        for i in cnt.values():
            sm+=i
        return sm",None,"class Solution:
    def minSteps(self, s: str, t: str) -> int:
        cnt1=Counter(s)
        cnt2=Counter(t)
        cnt=cnt1-cnt2
        return sum(abs(i) for i in cnt.values())
"
3420,python3,minimum-number-of-steps-to-make-two-strings-anagram-ii,"class Solution:
    def minSteps(self, s: str, t: str) -> int:
        cnt1=Counter(s)
        cnt2=Counter(t)
        sm=0
        cnt=cnt1+cnt2
        for i in cnt.values():
            sm+=i
        return sm",None,"from collections import Counter

class Solution:
    def minSteps(self, s: str, t: str) -> int:
        cnt1 = Counter(s)
        cnt2 = Counter(t)
        diff = cnt1 - cnt2
        return sum(diff.values())
"
3420,python3,minimum-number-of-steps-to-make-two-strings-anagram-ii,"class Solution:
    def minSteps(self, s: str, t: str) -> int:
        cnt1=Counter(s)
        cnt2=Counter(t)
        sm=0
        cnt=cnt1+cnt2
        for i in cnt.values():
            sm+=i
        return sm",None,"class Solution:
    def minSteps(self, s: str, t: str) -> int:
        from collections import Counter
        cnt1 = Counter(s)
        cnt2 = Counter(t)
        diff = cnt1 - cnt2
        sm = sum(diff.values())
        return sm
"
3421,python3,lexicographically-smallest-string-after-substring-operation,"class Solution:
    def smallestString(self, s: str) -> str:
        
        if len(check:=set(s))==1 and check != {'a'}: 
            return chr(ord(s[0])-1)*(len(s))
        contiguous,change,ct1,ct2 = True,False,0,0

        for i in s:
            if i == 'a':ct1+=1                                                  
            else:break
        ans='' + 'a' * ct1
        s = s[ct1:]
     
        for cha in s:
            ct2+=1
            if cha != 'a':
                ans+=chr(ord(cha)-2)
                change=True
                continue
            else:
                ans+=cha
                if change:
                    contiguous = False
            if not contiguous:
                break
        return ans+s[ct2:] if change else ans[:-1]+'z'",None,"class Solution:
    def smallestString(self, s: str) -> str:
        
        if len(check:=set(s))==1 and check != {'a'}: 
            return chr(ord(s[0])-1)*(len(s))

        found_a, contiguous, ct2 = False, True, 0
        ans =''
     
        for cha in s:
            ct2+=1
            if cha == 'a':
                found_a = True
                ans += cha
            else:
                if found_a:
                    ans+=chr(ord(cha)-1)
                    continue
                else:
                    ans+=cha
            if not contiguous:
                break
        return ans+s[ct2:]
"
3421,python3,lexicographically-smallest-string-after-substring-operation,"class Solution:
    def smallestString(self, s: str) -> str:
        
        if len(check:=set(s))==1 and check != {'a'}: 
            return chr(ord(s[0])-1)*(len(s))
        contiguous,change,ct1,ct2 = True,False,0,0

        for i in s:
            if i == 'a':ct1+=1                                                  
            else:break
        ans='' + 'a' * ct1
        s = s[ct1:]
     
        for cha in s:
            ct2+=1
            if cha != 'a':
                ans+=chr(ord(cha)-2)
                change=True
                continue
            else:
                ans+=cha
                if change:
                    contiguous = False
            if not contiguous:
                break
        return ans+s[ct2:] if change else ans[:-1]+'z'",None,"class Solution:
    def smallestString(self, s: str) -> str:
        
        if len(check:=set(s))==1 and check != {'a'}: 
            return chr(ord(s[0])-1)*(len(s))
        contiguous,change,ct1,ct2 = True,False,0,0

        for i in s:
            if i == 'a':ct1+=1                                                  
            else:break
        ans='' + 'a' * ct1
        s = s[ct1:]
     
        for cha in s:
            ct2+=1
            if cha != 'a':
                ans+=chr(ord(cha)-1)
                change=True
                continue
            else:
                ans+=cha
                if change:
                    contiguous = False
            if not contiguous:
                break
        return ans+s[ct2:] if change else ans[:-1]+'z'
"
3421,python3,lexicographically-smallest-string-after-substring-operation,"class Solution:
    def smallestString(self, s: str) -> str:
        
        if len(check:=set(s))==1 and check != {'a'}: 
            return chr(ord(s[0])-1)*(len(s))
        contiguous,change,ct1,ct2 = True,False,0,0

        for i in s:
            if i == 'a':ct1+=1                                                  
            else:break
        ans='' + 'a' * ct1
        s = s[ct1:]
     
        for cha in s:
            ct2+=1
            if cha != 'a':
                ans+=chr(ord(cha)-2)
                change=True
                continue
            else:
                ans+=cha
                if change:
                    contiguous = False
            if not contiguous:
                break
        return ans+s[ct2:] if change else ans[:-1]+'z'",None,"class Solution:
    def smallestString(self, s: str) -> str:
        
        if len(check:=set(s))==1 and check != {'a'}: 
            return chr(ord(s[0])-1)*(len(s))
        contiguous,change,ct1,ct2 = True,False,0,0

        for i in s:
            if i == 'a':ct1+=1                                                  
            else:break
        ans='' + 'a' * ct1
        s = s[ct1:]
     
        for cha in s:
            if cha != 'a':
                ans+=chr(ord(cha)-1)
                change=True
                continue
            else:
                ans+=cha
                if change:
                    contiguous = False
            if not contiguous:
                break
        return ans+s[ct2:] if change else ans[:-1]+'z'
"
3422,python3,next-greater-element-i,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        l = []
        for i in nums1:
            count=0
            for j in nums2:
                if i==j:
                    for k in range(nums2.index(j)+1,len(nums2)):
                        if nums2[k]>j:
                            count+=1
                            l.append(nums2[k])
                            break
                    if count==0:
                        l.append(j)
        return (l)",None,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        l = []
        for i in nums1:
            found = False
            for j in nums2:
                if i==j:
                    found = True
                if found and j > i:
                    l.append(j)
                    break
            else:
                l.append(-1)
        return l
"
3422,python3,next-greater-element-i,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        l = []
        for i in nums1:
            count=0
            for j in nums2:
                if i==j:
                    for k in range(nums2.index(j)+1,len(nums2)):
                        if nums2[k]>j:
                            count+=1
                            l.append(nums2[k])
                            break
                    if count==0:
                        l.append(j)
        return (l)",None,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        l = []
        for i in nums1:
            index = nums2.index(i)
            for j in range(index + 1, len(nums2)):
                if nums2[j] > i:
                    l.append(nums2[j])
                    break
            else:
                l.append(-1)
        return l
"
3422,python3,next-greater-element-i,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        l = []
        for i in nums1:
            count=0
            for j in nums2:
                if i==j:
                    for k in range(nums2.index(j)+1,len(nums2)):
                        if nums2[k]>j:
                            count+=1
                            l.append(nums2[k])
                            break
                    if count==0:
                        l.append(j)
        return (l)",None,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        l = []
        for i in nums1:
            count=0
            for j in nums2:
                if i==j:
                    for k in range(nums2.index(j)+1,len(nums2)):
                        if nums2[k]>j:
                            count+=1
                            l.append(nums2[k])
                            break
                    if count==0:
                        l.append(-1)
        return (l)
"
3423,python3,count-good-numbers,"class Solution:
    def countGoodNumbers(self, n: int) -> int:
        return (pow(5,(n - 1)//2,1000000007)*pow(4,n//2,1000000007))%1000000007",None,"class Solution:
    def countGoodNumbers(self, n: int) -> int:
        return (pow(5,(n + 1)//2,1000000007)*pow(4,n//2,1000000007))%1000000007
"
3423,python3,count-good-numbers,"class Solution:
    def countGoodNumbers(self, n: int) -> int:
        return (pow(5,(n - 1)//2,1000000007)*pow(4,n//2,1000000007))%1000000007",None,"class Solution:
    def countGoodNumbers(self, n: int) -> int:
        return (pow(5,(n + 1)//2,1000000007)*pow(4,n//2,1000000007))%1000000007
"
3423,python3,count-good-numbers,"class Solution:
    def countGoodNumbers(self, n: int) -> int:
        return (pow(5,(n - 1)//2,1000000007)*pow(4,n//2,1000000007))%1000000007",None,"class Solution:
    def countGoodNumbers(self, n: int) -> int:
        return (pow(5, (n + 1)//2, 1000000007) * pow(4, n//2, 1000000007)) % 1000000007
"
3424,python3,reverse-bits,"class Solution:
    def f(self,n,r,count):
        if n<1:return r<<(32-count)
        return self.f(n<<1,(r<<1)|(n&1),count+1)
    def reverseBits(self, n: int) -> int:return self.f(n,0,0)",None,"class Solution:
    def f(self,n,r,count):
        if n<1:return r<<(32-count)
        return self.f(n>>1,(r<<1)|(n&1),count+1)
    def reverseBits(self, n: int) -> int:return self.f(n,0,0)
"
3424,python3,reverse-bits,"class Solution:
    def f(self,n,r,count):
        if n<1:return r<<(32-count)
        return self.f(n<<1,(r<<1)|(n&1),count+1)
    def reverseBits(self, n: int) -> int:return self.f(n,0,0)",None,"class Solution:
    def f(self,n,r,count):
        if n<1:return r<<(32-count)
        return self.f(n>>1,(r<<1)|(n&1),count+1)
    def reverseBits(self, n: int) -> int:
        return self.f(n,0,0)
"
3424,python3,reverse-bits,"class Solution:
    def f(self,n,r,count):
        if n<1:return r<<(32-count)
        return self.f(n<<1,(r<<1)|(n&1),count+1)
    def reverseBits(self, n: int) -> int:return self.f(n,0,0)",None,"class Solution:
    def f(self,n,r,count):
        if n<1:return r<<(32-count)
        return self.f(n>>1,(r<<1)|(n&1),count+1)
    def reverseBits(self, n: int) -> int:return self.f(n,0,0)
"
3425,python3,alternating-digit-sum,"class Solution:
    def alternateDigitSum(self, n: int) -> int:
        count=0
        n=str(n)
        for i in range(len(n)):
            if i%2==0:
                count+=int(n[i])
            else:
                count+=int(n[i])
        return count",None,"class Solution:
    def alternateDigitSum(self, n: int) -> int:
        count = 0
        n = str(n)
        for i in range(len(n)):
            if i % 2 == 0:
                count += int(n[i])
            else:
                count -= int(n[i])
        return count
"
3425,python3,alternating-digit-sum,"class Solution:
    def alternateDigitSum(self, n: int) -> int:
        count=0
        n=str(n)
        for i in range(len(n)):
            if i%2==0:
                count+=int(n[i])
            else:
                count+=int(n[i])
        return count",None,"class Solution:
    def alternateDigitSum(self, n: int) -> int:
        count=0
        n=str(n)
        for i in range(len(n)):
            if i%2==0:
                count+=int(n[i])
            else:
                count-=int(n[i])
        return count
"
3425,python3,alternating-digit-sum,"class Solution:
    def alternateDigitSum(self, n: int) -> int:
        count=0
        n=str(n)
        for i in range(len(n)):
            if i%2==0:
                count+=int(n[i])
            else:
                count+=int(n[i])
        return count",None,"class Solution:
    def alternateDigitSum(self, n: int) -> int:
        count = 0
        n = str(n)
        for i in range(len(n)):
            if i % 2 == 0:
                count += int(n[i])
            else:
                count -= int(n[i])
        return count
"
3426,python3,length-of-the-longest-valid-substring,"class Solution:
    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:
        trie = {}
        for f in forbidden:
            t = trie
            for c in f:
                if c not in t:
                    t[c] = {}
                t = t[c]
            t[""end""] = True
        
        def isForbidden(s):
            t = trie
            counter = 0
            for c in s:
                if c not in t:
                    return False
                t = t[c]
                counter += 1
                if ""end"" in t:
                    return counter
            return False
        
        res = 0
        j = len(word)
        for i in range(len(word) - 1, -1, -1):
            truc = isForbidden(word[i:j])
            if truc:
                j = i - truc - 1
            res = max(res, j - i)
        return res",None,"class Solution:
    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:
        trie = {}
        for f in forbidden:
            t = trie
            for c in f:
                if c not in t:
                    t[c] = {}
                t = t[c]
            t[""end""] = True
        
        def isForbidden(s):
            t = trie
            counter = 0
            for c in s:
                if c not in t:
                    return False
                t = t[c]
                counter += 1
                if ""end"" in t:
                    return counter
            return False
        
        res = 0
        j = len(word)
        for i in range(len(word) - 1, -1, -1):
            truc = isForbidden(word[i:j])
            if truc:
                j = i + truc - 1
            res = max(res, j - i)
        return res
"
3426,python3,length-of-the-longest-valid-substring,"class Solution:
    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:
        trie = {}
        for f in forbidden:
            t = trie
            for c in f:
                if c not in t:
                    t[c] = {}
                t = t[c]
            t[""end""] = True
        
        def isForbidden(s):
            t = trie
            counter = 0
            for c in s:
                if c not in t:
                    return False
                t = t[c]
                counter += 1
                if ""end"" in t:
                    return counter
            return False
        
        res = 0
        j = len(word)
        for i in range(len(word) - 1, -1, -1):
            truc = isForbidden(word[i:j])
            if truc:
                j = i - truc - 1
            res = max(res, j - i)
        return res",None,"class Solution:
    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:
        trie = {}
        for f in forbidden:
            t = trie
            for c in f:
                if c not in t:
                    t[c] = {}
                t = t[c]
            t[""end""] = True
       
        def isForbidden(s):
            t = trie
            counter = 0
            for c in s:
                if c not in t:
                    return False
                t = t[c]
                counter += 1
                if ""end"" in t:
                    return counter
            return False
        
        res = 0
        j = len(word)
        for i in range(len(word)):
            truc = isForbidden(word[i:j])
            if truc:
                i += truc
            else:
                res = max(res, j - i)
                j -= 1
        return res
"
3426,python3,length-of-the-longest-valid-substring,"class Solution:
    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:
        trie = {}
        for f in forbidden:
            t = trie
            for c in f:
                if c not in t:
                    t[c] = {}
                t = t[c]
            t[""end""] = True
        
        def isForbidden(s):
            t = trie
            counter = 0
            for c in s:
                if c not in t:
                    return False
                t = t[c]
                counter += 1
                if ""end"" in t:
                    return counter
            return False
        
        res = 0
        j = len(word)
        for i in range(len(word) - 1, -1, -1):
            truc = isForbidden(word[i:j])
            if truc:
                j = i - truc - 1
            res = max(res, j - i)
        return res",None,"class Solution:
    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:
        trie = {}
        for f in forbidden:
            t = trie
            for c in f:
                if c not in t:
                    t[c] = {}
                t = t[c]
            t[""end""] = True
        
        def isForbidden(s):
            t = trie
            counter = 0
            for c in s:
                if c not in t:
                    return False
                t = t[c]
                counter += 1
                if ""end"" in t:
                    return counter
            return False
        
        res = 0
        j = len(word)
        for i in range(len(word) - 1, -1, -1):
            truc = isForbidden(word[i:j])
            if truc:
                j = i + truc
            res = max(res, j - i)
        return res
"
3427,python3,minimum-subsequence-in-non-increasing-order,"class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        total = sum(nums)
        nums.sort(reverse = True)
        sub_sum, sub_seq = 0, []
        for x in nums:
            sub_sum += x
            sub_seq.append(x)
            if sub_sum > total:
                return sub_seq
            sub_sum -= x",None,"class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        total = sum(nums)
        nums.sort(reverse = True)
        sub_sum, sub_seq = 0, []
        for x in nums:
            sub_sum += x
            sub_seq.append(x)
            if sub_sum > total - sub_sum:
                return sub_seq"
3427,python3,minimum-subsequence-in-non-increasing-order,"class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        total = sum(nums)
        nums.sort(reverse = True)
        sub_sum, sub_seq = 0, []
        for x in nums:
            sub_sum += x
            sub_seq.append(x)
            if sub_sum > total:
                return sub_seq
            sub_sum -= x",None,"class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        total = sum(nums)
        nums.sort(reverse = True)
        sub_sum, sub_seq = 0, []
        for x in nums:
            sub_sum += x
            sub_seq.append(x)
            if sub_sum > total - sub_sum:
                return sub_seq
"
3427,python3,minimum-subsequence-in-non-increasing-order,"class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        total = sum(nums)
        nums.sort(reverse = True)
        sub_sum, sub_seq = 0, []
        for x in nums:
            sub_sum += x
            sub_seq.append(x)
            if sub_sum > total:
                return sub_seq
            sub_sum -= x",None,"class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        total = sum(nums)
        nums.sort(reverse = True)
        sub_sum, sub_seq = 0, []
        for x in nums:
            sub_sum += x
            sub_seq.append(x)
            if sub_sum > total - sub_sum:
                return sub_seq
"
3428,python3,kth-largest-element-in-an-array,"class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return sorted(nums)[-k-1]",None,"class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return sorted(nums)[-k]
"
3428,python3,kth-largest-element-in-an-array,"class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return sorted(nums)[-k-1]",None,"class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return sorted(nums)[-k]
"
3428,python3,kth-largest-element-in-an-array,"class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return sorted(nums)[-k-1]",None,"class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return sorted(nums)[-k]
"
3429,python3,maximize-number-of-nice-divisors,"class Solution:
    def maxNiceDivisors(self, primeFactors: int) -> int:
        if primeFactors <= 3:
            return primeFactors
        
        MOD = int(1e9 + 7)
        if primeFactors % 3 == 0:
            power = primeFactors // 3
            return self.calculateNiceDivisors(3, power, MOD) * 2
        elif primeFactors % 3 == 1:
            power = (primeFactors // 3) - 1
            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD
        else:
            power = primeFactors // 3
            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD
    
    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:
        if power == 0:
            return 1

        result = self.calculateNiceDivisors(base, power // 2, MOD)
        result = (result * result) % MOD

        if power % 2 == 1:
            result = (result * base) % MOD

        return result",None,"class Solution:
    def maxNiceDivisors(self, primeFactors: int) -> int:
        if primeFactors <= 3:
            return primeFactors
        
        MOD = int(1e9 + 7)
        if primeFactors % 3 == 0:
            power = primeFactors // 3
            return self.calculateNiceDivisors(3, power, MOD) % MOD
        elif primeFactors % 3 == 1:
            power = (primeFactors // 3) - 1
            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD
        else:
            power = primeFactors // 3
            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD
    
    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:
        if power == 0:
            return 1

        result = self.calculateNiceDivisors(base, power // 2, MOD)
        result = (result * result) % MOD

        if power % 2 == 1:
            result = (result * base) % MOD

        return result
"
3429,python3,maximize-number-of-nice-divisors,"class Solution:
    def maxNiceDivisors(self, primeFactors: int) -> int:
        if primeFactors <= 3:
            return primeFactors
        
        MOD = int(1e9 + 7)
        if primeFactors % 3 == 0:
            power = primeFactors // 3
            return self.calculateNiceDivisors(3, power, MOD) * 2
        elif primeFactors % 3 == 1:
            power = (primeFactors // 3) - 1
            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD
        else:
            power = primeFactors // 3
            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD
    
    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:
        if power == 0:
            return 1

        result = self.calculateNiceDivisors(base, power // 2, MOD)
        result = (result * result) % MOD

        if power % 2 == 1:
            result = (result * base) % MOD

        return result",None,"class Solution:
    def maxNiceDivisors(self, primeFactors: int) -> int:
        if primeFactors <= 3:
            return primeFactors
        
        MOD = int(1e9 + 7)
        if primeFactors % 3 == 0:
            power = primeFactors // 3
            return self.calculateNiceDivisors(3, power, MOD) % MOD
        elif primeFactors % 3 == 1:
            power = (primeFactors // 3) - 1
            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD
        else:
            power = primeFactors // 3
            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD
    
    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:
        if power == 0:
            return 1

        result = self.calculateNiceDivisors(base, power // 2, MOD)
        result = (result * result) % MOD

        if power % 2 == 1:
            result = (result * base) % MOD

        return result
"
3429,python3,maximize-number-of-nice-divisors,"class Solution:
    def maxNiceDivisors(self, primeFactors: int) -> int:
        if primeFactors <= 3:
            return primeFactors
        
        MOD = int(1e9 + 7)
        if primeFactors % 3 == 0:
            power = primeFactors // 3
            return self.calculateNiceDivisors(3, power, MOD) * 2
        elif primeFactors % 3 == 1:
            power = (primeFactors // 3) - 1
            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD
        else:
            power = primeFactors // 3
            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD
    
    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:
        if power == 0:
            return 1

        result = self.calculateNiceDivisors(base, power // 2, MOD)
        result = (result * result) % MOD

        if power % 2 == 1:
            result = (result * base) % MOD

        return result",None,"class Solution:
    def maxNiceDivisors(self, primeFactors: int) -> int:
        if primeFactors <= 3:
            return primeFactors
        
        MOD = int(1e9 + 7)
        if primeFactors % 3 == 0:
            power = primeFactors // 3
            return self.calculateNiceDivisors(3, power, MOD)
        elif primeFactors % 3 == 1:
            power = (primeFactors // 3) - 1
            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD
        else:
            power = primeFactors // 3
            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD
    
    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:
        if power == 0:
            return 1

        result = self.calculateNiceDivisors(base, power // 2, MOD)
        result = (result * result) % MOD

        if power % 2 == 1:
            result = (result * base) % MOD

        return result
"
3430,python3,maximum-sum-queries,"import math
from typing import List
import bisect

class Solution:
    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        def buildSparseTable(arr, n):
            k = int(math.log2(n))
            st = [[None for j in range(n)] for i in range(k + 1)]
            for i in range(k + 1):
                for j in range(n - (1 << i) + 1):
                    if i == 0:
                        st[i][j] = arr[j]
                    else:
                        st[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << (i - 1))])
            return st

        def getMax(st, l, r):
            i = int(math.log2(r - l + 1))
            return max(st[i][l], st[i][r - (1 << i) + 1])

        n = len(nums1)
        a = sorted([[nums1[i], nums2[i]] for i in range(n)])
        max_y = [v[1] for v in a]
        for i in range(n - 2, -1, -1):
            max_y[i] = max(max_y[i], max_y[1 + 1])   
        _sum = [v[0] + v[1] for v in a]
        st_max_sum = buildSparseTable(_sum, n)
        res = []
        for x, y in queries:
            i = bisect.bisect_left(a, [x, y])
            if i == n or max_y[i] < y:
                res.append(-1)
                continue
            left, right = i, n - 1
            while left < right:
                m = (left + right + 1) // 2
                if max_y[m] >= y:
                    left = m
                else:
                    right = m - 1
            j = right
            res.append(getMax(st_max_sum, i, j))
        return res",None,"import math
from typing import List
import bisect

class Solution:
    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        def buildSparseTable(arr, n):
            k = int(math.log2(n))
            st = [[None for j in range(n)] for i in range(k + 1)]
            for i in range(k + 1):
                for j in range(n - (1 << i) + 1):
                    if i == 0:
                        st[i][j] = arr[j]
                    else:
                        st[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << (i - 1))])
            return st

        def getMax(st, l, r):
            i = int(math.log2(r - l + 1))
            return max(st[i][l], st[i][r - (1 << i) + 1])

        n = len(nums1)
        a = sorted([[nums1[i], nums2[i]] for i in range(n)])
        max_y = [v[1] for v in a]
        for i in range(n - 2, -1, -1):
            max_y[i] = max(max_y[i], max_y[i + 1])   
        _sum = [v[0] + v[1] for v in a]
        st_max_sum = buildSparseTable(_sum, n)
        res = []
        for x, y in queries:
            i = bisect.bisect_left(a, [x, y])
            if i == n or max_y[i] < y:
                res.append(-1)
                continue
            left, right = i, n - 1
            while left < right:
                m = (left + right + 1) // 2
                if max_y[m] >= y:
                    left = m
                else:
                    right = m - 1
            j = right
            res.append(getMax(st_max_sum, i, j))
        return res
"
3430,python3,maximum-sum-queries,"import math
from typing import List
import bisect

class Solution:
    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        def buildSparseTable(arr, n):
            k = int(math.log2(n))
            st = [[None for j in range(n)] for i in range(k + 1)]
            for i in range(k + 1):
                for j in range(n - (1 << i) + 1):
                    if i == 0:
                        st[i][j] = arr[j]
                    else:
                        st[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << (i - 1))])
            return st

        def getMax(st, l, r):
            i = int(math.log2(r - l + 1))
            return max(st[i][l], st[i][r - (1 << i) + 1])

        n = len(nums1)
        a = sorted([[nums1[i], nums2[i]] for i in range(n)])
        max_y = [v[1] for v in a]
        for i in range(n - 2, -1, -1):
            max_y[i] = max(max_y[i], max_y[1 + 1])   
        _sum = [v[0] + v[1] for v in a]
        st_max_sum = buildSparseTable(_sum, n)
        res = []
        for x, y in queries:
            i = bisect.bisect_left(a, [x, y])
            if i == n or max_y[i] < y:
                res.append(-1)
                continue
            left, right = i, n - 1
            while left < right:
                m = (left + right + 1) // 2
                if max_y[m] >= y:
                    left = m
                else:
                    right = m - 1
            j = right
            res.append(getMax(st_max_sum, i, j))
        return res",None,"import math
from typing import List
import bisect

class Solution:
    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        def buildSparseTable(arr, n):
            k = int(math.log2(n))
            st = [[None for j in range(n)] for i in range(k + 1)]
            for i in range(n):  # fix here, need to initialize for every element in arr
                st[0][i] = arr[i]
            for i in range(1, k + 1):
                j = 0
                while j + (1 << i) <= n:  # fix here, to ensure index doesn't go out of bounds
                    st[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << (i - 1))])
                    j += 1
            return st

        def getMax(st, l, r):
            i = int(math.log2(r - l + 1))
            return max(st[i][l], st[i][r - (1 << i) + 1])

        n = len(nums1)
        a = sorted([[nums1[i], nums2[i]] for i in range(n)])
        max_y = [v[1] for v in a]
        for i in range(n - 2, -1, -1):
            max_y[i] = max(max_y[i], max_y[i + 1])  # fix here, the index of max_y should be i + 1
        _sum = [v[0] + v[1] for v in a]
        st_max_sum = buildSparseTable(_sum, n)
        res = []
        for x, y in queries:
            i = bisect.bisect_left(a, [x, y])
            if i == n or max_y[i] < y:
                res.append(-1)
                continue
            left, right = i, n - 1
            while left < right:
                m = (left + right + 1) // 2
                if max_y[m] >= y:
                    left = m
                else:
                    right = m - 1
            j = right
            res.append(getMax(st_max_sum, i, j))
        return res
"
3430,python3,maximum-sum-queries,"import math
from typing import List
import bisect

class Solution:
    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        def buildSparseTable(arr, n):
            k = int(math.log2(n))
            st = [[None for j in range(n)] for i in range(k + 1)]
            for i in range(k + 1):
                for j in range(n - (1 << i) + 1):
                    if i == 0:
                        st[i][j] = arr[j]
                    else:
                        st[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << (i - 1))])
            return st

        def getMax(st, l, r):
            i = int(math.log2(r - l + 1))
            return max(st[i][l], st[i][r - (1 << i) + 1])

        n = len(nums1)
        a = sorted([[nums1[i], nums2[i]] for i in range(n)])
        max_y = [v[1] for v in a]
        for i in range(n - 2, -1, -1):
            max_y[i] = max(max_y[i], max_y[1 + 1])   
        _sum = [v[0] + v[1] for v in a]
        st_max_sum = buildSparseTable(_sum, n)
        res = []
        for x, y in queries:
            i = bisect.bisect_left(a, [x, y])
            if i == n or max_y[i] < y:
                res.append(-1)
                continue
            left, right = i, n - 1
            while left < right:
                m = (left + right + 1) // 2
                if max_y[m] >= y:
                    left = m
                else:
                    right = m - 1
            j = right
            res.append(getMax(st_max_sum, i, j))
        return res",None,"import math
from typing import List
import bisect

class Solution:
    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        def buildSparseTable(arr, n):
            k = int(math.log2(n))
            st = [[None for j in range(n)] for i in range(k + 1)]
            for i in range(k + 1):
                for j in range(n - (1 << i) + 1):
                    if i == 0:
                        st[i][j] = arr[j]
                    else:
                        st[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << (i - 1))])
            return st

        def getMax(st, l, r):
            i = int(math.log2(r - l + 1))
            return max(st[i][l], st[i][r - (1 << i) + 1])

        n = len(nums1)
        a = sorted([[nums1[i], nums2[i]] for i in range(n)])
        max_y = [v[1] for v in a]
        for i in range(n - 2, -1, -1):
            max_y[i] = max(max_y[i], max_y[i + 1])   
        _sum = [v[0] + v[1] for v in a]
        st_max_sum = buildSparseTable(_sum, n)
        res = []
        for x, y in queries:
            i = bisect.bisect_left(a, [x, y])
            if i == n or max_y[i] < y:
                res.append(-1)
                continue
            left, right = i, n - 1
            while left < right:
                m = (left + right + 1) // 2
                if max_y[m] >= y:
                    left = m
                else:
                    right = m - 1
            j = right
            res.append(getMax(st_max_sum, i, j))
        return res
"
3431,python3,maximum-strength-of-a-group,"class Solution:
    def maxStrength(self, nums: List[int]) -> int:
        max_memo, min_memo = nums[0], nums[0]
        for num in nums[1:]:
            max_memo, min_memo = max(max_memo, num, num*min_memo), min(min_memo, num, num*min_memo, num*max_memo)
        return max_memo",None,"class Solution:
    def maxStrength(self, nums: List[int]) -> int:
        max_memo, min_memo = nums[0], nums[0]
        max_product = nums[0]
        for num in nums[1:]:
            temp_max = max(num, num * max_memo, num * min_memo)
            min_memo = min(num, num * max_memo, num * min_memo)
            max_memo = temp_max
            max_product = max(max_product, max_memo)
        return max_product
"
3431,python3,maximum-strength-of-a-group,"class Solution:
    def maxStrength(self, nums: List[int]) -> int:
        max_memo, min_memo = nums[0], nums[0]
        for num in nums[1:]:
            max_memo, min_memo = max(max_memo, num, num*min_memo), min(min_memo, num, num*min_memo, num*max_memo)
        return max_memo",None,"class Solution:
    def maxStrength(self, nums: List[int]) -> int:
        max_memo = [0]*len(nums)
        min_memo = [0]*len(nums)
        max_memo[0], min_memo[0] = nums[0], nums[0]
        for i in range(1, len(nums)):
            max_memo[i] = max(nums[i], nums[i]*min_memo[i-1], nums[i]*max_memo[i-1])
            min_memo[i] = min(nums[i], nums[i]*min_memo[i-1], nums[i]*max_memo[i-1])
        return max(max_memo)
"
3431,python3,maximum-strength-of-a-group,"class Solution:
    def maxStrength(self, nums: List[int]) -> int:
        max_memo, min_memo = nums[0], nums[0]
        for num in nums[1:]:
            max_memo, min_memo = max(max_memo, num, num*min_memo), min(min_memo, num, num*min_memo, num*max_memo)
        return max_memo",None,"class Solution:
    def maxStrength(self, nums: List[int]) -> int:
        max_memo, min_memo = nums[0], nums[0]
        max_result = max_memo
        for num in nums[1:]:
            max_memo_temp = max(num, num*max_memo, num*min_memo)
            min_memo = min(num, num*min_memo, num*max_memo)
            max_memo = max_memo_temp
            max_result = max(max_result, max_memo)
        return max_result
"
3432,python3,largest-positive-integer-that-exists-with-its-negative,"class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        nums=sorted(nums,reverse=True)
        s=set(nums)
        for i in range(len(nums)):
            if nums[i] in s:
                return nums[i]
        return -1",None,"class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        nums=sorted(nums,reverse=True)
        s=set(nums)
        for i in range(len(nums)):
            if -nums[i] in s:
                return nums[i]
        return -1
"
3432,python3,largest-positive-integer-that-exists-with-its-negative,"class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        nums=sorted(nums,reverse=True)
        s=set(nums)
        for i in range(len(nums)):
            if nums[i] in s:
                return nums[i]
        return -1",None,"class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        s = set(nums)
        for num in sorted(s, reverse=True):
            if -num in s:
                return num
        return -1
"
3432,python3,largest-positive-integer-that-exists-with-its-negative,"class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        nums=sorted(nums,reverse=True)
        s=set(nums)
        for i in range(len(nums)):
            if nums[i] in s:
                return nums[i]
        return -1",None,"class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        nums=sorted(nums,reverse=True)
        s=set(nums)
        for i in range(len(nums)):
            if -nums[i] in s and nums[i] > 0:
                return nums[i]
        return -1
"
3433,python3,longest-cycle-in-a-graph,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        v=[0]*len(edges)
        ans=-1
        for i in range(len(edges)):
            t=1
            c=i
            while c>=0:
                if v[c]!=0:
                    if v[c][0]==i:
                        ans=max(ans,t-v[c][1])
                    break
                else:
                    v[c]=[i,t]
                    t+=1
                    c=edges[c] - 1
        return ans",None,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        v=[0]*len(edges)
        ans=-1
        for i in range(len(edges)):
            t=1
            c=i
            while c>=0:
                if v[c]!=0:
                    if v[c][0]==i:
                        ans=max(ans,t-v[c][1])
                    break
                else:
                    v[c]=[i,t]
                    t+=1
                    c=edges[c]
        return ans
"
3433,python3,longest-cycle-in-a-graph,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        v=[0]*len(edges)
        ans=-1
        for i in range(len(edges)):
            t=1
            c=i
            while c>=0:
                if v[c]!=0:
                    if v[c][0]==i:
                        ans=max(ans,t-v[c][1])
                    break
                else:
                    v[c]=[i,t]
                    t+=1
                    c=edges[c] - 1
        return ans",None,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        v=[0]*len(edges)
        ans=-1
        for i in range(len(edges)):
            t=1
            c=i
            while c>=0:
                if v[c]!=0:
                    if v[c][0]==i:
                        ans=max(ans,t-v[c][1])
                    break
                else:
                    v[c]=[i,t]
                    t+=1
                    c=edges[c]
        return ans
"
3433,python3,longest-cycle-in-a-graph,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        v=[0]*len(edges)
        ans=-1
        for i in range(len(edges)):
            t=1
            c=i
            while c>=0:
                if v[c]!=0:
                    if v[c][0]==i:
                        ans=max(ans,t-v[c][1])
                    break
                else:
                    v[c]=[i,t]
                    t+=1
                    c=edges[c] - 1
        return ans",None,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        v=[0]*len(edges)
        ans=-1
        for i in range(len(edges)):
            t=1
            c=i
            while edges[c] != -1:
                if v[c]!=0:
                    if v[c][0]==i:
                        ans=max(ans,t-v[c][1])
                    break
                else:
                    v[c]=[i,t]
                    t+=1
                    c=edges[c]
        return ans
"
3434,python3,kth-missing-positive-number,"class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        l,h=0,len(arr)
        while l<h:
            mid=(h+l)//2
            if arr[mid]-mid>k:h=mid
            else: l=mid+1
        return l+k-1",None,"class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        l,h=0,len(arr)
        while l<h:
            mid=(h+l)//2
            if arr[mid]-mid-1>=k:h=mid
            else: l=mid+1
        return l+k
"
3434,python3,kth-missing-positive-number,"class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        l,h=0,len(arr)
        while l<h:
            mid=(h+l)//2
            if arr[mid]-mid>k:h=mid
            else: l=mid+1
        return l+k-1",None,"class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        l, h = 0, len(arr)
        while l < h:
            mid = (h + l) // 2
            if arr[mid] - mid - 1 < k: l = mid + 1
            else: h = mid
        return l + k
"
3434,python3,kth-missing-positive-number,"class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        l,h=0,len(arr)
        while l<h:
            mid=(h+l)//2
            if arr[mid]-mid>k:h=mid
            else: l=mid+1
        return l+k-1",None,"class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        l,h=1,len(arr)
        while l<h:
            mid=(h+l)//2
            if arr[mid-1]-mid>=k:
                h=mid
            else: 
                l=mid+1
        return l+k-1
"
3435,python3,longest-word-in-dictionary-through-deleting,"class Solution:
    def findLongestWord(self, s: str, d: List[str]) -> str:
        res = ''
        for cand in d:
            if self.find(s, cand) and (len(cand) < len(res) or (len(cand) == len(res) and cand < res)):
                res = cand
        return res
    

    def find(self , s ,d):
        i , j = 0 , 0
        while i < len(s) and j < len(d):
            if s[i] == d[j]:
                i-=1
                j+=1
            else:
                i+=1
        return j == len(d)",None,"class Solution:
    def findLongestWord(self, s: str, d: List[str]) -> str:
        res = ''
        for cand in d:
            if self.find(s, cand) and (len(cand) > len(res) or (len(cand) == len(res) and cand < res)):
                res = cand
        return res
    

    def find(self , s ,d):
        i , j = 0 , 0
        while i < len(s) and j < len(d):
            if s[i] == d[j]:
                i+=1
                j+=1
            else:
                i+=1
        return j == len(d)
"
3435,python3,longest-word-in-dictionary-through-deleting,"class Solution:
    def findLongestWord(self, s: str, d: List[str]) -> str:
        res = ''
        for cand in d:
            if self.find(s, cand) and (len(cand) < len(res) or (len(cand) == len(res) and cand < res)):
                res = cand
        return res
    

    def find(self , s ,d):
        i , j = 0 , 0
        while i < len(s) and j < len(d):
            if s[i] == d[j]:
                i-=1
                j+=1
            else:
                i+=1
        return j == len(d)",None,"class Solution:
    def findLongestWord(self, s: str, d: List[str]) -> str:
        res = ''
        for cand in d:
            if self.find(s, cand) and (len(cand) > len(res) or (len(cand) == len(res) and cand < res)):
                res = cand
        return res
    

    def find(self , s ,d):
        i , j = 0 , 0
        while i < len(s) and j < len(d):
            if s[i] == d[j]:
                i+=1
                j+=1
            else:
                i+=1
        return j == len(d)
"
3435,python3,longest-word-in-dictionary-through-deleting,"class Solution:
    def findLongestWord(self, s: str, d: List[str]) -> str:
        res = ''
        for cand in d:
            if self.find(s, cand) and (len(cand) < len(res) or (len(cand) == len(res) and cand < res)):
                res = cand
        return res
    

    def find(self , s ,d):
        i , j = 0 , 0
        while i < len(s) and j < len(d):
            if s[i] == d[j]:
                i-=1
                j+=1
            else:
                i+=1
        return j == len(d)",None,"class Solution:
    def findLongestWord(self, s: str, d: List[str]) -> str:
        res = ''
        for cand in d:
            if self.find(s, cand) and (len(cand) > len(res) or (len(cand) == len(res) and cand < res)):
                res = cand
        return res
    

    def find(self , s ,d):
        i , j = 0 , 0
        while i < len(s) and j < len(d):
            if s[i] == d[j]:
                i += 1
                j += 1
            else:
                i += 1
        return j == len(d)
"
3436,python3,number-complement,"class Solution:
    def findComplement(self, num: int) -> int:
        com = ''
        while num > 0 :
            
            if num % 2 == 1:
                com += '0'
            else:
                com += '1'
            num = num // 2
        return int(com,2)",None,"class Solution:
    def findComplement(self, num: int) -> int:
        com = ''
        binary_num = bin(num)[2:]
        for digit in binary_num:
            com += '1' if digit == '0' else '0'
        return int(com,2)
"
3436,python3,number-complement,"class Solution:
    def findComplement(self, num: int) -> int:
        com = ''
        while num > 0 :
            
            if num % 2 == 1:
                com += '0'
            else:
                com += '1'
            num = num // 2
        return int(com,2)",None,"class Solution:
    def findComplement(self, num: int) -> int:
        com = ''
        while num > 0 :
            
            if num % 2 == 1:
                com = '0' + com
            else:
                com = '1' + com
            num = num // 2
        return int(com,2)
"
3436,python3,number-complement,"class Solution:
    def findComplement(self, num: int) -> int:
        com = ''
        while num > 0 :
            
            if num % 2 == 1:
                com += '0'
            else:
                com += '1'
            num = num // 2
        return int(com,2)",None,"class Solution:
    def findComplement(self, num: int) -> int:
        com = ''
        binary = bin(num)[2:]
        for bit in binary:
            com += '0' if bit == '1' else '1'
        return int(com,2)
"
3437,python3,design-hashmap,"class MyHashMap:

    def __init__(self):
        self.h = {}

    def put(self, key: int, value: int) -> None:
        if key in self.h:
            self.h[key] = value+1
        else:
            self.h[key] = value

    def get(self, key: int) -> int:
        if key not in self.h:
            return -1
        else:
            return self.h[key]

    def remove(self, key: int) -> None:
        if key in self.h:
            del self.h[key]",None,"class MyHashMap:

    def __init__(self):
        self.h = {}

    def put(self, key: int, value: int) -> None:
        self.h[key] = value

    def get(self, key: int) -> int:
        if key not in self.h:
            return -1
        else:
            return self.h[key]

    def remove(self, key: int) -> None:
        if key in self.h:
            del self.h[key]
"
3437,python3,design-hashmap,"class MyHashMap:

    def __init__(self):
        self.h = {}

    def put(self, key: int, value: int) -> None:
        if key in self.h:
            self.h[key] = value+1
        else:
            self.h[key] = value

    def get(self, key: int) -> int:
        if key not in self.h:
            return -1
        else:
            return self.h[key]

    def remove(self, key: int) -> None:
        if key in self.h:
            del self.h[key]",None,"class MyHashMap:

    def __init__(self):
        self.h = {}

    def put(self, key: int, value: int) -> None:
        self.h[key] = value

    def get(self, key: int) -> int:
        if key not in self.h:
            return -1
        else:
            return self.h[key]

    def remove(self, key: int) -> None:
        if key in self.h:
            del self.h[key]
"
3437,python3,design-hashmap,"class MyHashMap:

    def __init__(self):
        self.h = {}

    def put(self, key: int, value: int) -> None:
        if key in self.h:
            self.h[key] = value+1
        else:
            self.h[key] = value

    def get(self, key: int) -> int:
        if key not in self.h:
            return -1
        else:
            return self.h[key]

    def remove(self, key: int) -> None:
        if key in self.h:
            del self.h[key]",None,"class MyHashMap:

    def __init__(self):
        self.h = {}

    def put(self, key: int, value: int) -> None:
        self.h[key] = value

    def get(self, key: int) -> int:
        if key not in self.h:
            return -1
        else:
            return self.h[key]

    def remove(self, key: int) -> None:
        if key in self.h:
            del self.h[key]
"
3438,python3,find-the-kth-largest-integer-in-the-array,"class Solution:
    def kthLargestNumber(self, nums: List[str], k: int) -> str:
        ls = []
        for i in nums:
            ls.append(int(i))
        sorted_ = sorted(ls)
        return str(sorted_[k])",None,"class Solution:
    def kthLargestNumber(self, nums: List[str], k: int) -> str:
        ls = []
        for i in nums:
            ls.append(int(i))
        sorted_ = sorted(ls, reverse=True)
        return str(sorted_[k - 1])
"
3438,python3,find-the-kth-largest-integer-in-the-array,"class Solution:
    def kthLargestNumber(self, nums: List[str], k: int) -> str:
        ls = []
        for i in nums:
            ls.append(int(i))
        sorted_ = sorted(ls)
        return str(sorted_[k])",None,"class Solution:
    def kthLargestNumber(self, nums: List[str], k: int) -> str:
        ls = []
        for i in nums:
            ls.append(int(i))
        sorted_ = sorted(ls, reverse=True)
        return str(sorted_[k-1])
"
3438,python3,find-the-kth-largest-integer-in-the-array,"class Solution:
    def kthLargestNumber(self, nums: List[str], k: int) -> str:
        ls = []
        for i in nums:
            ls.append(int(i))
        sorted_ = sorted(ls)
        return str(sorted_[k])",None,"class Solution:
    def kthLargestNumber(self, nums: List[str], k: int) -> str:
        ls = []
        for i in nums:
            ls.append(int(i))
        sorted_ = sorted(ls, reverse=True)
        return str(sorted_[k-1])
"
3439,python3,minimum-fuel-cost-to-report-to-the-capital,"class Solution:
    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:
        adjacencyList = [[] for i in range(len(roads) + 1)]
        res = [0]
        for road in roads : 
            adjacencyList[road[0]].append(road[1])
            adjacencyList[road[1]].append(road[0])
        visited = [0 for i in range(len(roads) + 1)]
        visited[0]=1
        def dfs(i,visited):
            if visited[i] == 1:
                return 0
            visited[i] = 1
            tot = 1
            for k in adjacencyList[i]:
                tot += dfs(k,visited)
            if tot%seats == 0:
                res[0] += tot//seats
            else :
                res[0] += tot//seats
            return tot
        for i in adjacencyList[0]:
            total = dfs(i,visited)
        return res[0]",None,"class Solution:
    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:
        adjacencyList = [[] for i in range(len(roads) + 1)]
        res = [0]
        for road in roads : 
            adjacencyList[road[0]].append(road[1])
            adjacencyList[road[1]].append(road[0])
        visited = [0 for i in range(len(roads) + 1)]
        visited[0]=1
        def dfs(i, visited):
            if visited[i] == 1:
                return 0
            visited[i] = 1
            tot = 1
            for k in adjacencyList[i]:
                tot += dfs(k, visited)
            if tot%seats == 0:
                res[0] += tot//seats - 1
            else:
                res[0] += tot//seats
            return tot
        for i in adjacencyList[0]:
            total = dfs(i, visited)
        return res[0]
"
3439,python3,minimum-fuel-cost-to-report-to-the-capital,"class Solution:
    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:
        adjacencyList = [[] for i in range(len(roads) + 1)]
        res = [0]
        for road in roads : 
            adjacencyList[road[0]].append(road[1])
            adjacencyList[road[1]].append(road[0])
        visited = [0 for i in range(len(roads) + 1)]
        visited[0]=1
        def dfs(i,visited):
            if visited[i] == 1:
                return 0
            visited[i] = 1
            tot = 1
            for k in adjacencyList[i]:
                tot += dfs(k,visited)
            if tot%seats == 0:
                res[0] += tot//seats
            else :
                res[0] += tot//seats
            return tot
        for i in adjacencyList[0]:
            total = dfs(i,visited)
        return res[0]",None,"class Solution:
    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:
        adjacencyList = [[] for i in range(len(roads) + 1)]
        res = [0]
        for road in roads : 
            adjacencyList[road[0]].append(road[1])
            adjacencyList[road[1]].append(road[0])
        visited = [0 for i in range(len(roads) + 1)]
        visited[0]=1
        def dfs(i,visited):
            if visited[i] == 1:
                return 0
            visited[i] = 1
            tot = 1
            for k in adjacencyList[i]:
                tot += dfs(k,visited)
            if tot%seats == 0:
                res[0] += tot//seats
            else :
                res[0] += tot//seats + 1
                tot = tot % seats
            return tot
        for i in adjacencyList[0]:
            total = dfs(i,visited)
        return res[0]
"
3439,python3,minimum-fuel-cost-to-report-to-the-capital,"class Solution:
    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:
        adjacencyList = [[] for i in range(len(roads) + 1)]
        res = [0]
        for road in roads : 
            adjacencyList[road[0]].append(road[1])
            adjacencyList[road[1]].append(road[0])
        visited = [0 for i in range(len(roads) + 1)]
        visited[0]=1
        def dfs(i,visited):
            if visited[i] == 1:
                return 0
            visited[i] = 1
            tot = 1
            for k in adjacencyList[i]:
                tot += dfs(k,visited)
            if tot%seats == 0:
                res[0] += tot//seats
            else :
                res[0] += tot//seats
            return tot
        for i in adjacencyList[0]:
            total = dfs(i,visited)
        return res[0]",None,"class Solution:
    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:
        adjacencyList = [[] for i in range(len(roads) + 1)]
        res = [0]
        for road in roads : 
            adjacencyList[road[0]].append(road[1])
            adjacencyList[road[1]].append(road[0])
        visited = [0 for i in range(len(roads) + 1)]
        visited[0]=1
        def dfs(i,visited):
            if visited[i] == 1:
                return 0
            visited[i] = 1
            tot = 1
            for k in adjacencyList[i]:
                tot += dfs(k,visited)
            if tot%seats == 0:
                res[0] += tot//seats
            else :
                res[0] += tot//seats + 1
            return tot
        for i in adjacencyList[0]:
            total = dfs(i,visited)
        return res[0]
"
3440,python3,check-if-two-string-arrays-are-equivalent,"class Solution:
    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        word3="""".join(word1.reverse())
        word4="""".join(word2)
        if word3==word4:
            return True
        else:
            return False",None,"class Solution:
    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        word3="""".join(word1)
        word4="""".join(word2)
        if word3==word4:
            return True
        else:
            return False
"
3440,python3,check-if-two-string-arrays-are-equivalent,"class Solution:
    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        word3="""".join(word1.reverse())
        word4="""".join(word2)
        if word3==word4:
            return True
        else:
            return False",None,"class Solution:
    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        word3="""".join(word1)
        word4="""".join(word2)
        if word3==word4:
            return True
        else:
            return False
"
3440,python3,check-if-two-string-arrays-are-equivalent,"class Solution:
    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        word3="""".join(word1.reverse())
        word4="""".join(word2)
        if word3==word4:
            return True
        else:
            return False",None,"class Solution:
    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        word3 = """".join(word1)
        word4 = """".join(word2)
        if word3 == word4:
            return True
        else:
            return False
"
3441,python3,string-compression-ii,"class Solution:
    def dp(self,i,s,prev,k,ct,n,dct):
        if k<0:
            return float(""infinity"")
        if i>=n:
            x=0
            if ct>1:
                x=len(str(ct))+1
            elif ct==1:
                x=1
            return x
        if (i,prev,ct,k) in dct:
            return dct[(i,prev,ct,k)]
        if s[i]==prev:
            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)
        else:
            x=0
            if ct>1:
                x=len(str(ct))+1
            elif ct==1:
                x=1
            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)
        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)
        dct[(i,prev,ct,k)]=max(inc,exc)
        return min(inc,exc)


    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        n=len(s)
        return self.dp(0,s,"""",k,0,n,{})",None,"class Solution:
    def dp(self, i, s, prev, k, ct, n, dct):
        if k < 0:
            return float(""infinity"")
        if i >= n:
            x = 0
            if ct > 1:
                x = len(str(ct)) + 1
            elif ct == 1:
                x = 1
            return x
        if (i, prev, ct, k) in dct:
            return dct[(i, prev, ct, k)]
        exc = self.dp(i + 1, s, prev, k - 1, ct, n, dct)
        if s[i] == prev:
            inc = self.dp(i + 1, s, prev, k, ct + 1, n, dct)
        else:
            x = 0
            if ct > 1:
                x = len(str(ct)) + 1
            elif ct == 1:
                x = 1
            inc = x + self.dp(i + 1, s, s[i], k, 1, n, dct)
        dct[(i, prev, ct, k)] = min(inc, exc)
        return dct[(i, prev, ct, k)]

    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        n = len(s)
        return self.dp(0, s, """", k, 0, n, {})
"
3441,python3,string-compression-ii,"class Solution:
    def dp(self,i,s,prev,k,ct,n,dct):
        if k<0:
            return float(""infinity"")
        if i>=n:
            x=0
            if ct>1:
                x=len(str(ct))+1
            elif ct==1:
                x=1
            return x
        if (i,prev,ct,k) in dct:
            return dct[(i,prev,ct,k)]
        if s[i]==prev:
            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)
        else:
            x=0
            if ct>1:
                x=len(str(ct))+1
            elif ct==1:
                x=1
            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)
        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)
        dct[(i,prev,ct,k)]=max(inc,exc)
        return min(inc,exc)


    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        n=len(s)
        return self.dp(0,s,"""",k,0,n,{})",None,"class Solution:
    def dp(self, i, s, prev, k, ct, n, dct):
        if k < 0:
            return float(""infinity"")
        if i >= n:
            x = 0
            if ct > 1:
                x = len(str(ct)) + 1
            elif ct == 1:
                x = 1
            return x
        if (i, prev, ct, k) in dct:
            return dct[(i, prev, ct, k)]
        if s[i] == prev:
            inc = self.dp(i + 1, s, prev, k, ct + 1, n, dct)
        else:
            x = 0
            if ct > 1:
                x = len(str(ct)) + 1
            elif ct == 1:
                x = 1
            inc = x + self.dp(i + 1, s, s[i], k, 1, n, dct)
        exc = self.dp(i + 1, s, prev, k - 1, ct, n, dct)
        dct[(i, prev, ct, k)] = min(inc, exc)
        return min(inc, exc)

    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        n = len(s)
        return self.dp(0, s, """", k, 0, n, {})
"
3441,python3,string-compression-ii,"class Solution:
    def dp(self,i,s,prev,k,ct,n,dct):
        if k<0:
            return float(""infinity"")
        if i>=n:
            x=0
            if ct>1:
                x=len(str(ct))+1
            elif ct==1:
                x=1
            return x
        if (i,prev,ct,k) in dct:
            return dct[(i,prev,ct,k)]
        if s[i]==prev:
            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)
        else:
            x=0
            if ct>1:
                x=len(str(ct))+1
            elif ct==1:
                x=1
            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)
        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)
        dct[(i,prev,ct,k)]=max(inc,exc)
        return min(inc,exc)


    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        n=len(s)
        return self.dp(0,s,"""",k,0,n,{})",None,"class Solution:
    def dp(self,i,s,prev,k,ct,n,dct):
        if k<0:
            return float(""infinity"")
        if i>=n:
            x=0
            if ct>1:
                x=len(str(ct))+1
            elif ct==1:
                x=1
            return x
        if (i,prev,ct,k) in dct:
            return dct[(i,prev,ct,k)]
        if s[i]==prev:
            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)
            if ct==0:
                x=1
            else:
                x=len(str(ct+1))+1
            inc=min(inc,x)
        else:
            x=0
            if ct>1:
                x=len(str(ct))+1
            elif ct==1:
                x=1
            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)
        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)
        dct[(i,prev,ct,k)]=min(inc,exc)
        return dct[(i,prev,ct,k)]


    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        n=len(s)
        return self.dp(0,s,"""",k,0,n,{})
"
3442,python3,longest-well-performing-interval,"class Solution:
    def longestWPI(self, A):
        curr, ans, D = 0, 0, {}
        for e, i in enumerate(map(lambda x: (-1, 1)[x > 8], A)):
            curr += i
            D[curr] = D.get(curr, e)
            ans = e + 1 if curr > 0 else max(ans, e - D.get(curr - 1, e))
        return ans + 1",None,"class Solution:
    def longestWPI(self, A):
        curr, ans, D = 0, 0, {}
        for e, i in enumerate(map(lambda x: (-1, 1)[x > 8], A)):
            curr += i
            D[curr] = D.get(curr, e)
            ans = e + 1 if curr > 0 else max(ans, e - D.get(curr - 1, float('-inf')))
        return ans
"
3442,python3,longest-well-performing-interval,"class Solution:
    def longestWPI(self, A):
        curr, ans, D = 0, 0, {}
        for e, i in enumerate(map(lambda x: (-1, 1)[x > 8], A)):
            curr += i
            D[curr] = D.get(curr, e)
            ans = e + 1 if curr > 0 else max(ans, e - D.get(curr - 1, e))
        return ans + 1",None,"class Solution:
    def longestWPI(self, A):
        curr, ans, D = 0, 0, {}
        for e, i in enumerate(map(lambda x: (-1, 1)[x > 8], A)):
            curr += i
            if curr > 0:
                ans = max(ans, e + 1)
            else:
                D.setdefault(curr, e)
                if curr - 1 in D:
                    ans = max(ans, e - D[curr - 1])
        return ans
"
3442,python3,longest-well-performing-interval,"class Solution:
    def longestWPI(self, A):
        curr, ans, D = 0, 0, {}
        for e, i in enumerate(map(lambda x: (-1, 1)[x > 8], A)):
            curr += i
            D[curr] = D.get(curr, e)
            ans = e + 1 if curr > 0 else max(ans, e - D.get(curr - 1, e))
        return ans + 1",None,"class Solution:
    def longestWPI(self, hours):
        curr, ans, D = 0, 0, {}
        for e, i in enumerate(map(lambda x: (-1, 1)[x > 8], hours)):
            curr += i
            if curr > 0:
                ans = e + 1
            else:
                D.setdefault(curr, e)
                if curr - 1 in D:
                    ans = max(ans, e - D[curr - 1])
        return ans
"
3443,python3,longest-happy-prefix,"class Solution:
    def longestPrefix(self, s: str) -> str:
        n=len(s)
        lps=[0]*n
        j=0
        for i in range(1,n):
            while s[i]!=s[j] and j>0:
                j=lps[j]

            if s[i]==s[j]:
                lps[i]=j+1
                j+=1

        return s[:lps[-1]]",None,"class Solution:
    def longestPrefix(self, s: str) -> str:
        n=len(s)
        lps=[0]*n
        j=0
        for i in range(1,n):
            while s[i]!=s[j] and j>0:
                j=lps[j-1]

            if s[i]==s[j]:
                lps[i]=j+1
                j+=1

        return s[:lps[-1]]
"
3443,python3,longest-happy-prefix,"class Solution:
    def longestPrefix(self, s: str) -> str:
        n=len(s)
        lps=[0]*n
        j=0
        for i in range(1,n):
            while s[i]!=s[j] and j>0:
                j=lps[j]

            if s[i]==s[j]:
                lps[i]=j+1
                j+=1

        return s[:lps[-1]]",None,"class Solution:
    def longestPrefix(self, s: str) -> str:
        n=len(s)
        lps=[0]*n
        j=0
        for i in range(1,n):
            while s[i]!=s[j] and j>0:
                j=lps[j-1]

            if s[i]==s[j]:
                lps[i]=j+1
                j+=1

        return s[:lps[-1]]
"
3443,python3,longest-happy-prefix,"class Solution:
    def longestPrefix(self, s: str) -> str:
        n=len(s)
        lps=[0]*n
        j=0
        for i in range(1,n):
            while s[i]!=s[j] and j>0:
                j=lps[j]

            if s[i]==s[j]:
                lps[i]=j+1
                j+=1

        return s[:lps[-1]]",None,"class Solution:
    def longestPrefix(self, s: str) -> str:
        n=len(s)
        lps=[0]*n
        j=0
        for i in range(1,n):
            while s[i]!=s[j] and j>0:
                j=lps[j-1]

            if s[i]==s[j]:
                lps[i]=j+1
                j+=1

        return s[:lps[-1]]
"
3444,python3,best-time-to-buy-and-sell-stock-with-cooldown,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n=len(prices)
        ahd=[0]*2
        ahd2=[0]*2
        for i in range(n-1,-1,-1):
            curr=[0]*2
            for buy in range(2):
                if buy:
                    curr[buy]=max(ahd[buy],ahd[0]-prices[i])
                else:
                    curr[buy]=max(ahd[buy],ahd2[0]+prices[i])  
            ahd2=ahd[:]
            ahd=curr[:]
        return ahd[1]",None,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n=len(prices)
        ahd=[0]*2
        ahd2=[0]*2
        for i in range(n-1,-1,-1):
            curr=[0]*2
            for buy in range(2):
                if buy:
                    curr[buy]=max(ahd[buy],ahd[1]-prices[i])
                else:
                    curr[buy]=max(ahd[buy],ahd2[1]+prices[i])  
            ahd2=ahd[:]
            ahd=curr[:]
        return ahd[0]
"
3444,python3,best-time-to-buy-and-sell-stock-with-cooldown,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n=len(prices)
        ahd=[0]*2
        ahd2=[0]*2
        for i in range(n-1,-1,-1):
            curr=[0]*2
            for buy in range(2):
                if buy:
                    curr[buy]=max(ahd[buy],ahd[0]-prices[i])
                else:
                    curr[buy]=max(ahd[buy],ahd2[0]+prices[i])  
            ahd2=ahd[:]
            ahd=curr[:]
        return ahd[1]",None,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        ahd = [0]*2
        ahd2 = [0]*2
        for i in range(n-1, -1, -1):
            curr = [0]*2
            for buy in range(2):
                if buy:
                    curr[buy] = max(ahd[buy], ahd[0] - prices[i])
                else:
                    curr[buy] = max(ahd[buy], ahd2[1] + prices[i])  
            ahd2 = ahd[:]
            ahd = curr[:]
        return ahd[0]
"
3444,python3,best-time-to-buy-and-sell-stock-with-cooldown,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n=len(prices)
        ahd=[0]*2
        ahd2=[0]*2
        for i in range(n-1,-1,-1):
            curr=[0]*2
            for buy in range(2):
                if buy:
                    curr[buy]=max(ahd[buy],ahd[0]-prices[i])
                else:
                    curr[buy]=max(ahd[buy],ahd2[0]+prices[i])  
            ahd2=ahd[:]
            ahd=curr[:]
        return ahd[1]",None,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n=len(prices)
        ahd=[0]*2
        ahd2=[0]*2
        for i in range(n-1,-1,-1):
            curr=[0]*2
            for buy in range(2):
                if buy:
                    curr[buy]=max(ahd[buy],ahd[0]-prices[i])
                else:
                    curr[buy]=max(ahd[buy],ahd2[1]+prices[i])  
            ahd2=ahd[:]
            ahd=curr[:]
        return ahd[0]
"
3445,python3,amount-of-time-for-binary-tree-to-be-infected,"class Solution:       
    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:
        graph = defaultdict(list)
        
        stack = [(root, None)]
        while stack: 
            n, p = stack.pop()
            if p: 
                graph[p.val].append(n.val)
                graph[n.val].append(p.val)
            if n.left: stack.append((n.left, n))
            if n.right: stack.append((n.right, n))
        
        ans = -1
        seen = {start}
        queue = deque([start])
        while queue: 
            for _ in range(len(queue)): 
                u = queue.pop()
                for v in graph[u]: 
                    if v not in seen: 
                        seen.add(v)
                        queue.append(v)
            ans += 1
        return ans",None,"class Solution:       
    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:
        graph = defaultdict(list)
        
        stack = [(root, None)]
        while stack: 
            n, p = stack.pop()
            if p: 
                graph[p.val].append(n.val)
                graph[n.val].append(p.val)
            if n.left: stack.append((n.left, n))
            if n.right: stack.append((n.right, n))
        
        ans = -1
        seen = {start}
        queue = deque([start])
        while queue: 
            tempQueue = deque()
            for node in queue: 
                for neighbour in graph[node]: 
                    if neighbour not in seen: 
                        seen.add(neighbour)
                        tempQueue.append(neighbour)
            queue = tempQueue
            ans += 1
        return ans
"
3445,python3,amount-of-time-for-binary-tree-to-be-infected,"class Solution:       
    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:
        graph = defaultdict(list)
        
        stack = [(root, None)]
        while stack: 
            n, p = stack.pop()
            if p: 
                graph[p.val].append(n.val)
                graph[n.val].append(p.val)
            if n.left: stack.append((n.left, n))
            if n.right: stack.append((n.right, n))
        
        ans = -1
        seen = {start}
        queue = deque([start])
        while queue: 
            for _ in range(len(queue)): 
                u = queue.pop()
                for v in graph[u]: 
                    if v not in seen: 
                        seen.add(v)
                        queue.append(v)
            ans += 1
        return ans",None,"class Solution:       
    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:
        graph = defaultdict(list)
        
        stack = [(root, None)]
        while stack: 
            n, p = stack.pop()
            if p: 
                graph[p.val].append(n.val)
                graph[n.val].append(p.val)
            if n.left: stack.append((n.left, n))
            if n.right: stack.append((n.right, n))
        
        ans = -1
        seen = {start}
        queue = deque([start])
        while queue: 
            for _ in range(len(queue)): 
                u = queue.popleft()
                for v in graph[u]: 
                    if v not in seen: 
                        seen.add(v)
                        queue.append(v)
            ans += 1
        return ans
"
3445,python3,amount-of-time-for-binary-tree-to-be-infected,"class Solution:       
    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:
        graph = defaultdict(list)
        
        stack = [(root, None)]
        while stack: 
            n, p = stack.pop()
            if p: 
                graph[p.val].append(n.val)
                graph[n.val].append(p.val)
            if n.left: stack.append((n.left, n))
            if n.right: stack.append((n.right, n))
        
        ans = -1
        seen = {start}
        queue = deque([start])
        while queue: 
            for _ in range(len(queue)): 
                u = queue.pop()
                for v in graph[u]: 
                    if v not in seen: 
                        seen.add(v)
                        queue.append(v)
            ans += 1
        return ans",None,"class Solution:       
    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:
        graph = defaultdict(list)
        
        stack = [(root, None)]
        while stack: 
            n, p = stack.pop()
            if p: 
                graph[p.val].append(n.val)
                graph[n.val].append(p.val)
            if n.left: stack.append((n.left, n))
            if n.right: stack.append((n.right, n))
        
        ans = -1
        seen = {start}
        queue = deque([start])
        while queue: 
            for _ in range(len(queue)): 
                u = queue.popleft()
                for v in graph[u]: 
                    if v not in seen: 
                        seen.add(v)
                        queue.append(v)
            ans += 1
        return ans
"
3446,python3,maximum-of-absolute-value-expression,"class Solution:
    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
        val1,val2,val3,val4=[],[],[],[]
        for i in range(len(arr1)):
            val1.append(i+arr1[i]+arr2[i])
            val2.append(i+arr1[i]-arr2[i])
            val3.append(i-arr1[i]+arr2[i])
            val4.append(i-arr1[i]-arr2[i])
        ans=0
        ans=min(ans,max(val1)-min(val1))
        ans=min(ans,max(val2)-min(val2))
        ans=min(ans,max(val3)-min(val3))
        ans=min(ans,max(val4)-min(val4))
        return ans",None,"class Solution:
    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
        val1,val2,val3,val4=[],[],[],[]
        for i in range(len(arr1)):
            val1.append(i+arr1[i]+arr2[i])
            val2.append(i+arr1[i]-arr2[i])
            val3.append(i-arr1[i]+arr2[i])
            val4.append(i-arr1[i]-arr2[i])
        ans=0
        ans=max(ans,max(val1)-min(val1))
        ans=max(ans,max(val2)-min(val2))
        ans=max(ans,max(val3)-min(val3))
        ans=max(ans,max(val4)-min(val4))
        return ans
"
3446,python3,maximum-of-absolute-value-expression,"class Solution:
    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
        val1,val2,val3,val4=[],[],[],[]
        for i in range(len(arr1)):
            val1.append(i+arr1[i]+arr2[i])
            val2.append(i+arr1[i]-arr2[i])
            val3.append(i-arr1[i]+arr2[i])
            val4.append(i-arr1[i]-arr2[i])
        ans=0
        ans=min(ans,max(val1)-min(val1))
        ans=min(ans,max(val2)-min(val2))
        ans=min(ans,max(val3)-min(val3))
        ans=min(ans,max(val4)-min(val4))
        return ans",None,"class Solution:
    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
        val1,val2,val3,val4=[],[],[],[]
        for i in range(len(arr1)):
            val1.append(i+arr1[i]+arr2[i])
            val2.append(i+arr1[i]-arr2[i])
            val3.append(i-arr1[i]+arr2[i])
            val4.append(i-arr1[i]-arr2[i])
        ans=0
        ans=max(ans,max(val1)-min(val1))
        ans=max(ans,max(val2)-min(val2))
        ans=max(ans,max(val3)-min(val3))
        ans=max(ans,max(val4)-min(val4))
        return ans
"
3446,python3,maximum-of-absolute-value-expression,"class Solution:
    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
        val1,val2,val3,val4=[],[],[],[]
        for i in range(len(arr1)):
            val1.append(i+arr1[i]+arr2[i])
            val2.append(i+arr1[i]-arr2[i])
            val3.append(i-arr1[i]+arr2[i])
            val4.append(i-arr1[i]-arr2[i])
        ans=0
        ans=min(ans,max(val1)-min(val1))
        ans=min(ans,max(val2)-min(val2))
        ans=min(ans,max(val3)-min(val3))
        ans=min(ans,max(val4)-min(val4))
        return ans",None,"class Solution:
    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
        val1,val2,val3,val4=[],[],[],[]
        for i in range(len(arr1)):
            val1.append(i+arr1[i]+arr2[i])
            val2.append(i+arr1[i]-arr2[i])
            val3.append(i-arr1[i]+arr2[i])
            val4.append(i-arr1[i]-arr2[i])
        ans=0
        ans=max(ans,max(val1)-min(val1))
        ans=max(ans,max(val2)-min(val2))
        ans=max(ans,max(val3)-min(val3))
        ans=max(ans,max(val4)-min(val4))
        return ans
"
3447,python3,rank-transform-of-an-array,"class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        list1=[]
        x=sorted(set(arr))
        dict1={}
        for i in range(len(x)):
            dict1[x[i]]=i
        for j in arr:
            dict1[j]+=1
            y=dict1[j]
            list1.append(y)
        return list1",None,"class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        sorted_arr = sorted(set(arr))
        dict1 = {val: rank+1 for rank, val in enumerate(sorted_arr)}
        return [dict1[i] for i in arr]
"
3447,python3,rank-transform-of-an-array,"class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        list1=[]
        x=sorted(set(arr))
        dict1={}
        for i in range(len(x)):
            dict1[x[i]]=i
        for j in arr:
            dict1[j]+=1
            y=dict1[j]
            list1.append(y)
        return list1",None,"class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        rank_dict = {val: rank+1 for rank, val in enumerate(sorted(set(arr)))}
        return [rank_dict[i] for i in arr]
"
3447,python3,rank-transform-of-an-array,"class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        list1=[]
        x=sorted(set(arr))
        dict1={}
        for i in range(len(x)):
            dict1[x[i]]=i
        for j in arr:
            dict1[j]+=1
            y=dict1[j]
            list1.append(y)
        return list1",None,"class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        sorted_set = sorted(set(arr))
        dict1 = {value: i + 1 for i, value in enumerate(sorted_set)}
        return [dict1[i] for i in arr]
"
3448,python3,find-the-string-with-lcp,"class Solution:
    def findTheString(self, lcp: List[List[int]]) -> str:
        n = len(lcp)

        for i in range(n):
            for j in range(i + 1, n):
                if lcp[i][j] != lcp[j][i]:
                    return ''
                if lcp[i][j] > n - j:
                    return ''
        for i in range(n):
            if lcp[i][i] != n - i:
                return ''

        pattern = [None for _ in range(n)]
        next_el_ind = 0
        for i in range(n):
            if pattern[i] is not None:
                continue
            pattern[i] = next_el_ind
            next_el_ind += 1
            for j in range(i+1, n):
                if lcp[i][j] > 0:
                    if pattern[j] is not None and pattern[j] != pattern[i]:      
                        return ''      
                    pattern[j] = pattern[i]

        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]
        for i in range(n-1, -1, -1):
            for j in range(n-1, -1, -1):
                if pattern[i] == pattern[j]:
                    if max(i, j) + 1 < n:
                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 2 //Add 2 instead of 1
                    else:
                        pattern_lcp[i][j] = 1
        for i in range(n):
            for j in range(n):
                if lcp[i][j] != pattern_lcp[i][j]:
                    return ''


        if max(pattern) > ord('z') - ord('a'):
            return ''

        return  ''.join(chr(ord('a') + ind) for ind in pattern)",None,"class Solution:
    def findTheString(self, lcp: List[List[int]]) -> str:
        n = len(lcp)

        for i in range(n):
            for j in range(i + 1, n):
                if lcp[i][j] != lcp[j][i]:
                    return ''
                if lcp[i][j] > n - j:
                    return ''
        for i in range(n):
            if lcp[i][i] != n - i:
                return ''

        pattern = [None for _ in range(n)]
        next_el_ind = 0
        for i in range(n):
            if pattern[i] is not None:
                continue
            pattern[i] = next_el_ind
            next_el_ind += 1
            for j in range(i+1, n):
                if lcp[i][j] > 0:
                    if pattern[j] is not None and pattern[j] != pattern[i]:      
                        return ''      
                    pattern[j] = pattern[i]

        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]
        for i in range(n-1, -1, -1):
            for j in range(n-1, -1, -1):
                if pattern[i] == pattern[j]:
                    if max(i, j) + 1 < n:
                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1 #Add 1 instead of 2
                    else:
                        pattern_lcp[i][j] = 1
        for i in range(n):
            for j in range(n):
                if lcp[i][j] != pattern_lcp[i][j]:
                    return ''

        if max(pattern) > ord('z') - ord('a'):
            return ''

        return  ''.join(chr(ord('a') + ind) for ind in pattern)
"
3448,python3,find-the-string-with-lcp,"class Solution:
    def findTheString(self, lcp: List[List[int]]) -> str:
        n = len(lcp)

        for i in range(n):
            for j in range(i + 1, n):
                if lcp[i][j] != lcp[j][i]:
                    return ''
                if lcp[i][j] > n - j:
                    return ''
        for i in range(n):
            if lcp[i][i] != n - i:
                return ''

        pattern = [None for _ in range(n)]
        next_el_ind = 0
        for i in range(n):
            if pattern[i] is not None:
                continue
            pattern[i] = next_el_ind
            next_el_ind += 1
            for j in range(i+1, n):
                if lcp[i][j] > 0:
                    if pattern[j] is not None and pattern[j] != pattern[i]:      
                        return ''      
                    pattern[j] = pattern[i]

        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]
        for i in range(n-1, -1, -1):
            for j in range(n-1, -1, -1):
                if pattern[i] == pattern[j]:
                    if max(i, j) + 1 < n:
                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 2 //Add 2 instead of 1
                    else:
                        pattern_lcp[i][j] = 1
        for i in range(n):
            for j in range(n):
                if lcp[i][j] != pattern_lcp[i][j]:
                    return ''


        if max(pattern) > ord('z') - ord('a'):
            return ''

        return  ''.join(chr(ord('a') + ind) for ind in pattern)",None,"class Solution:
    def findTheString(self, lcp: List[List[int]]) -> str:
        n = len(lcp)

        for i in range(n):
            for j in range(i + 1, n):
                if lcp[i][j] != lcp[j][i]:
                    return ''
                if lcp[i][j] > n - j:
                    return ''
        for i in range(n):
            if lcp[i][i] != n - i:
                return ''

        pattern = [None for _ in range(n)]
        next_el_ind = 0
        for i in range(n):
            if pattern[i] is not None:
                continue
            pattern[i] = next_el_ind
            next_el_ind += 1
            for j in range(i+1, n):
                if lcp[i][j] > 0:
                    if pattern[j] is not None and pattern[j] != pattern[i]:      
                        return ''      
                    pattern[j] = pattern[i]

        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]
        for i in range(n-1, -1, -1):
            for j in range(n-1, -1, -1):
                if pattern[i] == pattern[j]:
                    if max(i, j) + 1 < n:
                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1 # add 1 instead of 2
                    else:
                        pattern_lcp[i][j] = 1
        for i in range(n):
            for j in range(n):
                if lcp[i][j] != pattern_lcp[i][j]:
                    return ''

        if max(pattern) > ord('z') - ord('a'):
            return ''

        return  ''.join(chr(ord('a') + ind) for ind in pattern)
"
3448,python3,find-the-string-with-lcp,"class Solution:
    def findTheString(self, lcp: List[List[int]]) -> str:
        n = len(lcp)

        for i in range(n):
            for j in range(i + 1, n):
                if lcp[i][j] != lcp[j][i]:
                    return ''
                if lcp[i][j] > n - j:
                    return ''
        for i in range(n):
            if lcp[i][i] != n - i:
                return ''

        pattern = [None for _ in range(n)]
        next_el_ind = 0
        for i in range(n):
            if pattern[i] is not None:
                continue
            pattern[i] = next_el_ind
            next_el_ind += 1
            for j in range(i+1, n):
                if lcp[i][j] > 0:
                    if pattern[j] is not None and pattern[j] != pattern[i]:      
                        return ''      
                    pattern[j] = pattern[i]

        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]
        for i in range(n-1, -1, -1):
            for j in range(n-1, -1, -1):
                if pattern[i] == pattern[j]:
                    if max(i, j) + 1 < n:
                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 2 //Add 2 instead of 1
                    else:
                        pattern_lcp[i][j] = 1
        for i in range(n):
            for j in range(n):
                if lcp[i][j] != pattern_lcp[i][j]:
                    return ''


        if max(pattern) > ord('z') - ord('a'):
            return ''

        return  ''.join(chr(ord('a') + ind) for ind in pattern)",None,"class Solution:
    def findTheString(self, lcp: List[List[int]]) -> str:
        n = len(lcp)

        for i in range(n):
            for j in range(i + 1, n):
                if lcp[i][j] != lcp[j][i]:
                    return ''
                if lcp[i][j] > n - j:
                    return ''
        for i in range(n):
            if lcp[i][i] != n - i:
                return ''

        pattern = [None for _ in range(n)]
        next_el_ind = 0
        for i in range(n):
            if pattern[i] is not None:
                continue
            pattern[i] = next_el_ind
            next_el_ind += 1
            for j in range(i+1, n):
                if lcp[i][j] > 0:
                    if pattern[j] is not None and pattern[j] != pattern[i]:      
                        return ''      
                    pattern[j] = pattern[i]

        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]
        for i in range(n-1, -1, -1):
            for j in range(n-1, -1, -1):
                if pattern[i] == pattern[j]:
                    if max(i, j) + 1 < n:
                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1  #fix: Add 1 instead of 2
                    else:
                        pattern_lcp[i][j] = 1
        for i in range(n):
            for j in range(n):
                if lcp[i][j] != pattern_lcp[i][j]:
                    return ''

        if max(pattern) > ord('z') - ord('a'):
            return ''

        return  ''.join(chr(ord('a') + ind) for ind in pattern)
"
3449,python3,find-first-palindromic-string-in-the-array,"class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        for i in words:
            if i==i.sort():
                return i
        return """"",None,"class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        for i in words:
            if i==i[::-1]:
                return i
        return """"
"
3449,python3,find-first-palindromic-string-in-the-array,"class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        for i in words:
            if i==i.sort():
                return i
        return """"",None,"class Solution:
    def firstPalindrome(self, words):
        for word in words:
            if word == word[::-1]:
                return word
        return """"
"
3449,python3,find-first-palindromic-string-in-the-array,"class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        for i in words:
            if i==i.sort():
                return i
        return """"",None,"class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        for i in words:
            if i==i[::-1]:
                return i
        return """"
"
3450,python3,koko-eating-bananas,"class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        def check(x):
            return sum(ceil(ele/x) for ele in piles) <= h

        l = 1
        r = max(piles)
        while l < r:
            mid = (l+r) // 1
            if not check(mid):
                l=mid+1
            else:
                r=mid
        return l",None,"from math import ceil
from typing import List

class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        def check(x):
            return sum(ceil(ele/x) for ele in piles) <= h

        l = 1
        r = max(piles)
        while l < r:
            mid = (l + r) // 2
            if not check(mid):
                l = mid + 1
            else:
                r = mid
        return l
"
3450,python3,koko-eating-bananas,"class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        def check(x):
            return sum(ceil(ele/x) for ele in piles) <= h

        l = 1
        r = max(piles)
        while l < r:
            mid = (l+r) // 1
            if not check(mid):
                l=mid+1
            else:
                r=mid
        return l",None,"class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        def check(x):
            return sum(math.ceil(ele/x) for ele in piles) <= h

        l = 1
        r = max(piles)
        while l < r:
            mid = (l+r) // 2
            if not check(mid):
                l=mid+1
            else:
                r=mid
        return l
"
3450,python3,koko-eating-bananas,"class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        def check(x):
            return sum(ceil(ele/x) for ele in piles) <= h

        l = 1
        r = max(piles)
        while l < r:
            mid = (l+r) // 1
            if not check(mid):
                l=mid+1
            else:
                r=mid
        return l",None,"class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        def check(x):
            return sum(ceil(ele/x) for ele in piles) <= h

        l = 1
        r = max(piles)
        while l < r:
            mid = (l+r) // 2
            if not check(mid):
                l = mid + 1
            else:
                r = mid
        return l
"
3451,python3,maximum-difference-between-node-and-ancestor,"def fun(root,mx,mn,ans):
    if(root==None):
        return
    d1=abs(root.val-mx)
    d2=abs(root.val-mn)
    ans[0]=max(d1,d2,ans[0])
    mx=max(mx,root.val)
    mn=min(mn,root.val)
    fun(root.left,mx,mn,ans)
    fun(root.right,mx,mn,ans)
class Solution:
    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:
        ans=[0]
        if(root==None):
            return 0
        fun(root,root.val,root.val,ans)
        return 0",None,"def fun(root, mx, mn, ans):
    if root is None:
        return
    d1 = abs(root.val - mx)
    d2 = abs(root.val - mn)
    ans[0] = max(d1, d2, ans[0])
    mx = max(mx, root.val)
    mn = min(mn, root.val)
    fun(root.left, mx, mn, ans)
    fun(root.right, mx, mn, ans)

class Solution:
    def maxAncestorDiff(self, root) -> int:
        ans = [0]
        if root is None:
            return 0
        fun(root, root.val, root.val, ans)
        return ans[0]
"
3451,python3,maximum-difference-between-node-and-ancestor,"def fun(root,mx,mn,ans):
    if(root==None):
        return
    d1=abs(root.val-mx)
    d2=abs(root.val-mn)
    ans[0]=max(d1,d2,ans[0])
    mx=max(mx,root.val)
    mn=min(mn,root.val)
    fun(root.left,mx,mn,ans)
    fun(root.right,mx,mn,ans)
class Solution:
    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:
        ans=[0]
        if(root==None):
            return 0
        fun(root,root.val,root.val,ans)
        return 0",None,"def fun(root,mx,mn,ans):
    if(root==None):
        return
    d1=abs(root.val-mx)
    d2=abs(root.val-mn)
    ans[0]=max(d1,d2,ans[0])
    mx=max(mx,root.val)
    mn=min(mn,root.val)
    fun(root.left,mx,mn,ans)
    fun(root.right,mx,mn,ans)
    
class Solution:
    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:
        ans=[0]
        if(root==None):
            return 0
        fun(root,root.val,root.val,ans)
        return ans[0]
"
3451,python3,maximum-difference-between-node-and-ancestor,"def fun(root,mx,mn,ans):
    if(root==None):
        return
    d1=abs(root.val-mx)
    d2=abs(root.val-mn)
    ans[0]=max(d1,d2,ans[0])
    mx=max(mx,root.val)
    mn=min(mn,root.val)
    fun(root.left,mx,mn,ans)
    fun(root.right,mx,mn,ans)
class Solution:
    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:
        ans=[0]
        if(root==None):
            return 0
        fun(root,root.val,root.val,ans)
        return 0",None,"def fun(root,mx,mn,ans):
    if(root==None):
        return
    d1=abs(root.val-mx)
    d2=abs(root.val-mn)
    ans[0]=max(d1,d2,ans[0])
    mx=max(mx,root.val)
    mn=min(mn,root.val)
    fun(root.left,mx,mn,ans)
    fun(root.right,mx,mn,ans)

class Solution:
    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:
        ans=[0]
        if(root==None):
            return 0
        fun(root,root.val,root.val,ans)
        return ans[0]
"
3452,python3,word-subsets,"class Solution:
    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:
        w2 = reduce(operator.and_, map(Counter, words2))
        return [w1 for w1 in words1 if Counter(w1) >= w2]",None,"from collections import Counter
from functools import reduce
import operator

class Solution:
    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:
        w2 = reduce(operator.or_, map(Counter, words2))
        return [w1 for w1 in words1 if Counter(w1) & w2 == w2]
"
3452,python3,word-subsets,"class Solution:
    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:
        w2 = reduce(operator.and_, map(Counter, words2))
        return [w1 for w1 in words1 if Counter(w1) >= w2]",None,"from collections import Counter
from typing import List
import operator
from functools import reduce

class Solution:
    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:
        w2 = reduce(operator.or_, map(Counter, words2))
        return [w1 for w1 in words1 if not (w2 - Counter(w1))]
"
3452,python3,word-subsets,"class Solution:
    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:
        w2 = reduce(operator.and_, map(Counter, words2))
        return [w1 for w1 in words1 if Counter(w1) >= w2]",None,"class Solution:
    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:
        w2 = reduce(operator.or_, map(Counter, words2))
        return [w1 for w1 in words1 if Counter(w1) & w2 == w2]
"
3453,python3,construct-the-longest-new-string,"class Solution:
    def longestString(self, x: int, y: int, z: int) -> int:

        if x > y: x,y = y,x

        return min(x + y, 2*x + 1 ) * 2 - 2*z;",None,"class Solution:
    def longestString(self, x: int, y: int, z: int) -> int:
        
        if x > y: 
            x,y = y,x

        return min(x + z, y, 2*x + 1) * 2 + min(z,x*2)
"
3453,python3,construct-the-longest-new-string,"class Solution:
    def longestString(self, x: int, y: int, z: int) -> int:

        if x > y: x,y = y,x

        return min(x + y, 2*x + 1 ) * 2 - 2*z;",None,"class Solution:
    def longestString(self, x: int, y: int, z: int) -> int:
        if x > y: x, y = y, x
        if x+z<y: return 2*(x+z)
        return x + y + z
"
3453,python3,construct-the-longest-new-string,"class Solution:
    def longestString(self, x: int, y: int, z: int) -> int:

        if x > y: x,y = y,x

        return min(x + y, 2*x + 1 ) * 2 - 2*z;",None,"class Solution:
    def longestString(self, x: int, y: int, z: int) -> int:

        if x > y: x,y = y,x

        return min(x + y + z, 2*x + 1 ) * 2;
"
3454,python3,substring-with-concatenation-of-all-words,"class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        wlen= len(words[0])
        slen= wlen*len(words)
        track=dict()
        
        occ = collections.Counter(words)

        def test():
            for key, val in track.items():
                if val !=occ[key]:
                    return False
            return True
        res=[]

        for k in range(wlen):
            for i in words:
                track.update({i : 0})
            for i in range(k,slen+k,wlen):
                w=s[i:i+wlen]
                if w in words:
                    track.update({w: track[w]+1})
            if test():
                res.append(k)
            for i in range(wlen+k, len(s)-slen+1,wlen):
                
                nw=s[i+slen-wlen:i+slen]
                pw=s[i-wlen:i]
                if nw in words:
                    track.update({nw: track[nw]+1})
                if pw in words:
                    track.update({pw: track[pw]-1})
                if test():
                    res.append(i-wlen)
        return res",None,"class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]: 
        if not words: return []
        word_len = len(words[0]) 
        num_word = len(words)
        str_len = len(s)
        words_map = collections.Counter(words)
        result = []
        
        for i in range(word_len):
            left = i
            right = i
            cnt = 0
            cur_counter = collections.Counter()

            while right + word_len <= str_len:
                w = s[right: right + word_len]
                right += word_len
                
                if w not in words_map:
                    cur_counter.clear()
                    cnt = 0
                    left = right
                else:
                    cur_counter[w] += 1
                    cnt += 1
                    while cur_counter[w] > words_map[w]:
                        left_word = s[left: left + word_len]
                        left += word_len
                        cur_counter[left_word] -= 1
                        cnt -= 1
                    if cnt == num_word:
                        result.append(left)
        return result
"
3454,python3,substring-with-concatenation-of-all-words,"class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        wlen= len(words[0])
        slen= wlen*len(words)
        track=dict()
        
        occ = collections.Counter(words)

        def test():
            for key, val in track.items():
                if val !=occ[key]:
                    return False
            return True
        res=[]

        for k in range(wlen):
            for i in words:
                track.update({i : 0})
            for i in range(k,slen+k,wlen):
                w=s[i:i+wlen]
                if w in words:
                    track.update({w: track[w]+1})
            if test():
                res.append(k)
            for i in range(wlen+k, len(s)-slen+1,wlen):
                
                nw=s[i+slen-wlen:i+slen]
                pw=s[i-wlen:i]
                if nw in words:
                    track.update({nw: track[nw]+1})
                if pw in words:
                    track.update({pw: track[pw]-1})
                if test():
                    res.append(i-wlen)
        return res",None,"class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        if not s or not words:
            return []
            
        len_word = len(words[0])
        len_words = len_word * len(words)
        track = dict()
        res = []
        
        ocurrences = collections.Counter(words)
        
        def test():
            for key, val in track.items():
                if val != ocurrences[key]:
                    return False
            return True

        for k in range(len_word):
            track = dict.fromkeys(words, 0)
            
            start, end = k, k
            
            while end + len_word <= len(s):
                word = s[end:end + len_word]
                
                if word not in track:
                    start = end = end + len_word
                    track = dict.fromkeys(words, 0)
                else:
                    track[word] += 1
                    end += len_word
                    
                    while track[word] > ocurrences[word]:
                        track[s[start:start + len_word]] -= 1
                        start += len_word
                    
                    if end - start == len_words:
                        res.append(start)
        return res
"
3454,python3,substring-with-concatenation-of-all-words,"class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        wlen= len(words[0])
        slen= wlen*len(words)
        track=dict()
        
        occ = collections.Counter(words)

        def test():
            for key, val in track.items():
                if val !=occ[key]:
                    return False
            return True
        res=[]

        for k in range(wlen):
            for i in words:
                track.update({i : 0})
            for i in range(k,slen+k,wlen):
                w=s[i:i+wlen]
                if w in words:
                    track.update({w: track[w]+1})
            if test():
                res.append(k)
            for i in range(wlen+k, len(s)-slen+1,wlen):
                
                nw=s[i+slen-wlen:i+slen]
                pw=s[i-wlen:i]
                if nw in words:
                    track.update({nw: track[nw]+1})
                if pw in words:
                    track.update({pw: track[pw]-1})
                if test():
                    res.append(i-wlen)
        return res",None,"class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        wlen= len(words[0])
        slen= wlen*len(words)
        track=dict()
        
        occ = collections.Counter(words)

        def test():
            for key, val in track.items():
                if val !=occ[key]:
                    return False
            return True
        res=[]

        for k in range(wlen):
            track.clear()
            for i in words:
                track.update({i : 0})
            for i in range(k,slen+k,wlen):
                w=s[i:i+wlen]
                if w in words:
                    track.update({w: track[w]+1})
            if test():
                res.append(k)
            for i in range(wlen+k, len(s)-slen+1,wlen):
                
                nw=s[i+slen-wlen:i+slen]
                pw=s[i-wlen:i]
                if nw in words:
                    track.update({nw: track[nw]+1})
                if pw in words:
                    track.update({pw: track[pw]-1})
                if test():
                    res.append(i)
        return res
"
3455,python3,reverse-nodes-in-k-group,"class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        
        dummy = ListNode(0, head)
        currGroup = dummy

        while True:
            kth = self.getKth(currGroup, k)
            if not kth:
                break
            nextGroup =  kth.next

            prev, curr = kth.next, currGroup.next
            while curr != nextGroup:
                tmp = curr.next
                curr.next = prev
                prev = curr
                curr = tmp

            currGroup.next, currGroup = kth, currGroup.next

            k += 1 

        return dummy.next


    def getKth(self, node, k):
        while node and k:
            node = node.next
            k -= 1
        return node",None,"class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        
        dummy = ListNode(0, head)
        currGroup = dummy

        while True:
            kth = self.getKth(currGroup, k)
            if not kth:
                break
            nextGroup =  kth.next

            prev, curr = kth.next, currGroup.next
            while curr != nextGroup:
                tmp = curr.next
                curr.next = prev
                prev = curr
                curr = tmp

            next_ = currGroup.next
            currGroup.next = prev
            next_.next = curr
            currGroup = next_
        return dummy.next

    def getKth(self, node, k):
        while node and k:
            node = node.next
            k -= 1
        return node if k == 0 else None
"
3455,python3,reverse-nodes-in-k-group,"class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        
        dummy = ListNode(0, head)
        currGroup = dummy

        while True:
            kth = self.getKth(currGroup, k)
            if not kth:
                break
            nextGroup =  kth.next

            prev, curr = kth.next, currGroup.next
            while curr != nextGroup:
                tmp = curr.next
                curr.next = prev
                prev = curr
                curr = tmp

            currGroup.next, currGroup = kth, currGroup.next

            k += 1 

        return dummy.next


    def getKth(self, node, k):
        while node and k:
            node = node.next
            k -= 1
        return node",None,"class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        
        dummy = ListNode(0, head)
        groupStart = dummy

        while True:
            kth = self.getKth(groupStart, k)
            if not kth:
                break
            nextGroup =  kth.next

            prev, curr = kth.next, groupStart.next
            while curr != nextGroup:
                tmp = curr.next
                curr.next = prev
                prev = curr
                curr = tmp

            tmp = groupStart.next
            groupStart.next = kth
            groupStart = tmp

        return dummy.next

    def getKth(self, node, k):
        while node and k:
            node = node.next
            k -= 1
        return node
"
3455,python3,reverse-nodes-in-k-group,"class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        
        dummy = ListNode(0, head)
        currGroup = dummy

        while True:
            kth = self.getKth(currGroup, k)
            if not kth:
                break
            nextGroup =  kth.next

            prev, curr = kth.next, currGroup.next
            while curr != nextGroup:
                tmp = curr.next
                curr.next = prev
                prev = curr
                curr = tmp

            currGroup.next, currGroup = kth, currGroup.next

            k += 1 

        return dummy.next


    def getKth(self, node, k):
        while node and k:
            node = node.next
            k -= 1
        return node",None,"class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        
        dummy = ListNode(0, head)
        groupStart = dummy

        while True:
            kth = self.getKth(groupStart, k)
            if not kth:
                break
            nextGroup = kth.next

            prev, curr = nextGroup, groupStart.next
            while curr != nextGroup:
                tmp = curr.next
                curr.next = prev
                prev = curr
                curr = tmp
            
            tmp = groupStart.next
            groupStart.next = kth
            groupStart = tmp
                
        return dummy.next

    def getKth(self, node, k):
        while node and k:
            node = node.next
            k -= 1
        return node
"
3456,python3,card-flipping-game,"class Solution:
    def flipgame(self, fronts: List[int], backs: List[int]) -> int:
        bad = set(i for i,j in zip(fronts, backs) if i==j)
        for i in sorted(set(fronts - backs)):
            if i in bad:
                continue
            return i
        return 0",None,"class Solution:
    def flipgame(self, fronts: list[int], backs: list[int]) -> int:
        bad = set(i for i,j in zip(fronts, backs) if i==j)
        for i in sorted(set(fronts + backs)):
            if i not in bad:
                return i
        return 0
"
3456,python3,card-flipping-game,"class Solution:
    def flipgame(self, fronts: List[int], backs: List[int]) -> int:
        bad = set(i for i,j in zip(fronts, backs) if i==j)
        for i in sorted(set(fronts - backs)):
            if i in bad:
                continue
            return i
        return 0",None,"class Solution:
    def flipgame(self, fronts: List[int], backs: List[int]) -> int:
        bad = set(i for i,j in zip(fronts, backs) if i==j)
        candidates = set(fronts + backs)
        for i in sorted(candidates):
            if i in bad:
                continue
            return i
        return 0
"
3456,python3,card-flipping-game,"class Solution:
    def flipgame(self, fronts: List[int], backs: List[int]) -> int:
        bad = set(i for i,j in zip(fronts, backs) if i==j)
        for i in sorted(set(fronts - backs)):
            if i in bad:
                continue
            return i
        return 0",None,"class Solution:
    def flipgame(self, fronts: List[int], backs: List[int]) -> int:
        bad = set(i for i,j in zip(fronts, backs) if i==j)
        all_numbers = set(fronts + backs)
        for i in sorted(all_numbers):
            if i not in bad:
                return i
        return 0
"
3457,python3,unique-number-of-occurrences,"from collections import Counter
class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        d=Counter(arr)
        l=list(d.keys()) 
        print(l)
        if len(l)==len(set(l)):
            return True
        else:
            return False",None,"from collections import Counter
class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        d=Counter(arr)
        l=list(d.values()) 
        if len(l)==len(set(l)):
            return True
        else:
            return False
"
3457,python3,unique-number-of-occurrences,"from collections import Counter
class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        d=Counter(arr)
        l=list(d.keys()) 
        print(l)
        if len(l)==len(set(l)):
            return True
        else:
            return False",None,"from collections import Counter
class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        d = Counter(arr)
        l = list(d.values())
        if len(l) == len(set(l)):
            return True
        else:
            return False
"
3457,python3,unique-number-of-occurrences,"from collections import Counter
class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        d=Counter(arr)
        l=list(d.keys()) 
        print(l)
        if len(l)==len(set(l)):
            return True
        else:
            return False",None,"from collections import Counter
class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        d = Counter(arr)
        l = list(d.values()) 
        return len(l) == len(set(l))
"
3458,python3,check-if-string-is-transformable-with-substring-sort-operations,"class BIT():
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (n + 1)

    def sum(self, i):
        ans = 0
        i += 1
        while i > 0:
            ans += self.tree[i]
            i -= (i & (-i))
        return ans

    def update(self, i, value):
        i += 1
        while i <= self.n:
            self.tree[i] += value
            i -= (i & (-i))  


class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        if Counter(s)!=Counter(t):
            return False
        ind = defaultdict(deque)
        for id, i in enumerate(t):
            ind[i].append(id)
        a = []
        for i in s:
            a.append(ind[i].popleft())
        n=len(a)
        bt=BIT(n+1)
        ind=defaultdict(lambda :-1)
        for i in range(n):
            inv=bt.sum(n)-bt.sum(a[i])
            bt.update(a[i],1)
            for dig in range(int(s[i])-1,-1,-1):
                if ind[dig]>=i-inv:
                    return False
            ind[int(s[i])]=i-inv
        return True",None,"class BIT():
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (n + 1)

    def sum(self, i):
        ans = 0
        i += 1
        while i > 0:
            ans += self.tree[i]
            i -= i & -i
        return ans

    def update(self, i, value):
        i += 1
        while i <= self.n:
            self.tree[i] += value
            i += i & -i  


class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        if Counter(s) != Counter(t):
            return False
        ind = defaultdict(deque)
        for id, i in enumerate(t[::-1]):  
            ind[int(i)].append(id)
        a = []
        for i in s:
            a.append(ind[int(i)].popleft())
        n = len(a)
        bt = BIT(n + 1)
        ind = defaultdict(lambda: -1)
        for i in range(n):
            inv = bt.sum(n) - bt.sum(a[i])
            bt.update(a[i], 1)
            for dig in range(int(s[i])-1, -1, -1):
                if ind[dig] >= i - inv:
                    return False
            ind[int(s[i])] = i - inv
        return True
"
3458,python3,check-if-string-is-transformable-with-substring-sort-operations,"class BIT():
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (n + 1)

    def sum(self, i):
        ans = 0
        i += 1
        while i > 0:
            ans += self.tree[i]
            i -= (i & (-i))
        return ans

    def update(self, i, value):
        i += 1
        while i <= self.n:
            self.tree[i] += value
            i -= (i & (-i))  


class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        if Counter(s)!=Counter(t):
            return False
        ind = defaultdict(deque)
        for id, i in enumerate(t):
            ind[i].append(id)
        a = []
        for i in s:
            a.append(ind[i].popleft())
        n=len(a)
        bt=BIT(n+1)
        ind=defaultdict(lambda :-1)
        for i in range(n):
            inv=bt.sum(n)-bt.sum(a[i])
            bt.update(a[i],1)
            for dig in range(int(s[i])-1,-1,-1):
                if ind[dig]>=i-inv:
                    return False
            ind[int(s[i])]=i-inv
        return True",None,"class BIT():
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (n + 1)

    def sum(self, i):
        ans = 0
        i += 1
        while i > 0:
            ans += self.tree[i]
            i -= (i & (-i))
        return ans

    def update(self, i, value):
        i += 1
        while i <= self.n:
            self.tree[i] += value
            i += (i & (-i))


class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        if Counter(s) != Counter(t):
            return False
        ind = defaultdict(deque)
        for id, i in enumerate(t):
            ind[i].append(id)
        a = []
        for i in s:
            a.append(ind[i].popleft())
        n = len(a)
        bt = BIT(n + 1)
        ind = defaultdict(lambda: -1)
        for i in range(n):
            inv = bt.sum(n) - bt.sum(a[i])
            bt.update(a[i], 1)
            for dig in range(int(s[i]) - 1, -1, -1):
                if ind[str(dig)] >= i - inv:
                    return False
            ind[s[i]] = i - inv
        return True
"
3458,python3,check-if-string-is-transformable-with-substring-sort-operations,"class BIT():
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (n + 1)

    def sum(self, i):
        ans = 0
        i += 1
        while i > 0:
            ans += self.tree[i]
            i -= (i & (-i))
        return ans

    def update(self, i, value):
        i += 1
        while i <= self.n:
            self.tree[i] += value
            i -= (i & (-i))  


class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        if Counter(s)!=Counter(t):
            return False
        ind = defaultdict(deque)
        for id, i in enumerate(t):
            ind[i].append(id)
        a = []
        for i in s:
            a.append(ind[i].popleft())
        n=len(a)
        bt=BIT(n+1)
        ind=defaultdict(lambda :-1)
        for i in range(n):
            inv=bt.sum(n)-bt.sum(a[i])
            bt.update(a[i],1)
            for dig in range(int(s[i])-1,-1,-1):
                if ind[dig]>=i-inv:
                    return False
            ind[int(s[i])]=i-inv
        return True",None,"class BIT():
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (n + 1)

    def sum(self, i):
        ans = 0
        i += 1
        while i > 0:
            ans += self.tree[i]
            i -= (i & (-i))
        return ans

    def update(self, i, value):
        i += 1
        while i <= self.n:
            self.tree[i] += value
            i += (i & (-i))

class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        from collections import Counter, defaultdict
        if Counter(s)!=Counter(t):
            return False
        ind = defaultdict(deque)
        for id, i in enumerate(s):
            ind[int(i)].append(id)
        bit = BIT(len(s))
        for i in t:
            if not ind[int(i)]:
                return False
            idx = ind[int(i)].popleft()
            if bit.sum(idx):
                return False
            bit.update(idx, 1)
        return True
"
3459,python3,number-of-ways-of-cutting-a-pizza,"class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        self.r = len(pizza)
        self.c = len(pizza[0])
        
        tot_apples = 0
        self.pfsum_row = []
        self.pfsum_col = []
        
        for i in range(self.r):
            pfr = 0
            pfs_r = [0] * self.c
            pfs_c = [0] * self.c
            for j in range(self.c):
                if i > 0:
                    pfs_c[j] += self.pfsum_col[i - 1][j]
                if pizza[i][j] == 'A':
                    pfr += 1
                    pfs_c[j] += 1
                    tot_apples -= 1
                pfs_r[j] = pfr
            self.pfsum_row.append(pfs_r)
            self.pfsum_col.append(pfs_c)
        
        if tot_apples < k:
            return 0
        
        if k == 1:
            return 1
        
        return self.getWays(0, 0, k) % (1000000007)
    
    
    @cache
    def getWays(self, i, j, k):
        if k == 1:
            found = False
            for c in range(j, self.c):
                apple_in_region = self.pfsum_col[self.r - 1][c]
                if i > 0:
                     apple_in_region -= self.pfsum_col[i - 1][c]
                if apple_in_region:
                    found = True
                    break
            if found:
                return 1
            return 0
        else:
            cannot_cut = True
            nr = i
            t_cnt = 0
            while nr < self.r - 1:
                while nr < self.r - 1 and cannot_cut:
                    apple_in_region = self.pfsum_row[nr][self.c - 1]
                    if j > 0:
                        apple_in_region -= self.pfsum_row[nr][j - 1]
                    if apple_in_region:
                        cannot_cut = False
                    else:
                        nr += 1
                        
                if nr < self.r - 1:
                    t_cnt += self.getWays(nr + 1, j, k - 1)
                nr += 1
                
            cannot_cut = True
            nc = j
            while nc < self.c - 1:
                while nc < self. c - 1 and cannot_cut:
                    apple_in_region = self.pfsum_col[self.r - 1][nc]
                    if i > 0:
                        apple_in_region -= self.pfsum_col[i - 1][nc]
                    if apple_in_region:
                        cannot_cut = False
                    else:
                        nc += 1
                
                if nc < self.c - 1:
                    t_cnt += self.getWays(i, nc + 1, k - 1)
                nc += 1
            
            return t_cnt",None,"class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        self.r = len(pizza)
        self.c = len(pizza[0])
        
        tot_apples = 0
        self.pfsum_row = []
        self.pfsum_col = []
        
        for i in range(self.r):
            pfr = 0
            pfs_r = [0] * self.c
            pfs_c = [0] * self.c
            for j in range(self.c):
                if i > 0:
                    pfs_c[j] += self.pfsum_col[i - 1][j]
                if pizza[i][j] == 'A':
                    pfr += 1
                    pfs_c[j] += 1
                    tot_apples += 1
                pfs_r[j] = pfr
            self.pfsum_row.append(pfs_r)
            self.pfsum_col.append(pfs_c)
        
        if tot_apples < k:
            return 0
        
        if k == 1:
            return 1
        
        return self.getWays(0, 0, k) % (1000000007)
    
    
    @cache
    def getWays(self, i, j, k):
        if k == 1:
            found = False
            for c in range(j, self.c):
                apple_in_region = self.pfsum_col[self.r - 1][c]
                if i > 0:
                     apple_in_region -= self.pfsum_col[i - 1][c]
                if apple_in_region:
                    found = True
                    break
            if found:
                return 1
            return 0
        else:
            cannot_cut = True
            nr = i
            t_cnt = 0
            while nr < self.r - 1:
                while nr < self.r - 1 and cannot_cut:
                    apple_in_region = self.pfsum_row[nr][self.c - 1]
                    if j > 0:
                        apple_in_region -= self.pfsum_row[nr][j - 1]
                    if apple_in_region:
                        cannot_cut = False
                    else:
                        nr += 1
                        
                if nr < self.r - 1:
                    t_cnt += self.getWays(nr + 1, j, k - 1)
                nr += 1
                
            cannot_cut = True
            nc = j
            while nc < self.c - 1:
                while nc < self. c - 1 and cannot_cut:
                    apple_in_region = self.pfsum_col[self.r - 1][nc]
                    if i > 0:
                        apple_in_region -= self.pfsum_col[i - 1][nc]
                    if apple_in_region:
                        cannot_cut = False
                    else:
                        nc += 1
                
                if nc < self.c - 1:
                    t_cnt += self.getWays(i, nc + 1, k - 1)
                nc += 1
            
            return t_cnt
"
3459,python3,number-of-ways-of-cutting-a-pizza,"class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        self.r = len(pizza)
        self.c = len(pizza[0])
        
        tot_apples = 0
        self.pfsum_row = []
        self.pfsum_col = []
        
        for i in range(self.r):
            pfr = 0
            pfs_r = [0] * self.c
            pfs_c = [0] * self.c
            for j in range(self.c):
                if i > 0:
                    pfs_c[j] += self.pfsum_col[i - 1][j]
                if pizza[i][j] == 'A':
                    pfr += 1
                    pfs_c[j] += 1
                    tot_apples -= 1
                pfs_r[j] = pfr
            self.pfsum_row.append(pfs_r)
            self.pfsum_col.append(pfs_c)
        
        if tot_apples < k:
            return 0
        
        if k == 1:
            return 1
        
        return self.getWays(0, 0, k) % (1000000007)
    
    
    @cache
    def getWays(self, i, j, k):
        if k == 1:
            found = False
            for c in range(j, self.c):
                apple_in_region = self.pfsum_col[self.r - 1][c]
                if i > 0:
                     apple_in_region -= self.pfsum_col[i - 1][c]
                if apple_in_region:
                    found = True
                    break
            if found:
                return 1
            return 0
        else:
            cannot_cut = True
            nr = i
            t_cnt = 0
            while nr < self.r - 1:
                while nr < self.r - 1 and cannot_cut:
                    apple_in_region = self.pfsum_row[nr][self.c - 1]
                    if j > 0:
                        apple_in_region -= self.pfsum_row[nr][j - 1]
                    if apple_in_region:
                        cannot_cut = False
                    else:
                        nr += 1
                        
                if nr < self.r - 1:
                    t_cnt += self.getWays(nr + 1, j, k - 1)
                nr += 1
                
            cannot_cut = True
            nc = j
            while nc < self.c - 1:
                while nc < self. c - 1 and cannot_cut:
                    apple_in_region = self.pfsum_col[self.r - 1][nc]
                    if i > 0:
                        apple_in_region -= self.pfsum_col[i - 1][nc]
                    if apple_in_region:
                        cannot_cut = False
                    else:
                        nc += 1
                
                if nc < self.c - 1:
                    t_cnt += self.getWays(i, nc + 1, k - 1)
                nc += 1
            
            return t_cnt",None,"class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        self.r = len(pizza)
        self.c = len(pizza[0])
        
        tot_apples = 0
        self.pfsum_row = []
        self.pfsum_col = []
        
        for i in range(self.r):
            pfr = 0
            pfs_r = [0] * self.c
            pfs_c = [0] * self.c
            for j in range(self.c):
                if i > 0:
                    pfs_c[j] += self.pfsum_col[i - 1][j]
                if pizza[i][j] == 'A':
                    pfr += 1
                    pfs_c[j] += 1
                    tot_apples += 1
                pfs_r[j] = pfr
            self.pfsum_row.append(pfs_r)
            self.pfsum_col.append(pfs_c)
        
        if tot_apples < k:
            return 0
        
        if k == 1:
            return 1
        
        return self.getWays(0, 0, k) % (1000000007)
    
    
    @functools.lru_cache(None)
    def getWays(self, i, j, k):
        if k == 1:
            found = False
            for c in range(j, self.c):
                apple_in_region = self.pfsum_col[self.r - 1][c]
                if i > 0:
                     apple_in_region -= self.pfsum_col[i - 1][c]
                if apple_in_region:
                    found = True
                    break
            if found:
                return 1
            return 0
        else:
            cannot_cut = True
            nr = i
            t_cnt = 0
            while nr < self.r - 1:
                while nr < self.r - 1 and cannot_cut:
                    apple_in_region = self.pfsum_row[nr][self.c - 1]
                    if j > 0:
                        apple_in_region -= self.pfsum_row[nr][j - 1]
                    if apple_in_region:
                        cannot_cut = False
                    else:
                        nr += 1
                        
                if nr < self.r - 1:
                    t_cnt += self.getWays(nr + 1, j, k - 1)
                nr += 1
                
            cannot_cut = True
            nc = j
            while nc < self.c - 1:
                while nc < self. c - 1 and cannot_cut:
                    apple_in_region = self.pfsum_col[self.r - 1][nc]
                    if i > 0:
                        apple_in_region -= self.pfsum_col[i - 1][nc]
                    if apple_in_region:
                        cannot_cut = False
                    else:
                        nc += 1
                
                if nc < self.c - 1:
                    t_cnt += self.getWays(i, nc + 1, k - 1)
                nc += 1
            
            return t_cnt
"
3459,python3,number-of-ways-of-cutting-a-pizza,"class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        self.r = len(pizza)
        self.c = len(pizza[0])
        
        tot_apples = 0
        self.pfsum_row = []
        self.pfsum_col = []
        
        for i in range(self.r):
            pfr = 0
            pfs_r = [0] * self.c
            pfs_c = [0] * self.c
            for j in range(self.c):
                if i > 0:
                    pfs_c[j] += self.pfsum_col[i - 1][j]
                if pizza[i][j] == 'A':
                    pfr += 1
                    pfs_c[j] += 1
                    tot_apples -= 1
                pfs_r[j] = pfr
            self.pfsum_row.append(pfs_r)
            self.pfsum_col.append(pfs_c)
        
        if tot_apples < k:
            return 0
        
        if k == 1:
            return 1
        
        return self.getWays(0, 0, k) % (1000000007)
    
    
    @cache
    def getWays(self, i, j, k):
        if k == 1:
            found = False
            for c in range(j, self.c):
                apple_in_region = self.pfsum_col[self.r - 1][c]
                if i > 0:
                     apple_in_region -= self.pfsum_col[i - 1][c]
                if apple_in_region:
                    found = True
                    break
            if found:
                return 1
            return 0
        else:
            cannot_cut = True
            nr = i
            t_cnt = 0
            while nr < self.r - 1:
                while nr < self.r - 1 and cannot_cut:
                    apple_in_region = self.pfsum_row[nr][self.c - 1]
                    if j > 0:
                        apple_in_region -= self.pfsum_row[nr][j - 1]
                    if apple_in_region:
                        cannot_cut = False
                    else:
                        nr += 1
                        
                if nr < self.r - 1:
                    t_cnt += self.getWays(nr + 1, j, k - 1)
                nr += 1
                
            cannot_cut = True
            nc = j
            while nc < self.c - 1:
                while nc < self. c - 1 and cannot_cut:
                    apple_in_region = self.pfsum_col[self.r - 1][nc]
                    if i > 0:
                        apple_in_region -= self.pfsum_col[i - 1][nc]
                    if apple_in_region:
                        cannot_cut = False
                    else:
                        nc += 1
                
                if nc < self.c - 1:
                    t_cnt += self.getWays(i, nc + 1, k - 1)
                nc += 1
            
            return t_cnt",None,"class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        self.r = len(pizza)
        self.c = len(pizza[0])
        
        tot_apples = 0
        self.pfsum_row = []
        self.pfsum_col = []
        
        for i in range(self.r):
            pfr = 0
            pfs_r = [0] * self.c
            pfs_c = [0] * self.c
            for j in range(self.c):
                if i > 0:
                    pfs_c[j] += self.pfsum_col[i - 1][j]
                if pizza[i][j] == 'A':
                    pfr += 1
                    pfs_c[j] += 1
                    tot_apples += 1
                pfs_r[j] = pfr
            self.pfsum_row.append(pfs_r)
            self.pfsum_col.append(pfs_c)
        
        if tot_apples < k:
            return 0
        
        if k == 1:
            return 1
        
        return self.getWays(0, 0, k) % (1000000007)
    
    
    @cache
    def getWays(self, i, j, k):
        if k == 1:
            found = False
            for c in range(j, self.c):
                apple_in_region = self.pfsum_col[self.r - 1][c]
                if i > 0:
                     apple_in_region -= self.pfsum_col[i - 1][c]
                if apple_in_region:
                    found = True
                    break
            if found:
                return 1
            return 0
        else:
            cannot_cut = True
            nr = i
            t_cnt = 0
            while nr < self.r - 1:
                while nr < self.r - 1 and cannot_cut:
                    apple_in_region = self.pfsum_row[nr][self.c - 1]
                    if j > 0:
                        apple_in_region -= self.pfsum_row[nr][j - 1]
                    if apple_in_region:
                        cannot_cut = False
                    else:
                        nr += 1
                        
                if nr < self.r - 1:
                    t_cnt += self.getWays(nr + 1, j, k - 1)
                nr += 1
                
            cannot_cut = True
            nc = j
            while nc < self.c - 1:
                while nc < self. c - 1 and cannot_cut:
                    apple_in_region = self.pfsum_col[self.r - 1][nc]
                    if i > 0:
                        apple_in_region -= self.pfsum_col[i - 1][nc]
                    if apple_in_region:
                        cannot_cut = False
                    else:
                        nc += 1
                
                if nc < self.c - 1:
                    t_cnt += self.getWays(i, nc + 1, k - 1)
                nc += 1
            
            return t_cnt
"
3460,python3,alternating-digit-sum,"class Solution:
    def alternateDigitSum(self, n: int) -> int:
        result=str(n)
        sum=0
        for i in range(len(result)):
            if i%2 ==0:
                sum=sum+int(result[i])
            else:
                sum=sum+int(result[i])  
        return sum",None,"class Solution:
    def alternateDigitSum(self, n: int) -> int:
        result=str(n)
        sum=0
        for i in range(len(result)):
            if i%2 ==0:
                sum=sum+int(result[i])
            else:
                sum=sum-int(result[i])  
        return sum
"
3460,python3,alternating-digit-sum,"class Solution:
    def alternateDigitSum(self, n: int) -> int:
        result=str(n)
        sum=0
        for i in range(len(result)):
            if i%2 ==0:
                sum=sum+int(result[i])
            else:
                sum=sum+int(result[i])  
        return sum",None,"class Solution:
    def alternateDigitSum(self, n: int) -> int:
        result=str(n)
        sum=0
        for i in range(len(result)):
            if i%2 ==0:
                sum=sum+int(result[i])
            else:
                sum=sum-int(result[i])  
        return sum
"
3460,python3,alternating-digit-sum,"class Solution:
    def alternateDigitSum(self, n: int) -> int:
        result=str(n)
        sum=0
        for i in range(len(result)):
            if i%2 ==0:
                sum=sum+int(result[i])
            else:
                sum=sum+int(result[i])  
        return sum",None,"class Solution:
    def alternateDigitSum(self, n: int) -> int:
        result=str(n)
        sum=0
        for i in range(len(result)):
            if i%2 ==0:
                sum=sum+int(result[i])
            else:
                sum=sum-int(result[i])  
        return sum
"
3461,python3,self-dividing-numbers,"class Solution:
    def selfDividingNumbers(self, left: int, right: int) -> List[int]:
        res=[]
        for i in range(left,right+1 ):
            ch=True
            for j in str(i):
                if j!='0':
                    if i%int(j)!=0:
                        ch=False
                else:
                    ch=False
                    break   
            if ch:
                res.append(i)
        return res[-1]",None,"class Solution:
    def selfDividingNumbers(self, left: int, right: int) -> List[int]:
        res=[]
        for i in range(left,right+1 ):
            ch=True
            for j in str(i):
                if j!='0':
                    if i%int(j)!=0:
                        ch=False
                else:
                    ch=False
                    break   
            if ch:
                res.append(i)
        return res
"
3461,python3,self-dividing-numbers,"class Solution:
    def selfDividingNumbers(self, left: int, right: int) -> List[int]:
        res=[]
        for i in range(left,right+1 ):
            ch=True
            for j in str(i):
                if j!='0':
                    if i%int(j)!=0:
                        ch=False
                else:
                    ch=False
                    break   
            if ch:
                res.append(i)
        return res[-1]",None,"class Solution:
    def selfDividingNumbers(self, left: int, right: int) -> List[int]:
        res = []
        for i in range(left, right+1):
            ch = True
            for j in str(i):
                if j != '0':
                    if i % int(j) != 0:
                        ch = False
                        break
                else:
                    ch = False
                    break
            if ch:
                res.append(i)
        return res
"
3461,python3,self-dividing-numbers,"class Solution:
    def selfDividingNumbers(self, left: int, right: int) -> List[int]:
        res=[]
        for i in range(left,right+1 ):
            ch=True
            for j in str(i):
                if j!='0':
                    if i%int(j)!=0:
                        ch=False
                else:
                    ch=False
                    break   
            if ch:
                res.append(i)
        return res[-1]",None,"class Solution:
    def selfDividingNumbers(self, left: int, right: int) -> List[int]:
        res=[]
        for i in range(left,right+1 ):
            ch=True
            for j in str(i):
                if j=='0' or i%int(j)!=0:
                    ch=False
                    break   
            if ch:
                res.append(i)
        return res
"
3462,python3,fibonacci-number,"class Solution:
    def fib(self, n: int) -> int:
        def fib(n):
            if Fib[n] != -1:
                return Fib[n]
            Fib[n] = fib(n-1) + fib(n-1)
            return Fib[n]
        if n == 0:
            return 0
        if n == 1:
            return 1
        Fib = [-1 for _ in range(n+1)]
        Fib[0] = 0
        Fib[1] = 1
        return fib(n)",None,"class Solution:
    def fib(self, n: int) -> int:
        def fib(n):
            if Fib[n] != -1:
                return Fib[n]
            Fib[n] = fib(n-1) + fib(n-2)
            return Fib[n]
        if n == 0:
            return 0
        if n == 1:
            return 1
        Fib = [-1 for _ in range(n+1)]
        Fib[0] = 0
        Fib[1] = 1
        return fib(n)
"
3462,python3,fibonacci-number,"class Solution:
    def fib(self, n: int) -> int:
        def fib(n):
            if Fib[n] != -1:
                return Fib[n]
            Fib[n] = fib(n-1) + fib(n-1)
            return Fib[n]
        if n == 0:
            return 0
        if n == 1:
            return 1
        Fib = [-1 for _ in range(n+1)]
        Fib[0] = 0
        Fib[1] = 1
        return fib(n)",None,"class Solution:
    def fib(self, n: int) -> int:
        def fib(n):
            if Fib[n] != -1:
                return Fib[n]
            Fib[n] = fib(n-1) + fib(n-2)
            return Fib[n]
        if n == 0:
            return 0
        if n == 1:
            return 1
        Fib = [-1 for _ in range(n+1)]
        Fib[0] = 0
        Fib[1] = 1
        return fib(n)
"
3462,python3,fibonacci-number,"class Solution:
    def fib(self, n: int) -> int:
        def fib(n):
            if Fib[n] != -1:
                return Fib[n]
            Fib[n] = fib(n-1) + fib(n-1)
            return Fib[n]
        if n == 0:
            return 0
        if n == 1:
            return 1
        Fib = [-1 for _ in range(n+1)]
        Fib[0] = 0
        Fib[1] = 1
        return fib(n)",None,"class Solution:
    def fib(self, n: int) -> int:
        def fib(n):
            if Fib[n] != -1:
                return Fib[n]
            Fib[n] = fib(n-1) + fib(n-2)
            return Fib[n]
        if n == 0:
            return 0
        if n == 1:
            return 1
        Fib = [-1 for _ in range(n+1)]
        Fib[0] = 0
        Fib[1] = 1
        return fib(n)
"
3463,python3,count-number-of-maximum-bitwise-or-subsets,"import functools
class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        mapping = collections.defaultdict(int)
        for count in range(1,len(nums)+1):
            subsets = list(itertools.combinations(nums,count))
            for ele in subsets:
                mapping[functools.reduce(lambda a,b: a^b,list(ele))] += 1
        return mapping[max(mapping.keys())]",None,"import functools
class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        mapping = collections.defaultdict(int)
        for count in range(1,len(nums)+1):
            subsets = list(itertools.combinations(nums,count))
            for ele in subsets:
                mapping[functools.reduce(lambda a,b: a|b,list(ele))] += 1
        return mapping[max(mapping.keys())]
"
3463,python3,count-number-of-maximum-bitwise-or-subsets,"import functools
class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        mapping = collections.defaultdict(int)
        for count in range(1,len(nums)+1):
            subsets = list(itertools.combinations(nums,count))
            for ele in subsets:
                mapping[functools.reduce(lambda a,b: a^b,list(ele))] += 1
        return mapping[max(mapping.keys())]",None,"import functools
import collections
import itertools
from typing import List

class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        mapping = collections.defaultdict(int)
        for count in range(1,len(nums)+1):
            subsets = list(itertools.combinations(nums,count))
            for ele in subsets:
                mapping[functools.reduce(lambda a,b: a|b,list(ele))] += 1
        return mapping[max(mapping.keys())]
"
3463,python3,count-number-of-maximum-bitwise-or-subsets,"import functools
class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        mapping = collections.defaultdict(int)
        for count in range(1,len(nums)+1):
            subsets = list(itertools.combinations(nums,count))
            for ele in subsets:
                mapping[functools.reduce(lambda a,b: a^b,list(ele))] += 1
        return mapping[max(mapping.keys())]",None,"import functools
class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        mapping = collections.defaultdict(int)
        for count in range(1,len(nums)+1):
            subsets = list(itertools.combinations(nums,count))
            for ele in subsets:
                mapping[functools.reduce(lambda a,b: a|b,list(ele))] += 1
        return mapping[max(mapping.keys())]
"
3464,python3,distribute-candies,"class Solution:
    def distributeCandies(self, candyType: List[int]) -> int:
        return max(len(candyType)//2, len(set(candyType)))",None,"class Solution:
    def distributeCandies(self, candyType: List[int]) -> int:
        return min(len(candyType)//2, len(set(candyType)))
"
3464,python3,distribute-candies,"class Solution:
    def distributeCandies(self, candyType: List[int]) -> int:
        return max(len(candyType)//2, len(set(candyType)))",None,"class Solution:
    def distributeCandies(self, candyType: List[int]) -> int:
        return min(len(candyType)//2, len(set(candyType)))
"
3464,python3,distribute-candies,"class Solution:
    def distributeCandies(self, candyType: List[int]) -> int:
        return max(len(candyType)//2, len(set(candyType)))",None,"class Solution:
    def distributeCandies(self, candyType: List[int]) -> int:
        return min(len(candyType)//2, len(set(candyType)))
"
