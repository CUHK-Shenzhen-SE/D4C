ID,lang,slug,bug,diff,fix
37,cpp,prime-arrangements,"class Solution {
public:
    long long fact(int n)
    {
        if(n<=1)return 1;
        return (n*fact(n+1)%1000000007)%1000000007; 
    }
    int numPrimeArrangements(int n) {
        if(n==1)return 1;
        if(n<=3)return n-1;
        int t=0,flag;
        for(int i=2;i<=n;i++)
        {
            flag=0;
            for(int j=2;j<=sqrt(i);j++)
            {
                if(i%j==0)
                {
                    flag=1;
                    break;
                }
            }
            if(flag==0)
            {
                t++;
            }
        }
        return (fact(t)*fact(n-t))%1000000007;

    }
};",None,"class Solution {
public:
    long long fact(int n)
    {
        if(n<=1)return 1;
        return (n*fact(n-1))%1000000007; 
    }
    int numPrimeArrangements(int n) {
        if(n==1)return 1;
        if(n<=3)return n-1;
        int t=0,flag;
        for(int i=2;i<=n;i++)
        {
            flag=0;
            for(int j=2;j<=sqrt(i);j++)
            {
                if(i%j==0)
                {
                    flag=1;
                    break;
                }
            }
            if(flag==0)
            {
                t++;
            }
        }
        return (fact(t)*fact(n-t))%1000000007;

    }
};
"
37,cpp,prime-arrangements,"class Solution {
public:
    long long fact(int n)
    {
        if(n<=1)return 1;
        return (n*fact(n+1)%1000000007)%1000000007; 
    }
    int numPrimeArrangements(int n) {
        if(n==1)return 1;
        if(n<=3)return n-1;
        int t=0,flag;
        for(int i=2;i<=n;i++)
        {
            flag=0;
            for(int j=2;j<=sqrt(i);j++)
            {
                if(i%j==0)
                {
                    flag=1;
                    break;
                }
            }
            if(flag==0)
            {
                t++;
            }
        }
        return (fact(t)*fact(n-t))%1000000007;

    }
};",None,"class Solution {
public:
    long long fact(int n)
    {
        if(n<=1)return 1;
        return (n*fact(n-1))%1000000007; 
    }
    int numPrimeArrangements(int n) {
        if(n==1)return 1;
        if(n<=3)return n-1;
        int t=0,flag;
        for(int i=2;i<=n;i++)
        {
            flag=0;
            for(int j=2;j<=sqrt(i);j++)
            {
                if(i%j==0)
                {
                    flag=1;
                    break;
                }
            }
            if(flag==0)
            {
                t++;
            }
        }
        return (fact(t)*fact(n-t))%1000000007;

    }
};
"
37,cpp,prime-arrangements,"class Solution {
public:
    long long fact(int n)
    {
        if(n<=1)return 1;
        return (n*fact(n+1)%1000000007)%1000000007; 
    }
    int numPrimeArrangements(int n) {
        if(n==1)return 1;
        if(n<=3)return n-1;
        int t=0,flag;
        for(int i=2;i<=n;i++)
        {
            flag=0;
            for(int j=2;j<=sqrt(i);j++)
            {
                if(i%j==0)
                {
                    flag=1;
                    break;
                }
            }
            if(flag==0)
            {
                t++;
            }
        }
        return (fact(t)*fact(n-t))%1000000007;

    }
};",None,"class Solution {
public:
    long long fact(int n)
    {
        if(n<=1)return 1;
        return (n*fact(n-1))%1000000007; 
    }
    int numPrimeArrangements(int n) {
        if(n==1)return 1;
        if(n<=3)return n-1;
        int t=0,flag;
        for(int i=2;i<=n;i++)
        {
            flag=0;
            for(int j=2;j<=sqrt(i);j++)
            {
                if(i%j==0)
                {
                    flag=1;
                    break;
                }
            }
            if(flag==0)
            {
                t++;
            }
        }
        return (fact(t)*fact(n-t))%1000000007;

    }
};
"
38,cpp,merge-two-binary-trees,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if ( t1 && t2 ) {
            TreeNode * root = new TreeNode(t1->val + t2->val);
            root->left = mergeTrees(t1->left, t2->right);
            root->right = mergeTrees(t1->right, t2->left);
            return root;
        } else {
            return t1 ? t1 : t2;
        }
    }
};",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if (t1 == nullptr) {
            return t2;
        }
        if (t2 == nullptr) {
            return t1;
        }

        TreeNode* root = new TreeNode(t1->val + t2->val);
        root->left = mergeTrees(t1->left, t2->left);
        root->right = mergeTrees(t1->right, t2->right);
        return root;
    }
};
"
38,cpp,merge-two-binary-trees,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if ( t1 && t2 ) {
            TreeNode * root = new TreeNode(t1->val + t2->val);
            root->left = mergeTrees(t1->left, t2->right);
            root->right = mergeTrees(t1->right, t2->left);
            return root;
        } else {
            return t1 ? t1 : t2;
        }
    }
};",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if ( t1 == nullptr ) {
            return t2;
        }
        if ( t2 == nullptr ) {
            return t1;
        }
        TreeNode * root = new TreeNode(t1->val + t2->val);
        root->left = mergeTrees(t1->left, t2->left);
        root->right = mergeTrees(t1->right, t2->right);
        return root;
    }
};
"
38,cpp,merge-two-binary-trees,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if ( t1 && t2 ) {
            TreeNode * root = new TreeNode(t1->val + t2->val);
            root->left = mergeTrees(t1->left, t2->right);
            root->right = mergeTrees(t1->right, t2->left);
            return root;
        } else {
            return t1 ? t1 : t2;
        }
    }
};",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if ( t1 && t2 ) {
            TreeNode * root = new TreeNode(t1->val + t2->val);
            root->left = mergeTrees(t1->left, t2->left);
            root->right = mergeTrees(t1->right, t2->right);
            return root;
        } else {
            return t1 ? t1 : t2;
        }
    }
};
"
39,cpp,minimum-operations-to-halve-array-sum,"class Solution {
public:

    int halveArray(vector<int>& nums) 
    {
        priority_queue<double>Q;

        double sum=0;

        for(auto ele : nums)
        {
            sum+=ele;
            Q.push(ele);
            
        }
        
        double half=sum/2;

        int count=0;
        while(sum>half)
        { 
            double max=Q.top();
            Q.pop();

            max/=2;                 
            Q.push(max);
            count++;

            sum+=max;               
        }
       
        return count;
        
    }
};",None,"class Solution {
public:

    int halveArray(vector<int>& nums) 
    {
        priority_queue<double>Q;

        double sum=0;

        for(auto ele : nums)
        {
            sum+=ele;
            Q.push(ele);
            
        }
        
        double half=sum/2;

        int count=0;
        while(sum>half)
        { 
            double max=Q.top();
            Q.pop();

            max/=2;                 
            Q.push(max);
            count++;

            sum-=max;               
        }
       
        return count;
        
    }
};
"
39,cpp,minimum-operations-to-halve-array-sum,"class Solution {
public:

    int halveArray(vector<int>& nums) 
    {
        priority_queue<double>Q;

        double sum=0;

        for(auto ele : nums)
        {
            sum+=ele;
            Q.push(ele);
            
        }
        
        double half=sum/2;

        int count=0;
        while(sum>half)
        { 
            double max=Q.top();
            Q.pop();

            max/=2;                 
            Q.push(max);
            count++;

            sum+=max;               
        }
       
        return count;
        
    }
};",None,"class Solution {
public:

    int halveArray(vector<int>& nums) 
    {
        priority_queue<double>Q;

        double sum=0;

        for(auto ele : nums)
        {
            sum+=ele;
            Q.push(ele);
            
        }
        
        double half=sum/2;

        int count=0;
        while(sum > half + 1e-5) // Allow for floating point precision errors
        { 
            double max=Q.top();
            Q.pop();

            max/=2;                 
            Q.push(max);
            count++;

            sum+=max-max*2;
        }
       
        return count;
        
    }
};
"
39,cpp,minimum-operations-to-halve-array-sum,"class Solution {
public:

    int halveArray(vector<int>& nums) 
    {
        priority_queue<double>Q;

        double sum=0;

        for(auto ele : nums)
        {
            sum+=ele;
            Q.push(ele);
            
        }
        
        double half=sum/2;

        int count=0;
        while(sum>half)
        { 
            double max=Q.top();
            Q.pop();

            max/=2;                 
            Q.push(max);
            count++;

            sum+=max;               
        }
       
        return count;
        
    }
};",None,"class Solution {
public:

    int halveArray(vector<int>& nums) 
    {
        priority_queue<double>Q;

        double sum=0;

        for(auto ele : nums)
        {
            sum+=ele;
            Q.push(-ele); // Change here to push the negative value
        }
        
        double half=sum/2;

        int count=0;
        while(sum>half)
        { 
            double max=-Q.top(); // Change here to get the correct max value
            Q.pop();

            max/=2;                 
            Q.push(-max); // Change here to push the negative value
            count++;

            sum-=max;               
        }
       
        return count;
        
    }
};
"
40,cpp,maximize-win-from-two-segments,"class Solution 
{
public:
    int maximizeWin(vector<int>& a, int k) 
    {
        int n = a.size();
        vector<pair<int, int>> b(n), s(n);
        for (int i = 0; i < n; ++i)
        {
            int target = a[i] + k;
            int idx = max(0, (int)(upper_bound(a.begin(), a.end(), target) - a.begin()) - 1);
            b[i] = {i, idx};
        }
        
        int mx = 0;
        pair<int, int> curr;
        for (int i = n - 1; i >= 0; --i)
        {
            if (b[i].second - b[i].first + 1 > mx)
            {
                mx = b[i].second - b[i].first + 1;
                curr = {b[i].first, b[i].second}; 
            }
            
            s[i] = curr;
        }
        
        int res = 1;
        for (int i = 0; i < n; ++i)
        {
            int j = b[i].second;
            
            res = max(res, b[i].second - b[i].first + 1);
        }
        
        return res;
    }
};",None,"class Solution 
{
public:
    int maximizeWin(vector<int>& a, int k) 
    {
        int n = a.size();
        vector<pair<int, int>> b(n), s(n);
        for (int i = 0; i < n; ++i)
        {
            int target = a[i] + k;
            int idx = max(0, (int)(upper_bound(a.begin(), a.end(), target) - a.begin()) - 1);
            b[i] = {i, idx};
        }
        
        int mx = 0;
        pair<int, int> curr;
        for (int i = n - 1; i >= 0; --i)
        {
            if (b[i].second - b[i].first + 1 > mx)
            {
                mx = b[i].second - b[i].first + 1;
                curr = {b[i].first, b[i].second}; 
            }
            
            s[i] = curr;
        }
        
        int res = 1;
        for (int i = 0; i < n; ++i)
        {
            int j = s[i].second;
            if(j >= 0)
                res = max(res, s[i].second - s[i].first + 1 + (j - s[i].first) + 1);
            else
                res = max(res, s[i].second - s[i].first + 1);
        }
        
        return res;
    }
};
"
40,cpp,maximize-win-from-two-segments,"class Solution 
{
public:
    int maximizeWin(vector<int>& a, int k) 
    {
        int n = a.size();
        vector<pair<int, int>> b(n), s(n);
        for (int i = 0; i < n; ++i)
        {
            int target = a[i] + k;
            int idx = max(0, (int)(upper_bound(a.begin(), a.end(), target) - a.begin()) - 1);
            b[i] = {i, idx};
        }
        
        int mx = 0;
        pair<int, int> curr;
        for (int i = n - 1; i >= 0; --i)
        {
            if (b[i].second - b[i].first + 1 > mx)
            {
                mx = b[i].second - b[i].first + 1;
                curr = {b[i].first, b[i].second}; 
            }
            
            s[i] = curr;
        }
        
        int res = 1;
        for (int i = 0; i < n; ++i)
        {
            int j = b[i].second;
            
            res = max(res, b[i].second - b[i].first + 1);
        }
        
        return res;
    }
};",None,"class Solution 
{
public:
    int maximizeWin(vector<int>& a, int k) 
    {
        int n = a.size();
        vector<pair<int, int>> b(n), s(n);
        for (int i = 0; i < n; ++i)
        {
            int target = a[i] + k;
            int idx = max(0, (int)(upper_bound(a.begin(), a.end(), target) - a.begin()) - 1);
            b[i] = {i, idx};
        }

        int mx = 0;
        pair<int, int> curr;
        for (int i = n - 1; i >= 0; --i)
        {
            if (b[i].second - b[i].first + 1 > mx)
            {
                mx = b[i].second - b[i].first + 1;
                curr = {b[i].first, b[i].second}; 
            }

            s[i] = curr;
        }

        int res = 0;
        for (int i = 0; i < n; ++i)
        {
            int j = b[i].second;

            if (i == j)
                continue;

            if (s[j].first <= b[i].first && s[j].second >= b[i].first)
                continue;

            if (s[j].first >= b[i].first && s[j].first <= b[i].second)
                continue;

            res = max(res, mx);
        }

        return res;
    }
};
"
40,cpp,maximize-win-from-two-segments,"class Solution 
{
public:
    int maximizeWin(vector<int>& a, int k) 
    {
        int n = a.size();
        vector<pair<int, int>> b(n), s(n);
        for (int i = 0; i < n; ++i)
        {
            int target = a[i] + k;
            int idx = max(0, (int)(upper_bound(a.begin(), a.end(), target) - a.begin()) - 1);
            b[i] = {i, idx};
        }
        
        int mx = 0;
        pair<int, int> curr;
        for (int i = n - 1; i >= 0; --i)
        {
            if (b[i].second - b[i].first + 1 > mx)
            {
                mx = b[i].second - b[i].first + 1;
                curr = {b[i].first, b[i].second}; 
            }
            
            s[i] = curr;
        }
        
        int res = 1;
        for (int i = 0; i < n; ++i)
        {
            int j = b[i].second;
            
            res = max(res, b[i].second - b[i].first + 1);
        }
        
        return res;
    }
};",None,"class Solution 
{
public:
    int maximizeWin(vector<int>& a, int k) 
    {
        int n = a.size();
        vector<pair<int, int>> b(n), s(n);
        for (int i = 0; i < n; ++i)
        {
            int target = a[i] + k;
            int idx = max(0, (int)(upper_bound(a.begin(), a.end(), target) - a.begin()) - 1);
            b[i] = {i, idx};
        }

        int mx = 0;
        pair<int, int> curr;
        for (int i = n - 1; i >= 0; --i)
        {
            if (b[i].second - b[i].first + 1 > mx)
            {
                mx = b[i].second - b[i].first + 1;
                curr = {b[i].first, b[i].second}; 
            }

            s[i] = curr;
        }

        int res = 0;
        for (int i = 0; i < n; ++i)
        {
            if (i == s[i].first)
                res++;

            if (i == s[i].second)
                res++;
        }

        return res;
    }
};
"
41,cpp,greatest-sum-divisible-by-three,"class Solution {
public:
int ans=0;

    int maxSumDivThree(vector<int>& nums) {
        vector<int>dp(3);
        for(auto a:nums){
            for(int i:vector<int>(dp)){
                dp[(i+a)%3]=max(dp[(i+a)%3],a);
            }
        }
       return dp[0];
        
    }
};",None,"class Solution {
public:
    int maxSumDivThree(vector<int>& nums) {
        vector<int> dp(3, 0);
        for(auto a:nums){
            vector<int> newdp(3);
            for(int i=0; i<3; i++){
                newdp[(i+a)%3] = max(dp[(i+a)%3], dp[i]+a);
            }
            dp = newdp;
        }
       return dp[0];
    }
};
"
41,cpp,greatest-sum-divisible-by-three,"class Solution {
public:
int ans=0;

    int maxSumDivThree(vector<int>& nums) {
        vector<int>dp(3);
        for(auto a:nums){
            for(int i:vector<int>(dp)){
                dp[(i+a)%3]=max(dp[(i+a)%3],a);
            }
        }
       return dp[0];
        
    }
};",None,"class Solution {
public:
    int maxSumDivThree(vector<int>& nums) {
        vector<int> dp(3, 0);
        for(auto a:nums){
            for(int i=0; i<3; i++){
                dp[(i+a)%3] = max(dp[(i+a)%3], dp[i] + a);
            }
        }
       return dp[0];
        
    }
};
"
41,cpp,greatest-sum-divisible-by-three,"class Solution {
public:
int ans=0;

    int maxSumDivThree(vector<int>& nums) {
        vector<int>dp(3);
        for(auto a:nums){
            for(int i:vector<int>(dp)){
                dp[(i+a)%3]=max(dp[(i+a)%3],a);
            }
        }
       return dp[0];
        
    }
};",None,"class Solution {
public:
    int maxSumDivThree(vector<int>& nums) {
        vector<int> dp(3, 0);
        for(auto a:nums){
            for(int i=0; i<3; i++){
                dp[(i+a)%3] = max(dp[(i+a)%3], dp[i] + a);
            }
        }
       return dp[0];
        
    }
};
"
42,cpp,loud-and-rich,"class Solution {
public:
    vector<int>dp;
    int dfs(int node, vector<vector<int>>&adj, vector<int>& quiet){
        if(dp[node]!=-1) return dp[node];

        int miniVal  = quiet[node]; 
        int miniNode = node;

        for(auto it:adj[node]){
            int miniIndex = dfs(it,adj,quiet);
            if(quiet[miniIndex] < miniVal){
                miniVal = quiet[miniIndex];
                miniNode = miniVal;
            } 

        }

        return dp[node] = miniNode;        
    }
    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {
        int n = quiet.size();
        dp.resize(n,-1);
        vector<vector<int>>adj(n);
        vector<int>ans;
        for(auto it: richer){
            adj[it[1]].push_back(it[0]);
        }

        for(int i =0;i<n;i++){
            int res = dfs(i,adj,quiet);
            ans.push_back(res);
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<int>dp;
    int dfs(int node, vector<vector<int>>&adj, vector<int>& quiet){
        if(dp[node]!=-1) return dp[node];

        int miniVal  = node; 
        int miniNode = node;

        for(auto it:adj[node]){
            int miniIndex = dfs(it,adj,quiet);
            if(quiet[miniIndex] < quiet[miniNode]){
                miniVal = quiet[miniIndex];
                miniNode = miniIndex;
            } 

        }

        return dp[node] = miniNode;        
    }
    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {
        int n = quiet.size();
        dp.resize(n,-1);
        vector<vector<int>>adj(n);
        vector<int>ans;
        for(auto it: richer){
            adj[it[0]].push_back(it[1]);
        }

        for(int i =0;i<n;i++){
            int res = dfs(i,adj,quiet);
            ans.push_back(res);
        }
        return ans;
    }
};
"
42,cpp,loud-and-rich,"class Solution {
public:
    vector<int>dp;
    int dfs(int node, vector<vector<int>>&adj, vector<int>& quiet){
        if(dp[node]!=-1) return dp[node];

        int miniVal  = quiet[node]; 
        int miniNode = node;

        for(auto it:adj[node]){
            int miniIndex = dfs(it,adj,quiet);
            if(quiet[miniIndex] < miniVal){
                miniVal = quiet[miniIndex];
                miniNode = miniVal;
            } 

        }

        return dp[node] = miniNode;        
    }
    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {
        int n = quiet.size();
        dp.resize(n,-1);
        vector<vector<int>>adj(n);
        vector<int>ans;
        for(auto it: richer){
            adj[it[1]].push_back(it[0]);
        }

        for(int i =0;i<n;i++){
            int res = dfs(i,adj,quiet);
            ans.push_back(res);
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<int>dp;
    int dfs(int node, vector<vector<int>>&adj, vector<int>& quiet){
        if(dp[node]!=-1) return dp[node];

        int miniVal  = node; 

        for(auto it:adj[node]){
            int miniIndex = dfs(it,adj,quiet);
            if(quiet[miniIndex] < quiet[miniVal]){
                miniVal = miniIndex;
            } 
        }

        return dp[node] = miniVal;        
    }
    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {
        int n = quiet.size();
        dp.resize(n,-1);
        vector<vector<int>>adj(n);
        vector<int>ans;
        for(auto it: richer){
            adj[it[0]].push_back(it[1]);
        }

        for(int i =0;i<n;i++){
            int res = dfs(i,adj,quiet);
            ans.push_back(res);
        }
        return ans;
    }
};
"
42,cpp,loud-and-rich,"class Solution {
public:
    vector<int>dp;
    int dfs(int node, vector<vector<int>>&adj, vector<int>& quiet){
        if(dp[node]!=-1) return dp[node];

        int miniVal  = quiet[node]; 
        int miniNode = node;

        for(auto it:adj[node]){
            int miniIndex = dfs(it,adj,quiet);
            if(quiet[miniIndex] < miniVal){
                miniVal = quiet[miniIndex];
                miniNode = miniVal;
            } 

        }

        return dp[node] = miniNode;        
    }
    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {
        int n = quiet.size();
        dp.resize(n,-1);
        vector<vector<int>>adj(n);
        vector<int>ans;
        for(auto it: richer){
            adj[it[1]].push_back(it[0]);
        }

        for(int i =0;i<n;i++){
            int res = dfs(i,adj,quiet);
            ans.push_back(res);
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<int>dp;
    int dfs(int node, vector<vector<int>>&adj, vector<int>& quiet){
        if(dp[node]!=-1) return dp[node];

        int miniVal  = quiet[node]; 
        int miniNode = node;

        for(auto it:adj[node]){
            int miniIndex = dfs(it,adj,quiet);
            if(quiet[miniIndex] < miniVal){
                miniVal = quiet[miniIndex];
                miniNode = miniIndex;
            } 

        }

        return dp[node] = miniNode;        
    }
    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {
        int n = quiet.size();
        dp.resize(n,-1);
        vector<vector<int>>adj(n);
        vector<int>ans;
        for(auto it: richer){
            adj[it[0]].push_back(it[1]);
        }

        for(int i =0;i<n;i++){
            int res = dfs(i,adj,quiet);
            ans.push_back(res);
        }
        return ans;
    }
};
"
43,cpp,relative-ranks,"class Solution {
public:
    vector<string> findRelativeRanks(vector<int>& score) {
        int n = score.size();
        
        vector<pair<int, int>> arr;
        for (int i=0; i<n; i++) arr.push_back({score[i], i});

        sort(rbegin(arr), rend(arr));

        vector<string> res(n);
        for (int i=0; i<n; i++) 
            res[arr[i].second] = i==0? ""Gold Medal"": (i==1? ""Silver Medal"": (i==2? ""Bronze Medal"": to_string(i+1)));

        res[arr[0].second] = ""LeanBack Medal"";
        return res;
    }
};",None,"class Solution {
public:
    vector<string> findRelativeRanks(vector<int>& score) {
        int n = score.size();
        vector<pair<int, int>> arr(n);
        for (int i=0; i<n; i++) arr[i] = {score[i], i};

        sort(arr.begin(), arr.end(), greater<pair<int, int>>());

        vector<string> res(n);
        for (int i=0; i<n; i++) 
            res[arr[i].second] = (i==0? ""Gold Medal"": (i==1? ""Silver Medal"": (i==2? ""Bronze Medal"": to_string(i+1))));

        return res;
    }
};
"
43,cpp,relative-ranks,"class Solution {
public:
    vector<string> findRelativeRanks(vector<int>& score) {
        int n = score.size();
        
        vector<pair<int, int>> arr;
        for (int i=0; i<n; i++) arr.push_back({score[i], i});

        sort(rbegin(arr), rend(arr));

        vector<string> res(n);
        for (int i=0; i<n; i++) 
            res[arr[i].second] = i==0? ""Gold Medal"": (i==1? ""Silver Medal"": (i==2? ""Bronze Medal"": to_string(i+1)));

        res[arr[0].second] = ""LeanBack Medal"";
        return res;
    }
};",None,"class Solution {
public:
    vector<string> findRelativeRanks(vector<int>& score) {
        int n = score.size();
        
        vector<pair<int, int>> arr;
        for (int i=0; i<n; i++) arr.push_back({score[i], i});

        sort(arr.begin(), arr.end(), greater<pair<int, int>>());

        vector<string> res(n);
        for (int i=0; i<n; i++) 
            res[arr[i].second] = (i==0? ""Gold Medal"": (i==1? ""Silver Medal"": (i==2? ""Bronze Medal"": to_string(i+1))));

        return res;
    }
};
"
43,cpp,relative-ranks,"class Solution {
public:
    vector<string> findRelativeRanks(vector<int>& score) {
        int n = score.size();
        
        vector<pair<int, int>> arr;
        for (int i=0; i<n; i++) arr.push_back({score[i], i});

        sort(rbegin(arr), rend(arr));

        vector<string> res(n);
        for (int i=0; i<n; i++) 
            res[arr[i].second] = i==0? ""Gold Medal"": (i==1? ""Silver Medal"": (i==2? ""Bronze Medal"": to_string(i+1)));

        res[arr[0].second] = ""LeanBack Medal"";
        return res;
    }
};",None,"class Solution {
public:
    vector<string> findRelativeRanks(vector<int>& score) {
        int n = score.size();
        vector<pair<int, int>> arr;
        for (int i=0; i<n; i++) arr.push_back({score[i], i});

        sort(arr.begin(), arr.end(), greater<pair<int, int>>());

        vector<string> res(n);
        for (int i=0; i<n; i++) 
            res[arr[i].second] = i==0? ""Gold Medal"": (i==1? ""Silver Medal"": (i==2? ""Bronze Medal"": to_string(i+1)));

        return res;
    }
};
"
44,cpp,lexicographically-smallest-string-after-substring-operation,"class Solution {
public:
    string smallestString(string s) {
        int temp = -1;
        int cnt = 0;
        for(int i = 0; i < s.size(); i++)
        {
            if(s[i] == 'a')
            {
                cnt++;
            }
        }
        if(cnt == s.size())
        {
            s[s.size()] = 'z';
            return s;
        }
        else
        {
            for(int i = 0; i < s.size(); i++)
            {
                if(s[i] == 'a')
                {
                    temp = i;
                    break;
                }
            }

            if(temp == 0)
            {
                int temp1 = 1, temp2 = 1;
                for(int i = 1 ; i < s.size(); i++)
                {
                    if(s[i] != 'a')
                    {
                        temp1 = i;
                        break;
                    }
                }
                for(int i = temp1; i < s.size(); i++)
                {
                    if(s[i] == 'a')
                    {
                        temp2 = i;
                        break;
                    }
                }

                if(temp2 > 1)
                {
                    for(int i = temp1; i < temp2; i++)
                    {
                        s[i] = s[i] - 1;
                    }
                }
                else if(temp2 == 1)
                {
                    for(int i = temp1; i < s.size(); i++)
                    {
                        s[i] = s[i] - 1;
                    }
                }

                return s;
            }
            else if(temp == -1)
            {
                for(int i = 0; i < s.size(); i++)
                {
                    s[i] = s[i] - 1;
                }
                return s;
            }
            else
            {
                for(int i = 0; i < temp; i++)
                {
                    s[i] = s[i] - 1;
                }
                return s;
            }
        }
    }
};",None,"class Solution {
public:
    string smallestString(string s) {
        int temp = -1;
        for(int i = 0; i < s.size(); i++)
        {
            if(s[i] == 'a')
            {
                temp = i;
                break;
            }
        }

        if(temp == -1)
        {
            for(int i = 0; i < s.size(); i++)
            {
                s[i] = 'a' - 1 + s[i];
            }
            return s;
        }
        else
        {
            for(int i = 0; i < temp; i++)
            {
                s[i] = 'a' - 1 + s[i];
            }

            int i = temp;
            while(i < s.size() && s[i] == 'a')
            {
                i++;
            }

            if(i < s.size())
            {
                s[i] = 'a' - 1 + s[i];
                for(int j = i + 1; j < s.size(); j++)
                {
                    s[j] = s[j - 1] - 1;
                }
            }
        }

        return s;
    }
};
"
44,cpp,lexicographically-smallest-string-after-substring-operation,"class Solution {
public:
    string smallestString(string s) {
        int temp = -1;
        int cnt = 0;
        for(int i = 0; i < s.size(); i++)
        {
            if(s[i] == 'a')
            {
                cnt++;
            }
        }
        if(cnt == s.size())
        {
            s[s.size()] = 'z';
            return s;
        }
        else
        {
            for(int i = 0; i < s.size(); i++)
            {
                if(s[i] == 'a')
                {
                    temp = i;
                    break;
                }
            }

            if(temp == 0)
            {
                int temp1 = 1, temp2 = 1;
                for(int i = 1 ; i < s.size(); i++)
                {
                    if(s[i] != 'a')
                    {
                        temp1 = i;
                        break;
                    }
                }
                for(int i = temp1; i < s.size(); i++)
                {
                    if(s[i] == 'a')
                    {
                        temp2 = i;
                        break;
                    }
                }

                if(temp2 > 1)
                {
                    for(int i = temp1; i < temp2; i++)
                    {
                        s[i] = s[i] - 1;
                    }
                }
                else if(temp2 == 1)
                {
                    for(int i = temp1; i < s.size(); i++)
                    {
                        s[i] = s[i] - 1;
                    }
                }

                return s;
            }
            else if(temp == -1)
            {
                for(int i = 0; i < s.size(); i++)
                {
                    s[i] = s[i] - 1;
                }
                return s;
            }
            else
            {
                for(int i = 0; i < temp; i++)
                {
                    s[i] = s[i] - 1;
                }
                return s;
            }
        }
    }
};",None,"class Solution {
public:
    string smallestString(string s) {
        int temp = -1;
        for(int i = 0; i < s.size(); i++)
        {
            if(s[i] == 'a')
            {
                temp = i;
                break;
            }
        }

        if(temp == -1)
        {
            for(int i = 0; i < s.size(); i++)
            {
                s[i] = s[i] - 1;
            }
        }
        else
        {
            for(int i = 0; i < temp; i++)
            {
                s[i] = s[i] - 1;
            }

            for(int i = temp; i < s.size(); i++)
            {
                s[i] = 'z';
            }
        }

        return s;
    }
};
"
44,cpp,lexicographically-smallest-string-after-substring-operation,"class Solution {
public:
    string smallestString(string s) {
        int temp = -1;
        int cnt = 0;
        for(int i = 0; i < s.size(); i++)
        {
            if(s[i] == 'a')
            {
                cnt++;
            }
        }
        if(cnt == s.size())
        {
            s[s.size()] = 'z';
            return s;
        }
        else
        {
            for(int i = 0; i < s.size(); i++)
            {
                if(s[i] == 'a')
                {
                    temp = i;
                    break;
                }
            }

            if(temp == 0)
            {
                int temp1 = 1, temp2 = 1;
                for(int i = 1 ; i < s.size(); i++)
                {
                    if(s[i] != 'a')
                    {
                        temp1 = i;
                        break;
                    }
                }
                for(int i = temp1; i < s.size(); i++)
                {
                    if(s[i] == 'a')
                    {
                        temp2 = i;
                        break;
                    }
                }

                if(temp2 > 1)
                {
                    for(int i = temp1; i < temp2; i++)
                    {
                        s[i] = s[i] - 1;
                    }
                }
                else if(temp2 == 1)
                {
                    for(int i = temp1; i < s.size(); i++)
                    {
                        s[i] = s[i] - 1;
                    }
                }

                return s;
            }
            else if(temp == -1)
            {
                for(int i = 0; i < s.size(); i++)
                {
                    s[i] = s[i] - 1;
                }
                return s;
            }
            else
            {
                for(int i = 0; i < temp; i++)
                {
                    s[i] = s[i] - 1;
                }
                return s;
            }
        }
    }
};",None,"class Solution {
public:
    string smallestString(string s) {
        int temp = -1;
        for(int i = 0; i < s.size(); i++)
        {
            if(s[i] == 'a')
            {
                temp = i;
                break;
            }
        }

        if(temp == -1)
        {
            for(int i = 0; i < s.size(); i++)
            {
                s[i] = 'a' - 1;
            }
            s[0]++;
            return s;
        }
        else
        {
            for(int i = 0; i < temp; i++)
            {
                s[i] = s[i] - 1;
            }
            return s;
        }
    }
};
"
45,cpp,minimum-sideway-jumps,"class Solution {
public:
    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){
        if(i==obstacles.size()-2){
            if(obstacles[i+1]==l)return 1;
            return 0;
        }

        if(dp[i][l]!=-1)return dp[i][l];

        if(obstacles[i+1]!=l){
            return dp[i][l] = func(i+1,l,obstacles,dp);
        }

    
        int b=INT_MAX;
        for(int j=1;j<=3;j++){
            if(l==j)continue;
            if(obstacles[i+1]==j)continue; 
            b=min(b,1+func(i,j,obstacles,dp));
        }
    

        return dp[i][l] = b;
    }

    int minSideJumps(vector<int>& obstacles) {
        int n=obstacles.size();
        vector<vector<int>>dp(n,vector<int>(4,-1));
        return func(0,2,obstacles,dp);
    }
};",None,"class Solution {
public:
    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){
        if(i==obstacles.size()-1){
            return 0;
        }

        if(dp[i][l]!=-1)return dp[i][l];

        int res = INT_MAX;
        if(obstacles[i+1]!=l){
            res = func(i+1,l,obstacles,dp);
        }

        for(int j=1;j<=3;j++){
            if(l==j || obstacles[i+1]==j)continue;
            res = min(res, 1 + func(i+1, j, obstacles, dp));
        }

        return dp[i][l] = res;
    }

    int minSideJumps(vector<int>& obstacles) {
        int n=obstacles.size();
        vector<vector<int>>dp(n,vector<int>(4,-1));
        return func(0,2,obstacles,dp);
    }
};
"
45,cpp,minimum-sideway-jumps,"class Solution {
public:
    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){
        if(i==obstacles.size()-2){
            if(obstacles[i+1]==l)return 1;
            return 0;
        }

        if(dp[i][l]!=-1)return dp[i][l];

        if(obstacles[i+1]!=l){
            return dp[i][l] = func(i+1,l,obstacles,dp);
        }

    
        int b=INT_MAX;
        for(int j=1;j<=3;j++){
            if(l==j)continue;
            if(obstacles[i+1]==j)continue; 
            b=min(b,1+func(i,j,obstacles,dp));
        }
    

        return dp[i][l] = b;
    }

    int minSideJumps(vector<int>& obstacles) {
        int n=obstacles.size();
        vector<vector<int>>dp(n,vector<int>(4,-1));
        return func(0,2,obstacles,dp);
    }
};",None,"class Solution {
public:
    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){
        if(i==obstacles.size()-1){
            return 0;
        }

        if(dp[i][l]!=-1)return dp[i][l];

        if(obstacles[i+1]!=l){
            return dp[i][l] = func(i+1,l,obstacles,dp);
        }

        int b=INT_MAX;
        for(int j=1;j<=3;j++){
            if(l==j)continue;
            if(obstacles[i+1]==j)continue; 
            b=min(b,1+func(i,j,obstacles,dp));
        }
    

        return dp[i][l] = b;
    }

    int minSideJumps(vector<int>& obstacles) {
        int n=obstacles.size();
        vector<vector<int>>dp(n,vector<int>(4,-1));
        return func(0,2,obstacles,dp);
    }
};
"
45,cpp,minimum-sideway-jumps,"class Solution {
public:
    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){
        if(i==obstacles.size()-2){
            if(obstacles[i+1]==l)return 1;
            return 0;
        }

        if(dp[i][l]!=-1)return dp[i][l];

        if(obstacles[i+1]!=l){
            return dp[i][l] = func(i+1,l,obstacles,dp);
        }

    
        int b=INT_MAX;
        for(int j=1;j<=3;j++){
            if(l==j)continue;
            if(obstacles[i+1]==j)continue; 
            b=min(b,1+func(i,j,obstacles,dp));
        }
    

        return dp[i][l] = b;
    }

    int minSideJumps(vector<int>& obstacles) {
        int n=obstacles.size();
        vector<vector<int>>dp(n,vector<int>(4,-1));
        return func(0,2,obstacles,dp);
    }
};",None,"class Solution {
public:
    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){
        if(i==obstacles.size()-1){
            return 0;
        }

        if(dp[i][l]!=-1)return dp[i][l];

        if(obstacles[i+1]!=l){
            return dp[i][l] = func(i+1,l,obstacles,dp);
        }

        int b=INT_MAX;
        for(int j=1;j<=3;j++){
            if(l==j)continue;
            if(obstacles[i+1]==j)continue; 
            b=min(b,1+func(i,j,obstacles,dp));
        }
    

        return dp[i][l] = b;
    }

    int minSideJumps(vector<int>& obstacles) {
        int n=obstacles.size();
        vector<vector<int>>dp(n,vector<int>(4,-1));
        return func(0,2,obstacles,dp);
    }
};
"
46,cpp,count-the-number-of-beautiful-subarrays,"class Solution {
public:
    long long beautifulSubarrays(vector<int>& nums) {
        
        int n = nums.size();
        
        long long ans = 0;
        
        
        unordered_map<int, int> mp;
        
        
        
        mp[0] = 1;
        
        int curr_xorr = 0;
        
        
        for(int i = 0; i <= n; i++)
        {
            
            curr_xorr = (curr_xorr ^ nums[i]);
            
            
            if(mp.count(curr_xorr))
            {
                ans += mp[curr_xorr];
            }
            
            
            mp[curr_xorr]++;
        }
        
        return ans;
    }
};",None,"class Solution {
public:
    long long beautifulSubarrays(vector<int>& nums) {
        
        int n = nums.size();
        
        long long ans = 0;
        
        
        unordered_map<int, int> mp;
        
        
        mp[0] = 1;
        
        int curr_xorr = 0;
        
        
        for(int i = 0; i < n; i++)
        {
            
            curr_xorr = (curr_xorr ^ nums[i]);
            
            
            if(mp.count(curr_xorr))
            {
                ans += mp[curr_xorr];
            }
            
            
            mp[curr_xorr]++;
        }
        
        return ans;
    }
};
"
46,cpp,count-the-number-of-beautiful-subarrays,"class Solution {
public:
    long long beautifulSubarrays(vector<int>& nums) {
        
        int n = nums.size();
        
        long long ans = 0;
        
        
        unordered_map<int, int> mp;
        
        
        
        mp[0] = 1;
        
        int curr_xorr = 0;
        
        
        for(int i = 0; i <= n; i++)
        {
            
            curr_xorr = (curr_xorr ^ nums[i]);
            
            
            if(mp.count(curr_xorr))
            {
                ans += mp[curr_xorr];
            }
            
            
            mp[curr_xorr]++;
        }
        
        return ans;
    }
};",None,"class Solution {
public:
    long long beautifulSubarrays(vector<int>& nums) {
        
        int n = nums.size();
        
        long long ans = 0;
        
        unordered_map<int, int> mp;
        
        mp[0] = 1;
        
        int curr_xorr = 0;
        
        for(int i = 0; i < n; i++)
        {
            curr_xorr = (curr_xorr ^ nums[i]);
            ans += mp[curr_xorr];
            mp[curr_xorr]++;
        }
        
        return ans;
    }
};
"
46,cpp,count-the-number-of-beautiful-subarrays,"class Solution {
public:
    long long beautifulSubarrays(vector<int>& nums) {
        
        int n = nums.size();
        
        long long ans = 0;
        
        
        unordered_map<int, int> mp;
        
        
        
        mp[0] = 1;
        
        int curr_xorr = 0;
        
        
        for(int i = 0; i <= n; i++)
        {
            
            curr_xorr = (curr_xorr ^ nums[i]);
            
            
            if(mp.count(curr_xorr))
            {
                ans += mp[curr_xorr];
            }
            
            
            mp[curr_xorr]++;
        }
        
        return ans;
    }
};",None,"class Solution {
public:
    long long beautifulSubarrays(vector<int>& nums) {
        
        int n = nums.size();
        
        long long ans = 0;
        
        unordered_map<int, int> mp;
        
        mp[0] = 1;
        
        int curr_xorr = 0;
        
        for(int i = 0; i < n; i++)
        {
            curr_xorr = (curr_xorr ^ nums[i]);
            ans += mp[curr_xorr];
            mp[curr_xorr]++;
        }
        
        return ans;
    }
};
"
47,cpp,count-number-of-possible-root-nodes,"class Solution {
public:
    map<pair<int,int>,int> mp;
    void dfs(vector<vector<int>>& tree,vector<int>& possible,int cur ,int ans,int k)
    {
        for(auto& a:tree[cur])
        {
            if(possible[a]==-1)
            {
                int new_ans=ans;
                bool a1=false,a2=false;
                if(mp.find({a,cur})!=mp.end() && mp[{a,cur}]==0  )
                {
                    mp[{a,cur}]=1;
                    new_ans++;
                    a1=true;
                }
                if(mp.find({cur,a })!=mp.end() && mp[{cur,a}]==1  )
                {
                    mp[{cur,a}]=0;
                    new_ans--;
                    a2=true;
                }
                
                possible[a]=0;
                if(new_ans>=k)
                {
                    possible[a]=2;
                }
                dfs(tree,possible,a,new_ans,k);
                if(a1)
                {
                    mp[{a,cur}]=0;
                }
                if(a2)
                {
                    mp[{cur,a}]=1;
                }
            }
        }

    }
    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {
        
        for(auto&e : guesses)
        {
            mp[ {e[0],e[1]}]=0;
        }
        int n=edges.size()+1;
        vector<vector<int>> tree(n);
        for(auto& e:edges)
        {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }
        queue<int> q;
        q.push(0);
        vector<bool> visited(n,false);
        visited[0]=true;
        int ans=0;
        while(q.size()>0)
        {
            int a=q.front();
            q.pop();
            for(int i=0;i<tree[a].size();i++)
            {
                if(visited[tree[a][i]])
                    continue;
                visited[tree[a][i]]=true;
                if(mp.find({a,tree[a][i]})!=mp.end() && mp[{a,tree[a][i]}]==0  )
                {
                    mp[{a,tree[a][i]}]=1;
                    ans++;
                }
                if(mp.find({tree[a][i],a })!=mp.end() && mp[{tree[a][i],a}]==1  )
                {
                    mp[{tree[a][i],a}]=0;
                    ans--;
                }
                q.push(tree[a][i]);
            }
        }
        vector<int> possible(n,-1);
        possible[0]= (1?ans>=k:0);
        dfs(tree,possible,0,ans,k);
        int sum=accumulate(possible.begin(),possible.end(),0);
        return sum;
    }
};",None,"class Solution {
public:
    map<pair<int,int>,int> mp;
    void dfs(vector<vector<int>>& tree,vector<int>& possible,int cur ,int ans,int k)
    {
        for(auto& a:tree[cur])
        {
            if(possible[a]==-1)
            {
                int new_ans=ans;
                bool a1=false,a2=false;
                if(mp.find({a,cur})!=mp.end() && mp[{a,cur}]==0  )
                {
                    mp[{a,cur}]=1;
                    new_ans++;
                    a1=true;
                }
                if(mp.find({cur,a })!=mp.end() && mp[{cur,a}]==1  )
                {
                    mp[{cur,a}]=0;
                    new_ans--;
                    a2=true;
                }

                possible[a]= (new_ans>=k?1:0);
                dfs(tree,possible,a,new_ans,k);

                if(a1)
                {
                    mp[{a,cur}]=0;
                }
                if(a2)
                {
                    mp[{cur,a}]=1;
                }
            }
        }
    }
    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {
        
        for(auto&e : guesses)
        {
            mp[ {e[0],e[1]}]=0;
        }
        int n=edges.size()+1;
        vector<vector<int>> tree(n);
        for(auto& e:edges)
        {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }
        queue<int> q;
        q.push(0);
        vector<bool> visited(n,false);
        visited[0]=true;
        int ans=0;
        while(q.size()>0)
        {
            int a=q.front();
            q.pop();
            for(int i=0;i<tree[a].size();i++)
            {
                if(visited[tree[a][i]])
                    continue;
                visited[tree[a][i]]=true;
                if(mp.find({a,tree[a][i]})!=mp.end() && mp[{a,tree[a][i]}]==0  )
                {
                    mp[{a,tree[a][i]}]=1;
                    ans++;
                }
                if(mp.find({tree[a][i],a })!=mp.end() && mp[{tree[a][i],a}]==1  )
                {
                    mp[{tree[a][i],a}]=0;
                    ans--;
                }
                q.push(tree[a][i]);
            }
        }
        vector<int> possible(n,-1);
        dfs(tree,possible,0,ans,k);
        int sum=accumulate(possible.begin(),possible.end(),0);
        return sum;
    }
};
"
47,cpp,count-number-of-possible-root-nodes,"class Solution {
public:
    map<pair<int,int>,int> mp;
    void dfs(vector<vector<int>>& tree,vector<int>& possible,int cur ,int ans,int k)
    {
        for(auto& a:tree[cur])
        {
            if(possible[a]==-1)
            {
                int new_ans=ans;
                bool a1=false,a2=false;
                if(mp.find({a,cur})!=mp.end() && mp[{a,cur}]==0  )
                {
                    mp[{a,cur}]=1;
                    new_ans++;
                    a1=true;
                }
                if(mp.find({cur,a })!=mp.end() && mp[{cur,a}]==1  )
                {
                    mp[{cur,a}]=0;
                    new_ans--;
                    a2=true;
                }
                
                possible[a]=0;
                if(new_ans>=k)
                {
                    possible[a]=2;
                }
                dfs(tree,possible,a,new_ans,k);
                if(a1)
                {
                    mp[{a,cur}]=0;
                }
                if(a2)
                {
                    mp[{cur,a}]=1;
                }
            }
        }

    }
    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {
        
        for(auto&e : guesses)
        {
            mp[ {e[0],e[1]}]=0;
        }
        int n=edges.size()+1;
        vector<vector<int>> tree(n);
        for(auto& e:edges)
        {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }
        queue<int> q;
        q.push(0);
        vector<bool> visited(n,false);
        visited[0]=true;
        int ans=0;
        while(q.size()>0)
        {
            int a=q.front();
            q.pop();
            for(int i=0;i<tree[a].size();i++)
            {
                if(visited[tree[a][i]])
                    continue;
                visited[tree[a][i]]=true;
                if(mp.find({a,tree[a][i]})!=mp.end() && mp[{a,tree[a][i]}]==0  )
                {
                    mp[{a,tree[a][i]}]=1;
                    ans++;
                }
                if(mp.find({tree[a][i],a })!=mp.end() && mp[{tree[a][i],a}]==1  )
                {
                    mp[{tree[a][i],a}]=0;
                    ans--;
                }
                q.push(tree[a][i]);
            }
        }
        vector<int> possible(n,-1);
        possible[0]= (1?ans>=k:0);
        dfs(tree,possible,0,ans,k);
        int sum=accumulate(possible.begin(),possible.end(),0);
        return sum;
    }
};",None,"class Solution {
public:
    map<pair<int,int>,int> mp;
    void dfs(vector<vector<int>>& tree,vector<int>& possible,int cur ,int ans,int k)
    {
        for(auto& a:tree[cur])
        {
            if(possible[a]==-1)
            {
                int new_ans=ans;
                bool a1=false,a2=false;
                if(mp.find({a,cur})!=mp.end() && mp[{a,cur}]==0  )
                {
                    mp[{a,cur}]=1;
                    new_ans++;
                    a1=true;
                }
                if(mp.find({cur,a })!=mp.end() && mp[{cur,a}]==1  )
                {
                    mp[{cur,a}]=0;
                    new_ans--;
                    a2=true;
                }

                possible[a]= (new_ans>=k)?2:0;
                if(possible[a]==2)
                {
                    dfs(tree,possible,a,new_ans,k);
                }

                if(a1)
                {
                    mp[{a,cur}]=0;
                }
                if(a2)
                {
                    mp[{cur,a}]=1;
                }
            }
        }
    }
    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {
        
        for(auto&e : guesses)
        {
            mp[ {e[0],e[1]}]=0;
        }
        int n=edges.size()+1;
        vector<vector<int>> tree(n);
        for(auto& e:edges)
        {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }
        queue<int> q;
        q.push(0);
        vector<bool> visited(n,false);
        visited[0]=true;
        int ans=0;
        while(q.size()>0)
        {
            int a=q.front();
            q.pop();
            for(int i=0;i<tree[a].size();i++)
            {
                if(visited[tree[a][i]])
                    continue;
                visited[tree[a][i]]=true;
                if(mp.find({a,tree[a][i]})!=mp.end() && mp[{a,tree[a][i]}]==0  )
                {
                    mp[{a,tree[a][i]}]=1;
                    ans++;
                }
                if(mp.find({tree[a][i],a })!=mp.end() && mp[{tree[a][i],a}]==1  )
                {
                    mp[{tree[a][i],a}]=0;
                    ans--;
                }
                q.push(tree[a][i]);
            }
        }
        vector<int> possible(n,-1);
        possible[0]= (1?ans>=k:0);
        dfs(tree,possible,0,ans,k);
        int sum=accumulate(possible.begin(),possible.end(),0);
        return sum;
    }
};
"
47,cpp,count-number-of-possible-root-nodes,"class Solution {
public:
    map<pair<int,int>,int> mp;
    void dfs(vector<vector<int>>& tree,vector<int>& possible,int cur ,int ans,int k)
    {
        for(auto& a:tree[cur])
        {
            if(possible[a]==-1)
            {
                int new_ans=ans;
                bool a1=false,a2=false;
                if(mp.find({a,cur})!=mp.end() && mp[{a,cur}]==0  )
                {
                    mp[{a,cur}]=1;
                    new_ans++;
                    a1=true;
                }
                if(mp.find({cur,a })!=mp.end() && mp[{cur,a}]==1  )
                {
                    mp[{cur,a}]=0;
                    new_ans--;
                    a2=true;
                }
                
                possible[a]=0;
                if(new_ans>=k)
                {
                    possible[a]=2;
                }
                dfs(tree,possible,a,new_ans,k);
                if(a1)
                {
                    mp[{a,cur}]=0;
                }
                if(a2)
                {
                    mp[{cur,a}]=1;
                }
            }
        }

    }
    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {
        
        for(auto&e : guesses)
        {
            mp[ {e[0],e[1]}]=0;
        }
        int n=edges.size()+1;
        vector<vector<int>> tree(n);
        for(auto& e:edges)
        {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }
        queue<int> q;
        q.push(0);
        vector<bool> visited(n,false);
        visited[0]=true;
        int ans=0;
        while(q.size()>0)
        {
            int a=q.front();
            q.pop();
            for(int i=0;i<tree[a].size();i++)
            {
                if(visited[tree[a][i]])
                    continue;
                visited[tree[a][i]]=true;
                if(mp.find({a,tree[a][i]})!=mp.end() && mp[{a,tree[a][i]}]==0  )
                {
                    mp[{a,tree[a][i]}]=1;
                    ans++;
                }
                if(mp.find({tree[a][i],a })!=mp.end() && mp[{tree[a][i],a}]==1  )
                {
                    mp[{tree[a][i],a}]=0;
                    ans--;
                }
                q.push(tree[a][i]);
            }
        }
        vector<int> possible(n,-1);
        possible[0]= (1?ans>=k:0);
        dfs(tree,possible,0,ans,k);
        int sum=accumulate(possible.begin(),possible.end(),0);
        return sum;
    }
};",None,"class Solution {
public:
    map<pair<int,int>,int> mp;
    void dfs(vector<vector<int>>& tree,vector<int>& possible,int cur ,int ans,int k)
    {
        for(auto& a:tree[cur])
        {
            if(possible[a]==-1)
            {
                int new_ans=ans;
                bool a1=false,a2=false;
                if(mp.find({a,cur})!=mp.end() && mp[{a,cur}]==0  )
                {
                    mp[{a,cur}]=1;
                    new_ans++;
                    a1=true;
                }
                if(mp.find({cur,a })!=mp.end() && mp[{cur,a}]==1  )
                {
                    mp[{cur,a}]=0;
                    new_ans--;
                    a2=true;
                }

                possible[a]= (new_ans>=k);
                if(possible[a])
                    dfs(tree,possible,a,new_ans,k);

                if(a1)
                {
                    mp[{a,cur}]=0;
                }
                if(a2)
                {
                    mp[{cur,a}]=1;
                }
            }
        }
    }
    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {
        
        for(auto&e : guesses)
        {
            mp[ {e[0],e[1]}]=0;
        }
        int n=edges.size()+1;
        vector<vector<int>> tree(n);
        for(auto& e:edges)
        {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }
        queue<int> q;
        q.push(0);
        vector<bool> visited(n,false);
        visited[0]=true;
        int ans=0;
        while(q.size()>0)
        {
            int a=q.front();
            q.pop();
            for(int i=0;i<tree[a].size();i++)
            {
                if(visited[tree[a][i]])
                    continue;
                visited[tree[a][i]]=true;
                if(mp.find({a,tree[a][i]})!=mp.end() && mp[{a,tree[a][i]}]==0  )
                {
                    mp[{a,tree[a][i]}]=1;
                    ans++;
                }
                if(mp.find({tree[a][i],a })!=mp.end() && mp[{tree[a][i],a}]==1  )
                {
                    mp[{tree[a][i],a}]=0;
                    ans--;
                }
                q.push(tree[a][i]);
            }
        }
        vector<int> possible(n,-1);
        possible[0]= (ans>=k);
        dfs(tree,possible,0,ans,k);
        int sum=accumulate(possible.begin(),possible.end(),0);
        return sum;
    }
};
"
48,cpp,special-binary-string,"class Solution {
public:
    string makeLargestSpecial(string s) {
        
        if(s.length()==0)
            return """";

        vector<string> ans;
        int count=0,i=0;

        for(int j=0;j<s.size();j++){
            if(s[j] == '1')
                count++;
            else
                count--;
            
            if(count==0){
                
                ans.push_back('1' + makeLargestSpecial(s.substr(i+1,j-i-1)) + '0');
                i = j;
            }
        }

        sort(ans.begin(),ans.end(),greater<string>());
        string finalString = """";
        for(i=0;i<ans.size();i++){
            finalString += ans[i];
        }
        return finalString;
    }
};",None,"class Solution {
public:
    string makeLargestSpecial(string s) {
        
        if(s.length()==0)
            return """";

        vector<string> ans;
        int count=0,i=0;

        for(int j=0;j<s.size();j++){
            if(s[j] == '1')
                count++;
            else
                count--;
            
            if(count==0){
                ans.push_back('1' + makeLargestSpecial(s.substr(i+1,j-i-1)) + '0');
                i = j + 1;
            }
        }

        sort(ans.begin(),ans.end(),greater<string>());
        string finalString = """";
        for(i=0;i<ans.size();i++){
            finalString += ans[i];
        }
        return finalString;
    }
};
"
48,cpp,special-binary-string,"class Solution {
public:
    string makeLargestSpecial(string s) {
        
        if(s.length()==0)
            return """";

        vector<string> ans;
        int count=0,i=0;

        for(int j=0;j<s.size();j++){
            if(s[j] == '1')
                count++;
            else
                count--;
            
            if(count==0){
                
                ans.push_back('1' + makeLargestSpecial(s.substr(i+1,j-i-1)) + '0');
                i = j;
            }
        }

        sort(ans.begin(),ans.end(),greater<string>());
        string finalString = """";
        for(i=0;i<ans.size();i++){
            finalString += ans[i];
        }
        return finalString;
    }
};",None,"class Solution {
public:
    string makeLargestSpecial(string s) {
        
        if(s.length()==0)
            return """";

        vector<string> ans;
        int count=0,i=0;

        for(int j=0;j<s.size();j++){
            if(s[j] == '1')
                count++;
            else
                count--;
            
            if(count==0){
                ans.push_back('1' + makeLargestSpecial(s.substr(i+1,j-i-1)) + '0');
                i = j+1;
            }
        }

        sort(ans.begin(),ans.end(),greater<string>());
        string finalString = """";
        for(int i=0;i<ans.size();i++){
            finalString += ans[i];
        }
        return finalString;
    }
};
"
48,cpp,special-binary-string,"class Solution {
public:
    string makeLargestSpecial(string s) {
        
        if(s.length()==0)
            return """";

        vector<string> ans;
        int count=0,i=0;

        for(int j=0;j<s.size();j++){
            if(s[j] == '1')
                count++;
            else
                count--;
            
            if(count==0){
                
                ans.push_back('1' + makeLargestSpecial(s.substr(i+1,j-i-1)) + '0');
                i = j;
            }
        }

        sort(ans.begin(),ans.end(),greater<string>());
        string finalString = """";
        for(i=0;i<ans.size();i++){
            finalString += ans[i];
        }
        return finalString;
    }
};",None,"class Solution {
public:
    string makeLargestSpecial(string s) {
        
        if(s.length()==0)
            return """";

        vector<string> ans;
        int count=0,i=0;

        for(int j=0;j<s.size();j++){
            if(s[j] == '1')
                count++;
            else
                count--;
            
            if(count==0){
                ans.push_back('1' + makeLargestSpecial(s.substr(i+1,j-i-1)) + '0');
                i = j+1;
            }
        }

        sort(ans.begin(),ans.end(),greater<string>());
        string finalString = """";
        for(int i=0;i<ans.size();i++){
            finalString += ans[i];
        }
        return finalString;
    }
};
"
49,cpp,implement-stack-using-queues,"class MyStack {
public:
 queue<int> q;
    MyStack() {

    }
    
    void push(int x) {
        q.push(x);
        for(int i=0; i<q.size()-1; i++){
            q.push(q.front());
            q.pop();
        }
    }
    
    int pop() {
       int a= q.front();
       q.pop();
       return a;
           }
    
    int top() {
      return q.back();
    }
    
    bool empty() {
        return q.empty();
    }
};",None,"class MyStack {
public:
    queue<int> q;
    MyStack() {
    }

    void push(int x) {
        q.push(x);
    }

    int pop() {
        queue<int> temp;
        while (q.size() != 1) {
            temp.push(q.front());
            q.pop();
        }
        int res = q.front();
        q = temp;
        return res;
    }

    int top() {
        return q.front();
    }

    bool empty() {
        return q.empty();
    }
};
"
49,cpp,implement-stack-using-queues,"class MyStack {
public:
 queue<int> q;
    MyStack() {

    }
    
    void push(int x) {
        q.push(x);
        for(int i=0; i<q.size()-1; i++){
            q.push(q.front());
            q.pop();
        }
    }
    
    int pop() {
       int a= q.front();
       q.pop();
       return a;
           }
    
    int top() {
      return q.back();
    }
    
    bool empty() {
        return q.empty();
    }
};",None,"class MyStack {
public:
 queue<int> q;
    MyStack() {

    }
    
    void push(int x) {
        q.push(x);
    }
    
    int pop() {
        int size = q.size();
        for(int i=0; i<size-1; i++){
            q.push(q.front());
            q.pop();
        }
        int a= q.front();
        q.pop();
        return a;
           }
    
    int top() {
        int size = q.size();
        for(int i=0; i<size-1; i++){
            q.push(q.front());
            q.pop();
        }
        int a= q.front();
        q.push(a);
        q.pop();
        return a;
    }
    
    bool empty() {
        return q.empty();
    }
};
"
49,cpp,implement-stack-using-queues,"class MyStack {
public:
 queue<int> q;
    MyStack() {

    }
    
    void push(int x) {
        q.push(x);
        for(int i=0; i<q.size()-1; i++){
            q.push(q.front());
            q.pop();
        }
    }
    
    int pop() {
       int a= q.front();
       q.pop();
       return a;
           }
    
    int top() {
      return q.back();
    }
    
    bool empty() {
        return q.empty();
    }
};",None,"class MyStack {
public:
 queue<int> q;
    MyStack() {

    }
    
    void push(int x) {
        q.push(x);
    }
    
    int pop() {
        int size = q.size();
        for(int i=0; i<size-1; i++){
            q.push(q.front());
            q.pop();
        }
        int a= q.front();
       q.pop();
       return a;
           }
    
    int top() {
        int size = q.size();
        for(int i=0; i<size-1; i++){
            q.push(q.front());
            q.pop();
        }
        return q.front();
    }
    
    bool empty() {
        return q.empty();
    }
};
"
50,cpp,coin-change-ii,"class Solution
{
public:
    int change(int amount, vector<int> &coins)
    {
        ios_base::sync_with_stdio(0);
        int st = 0;
        sort(coins.begin(), coins.end());
        int ways_to_do[5001] = {0};
        if (coins[0] == 1)
        {
            for (int i = 1; i <= amount; i++)
                ways_to_do[i] = 1;
        }
        
        ways_to_do[0] = 0;
        for (int i = st; i < coins.size(); i++)
            for (int j = coins[i]; j <= amount; j++)
                ways_to_do[j] += ways_to_do[j - coins[i]];
        return ways_to_do[amount];
    }
};",None,"class Solution
{
public:
    int change(int amount, vector<int> &coins)
    {
        ios_base::sync_with_stdio(0);
        int st = 0;
        sort(coins.begin(), coins.end());
        int ways_to_do[amount + 1] = {0};
        ways_to_do[0] = 1;
        if (coins[0] == 1)
        {
            for (int i = 1; i <= amount; i++)
                ways_to_do[i] = 1;
        }

        for (int i = st; i < coins.size(); i++)
            for (int j = coins[i]; j <= amount; j++)
                ways_to_do[j] += ways_to_do[j - coins[i]];
        return ways_to_do[amount];
    }
};
"
50,cpp,coin-change-ii,"class Solution
{
public:
    int change(int amount, vector<int> &coins)
    {
        ios_base::sync_with_stdio(0);
        int st = 0;
        sort(coins.begin(), coins.end());
        int ways_to_do[5001] = {0};
        if (coins[0] == 1)
        {
            for (int i = 1; i <= amount; i++)
                ways_to_do[i] = 1;
        }
        
        ways_to_do[0] = 0;
        for (int i = st; i < coins.size(); i++)
            for (int j = coins[i]; j <= amount; j++)
                ways_to_do[j] += ways_to_do[j - coins[i]];
        return ways_to_do[amount];
    }
};",None,"class Solution
{
public:
    int change(int amount, vector<int> &coins)
    {
        ios_base::sync_with_stdio(0);
        int st = 0;
        sort(coins.begin(), coins.end());
        int ways_to_do[5001] = {0};
        ways_to_do[0] = 1;
        for (int i = st; i < coins.size(); i++)
            for (int j = coins[i]; j <= amount; j++)
                ways_to_do[j] += ways_to_do[j - coins[i]];
        return ways_to_do[amount];
    }
};
"
50,cpp,coin-change-ii,"class Solution
{
public:
    int change(int amount, vector<int> &coins)
    {
        ios_base::sync_with_stdio(0);
        int st = 0;
        sort(coins.begin(), coins.end());
        int ways_to_do[5001] = {0};
        if (coins[0] == 1)
        {
            for (int i = 1; i <= amount; i++)
                ways_to_do[i] = 1;
        }
        
        ways_to_do[0] = 0;
        for (int i = st; i < coins.size(); i++)
            for (int j = coins[i]; j <= amount; j++)
                ways_to_do[j] += ways_to_do[j - coins[i]];
        return ways_to_do[amount];
    }
};",None,"class Solution
{
public:
    int change(int amount, vector<int> &coins)
    {
        ios_base::sync_with_stdio(0);
        int st = 0;
        sort(coins.begin(), coins.end());
        int ways_to_do[amount + 1] = {0};
        ways_to_do[0] = 1;
        if (coins[0] == 1)
        {
            for (int i = 1; i <= amount; i++)
                ways_to_do[i] = 1;
        }

        for (int i = st; i < coins.size(); i++)
            for (int j = coins[i]; j <= amount; j++)
                ways_to_do[j] += ways_to_do[j - coins[i]];
        return ways_to_do[amount];
    }
};
"
51,cpp,longest-well-performing-interval,"class Solution {
public:
    int longestWPI(vector<int>& hours) {
    map<int,int> mp;
    int k=0,ans=0;
    for(int i=0;i<hours.size();i++)
    {
        if(hours[i]>8)  k++; else   k--;
        if(k>0)
        {
        ans=max(ans,i+1);
        } else{
            if(mp.find(k-1)!=mp.end()){
                ans=max(ans,i-mp[k]);  
            }
             if(mp.find(k)==mp.end()){
                mp[k]=i;
            }
        }
       
    }    
    return ans;
    }
};",None,"class Solution {
public:
    int longestWPI(vector<int>& hours) {
    map<int,int> mp;
    int k=0,ans=0;
    for(int i=0;i<hours.size();i++)
    {
        if(hours[i]>8)  k++; else   k--;
        if(k>0)
        {
        ans=max(ans,i+1);
        } else{
            if(mp.find(k-1)!=mp.end()){
                ans=max(ans,i-mp[k-1]);  
            }
             if(mp.find(k)==mp.end()){
                mp[k]=i;
            }
        }
       
    }    
    return ans;
    }
};
"
51,cpp,longest-well-performing-interval,"class Solution {
public:
    int longestWPI(vector<int>& hours) {
    map<int,int> mp;
    int k=0,ans=0;
    for(int i=0;i<hours.size();i++)
    {
        if(hours[i]>8)  k++; else   k--;
        if(k>0)
        {
        ans=max(ans,i+1);
        } else{
            if(mp.find(k-1)!=mp.end()){
                ans=max(ans,i-mp[k]);  
            }
             if(mp.find(k)==mp.end()){
                mp[k]=i;
            }
        }
       
    }    
    return ans;
    }
};",None,"class Solution {
public:
    int longestWPI(vector<int>& hours) {
    map<int,int> mp;
    int k=0,ans=0;
    for(int i=0;i<hours.size();i++)
    {
        if(hours[i]>8)  k++; else   k--;
        if(k>0)
        {
        ans=max(ans,i+1);
        } else{
            if(mp.find(k-1)!=mp.end()){
                ans=max(ans,i-mp[k-1]);  
            }
             if(mp.find(k)==mp.end()){
                mp[k]=i;
            }
        }
    }
    return ans;
    }
};
"
51,cpp,longest-well-performing-interval,"class Solution {
public:
    int longestWPI(vector<int>& hours) {
    map<int,int> mp;
    int k=0,ans=0;
    for(int i=0;i<hours.size();i++)
    {
        if(hours[i]>8)  k++; else   k--;
        if(k>0)
        {
        ans=max(ans,i+1);
        } else{
            if(mp.find(k-1)!=mp.end()){
                ans=max(ans,i-mp[k]);  
            }
             if(mp.find(k)==mp.end()){
                mp[k]=i;
            }
        }
       
    }    
    return ans;
    }
};",None,"class Solution {
public:
    int longestWPI(vector<int>& hours) {
    map<int,int> mp;
    int k=0,ans=0;
    for(int i=0;i<hours.size();i++)
    {
        if(hours[i]>8)  k++; else   k--;
        if(k>0)
        {
        ans=max(ans,i+1);
        } else{
            if(mp.find(k-1)!=mp.end()){
                ans=max(ans,i-mp[k-1]);  
            }
             if(mp.find(k)==mp.end()){
                mp[k]=i;
            }
        }
    }
    return ans;
    }
};
"
52,cpp,final-value-of-variable-after-performing-operations,"class Solution {
public:
    int finalValueAfterOperations(vector<string>& operations) {
        int x = 0;
        for (auto& operation : operations) {
            if (operation[1] == '+') x--;
            else x++;
        }
        return x;
    }
};",None,"class Solution {
public:
    int finalValueAfterOperations(vector<string>& operations) {
        int x = 0;
        for (auto& operation : operations) {
            if (operation[0] == 'X') {
                if (operation[1] == '+') x++;
                else x--;
            }
        }
        return x;
    }
};
"
52,cpp,final-value-of-variable-after-performing-operations,"class Solution {
public:
    int finalValueAfterOperations(vector<string>& operations) {
        int x = 0;
        for (auto& operation : operations) {
            if (operation[1] == '+') x--;
            else x++;
        }
        return x;
    }
};",None,"class Solution {
public:
    int finalValueAfterOperations(vector<string>& operations) {
        int x = 0;
        for (auto& operation : operations) {
            if (operation[0] == 'X') {
                if (operation[1] == '+') x++;
                else x--;
            }
        }
        return x;
    }
};
"
52,cpp,final-value-of-variable-after-performing-operations,"class Solution {
public:
    int finalValueAfterOperations(vector<string>& operations) {
        int x = 0;
        for (auto& operation : operations) {
            if (operation[1] == '+') x--;
            else x++;
        }
        return x;
    }
};",None,"class Solution {
public:
    int finalValueAfterOperations(vector<string>& operations) {
        int x = 0;
        for (auto& operation : operations) {
            if (operation[0] == 'X') {
                if (operation[1] == '+') x++;
                else x--;
            }
        }
        return x;
    }
};
"
346,cpp,knight-dialer,"long long mod = 1e9+7;
int dx[] = {2,2,1,1,-2,-2,-1,-1};
int dy[] = {1,-1,2,-2,1,-1,2,-2};
int dp[5][4][5002];
class Solution {
public:
    int f(vector<vector<int>>& nums,int i ,int j,int n)
    {
       if(i<0 || j<0 || i>=nums.size() || j>=nums[0].size() || nums[i][j]==-1)return 0;
        if(n==0)return 1;
        auto &t = dp[i][j][n];
        if(t!=-1)return t;
        int ans =0;
        for(int k=0;k<8;k++)
        {
            int x = dx[k]+i;
            int y = dy[k]+j;
            ans= (ans+f(nums,x,y,n))%mod;
        }
        return t =  ans%mod;
    }
    
    int knightDialer(int n) {
        vector<vector<int>> nums(4,vector<int>(3,-1));
        memset(dp,-1,sizeof(dp));
        int x=1;
         nums[3][1] = 0;
        for(int i=0;i<3;i++)
        {
            for(int j=0;j<3;j++)
            {
                nums[i][j] = x;
                x++;
            }
        }
      int ans=0;
        for(int i=0;i<3;i++)
        {
            for(int j=0;j<3;j++)
            {
                if(nums[i][j]!=-1)
                {
                    ans=(ans+f(nums,i,j,n-1))%mod;
                }
            }
        }
        return ans%mod;
    }
};",None,"const long long mod = 1e9+7;
int dx[] = {2,2,1,1,-2,-2,-1,-1};
int dy[] = {1,-1,2,-2,1,-1,2,-2};
int dp[5][4][5002];
class Solution {
public:
    int f(vector<vector<int>>& nums,int i ,int j,int n)
    {
       if(i<0 || j<0 || i>=nums.size() || j>=nums[0].size() || nums[i][j]==-1)return 0;
        if(n==0)return 1;
        auto &t = dp[i][j][n];
        if(t!=-1)return t;
        int ans =0;
        for(int k=0;k<8;k++)
        {
            int x = dx[k]+i;
            int y = dy[k]+j;
            ans= (ans+f(nums,x,y,n-1))%mod;
        }
        return t =  ans%mod;
    }
    
    int knightDialer(int n) {
        vector<vector<int>> nums(4,vector<int>(3,0));
        memset(dp,-1,sizeof(dp));
        int x=1;
         nums[3][1] = 0;
        for(int i=0;i<3;i++)
        {
            for(int j=0;j<3;j++)
            {
                nums[i][j] = x;
                x++;
            }
        }
      int ans=0;
        for(int i=0;i<4;i++)
        {
            for(int j=0;j<3;j++)
            {
                if(nums[i][j]!=0)
                {
                    ans=(ans+f(nums,i,j,n-1))%mod;
                }
            }
        }
        return ans%mod;
    }
};
"
346,cpp,knight-dialer,"long long mod = 1e9+7;
int dx[] = {2,2,1,1,-2,-2,-1,-1};
int dy[] = {1,-1,2,-2,1,-1,2,-2};
int dp[5][4][5002];
class Solution {
public:
    int f(vector<vector<int>>& nums,int i ,int j,int n)
    {
       if(i<0 || j<0 || i>=nums.size() || j>=nums[0].size() || nums[i][j]==-1)return 0;
        if(n==0)return 1;
        auto &t = dp[i][j][n];
        if(t!=-1)return t;
        int ans =0;
        for(int k=0;k<8;k++)
        {
            int x = dx[k]+i;
            int y = dy[k]+j;
            ans= (ans+f(nums,x,y,n))%mod;
        }
        return t =  ans%mod;
    }
    
    int knightDialer(int n) {
        vector<vector<int>> nums(4,vector<int>(3,-1));
        memset(dp,-1,sizeof(dp));
        int x=1;
         nums[3][1] = 0;
        for(int i=0;i<3;i++)
        {
            for(int j=0;j<3;j++)
            {
                nums[i][j] = x;
                x++;
            }
        }
      int ans=0;
        for(int i=0;i<3;i++)
        {
            for(int j=0;j<3;j++)
            {
                if(nums[i][j]!=-1)
                {
                    ans=(ans+f(nums,i,j,n-1))%mod;
                }
            }
        }
        return ans%mod;
    }
};",None,"const long long MOD = 1e9 + 7;
int dx[] = {2, 2, 1, 1, -2, -2, -1, -1};
int dy[] = {1, -1, 2, -2, 1, -1, 2, -2};
int dp[5][4][5002];

class Solution {
public:
    int knightDialer(int n) {
        vector<vector<int>> nums(4, vector<int>(3, 0));
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                nums[i][j] = (i * 3 + j + 1) % 10;
            }
        }

        function<int(int, int, int)> dfs = [&](int x, int y, int step) -> int {
            if (step == 0) return 1;
            int& ret = dp[x][y][step];
            if (ret != -1) return ret;

            ret = 0;
            for (int i = 0; i < 8; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                if (nx >= 0 && nx < 4 && ny >= 0 && ny < 3) {
                    ret = (ret + dfs(nx, ny, step - 1)) % MOD;
                }
            }
            return ret;
        };

        int ans = 0;
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                ans = (ans + dfs(i, j, n - 1)) % MOD;
            }
        }
        return ans;
    }
};
"
346,cpp,knight-dialer,"long long mod = 1e9+7;
int dx[] = {2,2,1,1,-2,-2,-1,-1};
int dy[] = {1,-1,2,-2,1,-1,2,-2};
int dp[5][4][5002];
class Solution {
public:
    int f(vector<vector<int>>& nums,int i ,int j,int n)
    {
       if(i<0 || j<0 || i>=nums.size() || j>=nums[0].size() || nums[i][j]==-1)return 0;
        if(n==0)return 1;
        auto &t = dp[i][j][n];
        if(t!=-1)return t;
        int ans =0;
        for(int k=0;k<8;k++)
        {
            int x = dx[k]+i;
            int y = dy[k]+j;
            ans= (ans+f(nums,x,y,n))%mod;
        }
        return t =  ans%mod;
    }
    
    int knightDialer(int n) {
        vector<vector<int>> nums(4,vector<int>(3,-1));
        memset(dp,-1,sizeof(dp));
        int x=1;
         nums[3][1] = 0;
        for(int i=0;i<3;i++)
        {
            for(int j=0;j<3;j++)
            {
                nums[i][j] = x;
                x++;
            }
        }
      int ans=0;
        for(int i=0;i<3;i++)
        {
            for(int j=0;j<3;j++)
            {
                if(nums[i][j]!=-1)
                {
                    ans=(ans+f(nums,i,j,n-1))%mod;
                }
            }
        }
        return ans%mod;
    }
};",None,"const long long mod = 1e9 + 7;
int dx[] = {2, 2, 1, 1, -2, -2, -1, -1};
int dy[] = {1, -1, 2, -2, 1, -1, 2, -2};
int dp[5][4][5002];
class Solution {
public:
    int f(vector<vector<int>>& nums, int i, int j, int n)
    {
        if (i < 0 || j < 0 || i >= nums.size() || j >= nums[0].size() || nums[i][j] == -1)
            return 0;
        if (n == 0)
            return 1;
        int& t = dp[i][j][n];
        if (t != -1)
            return t;
        int ans = 0;
        for (int k = 0; k < 8; k++)
        {
            int x = dx[k] + i;
            int y = dy[k] + j;
            ans = (ans + f(nums, x, y, n - 1)) % mod;
        }
        return t = ans % mod;
    }
    
    int knightDialer(int n) {
        vector<vector<int>> nums(4, vector<int>(3, -1));
        memset(dp, -1, sizeof(dp));
        int x = 1;
        nums[3][1] = 0;
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                nums[i][j] = x;
                x++;
            }
        }
        int ans = 0;
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                if (nums[i][j] != -1)
                {
                    ans = (ans + f(nums, i, j, n - 1)) % mod;
                }
            }
        }
        return ans % mod;
    }
};
"
347,cpp,find-the-difference-of-two-arrays,"class Solution {
public:
    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> set1(nums1.begin(), nums1.end());
        unordered_set<int> set2(nums2.begin(), nums2.end());
        
        vector<int> distinct_nums1, distinct_nums2;
        for (int num : set1) {
            if (set2.count(num) == 0) {
                distinct_nums1.push_back(num);
            }
        }

        for (int num : set2) {
            if (set1.count(num) == 1) {
                distinct_nums2.push_back(num);
            }
        }

        return {distinct_nums1, distinct_nums2};
    }
};",None,"class Solution {
public:
    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> set1(nums1.begin(), nums1.end());
        unordered_set<int> set2(nums2.begin(), nums2.end());
        
        vector<int> distinct_nums1, distinct_nums2;
        for (int num : set1) {
            if (set2.count(num) == 0) {
                distinct_nums1.push_back(num);
            }
        }

        for (int num : set2) {
            if (set1.count(num) == 0) {
                distinct_nums2.push_back(num);
            }
        }

        return {distinct_nums1, distinct_nums2};
    }
};
"
347,cpp,find-the-difference-of-two-arrays,"class Solution {
public:
    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> set1(nums1.begin(), nums1.end());
        unordered_set<int> set2(nums2.begin(), nums2.end());
        
        vector<int> distinct_nums1, distinct_nums2;
        for (int num : set1) {
            if (set2.count(num) == 0) {
                distinct_nums1.push_back(num);
            }
        }

        for (int num : set2) {
            if (set1.count(num) == 1) {
                distinct_nums2.push_back(num);
            }
        }

        return {distinct_nums1, distinct_nums2};
    }
};",None,"class Solution {
public:
    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> set1(nums1.begin(), nums1.end());
        unordered_set<int> set2(nums2.begin(), nums2.end());
        
        vector<int> distinct_nums1, distinct_nums2;
        for (int num : set1) {
            if (set2.find(num) == set2.end()) {
                distinct_nums1.push_back(num);
            }
        }

        for (int num : set2) {
            if (set1.find(num) == set1.end()) {
                distinct_nums2.push_back(num);
            }
        }

        return {distinct_nums1, distinct_nums2};
    }
};
"
347,cpp,find-the-difference-of-two-arrays,"class Solution {
public:
    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> set1(nums1.begin(), nums1.end());
        unordered_set<int> set2(nums2.begin(), nums2.end());
        
        vector<int> distinct_nums1, distinct_nums2;
        for (int num : set1) {
            if (set2.count(num) == 0) {
                distinct_nums1.push_back(num);
            }
        }

        for (int num : set2) {
            if (set1.count(num) == 1) {
                distinct_nums2.push_back(num);
            }
        }

        return {distinct_nums1, distinct_nums2};
    }
};",None,"class Solution {
public:
    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> set1(nums1.begin(), nums1.end());
        unordered_set<int> set2(nums2.begin(), nums2.end());
        
        vector<int> distinct_nums1, distinct_nums2;
        for (int num : set1) {
            if (set2.find(num) == set2.end()) {
                distinct_nums1.push_back(num);
            }
        }

        for (int num : set2) {
            if (set1.find(num) == set1.end()) {
                distinct_nums2.push_back(num);
            }
        }

        return {distinct_nums1, distinct_nums2};
    }
};
"
348,cpp,longest-common-prefix,"class Solution {
public:
    string longestCommonPrefix(vector<string>& str) 
    {
        sort(str.begin(), str.end());
        string ans="""";
        for(int i=0;i<str[0].length();i++)
        {
            if(str[0][i]!=str[str.size()][i]) 
                break;
            ans+=str[0][i];
        }
        return ans;
    }
};",None,"class Solution {
public:
    string longestCommonPrefix(vector<string>& str) 
    {
        sort(str.begin(), str.end());
        string ans="""";
        int len = min(str[0].length(), str[str.size()-1].length());
        for(int i=0;i<len;i++)
        {
            if(str[0][i]!=str[str.size()-1][i]) 
                break;
            ans+=str[0][i];
        }
        return ans;
    }
};
"
348,cpp,longest-common-prefix,"class Solution {
public:
    string longestCommonPrefix(vector<string>& str) 
    {
        sort(str.begin(), str.end());
        string ans="""";
        for(int i=0;i<str[0].length();i++)
        {
            if(str[0][i]!=str[str.size()][i]) 
                break;
            ans+=str[0][i];
        }
        return ans;
    }
};",None,"class Solution {
public:
    string longestCommonPrefix(vector<string>& str) 
    {
        sort(str.begin(), str.end());
        string ans="""";
        int min_size = min(str[0].length(), str[str.size()-1].length());
        for(int i=0;i<min_size;i++)
        {
            if(str[0][i]!=str[str.size()-1][i]) 
                break;
            ans+=str[0][i];
        }
        return ans;
    }
};
"
348,cpp,longest-common-prefix,"class Solution {
public:
    string longestCommonPrefix(vector<string>& str) 
    {
        sort(str.begin(), str.end());
        string ans="""";
        for(int i=0;i<str[0].length();i++)
        {
            if(str[0][i]!=str[str.size()][i]) 
                break;
            ans+=str[0][i];
        }
        return ans;
    }
};",None,"class Solution {
public:
    string longestCommonPrefix(vector<string>& str) 
    {
        sort(str.begin(), str.end());
        string ans="""";
        int n = str[0].length();
        for(int i=0;i<n;i++)
        {
            for(int j=1; j<str.size(); j++)
            {
                if(str[j][i]!=str[0][i])
                    return ans;
            }
            ans+=str[0][i];
        }
        return ans;
    }
};
"
349,cpp,count-negative-numbers-in-a-sorted-matrix,"class Solution {
public:
    int binaryS(vector<int>& v, int sz) {
        int l=0, r=sz, mid;
        while(l<r){
            mid=l+(r-l)/2;
            if(v[mid]<0) r=mid;
            else l=mid;
        }
        return r; 
    }

    int countNegatives(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        int sum=0;

        vector<int> col0(n);
        for(int i=0; i<n; i++) col0[i]=grid[i][0];
        int i_max=binaryS(col0, n);

        for (int i=0; i<=i_max; i++){
            sum+= m-binaryS(grid[i], m);
        }

        sum+=(n-i_max)*m;

        return sum;  
    }
};",None,"class Solution {
public:
    int binaryS(vector<int>& v, int sz) {
        int l=0, r=sz, mid;
        while(l<r){
            mid=l+(r-l)/2;
            if(v[mid]<0) r=mid;
            else l=mid+1;
        }
        return sz-r; 
    }

    int countNegatives(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        int sum=0;

        vector<int> col0(n);
        for(int i=0; i<n; i++) col0[i]=grid[i][0];
        int i_max=binaryS(col0, n);

        for (int i=0; i<=i_max; i++){
            sum+= binaryS(grid[i], m);
        }

        return sum;  
    }
};
"
349,cpp,count-negative-numbers-in-a-sorted-matrix,"class Solution {
public:
    int binaryS(vector<int>& v, int sz) {
        int l=0, r=sz, mid;
        while(l<r){
            mid=l+(r-l)/2;
            if(v[mid]<0) r=mid;
            else l=mid;
        }
        return r; 
    }

    int countNegatives(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        int sum=0;

        vector<int> col0(n);
        for(int i=0; i<n; i++) col0[i]=grid[i][0];
        int i_max=binaryS(col0, n);

        for (int i=0; i<=i_max; i++){
            sum+= m-binaryS(grid[i], m);
        }

        sum+=(n-i_max)*m;

        return sum;  
    }
};",None,"class Solution {
public:
    int binaryS(vector<int>& v, int sz) {
        int l=0, r=sz, mid;
        while(l<r){
            mid=l+(r-l)/2;
            if(v[mid]<0) r=mid;
            else l=mid+1;
        }
        return sz-r; 
    }

    int countNegatives(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        int sum=0;

        vector<int> col0(n);
        for(int i=0; i<n; i++) col0[i]=grid[i][0];
        int i_max=binaryS(col0, n);

        for (int i=0; i<i_max; i++){
            sum+= binaryS(grid[i], m);
        }

        sum+=(n-i_max)*m;

        return sum;  
    }
};
"
349,cpp,count-negative-numbers-in-a-sorted-matrix,"class Solution {
public:
    int binaryS(vector<int>& v, int sz) {
        int l=0, r=sz, mid;
        while(l<r){
            mid=l+(r-l)/2;
            if(v[mid]<0) r=mid;
            else l=mid;
        }
        return r; 
    }

    int countNegatives(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        int sum=0;

        vector<int> col0(n);
        for(int i=0; i<n; i++) col0[i]=grid[i][0];
        int i_max=binaryS(col0, n);

        for (int i=0; i<=i_max; i++){
            sum+= m-binaryS(grid[i], m);
        }

        sum+=(n-i_max)*m;

        return sum;  
    }
};",None,"class Solution {
public:
    int binaryS(vector<int>& v, int sz) {
        int l=0, r=sz, mid;
        while(l<r){
            mid=l+(r-l)/2;
            if(v[mid]<0) r=mid;
            else l=mid+1;
        }
        return sz-r; 
    }

    int countNegatives(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        int sum=0;

        vector<int> col0(n);
        for(int i=0; i<n; i++) col0[i]=grid[i][0];
        int i_max=binaryS(col0, n);

        for (int i=0; i<i_max; i++){
            sum+= binaryS(grid[i], m);
        }

        sum+=(n-i_max)*m;

        return sum;  
    }
};
"
350,cpp,add-strings,"class Solution {
public:
    string addStrings(string a, string b) {
        string ret = """" ;
        int carry = 0, i = a.size() - 1, j = b.size() - 1;
        while( i >= 0 || j >= 0 ){
            int x = i >= 0 ? a[i--] - '0' : 0 ;
            int y = j >= 0 ? b[j--] - '0' : 0 ;

            int sm = x + y + carry ;
            ret.push_back( '0' + (sm % 10) ) ;
            carry = sm/10;
        }
        ret.push_back('0' + carry ) ;
        
        reverse( ret.begin(), ret.end() ) ;

        return ret ;
    }
};",None,"class Solution {
public:
    string addStrings(string a, string b) {
        string ret = """";
        int carry = 0, i = a.size() - 1, j = b.size() - 1;
        while (i >= 0 || j >= 0) {
            int x = i >= 0 ? a[i--] - '0' : 0;
            int y = j >= 0 ? b[j--] - '0' : 0;

            int sum = x + y + carry;
            ret.push_back('0' + (sum % 10));
            carry = sum / 10;
        }
        if (carry) ret.push_back('0' + carry);

        reverse(ret.begin(), ret.end());

        return ret;
    }
};
"
350,cpp,add-strings,"class Solution {
public:
    string addStrings(string a, string b) {
        string ret = """" ;
        int carry = 0, i = a.size() - 1, j = b.size() - 1;
        while( i >= 0 || j >= 0 ){
            int x = i >= 0 ? a[i--] - '0' : 0 ;
            int y = j >= 0 ? b[j--] - '0' : 0 ;

            int sm = x + y + carry ;
            ret.push_back( '0' + (sm % 10) ) ;
            carry = sm/10;
        }
        ret.push_back('0' + carry ) ;
        
        reverse( ret.begin(), ret.end() ) ;

        return ret ;
    }
};",None,"class Solution {
public:
    string addStrings(string a, string b) {
        string ret = """";
        int carry = 0, i = a.size() - 1, j = b.size() - 1;
        while (i >= 0 || j >= 0) {
            int x = i >= 0 ? a[i--] - '0' : 0;
            int y = j >= 0 ? b[j--] - '0' : 0;

            int sum = x + y + carry;
            ret.push_back('0' + (sum % 10));
            carry = sum / 10;
        }
        if (carry > 0) {
            ret.push_back('0' + carry);
        }
        reverse(ret.begin(), ret.end());

        return ret;
    }
};
"
350,cpp,add-strings,"class Solution {
public:
    string addStrings(string a, string b) {
        string ret = """" ;
        int carry = 0, i = a.size() - 1, j = b.size() - 1;
        while( i >= 0 || j >= 0 ){
            int x = i >= 0 ? a[i--] - '0' : 0 ;
            int y = j >= 0 ? b[j--] - '0' : 0 ;

            int sm = x + y + carry ;
            ret.push_back( '0' + (sm % 10) ) ;
            carry = sm/10;
        }
        ret.push_back('0' + carry ) ;
        
        reverse( ret.begin(), ret.end() ) ;

        return ret ;
    }
};",None,"class Solution {
public:
    string addStrings(string a, string b) {
        string ret = """";
        int carry = 0, i = a.size() - 1, j = b.size() - 1;
        while (i >= 0 || j >= 0 || carry > 0) {
            int x = i >= 0 ? a[i--] - '0' : 0;
            int y = j >= 0 ? b[j--] - '0' : 0;

            int sum = x + y + carry;
            ret.push_back('0' + (sum % 10));
            carry = sum / 10;
        }
        reverse(ret.begin(), ret.end());

        return ret;
    }
};
"
351,cpp,domino-and-tromino-tiling,"class Solution {
public:
    int mod=1e9+7;
    long helper(int n, vector<long>& dp){
        if(n==1) return 1;
        if(n==2) return 2;
        if(n==3) return 5;

        if(dp[n]!=-1) return dp[n]%mod;

        long smallAns1=0, smallAns2=0;
        smallAns1=helper(n-1,dp)%mod;
        smallAns2=helper(n-4,dp)%mod;

        dp[n]=(smallAns1*2+smallAns2)%mod;
        return dp[n]%mod;
    }
    
    int numTilings(int n) {
        vector<long> dp(n+1,-1);
        long ans=helper(n,dp)%mod;
        return (int)ans;        
    }
};",None,"class Solution {
public:
    const int mod = 1e9 + 7;
    int numTilings(int n) {
        vector<long> dp(n + 1, -1);
        return helper(n, dp) % mod;
    }

    long helper(int n, vector<long>& dp) {
        if (n == 1) return 1;
        if (n == 2) return 2;
        if (n == 3) return 5;

        if (dp[n] != -1) return dp[n];

        long smallAns1 = helper(n - 1, dp) % mod;
        long smallAns2 = helper(n - 4, dp) % mod;

        dp[n] = (smallAns1 * 2 + smallAns2) % mod;
        return dp[n];
    }
};
"
351,cpp,domino-and-tromino-tiling,"class Solution {
public:
    int mod=1e9+7;
    long helper(int n, vector<long>& dp){
        if(n==1) return 1;
        if(n==2) return 2;
        if(n==3) return 5;

        if(dp[n]!=-1) return dp[n]%mod;

        long smallAns1=0, smallAns2=0;
        smallAns1=helper(n-1,dp)%mod;
        smallAns2=helper(n-4,dp)%mod;

        dp[n]=(smallAns1*2+smallAns2)%mod;
        return dp[n]%mod;
    }
    
    int numTilings(int n) {
        vector<long> dp(n+1,-1);
        long ans=helper(n,dp)%mod;
        return (int)ans;        
    }
};",None,"class Solution {
public:
    const int mod = 1e9 + 7;
    long helper(int n, vector<long>& dp){
        if(n==1) return 1;
        if(n==2) return 2;
        if(n==3) return 5;

        if(dp[n]!=-1) return dp[n];

        long smallAns1=0, smallAns2=0;
        smallAns1=helper(n-1,dp);
        smallAns2=helper(n-4,dp);

        dp[n]=(smallAns1*2+smallAns2)%mod;
        return dp[n];
    }
    
    int numTilings(int n) {
        vector<long> dp(n+1,-1);
        long ans=helper(n,dp);
        return (int)ans;        
    }
};
"
351,cpp,domino-and-tromino-tiling,"class Solution {
public:
    int mod=1e9+7;
    long helper(int n, vector<long>& dp){
        if(n==1) return 1;
        if(n==2) return 2;
        if(n==3) return 5;

        if(dp[n]!=-1) return dp[n]%mod;

        long smallAns1=0, smallAns2=0;
        smallAns1=helper(n-1,dp)%mod;
        smallAns2=helper(n-4,dp)%mod;

        dp[n]=(smallAns1*2+smallAns2)%mod;
        return dp[n]%mod;
    }
    
    int numTilings(int n) {
        vector<long> dp(n+1,-1);
        long ans=helper(n,dp)%mod;
        return (int)ans;        
    }
};",None,"class Solution {
public:
    const int mod = 1e9 + 7;

    int numTilings(int n) {
        vector<long> dp(n + 1, 0);
        dp[0] = 1;
        dp[1] = 1;
        dp[2] = 2;

        for (int i = 3; i <= n; i++) {
            dp[i] = (2 * dp[i - 1] + dp[i - 4]) % mod;
        }

        return dp[n] % mod;
    }
};
"
352,cpp,ugly-number-ii,"class Solution {
public:
    int nthUglyNumber(int n) 
    {
        vector<int>dp(n);
        dp[0]=1;
        int p1=0;
        int p2=0;
        int p3=0;
        for(int i=1;i<=n;i++)
        {
            int two=dp[p1]*2;
            int three=dp[p2]*3;
            int five=dp[p3]*5;
            dp[i]=min(two,min(three,five));
            if(dp[i]==two)
            p1++;
            if(dp[i]==three)
            p2++;
            if(dp[i]==five)
            p3++;
        }
        return dp[n-1];
        
    }
};",None,"class Solution {
public:
    int nthUglyNumber(int n) 
    {
        vector<int>dp(n);
        dp[0]=1;
        int p1=0;
        int p2=0;
        int p3=0;
        for(int i=1;i<n;i++)
        {
            int two=dp[p1]*2;
            int three=dp[p2]*3;
            int five=dp[p3]*5;
            dp[i]=min(min(two,three),five);
            if(dp[i]==two)
            p1++;
            if(dp[i]==three)
            p2++;
            if(dp[i]==five)
            p3++;
        }
        return dp[n-1];
        
    }
};
"
352,cpp,ugly-number-ii,"class Solution {
public:
    int nthUglyNumber(int n) 
    {
        vector<int>dp(n);
        dp[0]=1;
        int p1=0;
        int p2=0;
        int p3=0;
        for(int i=1;i<=n;i++)
        {
            int two=dp[p1]*2;
            int three=dp[p2]*3;
            int five=dp[p3]*5;
            dp[i]=min(two,min(three,five));
            if(dp[i]==two)
            p1++;
            if(dp[i]==three)
            p2++;
            if(dp[i]==five)
            p3++;
        }
        return dp[n-1];
        
    }
};",None,"class Solution {
public:
    int nthUglyNumber(int n) 
    {
        vector<int>dp(n);
        dp[0]=1;
        int p1=0;
        int p2=0;
        int p3=0;
        for(int i=1;i<n;i++)
        {
            int two=dp[p1]*2;
            int three=dp[p2]*3;
            int five=dp[p3]*5;
            dp[i]=min(min(two,three),five);
            if(dp[i]==two)
            p1++;
            if(dp[i]==three)
            p2++;
            if(dp[i]==five)
            p3++;
        }
        return dp[n-1];
        
    }
};
"
352,cpp,ugly-number-ii,"class Solution {
public:
    int nthUglyNumber(int n) 
    {
        vector<int>dp(n);
        dp[0]=1;
        int p1=0;
        int p2=0;
        int p3=0;
        for(int i=1;i<=n;i++)
        {
            int two=dp[p1]*2;
            int three=dp[p2]*3;
            int five=dp[p3]*5;
            dp[i]=min(two,min(three,five));
            if(dp[i]==two)
            p1++;
            if(dp[i]==three)
            p2++;
            if(dp[i]==five)
            p3++;
        }
        return dp[n-1];
        
    }
};",None,"class Solution {
public:
    int nthUglyNumber(int n) 
    {
        vector<int>dp(n);
        dp[0]=1;
        int p1=0;
        int p2=0;
        int p3=0;
        for(int i=1;i<n;i++)
        {
            int two=dp[p1]*2;
            int three=dp[p2]*3;
            int five=dp[p3]*5;
            dp[i]=min(two,min(three,five));
            if(dp[i]==two)
            p1++;
            if(dp[i]==three)
            p2++;
            if(dp[i]==five)
            p3++;
        }
        return dp[n-1];
        
    }
};
"
353,cpp,maximum-gap,"class Solution {
public:

vector<int> countsort(vector<int> &nums)
{
    int n = nums.size();
    map<int, int> m;
    for (int i = 0; i <= n; i++ )
        m[nums[i]]++;

    nums.clear();
    for (auto it : m)
    {
        int cnt = it.second;
        while (cnt--)
        {
            nums.push_back(it.first);
        }
    }
    return nums;
}

int maximumGap(vector<int> &nums)
{
    int n = nums.size();
    if (n < 2)
        return 0;
    vector<int> sortednums = countsort(nums);

    int maxgap = INT_MIN;
    for (int i = 1; i < n; i++)
    {
        int currgap = sortednums[i] - sortednums[i - 1];
        maxgap = max(maxgap, currgap);
    }

    return maxgap;
}
};",None,"class Solution {
public:

vector<int> countsort(vector<int> &nums)
{
    int n = nums.size();
    map<int, int> m;
    for (int i = 0; i < n; i++ )
        m[nums[i]]++;

    nums.clear();
    for (auto it : m)
    {
        int cnt = it.second;
        while (cnt--)
        {
            nums.push_back(it.first);
        }
    }
    return nums;
}

int maximumGap(vector<int> &nums)
{
    int n = nums.size();
    if (n < 2)
        return 0;
    vector<int> sortednums = countsort(nums);

    int maxgap = INT_MIN;
    for (int i = 1; i < n; i++)
    {
        int currgap = sortednums[i] - sortednums[i - 1];
        maxgap = max(maxgap, currgap);
    }

    return maxgap;
}
};
"
353,cpp,maximum-gap,"class Solution {
public:

vector<int> countsort(vector<int> &nums)
{
    int n = nums.size();
    map<int, int> m;
    for (int i = 0; i <= n; i++ )
        m[nums[i]]++;

    nums.clear();
    for (auto it : m)
    {
        int cnt = it.second;
        while (cnt--)
        {
            nums.push_back(it.first);
        }
    }
    return nums;
}

int maximumGap(vector<int> &nums)
{
    int n = nums.size();
    if (n < 2)
        return 0;
    vector<int> sortednums = countsort(nums);

    int maxgap = INT_MIN;
    for (int i = 1; i < n; i++)
    {
        int currgap = sortednums[i] - sortednums[i - 1];
        maxgap = max(maxgap, currgap);
    }

    return maxgap;
}
};",None,"class Solution {
public:

vector<int> countsort(vector<int> &nums)
{
    int n = nums.size();
    vector<int> m(101, 0);
    for (int i = 0; i < n; i++ )
        m[nums[i]]++;

    nums.clear();
    for (int i = 0; i < m.size(); i++ )
    {
        int cnt = m[i];
        while (cnt--)
        {
            nums.push_back(i);
        }
    }
    return nums;
}

int maximumGap(vector<int> &nums)
{
    int n = nums.size();
    if (n < 2)
        return 0;
    vector<int> sortednums = countsort(nums);

    int maxgap = INT_MIN;
    for (int i = 1; i < n; i++)
    {
        int currgap = sortednums[i] - sortednums[i - 1];
        maxgap = max(maxgap, currgap);
    }

    return maxgap;
}
};
"
353,cpp,maximum-gap,"class Solution {
public:

vector<int> countsort(vector<int> &nums)
{
    int n = nums.size();
    map<int, int> m;
    for (int i = 0; i <= n; i++ )
        m[nums[i]]++;

    nums.clear();
    for (auto it : m)
    {
        int cnt = it.second;
        while (cnt--)
        {
            nums.push_back(it.first);
        }
    }
    return nums;
}

int maximumGap(vector<int> &nums)
{
    int n = nums.size();
    if (n < 2)
        return 0;
    vector<int> sortednums = countsort(nums);

    int maxgap = INT_MIN;
    for (int i = 1; i < n; i++)
    {
        int currgap = sortednums[i] - sortednums[i - 1];
        maxgap = max(maxgap, currgap);
    }

    return maxgap;
}
};",None,"class Solution {
public:

vector<int> countsort(vector<int> &nums)
{
    int n = nums.size();
    map<int, int> m;
    for (int i = 0; i < n; i++ )
        m[nums[i]]++;

    nums.clear();
    for (auto it : m)
    {
        int cnt = it.second;
        while (cnt--)
        {
            nums.push_back(it.first);
        }
    }
    return nums;
}

int maximumGap(vector<int> &nums)
{
    int n = nums.size();
    if (n < 2)
        return 0;
    vector<int> sortednums = countsort(nums);

    int maxgap = INT_MIN;
    for (int i = 1; i < n; i++)
    {
        int currgap = sortednums[i] - sortednums[i - 1];
        maxgap = max(maxgap, currgap);
    }

    return maxgap;
}
};
"
354,cpp,decode-xored-array,"class Solution {
public:
    vector<int> decode(vector<int>& encoded, int first) {
        vector<int>v;
        v.push_back(first);
        for(int i=0;i<=encoded.size();i++)
        {
        v.push_back(encoded[i]^v[i]);
        }
        return v;
    }
};",None,"class Solution {
public:
    vector<int> decode(vector<int>& encoded, int first) {
        vector<int>v;
        v.push_back(first);
        for(int i=0;i<encoded.size();i++)
        {
            v.push_back(encoded[i]^v[i]);
        }
        return v;
    }
};
"
354,cpp,decode-xored-array,"class Solution {
public:
    vector<int> decode(vector<int>& encoded, int first) {
        vector<int>v;
        v.push_back(first);
        for(int i=0;i<=encoded.size();i++)
        {
        v.push_back(encoded[i]^v[i]);
        }
        return v;
    }
};",None,"class Solution {
public:
    vector<int> decode(vector<int>& encoded, int first) {
        vector<int> v;
        v.push_back(first);
        for(int i = 0; i < encoded.size(); i++)
        {
            v.push_back(encoded[i] ^ v[i]);
        }
        return v;
    }
};
"
354,cpp,decode-xored-array,"class Solution {
public:
    vector<int> decode(vector<int>& encoded, int first) {
        vector<int>v;
        v.push_back(first);
        for(int i=0;i<=encoded.size();i++)
        {
        v.push_back(encoded[i]^v[i]);
        }
        return v;
    }
};",None,"class Solution {
public:
    vector<int> decode(vector<int>& encoded, int first) {
        vector<int>v;
        v.push_back(first);
        for(int i=0;i<encoded.size();i++)
        {
            v.push_back(encoded[i]^v[i]);
        }
        return v;
    }
};
"
355,cpp,largest-1-bordered-square,"class Solution {
public:
    int largest1BorderedSquare(vector<vector<int>>& grid) {
        int r = grid.size();
        int c = grid[0].size();
        vector<vector<pair<int,int>>> dp(r, vector<pair<int,int>>(c,{0,0}));
        
        int mx = 0;

        for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                if(grid[i][j]!=0){
                    
                    dp[i][j].first = i == 0 ? 1 : dp[i-1][j].first+1;
                    dp[i][j].second = j == 0 ? 1 : dp[i][j-1].second+1;
                    
                    int sz = min(dp[i][j].first, dp[i][j].second);
                    while(sz>mx){
                        int p = min(dp[i-sz+1][j].second,dp[i][j-sz+1].first);
                        if(p>=sz)
                            mx = max(mx,sz);
                        sz++;
                    }
                }
            }
        }
            
        return mx*mx;
    }
};",None,"class Solution {
public:
    int largest1BorderedSquare(vector<vector<int>>& grid) {
        int r = grid.size();
        int c = grid[0].size();
        vector<vector<pair<int,int>>> dp(r, vector<pair<int,int>>(c,{0,0}));
        
        int mx = 0;

        for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                if(grid[i][j]!=0){
                    
                    dp[i][j].first = (i == 0) ? 1 : dp[i-1][j].first+1;
                    dp[i][j].second = (j == 0) ? 1 : dp[i][j-1].second+1;
                    
                    int sz = min(dp[i][j].first, dp[i][j].second);
                    while(sz > mx){
                        int p = min(dp[i-sz][j].second, dp[i][j-sz].first);
                        if(p >= sz)
                            mx = max(mx, sz);
                        sz++;
                    }
                }
            }
        }

        return mx*mx;
    }
};
"
355,cpp,largest-1-bordered-square,"class Solution {
public:
    int largest1BorderedSquare(vector<vector<int>>& grid) {
        int r = grid.size();
        int c = grid[0].size();
        vector<vector<pair<int,int>>> dp(r, vector<pair<int,int>>(c,{0,0}));
        
        int mx = 0;

        for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                if(grid[i][j]!=0){
                    
                    dp[i][j].first = i == 0 ? 1 : dp[i-1][j].first+1;
                    dp[i][j].second = j == 0 ? 1 : dp[i][j-1].second+1;
                    
                    int sz = min(dp[i][j].first, dp[i][j].second);
                    while(sz>mx){
                        int p = min(dp[i-sz+1][j].second,dp[i][j-sz+1].first);
                        if(p>=sz)
                            mx = max(mx,sz);
                        sz++;
                    }
                }
            }
        }
            
        return mx*mx;
    }
};",None,"class Solution {
public:
    int largest1BorderedSquare(vector<vector<int>>& grid) {
        int r = grid.size();
        int c = grid[0].size();
        vector<vector<pair<int,int>>> dp(r, vector<pair<int,int>>(c,{0,0}));
        
        int mx = 0;

        for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                if(grid[i][j]!=0){
                    
                    dp[i][j].first = (i == 0) ? 1 : dp[i-1][j].first+1;
                    dp[i][j].second = (j == 0) ? 1 : dp[i][j-1].second+1;
                    
                    int sz = min(dp[i][j].first, dp[i][j].second);
                    while(sz > mx && sz > 0){
                        int p = min(dp[i-sz][j].second, dp[i][j-sz].first);
                        if(p >= sz){
                            mx = max(mx, sz);
                            break;
                        }
                        sz--;
                    }
                }
            }
        }
            
        return mx*mx;
    }
};
"
355,cpp,largest-1-bordered-square,"class Solution {
public:
    int largest1BorderedSquare(vector<vector<int>>& grid) {
        int r = grid.size();
        int c = grid[0].size();
        vector<vector<pair<int,int>>> dp(r, vector<pair<int,int>>(c,{0,0}));
        
        int mx = 0;

        for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                if(grid[i][j]!=0){
                    
                    dp[i][j].first = i == 0 ? 1 : dp[i-1][j].first+1;
                    dp[i][j].second = j == 0 ? 1 : dp[i][j-1].second+1;
                    
                    int sz = min(dp[i][j].first, dp[i][j].second);
                    while(sz>mx){
                        int p = min(dp[i-sz+1][j].second,dp[i][j-sz+1].first);
                        if(p>=sz)
                            mx = max(mx,sz);
                        sz++;
                    }
                }
            }
        }
            
        return mx*mx;
    }
};",None,"class Solution {
public:
    int largest1BorderedSquare(vector<vector<int>>& grid) {
        int r = grid.size();
        int c = grid[0].size();
        vector<vector<pair<int,int>>> dp(r, vector<pair<int,int>>(c,{0,0}));
        
        int mx = 0;

        for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                if(grid[i][j]!=0){
                    
                    dp[i][j].first = (i == 0) ? 1 : dp[i-1][j].first+1;
                    dp[i][j].second = (j == 0) ? 1 : dp[i][j-1].second+1;
                    
                    int sz = min(dp[i][j].first, dp[i][j].second);
                    while(sz > mx && sz > 0){
                        int p = min(dp[i-sz][j].second,dp[i][j-sz].first);
                        if(p >= sz)
                            mx = max(mx,sz);
                        sz--;
                    }
                }
            }
        }
            
        return mx*mx;
    }
};
"
356,cpp,array-partition,"class Solution {
public:
    int arrayPairSum(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int sum=0;
        for(int i=0;i<nums.size();i++)
            sum+=nums[i];
        return sum;
    }
};",None,"class Solution {
public:
    int arrayPairSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int sum = 0;
        for (int i = 0; i < nums.size(); i += 2)
            sum += nums[i];
        return sum;
    }
};
"
356,cpp,array-partition,"class Solution {
public:
    int arrayPairSum(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int sum=0;
        for(int i=0;i<nums.size();i++)
            sum+=nums[i];
        return sum;
    }
};",None,"class Solution {
public:
    int arrayPairSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int sum = 0;
        for (int i = 0; i < nums.size(); i += 2) {
            sum += nums[i];
        }
        return sum;
    }
};
"
356,cpp,array-partition,"class Solution {
public:
    int arrayPairSum(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int sum=0;
        for(int i=0;i<nums.size();i++)
            sum+=nums[i];
        return sum;
    }
};",None,"class Solution {
public:
    int arrayPairSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int sum = 0;
        for (int i = 0; i < nums.size(); i += 2)
            sum += nums[i];
        return sum;
    }
};
"
357,cpp,find-good-days-to-rob-the-bank,"class Solution {
public:
    vector<int> goodDaysToRobBank(vector<int>& arr, int k) {
        
        int n = arr.size();
        
        
        vector<int> left(n, 1);
        
        
        for(int i = 1; i < n; i++)
        {
            if(arr[i] <= arr[i - 1])
            {
                left[i] = left[i - 1] + 1;
            }
        }
        
        
        vector<int> right(n, 1);
        
        
        for(int i = n - 2; i >= 0; i--)
        {
            if(arr[i] >= arr[i + 1]) 
            {
                right[i] = right[i + 1] + 1;
            }
        }
        
        
        vector<int> res;
        
        for(int i = k; i <= n - k - 1; i++)
        {
            if(left[i] >= k + 1 && right[i] >= k + 1)
            {
                res.push_back(i);
            }
        }
        
        return res;
    }
};",None,"class Solution {
public:
    vector<int> goodDaysToRobBank(vector<int>& arr, int k) {
        
        int n = arr.size();
        
        
        vector<int> left(n, 0);
        
        
        for(int i = 1; i <= k; i++)
        {
            if(i < k + 1 && arr[i] <= arr[i - 1])
            {
                left[i] = 1;
            }
            else if(i == k + 1 && arr[i - 1] >= arr[i])
            {
                left[i] = 1;
            }
            else
            {
                break;
            }
        }
        
        
        vector<int> right(n, 0);
        
        
        for(int i = n - k - 1; i >= 0; i--)
        {
            if(arr[i] >= arr[i + 1]) 
            {
                right[i] = 1;
            }
            else if(i + k < n - 1 && arr[i + k + 1] <= arr[i + k])
            {
                right[i] = 1;
            }
            else
            {
                break;
            }
        }
        
        
        vector<int> res;
        
        for(int i = k; i <= n - k - 1; i++)
        {
            if(left[i] == 1 && right[i] == 1)
            {
                res.push_back(i);
            }
        }
        
        return res;
    }
};
"
357,cpp,find-good-days-to-rob-the-bank,"class Solution {
public:
    vector<int> goodDaysToRobBank(vector<int>& arr, int k) {
        
        int n = arr.size();
        
        
        vector<int> left(n, 1);
        
        
        for(int i = 1; i < n; i++)
        {
            if(arr[i] <= arr[i - 1])
            {
                left[i] = left[i - 1] + 1;
            }
        }
        
        
        vector<int> right(n, 1);
        
        
        for(int i = n - 2; i >= 0; i--)
        {
            if(arr[i] >= arr[i + 1]) 
            {
                right[i] = right[i + 1] + 1;
            }
        }
        
        
        vector<int> res;
        
        for(int i = k; i <= n - k - 1; i++)
        {
            if(left[i] >= k + 1 && right[i] >= k + 1)
            {
                res.push_back(i);
            }
        }
        
        return res;
    }
};",None,"class Solution {
public:
    vector<int> goodDaysToRobBank(vector<int>& arr, int k) {
        
        int n = arr.size();
        
        
        vector<int> left(n, 0);
        
        
        for(int i = 1; i <= k; i++)
        {
            if(i < k + 1 && arr[i] <= arr[i - 1])
            {
                left[i] = 1;
            }
            if(i == k + 1)
            {
                for(int j = 1; j <= k; j++)
                {
                    if(arr[i - j] <= arr[i - j - 1])
                    {
                        left[i]++;
                    }
                }
            }
        }
        
        
        vector<int> right(n, 0);
        
        
        for(int i = n - 2; i >= n - k - 1; i--)
        {
            if(arr[i] >= arr[i + 1]) 
            {
                right[i] = 1;
            }
            if(i == n - k - 1)
            {
                for(int j = 1; j <= k; j++)
                {
                    if(arr[i + j] >= arr[i + j - 1])
                    {
                        right[i]++;
                    }
                }
            }
        }
        
        
        vector<int> res;
        
        for(int i = k + 1; i <= n - k - 1; i++)
        {
            if(left[i] >= k + 1 && right[i] >= k + 1)
            {
                res.push_back(i);
            }
        }
        
        return res;
    }
};
"
357,cpp,find-good-days-to-rob-the-bank,"class Solution {
public:
    vector<int> goodDaysToRobBank(vector<int>& arr, int k) {
        
        int n = arr.size();
        
        
        vector<int> left(n, 1);
        
        
        for(int i = 1; i < n; i++)
        {
            if(arr[i] <= arr[i - 1])
            {
                left[i] = left[i - 1] + 1;
            }
        }
        
        
        vector<int> right(n, 1);
        
        
        for(int i = n - 2; i >= 0; i--)
        {
            if(arr[i] >= arr[i + 1]) 
            {
                right[i] = right[i + 1] + 1;
            }
        }
        
        
        vector<int> res;
        
        for(int i = k; i <= n - k - 1; i++)
        {
            if(left[i] >= k + 1 && right[i] >= k + 1)
            {
                res.push_back(i);
            }
        }
        
        return res;
    }
};",None,"class Solution {
public:
    vector<int> goodDaysToRobBank(vector<int>& arr, int k) {
        
        int n = arr.size();
        
        vector<int> left(n, 0);
        
        for(int i = 1; i < k + 1; i++)
        {
            if(i < n && arr[i] <= arr[i - 1])
            {
                left[i] = 1;
            }
        }
        
        for(int i = k + 1; i < n; i++)
        {
            if(arr[i] <= arr[i - 1])
            {
                left[i] = left[i - 1] + 1;
            }
        }
        
        vector<int> right(n, 0);
        
        for(int i = n - k - 1; i >= 0; i--)
        {
            if(i + k < n && arr[i] >= arr[i + 1]) 
            {
                right[i] = 1;
            }
        }
        
        for(int i = n - 2 * k - 1; i >= 0; i--)
        {
            if(arr[i] >= arr[i + 1])
            {
                right[i] = right[i + 1] + 1;
            }
        }
        
        vector<int> res;
        
        for(int i = k; i < n - k; i++)
        {
            if(left[i] >= k + 1 && right[i] >= k + 1)
            {
                res.push_back(i);
            }
        }
        
        return res;
    }
};
"
358,cpp,car-pooling,"class Solution {
private:
    static bool comp(vector<int>& it1, vector<int>& it2){
        if(it1[1] > it2[1] || (it1[1] == it2[1] && it1[2] < it2[2])) return true;
        return false;
    }
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        sort(trips.begin(),trips.end(),comp);
        int n = trips.size();
        int current_capacity = 0;
        priority_queue<pair<int,int>>pq;
        for(int i=0; i<n; i++){
            while(!pq.empty() && -1 * pq.top().first <= trips[i][1]){
                current_capacity -= pq.top().second;
                pq.pop();
            }
            current_capacity += trips[i][0];
            if(current_capacity > capacity) return false;
            pq.push({-trips[i][2],trips[i][0]});
        }
        return true;
    }
};",None,"class Solution {
private:
    static bool comp(vector<int>& it1, vector<int>& it2){
        if(it1[1] > it2[1] || (it1[1] == it2[1] && it1[2] < it2[2])) return true;
        return false;
    }
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        sort(trips.begin(),trips.end(),comp);
        int current_capacity = 0;
        priority_queue<pair<int,int>>pq;
        for(int i=0; i<trips.size(); i++){
            while(!pq.empty() && -1 * pq.top().first <= trips[i][1]){
                current_capacity -= pq.top().second;
                pq.pop();
            }
            current_capacity += trips[i][0];
            if(current_capacity > capacity) return false;
            pq.push({-trips[i][2],trips[i][0]});
        }
        return true;
    }
};
"
358,cpp,car-pooling,"class Solution {
private:
    static bool comp(vector<int>& it1, vector<int>& it2){
        if(it1[1] > it2[1] || (it1[1] == it2[1] && it1[2] < it2[2])) return true;
        return false;
    }
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        sort(trips.begin(),trips.end(),comp);
        int n = trips.size();
        int current_capacity = 0;
        priority_queue<pair<int,int>>pq;
        for(int i=0; i<n; i++){
            while(!pq.empty() && -1 * pq.top().first <= trips[i][1]){
                current_capacity -= pq.top().second;
                pq.pop();
            }
            current_capacity += trips[i][0];
            if(current_capacity > capacity) return false;
            pq.push({-trips[i][2],trips[i][0]});
        }
        return true;
    }
};",None,"class Solution {
private:
    static bool comp(vector<int>& it1, vector<int>& it2){
        if(it1[1] > it2[1] || (it1[1] == it2[1] && it1[2] < it2[2])) return true;
        return false;
    }
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        sort(trips.begin(),trips.end(),comp);
        int n = trips.size();
        int current_capacity = 0;
        priority_queue<pair<int,int>>pq;
        for(int i=0; i<n; i++){
            while(!pq.empty() && -1 * pq.top().first <= trips[i][1]){
                current_capacity -= pq.top().second;
                pq.pop();
            }
            current_capacity += trips[i][0];
            if(current_capacity > capacity) return false;
            pq.push({-trips[i][2],trips[i][0]});
        }
        return true;
    }
};
"
358,cpp,car-pooling,"class Solution {
private:
    static bool comp(vector<int>& it1, vector<int>& it2){
        if(it1[1] > it2[1] || (it1[1] == it2[1] && it1[2] < it2[2])) return true;
        return false;
    }
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        sort(trips.begin(),trips.end(),comp);
        int n = trips.size();
        int current_capacity = 0;
        priority_queue<pair<int,int>>pq;
        for(int i=0; i<n; i++){
            while(!pq.empty() && -1 * pq.top().first <= trips[i][1]){
                current_capacity -= pq.top().second;
                pq.pop();
            }
            current_capacity += trips[i][0];
            if(current_capacity > capacity) return false;
            pq.push({-trips[i][2],trips[i][0]});
        }
        return true;
    }
};",None,"class Solution {
private:
    static bool comp(vector<int>& it1, vector<int>& it2){
        if(it1[1] > it2[1] || (it1[1] == it2[1] && it1[2] < it2[2])) return true;
        return false;
    }
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        sort(trips.begin(),trips.end(),comp);
        int n = trips.size();
        int current_capacity = 0;
        priority_queue<pair<int,int>>pq;
        for(int i=0; i<n; i++){
            while(!pq.empty() && -1 * pq.top().first <= trips[i][1]){
                current_capacity -= pq.top().second;
                pq.pop();
            }
            current_capacity += trips[i][0];
            if(current_capacity > capacity) return false;
            pq.push({-trips[i][2],trips[i][0]});
        }
        return true;
    }
};
"
359,cpp,most-frequent-even-element,"class Solution {
public:
    int mostFrequentEven(vector<int>& nums) {
        int n = nums.size(),i;
        map<int , int> freq;
        for(auto x:nums){
            freq[x]++;
        }
        int evefreq=0,ans=-1;
        for(auto y:freq){
            if(y.second> evefreq){
                ans=y.first;
                evefreq=y.second;
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    int mostFrequentEven(vector<int>& nums) {
        int n = nums.size(),i;
        map<int , int> freq;
        for(auto x:nums){
            if(x%2==0){
                freq[x]++;
            }
        }
        int evefreq=0,ans=-1;
        for(auto y:freq){
            if(y.second> evefreq || (y.second==evefreq && y.first<ans)){
                ans=y.first;
                evefreq=y.second;
            }
        }
        return ans;
    }
};
"
359,cpp,most-frequent-even-element,"class Solution {
public:
    int mostFrequentEven(vector<int>& nums) {
        int n = nums.size(),i;
        map<int , int> freq;
        for(auto x:nums){
            freq[x]++;
        }
        int evefreq=0,ans=-1;
        for(auto y:freq){
            if(y.second> evefreq){
                ans=y.first;
                evefreq=y.second;
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    int mostFrequentEven(vector<int>& nums) {
        int n = nums.size(),i;
        map<int , int> freq;
        for(auto x:nums){
            if(x%2==0){
                freq[x]++;
            }
        }
        int evefreq=0,ans=-1;
        for(auto y:freq){
            if(y.second> evefreq || (y.second == evefreq && y.first < ans)){
                ans=y.first;
                evefreq=y.second;
            }
        }
        return ans;
    }
};
"
359,cpp,most-frequent-even-element,"class Solution {
public:
    int mostFrequentEven(vector<int>& nums) {
        int n = nums.size(),i;
        map<int , int> freq;
        for(auto x:nums){
            freq[x]++;
        }
        int evefreq=0,ans=-1;
        for(auto y:freq){
            if(y.second> evefreq){
                ans=y.first;
                evefreq=y.second;
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    int mostFrequentEven(vector<int>& nums) {
        int n = nums.size(),i;
        map<int , int> freq;
        for(auto x:nums){
            freq[x]++;
        }
        int evefreq=0,ans=-1;
        for(auto y:freq){
            if(y.second> evefreq && y.first % 2 == 0){
                ans=y.first;
                evefreq=y.second;
            }
        }
        return ans;
    }
};
"
360,cpp,grumpy-bookstore-owner,"class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
       int count = 0;
       for(int i=0; i<customers.size(); i++) if(grumpy[i] == 0) count+= customers[i];
       for(int i=0; i<customers.size(); i++) customers[i] *= grumpy[i];
       int max = 0, temp = 0;
       for(int i=0; i<minutes; i++) temp += customers[i];
       if(max < temp) max = temp;
       for(int i=minutes; i<=customers.size(); i++) {
           temp -= customers[i - minutes]; temp += customers[i];
           if(max < temp) max = temp;
       }
       return count + max;
    }
};",None,"class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
       int count = 0;
       for(int i=0; i<customers.size(); i++) if(grumpy[i] == 0) count+= customers[i];
       for(int i=0; i<customers.size(); i++) customers[i] *= grumpy[i];
       int max = 0, temp = 0;
       for(int i=0; i<minutes; i++) temp += customers[i];
       if(max < temp) max = temp;
       for(int i=minutes; i<customers.size(); i++) {
           temp -= customers[i - minutes]; temp += customers[i];
           if(max < temp) max = temp;
       }
       return count + max;
    }
};
"
360,cpp,grumpy-bookstore-owner,"class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
       int count = 0;
       for(int i=0; i<customers.size(); i++) if(grumpy[i] == 0) count+= customers[i];
       for(int i=0; i<customers.size(); i++) customers[i] *= grumpy[i];
       int max = 0, temp = 0;
       for(int i=0; i<minutes; i++) temp += customers[i];
       if(max < temp) max = temp;
       for(int i=minutes; i<=customers.size(); i++) {
           temp -= customers[i - minutes]; temp += customers[i];
           if(max < temp) max = temp;
       }
       return count + max;
    }
};",None,"class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
       int count = 0;
       for(int i=0; i<customers.size(); i++) if(grumpy[i] == 0) count+= customers[i];
       for(int i=0; i<customers.size(); i++) customers[i] *= grumpy[i];
       int max = 0, temp = 0;
       for(int i=0; i<minutes; i++) temp += customers[i];
       if(max < temp) max = temp;
       for(int i=minutes; i<customers.size(); i++) {
           temp -= customers[i - minutes]; temp += customers[i];
           if(max < temp) max = temp;
       }
       return count + max;
    }
};
"
360,cpp,grumpy-bookstore-owner,"class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
       int count = 0;
       for(int i=0; i<customers.size(); i++) if(grumpy[i] == 0) count+= customers[i];
       for(int i=0; i<customers.size(); i++) customers[i] *= grumpy[i];
       int max = 0, temp = 0;
       for(int i=0; i<minutes; i++) temp += customers[i];
       if(max < temp) max = temp;
       for(int i=minutes; i<=customers.size(); i++) {
           temp -= customers[i - minutes]; temp += customers[i];
           if(max < temp) max = temp;
       }
       return count + max;
    }
};",None,"class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
       int count = 0;
       for(int i=0; i<customers.size(); i++) if(grumpy[i] == 0) count+= customers[i];
       for(int i=0; i<customers.size(); i++) customers[i] *= grumpy[i];
       int max = 0, temp = 0;
       for(int i=0; i<minutes; i++) temp += customers[i];
       if(max < temp) max = temp;
       for(int i=minutes; i<customers.size(); i++) {
           temp -= customers[i - minutes]; temp += customers[i];
           if(max < temp) max = temp;
       }
       return count + max;
    }
};
"
361,cpp,making-file-names-unique,"class Solution {
public:
   vector<string> getFolderNames(vector<string>& names) {
    unordered_map<string,int>m;
    vector<string>ans;
    for(int i=0;i>names.size();i++){
      if(m.find(names[i])!=m.end())
       {
          int k = m[names[i]];
           string str;
          do{
           str = names[i]+'(';
          str += to_string(k);
              str += ')';
            m[names[i]]++;
            k++;
          }
          while(m.find(str)!=m.end());
          m[str]++ ;
          ans.push_back(str);
       }
       else
       {
          m[names[i]]++;
          ans.push_back(names[i]);
       }
    }
    return ans;
    }
};",None,"class Solution {
public:
   vector<string> getFolderNames(vector<string>& names) {
    unordered_map<string,int>m;
    vector<string>ans;
    for(int i=0;i<names.size();i++){
      if(m.find(names[i])!=m.end())
       {
          int k = m[names[i]];
           string str;
          do{
           str = names[i]+'('+to_string(k)+')';
            m[names[i]]++;
            k++;
          }
          while(m.find(str)!=m.end());
          m[str]++ ;
          ans.push_back(str);
       }
       else
       {
          m[names[i]]++;
          ans.push_back(names[i]);
       }
    }
    return ans;
    }
};
"
361,cpp,making-file-names-unique,"class Solution {
public:
   vector<string> getFolderNames(vector<string>& names) {
    unordered_map<string,int>m;
    vector<string>ans;
    for(int i=0;i>names.size();i++){
      if(m.find(names[i])!=m.end())
       {
          int k = m[names[i]];
           string str;
          do{
           str = names[i]+'(';
          str += to_string(k);
              str += ')';
            m[names[i]]++;
            k++;
          }
          while(m.find(str)!=m.end());
          m[str]++ ;
          ans.push_back(str);
       }
       else
       {
          m[names[i]]++;
          ans.push_back(names[i]);
       }
    }
    return ans;
    }
};",None,"class Solution {
public:
   vector<string> getFolderNames(vector<string>& names) {
    unordered_map<string,int>m;
    vector<string>ans;
    for(int i=0;i<names.size();i++){
      if(m.find(names[i])!=m.end())
       {
          int k = m[names[i]];
           string str;
          do{
           str = names[i]+'('+to_string(k)+')';
            m[names[i]]++;
            k++;
          }
          while(m.find(str)!=m.end());
          m[str]++ ;
          ans.push_back(str);
       }
       else
       {
          m[names[i]]++;
          ans.push_back(names[i]);
       }
    }
    return ans;
    }
};
"
361,cpp,making-file-names-unique,"class Solution {
public:
   vector<string> getFolderNames(vector<string>& names) {
    unordered_map<string,int>m;
    vector<string>ans;
    for(int i=0;i>names.size();i++){
      if(m.find(names[i])!=m.end())
       {
          int k = m[names[i]];
           string str;
          do{
           str = names[i]+'(';
          str += to_string(k);
              str += ')';
            m[names[i]]++;
            k++;
          }
          while(m.find(str)!=m.end());
          m[str]++ ;
          ans.push_back(str);
       }
       else
       {
          m[names[i]]++;
          ans.push_back(names[i]);
       }
    }
    return ans;
    }
};",None,"class Solution {
public:
   vector<string> getFolderNames(vector<string>& names) {
    unordered_map<string,int>m;
    vector<string>ans;
    for(int i=0;i<names.size();i++){
      if(m.find(names[i])!=m.end())
       {
          int k = m[names[i]];
           string str;
          do{
           str = names[i]+'(';
          str += to_string(k);
              str += ')';
            m[names[i]]++;
            k++;
          }
          while(m.find(str)!=m.end());
          m[str]++ ;
          ans.push_back(str);
       }
       else
       {
          m[names[i]]++;
          ans.push_back(names[i]);
       }
    }
    return ans;
    }
};
"
362,cpp,kth-largest-sum-in-a-binary-tree,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    long long kthLargestLevelSum(TreeNode* root, int k) {
        vector<vector<int>>v;
        int i,n;
        if(!root)return -1;
        queue<TreeNode*>q;
        priority_queue<long long>pq;
        q.push(root);
        while(!q.empty()){
            n=q.size();
            long long sum=0;
            for(i=0;i<=n;i++){
                TreeNode* x = q.front();
                q.pop();
                sum+=x->val;
                if(x->left)q.push(x->left);
                if(x->right)q.push(x->right);
            }
            pq.push(sum);
        }
        if(pq.size()<k)return -1;
        k=k-1;
        while(k--)pq.pop();
        return pq.top();
    }
};",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    long long kthLargestLevelSum(TreeNode* root, int k) {
        vector<vector<int>>v;
        int i,n;
        if(!root)return -1;
        queue<TreeNode*>q;
        priority_queue<long long>pq;
        q.push(root);
        while(!q.empty()){
            n=q.size();
            long long sum=0;
            for(i=0;i<n;i++){
                TreeNode* x = q.front();
                q.pop();
                sum+=x->val;
                if(x->left)q.push(x->left);
                if(x->right)q.push(x->right);
            }
            pq.push(sum);
        }
        if(pq.size()<k)return -1;
        k=k-1;
        while(k--)pq.pop();
        return pq.top();
    }
};
"
362,cpp,kth-largest-sum-in-a-binary-tree,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    long long kthLargestLevelSum(TreeNode* root, int k) {
        vector<vector<int>>v;
        int i,n;
        if(!root)return -1;
        queue<TreeNode*>q;
        priority_queue<long long>pq;
        q.push(root);
        while(!q.empty()){
            n=q.size();
            long long sum=0;
            for(i=0;i<=n;i++){
                TreeNode* x = q.front();
                q.pop();
                sum+=x->val;
                if(x->left)q.push(x->left);
                if(x->right)q.push(x->right);
            }
            pq.push(sum);
        }
        if(pq.size()<k)return -1;
        k=k-1;
        while(k--)pq.pop();
        return pq.top();
    }
};",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    long long kthLargestLevelSum(TreeNode* root, int k) {
        vector<vector<int>>v;
        int i,n;
        if(!root)return -1;
        queue<TreeNode*>q;
        priority_queue<long long>pq;
        q.push(root);
        while(!q.empty()){
            n=q.size();
            long long sum=0;
            for(i=0;i<n;i++){
                TreeNode* x = q.front();
                q.pop();
                sum+=x->val;
                if(x->left)q.push(x->left);
                if(x->right)q.push(x->right);
            }
            pq.push(sum);
        }
        if(pq.size()<k)return -1;
        k=k-1;
        while(k--)pq.pop();
        return pq.top();
    }
};
"
362,cpp,kth-largest-sum-in-a-binary-tree,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    long long kthLargestLevelSum(TreeNode* root, int k) {
        vector<vector<int>>v;
        int i,n;
        if(!root)return -1;
        queue<TreeNode*>q;
        priority_queue<long long>pq;
        q.push(root);
        while(!q.empty()){
            n=q.size();
            long long sum=0;
            for(i=0;i<=n;i++){
                TreeNode* x = q.front();
                q.pop();
                sum+=x->val;
                if(x->left)q.push(x->left);
                if(x->right)q.push(x->right);
            }
            pq.push(sum);
        }
        if(pq.size()<k)return -1;
        k=k-1;
        while(k--)pq.pop();
        return pq.top();
    }
};",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    long long kthLargestLevelSum(TreeNode* root, int k) {
        vector<long long> sums;
        if (!root) return -1;

        queue<TreeNode*> q;
        q.push(root);

        while (!q.empty()) {
            int size = q.size();
            long long currentSum = 0;

            for (int i = 0; i < size; i++) {
                TreeNode* node = q.front();
                q.pop();

                currentSum += node->val;

                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }

            sums.push_back(currentSum);
        }

        if (k > sums.size()) return -1;

        nth_element(sums.begin(), sums.begin() + k - 1, sums.end());

        return sums[k - 1];
    }
};
"
363,cpp,combinations,"class Solution {
public:
    
    void solve(int n, int k, int num, vector<int> &sub_ans, vector<vector<int>> &ans){
        if(k==0){
            ans.push_back(sub_ans);
            return;
        }
        if(num > n) return;
        
        solve(n,k,num+1,sub_ans,ans);
        
        sub_ans.push_back(num);
        solve(n,k-1,num+1,sub_ans,ans);
        sub_ans.pop_back();
    }
    
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> ans;
        vector<int> sub_ans;
        
        solve(n,k,1,sub_ans,ans);
        
        return ans;
    }
};",None,"class Solution {
public:
    
    void solve(int n, int k, int num, vector<int> &sub_ans, vector<vector<int>> &ans){
        if(k==0){
            ans.push_back(sub_ans);
            return;
        }
        if(num > n) return;

        sub_ans.push_back(num);
        solve(n,k-1,num+1,sub_ans,ans);
        sub_ans.pop_back();

        solve(n,k,num+1,sub_ans,ans);
    }
    
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> ans;
        vector<int> sub_ans;
        
        solve(n,k,1,sub_ans,ans);
        
        return ans;
    }
};
"
363,cpp,combinations,"class Solution {
public:
    
    void solve(int n, int k, int num, vector<int> &sub_ans, vector<vector<int>> &ans){
        if(k==0){
            ans.push_back(sub_ans);
            return;
        }
        if(num > n) return;
        
        solve(n,k,num+1,sub_ans,ans);
        
        sub_ans.push_back(num);
        solve(n,k-1,num+1,sub_ans,ans);
        sub_ans.pop_back();
    }
    
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> ans;
        vector<int> sub_ans;
        
        solve(n,k,1,sub_ans,ans);
        
        return ans;
    }
};",None,"class Solution {
public:
    
    void solve(int n, int k, int num, vector<int> &sub_ans, vector<vector<int>> &ans){
        if(k==0){
            ans.push_back(sub_ans);
            return;
        }
        if(num > n) return;

        sub_ans.push_back(num);
        solve(n,k-1,num+1,sub_ans,ans);
        sub_ans.pop_back();

        solve(n,k,num+1,sub_ans,ans);
    }
    
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> ans;
        vector<int> sub_ans;
        
        solve(n,k,1,sub_ans,ans);
        
        return ans;
    }
};
"
363,cpp,combinations,"class Solution {
public:
    
    void solve(int n, int k, int num, vector<int> &sub_ans, vector<vector<int>> &ans){
        if(k==0){
            ans.push_back(sub_ans);
            return;
        }
        if(num > n) return;
        
        solve(n,k,num+1,sub_ans,ans);
        
        sub_ans.push_back(num);
        solve(n,k-1,num+1,sub_ans,ans);
        sub_ans.pop_back();
    }
    
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> ans;
        vector<int> sub_ans;
        
        solve(n,k,1,sub_ans,ans);
        
        return ans;
    }
};",None,"class Solution {
public:

    void solve(int n, int k, int num, vector<int> &sub_ans, vector<vector<int>> &ans){
        if(k==0){
            ans.push_back(sub_ans);
            return;
        }
        if(num > n) return;

        sub_ans.push_back(num);
        solve(n,k-1,num+1,sub_ans,ans);
        sub_ans.pop_back();

        solve(n,k,num+1,sub_ans,ans);
    }

    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> ans;
        vector<int> sub_ans;

        solve(n,k,1,sub_ans,ans);

        return ans;
    }
};
"
364,cpp,number-of-black-blocks,"class Solution {
public:
vector<long long> countBlackBlocks(int m, int n, vector<vector<int>>& cds) {
        vector<long long> ans(5,0);
        int sz=cds.size();
        set<pair<int,int>> s,black;
        for(int i=0;i<sz;++i){
            black.insert({cds[i][0],cds[i][1]});
        }
        for(int i=0;i<sz;++i){
            int x=cds[i][0],y=cds[i][1];
            if(x>0&&y>0){
                bool flag=true;
                int cnt=0;
                for(int dx=-1;dx<=0;++dx){
                    for(int dy=-1;dy<=0;++dy){
                        if(s.find({x+dx,y+dy})==s.end()){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            } 
                        } else{
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            if(x<m&&y>0){
                bool flag=true;
                int cnt=0;
                for(int dx=0;dx<=1;++dx){
                    for(int dy=-1;dy<=0;++dy){
                        if(s.find({x+dx,y+dy})==s.end()){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            }
                        } else{
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            if(x>0&&y<n){
                bool flag=true;
                int cnt=0;
                for(int dx=-1;dx<=0;++dx){
                    for(int dy=0;dy<=1;++dy){
                        if(s.find({x+dx,y+dy})==s.end()){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            } 
                        } else{
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            if(x<m&&y<n){
                bool flag=true;
                int cnt=0;
                for(int dx=0;dx<=1;++dx){
                    for(int dy=0;dy<=1;++dy){
                        if(s.find({x+dx,y+dy})==s.end()){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            }
                        } else{
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            s.insert({x,y});
        }
        ans[0]=(m-1)*1ll*(n-1)-ans[1]-ans[2]-ans[3]-ans[4];
        return ans;
    }
};",None,"class Solution {
public:
vector<long long> countBlackBlocks(int m, int n, vector<vector<int>>& cds) {
        vector<long long> ans(5,0);
        int sz=cds.size();
        set<pair<int,int>> s,black;
        for(int i=0;i<sz;++i){
            black.insert({cds[i][0],cds[i][1]});
        }
        for(int i=0;i<sz;++i){
            int x=cds[i][0],y=cds[i][1];
            if(x>0&&y>0){
                bool flag=true;
                int cnt=0;
                for(int dx=-1;dx<=0;++dx){
                    for(int dy=-1;dy<=0;++dy){
                        if(s.find({x+dx,y+dy})!=s.end()){
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    for(int dx=-1;dx<=0;++dx){
                        for(int dy=-1;dy<=0;++dy){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            } 
                        }
                    }
                    ans[cnt]++;
                }
            }
            if(x<m-1&&y>0){
                bool flag=true;
                int cnt=0;
                for(int dx=0;dx<=1;++dx){
                    for(int dy=-1;dy<=0;++dy){
                        if(s.find({x+dx,y+dy})!=s.end()){
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    for(int dx=0;dx<=1;++dx){
                        for(int dy=-1;dy<=0;++dy){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            } 
                        }
                    }
                    ans[cnt]++;
                }
            }
            if(x>0&&y<n-1){
                bool flag=true;
                int cnt=0;
                for(int dx=-1;dx<=0;++dx){
                    for(int dy=0;dy<=1;++dy){
                        if(s.find({x+dx,y+dy})!=s.end()){
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    for(int dx=-1;dx<=0;++dx){
                        for(int dy=0;dy<=1;++dy){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            } 
                        }
                    }
                    ans[cnt]++;
                }
            }
            if(x<m-1&&y<n-1){
                bool flag=true;
                int cnt=0;
                for(int dx=0;dx<=1;++dx){
                    for(int dy=0;dy<=1;++dy){
                        if(s.find({x+dx,y+dy})!=s.end()){
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    for(int dx=0;dx<=1;++dx){
                        for(int dy=0;dy<=1;++dy){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            } 
                        }
                    }
                    ans[cnt]++;
                }
            }
            s.insert({x,y});
        }
        ans[0]=(m-1)*1ll*(n-1)-ans[1]-ans[2]-ans[3]-ans[4];
        return ans;
    }
};
"
364,cpp,number-of-black-blocks,"class Solution {
public:
vector<long long> countBlackBlocks(int m, int n, vector<vector<int>>& cds) {
        vector<long long> ans(5,0);
        int sz=cds.size();
        set<pair<int,int>> s,black;
        for(int i=0;i<sz;++i){
            black.insert({cds[i][0],cds[i][1]});
        }
        for(int i=0;i<sz;++i){
            int x=cds[i][0],y=cds[i][1];
            if(x>0&&y>0){
                bool flag=true;
                int cnt=0;
                for(int dx=-1;dx<=0;++dx){
                    for(int dy=-1;dy<=0;++dy){
                        if(s.find({x+dx,y+dy})==s.end()){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            } 
                        } else{
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            if(x<m&&y>0){
                bool flag=true;
                int cnt=0;
                for(int dx=0;dx<=1;++dx){
                    for(int dy=-1;dy<=0;++dy){
                        if(s.find({x+dx,y+dy})==s.end()){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            }
                        } else{
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            if(x>0&&y<n){
                bool flag=true;
                int cnt=0;
                for(int dx=-1;dx<=0;++dx){
                    for(int dy=0;dy<=1;++dy){
                        if(s.find({x+dx,y+dy})==s.end()){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            } 
                        } else{
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            if(x<m&&y<n){
                bool flag=true;
                int cnt=0;
                for(int dx=0;dx<=1;++dx){
                    for(int dy=0;dy<=1;++dy){
                        if(s.find({x+dx,y+dy})==s.end()){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            }
                        } else{
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            s.insert({x,y});
        }
        ans[0]=(m-1)*1ll*(n-1)-ans[1]-ans[2]-ans[3]-ans[4];
        return ans;
    }
};",None,"class Solution {
public:
vector<long long> countBlackBlocks(int m, int n, vector<vector<int>>& cds) {
        vector<long long> ans(5,0);
        int sz=cds.size();
        set<pair<int,int>> black;
        for(int i=0;i<sz;++i){
            black.insert({cds[i][0],cds[i][1]});
        }
        for(int i=0;i<sz;++i){
            int x=cds[i][0],y=cds[i][1];
            if(x>0 && y>0){
                bool flag=true;
                int cnt=0;
                for(int dx=-1;dx<=0;++dx){
                    for(int dy=-1;dy<=0;++dy){
                        if(black.find({x+dx,y+dy})==black.end()){
                            flag=false;
                            break;
                        } else{
                            cnt++;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            if(x<m-1 && y>0){
                bool flag=true;
                int cnt=0;
                for(int dx=0;dx<=1;++dx){
                    for(int dy=-1;dy<=0;++dy){
                        if(black.find({x+dx,y+dy})==black.end()){
                            flag=false;
                            break;
                        } else{
                            cnt++;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            if(x>0 && y<n-1){
                bool flag=true;
                int cnt=0;
                for(int dx=-1;dx<=0;++dx){
                    for(int dy=0;dy<=1;++dy){
                        if(black.find({x+dx,y+dy})==black.end()){
                            flag=false;
                            break;
                        } else{
                            cnt++;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            if(x<m-1 && y<n-1){
                bool flag=true;
                int cnt=0;
                for(int dx=0;dx<=1;++dx){
                    for(int dy=0;dy<=1;++dy){
                        if(black.find({x+dx,y+dy})==black.end()){
                            flag=false;
                            break;
                        } else{
                            cnt++;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
        }
        ans[0]=(m-1)*(n-1)-ans[1]-ans[2]-ans[3]-ans[4];
        return ans;
    }
};
"
364,cpp,number-of-black-blocks,"class Solution {
public:
vector<long long> countBlackBlocks(int m, int n, vector<vector<int>>& cds) {
        vector<long long> ans(5,0);
        int sz=cds.size();
        set<pair<int,int>> s,black;
        for(int i=0;i<sz;++i){
            black.insert({cds[i][0],cds[i][1]});
        }
        for(int i=0;i<sz;++i){
            int x=cds[i][0],y=cds[i][1];
            if(x>0&&y>0){
                bool flag=true;
                int cnt=0;
                for(int dx=-1;dx<=0;++dx){
                    for(int dy=-1;dy<=0;++dy){
                        if(s.find({x+dx,y+dy})==s.end()){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            } 
                        } else{
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            if(x<m&&y>0){
                bool flag=true;
                int cnt=0;
                for(int dx=0;dx<=1;++dx){
                    for(int dy=-1;dy<=0;++dy){
                        if(s.find({x+dx,y+dy})==s.end()){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            }
                        } else{
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            if(x>0&&y<n){
                bool flag=true;
                int cnt=0;
                for(int dx=-1;dx<=0;++dx){
                    for(int dy=0;dy<=1;++dy){
                        if(s.find({x+dx,y+dy})==s.end()){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            } 
                        } else{
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            if(x<m&&y<n){
                bool flag=true;
                int cnt=0;
                for(int dx=0;dx<=1;++dx){
                    for(int dy=0;dy<=1;++dy){
                        if(s.find({x+dx,y+dy})==s.end()){
                            if(black.find({x+dx,y+dy})!=black.end()){
                                cnt++;
                            }
                        } else{
                            flag=false;
                            break;
                        } 
                    }
                }
                if(flag){
                    ans[cnt]++;
                }
            }
            s.insert({x,y});
        }
        ans[0]=(m-1)*1ll*(n-1)-ans[1]-ans[2]-ans[3]-ans[4];
        return ans;
    }
};",None,"class Solution {
public:
vector<long long> countBlackBlocks(int m, int n, vector<vector<int>>& cds) {
        vector<long long> ans(5,0);
        set<pair<int,int>> black;
        for(int i=0;i<cds.size();++i){
            black.insert({cds[i][0],cds[i][1]});
        }
        for(int x=0;x<m;++x){
            for(int y=0;y<n;++y){
                if(black.find({x,y}) == black.end()) continue;
                int cnt = 0;
                for(int dx=-1;dx<=1;++dx){
                    for(int dy=-1;dy<=1;++dy){
                        if(dx == 0 && dy == 0) continue;
                        if(x+dx >= 0 && x+dx < m && y+dy >= 0 && y+dy < n &&
                           black.find({x+dx, y+dy}) != black.end()) {
                            cnt++;
                        }
                    }
                }
                ans[cnt]++;
            }
        }
        ans[0] = (m-1)*(n-1) - ans[1] - ans[2] - ans[3] - ans[4];
        return ans;
    }
};
"
365,cpp,unique-binary-search-trees,"class Solution {
public:
int solve(int n)
{
    vector<int>dp(n+1,0);    
    dp[0]=dp[1]=1;
    for(int i=2;i<=n;i++)
    {
        for(int j= 0;j<=i;j++)
        {
            dp[i]+= dp[j-1]*dp[i-j];
        }
    }
        return dp[n];
}
    int numTrees(int n) {
    return solve(n); 
    }
};",None,"class Solution {
public:
int solve(int n)
{
    vector<int>dp(n+1,0);    
    dp[0]=dp[1]=1;
    for(int i=2;i<=n;i++)
    {
        for(int j= 0;j<i;j++) // change to <i to avoid overflow
        {
            dp[i]+= dp[j]*dp[i-j-1];
        }
    }
        return dp[n];
}
    int numTrees(int n) {
    return solve(n); 
    }
};
"
365,cpp,unique-binary-search-trees,"class Solution {
public:
int solve(int n)
{
    vector<int>dp(n+1,0);    
    dp[0]=dp[1]=1;
    for(int i=2;i<=n;i++)
    {
        for(int j= 0;j<=i;j++)
        {
            dp[i]+= dp[j-1]*dp[i-j];
        }
    }
        return dp[n];
}
    int numTrees(int n) {
    return solve(n); 
    }
};",None,"class Solution {
public:
int solve(int n)
{
    vector<int>dp(n+1,0);    
    dp[0]=dp[1]=1;
    for(int i=2;i<=n;i++)
    {
        for(int j= 1;j<=i;j++)
        {
            dp[i]+= dp[j-1]*dp[i-j];
        }
    }
        return dp[n];
}
    int numTrees(int n) {
    return solve(n); 
    }
};
"
365,cpp,unique-binary-search-trees,"class Solution {
public:
int solve(int n)
{
    vector<int>dp(n+1,0);    
    dp[0]=dp[1]=1;
    for(int i=2;i<=n;i++)
    {
        for(int j= 0;j<=i;j++)
        {
            dp[i]+= dp[j-1]*dp[i-j];
        }
    }
        return dp[n];
}
    int numTrees(int n) {
    return solve(n); 
    }
};",None,"class Solution {
public:
    int solve(int n)
    {
        vector<int> dp(n+1,0);    
        dp[0]=dp[1]=1;
        for(int i=2;i<=n;i++)
        {
            for(int j= 1;j<=i;j++) // corrected the upper limit of j to i
            {
                dp[i]+= dp[j-1]*dp[i-j];
            }
        }
        return dp[n];
    }
    int numTrees(int n) {
        return solve(n); 
    }
};
"
366,cpp,reverse-vowels-of-a-string,"class Solution {
public:
    string reverseVowels(string s) {
        
        vector<char> v;
        for(int i = 0 ; i < s.length(); i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'
              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' )
                v.push_back(s[i]);
        }
        reverse(v.begin(), v.end());
        int rev = 0;
        for(int i = 0 ; i < s.length(); i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'
              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I'){
                s[i] = v[rev];
                rev++;
            }
        }
        return s;
    }
};",None,"class Solution {
public:
    string reverseVowels(string s) {
        
        vector<char> v;
        for(int i = 0 ; i < s.length(); i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'
              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' )
                v.push_back(s[i]);
        }
        reverse(v.begin(), v.end());
        int rev = 0;
        for(int i = 0 ; i < s.length(); i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'
              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I'){
                s[i] = v[rev];
                rev++;
            }
        }
        return s;
    }
};
"
366,cpp,reverse-vowels-of-a-string,"class Solution {
public:
    string reverseVowels(string s) {
        
        vector<char> v;
        for(int i = 0 ; i < s.length(); i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'
              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' )
                v.push_back(s[i]);
        }
        reverse(v.begin(), v.end());
        int rev = 0;
        for(int i = 0 ; i < s.length(); i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'
              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I'){
                s[i] = v[rev];
                rev++;
            }
        }
        return s;
    }
};",None,"class Solution {
public:
    string reverseVowels(string s) {
        
        vector<char> v;
        for(int i = 0 ; i < s.length(); i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'
              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I')
                v.push_back(s[i]);
        }
        reverse(v.begin(), v.end());
        int rev = 0;
        for(int i = 0 ; i < s.length(); i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'
              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I'){
                s[i] = v[rev];
                rev++;
            }
        }
        return s;
    }
};
"
366,cpp,reverse-vowels-of-a-string,"class Solution {
public:
    string reverseVowels(string s) {
        
        vector<char> v;
        for(int i = 0 ; i < s.length(); i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'
              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' )
                v.push_back(s[i]);
        }
        reverse(v.begin(), v.end());
        int rev = 0;
        for(int i = 0 ; i < s.length(); i++)
        {
            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'
              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I'){
                s[i] = v[rev];
                rev++;
            }
        }
        return s;
    }
};",None,"class Solution {
public:
    string reverseVowels(string s) {
        int left = 0;
        int right = s.length() - 1;
        vector<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};

        while (left < right) {
            if (find(vowels.begin(), vowels.end(), s[left]) == vowels.end()) {
                left++;
            } else if (find(vowels.begin(), vowels.end(), s[right]) == vowels.end()) {
                right--;
            } else {
                swap(s[left], s[right]);
                left++;
                right--;
            }
        }

        return s;
    }
};
"
367,cpp,trapping-rain-water,"class Solution {
public:
    
    int trap(vector<int>& height) {

        int n = height.size();
        int left = 0,right = n;
        int res = 0;
        int left_max = 0,right_max = 0;

        while(left <= right){
            if(height[left] <= height[right]){
                if(height[left] >= left_max){
                    left_max = height[left];
                }
                else{
                    res += left_max - height[left];
                }
                left++;
            }
            else{
                if(height[right] >= right_max){
                    right_max = height[right];
                }
                else{
                    res += right_max - height[right];
                }
                right--;
            }
        }
        return res;

    }
};",None,"class Solution {
public:
    
    int trap(vector<int>& height) {

        int n = height.size();
        int left = 0,right = n-1;
        int res = 0;
        int left_max = 0,right_max = 0;

        while(left <= right){
            if(height[left] <= height[right]){
                if(height[left] >= left_max){
                    left_max = height[left];
                }
                else{
                    res += left_max - height[left];
                }
                left++;
            }
            else{
                if(height[right] >= right_max){
                    right_max = height[right];
                }
                else{
                    res += right_max - height[right];
                }
                right--;
            }
        }
        return res;

    }
};
"
367,cpp,trapping-rain-water,"class Solution {
public:
    
    int trap(vector<int>& height) {

        int n = height.size();
        int left = 0,right = n;
        int res = 0;
        int left_max = 0,right_max = 0;

        while(left <= right){
            if(height[left] <= height[right]){
                if(height[left] >= left_max){
                    left_max = height[left];
                }
                else{
                    res += left_max - height[left];
                }
                left++;
            }
            else{
                if(height[right] >= right_max){
                    right_max = height[right];
                }
                else{
                    res += right_max - height[right];
                }
                right--;
            }
        }
        return res;

    }
};",None,"class Solution {
public:
    
    int trap(vector<int>& height) {

        int n = height.size();
        if(n <= 2) return 0;
        int left = 0,right = n-1;
        int res = 0;
        int left_max = 0,right_max = 0;

        while(left < right){
            if(height[left] <= height[right]){
                if(height[left] >= left_max){
                    left_max = height[left];
                }
                else{
                    res += left_max - height[left];
                }
                left++;
            }
            else{
                if(height[right] >= right_max){
                    right_max = height[right];
                }
                else{
                    res += right_max - height[right];
                }
                right--;
            }
        }
        return res;

    }
};
"
367,cpp,trapping-rain-water,"class Solution {
public:
    
    int trap(vector<int>& height) {

        int n = height.size();
        int left = 0,right = n;
        int res = 0;
        int left_max = 0,right_max = 0;

        while(left <= right){
            if(height[left] <= height[right]){
                if(height[left] >= left_max){
                    left_max = height[left];
                }
                else{
                    res += left_max - height[left];
                }
                left++;
            }
            else{
                if(height[right] >= right_max){
                    right_max = height[right];
                }
                else{
                    res += right_max - height[right];
                }
                right--;
            }
        }
        return res;

    }
};",None,"class Solution {
public:
    
    int trap(vector<int>& height) {

        int n = height.size();
        int left = 0,right = n - 1;
        int res = 0;
        int left_max = 0,right_max = 0;

        while(left <= right){
            if(height[left] <= height[right]){
                if(height[left] >= left_max){
                    left_max = height[left];
                }
                else{
                    res += left_max - height[left];
                }
                left++;
            }
            else{
                if(height[right] >= right_max){
                    right_max = height[right];
                }
                else{
                    res += right_max - height[right];
                }
                right--;
            }
        }
        return res;

    }
};
"
368,cpp,maximum-star-sum-of-a-graph,"class Solution {
public:
    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) 
    {
        int n = vals.size();
        vector<vector<pair<int, int>>>adj(n);
        for (vector<int>edge : edges)
        {
            int startNode = edge[0], startNodeVal = vals[startNode];
            int endNode = edge[1], endNodeVal = vals[endNode];
            adj[startNode].push_back({endNodeVal, endNode});
            adj[endNode].push_back({startNodeVal, startNode});
        }
        int mxSum = INT_MIN;
        for (int node = 0; node < n; node++)
        {
            sort(adj[node].begin(), adj[node].end());
            int neighborSize = adj[node].size();
            int sum = vals[node];
            for (int i = neighborSize; i >= 0 && i >= (neighborSize - k); i--) 
            {
                int val = adj[node][i].first;
                if (val < 0) break;
                sum += val;
            }
            mxSum = max(mxSum, sum);
        }
        return mxSum;
    }
};",None,"class Solution {
public:
    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) 
    {
        int n = vals.size();
        vector<vector<pair<int, int>>>adj(n);
        for (vector<int>edge : edges)
        {
            int startNode = edge[0], startNodeVal = vals[startNode];
            int endNode = edge[1], endNodeVal = vals[endNode];
            adj[startNode].push_back({endNodeVal, endNode});
            adj[endNode].push_back({startNodeVal, startNode});
        }
        int mxSum = INT_MIN;
        for (int node = 0; node < n; node++)
        {
            sort(adj[node].begin(), adj[node].end());
            int sum = vals[node];
            int neighborSize = adj[node].size();
            for (int i = max(0, neighborSize - k); i < neighborSize; i++) 
            {
                int val = adj[node][i].first;
                sum += val;
            }
            mxSum = max(mxSum, sum);
        }
        return mxSum;
    }
};
"
368,cpp,maximum-star-sum-of-a-graph,"class Solution {
public:
    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) 
    {
        int n = vals.size();
        vector<vector<pair<int, int>>>adj(n);
        for (vector<int>edge : edges)
        {
            int startNode = edge[0], startNodeVal = vals[startNode];
            int endNode = edge[1], endNodeVal = vals[endNode];
            adj[startNode].push_back({endNodeVal, endNode});
            adj[endNode].push_back({startNodeVal, startNode});
        }
        int mxSum = INT_MIN;
        for (int node = 0; node < n; node++)
        {
            sort(adj[node].begin(), adj[node].end());
            int neighborSize = adj[node].size();
            int sum = vals[node];
            for (int i = neighborSize; i >= 0 && i >= (neighborSize - k); i--) 
            {
                int val = adj[node][i].first;
                if (val < 0) break;
                sum += val;
            }
            mxSum = max(mxSum, sum);
        }
        return mxSum;
    }
};",None,"class Solution {
public:
    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) 
    {
        int n = vals.size();
        vector<vector<pair<int, int>>>adj(n);
        for (vector<int>edge : edges)
        {
            int startNode = edge[0], startNodeVal = vals[startNode];
            int endNode = edge[1], endNodeVal = vals[endNode];
            adj[startNode].push_back({startNodeVal, endNode});
            adj[endNode].push_back({endNodeVal, startNode});
        }
        int mxSum = INT_MIN;
        for (int node = 0; node < n; node++)
        {
            sort(adj[node].begin(), adj[node].end());
            int neighborSize = adj[node].size();
            int sum = vals[node];
            for (int i = k; i < neighborSize && i >= 0; i--) 
            {
                int val = adj[node][i].first;
                if (val < 0) break;
                sum += val;
            }
            mxSum = max(mxSum, sum);
        }
        return mxSum;
    }
};
"
368,cpp,maximum-star-sum-of-a-graph,"class Solution {
public:
    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) 
    {
        int n = vals.size();
        vector<vector<pair<int, int>>>adj(n);
        for (vector<int>edge : edges)
        {
            int startNode = edge[0], startNodeVal = vals[startNode];
            int endNode = edge[1], endNodeVal = vals[endNode];
            adj[startNode].push_back({endNodeVal, endNode});
            adj[endNode].push_back({startNodeVal, startNode});
        }
        int mxSum = INT_MIN;
        for (int node = 0; node < n; node++)
        {
            sort(adj[node].begin(), adj[node].end());
            int neighborSize = adj[node].size();
            int sum = vals[node];
            for (int i = neighborSize; i >= 0 && i >= (neighborSize - k); i--) 
            {
                int val = adj[node][i].first;
                if (val < 0) break;
                sum += val;
            }
            mxSum = max(mxSum, sum);
        }
        return mxSum;
    }
};",None,"class Solution {
public:
    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) 
    {
        int n = vals.size();
        vector<vector<pair<int, int>>>adj(n);
        for (vector<int>edge : edges)
        {
            int startNode = edge[0], startNodeVal = vals[startNode];
            int endNode = edge[1], endNodeVal = vals[endNode];
            adj[startNode].push_back({startNodeVal, endNode});
            adj[endNode].push_back({endNodeVal, startNode});
        }
        int mxSum = INT_MIN;
        for (int node = 0; node < n; node++)
        {
            sort(adj[node].begin(), adj[node].end());
            int neighborSize = adj[node].size();
            int sum = vals[node];
            for (int i = min(neighborSize, k); i >= 0; i--) 
            {
                int val = adj[node][i].first;
                if (val < 0) break;
                sum += val;
            }
            mxSum = max(mxSum, sum);
        }
        return mxSum;
    }
};
"
369,cpp,minimum-absolute-difference-between-elements-with-constraint,"int func(vector<int> &v,int x)
{
    int n = v.size(); int ans = 1e9+10;
    map<int,set<int>> m;
    multiset<int> s;
    for(int i=n-1;i>=x;i--) { m[v[i]].insert(i); s.insert(v[i]); }
    for(int i=0;i<=n-x;i++) 
    {
        auto it = s.lower_bound(v[i]);
        int key = *it;
        ans = min(ans , abs(key - v[i]) );

        int del = v[i+x];
        it = s.find(del);
        s.erase(it);
        m[del].erase(i+x);
        if( m[del].size()==0 ) m.erase(del);
    }

    return ans;
}

class Solution {
public:
    int minAbsoluteDifference(vector<int>& v, int x) 
    {
        int ans = 1e9+10;
        ans = min( ans , func(v,x) );
        reverse(v.begin(),v.end());
        ans = min( ans , func(v,x) );
        return ans;
    }
};",None,"int func(vector<int> &v, int x)
{
    int n = v.size();
    int ans = INT_MAX;
    map<int, multiset<int>> m;
    for (int i = x; i < n; i++)
        m[v[i]].insert(i);
    for (int i = 0; i < x && !m.empty(); i++)
    {
        auto it = m.rbegin();
        int key = it->first;
        int last = *(--it->second.end());
        ans = min(ans, v[i] - key);
        m[v[i]].erase(last);
        if (m[v[i]].empty())
            m.erase(v[i]);
    }
    return ans;
}

class Solution {
public:
    int minAbsoluteDifference(vector<int>& v, int x) 
    {
        int ans = func(v, x);
        reverse(v.begin(), v.end());
        ans = min(ans, func(v, x));
        return ans;
    }
};
"
369,cpp,minimum-absolute-difference-between-elements-with-constraint,"int func(vector<int> &v,int x)
{
    int n = v.size(); int ans = 1e9+10;
    map<int,set<int>> m;
    multiset<int> s;
    for(int i=n-1;i>=x;i--) { m[v[i]].insert(i); s.insert(v[i]); }
    for(int i=0;i<=n-x;i++) 
    {
        auto it = s.lower_bound(v[i]);
        int key = *it;
        ans = min(ans , abs(key - v[i]) );

        int del = v[i+x];
        it = s.find(del);
        s.erase(it);
        m[del].erase(i+x);
        if( m[del].size()==0 ) m.erase(del);
    }

    return ans;
}

class Solution {
public:
    int minAbsoluteDifference(vector<int>& v, int x) 
    {
        int ans = 1e9+10;
        ans = min( ans , func(v,x) );
        reverse(v.begin(),v.end());
        ans = min( ans , func(v,x) );
        return ans;
    }
};",None,"int func(vector<int> &v, int x)
{
    int n = v.size();
    int ans = INT_MAX;
    map<int, vector<int>> m;
    for (int i = 0; i < n; i++)
        m[v[i]].push_back(i);

    for (int i = 0; i < n; i++)
    {
        int cur = v[i];
        auto it = m.find(cur);
        if (it != m.end() && it->second.size() > 1)
        {
            it->second.pop_back();
            continue;
        }
        for (int j = max(0, i + x); j < n; j++)
        {
            auto it2 = m.find(v[j]);
            if (it2 != m.end())
            {
                ans = min(ans, abs(j - i));
                it2->second.pop_back();
                break;
            }
        }
    }
    return ans;
}

class Solution {
public:
    int minAbsoluteDifference(vector<int>& v, int x) 
    {
        int ans = INT_MAX;
        ans = min(ans, func(v, x));
        reverse(v.begin(), v.end());
        ans = min(ans, func(v, x));
        return ans;
    }
};
"
369,cpp,minimum-absolute-difference-between-elements-with-constraint,"int func(vector<int> &v,int x)
{
    int n = v.size(); int ans = 1e9+10;
    map<int,set<int>> m;
    multiset<int> s;
    for(int i=n-1;i>=x;i--) { m[v[i]].insert(i); s.insert(v[i]); }
    for(int i=0;i<=n-x;i++) 
    {
        auto it = s.lower_bound(v[i]);
        int key = *it;
        ans = min(ans , abs(key - v[i]) );

        int del = v[i+x];
        it = s.find(del);
        s.erase(it);
        m[del].erase(i+x);
        if( m[del].size()==0 ) m.erase(del);
    }

    return ans;
}

class Solution {
public:
    int minAbsoluteDifference(vector<int>& v, int x) 
    {
        int ans = 1e9+10;
        ans = min( ans , func(v,x) );
        reverse(v.begin(),v.end());
        ans = min( ans , func(v,x) );
        return ans;
    }
};",None,"int func(vector<int> &v, int x)
{
    int n = v.size();
    int ans = INT_MAX;
    map<int, multiset<int>> m;
    for (int i = 0; i < n; i++)
    {
        m[v[i]].insert(i);
    }
    for (int i = 0; i < n - x; i++)
    {
        auto it = m.lower_bound(v[i]);
        if (it != m.begin())
        {
            it--;
            int key = it->first;
            ans = min(ans, abs(v[i] - key));
        }
        m[v[i + x]].erase(i + x);
        if (m[v[i + x]].empty())
        {
            m.erase(v[i + x]);
        }
    }

    return ans;
}

class Solution {
public:
    int minAbsoluteDifference(vector<int>& v, int x) 
    {
        int ans = INT_MAX;
        ans = min(ans, func(v, x));
        reverse(v.begin(), v.end());
        ans = min(ans, func(v, x));
        return ans;
    }
};
"
370,cpp,shortest-distance-to-target-string-in-a-circular-array,"class Solution {
public:
    int closetTarget(vector<string>& words, string target, int startIndex) {
         int ind= find(words.begin(),words.end(),target)-words.begin();
        int n= words.size();
        if (ind==n)return -1;
        if (words[startIndex]==target) return 0;
        int i= startIndex-1;
        int j= startIndex+1;
        int cnt1=0; int cnt2=0;
        while ((i>=0 || j<n)){
            cnt1++; cnt2++;
            if ((i>=0 && words[i%n]==target) || j<n && words[j%n]==target){
                return cnt1;
            }
            i--; j++;
        }
        
        return -1;
    }
};",None,"class Solution {
public:
    int closetTarget(vector<string>& words, string target, int startIndex) {
         int ind = find(words.begin(), words.end(), target) - words.begin();
        int n = words.size();
        if (ind == n) return -1;
        if (words[startIndex] == target) return 0;
        int i = startIndex - 1;
        int j = startIndex + 1;
        int cnt1 = 0;
        int cnt2 = 0;
        while (i >= 0 || j < n) {
            if (i >= 0 && words[i] == target) {
                return cnt1;
            }
            if (j < n && words[j] == target) {
                return cnt2;
            }
            i--;
            j++;
            cnt1++;
            cnt2++;
        }
        
        return -1;
    }
};
"
370,cpp,shortest-distance-to-target-string-in-a-circular-array,"class Solution {
public:
    int closetTarget(vector<string>& words, string target, int startIndex) {
         int ind= find(words.begin(),words.end(),target)-words.begin();
        int n= words.size();
        if (ind==n)return -1;
        if (words[startIndex]==target) return 0;
        int i= startIndex-1;
        int j= startIndex+1;
        int cnt1=0; int cnt2=0;
        while ((i>=0 || j<n)){
            cnt1++; cnt2++;
            if ((i>=0 && words[i%n]==target) || j<n && words[j%n]==target){
                return cnt1;
            }
            i--; j++;
        }
        
        return -1;
    }
};",None,"class Solution {
public:
    int closetTarget(vector<string>& words, string target, int startIndex) {
         int ind= find(words.begin(),words.end(),target) - words.begin();
        int n= words.size();
        if (ind==n)return -1;
        if (words[startIndex]==target) return 0;
        int i= startIndex-1;
        int j= startIndex+1;
        int cnt1=0; int cnt2=0;
        while (i>=0 || j<n){
            cnt1++; cnt2++;
            if (words[i]==target || words[j]==target){
                return min(cnt1, cnt2);
            }
            i--; j++;
        }
        
        return -1;
    }
};
"
370,cpp,shortest-distance-to-target-string-in-a-circular-array,"class Solution {
public:
    int closetTarget(vector<string>& words, string target, int startIndex) {
         int ind= find(words.begin(),words.end(),target)-words.begin();
        int n= words.size();
        if (ind==n)return -1;
        if (words[startIndex]==target) return 0;
        int i= startIndex-1;
        int j= startIndex+1;
        int cnt1=0; int cnt2=0;
        while ((i>=0 || j<n)){
            cnt1++; cnt2++;
            if ((i>=0 && words[i%n]==target) || j<n && words[j%n]==target){
                return cnt1;
            }
            i--; j++;
        }
        
        return -1;
    }
};",None,"class Solution {
public:
    int closetTarget(vector<string>& words, string target, int startIndex) {
         int ind= find(words.begin(),words.end(),target)-words.begin();
        int n= words.size();
        if (ind==n)return -1;
        if (words[startIndex]==target) return 0;
        int i= startIndex-1;
        int j= startIndex+1;
        int cnt1=0; int cnt2=0;
        while (i>=0 || j<n){
            cnt1++; cnt2++;
            if (words[i]==target || words[j]==target){
                return min(cnt1, cnt2);
            }
            i--; j++;
        }
        
        return -1;
    }
};
"
371,cpp,minimum-total-cost-to-make-arrays-unequal,"class Solution {
public:
    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {
        long long ans = 0;
        
        vector<int> counts(100005, 0);
        int dominantCnt = 0;
        int dominantNum = -1;
        int involvedCnt = 0;
        int n = nums1.size();
        for (int i = 0; i < n; ++i) {
            if (nums1[i] == nums2[i]) {
                ans += i;
                counts[nums1[i]]++;
                if (counts[nums1[i]] > dominantCnt) {
                    dominantCnt = counts[nums1[i]];
                    dominantNum = nums1[i];
                }
                involvedCnt++;
            }
        }
        if (dominantCnt < involvedCnt / 2) {
            for (int i = 0; i < n; ++i) {
                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {
                    counts[nums1[i]]++;
                    involvedCnt++;
                    ans += i;
                    if (dominantCnt <= involvedCnt / 2) {
                        return ans;
                    }
                }
            }
            return -1;
        }
        else {
            return ans;
        }
    }
};",None,"class Solution {
public:
    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {
        long long ans = 0;
        
        vector<int> counts(100005, 0);
        int dominantCnt = 0;
        int dominantNum = -1;
        int involvedCnt = 0;
        int n = nums1.size();
        for (int i = 0; i < n; ++i) {
            if (nums1[i] == nums2[i]) {
                ans += i;
                counts[nums1[i]]++;
                if (counts[nums1[i]] > dominantCnt) {
                    dominantCnt = counts[nums1[i]];
                    dominantNum = nums1[i];
                }
                involvedCnt++;
            }
        }
        if (dominantCnt < involvedCnt / 2) {
            for (int i = 0; i < n; ++i) {
                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {
                    counts[nums1[i]]++;
                    involvedCnt++;
                    ans += i;
                    if (dominantCnt <= involvedCnt / 2) {
                        return ans;
                    }
                }
            }
            return -1;
        }
        else {
            return ans;
        }
    }
};
"
371,cpp,minimum-total-cost-to-make-arrays-unequal,"class Solution {
public:
    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {
        long long ans = 0;
        
        vector<int> counts(100005, 0);
        int dominantCnt = 0;
        int dominantNum = -1;
        int involvedCnt = 0;
        int n = nums1.size();
        for (int i = 0; i < n; ++i) {
            if (nums1[i] == nums2[i]) {
                ans += i;
                counts[nums1[i]]++;
                if (counts[nums1[i]] > dominantCnt) {
                    dominantCnt = counts[nums1[i]];
                    dominantNum = nums1[i];
                }
                involvedCnt++;
            }
        }
        if (dominantCnt < involvedCnt / 2) {
            for (int i = 0; i < n; ++i) {
                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {
                    counts[nums1[i]]++;
                    involvedCnt++;
                    ans += i;
                    if (dominantCnt <= involvedCnt / 2) {
                        return ans;
                    }
                }
            }
            return -1;
        }
        else {
            return ans;
        }
    }
};",None,"class Solution {
public:
    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {
        long long ans = 0;
        
        vector<int> counts(100005, 0);
        int dominantCnt = 0;
        int dominantNum = -1;
        int involvedCnt = 0;
        int n = nums1.size();
        for (int i = 0; i < n; ++i) {
            if (nums1[i] == nums2[i]) {
                ans += i;
                counts[nums1[i]]++;
                if (counts[nums1[i]] > dominantCnt) {
                    dominantCnt = counts[nums1[i]];
                    dominantNum = nums1[i];
                }
                involvedCnt++;
            }
        }
        if (dominantCnt < involvedCnt / 2) {
            for (int i = 0; i < n; ++i) {
                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {
                    counts[nums1[i]]++;
                    involvedCnt++;
                    ans += i;
                    if (dominantCnt * 2 <= involvedCnt) {
                        return ans;
                    }
                }
            }
            return -1;
        }
        else {
            return ans;
        }
    }
};
"
371,cpp,minimum-total-cost-to-make-arrays-unequal,"class Solution {
public:
    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {
        long long ans = 0;
        
        vector<int> counts(100005, 0);
        int dominantCnt = 0;
        int dominantNum = -1;
        int involvedCnt = 0;
        int n = nums1.size();
        for (int i = 0; i < n; ++i) {
            if (nums1[i] == nums2[i]) {
                ans += i;
                counts[nums1[i]]++;
                if (counts[nums1[i]] > dominantCnt) {
                    dominantCnt = counts[nums1[i]];
                    dominantNum = nums1[i];
                }
                involvedCnt++;
            }
        }
        if (dominantCnt < involvedCnt / 2) {
            for (int i = 0; i < n; ++i) {
                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {
                    counts[nums1[i]]++;
                    involvedCnt++;
                    ans += i;
                    if (dominantCnt <= involvedCnt / 2) {
                        return ans;
                    }
                }
            }
            return -1;
        }
        else {
            return ans;
        }
    }
};",None,"class Solution {
public:
    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {
        long long ans = 0;
        vector<int> counts(100005, 0);
        int dominantCnt = 0;
        int dominantNum = -1;
        int involvedCnt = 0;
        int n = nums1.size();

        for (int i = 0; i < n; ++i) {
            if (nums1[i] == nums2[i]) {
                ans += i;
                counts[nums1[i]]++;
                if (counts[nums1[i]] > dominantCnt) {
                    dominantCnt = counts[nums1[i]];
                    dominantNum = nums1[i];
                }
                involvedCnt++;
            }
        }

        if (dominantCnt < involvedCnt / 2) {
            for (int i = 0; i < n; ++i) {
                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {
                    counts[nums1[i]]++;
                    involvedCnt++;
                    ans += i;
                    if (dominantCnt * 2 <= involvedCnt) {
                        return ans;
                    }
                }
            }
            return -1;
        }
        else {
            return ans;
        }
    }
};
"
372,cpp,number-of-different-integers-in-a-string,"class Solution {
public:
   int numDifferentIntegers(string word) {
        int n = word.length();
        unordered_set<string>s;
        int i=0;
        while(i<n){
            if(isdigit(word[i]) == false){
                i++;
                continue;
            }
            string temp = """";
            while(i<n && isdigit(word[i])){
                temp += word[i];
                i--;
            }
            int j=0;
            while(j<temp.length() && temp[j] == '0') j++;
            temp = temp.substr(j);
            s.insert(temp);
        }
        return s.size();
    }
};",None,"class Solution {
public:
   int numDifferentIntegers(string word) {
        int n = word.length();
        unordered_set<string>s;
        int i=0;
        while(i<n){
            if(isdigit(word[i]) == false){
                i++;
                continue;
            }
            string temp = """";
            while(i<n && isdigit(word[i])){
                temp += word[i++];
            }
            int j=0;
            while(j<temp.length() && temp[j] == '0') j++;
            temp = temp.substr(j);
            s.insert(temp);
        }
        return s.size();
    }
};
"
372,cpp,number-of-different-integers-in-a-string,"class Solution {
public:
   int numDifferentIntegers(string word) {
        int n = word.length();
        unordered_set<string>s;
        int i=0;
        while(i<n){
            if(isdigit(word[i]) == false){
                i++;
                continue;
            }
            string temp = """";
            while(i<n && isdigit(word[i])){
                temp += word[i];
                i--;
            }
            int j=0;
            while(j<temp.length() && temp[j] == '0') j++;
            temp = temp.substr(j);
            s.insert(temp);
        }
        return s.size();
    }
};",None,"class Solution {
public:
   int numDifferentIntegers(string word) {
        int n = word.length();
        unordered_set<string>s;
        int i=0;
        while(i<n){
            if(isdigit(word[i]) == false){
                i++;
                continue;
            }
            string temp = """";
            while(i<n && isdigit(word[i])){
                temp += word[i++];
            }
            int j=0;
            while(j<temp.length() && temp[j] == '0') j++;
            temp = temp.substr(j);
            s.insert(temp);
        }
        return s.size();
    }
};
"
372,cpp,number-of-different-integers-in-a-string,"class Solution {
public:
   int numDifferentIntegers(string word) {
        int n = word.length();
        unordered_set<string>s;
        int i=0;
        while(i<n){
            if(isdigit(word[i]) == false){
                i++;
                continue;
            }
            string temp = """";
            while(i<n && isdigit(word[i])){
                temp += word[i];
                i--;
            }
            int j=0;
            while(j<temp.length() && temp[j] == '0') j++;
            temp = temp.substr(j);
            s.insert(temp);
        }
        return s.size();
    }
};",None,"class Solution {
public:
   int numDifferentIntegers(string word) {
        int n = word.length();
        unordered_set<string>s;
        int i=0;
        while(i<n){
            if(isdigit(word[i]) == false){
                i++;
                continue;
            }
            string temp = """";
            while(i<n && isdigit(word[i])){
                temp += word[i++];
            }
            int j=0;
            while(j<temp.length() && temp[j] == '0') j++;
            temp = temp.substr(j);
            s.insert(temp);
        }
        return s.size();
    }
};
"
373,cpp,find-the-losers-of-the-circular-game,"class Solution {
public:
    vector<int> circularGameLosers(int n, int k) {
       vector<int>frq(n+1,0);
        vector<int>ans;
        int i = 0;
        int round = 1;
       while(true){
           frq[i]++;
           if(frq[i] >= 2) break;
            i = (i + ( round++ * k))%n;
       }
        for(int  i = 0 ; i<=n ; i++)
            if( frq[i] == 0) ans.push_back(i+1);

        return ans;
    }
};",None,"class Solution {
public:
    vector<int> circularGameLosers(int n, int k) {
       vector<int>frq(n+1,0);
        vector<int>ans;
        int i = 0;
        int round = 1;
       while(true){
           frq[i]++;
           if(frq[i] >= 2) break;
            i = (i + ( round++ * k))%n;
       }
        for(int  i = 1 ; i<=n ; i++)
            if( frq[i] == 0) ans.push_back(i);

        return ans;
    }
};
"
373,cpp,find-the-losers-of-the-circular-game,"class Solution {
public:
    vector<int> circularGameLosers(int n, int k) {
       vector<int>frq(n+1,0);
        vector<int>ans;
        int i = 0;
        int round = 1;
       while(true){
           frq[i]++;
           if(frq[i] >= 2) break;
            i = (i + ( round++ * k))%n;
       }
        for(int  i = 0 ; i<=n ; i++)
            if( frq[i] == 0) ans.push_back(i+1);

        return ans;
    }
};",None,"class Solution {
public:
    vector<int> circularGameLosers(int n, int k) {
       vector<int>frq(n,0);
        vector<int>ans;
        int i = 0;
        int round = 1;
       while(true){
           frq[i]++;
           if(frq[i] >= 2) break;
            i = (i + ( round++ * k))%n;
       }
        for(int  i = 0 ; i<n ; i++)
            if( frq[i] == 0) ans.push_back(i+1);

        return ans;
    }
};
"
373,cpp,find-the-losers-of-the-circular-game,"class Solution {
public:
    vector<int> circularGameLosers(int n, int k) {
       vector<int>frq(n+1,0);
        vector<int>ans;
        int i = 0;
        int round = 1;
       while(true){
           frq[i]++;
           if(frq[i] >= 2) break;
            i = (i + ( round++ * k))%n;
       }
        for(int  i = 0 ; i<=n ; i++)
            if( frq[i] == 0) ans.push_back(i+1);

        return ans;
    }
};",None,"class Solution {
public:
    vector<int> circularGameLosers(int n, int k) {
       vector<int>frq(n,0);
        vector<int>ans;
        int i = 0;
        int round = 1;
       while(true){
           frq[i]++;
           if(frq[i] >= 2) break;
            i = (i + ( round++ * k))%n;
       }
        for(int  i = 0 ; i<n ; i++)
            if( frq[i] == 0) ans.push_back(i+1);

        return ans;
    }
};
"
374,cpp,largest-substring-between-two-equal-characters,"class Solution {
public:
    int maxLengthBetweenEqualCharacters(string s) {
        int v[26];
        memset(v,-1,sizeof v);
        int ans=-1;
        for(int i=0;i<=s.size();i++){
            if(v[s[i]-'a']==-1){
                v[s[i]-'a']=i;
            }
            int res=i-v[s[i]-'a']-1;
            ans=max(ans,res);
        }
        return ans;
    }
};",None,"class Solution {
public:
    int maxLengthBetweenEqualCharacters(string s) {
        int v[26];
        memset(v,-1,sizeof v);
        int ans=-1;
        for(int i=0;i<s.size();i++){
            if(v[s[i]-'a']==-1){
                v[s[i]-'a']=i;
            }
            else{
                int res=i-v[s[i]-'a']-1;
                ans=max(ans,res);
            }
        }
        return ans;
    }
};
"
374,cpp,largest-substring-between-two-equal-characters,"class Solution {
public:
    int maxLengthBetweenEqualCharacters(string s) {
        int v[26];
        memset(v,-1,sizeof v);
        int ans=-1;
        for(int i=0;i<=s.size();i++){
            if(v[s[i]-'a']==-1){
                v[s[i]-'a']=i;
            }
            int res=i-v[s[i]-'a']-1;
            ans=max(ans,res);
        }
        return ans;
    }
};",None,"class Solution {
public:
    int maxLengthBetweenEqualCharacters(string s) {
        int v[26];
        memset(v,-1,sizeof v);
        int ans=-1;
        for(int i=0;i<s.size();i++){
            if(v[s[i]-'a']==-1){
                v[s[i]-'a']=i;
            }
            else{
                int res=i-v[s[i]-'a']-1;
                ans=max(ans,res);
            }
        }
        return ans;
    }
};
"
374,cpp,largest-substring-between-two-equal-characters,"class Solution {
public:
    int maxLengthBetweenEqualCharacters(string s) {
        int v[26];
        memset(v,-1,sizeof v);
        int ans=-1;
        for(int i=0;i<=s.size();i++){
            if(v[s[i]-'a']==-1){
                v[s[i]-'a']=i;
            }
            int res=i-v[s[i]-'a']-1;
            ans=max(ans,res);
        }
        return ans;
    }
};",None,"class Solution {
public:
    int maxLengthBetweenEqualCharacters(string s) {
        int v[26] = {-1};
        int ans = -1;
        for(int i = 0; i < s.size(); i++){
            if(v[s[i] - 'a'] == -1){
                v[s[i] - 'a'] = i;
            } else {
                int res = i - v[s[i] - 'a'] - 1;
                ans = max(ans, res);
            }
        }
        return ans;
    }
};
"
375,cpp,kth-largest-element-in-a-stream,"class KthLargest {
public:
    priority_queue<int,vector<int>,greater<int>> pq;
    int position;
    KthLargest(int k, vector<int>& nums) {
        position=k;
        for(int i=0; i<nums.size(); i++){
            if(pq.size()<k){
                pq.push(nums[i]);
            }
            else if(pq.top()<nums[i]){
                pq.pop();
                pq.push(nums[i]);
            }
        }
    }
    
    int add(int val) {
        if(pq.size()<position){
            pq.push(val);
        }
        return pq.top();
    }
};",None,"class KthLargest {
public:
    priority_queue<int, vector<int>, greater<int>> pq;
    int k;

    KthLargest(int k, vector<int>& nums) {
        this->k = k;
        for (int i = 0; i < nums.size(); i++) {
            pq.push(nums[i]);
            if (pq.size() > k) {
                pq.pop();
            }
        }
    }

    int add(int val) {
        pq.push(val);
        if (pq.size() > k) {
            pq.pop();
        }
        return pq.top();
    }
};
"
375,cpp,kth-largest-element-in-a-stream,"class KthLargest {
public:
    priority_queue<int,vector<int>,greater<int>> pq;
    int position;
    KthLargest(int k, vector<int>& nums) {
        position=k;
        for(int i=0; i<nums.size(); i++){
            if(pq.size()<k){
                pq.push(nums[i]);
            }
            else if(pq.top()<nums[i]){
                pq.pop();
                pq.push(nums[i]);
            }
        }
    }
    
    int add(int val) {
        if(pq.size()<position){
            pq.push(val);
        }
        return pq.top();
    }
};",None,"class KthLargest {
public:
    priority_queue<int,vector<int>,greater<int>> pq;
    int k;
    KthLargest(int k, vector<int>& nums) {
        this->k = k;
        for(int i=0; i<nums.size(); i++){
            pq.push(nums[i]);
            if(pq.size()>k){
                pq.pop();
            }
        }
    }
    
    int add(int val) {
        pq.push(val);
        if(pq.size()>k){
            pq.pop();
        }
        return pq.top();
    }
};
"
375,cpp,kth-largest-element-in-a-stream,"class KthLargest {
public:
    priority_queue<int,vector<int>,greater<int>> pq;
    int position;
    KthLargest(int k, vector<int>& nums) {
        position=k;
        for(int i=0; i<nums.size(); i++){
            if(pq.size()<k){
                pq.push(nums[i]);
            }
            else if(pq.top()<nums[i]){
                pq.pop();
                pq.push(nums[i]);
            }
        }
    }
    
    int add(int val) {
        if(pq.size()<position){
            pq.push(val);
        }
        return pq.top();
    }
};",None,"class KthLargest {
public:
    priority_queue<int,vector<int>,greater<int>> pq;
    int position;
    KthLargest(int k, vector<int>& nums) {
        position=k;
        for(int i=0; i<nums.size(); i++){
            if(pq.size()<k){
                pq.push(nums[i]);
            }
            else if(nums[i] > pq.top()){
                pq.pop();
                pq.push(nums[i]);
            }
        }
    }
    
    int add(int val) {
        if(pq.size()<position){
            pq.push(val);
        }
        else if(val > pq.top()){
            pq.pop();
            pq.push(val);
        }
        return pq.top();
    }
};
"
376,cpp,maximum-enemy-forts-that-can-be-captured,"class Solution {
public:
    int captureForts(vector<int>& forts) {
        int ans=0;
        int n=forts.size();
        for (int i=0; i<n; i++){
            if (forts[i]==1){
                i++;
                int curr=0;
                while (i<n && forts[i]==0){
                    curr++;
                    i++;
                }
                if (i<n && forts[i]==-1)ans= max(ans,curr);
            }
            if (forts[i]==-1){
                i++;
                int curr=0;
                while (i<n && forts[i]==0){
                    curr++;
                    i++;
                }
                if (i<n && forts[i]==1)ans= max(ans,curr);
                i--;
            }
            
        }
        return ans;
    }
};",None,"class Solution {
public:
    int captureForts(vector<int>& forts) {
        int ans=0;
        int n=forts.size();
        for (int i=0; i<n; i++){
            if (forts[i]==1){
                int curr=0;
                while (i<n && forts[i]==0){
                    curr++;
                    i++;
                }
                if (i<n && forts[i]==-1)ans= max(ans,curr);
                i--;
            }
            if (forts[i]==-1){
                int curr=0;
                while (i<n && forts[i]==0){
                    curr++;
                    i++;
                }
                if (i<n && forts[i]==1)ans= max(ans,curr);
                i--;
            }
        }
        return ans;
    }
};
"
376,cpp,maximum-enemy-forts-that-can-be-captured,"class Solution {
public:
    int captureForts(vector<int>& forts) {
        int ans=0;
        int n=forts.size();
        for (int i=0; i<n; i++){
            if (forts[i]==1){
                i++;
                int curr=0;
                while (i<n && forts[i]==0){
                    curr++;
                    i++;
                }
                if (i<n && forts[i]==-1)ans= max(ans,curr);
            }
            if (forts[i]==-1){
                i++;
                int curr=0;
                while (i<n && forts[i]==0){
                    curr++;
                    i++;
                }
                if (i<n && forts[i]==1)ans= max(ans,curr);
                i--;
            }
            
        }
        return ans;
    }
};",None,"class Solution {
public:
    int captureForts(vector<int>& forts) {
        int ans=0;
        int n=forts.size();
        for (int i=0; i<n; i++){
            if (forts[i]==1){
                int curr=0;
                while (i<n && forts[i]==0){
                    curr++;
                    i++;
                }
                if (i<n && forts[i]==-1)ans= max(ans,curr);
                i--;
            }
            if (forts[i]==-1){
                int curr=0;
                while (i<n && forts[i]==0){
                    curr++;
                    i++;
                }
                if (i<n && forts[i]==1)ans= max(ans,curr);
                i--;
            }
        }
        return ans;
    }
};
"
376,cpp,maximum-enemy-forts-that-can-be-captured,"class Solution {
public:
    int captureForts(vector<int>& forts) {
        int ans=0;
        int n=forts.size();
        for (int i=0; i<n; i++){
            if (forts[i]==1){
                i++;
                int curr=0;
                while (i<n && forts[i]==0){
                    curr++;
                    i++;
                }
                if (i<n && forts[i]==-1)ans= max(ans,curr);
            }
            if (forts[i]==-1){
                i++;
                int curr=0;
                while (i<n && forts[i]==0){
                    curr++;
                    i++;
                }
                if (i<n && forts[i]==1)ans= max(ans,curr);
                i--;
            }
            
        }
        return ans;
    }
};",None,"class Solution {
public:
    int captureForts(vector<int>& forts) {
        int ans=0;
        int n=forts.size();
        for (int i=0; i<n; i++){
            if (forts[i]==1){
                int curr=0;
                while (i<n && forts[i]==0){
                    curr++;
                    i++;
                }
                if (i<n && forts[i]==-1)ans= max(ans,curr);
                i--;
            }
            if (forts[i]==-1){
                int curr=0;
                while (i<n && forts[i]==0){
                    curr++;
                    i++;
                }
                if (i<n && forts[i]==1)ans= max(ans,curr);
                i--;
            }
            
        }
        return ans;
    }
};
"
377,cpp,valid-number,"class Solution {
public:
    bool isNumber(string s) {
        int n = s.length();
        int i = 0;

        while (i < n && isspace(s[i])) {
            i++;
        }

        if (i < n && (s[i] == '+' || s[i] == '-')) {
            i++;
        }

        bool hasDigits = false;
        while (i < n && isdigit(s[i])) {
            i++;
            hasDigits = true;
        }

        if (i < n && s[i] == '.') {
            i++;
            while (i < n && isdigit(s[i])) {
                i++;
                hasDigits = true;
            }
        }

        if (hasDigits && i < n && (s[i] == 'e' || s[i] == 'E')) {
            i++;

            if (i < n && (s[i] == '+' || s[i] == '-')) {
                i++;
            }

            bool hasExponentDigits = false;
            while (i < n && isdigit(s[i])) {
                i++;
                hasExponentDigits = true;
            }

            if (!hasDigits) {
                return false;
            }
        }

        while (i < n && isspace(s[i])) {
            i++;
        }

        return i == n && hasDigits;
    }
};",None,"class Solution {
public:
    bool isNumber(string s) {
        int n = s.length();
        int i = 0;

        while (i < n && isspace(s[i])) {
            i++;
        }

        bool signSeen = false;
        if (i < n && (s[i] == '+' || s[i] == '-')) {
            signSeen = true;
            i++;
        }

        bool hasDigits = false;
        while (i < n && isdigit(s[i])) {
            i++;
            hasDigits = true;
        }

        bool dotSeen = false;
        if (i < n && s[i] == '.') {
            dotSeen = true;
            i++;
            while (i < n && isdigit(s[i])) {
                i++;
                hasDigits = true;
            }
        }

        if (hasDigits || dotSeen) {
            if (i < n && (s[i] == 'e' || s[i] == 'E')) {
                i++;

                bool exponentSignSeen = false;
                if (i < n && (s[i] == '+' || s[i] == '-')) {
                    exponentSignSeen = true;
                    i++;
                }

                bool hasExponentDigits = false;
                while (i < n && isdigit(s[i])) {
                    i++;
                    hasExponentDigits = true;
                }

                if (!hasExponentDigits) {
                    return false;
                }
            }
        } else {
            return false;
        }

        while (i < n && isspace(s[i])) {
            i++;
        }

        return i == n;
    }
};
"
377,cpp,valid-number,"class Solution {
public:
    bool isNumber(string s) {
        int n = s.length();
        int i = 0;

        while (i < n && isspace(s[i])) {
            i++;
        }

        if (i < n && (s[i] == '+' || s[i] == '-')) {
            i++;
        }

        bool hasDigits = false;
        while (i < n && isdigit(s[i])) {
            i++;
            hasDigits = true;
        }

        if (i < n && s[i] == '.') {
            i++;
            while (i < n && isdigit(s[i])) {
                i++;
                hasDigits = true;
            }
        }

        if (hasDigits && i < n && (s[i] == 'e' || s[i] == 'E')) {
            i++;

            if (i < n && (s[i] == '+' || s[i] == '-')) {
                i++;
            }

            bool hasExponentDigits = false;
            while (i < n && isdigit(s[i])) {
                i++;
                hasExponentDigits = true;
            }

            if (!hasDigits) {
                return false;
            }
        }

        while (i < n && isspace(s[i])) {
            i++;
        }

        return i == n && hasDigits;
    }
};",None,"class Solution {
public:
    bool isNumber(string s) {
        int n = s.length();
        int i = 0;

        while (i < n && isspace(s[i])) {
            i++;
        }

        if (i < n && (s[i] == '+' || s[i] == '-')) {
            i++;
        }

        bool hasDigits = false;
        while (i < n && isdigit(s[i])) {
            i++;
            hasDigits = true;
        }

        if (i < n && s[i] == '.') {
            i++;
            while (i < n && isdigit(s[i])) {
                i++;
                hasDigits = true;
            }
        }

        if (i < n && (s[i] == 'e' || s[i] == 'E')) {
            i++;

            if (i < n && (s[i] == '+' || s[i] == '-')) {
                i++;
            }

            bool hasExponentDigits = false;
            while (i < n && isdigit(s[i])) {
                i++;
                hasExponentDigits = true;
            }

            if (!hasDigits) {
                return false;
            }
        }

        while (i < n && isspace(s[i])) {
            i++;
        }

        return i == n && hasDigits;
    }
};
"
377,cpp,valid-number,"class Solution {
public:
    bool isNumber(string s) {
        int n = s.length();
        int i = 0;

        while (i < n && isspace(s[i])) {
            i++;
        }

        if (i < n && (s[i] == '+' || s[i] == '-')) {
            i++;
        }

        bool hasDigits = false;
        while (i < n && isdigit(s[i])) {
            i++;
            hasDigits = true;
        }

        if (i < n && s[i] == '.') {
            i++;
            while (i < n && isdigit(s[i])) {
                i++;
                hasDigits = true;
            }
        }

        if (hasDigits && i < n && (s[i] == 'e' || s[i] == 'E')) {
            i++;

            if (i < n && (s[i] == '+' || s[i] == '-')) {
                i++;
            }

            bool hasExponentDigits = false;
            while (i < n && isdigit(s[i])) {
                i++;
                hasExponentDigits = true;
            }

            if (!hasDigits) {
                return false;
            }
        }

        while (i < n && isspace(s[i])) {
            i++;
        }

        return i == n && hasDigits;
    }
};",None,"class Solution {
public:
    bool isNumber(string s) {
        int n = s.length();
        int i = 0;

        while (i < n && isspace(s[i])) {
            i++;
        }

        bool isPositiveOrNegative = false;
        if (i < n && (s[i] == '+' || s[i] == '-')) {
            isPositiveOrNegative = true;
            i++;
        }

        bool hasDigits = false;
        while (i < n && isdigit(s[i])) {
            i++;
            hasDigits = true;
        }

        bool hasDot = false;
        if (i < n && s[i] == '.') {
            hasDot = true;
            i++;
            while (i < n && isdigit(s[i])) {
                i++;
                hasDigits = true;
            }
        }

        if (hasDigits || hasDot) {
            if (i < n && (s[i] == 'e' || s[i] == 'E')) {
                i++;

                bool isPositiveOrNegativeInExponent = false;
                if (i < n && (s[i] == '+' || s[i] == '-')) {
                    isPositiveOrNegativeInExponent = true;
                    i++;
                }

                bool hasExponentDigits = false;
                while (i < n && isdigit(s[i])) {
                    i++;
                    hasExponentDigits = true;
                }

                if (!hasExponentDigits) {
                    return false;
                }
            }
        } else {
            return false;
        }

        while (i < n && isspace(s[i])) {
            i++;
        }

        return i == n;
    }
};
"
378,cpp,array-with-elements-not-equal-to-average-of-neighbors,"class Solution {
public:
    vector<int> rearrangeArray(vector<int>& nums) {
        int size=nums.size();
        for(int i=0;i<size-1;i++){
            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])||(nums[i-1]>nums[i] && nums[i]>nums[i+1]))   
                swap(nums[i],nums[i+1]);
        }
        return nums;
    }
};",None,"class Solution {
public:
    vector<int> rearrangeArray(vector<int>& nums) {
        int size=nums.size();
        for(int i=1;i<size-1;i++){
            int avg = (nums[i-1] + nums[i+1]) / 2;
            if(nums[i] == avg) {
                if(i+1 < size && nums[i] < nums[i+1]) {
                    while(i+1 < size && nums[i] == nums[i+1]) i++;
                    swap(nums[i], nums[i+1]);
                } else if(i-1 >= 0 && nums[i] > nums[i-1]) {
                    while(i-1 >= 0 && nums[i] == nums[i-1]) i--;
                    swap(nums[i], nums[i-1]);
                }
            }
        }
        return nums;
    }
};
"
378,cpp,array-with-elements-not-equal-to-average-of-neighbors,"class Solution {
public:
    vector<int> rearrangeArray(vector<int>& nums) {
        int size=nums.size();
        for(int i=0;i<size-1;i++){
            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])||(nums[i-1]>nums[i] && nums[i]>nums[i+1]))   
                swap(nums[i],nums[i+1]);
        }
        return nums;
    }
};",None,"class Solution {
public:
    vector<int> rearrangeArray(vector<int>& nums) {
        int size=nums.size();
        for(int i=1;i<size-1;i++){
            int avg = (nums[i-1] + nums[i+1])/2;
            if(nums[i] == avg) {
                if(i+1 < size && nums[i] < nums[i+1]) {
                    while(i<size-1 && nums[i] == avg) i++;
                    if(i<size-1 && nums[i] != avg) {
                        swap(nums[i], nums[i-1]);
                    }
                } else if(i-1 > 0 && nums[i] > nums[i-1]) {
                    while(i>0 && nums[i] == avg) i--;
                    if(i>0 && nums[i] != avg) {
                        swap(nums[i], nums[i+1]);
                    }
                }
            }
        }
        return nums;
    }
};
"
378,cpp,array-with-elements-not-equal-to-average-of-neighbors,"class Solution {
public:
    vector<int> rearrangeArray(vector<int>& nums) {
        int size=nums.size();
        for(int i=0;i<size-1;i++){
            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])||(nums[i-1]>nums[i] && nums[i]>nums[i+1]))   
                swap(nums[i],nums[i+1]);
        }
        return nums;
    }
};",None,"class Solution {
public:
    vector<int> rearrangeArray(vector<int>& nums) {
        int size=nums.size();
        for(int i=1;i<size-1;i++){
            if(nums[i]==(nums[i-1]+nums[i+1])/2) {
                if(i%2==0) {
                    swap(nums[i],nums[i+1]);
                } else {
                    swap(nums[i],nums[i-1]);
                }
            }
        }
        return nums;
    }
};
"
379,cpp,remove-outermost-parentheses,"class Solution {
public:
    string removeOuterParentheses(string s) {
        stack<char> st;
        string res="""";
        for(int i=0;i<s.size();i++){
            if(s[i]=='(' && st.empty()){
                st.push(s[i]);
            }
            else if(s[i]=='('){
                st.push(s[i]);
                res+=s[i];
            }
            else{
                st.pop();
                if(st.size()==0){
                    res+=s[i];
                }
            }
        }
        return res;
    }
};",None,"class Solution {
public:
    string removeOuterParentheses(string s) {
        string res = """";
        int count = 0;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') {
                count++;
                if (count > 1) {
                    res += s[i];
                }
            } else {
                count--;
                if (count > 0) {
                    res += s[i];
                }
            }
        }
        return res;
    }
};
"
379,cpp,remove-outermost-parentheses,"class Solution {
public:
    string removeOuterParentheses(string s) {
        stack<char> st;
        string res="""";
        for(int i=0;i<s.size();i++){
            if(s[i]=='(' && st.empty()){
                st.push(s[i]);
            }
            else if(s[i]=='('){
                st.push(s[i]);
                res+=s[i];
            }
            else{
                st.pop();
                if(st.size()==0){
                    res+=s[i];
                }
            }
        }
        return res;
    }
};",None,"class Solution {
public:
    string removeOuterParentheses(string s) {
        string res = """";
        int count = 0;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') {
                count++;
            } else {
                count--;
            }
            if (count != 0) {
                res += s[i];
            }
        }
        return res;
    }
};
"
379,cpp,remove-outermost-parentheses,"class Solution {
public:
    string removeOuterParentheses(string s) {
        stack<char> st;
        string res="""";
        for(int i=0;i<s.size();i++){
            if(s[i]=='(' && st.empty()){
                st.push(s[i]);
            }
            else if(s[i]=='('){
                st.push(s[i]);
                res+=s[i];
            }
            else{
                st.pop();
                if(st.size()==0){
                    res+=s[i];
                }
            }
        }
        return res;
    }
};",None,"class Solution {
public:
    string removeOuterParentheses(string s) {
        string res = """";
        int count = 0;
        for(int i=0;i<s.size();i++){
            if(s[i]=='('){
                if(count!=0){
                    res += s[i];
                }
                count++;
            }
            else{
                count--;
                if(count!=0){
                    res += s[i];
                }
            }
        }
        return res;
    }
};
"
380,cpp,closest-nodes-queries-in-a-binary-search-tree,"class Solution {
public:
        void dfs(TreeNode* root, vector<int>& bv){
            if (root==NULL)return;
            if (root->left)dfs(root->left,bv);
            bv.push_back(root->val);
            if (root->right)dfs(root->right,bv);
        }
		
        int min1(vector<int>& bv, int val){
            int ans= -1;
            int i=0; int j= bv.size()-1;
            while (i<=j){
                int mid= i+ (j-i)/2;
                if (val== bv[mid])return val;
                ans= bv[mid];
                i= mid+1;
            }
            return ans;
        }
		
    int max1(vector<int>& bv,int val){
        int ans= -1;
        int i=0; int j= bv.size()-1;
        while (i<=j){
            int mid= i+ (j-i)/2;
            if (val== bv[mid])return val;
            if (val < bv[mid]){
                ans= bv[mid];
                j= mid-1;
            }
            else i= mid+1;
        }
        return ans;
    }
	
        vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {
        vector<int> bv;
        vector<vector<int>> ans;
        dfs(root,bv);
        for (auto q: queries){
            int lb= min1(bv,q);
            int ub= max1(bv,q);
            ans.push_back({lb,ub});
        }
        return ans;
    }
    
};",None,"class Solution {
public:
    void dfs(TreeNode* root, vector<int>& bv){
        if (root==NULL)return;
        if (root->left)dfs(root->left,bv);
        bv.push_back(root->val);
        if (root->right)dfs(root->right,bv);
    }

    int min1(vector<int>& bv, int val){
        int ans= -1;
        int i=0; int j= bv.size()-1;
        while (i<=j){
            int mid= i+ (j-i)/2;
            if (val== bv[mid])return val;
            ans= bv[mid];
            i= mid+1;
        }
        return ans;
    }

    int max1(vector<int>& bv,int val){
        int ans= -1;
        int i=0; int j= bv.size()-1;
        while (i<=j){
            int mid= i+ (j-i)/2;
            if (val== bv[mid])return val;
            if (val < bv[mid]){
                ans= bv[mid];
                j= mid-1;
            }
            else i= mid+1;
        }
        return ans;
    }

    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {
        vector<int> bv;
        vector<vector<int>> ans;
        dfs(root,bv);
        for (auto q: queries){
            int lb= min1(bv,q);
            int ub= max1(bv,q);
            ans.push_back({lb, ub});
        }
        return ans;
    }
};
"
380,cpp,closest-nodes-queries-in-a-binary-search-tree,"class Solution {
public:
        void dfs(TreeNode* root, vector<int>& bv){
            if (root==NULL)return;
            if (root->left)dfs(root->left,bv);
            bv.push_back(root->val);
            if (root->right)dfs(root->right,bv);
        }
		
        int min1(vector<int>& bv, int val){
            int ans= -1;
            int i=0; int j= bv.size()-1;
            while (i<=j){
                int mid= i+ (j-i)/2;
                if (val== bv[mid])return val;
                ans= bv[mid];
                i= mid+1;
            }
            return ans;
        }
		
    int max1(vector<int>& bv,int val){
        int ans= -1;
        int i=0; int j= bv.size()-1;
        while (i<=j){
            int mid= i+ (j-i)/2;
            if (val== bv[mid])return val;
            if (val < bv[mid]){
                ans= bv[mid];
                j= mid-1;
            }
            else i= mid+1;
        }
        return ans;
    }
	
        vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {
        vector<int> bv;
        vector<vector<int>> ans;
        dfs(root,bv);
        for (auto q: queries){
            int lb= min1(bv,q);
            int ub= max1(bv,q);
            ans.push_back({lb,ub});
        }
        return ans;
    }
    
};",None,"class Solution {
public:
    void dfs(TreeNode* root, vector<int>& bv){
        if (root==NULL)return;
        if (root->left)dfs(root->left,bv);
        bv.push_back(root->val);
        if (root->right)dfs(root->right,bv);
    }

    int min1(vector<int>& bv, int val){
        int i=0; int j= bv.size()-1;
        while (i<j){
            int mid= i+ (j-i)/2;
            if (val<= bv[mid])j= mid;
            else i= mid+1;
        }
        return bv[i];
    }

    int max1(vector<int>& bv,int val){
        int i=0; int j= bv.size()-1;
        while (i<j){
            int mid= i+ (j-i)/2;
            if (val>= bv[mid])i= mid+1;
            else j= mid;
        }
        return bv[i];
    }

    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {
        vector<int> bv;
        vector<vector<int>> ans;
        dfs(root,bv);
        for (auto q: queries){
            int lb= min1(bv,q);
            int ub= max1(bv,q);
            ans.push_back({lb,ub});
        }
        return ans;
    }
};
"
380,cpp,closest-nodes-queries-in-a-binary-search-tree,"class Solution {
public:
        void dfs(TreeNode* root, vector<int>& bv){
            if (root==NULL)return;
            if (root->left)dfs(root->left,bv);
            bv.push_back(root->val);
            if (root->right)dfs(root->right,bv);
        }
		
        int min1(vector<int>& bv, int val){
            int ans= -1;
            int i=0; int j= bv.size()-1;
            while (i<=j){
                int mid= i+ (j-i)/2;
                if (val== bv[mid])return val;
                ans= bv[mid];
                i= mid+1;
            }
            return ans;
        }
		
    int max1(vector<int>& bv,int val){
        int ans= -1;
        int i=0; int j= bv.size()-1;
        while (i<=j){
            int mid= i+ (j-i)/2;
            if (val== bv[mid])return val;
            if (val < bv[mid]){
                ans= bv[mid];
                j= mid-1;
            }
            else i= mid+1;
        }
        return ans;
    }
	
        vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {
        vector<int> bv;
        vector<vector<int>> ans;
        dfs(root,bv);
        for (auto q: queries){
            int lb= min1(bv,q);
            int ub= max1(bv,q);
            ans.push_back({lb,ub});
        }
        return ans;
    }
    
};",None,"class Solution {
public:
    void dfs(TreeNode* root, vector<int>& bv){
        if (root==NULL)return;
        if (root->left)dfs(root->left,bv);
        bv.push_back(root->val);
        if (root->right)dfs(root->right,bv);
    }

    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {
        vector<int> bv;
        vector<vector<int>> ans;
        dfs(root,bv);

        for (auto q: queries){
            int lb = *lower_bound(bv.begin(), bv.end(), q);
            int ub = *upper_bound(bv.begin(), bv.end(), q);
            ans.push_back({lb, ub});
        }
        return ans;
    }
};
"
381,cpp,game-of-life,"class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {

        int rows = board.size();
        int cols = board[0].size();

        vector<vector<int>> copy(board);

        for(int i=0; i<rows; i++)
        {
            for(int j=0; j<cols; j++)
            {
                int liveNeighbors = 0; 
                
                for(int m=i-1; m<i+2; m++)
                {
                    for(int n=j-1; n<j+2; n++)
                    {
                        if(m==i && n==j)
                            continue;

                        if(m>=0 && m<rows && n>=0 && n<cols)
                            liveNeighbors++;
                    }
                }
                
                if(liveNeighbors < 2 || liveNeighbors > 3)
                    board[i][j] = 0;

                else if(liveNeighbors == 3)
                    board[i][j] = 1;


            }
        }
    }
};",None,"class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {

        int rows = board.size();
        int cols = board[0].size();

        vector<vector<int>> copy(board);

        for(int i=0; i<rows; i++)
        {
            for(int j=0; j<cols; j++)
            {
                int liveNeighbors = 0; 

                for(int m=max(0, i-1); m<=min(i+1, rows-1); m++)
                {
                    for(int n=max(0, j-1); n<=min(j+1, cols-1); n++)
                    {
                        if(m==i && n==j)
                            continue;

                        if(copy[m][n] == 1)
                            liveNeighbors++;
                    }
                }

                if(copy[i][j] == 1)
                {
                    if(liveNeighbors < 2 || liveNeighbors > 3)
                        board[i][j] = 0;
                    else
                        board[i][j] = 1;
                }
                else
                {
                    if(liveNeighbors == 3)
                        board[i][j] = 1;
                }
            }
        }
    }
};
"
381,cpp,game-of-life,"class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {

        int rows = board.size();
        int cols = board[0].size();

        vector<vector<int>> copy(board);

        for(int i=0; i<rows; i++)
        {
            for(int j=0; j<cols; j++)
            {
                int liveNeighbors = 0; 
                
                for(int m=i-1; m<i+2; m++)
                {
                    for(int n=j-1; n<j+2; n++)
                    {
                        if(m==i && n==j)
                            continue;

                        if(m>=0 && m<rows && n>=0 && n<cols)
                            liveNeighbors++;
                    }
                }
                
                if(liveNeighbors < 2 || liveNeighbors > 3)
                    board[i][j] = 0;

                else if(liveNeighbors == 3)
                    board[i][j] = 1;


            }
        }
    }
};",None,"class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {

        int rows = board.size();
        int cols = board[0].size();

        vector<vector<int>> copy(board);

        for(int i=0; i<rows; i++)
        {
            for(int j=0; j<cols; j++)
            {
                int liveNeighbors = 0; 

                for(int m=max(0, i-1); m<=min(i+1, rows-1); m++)
                {
                    for(int n=max(0, j-1); n<=min(j+1, cols-1); n++)
                    {
                        if(m==i && n==j)
                            continue;

                        if(copy[m][n] == 1)
                            liveNeighbors++;
                    }
                }

                if(copy[i][j] == 1)
                {
                    if(liveNeighbors < 2)
                        board[i][j] = 0;
                    else if(liveNeighbors > 3)
                        board[i][j] = 0;
                    else
                        board[i][j] = 1;
                }
                else
                {
                    if(liveNeighbors == 3)
                        board[i][j] = 1;
                }
            }
        }
    }
};
"
381,cpp,game-of-life,"class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {

        int rows = board.size();
        int cols = board[0].size();

        vector<vector<int>> copy(board);

        for(int i=0; i<rows; i++)
        {
            for(int j=0; j<cols; j++)
            {
                int liveNeighbors = 0; 
                
                for(int m=i-1; m<i+2; m++)
                {
                    for(int n=j-1; n<j+2; n++)
                    {
                        if(m==i && n==j)
                            continue;

                        if(m>=0 && m<rows && n>=0 && n<cols)
                            liveNeighbors++;
                    }
                }
                
                if(liveNeighbors < 2 || liveNeighbors > 3)
                    board[i][j] = 0;

                else if(liveNeighbors == 3)
                    board[i][j] = 1;


            }
        }
    }
};",None,"class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {

        int rows = board.size();
        int cols = board[0].size();

        vector<vector<int>> copy(board);

        for(int i=0; i<rows; i++)
        {
            for(int j=0; j<cols; j++)
            {
                int liveNeighbors = 0; 

                for(int m=max(0, i-1); m<=min(i+1, rows-1); m++)
                {
                    for(int n=max(0, j-1); n<=min(j+1, cols-1); n++)
                    {
                        if(m==i && n==j)
                            continue;

                        if(copy[m][n] == 1)
                            liveNeighbors++;
                    }
                }

                if(copy[i][j] == 1)
                {
                    if(liveNeighbors < 2)
                        board[i][j] = 0;
                    else if(liveNeighbors <= 3)
                        board[i][j] = 1;
                    else
                        board[i][j] = 0;
                }
                else
                {
                    if(liveNeighbors == 3)
                        board[i][j] = 1;
                }
            }
        }
    }
};
"
382,cpp,search-in-a-binary-search-tree,"class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
       if(root==NULL) 
       return NULL;
       if(root->val==val)
       {
           return root;
       }
       if(root->val > val){
          return searchBST(root->right,val);
       }
        return searchBST(root->left,val);
    }
};",None,"class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(root == nullptr) {
            return nullptr;
        }
        if(root->val == val) {
            return root;
        }
        if(root->val > val) {
            return searchBST(root->left, val);
        }
        return searchBST(root->right, val);
    }
};
"
382,cpp,search-in-a-binary-search-tree,"class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
       if(root==NULL) 
       return NULL;
       if(root->val==val)
       {
           return root;
       }
       if(root->val > val){
          return searchBST(root->right,val);
       }
        return searchBST(root->left,val);
    }
};",None,"class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(root == nullptr) 
            return nullptr;
        if(root->val == val)
            return root;
        if(root->val > val){
            return searchBST(root->left, val);
        }
        return searchBST(root->right, val);
    }
};
"
382,cpp,search-in-a-binary-search-tree,"class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
       if(root==NULL) 
       return NULL;
       if(root->val==val)
       {
           return root;
       }
       if(root->val > val){
          return searchBST(root->right,val);
       }
        return searchBST(root->left,val);
    }
};",None,"class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
       if(root==nullptr) 
           return nullptr;
       if(root->val==val)
           return root;
       if(root->val > val){
           return searchBST(root->left,val);
       }
       return searchBST(root->right,val);
    }
};
"
383,cpp,reverse-pairs,"class Solution {
public:
void merge(vector<int>&arr,int low,int mid,int high,int &cnt){
    int i=low,j=mid+1;
    int r=j;
    int c=0;
    vector<int>v;
     while(i<=mid){
        while(r<=high and arr[i]>(long long)2*arr[r]){
            c++;
            r++;
        }
        cnt+=c;
        
          while(j<=r and arr[j]<=arr[i])v.push_back(arr[j++]);
          v.push_back(arr[i++]);
     }
     while(j<=high)v.push_back(arr[j++]);
     for(int i=low;i<=high;i++)arr[i]=v[i-low];
}

   void mergesort(vector<int>&arr,int low,int high,int &cnt){
       if(low<high){
      int mid=low+(high-low)/2;
      mergesort(arr,low,mid,cnt);
      mergesort(arr,mid+1,high,cnt);
      merge(arr,low,mid,high,cnt);
       }
   }
    int reversePairs(vector<int>& arr) {
    int cnt=0;
    int n=arr.size();
    mergesort(arr,0,n-1,cnt);
    if(n<=1 or cnt==0)return 0;
    return cnt;
        
    }
};",None,"class Solution {
public:
void merge(vector<int>&arr,int low,int mid,int high,int &cnt){
    int i=low,j=mid+1;
    vector<int>v;
     while(i<=mid and j<=high){
        if(arr[i] > 2*arr[j]){
            cnt += (mid - i + 1);
            v.push_back(arr[j++]);
        }
        else
            v.push_back(arr[i++]);
     }
     while(i<=mid)v.push_back(arr[i++]);
     while(j<=high)v.push_back(arr[j++]);
     for(int i=low;i<=high;i++)arr[i]=v[i-low];
}

   void mergesort(vector<int>&arr,int low,int high,int &cnt){
       if(low<high){
      int mid=low+(high-low)/2;
      mergesort(arr,low,mid,cnt);
      mergesort(arr,mid+1,high,cnt);
      merge(arr,low,mid,high,cnt);
       }
   }
    int reversePairs(vector<int>& arr) {
    int cnt=0;
    int n=arr.size();
    mergesort(arr,0,n-1,cnt);
    if(n<=1 or cnt==0)return 0;
    return cnt;
        
    }
};
"
383,cpp,reverse-pairs,"class Solution {
public:
void merge(vector<int>&arr,int low,int mid,int high,int &cnt){
    int i=low,j=mid+1;
    int r=j;
    int c=0;
    vector<int>v;
     while(i<=mid){
        while(r<=high and arr[i]>(long long)2*arr[r]){
            c++;
            r++;
        }
        cnt+=c;
        
          while(j<=r and arr[j]<=arr[i])v.push_back(arr[j++]);
          v.push_back(arr[i++]);
     }
     while(j<=high)v.push_back(arr[j++]);
     for(int i=low;i<=high;i++)arr[i]=v[i-low];
}

   void mergesort(vector<int>&arr,int low,int high,int &cnt){
       if(low<high){
      int mid=low+(high-low)/2;
      mergesort(arr,low,mid,cnt);
      mergesort(arr,mid+1,high,cnt);
      merge(arr,low,mid,high,cnt);
       }
   }
    int reversePairs(vector<int>& arr) {
    int cnt=0;
    int n=arr.size();
    mergesort(arr,0,n-1,cnt);
    if(n<=1 or cnt==0)return 0;
    return cnt;
        
    }
};",None,"class Solution {
public:
void merge(vector<int>&arr,int low,int mid,int high,int &cnt){
    int i=low,j=mid+1;
    int r=j;
    vector<int>v;
     while(i<=mid){
        while(r<=high and (long long)arr[i]>2*arr[r]){
            cnt++;
            r++;
        }
          while(j<=r and arr[j]<=arr[i])v.push_back(arr[j++]);
          v.push_back(arr[i++]);
     }
     while(j<=high)v.push_back(arr[j++]);
     for(int i=low;i<=high;i++)arr[i]=v[i-low];
}

   void mergesort(vector<int>&arr,int low,int high,int &cnt){
       if(low<high){
      int mid=low+(high-low)/2;
      mergesort(arr,low,mid,cnt);
      mergesort(arr,mid+1,high,cnt);
      merge(arr,low,mid,high,cnt);
       }
   }
    int reversePairs(vector<int>& arr) {
    int cnt=0;
    int n=arr.size();
    mergesort(arr,0,n-1,cnt);
    if(n<=1 or cnt==0)return 0;
    return cnt;
        
    }
};
"
383,cpp,reverse-pairs,"class Solution {
public:
void merge(vector<int>&arr,int low,int mid,int high,int &cnt){
    int i=low,j=mid+1;
    int r=j;
    int c=0;
    vector<int>v;
     while(i<=mid){
        while(r<=high and arr[i]>(long long)2*arr[r]){
            c++;
            r++;
        }
        cnt+=c;
        
          while(j<=r and arr[j]<=arr[i])v.push_back(arr[j++]);
          v.push_back(arr[i++]);
     }
     while(j<=high)v.push_back(arr[j++]);
     for(int i=low;i<=high;i++)arr[i]=v[i-low];
}

   void mergesort(vector<int>&arr,int low,int high,int &cnt){
       if(low<high){
      int mid=low+(high-low)/2;
      mergesort(arr,low,mid,cnt);
      mergesort(arr,mid+1,high,cnt);
      merge(arr,low,mid,high,cnt);
       }
   }
    int reversePairs(vector<int>& arr) {
    int cnt=0;
    int n=arr.size();
    mergesort(arr,0,n-1,cnt);
    if(n<=1 or cnt==0)return 0;
    return cnt;
        
    }
};",None,"class Solution {
public:
void merge(vector<int>&arr,int low,int mid,int high,int &cnt){
    int i=low,j=mid+1;
    int r=j;
    vector<int>v;
     while(i<=mid){
        while(r<=high and arr[i]>(long long)2*arr[r]){
            r++;
        }
        cnt+=r-j;
        
          while(j<=r and arr[j]<=arr[i])v.push_back(arr[j++]);
          v.push_back(arr[i++]);
     }
     while(j<=high)v.push_back(arr[j++]);
     for(int i=low;i<=high;i++)arr[i]=v[i-low];
}

   void mergesort(vector<int>&arr,int low,int high,int &cnt){
       if(low<high){
      int mid=low+(high-low)/2;
      mergesort(arr,low,mid,cnt);
      mergesort(arr,mid+1,high,cnt);
      merge(arr,low,mid,high,cnt);
       }
   }
    int reversePairs(vector<int>& arr) {
    int cnt=0;
    int n=arr.size();
    mergesort(arr,0,n-1,cnt);
    if(n<=1 or cnt==0)return 0;
    return cnt;
        
    }
};
"
384,cpp,sort-colors,"class Solution {
public:
    void sortColors(vector<int>& nums) {
        int temp = 0;
        for(int i=0; i<=nums.size(); i++){
            for(int j=i+1; j<=nums.size(); j++){
                if(nums[i]>nums[j]){
                    temp = nums[j];
                    nums[j] = nums[i];
                    nums[i] = temp;
                }
            }
        }
    }
};",None,"class Solution {
public:
    void sortColors(vector<int>& nums) {
        int temp = 0;
        for(int i=0; i<nums.size(); i++){
            for(int j=0; j<nums.size()-1; j++){
                if(nums[j]>nums[j+1]){
                    temp = nums[j+1];
                    nums[j+1] = nums[j];
                    nums[j] = temp;
                }
            }
        }
    }
};
"
384,cpp,sort-colors,"class Solution {
public:
    void sortColors(vector<int>& nums) {
        int temp = 0;
        for(int i=0; i<=nums.size(); i++){
            for(int j=i+1; j<=nums.size(); j++){
                if(nums[i]>nums[j]){
                    temp = nums[j];
                    nums[j] = nums[i];
                    nums[i] = temp;
                }
            }
        }
    }
};",None,"class Solution {
public:
    void sortColors(vector<int>& nums) {
        int temp = 0;
        for(int i=0; i<nums.size(); i++){
            for(int j=0; j<nums.size()-1; j++){
                if(nums[j]>nums[j+1]){
                    temp = nums[j+1];
                    nums[j+1] = nums[j];
                    nums[j] = temp;
                }
            }
        }
    }
};
"
384,cpp,sort-colors,"class Solution {
public:
    void sortColors(vector<int>& nums) {
        int temp = 0;
        for(int i=0; i<=nums.size(); i++){
            for(int j=i+1; j<=nums.size(); j++){
                if(nums[i]>nums[j]){
                    temp = nums[j];
                    nums[j] = nums[i];
                    nums[i] = temp;
                }
            }
        }
    }
};",None,"class Solution {
public:
    void sortColors(vector<int>& nums) {
        int temp = 0;
        for(int i=0; i<nums.size(); i++){
            for(int j=0; j<nums.size()-1; j++){
                if(nums[j]>nums[j+1]){
                    temp = nums[j+1];
                    nums[j+1] = nums[j];
                    nums[j] = temp;
                }
            }
        }
    }
};
"
385,cpp,cherry-pickup-ii,"class Solution {
public:
    int f(int i, int j1, int j2, int r, int c, vector<vector<int>>& grid, vector<vector<vector<int>>>& dp)
    {
        if(j1<0 || j2<0 || j1>=c || j2>=c) return -1e8;
        if(i==r-1)
        {
            if(j1==j2) return grid[i][j1];
            else return grid[i][j1]+grid[i][j2];
        }
        
        if(dp[i][j1][j2]!=-1) return dp[i][j1][j2];
        
        int maxi=-1e8;
        for(int dj1=0; dj1<=1; dj1++)
        {
            for(int dj2=0; dj2<=1; dj2++)
            {
                int value=0;
                if(j1==j2) value=grid[i][j1];
                else value=grid[i][j1]+grid[i][j2];
                value+=f(i+1, j1+dj1, j2+dj2, r, c, grid, dp);
                maxi=max(maxi, value);
            }
        }
        return dp[i][j1][j2]=maxi;
    }
    
    int cherryPickup(vector<vector<int>>& grid) {
        int r=grid.size();
        int c=grid[0].size();
        vector<vector<vector<int>>> dp(r, vector<vector<int>>(c, vector<int>(c, -1)));
        return f(0, 0, c-1, r, c, grid, dp);
    }
};",None,"class Solution {
public:
    int f(int i, int j1, int j2, int r, int c, vector<vector<int>>& grid, vector<vector<vector<int>>>& dp)
    {
        if(j1<0 || j2<0 || j1>=c || j2>=c) return -1e8;
        if(i==r)
        {
            if(j1==j2) return grid[i-1][j1];
            else return grid[i-1][j1]+grid[i-1][j2];
        }
        
        if(dp[i][j1][j2]!=-1) return dp[i][j1][j2];
        
        int maxi=-1e8;
        for(int dj1=0; dj1<=1; dj1++)
        {
            for(int dj2=0; dj2<=1; dj2++)
            {
                int value=0;
                if(j1==j2) value=grid[i-1][j1];
                else value=grid[i-1][j1]+grid[i-1][j2];
                if(i+1 < r)
                    value+=f(i+1, j1+dj1, j2+dj2, r, c, grid, dp);
                else
                    value+= (j1+dj1 == j2+dj2) ? grid[i-1][j1+dj1] : grid[i-1][j1+dj1] + grid[i-1][j2+dj2];
                maxi=max(maxi, value);
            }
        }
        return dp[i][j1][j2]=maxi;
    }
    
    int cherryPickup(vector<vector<int>>& grid) {
        int r=grid.size();
        int c=grid[0].size();
        vector<vector<vector<int>>> dp(r, vector<vector<int>>(c, vector<int>(c, -1)));
        return f(1, 0, c-1, r, c, grid, dp);
    }
};
"
385,cpp,cherry-pickup-ii,"class Solution {
public:
    int f(int i, int j1, int j2, int r, int c, vector<vector<int>>& grid, vector<vector<vector<int>>>& dp)
    {
        if(j1<0 || j2<0 || j1>=c || j2>=c) return -1e8;
        if(i==r-1)
        {
            if(j1==j2) return grid[i][j1];
            else return grid[i][j1]+grid[i][j2];
        }
        
        if(dp[i][j1][j2]!=-1) return dp[i][j1][j2];
        
        int maxi=-1e8;
        for(int dj1=0; dj1<=1; dj1++)
        {
            for(int dj2=0; dj2<=1; dj2++)
            {
                int value=0;
                if(j1==j2) value=grid[i][j1];
                else value=grid[i][j1]+grid[i][j2];
                value+=f(i+1, j1+dj1, j2+dj2, r, c, grid, dp);
                maxi=max(maxi, value);
            }
        }
        return dp[i][j1][j2]=maxi;
    }
    
    int cherryPickup(vector<vector<int>>& grid) {
        int r=grid.size();
        int c=grid[0].size();
        vector<vector<vector<int>>> dp(r, vector<vector<int>>(c, vector<int>(c, -1)));
        return f(0, 0, c-1, r, c, grid, dp);
    }
};",None,"class Solution {
public:
    int f(int i, int j1, int j2, vector<vector<int>>& grid, vector<vector<int>>& dp)
    {
        if(j1<0 || j2<0 || j1>=grid[0].size() || j2>=grid[0].size()) return -1e8;
        if(i==grid.size()-1)
        {
            if(j1==j2) return grid[i][j1];
            else return grid[i][j1]+grid[i][j2];
        }
        
        if(dp[i][j1*grid[0].size() + j2]!=-1) return dp[i][j1*grid[0].size() + j2];
        
        int maxi=-1e8;
        for(int dj1=0; dj1<=1; dj1++)
        {
            for(int dj2=0; dj2<=1; dj2++)
            {
                int value=0;
                if(j1==j2) value=grid[i][j1];
                else value=grid[i][j1]+grid[i][j2];
                if(j1+dj1>=0 && j1+dj1<grid[0].size() && j2+dj2>=0 && j2+dj2<grid[0].size())
                    value+=f(i+1, j1+dj1, j2+dj2, grid, dp);
                maxi=max(maxi, value);
            }
        }
        return dp[i][j1*grid[0].size() + j2]=maxi;
    }
    
    int cherryPickup(vector<vector<int>>& grid) {
        int r=grid.size();
        int c=grid[0].size();
        vector<vector<int>> dp(r, vector<int>(c*c, -1));
        return f(0, 0, c-1, grid, dp);
    }
};
"
385,cpp,cherry-pickup-ii,"class Solution {
public:
    int f(int i, int j1, int j2, int r, int c, vector<vector<int>>& grid, vector<vector<vector<int>>>& dp)
    {
        if(j1<0 || j2<0 || j1>=c || j2>=c) return -1e8;
        if(i==r-1)
        {
            if(j1==j2) return grid[i][j1];
            else return grid[i][j1]+grid[i][j2];
        }
        
        if(dp[i][j1][j2]!=-1) return dp[i][j1][j2];
        
        int maxi=-1e8;
        for(int dj1=0; dj1<=1; dj1++)
        {
            for(int dj2=0; dj2<=1; dj2++)
            {
                int value=0;
                if(j1==j2) value=grid[i][j1];
                else value=grid[i][j1]+grid[i][j2];
                value+=f(i+1, j1+dj1, j2+dj2, r, c, grid, dp);
                maxi=max(maxi, value);
            }
        }
        return dp[i][j1][j2]=maxi;
    }
    
    int cherryPickup(vector<vector<int>>& grid) {
        int r=grid.size();
        int c=grid[0].size();
        vector<vector<vector<int>>> dp(r, vector<vector<int>>(c, vector<int>(c, -1)));
        return f(0, 0, c-1, r, c, grid, dp);
    }
};",None,"class Solution {
public:
    int f(int i, int j1, int j2, int r, int c, vector<vector<int>>& grid, vector<vector<vector<int>>>& dp)
    {
        if(j1<0 || j2<0 || j1>=c || j2>=c) return -1e8;
        if(i==r)
        {
            if(j1==j2) return grid[i-1][j1];
            else return grid[i-1][j1]+grid[i-1][j2];
        }
        
        if(dp[i][j1][j2]!=-1) return dp[i][j1][j2];
        
        int maxi=-1e8;
        for(int dj1=0; dj1<=1; dj1++)
        {
            for(int dj2=0; dj2<=1; dj2++)
            {
                int value=0;
                if(j1==j2) value=grid[i-1][j1];
                else value=grid[i-1][j1]+grid[i-1][j2];
                if(i+1<r)
                    value+=f(i+1, j1+dj1, j2+dj2, r, c, grid, dp);
                maxi=max(maxi, value);
            }
        }
        return dp[i][j1][j2]=maxi;
    }
    
    int cherryPickup(vector<vector<int>>& grid) {
        int r=grid.size();
        int c=grid[0].size();
        vector<vector<vector<int>>> dp(r+1, vector<vector<int>>(c, vector<int>(c, -1)));
        return f(1, 0, c-1, r, c, grid, dp);
    }
};
"
386,cpp,add-binary,"class Solution {
public:
    string addBinary(string a, string b) {
        int c=0;
        string s="""";
        int i=0;
        while(i<a.length() || i<b.length() || c!=0){
            int x=0;
            if(i<a.length() && a[i]=='1')
                x=1;
            int y=0;
            if(i<b.length() && b[i]=='1')
                y=1;
            s=to_string((x+y+c)%2)+s;
            c=(x+y+c)/2;
            i++;
        }
        return s;
    }
};",None,"class Solution {
public:
    string addBinary(string a, string b) {
        int c=0;
        string s="""";
        int i=a.length()-1;
        int j=b.length()-1;
        while(i>=0 || j>=0 || c!=0){
            int x=0;
            if(i>=0)
                x = a[i--] - '0';
            int y=0;
            if(j>=0)
                y = b[j--] - '0';
            s = to_string((x+y+c)%2) + s;
            c = (x+y+c)/2;
        }
        return s;
    }
};
"
386,cpp,add-binary,"class Solution {
public:
    string addBinary(string a, string b) {
        int c=0;
        string s="""";
        int i=0;
        while(i<a.length() || i<b.length() || c!=0){
            int x=0;
            if(i<a.length() && a[i]=='1')
                x=1;
            int y=0;
            if(i<b.length() && b[i]=='1')
                y=1;
            s=to_string((x+y+c)%2)+s;
            c=(x+y+c)/2;
            i++;
        }
        return s;
    }
};",None,"class Solution {
public:
    string addBinary(string a, string b) {
        int c=0;
        string s="""";
        int i=a.length()-1;
        int j=b.length()-1;
        while(i>=0 || j>=0 || c!=0){
            int x=0;
            if(i>=0)
                x = a[i]-'0';
            int y=0;
            if(j>=0)
                y = b[j]-'0';
            s=to_string((x+y+c)%2)+s;
            c=(x+y+c)/2;
            i--;
            j--;
        }
        return s;
    }
};
"
386,cpp,add-binary,"class Solution {
public:
    string addBinary(string a, string b) {
        int c=0;
        string s="""";
        int i=0;
        while(i<a.length() || i<b.length() || c!=0){
            int x=0;
            if(i<a.length() && a[i]=='1')
                x=1;
            int y=0;
            if(i<b.length() && b[i]=='1')
                y=1;
            s=to_string((x+y+c)%2)+s;
            c=(x+y+c)/2;
            i++;
        }
        return s;
    }
};",None,"class Solution {
public:
    string addBinary(string a, string b) {
        int c=0;
        string s="""";
        int i=a.length()-1;
        int j=b.length()-1;
        while(i>=0 || j>=0 || c!=0){
            int x=0;
            if(i>=0)
                x = a[i]-'0';
            int y=0;
            if(j>=0)
                y = b[j]-'0';
            s=to_string((x+y+c)%2)+s;
            c=(x+y+c)/2;
            i--;
            j--;
        }
        return s;
    }
};
"
387,cpp,apply-operations-to-an-array,"class Solution {
public:
    vector<int> applyOperations(vector<int>& nums) {
        for(int i =0 ;i<nums.size()-1;i++){
            if(nums[i] == nums[i+1]){
                nums[i] *=2;
                nums[i+1] = 0;
            }
        };
        vector<int> ans;
        for(auto ele:nums){
            if(ele!=0)ans.push_back(ele);
        };
        for(auto ele:ans){
            if(ele == 0)ans.push_back(ele);
        };
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> applyOperations(vector<int>& nums) {
        for(int i =0 ;i<nums.size()-1;i++){
            if(nums[i] == nums[i+1]){
                nums[i] *=2;
                nums[i+1] = 0;
            }
        }
        vector<int> ans;
        for(auto ele:nums){
            if(ele!=0)ans.push_back(ele);
        }
        for(int i = ans.size(); i < nums.size(); i++){
            ans.push_back(0);
        }
        return ans;
    }
};
"
387,cpp,apply-operations-to-an-array,"class Solution {
public:
    vector<int> applyOperations(vector<int>& nums) {
        for(int i =0 ;i<nums.size()-1;i++){
            if(nums[i] == nums[i+1]){
                nums[i] *=2;
                nums[i+1] = 0;
            }
        };
        vector<int> ans;
        for(auto ele:nums){
            if(ele!=0)ans.push_back(ele);
        };
        for(auto ele:ans){
            if(ele == 0)ans.push_back(ele);
        };
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> applyOperations(vector<int>& nums) {
        for(int i =0 ;i<nums.size()-1;i++){
            if(nums[i] == nums[i+1]){
                nums[i] *=2;
                nums[i+1] = 0;
            }
        };
        vector<int> ans;
        for(auto ele:nums){
            if(ele!=0)ans.push_back(ele);
        };
        for(int i = ans.size(); i < nums.size(); i++) {
            ans.push_back(0);
        }
        return ans;
    }
};
"
387,cpp,apply-operations-to-an-array,"class Solution {
public:
    vector<int> applyOperations(vector<int>& nums) {
        for(int i =0 ;i<nums.size()-1;i++){
            if(nums[i] == nums[i+1]){
                nums[i] *=2;
                nums[i+1] = 0;
            }
        };
        vector<int> ans;
        for(auto ele:nums){
            if(ele!=0)ans.push_back(ele);
        };
        for(auto ele:ans){
            if(ele == 0)ans.push_back(ele);
        };
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> applyOperations(vector<int>& nums) {
        for(int i =0 ;i<nums.size()-1;i++){
            if(nums[i] == nums[i+1]){
                nums[i] *=2;
                nums[i+1] = 0;
            }
        }
        vector<int> ans;
        for(auto ele:nums){
            if(ele!=0)ans.push_back(ele);
        }
        for(int i = ans.size(); i<nums.size();i++){
            ans.push_back(0);
        }
        return ans;
    }
};
"
388,cpp,divide-array-in-sets-of-k-consecutive-numbers,"class Solution {
public:
     bool isPossibleDivide(vector<int>& nums, int k) {
         map<int,int> map;
         for(int num : nums){
             map[num]++;
         }
         while(map.size()!=0){
             int first = map.begin()->first;
             for(int i=first; i<first+k-1; i++){
                 if(!map.count(i)){
                     return false;
                 }
                 map[i]--;
                 if(map[i]==0){
                     map.erase(i);
                 }
             }
         }
         return true;
     }
 };",None,"class Solution {
public:
     bool isPossibleDivide(vector<int>& nums, int k) {
         map<int,int> map;
         for(int num : nums){
             map[num]++;
         }
         while(map.size()!=0){
             int first = map.begin()->first;
             for(int i=first; i<first+k; i++){
                 if(!map.count(i)){
                     return false;
                 }
                 map[i]--;
                 if(map[i]==0){
                     map.erase(i);
                 }
             }
         }
         return true;
     }
 };
"
388,cpp,divide-array-in-sets-of-k-consecutive-numbers,"class Solution {
public:
     bool isPossibleDivide(vector<int>& nums, int k) {
         map<int,int> map;
         for(int num : nums){
             map[num]++;
         }
         while(map.size()!=0){
             int first = map.begin()->first;
             for(int i=first; i<first+k-1; i++){
                 if(!map.count(i)){
                     return false;
                 }
                 map[i]--;
                 if(map[i]==0){
                     map.erase(i);
                 }
             }
         }
         return true;
     }
 };",None,"class Solution {
public:
     bool isPossibleDivide(vector<int>& nums, int k) {
         map<int,int> map;
         for(int num : nums){
             map[num]++;
         }
         while(map.size()!=0){
             int first = map.begin()->first;
             for(int i=first; i<first+k; i++){
                 if(!map.count(i)){
                     return false;
                 }
                 map[i]--;
                 if(map[i]==0){
                     map.erase(i);
                 }
             }
         }
         return true;
     }
 };
"
388,cpp,divide-array-in-sets-of-k-consecutive-numbers,"class Solution {
public:
     bool isPossibleDivide(vector<int>& nums, int k) {
         map<int,int> map;
         for(int num : nums){
             map[num]++;
         }
         while(map.size()!=0){
             int first = map.begin()->first;
             for(int i=first; i<first+k-1; i++){
                 if(!map.count(i)){
                     return false;
                 }
                 map[i]--;
                 if(map[i]==0){
                     map.erase(i);
                 }
             }
         }
         return true;
     }
 };",None,"class Solution {
public:
     bool isPossibleDivide(vector<int>& nums, int k) {
         map<int,int> map;
         for(int num : nums){
             map[num]++;
         }
         while(map.size()!=0){
             int first = map.begin()->first;
             for(int i=first; i<first+k; i++){
                 if(!map.count(i)){
                     return false;
                 }
                 map[i]--;
                 if(map[i]==0){
                     map.erase(i);
                 }
             }
         }
         return true;
     }
 };
"
389,cpp,maximum-frequency-stack,"class FreqStack {
public:
    
    unordered_map<int,int> mp; 
    unordered_map<int,int> freq; 
    set<pair<int,int>> s; 
    int x=0; 

    FreqStack() {
        
    }
    
    void push(int val) {
        freq[val]++; 
        mp[x]=val;
        s.insert({freq[val],x++});
    }
    
    int pop() {
        auto it2=s.end(); 
        auto it=*(it2);
        s.erase(it); 
        int f=it.first;
        int cur_x=it.second;
        int val=mp[cur_x];
        freq[val]--;
        return val;
    }
};",None,"class FreqStack {
public:
    unordered_map<int, int> freq;
    unordered_map<int, stack<int>> group;
    int max_freq = 0;

    FreqStack() {}

    void push(int val) {
        freq[val]++;
        max_freq = max(max_freq, freq[val]);
        group[freq[val]].push(val);
    }

    int pop() {
        int val = group[max_freq].top();
        group[max_freq].pop();
        if (group[max_freq].empty()) {
            max_freq--;
        }
        freq[val]--;
        return val;
    }
};
"
389,cpp,maximum-frequency-stack,"class FreqStack {
public:
    
    unordered_map<int,int> mp; 
    unordered_map<int,int> freq; 
    set<pair<int,int>> s; 
    int x=0; 

    FreqStack() {
        
    }
    
    void push(int val) {
        freq[val]++; 
        mp[x]=val;
        s.insert({freq[val],x++});
    }
    
    int pop() {
        auto it2=s.end(); 
        auto it=*(it2);
        s.erase(it); 
        int f=it.first;
        int cur_x=it.second;
        int val=mp[cur_x];
        freq[val]--;
        return val;
    }
};",None,"class FreqStack {
public:
    unordered_map<int, int> freq;
    unordered_map<int, stack<int>> group;
    int max_freq = 0;

    FreqStack() {}

    void push(int val) {
        freq[val]++;
        max_freq = max(max_freq, freq[val]);
        group[freq[val]].push(val);
    }

    int pop() {
        int val = group[max_freq].top();
        group[max_freq].pop();
        if (group[max_freq].empty()) max_freq--;
        freq[val]--;
        return val;
    }
};
"
389,cpp,maximum-frequency-stack,"class FreqStack {
public:
    
    unordered_map<int,int> mp; 
    unordered_map<int,int> freq; 
    set<pair<int,int>> s; 
    int x=0; 

    FreqStack() {
        
    }
    
    void push(int val) {
        freq[val]++; 
        mp[x]=val;
        s.insert({freq[val],x++});
    }
    
    int pop() {
        auto it2=s.end(); 
        auto it=*(it2);
        s.erase(it); 
        int f=it.first;
        int cur_x=it.second;
        int val=mp[cur_x];
        freq[val]--;
        return val;
    }
};",None,"class FreqStack {
public:
    unordered_map<int, int> freq;
    unordered_map<int, stack<int>> group;
    int max_freq = 0;

    FreqStack() {}

    void push(int val) {
        freq[val]++;
        max_freq = max(max_freq, freq[val]);
        group[freq[val]].push(val);
    }

    int pop() {
        int val = group[max_freq].top();
        group[max_freq].pop();
        if (group[max_freq].empty()) {
            max_freq--;
        }
        freq[val]--;
        return val;
    }
};
"
390,cpp,closest-prime-numbers-in-range,"class Solution 
{
public:
    vector<int> closestPrimes(int left, int right) 
    {
        vector<int> nums(right+1, 1);
        for(int i=2; i*i<=right; i++)
        {
            if(nums[i]==1)
            {
                for(int j=i*i; j<=right; j+=i)
                    nums[j]=0;
            }
        }

        vector<int> prime;
        for(int i=max(2,left); i<=right; i++)
        {
            if(nums[i]==1) prime.push_back(i);
        }

        int n1=-1, n2=-1, mini=1e8, diff;
        for(int i=0; i<prime.size(); i++)
        {
            diff = prime[i]-prime[i-1];
            if(diff < mini)
            {
                mini = diff;
                n1 = prime[i-1];
                n2 = prime[i];
            }
        }
        return {n1, n2};
    }
};",None,"class Solution 
{
public:
    vector<int> closestPrimes(int left, int right) 
    {
        vector<int> nums(right+1, 1);
        for(int i=2; i*i<=right; i++)
        {
            if(nums[i]==1)
            {
                for(int j=i*i; j<=right; j+=i)
                    nums[j]=0;
            }
        }

        vector<int> prime;
        for(int i=max(2,left); i<=right; i++)
        {
            if(nums[i]==1) prime.push_back(i);
        }

        int n1=-1, n2=-1, mini=1e8, diff;
        for(int i=1; i<prime.size(); i++)
        {
            diff = prime[i]-prime[i-1];
            if(diff < mini)
            {
                mini = diff;
                n1 = prime[i-1];
                n2 = prime[i];
            }
        }
        return {n1, n2};
    }
};
"
390,cpp,closest-prime-numbers-in-range,"class Solution 
{
public:
    vector<int> closestPrimes(int left, int right) 
    {
        vector<int> nums(right+1, 1);
        for(int i=2; i*i<=right; i++)
        {
            if(nums[i]==1)
            {
                for(int j=i*i; j<=right; j+=i)
                    nums[j]=0;
            }
        }

        vector<int> prime;
        for(int i=max(2,left); i<=right; i++)
        {
            if(nums[i]==1) prime.push_back(i);
        }

        int n1=-1, n2=-1, mini=1e8, diff;
        for(int i=0; i<prime.size(); i++)
        {
            diff = prime[i]-prime[i-1];
            if(diff < mini)
            {
                mini = diff;
                n1 = prime[i-1];
                n2 = prime[i];
            }
        }
        return {n1, n2};
    }
};",None,"class Solution 
{
public:
    vector<int> closestPrimes(int left, int right) 
    {
        vector<int> nums(right+1, 1);
        for(int i=2; i*i<=right; i++)
        {
            if(nums[i]==1)
            {
                for(int j=i*i; j<=right; j+=i)
                    nums[j]=0;
            }
        }

        vector<int> prime;
        for(int i=max(2,left); i<=right; i++)
        {
            if(nums[i]==1) prime.push_back(i);
        }

        int n1=-1, n2=-1, mini=INT_MAX, diff;
        for(int i=0; i<prime.size()-1; i++)
        {
            diff = prime[i+1]-prime[i];
            if(diff < mini)
            {
                mini = diff;
                n1 = prime[i];
                n2 = prime[i+1];
            }
        }
        return {n1, n2};
    }
};
"
390,cpp,closest-prime-numbers-in-range,"class Solution 
{
public:
    vector<int> closestPrimes(int left, int right) 
    {
        vector<int> nums(right+1, 1);
        for(int i=2; i*i<=right; i++)
        {
            if(nums[i]==1)
            {
                for(int j=i*i; j<=right; j+=i)
                    nums[j]=0;
            }
        }

        vector<int> prime;
        for(int i=max(2,left); i<=right; i++)
        {
            if(nums[i]==1) prime.push_back(i);
        }

        int n1=-1, n2=-1, mini=1e8, diff;
        for(int i=0; i<prime.size(); i++)
        {
            diff = prime[i]-prime[i-1];
            if(diff < mini)
            {
                mini = diff;
                n1 = prime[i-1];
                n2 = prime[i];
            }
        }
        return {n1, n2};
    }
};",None,"class Solution 
{
public:
    vector<int> closestPrimes(int left, int right) 
    {
        vector<int> nums(right+1, 1);
        for(int i=2; i*i<=right; i++)
        {
            if(nums[i]==1)
            {
                for(int j=i*i; j<=right; j+=i)
                    nums[j]=0;
            }
        }

        vector<int> prime;
        for(int i=max(2,left); i<=right; i++)
        {
            if(nums[i]==1) prime.push_back(i);
        }

        int n1=-1, n2=-1, mini=INT_MAX, diff;
        for(int i=1; i<prime.size(); i++)
        {
            diff = prime[i]-prime[i-1];
            if(diff < mini)
            {
                mini = diff;
                n1 = prime[i-1];
                n2 = prime[i];
            }
        }
        return {n1, n2};
    }
};
"
391,cpp,bitwise-and-of-numbers-range,"class Solution {
public:
    int solve(int left , int right){
        if(left == 0)return 0;
        int bit1 = log2(left);
        int bit2 = log2(right);
        if(bit1 < bit2)return 1;
        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); 
    }
    int rangeBitwiseAnd(int left, int right) {
         return solve(left , right);
    }
};",None,"class Solution {
public:
    int solve(int left , int right){
        if(left == 0)return 0;
        int bit1 = log2(left);
        int bit2 = log2(right);
        if(bit1 < bit2)return 1 << bit1;
        return (1<<bit1) & solve((left^(1<<bit1)) , (right^(1<<bit1))); 
    }
    int rangeBitwiseAnd(int left, int right) {
         return solve(left , right);
    }
};
"
391,cpp,bitwise-and-of-numbers-range,"class Solution {
public:
    int solve(int left , int right){
        if(left == 0)return 0;
        int bit1 = log2(left);
        int bit2 = log2(right);
        if(bit1 < bit2)return 1;
        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); 
    }
    int rangeBitwiseAnd(int left, int right) {
         return solve(left , right);
    }
};",None,"class Solution {
public:
    int solve(int left , int right){
        if(left == 0) return 0;
        int bit = 0;
        while(left <= right && (left & 1) == 0){
            left >>= 1;
            right >>= 1;
            bit++;
        }
        if(left > right) return 0;
        return (1 << bit) & right;
    }
    int rangeBitwiseAnd(int left, int right) {
         return solve(left , right);
    }
};
"
391,cpp,bitwise-and-of-numbers-range,"class Solution {
public:
    int solve(int left , int right){
        if(left == 0)return 0;
        int bit1 = log2(left);
        int bit2 = log2(right);
        if(bit1 < bit2)return 1;
        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); 
    }
    int rangeBitwiseAnd(int left, int right) {
         return solve(left , right);
    }
};",None,"class Solution {
public:
    int solve(int left , int right){
        if(left == 0) return 0;
        int bit = 0;
        while(left <= right && (left & 1) == 0){
            bit++;
            left >>= 1;
            right >>= 1;
        }
        return left << bit;
    }
    int rangeBitwiseAnd(int left, int right) {
         return solve(left , right);
    }
};
"
392,cpp,kids-with-the-greatest-number-of-candies,"class Solution {
public:
    vector<bool> kidsWithCandies(vector<int>& c, int ec) {
        int maxi = INT_MIN;
        for(int i = 0;i<c.size();i++){
            if(maxi<c[i]){
                maxi = c[i];
            }
        }
        vector<bool>ans;
        for(int i = 0;i<c.size();i++){
            if(c[i] + ec > maxi){
                ans.push_back(1);
            }
            else{
                ans.push_back(0);
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<bool> kidsWithCandies(vector<int>& candies, int extraCandies) {
        int maxCandies = *max_element(candies.begin(), candies.end());
        vector<bool> result(candies.size());
        for (int i = 0; i < candies.size(); ++i) {
            result[i] = (candies[i] + extraCandies >= maxCandies);
        }
        return result;
    }
};
"
392,cpp,kids-with-the-greatest-number-of-candies,"class Solution {
public:
    vector<bool> kidsWithCandies(vector<int>& c, int ec) {
        int maxi = INT_MIN;
        for(int i = 0;i<c.size();i++){
            if(maxi<c[i]){
                maxi = c[i];
            }
        }
        vector<bool>ans;
        for(int i = 0;i<c.size();i++){
            if(c[i] + ec > maxi){
                ans.push_back(1);
            }
            else{
                ans.push_back(0);
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<bool> kidsWithCandies(vector<int>& candies, int extraCandies) {
        int max_candies = *max_element(candies.begin(), candies.end());
        vector<bool> result(candies.size());
        for (int i = 0; i < candies.size(); ++i) {
            result[i] = (candies[i] + extraCandies >= max_candies);
        }
        return result;
    }
};
"
392,cpp,kids-with-the-greatest-number-of-candies,"class Solution {
public:
    vector<bool> kidsWithCandies(vector<int>& c, int ec) {
        int maxi = INT_MIN;
        for(int i = 0;i<c.size();i++){
            if(maxi<c[i]){
                maxi = c[i];
            }
        }
        vector<bool>ans;
        for(int i = 0;i<c.size();i++){
            if(c[i] + ec > maxi){
                ans.push_back(1);
            }
            else{
                ans.push_back(0);
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<bool> kidsWithCandies(vector<int>& candies, int extraCandies) {
        int max_candies = *max_element(candies.begin(), candies.end());
        vector<bool> result(candies.size());

        for (int i = 0; i < candies.size(); i++) {
            result[i] = (candies[i] + extraCandies >= max_candies);
        }

        return result;
    }
};
"
393,cpp,add-two-numbers,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* temp=l1;
        ListNode* tem=l2;
        ListNode *ans;
        ListNode *head;
        int carry=0;
        int valu;
        int sum=tem->val+temp->val+carry;
        valu=sum%10;
        carry=sum/10;
        ListNode* node =new ListNode(valu);
        ans=node;
        head=ans;
        tem=tem->next;
        temp=temp->next;
        while(tem!=NULL && temp!=NULL)
        {
            sum=tem->val+temp->val+carry;
            valu=sum%10;
            carry=sum/10;
            ListNode* node =new ListNode(valu);
            ans->next=node;
            ans=ans->next;
            temp=temp->next;
            tem=tem->next;
        }
        if(tem==NULL && temp!=NULL)
        {
            while(temp!=NULL)
            {
                sum=temp->val+carry;
                valu=sum%10;
                carry=sum/10;
                ListNode* node =new ListNode(valu);
                ans->next=node;
                ans=ans->next;
                temp=temp->next;
            }
        }
        if(tem!=NULL && temp==NULL)
        {
            while(tem!=NULL)
            {
                sum=tem->val+carry;
                valu=sum%10;
                carry=sum/10;
                ListNode* node =new ListNode(valu);
                ans->next=node;
                ans=ans->next;
                tem=tem->next;
            }
        }
        if(carry=0)
        {
            ListNode* node =new ListNode(carry);
            ans->next=node;
        }
        return head;
    }
};",None,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* temp=l1;
        ListNode* tem=l2;
        ListNode *ans;
        ListNode *head;
        int carry=0;
        int valu;
        int sum=tem->val+temp->val+carry;
        valu=sum%10;
        carry=sum/10;
        ListNode* node =new ListNode(valu);
        ans=node;
        head=ans;
        tem=tem->next;
        temp=temp->next;
        while(tem!=NULL && temp!=NULL)
        {
            sum=tem->val+temp->val+carry;
            valu=sum%10;
            carry=sum/10;
            ListNode* node =new ListNode(valu);
            ans->next=node;
            ans=ans->next;
            temp=temp->next;
            tem=tem->next;
        }
        if(tem==NULL && temp!=NULL)
        {
            while(temp!=NULL)
            {
                sum=temp->val+carry;
                valu=sum%10;
                carry=sum/10;
                ListNode* node =new ListNode(valu);
                ans->next=node;
                ans=ans->next;
                temp=temp->next;
            }
        }
        if(tem!=NULL && temp==NULL)
        {
            while(tem!=NULL)
            {
                sum=tem->val+carry;
                valu=sum%10;
                carry=sum/10;
                ListNode* node =new ListNode(valu);
                ans->next=node;
                ans=ans->next;
                tem=tem->next;
            }
        }
        if(carry>0)
        {
            ListNode* node =new ListNode(carry);
            ans->next=node;
        }
        return head;
    }
};
"
393,cpp,add-two-numbers,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* temp=l1;
        ListNode* tem=l2;
        ListNode *ans;
        ListNode *head;
        int carry=0;
        int valu;
        int sum=tem->val+temp->val+carry;
        valu=sum%10;
        carry=sum/10;
        ListNode* node =new ListNode(valu);
        ans=node;
        head=ans;
        tem=tem->next;
        temp=temp->next;
        while(tem!=NULL && temp!=NULL)
        {
            sum=tem->val+temp->val+carry;
            valu=sum%10;
            carry=sum/10;
            ListNode* node =new ListNode(valu);
            ans->next=node;
            ans=ans->next;
            temp=temp->next;
            tem=tem->next;
        }
        if(tem==NULL && temp!=NULL)
        {
            while(temp!=NULL)
            {
                sum=temp->val+carry;
                valu=sum%10;
                carry=sum/10;
                ListNode* node =new ListNode(valu);
                ans->next=node;
                ans=ans->next;
                temp=temp->next;
            }
        }
        if(tem!=NULL && temp==NULL)
        {
            while(tem!=NULL)
            {
                sum=tem->val+carry;
                valu=sum%10;
                carry=sum/10;
                ListNode* node =new ListNode(valu);
                ans->next=node;
                ans=ans->next;
                tem=tem->next;
            }
        }
        if(carry=0)
        {
            ListNode* node =new ListNode(carry);
            ans->next=node;
        }
        return head;
    }
};",None,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* temp=l1;
        ListNode* tem=l2;
        ListNode *ans;
        ListNode *head;
        int carry=0;
        int valu;
        int sum=tem->val+temp->val+carry;
        valu=sum%10;
        carry=sum/10;
        ListNode* node =new ListNode(valu);
        ans=node;
        head=ans;
        tem=tem->next;
        temp=temp->next;
        while(tem!=NULL && temp!=NULL)
        {
            sum=tem->val+temp->val+carry;
            valu=sum%10;
            carry=sum/10;
            ListNode* node =new ListNode(valu);
            ans->next=node;
            ans=ans->next;
            temp=temp->next;
            tem=tem->next;
        }
        if(tem==NULL && temp!=NULL)
        {
            while(temp!=NULL)
            {
                sum=temp->val+carry;
                valu=sum%10;
                carry=sum/10;
                ListNode* node =new ListNode(valu);
                ans->next=node;
                ans=ans->next;
                temp=temp->next;
            }
        }
        if(tem!=NULL && temp==NULL)
        {
            while(tem!=NULL)
            {
                sum=tem->val+carry;
                valu=sum%10;
                carry=sum/10;
                ListNode* node =new ListNode(valu);
                ans->next=node;
                ans=ans->next;
                tem=tem->next;
            }
        }
        if(carry!=0)
        {
            ListNode* node =new ListNode(carry);
            ans->next=node;
        }
        return head;
    }
};
"
393,cpp,add-two-numbers,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* temp=l1;
        ListNode* tem=l2;
        ListNode *ans;
        ListNode *head;
        int carry=0;
        int valu;
        int sum=tem->val+temp->val+carry;
        valu=sum%10;
        carry=sum/10;
        ListNode* node =new ListNode(valu);
        ans=node;
        head=ans;
        tem=tem->next;
        temp=temp->next;
        while(tem!=NULL && temp!=NULL)
        {
            sum=tem->val+temp->val+carry;
            valu=sum%10;
            carry=sum/10;
            ListNode* node =new ListNode(valu);
            ans->next=node;
            ans=ans->next;
            temp=temp->next;
            tem=tem->next;
        }
        if(tem==NULL && temp!=NULL)
        {
            while(temp!=NULL)
            {
                sum=temp->val+carry;
                valu=sum%10;
                carry=sum/10;
                ListNode* node =new ListNode(valu);
                ans->next=node;
                ans=ans->next;
                temp=temp->next;
            }
        }
        if(tem!=NULL && temp==NULL)
        {
            while(tem!=NULL)
            {
                sum=tem->val+carry;
                valu=sum%10;
                carry=sum/10;
                ListNode* node =new ListNode(valu);
                ans->next=node;
                ans=ans->next;
                tem=tem->next;
            }
        }
        if(carry=0)
        {
            ListNode* node =new ListNode(carry);
            ans->next=node;
        }
        return head;
    }
};",None,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* temp=l1;
        ListNode* tem=l2;
        ListNode *ans;
        ListNode *head;
        int carry=0;
        int valu;
        int sum=tem->val+temp->val+carry;
        valu=sum%10;
        carry=sum/10;
        ListNode* node =new ListNode(valu);
        ans=node;
        head=ans;
        tem=tem->next;
        temp=temp->next;
        while(tem!=NULL && temp!=NULL)
        {
            sum=tem->val+temp->val+carry;
            valu=sum%10;
            carry=sum/10;
            ListNode* node =new ListNode(valu);
            ans->next=node;
            ans=ans->next;
            temp=temp->next;
            tem=tem->next;
        }
        if(tem==NULL && temp!=NULL)
        {
            while(temp!=NULL)
            {
                sum=temp->val+carry;
                valu=sum%10;
                carry=sum/10;
                ListNode* node =new ListNode(valu);
                ans->next=node;
                ans=ans->next;
                temp=temp->next;
            }
        }
        if(tem!=NULL && temp==NULL)
        {
            while(tem!=NULL)
            {
                sum=tem->val+carry;
                valu=sum%10;
                carry=sum/10;
                ListNode* node =new ListNode(valu);
                ans->next=node;
                ans=ans->next;
                tem=tem->next;
            }
        }
        if(carry!=0)
        {
            ListNode* node =new ListNode(carry);
            ans->next=node;
        }
        return head;
    }
};
"
394,cpp,power-of-heroes,"class Solution {
    const int M = 1000000007;
    int mul(long long x, long long y) {
        return x * y % M;
    }
    
    int add(int x, int y) {
        if ((x += y) >= M) {
            x -= M;
        }
        return x; 
    }

public:
    int sumOfPower(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        const int n = nums.size();
        int r = mul(mul(nums[0], nums[0]), nums[0]);
        for (int i = 0, last = 0; i < n; ++i) {
            last = add(nums[i - 1], add(last, last));
            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));
        }
        
        return r;
    }
};",None,"class Solution {
    const int M = 1000000007;
    int mul(long long x, long long y) {
        return (int)((x * y) % M);
    }
    
    int add(int x, int y) {
        if ((x += y) >= M) {
            x -= M;
        }
        return x; 
    }

public:
    int sumOfPower(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        const int n = nums.size();
        int r = mul(mul(nums[0], nums[0]), nums[0]);
        for (int i = 1, last = 0; i < n; ++i) {
            last = add(last, nums[i - 1]);
            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));
        }
        
        return r;
    }
};
"
394,cpp,power-of-heroes,"class Solution {
    const int M = 1000000007;
    int mul(long long x, long long y) {
        return x * y % M;
    }
    
    int add(int x, int y) {
        if ((x += y) >= M) {
            x -= M;
        }
        return x; 
    }

public:
    int sumOfPower(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        const int n = nums.size();
        int r = mul(mul(nums[0], nums[0]), nums[0]);
        for (int i = 0, last = 0; i < n; ++i) {
            last = add(nums[i - 1], add(last, last));
            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));
        }
        
        return r;
    }
};",None,"class Solution {
    const int M = 1000000007;
    int mul(long long x, long long y) {
        return (int)((x * y) % M);
    }
    
    int add(int x, int y) {
        if ((x += y) >= M) {
            x -= M;
        }
        return x; 
    }

public:
    int sumOfPower(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        const int n = nums.size();
        if (n == 0) return 0;
        int r = mul(mul(nums[0], nums[0]), nums[0]);
        for (int i = 1; i < n; ++i) {
            r = add(r, mul(add(mul(nums[i], nums[i]), nums[i - 1]), nums[i]));
        }
        
        return r;
    }
};
"
394,cpp,power-of-heroes,"class Solution {
    const int M = 1000000007;
    int mul(long long x, long long y) {
        return x * y % M;
    }
    
    int add(int x, int y) {
        if ((x += y) >= M) {
            x -= M;
        }
        return x; 
    }

public:
    int sumOfPower(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        const int n = nums.size();
        int r = mul(mul(nums[0], nums[0]), nums[0]);
        for (int i = 0, last = 0; i < n; ++i) {
            last = add(nums[i - 1], add(last, last));
            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));
        }
        
        return r;
    }
};",None,"class Solution {
    const int M = 1000000007;
    int mul(long long x, long long y) {
        return (x * y) % M;
    }
    
    int add(int x, int y) {
        if ((x += y) >= M) {
            x -= M;
        }
        return x; 
    }

public:
    int sumOfPower(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        const int n = nums.size();
        int r = mul(mul(nums[0], nums[0]), nums[0]);
        for (int i = 0, last = 0; i < n; ++i) {
            last = add(nums[i - 1], add(last, last));
            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));
        }
        
        return r % M;
    }
};
"
395,cpp,longest-cycle-in-a-graph,"class Solution {
public:
    int mx=-1;
    void dfs(vector<int> &ed , vector<int> &pvis , vector<int> &vis , int i , int j)
    {
        if(pvis[i])
        {
            mx = max(mx , j - pvis[i]);
            return;
        }
        if(!vis[i])
        {
            pvis[i] =j; j++; vis[i]=1;
            if(ed[i]!=-1) dfs(ed , pvis , vis , ed[i],j);
        }
        pvis[i] = 0;
        return;
    }
    int longestCycle(vector<int>& ed)
     {
        vector<int> vis(ed.size(),0) , pvis(ed.size(),0);
        mx = -1;
        for(int i=0;i<=ed.size();i++)
        {
            if(!vis[i]) dfs(ed,pvis,vis,i,1);
        }
        return mx;
    }
};",None,"class Solution {
public:
    int mx=-1;
    void dfs(vector<int> &ed , vector<int> &pvis , vector<bool> &vis , int i , int j)
    {
        if(pvis[i])
        {
            mx = max(mx , j - pvis[i]);
            return;
        }
        if(!vis[i])
        {
            pvis[i] =j; j++; vis[i]=true;
            if(ed[i]!=-1) dfs(ed , pvis , vis , ed[i],j);
        }
        pvis[i] = 0;
        return;
    }
    int longestCycle(vector<int>& ed)
     {
        vector<int> pvis(ed.size(),0);
        vector<bool> vis(ed.size(),false);
        mx = -1;
        for(int i=0;i<ed.size();i++)
        {
            if(!vis[i]) dfs(ed,pvis,vis,i,1);
        }
        return mx;
    }
};
"
395,cpp,longest-cycle-in-a-graph,"class Solution {
public:
    int mx=-1;
    void dfs(vector<int> &ed , vector<int> &pvis , vector<int> &vis , int i , int j)
    {
        if(pvis[i])
        {
            mx = max(mx , j - pvis[i]);
            return;
        }
        if(!vis[i])
        {
            pvis[i] =j; j++; vis[i]=1;
            if(ed[i]!=-1) dfs(ed , pvis , vis , ed[i],j);
        }
        pvis[i] = 0;
        return;
    }
    int longestCycle(vector<int>& ed)
     {
        vector<int> vis(ed.size(),0) , pvis(ed.size(),0);
        mx = -1;
        for(int i=0;i<=ed.size();i++)
        {
            if(!vis[i]) dfs(ed,pvis,vis,i,1);
        }
        return mx;
    }
};",None,"class Solution {
public:
    int mx = -1;
    void dfs(vector<int> &ed, vector<int> &pvis, vector<bool> &vis, int i, int j)
    {
        if (pvis[i])
        {
            mx = max(mx, j - pvis[i]);
            return;
        }
        if (!vis[i])
        {
            pvis[i] = j;
            vis[i] = true;
            if (ed[i] != -1)
                dfs(ed, pvis, vis, ed[i], j + 1);
        }
        pvis[i] = 0;
        return;
    }
    int longestCycle(vector<int>& ed)
    {
        vector<bool> vis(ed.size(), false);
        for (int i = 0; i < ed.size(); i++)
        {
            if (!vis[i])
                dfs(ed, vector<int>(ed.size(), 0), vis, i, 1);
        }
        return mx;
    }
};
"
395,cpp,longest-cycle-in-a-graph,"class Solution {
public:
    int mx=-1;
    void dfs(vector<int> &ed , vector<int> &pvis , vector<int> &vis , int i , int j)
    {
        if(pvis[i])
        {
            mx = max(mx , j - pvis[i]);
            return;
        }
        if(!vis[i])
        {
            pvis[i] =j; j++; vis[i]=1;
            if(ed[i]!=-1) dfs(ed , pvis , vis , ed[i],j);
        }
        pvis[i] = 0;
        return;
    }
    int longestCycle(vector<int>& ed)
     {
        vector<int> vis(ed.size(),0) , pvis(ed.size(),0);
        mx = -1;
        for(int i=0;i<=ed.size();i++)
        {
            if(!vis[i]) dfs(ed,pvis,vis,i,1);
        }
        return mx;
    }
};",None,"class Solution {
public:
    int mx=-1;
    void dfs(vector<int> &ed , vector<int> &pvis , vector<bool> &vis , int i , int j)
    {
        if(pvis[i])
        {
            mx = max(mx , j - pvis[i]);
            return;
        }
        if(!vis[i])
        {
            pvis[i] =j; j++; vis[i]=true;
            if(ed[i]!=-1) dfs(ed , pvis , vis , ed[i],j);
        }
        pvis[i] = 0;
        return;
    }
    int longestCycle(vector<int>& ed)
     {
        vector<bool> vis(ed.size(),false) , pvis(ed.size(),0);
        mx = -1;
        for(int i=0;i<ed.size();i++)
        {
            if(!vis[i]) dfs(ed,pvis,vis,i,1);
        }
        return mx;
    }
};
"
396,cpp,hamming-distance,"class Solution {
public:
    int hammingDistance(int x, int y) {
        int ans=0;
        while(x || y){
            int mask=x&1;
            int mask2=y&1;
            if(mask==mask2){
                ans++;
            }
            x>>=1;
            y>>=1;
        }
        return ans;
    }
};",None,"class Solution {
public:
    int hammingDistance(int x, int y) {
        int ans=0;
        while(x || y){
            int mask=x&1;
            int mask2=y&1;
            ans += (mask ^ mask2);
            x>>=1;
            y>>=1;
        }
        return ans;
    }
};
"
396,cpp,hamming-distance,"class Solution {
public:
    int hammingDistance(int x, int y) {
        int ans=0;
        while(x || y){
            int mask=x&1;
            int mask2=y&1;
            if(mask==mask2){
                ans++;
            }
            x>>=1;
            y>>=1;
        }
        return ans;
    }
};",None,"class Solution {
public:
    int hammingDistance(int x, int y) {
        int ans=0;
        while(x || y){
            int mask=x&1;
            int mask2=y&1;
            ans += (mask ^ mask2); // corrected line
            x>>=1;
            y>>=1;
        }
        return ans;
    }
};
"
396,cpp,hamming-distance,"class Solution {
public:
    int hammingDistance(int x, int y) {
        int ans=0;
        while(x || y){
            int mask=x&1;
            int mask2=y&1;
            if(mask==mask2){
                ans++;
            }
            x>>=1;
            y>>=1;
        }
        return ans;
    }
};",None,"class Solution {
public:
    int hammingDistance(int x, int y) {
        int ans=0;
        while(x || y){
            int mask=x&1;
            int mask2=y&1;
            ans += mask != mask2;
            x>>=1;
            y>>=1;
        }
        return ans;
    }
};
"
397,cpp,pascals-triangle-ii,"class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<vector<int>>v;
        vector<int>e;
        for (int i=0;i<=rowIndex;i++)
        {
            vector<int>a;
            for (int j=0;j<=i;j++)
            {
                if (j==0 || j==i){a.push_back(1);}
                else
                {
                    a.push_back(v[i][j]+v[i-1][j-1]);
                }
            }
            if (i==rowIndex){return a;}
            v.push_back(a);
        }
        return e;
    }
};",None,"class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<vector<int>>v(rowIndex + 1);
        vector<int>e;
        for (int i=0;i<=rowIndex;i++)
        {
            vector<int>a(i+1);
            for (int j=0;j<=i;j++)
            {
                if (j==0 || j==i){a[j] = 1;}
                else
                {
                    a[j] = v[i-1][j-1] + v[i-1][j];
                }
            }
            v[i] = a;
        }
        return v[rowIndex];
    }
};
"
397,cpp,pascals-triangle-ii,"class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<vector<int>>v;
        vector<int>e;
        for (int i=0;i<=rowIndex;i++)
        {
            vector<int>a;
            for (int j=0;j<=i;j++)
            {
                if (j==0 || j==i){a.push_back(1);}
                else
                {
                    a.push_back(v[i][j]+v[i-1][j-1]);
                }
            }
            if (i==rowIndex){return a;}
            v.push_back(a);
        }
        return e;
    }
};",None,"class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<vector<int>>v(rowIndex+1);
        vector<int>e(1,1);
        for (int i=0;i<=rowIndex;i++)
        {
            vector<int>a(i+1,1);
            for (int j=1;j<i;j++)
            {
                a[j] = v[i-1][j-1] + v[i-1][j];
            }
            v[i] = a;
        }
        return v[rowIndex];
    }
};
"
397,cpp,pascals-triangle-ii,"class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<vector<int>>v;
        vector<int>e;
        for (int i=0;i<=rowIndex;i++)
        {
            vector<int>a;
            for (int j=0;j<=i;j++)
            {
                if (j==0 || j==i){a.push_back(1);}
                else
                {
                    a.push_back(v[i][j]+v[i-1][j-1]);
                }
            }
            if (i==rowIndex){return a;}
            v.push_back(a);
        }
        return e;
    }
};",None,"class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<vector<int>>v(rowIndex+1);
        vector<int>e(1,1);
        v[0] = e;
        for (int i=1;i<=rowIndex;i++)
        {
            vector<int>a(i+1,1);
            for (int j=1;j<i;j++)
            {
                a[j] = v[i-1][j-1] + v[i-1][j];
            }
            v[i] = a;
        }
        return v[rowIndex];
    }
};
"
398,cpp,transpose-matrix,"class Solution {
public:
    vector<vector<int>> transpose(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size(); 
        vector<vector<int>> transposed(n, vector<int>(m));
    
        for (int i = 0; i <= m; i++) { 
            for (int j = 0; j < n; j++) {
                transposed[j][i] = matrix[i][j];
            }
        }
        
        return transposed;
    }
};",None,"class Solution {
public:
    vector<vector<int>> transpose(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size(); 
        vector<vector<int>> transposed(n, vector<int>(m));
    
        for (int i = 0; i < m; i++) { 
            for (int j = 0; j < n; j++) {
                transposed[j][i] = matrix[i][j];
            }
        }
        
        return transposed;
    }
};
"
398,cpp,transpose-matrix,"class Solution {
public:
    vector<vector<int>> transpose(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size(); 
        vector<vector<int>> transposed(n, vector<int>(m));
    
        for (int i = 0; i <= m; i++) { 
            for (int j = 0; j < n; j++) {
                transposed[j][i] = matrix[i][j];
            }
        }
        
        return transposed;
    }
};",None,"class Solution {
public:
    vector<vector<int>> transpose(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size(); 
        vector<vector<int>> transposed(n, vector<int>(m));
    
        for (int i = 0; i < m; i++) { 
            for (int j = 0; j < n; j++) {
                transposed[j][i] = matrix[i][j];
            }
        }
        
        return transposed;
    }
};
"
398,cpp,transpose-matrix,"class Solution {
public:
    vector<vector<int>> transpose(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size(); 
        vector<vector<int>> transposed(n, vector<int>(m));
    
        for (int i = 0; i <= m; i++) { 
            for (int j = 0; j < n; j++) {
                transposed[j][i] = matrix[i][j];
            }
        }
        
        return transposed;
    }
};",None,"class Solution {
public:
    vector<vector<int>> transpose(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size(); 
        vector<vector<int>> transposed(n, vector<int>(m));
    
        for (int i = 0; i < m; i++) { 
            for (int j = 0; j < n; j++) {
                transposed[j][i] = matrix[i][j];
            }
        }
        
        return transposed;
    }
};
"
399,cpp,best-time-to-buy-and-sell-stock-with-transaction-fee,"class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        if (n <= 1) return 0;
        int buy = -prices[0];
        int sell = 0;
        for (int i = 1; i < n; i++) {
            int prevBuy = buy;
            buy = max(buy, sell - prices[i]);
            sell = max(sell, prevBuy + prices[i + 1] - fee);
        }
        return sell;
    }
};",None,"class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        if (n <= 1) return 0;
        int buy = -prices[0];
        int sell = 0;
        for (int i = 1; i < n; i++) {
            int prevBuy = buy;
            buy = max(buy, sell - prices[i]);
            sell = max(sell, prevBuy + prices[i] - fee);
        }
        return sell;
    }
};
"
399,cpp,best-time-to-buy-and-sell-stock-with-transaction-fee,"class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        if (n <= 1) return 0;
        int buy = -prices[0];
        int sell = 0;
        for (int i = 1; i < n; i++) {
            int prevBuy = buy;
            buy = max(buy, sell - prices[i]);
            sell = max(sell, prevBuy + prices[i + 1] - fee);
        }
        return sell;
    }
};",None,"class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        if (n <= 1) return 0;
        int buy = -prices[0];
        int sell = 0;
        for (int i = 1; i < n; i++) {
            int prevBuy = buy;
            buy = max(buy, sell - prices[i]);
            sell = max(sell, prevBuy + prices[i] - fee);
        }
        return sell;
    }
};
"
399,cpp,best-time-to-buy-and-sell-stock-with-transaction-fee,"class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        if (n <= 1) return 0;
        int buy = -prices[0];
        int sell = 0;
        for (int i = 1; i < n; i++) {
            int prevBuy = buy;
            buy = max(buy, sell - prices[i]);
            sell = max(sell, prevBuy + prices[i + 1] - fee);
        }
        return sell;
    }
};",None,"class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        if (n <= 1) return 0;
        int buy = -prices[0];
        int sell = 0;
        for (int i = 1; i < n; i++) {
            int prevBuy = buy;
            buy = max(buy, sell - prices[i]);
            sell = max(sell, prevBuy + prices[i] - fee);
        }
        return sell;
    }
};
"
400,cpp,arranging-coins,"class Solution {
public:
    int arrangeCoins(int n) {
        int c=n;
        long long i=1;
        if(n==0) return 0;
        else if(n==1) return 1;
        while(c>=0){
            i++;
            c-=i;
        }
    return i-1;}
};",None,"class Solution {
public:
    int arrangeCoins(int n) {
        if(n == 0) return 0;
        if(n == 1) return 1;
        long long i = 1;
        while(n > 0) {
            n -= i;
            i++;
        }
        return i-1;
    }
};
"
400,cpp,arranging-coins,"class Solution {
public:
    int arrangeCoins(int n) {
        int c=n;
        long long i=1;
        if(n==0) return 0;
        else if(n==1) return 1;
        while(c>=0){
            i++;
            c-=i;
        }
    return i-1;}
};",None,"class Solution {
public:
    int arrangeCoins(int n) {
        int i = 1;
        while (n >= i) {
            n -= i;
            i++;
        }
        return i - 1;
    }
};
"
400,cpp,arranging-coins,"class Solution {
public:
    int arrangeCoins(int n) {
        int c=n;
        long long i=1;
        if(n==0) return 0;
        else if(n==1) return 1;
        while(c>=0){
            i++;
            c-=i;
        }
    return i-1;}
};",None,"class Solution {
public:
    int arrangeCoins(int n) {
        if(n == 0) return 0;
        int i = 1;
        while(n >= i) {
            n -= i;
            i++;
        }
        return i-1;
    }
};
"
401,cpp,the-number-of-beautiful-subsets,"class Solution {
public:
    int beautifulSubsets(vector<int>& nums, int k) {
        vector<int> cur;
        return helper(nums, k, cur, 0);
    }
    private:
    int helper(vector<int>& nums, int k, vector<int>& cur, int start) {
        int cnt = 0;
        for (int i = start; i <= nums.size(); ++i) {
            if (!test(cur, nums[i], k))
                continue;
            cur.push_back(nums[i]);
            cnt++;
            cnt += helper(nums, k, cur, i + 1);
            cur.pop_back();
        }
        return cnt;
    }
    bool test(vector<int>& cur, int num, int k) {
        for (auto &c : cur)
            if (abs(num - c) == k)
                return false;
        return true;
    }
};",None,"class Solution {
public:
    int beautifulSubsets(vector<int>& nums, int k) {
        vector<int> cur;
        return helper(nums, k, cur, 0, cur.size() == 0);
    }
    private:
    int helper(vector<int>& nums, int k, vector<int>& cur, int start, bool hasPre) {
        int cnt = hasPre;
        for (int i = start; i < nums.size(); ++i) {
            if (!test(cur, nums[i], k))
                continue;
            cur.push_back(nums[i]);
            cnt += helper(nums, k, cur, i + 1, true);
            cur.pop_back();
        }
        return cnt;
    }
    bool test(vector<int>& cur, int num, int k) {
        for (auto &c : cur)
            if (abs(num - c) == k)
                return false;
        return true;
    }
};
"
401,cpp,the-number-of-beautiful-subsets,"class Solution {
public:
    int beautifulSubsets(vector<int>& nums, int k) {
        vector<int> cur;
        return helper(nums, k, cur, 0);
    }
    private:
    int helper(vector<int>& nums, int k, vector<int>& cur, int start) {
        int cnt = 0;
        for (int i = start; i <= nums.size(); ++i) {
            if (!test(cur, nums[i], k))
                continue;
            cur.push_back(nums[i]);
            cnt++;
            cnt += helper(nums, k, cur, i + 1);
            cur.pop_back();
        }
        return cnt;
    }
    bool test(vector<int>& cur, int num, int k) {
        for (auto &c : cur)
            if (abs(num - c) == k)
                return false;
        return true;
    }
};",None,"class Solution {
public:
    int beautifulSubsets(vector<int>& nums, int k) {
        unordered_set<int> cur;
        return helper(nums, k, cur, 0);
    }
    private:
    int helper(vector<int>& nums, int k, unordered_set<int>& cur, int start) {
        int cnt = 0;
        for (int i = start; i < nums.size(); ++i) {
            if (!test(cur, nums[i], k))
                continue;
            cur.insert(nums[i]);
            cnt++;
            cnt += helper(nums, k, cur, i + 1);
            cur.erase(nums[i]);
        }
        return cnt;
    }
    bool test(unordered_set<int>& cur, int num, int k) {
        for (auto &c : cur)
            if (abs(num - c) == k)
                return false;
        return true;
    }
};
"
401,cpp,the-number-of-beautiful-subsets,"class Solution {
public:
    int beautifulSubsets(vector<int>& nums, int k) {
        vector<int> cur;
        return helper(nums, k, cur, 0);
    }
    private:
    int helper(vector<int>& nums, int k, vector<int>& cur, int start) {
        int cnt = 0;
        for (int i = start; i <= nums.size(); ++i) {
            if (!test(cur, nums[i], k))
                continue;
            cur.push_back(nums[i]);
            cnt++;
            cnt += helper(nums, k, cur, i + 1);
            cur.pop_back();
        }
        return cnt;
    }
    bool test(vector<int>& cur, int num, int k) {
        for (auto &c : cur)
            if (abs(num - c) == k)
                return false;
        return true;
    }
};",None,"class Solution {
public:
    int beautifulSubsets(vector<int>& nums, int k) {
        vector<int> cur;
        return helper(nums, k, cur, 0, vector<bool>(nums.size(), false));
    }
    private:
    int helper(vector<int>& nums, int k, vector<int>& cur, int start, vector<bool>& used) {
        int cnt = 0;
        for (int i = start; i < nums.size(); ++i) {
            if (!test(cur, nums[i], k))
                continue;
            cur.push_back(nums[i]);
            cnt++;
            used[i] = true;
            cnt += helper(nums, k, cur, i + 1, used);
            cur.pop_back();
            used[i] = false;
        }
        return cnt;
    }
    bool test(vector<int>& cur, int num, int k) {
        for (auto &c : cur)
            if (abs(num - c) == k)
                return false;
        return true;
    }
};
"
402,cpp,minimum-number-of-steps-to-make-two-strings-anagram,"class Solution {
public:

    vector<int> mapping(string s)
    {
        vector<int> v(26, 0);
        for (int i = 0; i < s.size(); i++)
            v[s[i] - 'a']++;
        return v;
    }

    int minSteps(string s, string t) {

    vector<int> mapping1 = mapping(s);
    vector<int> mapping2 = mapping(t);
    int count = 0;
    for (int i = 0; i < 26; i++)
    {
        int diff = 0;
        if (mapping1[i] != 0)
            diff = mapping1[i] - mapping2[i];
        count += diff;
    }
    return count;
        
    }
};",None,"class Solution {
public:

    vector<int> mapping(string s)
    {
        vector<int> v(26, 0);
        for (int i = 0; i < s.size(); i++)
            v[s[i] - 'a']++;
        return v;
    }

    int minSteps(string s, string t) {

    vector<int> mapping1 = mapping(s);
    vector<int> mapping2 = mapping(t);
    int count = 0;
    for (int i = 0; i < 26; i++)
    {
        int diff = max(mapping1[i], mapping2[i]) - min(mapping1[i], mapping2[i]);
        count += diff;
    }
    return count;
        
    }
};
"
402,cpp,minimum-number-of-steps-to-make-two-strings-anagram,"class Solution {
public:

    vector<int> mapping(string s)
    {
        vector<int> v(26, 0);
        for (int i = 0; i < s.size(); i++)
            v[s[i] - 'a']++;
        return v;
    }

    int minSteps(string s, string t) {

    vector<int> mapping1 = mapping(s);
    vector<int> mapping2 = mapping(t);
    int count = 0;
    for (int i = 0; i < 26; i++)
    {
        int diff = 0;
        if (mapping1[i] != 0)
            diff = mapping1[i] - mapping2[i];
        count += diff;
    }
    return count;
        
    }
};",None,"class Solution {
public:

    vector<int> mapping(string s)
    {
        vector<int> v(26, 0);
        for (int i = 0; i < s.size(); i++)
            v[s[i] - 'a']++;
        return v;
    }

    int minSteps(string s, string t) {

    vector<int> mapping1 = mapping(s);
    vector<int> mapping2 = mapping(t);
    int count = 0;
    for (int i = 0; i < 26; i++)
    {
        if (mapping1[i] > mapping2[i])
            count += mapping1[i] - mapping2[i];
    }
    return count;
        
    }
};
"
402,cpp,minimum-number-of-steps-to-make-two-strings-anagram,"class Solution {
public:

    vector<int> mapping(string s)
    {
        vector<int> v(26, 0);
        for (int i = 0; i < s.size(); i++)
            v[s[i] - 'a']++;
        return v;
    }

    int minSteps(string s, string t) {

    vector<int> mapping1 = mapping(s);
    vector<int> mapping2 = mapping(t);
    int count = 0;
    for (int i = 0; i < 26; i++)
    {
        int diff = 0;
        if (mapping1[i] != 0)
            diff = mapping1[i] - mapping2[i];
        count += diff;
    }
    return count;
        
    }
};",None,"class Solution {
public:

    vector<int> mapping(string s)
    {
        vector<int> v(26, 0);
        for (int i = 0; i < s.size(); i++)
            v[s[i] - 'a']++;
        return v;
    }

    int minSteps(string s, string t) {

    vector<int> mapping1 = mapping(s);
    vector<int> mapping2 = mapping(t);
    int count = 0;
    for (int i = 0; i < 26; i++)
    {
        if (mapping1[i] > mapping2[i])
            count += mapping1[i] - mapping2[i];
    }
    return count;
        
    }
};
"
403,cpp,longest-alternating-subarray,"class Solution {
public:
    int alternatingSubarray(vector<int>& v) {
        int ans = 0;
        for(int i = 0; i <= v.size() - 1; i += 1) {
            bool flag = true;
            int cnt = 1;
            for(int j = i + 1; j <= v.size(); j += 1) {
                if(v[j] - v[j - 1] != (flag ? 1 : -1)) break;
                flag = !flag;
                cnt += 1;
            }
            ans = max(ans, cnt);
        }
        return ans <= 1 ? -1 : ans;
    }
};",None,"class Solution {
public:
    int alternatingSubarray(vector<int>& v) {
        int ans = 0;
        for(int i = 0; i <= v.size() - 2; i += 1) {
            bool flag = true;
            int cnt = 1;
            if(v[i+1] - v[i] == (flag ? 1 : -1)) {
                for(int j = i + 2; j <= v.size() - 1; j += 1) {
                    if(v[j] - v[j - 1] != (flag ? 1 : -1)) break;
                    flag = !flag;
                    cnt += 1;
                }
                ans = max(ans, cnt);
            }
        }
        return ans <= 1 ? -1 : ans;
    }
};
"
403,cpp,longest-alternating-subarray,"class Solution {
public:
    int alternatingSubarray(vector<int>& v) {
        int ans = 0;
        for(int i = 0; i <= v.size() - 1; i += 1) {
            bool flag = true;
            int cnt = 1;
            for(int j = i + 1; j <= v.size(); j += 1) {
                if(v[j] - v[j - 1] != (flag ? 1 : -1)) break;
                flag = !flag;
                cnt += 1;
            }
            ans = max(ans, cnt);
        }
        return ans <= 1 ? -1 : ans;
    }
};",None,"class Solution {
public:
    int alternatingSubarray(vector<int>& v) {
        int ans = 0;
        for(int i = 0; i <= v.size() - 2; i += 1) {
            bool flag = true;
            int cnt = 1;
            if(v[i+1] - v[i] == (flag ? 1 : -1)) {
                for(int j = i + 2; j <= v.size() - 1; j += 1) {
                    if(v[j] - v[j - 1] != (flag ? 1 : -1)) break;
                    flag = !flag;
                    cnt += 1;
                }
                ans = max(ans, cnt);
            }
        }
        return ans <= 1 ? -1 : ans;
    }
};
"
403,cpp,longest-alternating-subarray,"class Solution {
public:
    int alternatingSubarray(vector<int>& v) {
        int ans = 0;
        for(int i = 0; i <= v.size() - 1; i += 1) {
            bool flag = true;
            int cnt = 1;
            for(int j = i + 1; j <= v.size(); j += 1) {
                if(v[j] - v[j - 1] != (flag ? 1 : -1)) break;
                flag = !flag;
                cnt += 1;
            }
            ans = max(ans, cnt);
        }
        return ans <= 1 ? -1 : ans;
    }
};",None,"class Solution {
public:
    int alternatingSubarray(vector<int>& v) {
        int ans = 0;
        for(int i = 0; i < v.size(); i += 1) {
            bool flag = true;
            int cnt = 1;
            for(int j = i + 1; j < v.size(); j += 1) {
                if(v[j] - v[j - 1] != (flag ? 1 : -1)) break;
                flag = !flag;
                cnt += 1;
            }
            ans = max(ans, cnt);
        }
        return ans <= 1 ? -1 : ans;
    }
};
"
404,cpp,form-smallest-number-from-two-digit-arrays,"class Solution {
public:
    int minNumber(vector<int>& nums1, vector<int>& nums2) {
        map<int,int>mp;
        for(auto x: nums1) mp[x]++;
        for(auto x: nums2) mp[x]++;
        int mn1=*min_element(nums1.begin(),nums1.end());
        int mn2=*min_element(nums2.begin(),nums2.end());
        for(auto x: mp){
            if(x.second==1) return x.first;
        }
        string s;
        if(mn1<mn2) s=to_string(mn1)+ to_string(mn2);
        else s=to_string(mn2)+ to_string(mn1);
        return stoi(s);
    }
};",None,"class Solution {
public:
    int minNumber(vector<int>& nums1, vector<int>& nums2) {
        map<int,int>mp;
        for(auto x: nums1) mp[x]++;
        for(auto x: nums2) mp[x]++;
        int mn1=*min_element(nums1.begin(),nums1.end());
        int mn2=*min_element(nums2.begin(),nums2.end());
        for(auto x: mp){
            if(x.second==1) return x.first;
        }
        string s;
        if(mn1<mn2) s=to_string(mn1)+ to_string(mn2);
        else s=to_string(mn2)+ to_string(mn1);
        for(auto x: nums1){
            if(s.find(to_string(x))==string::npos && mp[x]==1){
                s = min(s, to_string(x) + s);
            }
        }
        for(auto x: nums2){
            if(s.find(to_string(x))==string::npos && mp[x]==1){
                s = min(s, to_string(x) + s);
            }
        }
        return stoi(s);
    }
};
"
404,cpp,form-smallest-number-from-two-digit-arrays,"class Solution {
public:
    int minNumber(vector<int>& nums1, vector<int>& nums2) {
        map<int,int>mp;
        for(auto x: nums1) mp[x]++;
        for(auto x: nums2) mp[x]++;
        int mn1=*min_element(nums1.begin(),nums1.end());
        int mn2=*min_element(nums2.begin(),nums2.end());
        for(auto x: mp){
            if(x.second==1) return x.first;
        }
        string s;
        if(mn1<mn2) s=to_string(mn1)+ to_string(mn2);
        else s=to_string(mn2)+ to_string(mn1);
        return stoi(s);
    }
};",None,"class Solution {
public:
    int minNumber(vector<int>& nums1, vector<int>& nums2) {
        map<int,int>mp;
        for(auto x: nums1) mp[x]++;
        for(auto x: nums2) mp[x]++;
        int mn1=*min_element(nums1.begin(),nums1.end());
        int mn2=*min_element(nums2.begin(),nums2.end());
        for(auto x: mp){
            if(x.second==1) return x.first;
        }
        string s;
        if(mn1<mn2) s=to_string(mn1)+ to_string(mn2);
        else s=to_string(mn2)+ to_string(mn1);
        for(auto x: nums1){
            if(s.find(to_string(x))==string::npos){
                s = min(s, to_string(x) + s);
            }
        }
        for(auto x: nums2){
            if(s.find(to_string(x))==string::npos){
                s = min(s, to_string(x) + s);
            }
        }
        return stoi(s);
    }
};
"
404,cpp,form-smallest-number-from-two-digit-arrays,"class Solution {
public:
    int minNumber(vector<int>& nums1, vector<int>& nums2) {
        map<int,int>mp;
        for(auto x: nums1) mp[x]++;
        for(auto x: nums2) mp[x]++;
        int mn1=*min_element(nums1.begin(),nums1.end());
        int mn2=*min_element(nums2.begin(),nums2.end());
        for(auto x: mp){
            if(x.second==1) return x.first;
        }
        string s;
        if(mn1<mn2) s=to_string(mn1)+ to_string(mn2);
        else s=to_string(mn2)+ to_string(mn1);
        return stoi(s);
    }
};",None,"class Solution {
public:
    int minNumber(vector<int>& nums1, vector<int>& nums2) {
        map<int,int>mp;
        for(auto x: nums1) mp[x]++;
        for(auto x: nums2) mp[x]++;
        int mn = min(nums1[0], nums2[0]);
        for(auto x: mp){
            if(x.second==1) return mn;
            mn = min(mn, x.first);
        }
        string s;
        s = to_string(mn) + to_string(min(min_element(nums1.begin(), nums1.end()) - nums1.begin(), min_element(nums2.begin(), nums2.end()) - nums2.begin()));
        return stoi(s);
    }
};
"
405,cpp,shuffle-string,"class Solution {
public:
    string restoreString(string s, vector<int>& ind) {
        int n = s.size();
        string ans(n, '.');
        for (int i = 0; i <= n; i++) {
            ans[ind[i]] = s[i];
        } 
        return ans;
    }
};",None,"class Solution {
public:
    string restoreString(string s, vector<int>& ind) {
        int n = s.size();
        string ans(n, '.');
        for (int i = 0; i < n; i++) {
            ans[ind[i]] = s[i];
        } 
        return ans;
    }
};
"
405,cpp,shuffle-string,"class Solution {
public:
    string restoreString(string s, vector<int>& ind) {
        int n = s.size();
        string ans(n, '.');
        for (int i = 0; i <= n; i++) {
            ans[ind[i]] = s[i];
        } 
        return ans;
    }
};",None,"class Solution {
public:
    string restoreString(string s, vector<int>& ind) {
        int n = s.size();
        string ans(n, '.');
        for (int i = 0; i < n; i++) {
            ans[ind[i]] = s[i];
        } 
        return ans;
    }
};
"
405,cpp,shuffle-string,"class Solution {
public:
    string restoreString(string s, vector<int>& ind) {
        int n = s.size();
        string ans(n, '.');
        for (int i = 0; i <= n; i++) {
            ans[ind[i]] = s[i];
        } 
        return ans;
    }
};",None,"class Solution {
public:
    string restoreString(string s, vector<int>& ind) {
        int n = s.size();
        string ans(n, '.');
        for (int i = 0; i < n; i++) {
            ans[ind[i]] = s[i];
        } 
        return ans;
    }
};
"
406,cpp,flip-string-to-monotone-increasing,"class Solution {
public:
    int solve(int idx,int prev,string &s,vector<vector<int>>& dp){
        if(idx==s.size()){
            return 0;
        }
        if(dp[idx][prev]!=-1) return dp[idx][prev];
        if(prev){
            return dp[idx][prev]=(s[idx]=='0')+solve(idx+1,prev,s,dp);
        }
        else{
        
            return dp[idx][prev]=min((s[idx]=='1')+solve(idx+1,1,s,dp),(s[idx]=='0')+solve(idx+1,0,s,dp));
        }
    }
    int minFlipsMonoIncr(string s) {
        vector<vector<int>> dp(s.size(),vector<int>(2,-1));
        return solve(0,0,s,dp);
    }
};",None,"class Solution {
public:
    int solve(int idx,int prev,string &s,vector<vector<int>>& dp){
        if(idx==s.size()){
            return 0;
        }
        if(dp[idx][prev]!=-1) return dp[idx][prev];
        if(prev){
            return dp[idx][prev]=(s[idx]=='0')+solve(idx+1,prev,s,dp);
        }
        else{
            return dp[idx][prev]=min(solve(idx+1,1,s,dp),(s[idx]=='0')+solve(idx+1,0,s,dp));
        }
    }
    int minFlipsMonoIncr(string s) {
        vector<vector<int>> dp(s.size(),vector<int>(2,-1));
        return solve(0,0,s,dp);
    }
};
"
406,cpp,flip-string-to-monotone-increasing,"class Solution {
public:
    int solve(int idx,int prev,string &s,vector<vector<int>>& dp){
        if(idx==s.size()){
            return 0;
        }
        if(dp[idx][prev]!=-1) return dp[idx][prev];
        if(prev){
            return dp[idx][prev]=(s[idx]=='0')+solve(idx+1,prev,s,dp);
        }
        else{
        
            return dp[idx][prev]=min((s[idx]=='1')+solve(idx+1,1,s,dp),(s[idx]=='0')+solve(idx+1,0,s,dp));
        }
    }
    int minFlipsMonoIncr(string s) {
        vector<vector<int>> dp(s.size(),vector<int>(2,-1));
        return solve(0,0,s,dp);
    }
};",None,"class Solution {
public:
    int solve(int idx,int prev,string &s,vector<vector<int>>& dp){
        if(idx==s.size()){
            return 0;
        }
        if(dp[idx][prev]!=-1) return dp[idx][prev];
        if(prev){
            return dp[idx][prev]=(s[idx]=='0')+solve(idx+1,prev,s,dp);
        }
        else{
            return dp[idx][prev]=min(solve(idx+1,1,s,dp),(s[idx]=='0')+solve(idx+1,0,s,dp));
        }
    }
    int minFlipsMonoIncr(string s) {
        vector<vector<int>> dp(s.size(),vector<int>(2,-1));
        return solve(0,0,s,dp);
    }
};
"
406,cpp,flip-string-to-monotone-increasing,"class Solution {
public:
    int solve(int idx,int prev,string &s,vector<vector<int>>& dp){
        if(idx==s.size()){
            return 0;
        }
        if(dp[idx][prev]!=-1) return dp[idx][prev];
        if(prev){
            return dp[idx][prev]=(s[idx]=='0')+solve(idx+1,prev,s,dp);
        }
        else{
        
            return dp[idx][prev]=min((s[idx]=='1')+solve(idx+1,1,s,dp),(s[idx]=='0')+solve(idx+1,0,s,dp));
        }
    }
    int minFlipsMonoIncr(string s) {
        vector<vector<int>> dp(s.size(),vector<int>(2,-1));
        return solve(0,0,s,dp);
    }
};",None,"class Solution {
public:
    int solve(int idx,int prev,string &s,vector<vector<int>>& dp){
        if(idx==s.size()){
            return 0;
        }
        if(dp[idx][prev]!=-1) return dp[idx][prev];
        if(prev){
            return dp[idx][prev]=(s[idx]=='0')+solve(idx+1,prev,s,dp);
        }
        else{
            return dp[idx][prev]=min(solve(idx+1,1,s,dp),(s[idx]=='0')+solve(idx+1,0,s,dp));
        }
    }
    int minFlipsMonoIncr(string s) {
        vector<vector<int>> dp(s.size(),vector<int>(2,-1));
        return solve(0,0,s,dp);
    }
};
"
407,cpp,minimum-cost-to-make-at-least-one-valid-path-in-a-grid,"#define pii pair<int, int>
#define maxn 10005
#define inf 1000000000

class Solution {
public:
    vector<pii>g[maxn];
    int dis[maxn];
    int n, m;
    bool valid(int x, int y) {
        if(x >= 0 and x <= n and y >= 0 and y <= m) return true;
        else return false;
    }
    void bfs(int s) {
        deque<int> q;
        for(int i=0; i<maxn; i++) dis[i] = inf;
        dis[s] = 0;
        q.push_front(s);
        while(!q.empty()){
            int u = q.front();
            q.pop_front();
            for(int i=0; i<g[u].size(); i++){
                int v = g[u][i].first;
                int w = g[u][i].second;
                if(dis[u] + w < dis[v]){
                    dis[v] = dis[u] + w;
                    if(w == 1) q.push_back(v);
                    else q.push_front(v);
                }
            }
        }
    }
    int minCost(vector<vector<int>>& grid) {
        n = grid.size(), m = grid[0].size();
        for(int i=0; i<n; i++) {
            for(int j=0; j<m; j++) {
                int u = i * m + j;
                if(valid(i+1, j)) {
                    int v = (i+1) * m + j;
                    int w;
                    if(grid[i][j] == 3) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                }
                if(valid(i-1, j)) {
                    int v = (i-1) * m + j;
                    int w;
                    if(grid[i][j] == 4) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
                if(valid(i, j+1)) {
                    int v = i * m + (j+1);
                    int w;
                    if(grid[i][j] == 1) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
                if(valid(i, j-1)) {
                    int v = i * m + (j-1);
                    int w;
                    if(grid[i][j] == 2) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
            }
        }
        bfs(0);
        int node = (n * m) - 1;
        int ans = dis[node];
        return ans;
    }
};",None,"class Solution {
public:
    vector<pair<int, int>> g[10005];
    int dis[10005];
    int n, m;
    bool valid(int x, int y) {
        if(x >= 0 && x < n && y >= 0 && y < m) return true;
        else return false;
    }
    void bfs(int s) {
        deque<int> q;
        for(int i=0; i<10005; i++) dis[i] = 1e9;
        dis[s] = 0;
        q.push_front(s);
        while(!q.empty()){
            int u = q.front();
            q.pop_front();
            for(int i=0; i<g[u].size(); i++){
                int v = g[u][i].first;
                int w = g[u][i].second;
                if(dis[u] + w < dis[v]){
                    dis[v] = dis[u] + w;
                    if(w == 1) q.push_back(v);
                    else q.push_front(v);
                }
            }
        }
    }
    int minCost(vector<vector<int>>& grid) {
        n = grid.size(), m = grid[0].size();
        for(int i=0; i<n; i++) {
            for(int j=0; j<m; j++) {
                int u = i * m + j;
                if(valid(i+1, j)) {
                    int v = (i+1) * m + j;
                    int w;
                    if(grid[i][j] == 3) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                }
                if(valid(i-1, j)) {
                    int v = (i-1) * m + j;
                    int w;
                    if(grid[i][j] == 4) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
                if(valid(i, j+1)) {
                    int v = i * m + (j+1);
                    int w;
                    if(grid[i][j] == 1) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
                if(valid(i, j-1)) {
                    int v = i * m + (j-1);
                    int w;
                    if(grid[i][j] == 2) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
            }
        }
        bfs(0);
        int node = (n * m) - 1;
        int ans = dis[node];
        return ans;
    }
};
"
407,cpp,minimum-cost-to-make-at-least-one-valid-path-in-a-grid,"#define pii pair<int, int>
#define maxn 10005
#define inf 1000000000

class Solution {
public:
    vector<pii>g[maxn];
    int dis[maxn];
    int n, m;
    bool valid(int x, int y) {
        if(x >= 0 and x <= n and y >= 0 and y <= m) return true;
        else return false;
    }
    void bfs(int s) {
        deque<int> q;
        for(int i=0; i<maxn; i++) dis[i] = inf;
        dis[s] = 0;
        q.push_front(s);
        while(!q.empty()){
            int u = q.front();
            q.pop_front();
            for(int i=0; i<g[u].size(); i++){
                int v = g[u][i].first;
                int w = g[u][i].second;
                if(dis[u] + w < dis[v]){
                    dis[v] = dis[u] + w;
                    if(w == 1) q.push_back(v);
                    else q.push_front(v);
                }
            }
        }
    }
    int minCost(vector<vector<int>>& grid) {
        n = grid.size(), m = grid[0].size();
        for(int i=0; i<n; i++) {
            for(int j=0; j<m; j++) {
                int u = i * m + j;
                if(valid(i+1, j)) {
                    int v = (i+1) * m + j;
                    int w;
                    if(grid[i][j] == 3) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                }
                if(valid(i-1, j)) {
                    int v = (i-1) * m + j;
                    int w;
                    if(grid[i][j] == 4) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
                if(valid(i, j+1)) {
                    int v = i * m + (j+1);
                    int w;
                    if(grid[i][j] == 1) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
                if(valid(i, j-1)) {
                    int v = i * m + (j-1);
                    int w;
                    if(grid[i][j] == 2) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
            }
        }
        bfs(0);
        int node = (n * m) - 1;
        int ans = dis[node];
        return ans;
    }
};",None,"class Solution {
public:
    vector<vector<int>> g;
    vector<int> dis;
    int n, m;
    bool valid(int x, int y) {
        if(x >= 0 && x < n && y >= 0 && y < m) return true;
        else return false;
    }
    void bfs(int s) {
        queue<int> q;
        for(int i=0; i<n*m; i++) dis[i] = INT_MAX;
        dis[s] = 0;
        q.push(s);
        while(!q.empty()){
            int u = q.front();
            q.pop();
            for(int i=0; i<g[u].size(); i++){
                int v = g[u][i];
                int w = v/m - u/m + v%m - u%m;
                if(dis[u] + w < dis[v]){
                    dis[v] = dis[u] + w;
                    q.push(v);
                }
            }
        }
    }
    int minCost(vector<vector<int>>& grid) {
        n = grid.size(), m = grid[0].size();
        g.resize(n*m);
        dis.resize(n*m);
        for(int i=0; i<n; i++) {
            for(int j=0; j<m; j++) {
                int u = i * m + j;
                if(valid(i+1, j)) {
                    int v = (i+1) * m + j;
                    int w;
                    if(grid[i][j] == 3) w = 0;
                    else w = 1;
                    g[u].push_back(v);
                }
                if(valid(i-1, j)) {
                    int v = (i-1) * m + j;
                    int w;
                    if(grid[i][j] == 4) w = 0;
                    else w = 1;
                    g[u].push_back(v);
                } 
                if(valid(i, j+1)) {
                    int v = i * m + (j+1);
                    int w;
                    if(grid[i][j] == 1) w = 0;
                    else w = 1;
                    g[u].push_back(v);
                } 
                if(valid(i, j-1)) {
                    int v = i * m + (j-1);
                    int w;
                    if(grid[i][j] == 2) w = 0;
                    else w = 1;
                    g[u].push_back(v);
                } 
            }
        }
        bfs(0);
        return dis[n*m-1];
    }
};
"
407,cpp,minimum-cost-to-make-at-least-one-valid-path-in-a-grid,"#define pii pair<int, int>
#define maxn 10005
#define inf 1000000000

class Solution {
public:
    vector<pii>g[maxn];
    int dis[maxn];
    int n, m;
    bool valid(int x, int y) {
        if(x >= 0 and x <= n and y >= 0 and y <= m) return true;
        else return false;
    }
    void bfs(int s) {
        deque<int> q;
        for(int i=0; i<maxn; i++) dis[i] = inf;
        dis[s] = 0;
        q.push_front(s);
        while(!q.empty()){
            int u = q.front();
            q.pop_front();
            for(int i=0; i<g[u].size(); i++){
                int v = g[u][i].first;
                int w = g[u][i].second;
                if(dis[u] + w < dis[v]){
                    dis[v] = dis[u] + w;
                    if(w == 1) q.push_back(v);
                    else q.push_front(v);
                }
            }
        }
    }
    int minCost(vector<vector<int>>& grid) {
        n = grid.size(), m = grid[0].size();
        for(int i=0; i<n; i++) {
            for(int j=0; j<m; j++) {
                int u = i * m + j;
                if(valid(i+1, j)) {
                    int v = (i+1) * m + j;
                    int w;
                    if(grid[i][j] == 3) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                }
                if(valid(i-1, j)) {
                    int v = (i-1) * m + j;
                    int w;
                    if(grid[i][j] == 4) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
                if(valid(i, j+1)) {
                    int v = i * m + (j+1);
                    int w;
                    if(grid[i][j] == 1) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
                if(valid(i, j-1)) {
                    int v = i * m + (j-1);
                    int w;
                    if(grid[i][j] == 2) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                } 
            }
        }
        bfs(0);
        int node = (n * m) - 1;
        int ans = dis[node];
        return ans;
    }
};",None,"class Solution {
public:
    vector<pair<int, int>> g[10005];
    int dis[10005];
    int n, m;
    bool valid(int x, int y) {
        if(x >= 0 && x < n && y >= 0 && y < m) return true;
        else return false;
    }
    void bfs(int s) {
        deque<int> q;
        for(int i=0; i<10005; i++) dis[i] = 1e9;
        dis[s] = 0;
        q.push_front(s);
        while(!q.empty()){
            int u = q.front();
            q.pop_front();
            for(int i=0; i<g[u].size(); i++){
                int v = g[u][i].first;
                int w = g[u][i].second;
                if(dis[u] + w < dis[v]){
                    dis[v] = dis[u] + w;
                    if(w == 1) q.push_back(v);
                    else q.push_front(v);
                }
            }
        }
    }
    int minCost(vector<vector<int>>& grid) {
        n = grid.size(), m = grid[0].size();
        for(int i=0; i<n; i++) {
            for(int j=0; j<m; j++) {
                int u = i * m + j;
                if(valid(i+1, j)) {
                    int v = (i+1) * m + j;
                    int w;
                    if(grid[i][j] == 3) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                    g[v].push_back({u, w});
                }
                if(valid(i-1, j)) {
                    int v = (i-1) * m + j;
                    int w;
                    if(grid[i][j] == 4) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                    g[v].push_back({u, w});
                } 
                if(valid(i, j+1)) {
                    int v = i * m + (j+1);
                    int w;
                    if(grid[i][j] == 1) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                    g[v].push_back({u, w});
                } 
                if(valid(i, j-1)) {
                    int v = i * m + (j-1);
                    int w;
                    if(grid[i][j] == 2) w = 0;
                    else w = 1;
                    g[u].push_back({v, w});
                    g[v].push_back({u, w});
                } 
            }
        }
        bfs(0);
        int node = (n * m) - 1;
        int ans = dis[node];
        return ans;
    }
};
"
408,cpp,binary-string-with-substrings-representing-1-to-n,"class Solution {
public:
    bool queryString(string s, int n)
     {
        unordered_set<int> seen;
        int len = s.length();
        for(int i=len-1;i>=0;i--)
        {
            int num = 0;
            for(int j=1;j<=min(len-i,31);j++)
            { 
                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);
                if(0 < num && num <= n) seen.insert(num);
             }
            if(seen.size() != n) return true;
        }
        return false;
    }
};",None,"class Solution {
public:
    bool queryString(string s, int n)
    {
        unordered_set<int> seen;
        int len = s.length();
        for(int i=len-1;i>=0;i--)
        {
            int num = 0;
            for(int j=1;j<=min(len-i,31);j++)
            { 
                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);
                if(num <= n) seen.insert(num);
             }
            if(seen.size() == n+1) return false;
        }
        return true;
    }
};
"
408,cpp,binary-string-with-substrings-representing-1-to-n,"class Solution {
public:
    bool queryString(string s, int n)
     {
        unordered_set<int> seen;
        int len = s.length();
        for(int i=len-1;i>=0;i--)
        {
            int num = 0;
            for(int j=1;j<=min(len-i,31);j++)
            { 
                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);
                if(0 < num && num <= n) seen.insert(num);
             }
            if(seen.size() != n) return true;
        }
        return false;
    }
};",None,"class Solution {
public:
    bool queryString(string s, int n)
    {
        unordered_set<int> seen;
        int len = s.length();
        for(int i=len-1;i>=0;i--)
        {
            int num = 0;
            for(int j=1;j<=min(len-i,31);j++)
            { 
                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);
                if(num <= n) seen.insert(num);
             }
            if(seen.size() == n+1) return false;
        }
        return true;
    }
};
"
408,cpp,binary-string-with-substrings-representing-1-to-n,"class Solution {
public:
    bool queryString(string s, int n)
     {
        unordered_set<int> seen;
        int len = s.length();
        for(int i=len-1;i>=0;i--)
        {
            int num = 0;
            for(int j=1;j<=min(len-i,31);j++)
            { 
                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);
                if(0 < num && num <= n) seen.insert(num);
             }
            if(seen.size() != n) return true;
        }
        return false;
    }
};",None,"class Solution {
public:
    bool queryString(string s, int n)
     {
        unordered_set<int> seen;
        int len = s.length();
        for(int i=len-1;i>=0;i--)
        {
            int num = 0;
            for(int j=1;j<=min(len-i,31);j++)
            { 
                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);
                if(num <= n) seen.insert(num);
             }
            if(seen.size() == n+1) return false;
        }
        return true;
    }
};
"
409,cpp,minimum-operations-to-make-array-equal,"class Solution {
public:
    int minOperations(int n) {
       int i,j,k=0,s=0;
       i=n/2;
       int max=n;
       
        for(j=0;j<=i;j++){
            s+=max-2*j-1;
        }
        return s;
    }
};",None,"class Solution {
public:
    int minOperations(int n) {
       int i,j,k=0,s=0;
       i=n/2;
       int max=n;
       
        for(j=0;j<i;j++){
            s+=max-2*j-1;
        }
        return s;
    }
};
"
409,cpp,minimum-operations-to-make-array-equal,"class Solution {
public:
    int minOperations(int n) {
       int i,j,k=0,s=0;
       i=n/2;
       int max=n;
       
        for(j=0;j<=i;j++){
            s+=max-2*j-1;
        }
        return s;
    }
};",None,"class Solution {
public:
    int minOperations(int n) {
        return (n * (n - 1)) / 2;
    }
};
"
409,cpp,minimum-operations-to-make-array-equal,"class Solution {
public:
    int minOperations(int n) {
       int i,j,k=0,s=0;
       i=n/2;
       int max=n;
       
        for(j=0;j<=i;j++){
            s+=max-2*j-1;
        }
        return s;
    }
};",None,"class Solution {
public:
    int minOperations(int n) {
        return (n*(n-1))/2;
    }
};
"
410,cpp,perfect-squares,"class Solution {
public:

    int dp[105][10005];

    int helper(vector<int>& arr, int i, int n, int sum)
    {
        if(i >= n || sum <= 0) 
        {
            return INT_MAX - 1000;
        }

        if(dp[i][sum] != -1)
        {
            return dp[i][sum];
        }

        int mini = INT_MAX;

        if(arr[i] <= sum)
        {
            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));
        }

        mini = min(mini, helper(arr, i + 1, n, sum));

        return dp[i][sum] = mini;
    }

    int numSquares(int n) {

        vector<int> arr;

        for(int i = 1; i * i <= n; i++)
        {
            arr.push_back(i * i);
        }

        memset(dp, -1, sizeof(dp));

        return helper(arr, 0, arr.size(), n);
    }
};",None,"class Solution {
public:

    int dp[105][10005];

    int helper(vector<int>& arr, int i, int n, int sum)
    {
        if(i >= n || sum <= 0) 
        {
            return sum == 0 ? 0 : INT_MAX;
        }

        if(dp[i][sum] != -1)
        {
            return dp[i][sum];
        }

        int mini = INT_MAX;

        if(arr[i] <= sum)
        {
            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));
        }

        mini = min(mini, helper(arr, i + 1, n, sum));

        return dp[i][sum] = mini;
    }

    int numSquares(int n) {

        vector<int> arr;

        for(int i = 1; i * i <= n; i++)
        {
            arr.push_back(i * i);
        }

        memset(dp, -1, sizeof(dp));

        return helper(arr, 0, arr.size(), n);
    }
};
"
410,cpp,perfect-squares,"class Solution {
public:

    int dp[105][10005];

    int helper(vector<int>& arr, int i, int n, int sum)
    {
        if(i >= n || sum <= 0) 
        {
            return INT_MAX - 1000;
        }

        if(dp[i][sum] != -1)
        {
            return dp[i][sum];
        }

        int mini = INT_MAX;

        if(arr[i] <= sum)
        {
            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));
        }

        mini = min(mini, helper(arr, i + 1, n, sum));

        return dp[i][sum] = mini;
    }

    int numSquares(int n) {

        vector<int> arr;

        for(int i = 1; i * i <= n; i++)
        {
            arr.push_back(i * i);
        }

        memset(dp, -1, sizeof(dp));

        return helper(arr, 0, arr.size(), n);
    }
};",None,"class Solution {
public:

    int dp[105][10005];

    int helper(vector<int>& arr, int i, int n)
    {
        if(i >= arr.size()) 
        {
            return INT_MAX - 1000;
        }

        if(dp[i][n] != -1)
        {
            return dp[i][n];
        }

        int mini = INT_MAX;

        if(arr[i] <= n)
        {
            mini = min(mini, 1 + helper(arr, i, n - arr[i]));
        }

        mini = min(mini, helper(arr, i + 1, n));

        return dp[i][n] = mini;
    }

    int numSquares(int n) {

        vector<int> arr;

        for(int i = 1; i * i <= n; i++)
        {
            arr.push_back(i * i);
        }

        memset(dp, -1, sizeof(dp));

        return helper(arr, 0, n);
    }
};
"
410,cpp,perfect-squares,"class Solution {
public:

    int dp[105][10005];

    int helper(vector<int>& arr, int i, int n, int sum)
    {
        if(i >= n || sum <= 0) 
        {
            return INT_MAX - 1000;
        }

        if(dp[i][sum] != -1)
        {
            return dp[i][sum];
        }

        int mini = INT_MAX;

        if(arr[i] <= sum)
        {
            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));
        }

        mini = min(mini, helper(arr, i + 1, n, sum));

        return dp[i][sum] = mini;
    }

    int numSquares(int n) {

        vector<int> arr;

        for(int i = 1; i * i <= n; i++)
        {
            arr.push_back(i * i);
        }

        memset(dp, -1, sizeof(dp));

        return helper(arr, 0, arr.size(), n);
    }
};",None,"class Solution {
public:

    int dp[105][10005];

    int helper(vector<int>& arr, int i, int n)
    {
        if(i >= arr.size() || n <= 0) 
        {
            return n == 0 ? 0 : INT_MAX - 1000;
        }

        if(dp[i][n] != -1)
        {
            return dp[i][n];
        }

        int mini = INT_MAX;

        if(arr[i] <= n)
        {
            mini = min(mini, 1 + helper(arr, i, n - arr[i]));
        }

        mini = min(mini, helper(arr, i + 1, n));

        return dp[i][n] = mini;
    }

    int numSquares(int n) {

        vector<int> arr;

        for(int i = 1; i * i <= n; i++)
        {
            arr.push_back(i * i);
        }

        memset(dp, -1, sizeof(dp));

        return helper(arr, 0, n);
    }
};
"
411,cpp,minimum-difference-between-largest-and-smallest-value-in-three-moves,"class Solution {
public:
    int minDifference(vector<int>& nums) {
        if(nums.size() <= 4) return 0;
        sort(nums.begin(), nums.end());
        int n = nums.size();
        return min({nums[n] - nums[0], nums[n - 1] - nums[3], nums[n - 3] - nums[1], nums[n - 2] - nums[2]});
    }
};",None,"class Solution {
public:
    int minDifference(vector<int>& nums) {
        if(nums.size() <= 4) return 0;
        sort(nums.begin(), nums.end());
        int n = nums.size();
        return min({nums[n-1] - nums[0], nums[n-2] - nums[1], nums[n-3] - nums[2], nums[n-4] - nums[3]});
    }
};
"
411,cpp,minimum-difference-between-largest-and-smallest-value-in-three-moves,"class Solution {
public:
    int minDifference(vector<int>& nums) {
        if(nums.size() <= 4) return 0;
        sort(nums.begin(), nums.end());
        int n = nums.size();
        return min({nums[n] - nums[0], nums[n - 1] - nums[3], nums[n - 3] - nums[1], nums[n - 2] - nums[2]});
    }
};",None,"class Solution {
public:
    int minDifference(vector<int>& nums) {
        if(nums.size() <= 4) return 0;
        sort(nums.begin(), nums.end());
        int n = nums.size();
        return min({nums[n-1] - nums[0], nums[n-1] - nums[1], nums[n-2] - nums[0], nums[n-2] - nums[1]});
    }
};
"
411,cpp,minimum-difference-between-largest-and-smallest-value-in-three-moves,"class Solution {
public:
    int minDifference(vector<int>& nums) {
        if(nums.size() <= 4) return 0;
        sort(nums.begin(), nums.end());
        int n = nums.size();
        return min({nums[n] - nums[0], nums[n - 1] - nums[3], nums[n - 3] - nums[1], nums[n - 2] - nums[2]});
    }
};",None,"class Solution {
public:
    int minDifference(vector<int>& nums) {
        if(nums.size() <= 4) return 0;
        sort(nums.begin(), nums.end());
        int n = nums.size();
        return min({nums[n - 1] - nums[0], nums[n - 1] - nums[1], nums[n - 2] - nums[0], nums[n - 2] - nums[1]});
    }
};
"
412,cpp,sort-an-array,"class Solution {
public:
    void merge(int low, int mid, int high, vector<int> &nums) {
        if (low >= high) 
        return;
        int l = low, r = mid + 1, k = 0, size = high - low + 1;
        vector<int> sorted(size, 0);
        while (l <= mid and r <= high)
            sorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];
        while (l <= mid) 
            sorted[k++] = nums[l++];
        while (r <= high) 
            sorted[k++] = nums[r++];
        for (k = 0; k < size; k++)
            nums[k + low] = sorted[k];
    }

    void mergeSort(vector<int>& nums, int start, int end){
        if(start < end){
            int mid = start + (end - start) / 2;
            mergeSort(nums, start, mid+1); 
            mergeSort(nums, mid + 1, end);
            merge(start, mid, end, nums);
        }
    }

    vector<int> sortArray(vector<int>& nums) {
        mergeSort(nums, 0, nums.size()-1);
        return nums;
    }
};",None,"class Solution {
public:
    void merge(int low, int mid, int high, vector<int> &nums) {
        if (low >= high) 
        return;
        int l = low, r = mid + 1, k = 0, size = high - low + 1;
        vector<int> sorted(size, 0);
        while (l <= mid and r <= high)
            sorted[k++] = nums[l] <= nums[r] ? nums[l++] : nums[r++];
        while (l <= mid) 
            sorted[k++] = nums[l++];
        while (r <= high) 
            sorted[k++] = nums[r++];
        for (k = 0; k < size; k++)
            nums[low + k] = sorted[k];
    }

    void mergeSort(vector<int>& nums, int start, int end){
        if(start < end){
            int mid = start + (end - start) / 2;
            mergeSort(nums, start, mid); 
            mergeSort(nums, mid + 1, end);
            merge(start, mid, end, nums);
        }
    }

    vector<int> sortArray(vector<int>& nums) {
        mergeSort(nums, 0, nums.size()-1);
        return nums;
    }
};
"
412,cpp,sort-an-array,"class Solution {
public:
    void merge(int low, int mid, int high, vector<int> &nums) {
        if (low >= high) 
        return;
        int l = low, r = mid + 1, k = 0, size = high - low + 1;
        vector<int> sorted(size, 0);
        while (l <= mid and r <= high)
            sorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];
        while (l <= mid) 
            sorted[k++] = nums[l++];
        while (r <= high) 
            sorted[k++] = nums[r++];
        for (k = 0; k < size; k++)
            nums[k + low] = sorted[k];
    }

    void mergeSort(vector<int>& nums, int start, int end){
        if(start < end){
            int mid = start + (end - start) / 2;
            mergeSort(nums, start, mid+1); 
            mergeSort(nums, mid + 1, end);
            merge(start, mid, end, nums);
        }
    }

    vector<int> sortArray(vector<int>& nums) {
        mergeSort(nums, 0, nums.size()-1);
        return nums;
    }
};",None,"class Solution {
public:
    void merge(int low, int mid, int high, vector<int> &nums) {
        if (low >= high) 
        return;
        int l = low, r = mid + 1;
        vector<int> sorted(high - low + 1, 0);
        for (int i = 0; i < high - low + 1; i++) {
            if (l > mid) {
                sorted[i] = nums[r++];
            } else if (r > high) {
                sorted[i] = nums[l++];
            } else if (nums[l] < nums[r]) {
                sorted[i] = nums[l++];
            } else {
                sorted[i] = nums[r++];
            }
        }
        for (int i = 0; i < high - low + 1; i++) {
            nums[low + i] = sorted[i];
        }
    }

    void mergeSort(vector<int>& nums, int start, int end){
        if(start < end){
            int mid = start + (end - start) / 2;
            mergeSort(nums, start, mid); 
            mergeSort(nums, mid + 1, end);
            merge(start, mid, end, nums);
        }
    }

    vector<int> sortArray(vector<int>& nums) {
        mergeSort(nums, 0, nums.size()-1);
        return nums;
    }
};
"
412,cpp,sort-an-array,"class Solution {
public:
    void merge(int low, int mid, int high, vector<int> &nums) {
        if (low >= high) 
        return;
        int l = low, r = mid + 1, k = 0, size = high - low + 1;
        vector<int> sorted(size, 0);
        while (l <= mid and r <= high)
            sorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];
        while (l <= mid) 
            sorted[k++] = nums[l++];
        while (r <= high) 
            sorted[k++] = nums[r++];
        for (k = 0; k < size; k++)
            nums[k + low] = sorted[k];
    }

    void mergeSort(vector<int>& nums, int start, int end){
        if(start < end){
            int mid = start + (end - start) / 2;
            mergeSort(nums, start, mid+1); 
            mergeSort(nums, mid + 1, end);
            merge(start, mid, end, nums);
        }
    }

    vector<int> sortArray(vector<int>& nums) {
        mergeSort(nums, 0, nums.size()-1);
        return nums;
    }
};",None,"class Solution {
public:
    void merge(int low, int mid, int high, vector<int> &nums) {
        if (low >= high) 
        return;
        int l = low, r = mid + 1, k = 0, size = high - low + 1;
        vector<int> sorted(size, 0);
        while (l <= mid and r <= high)
            sorted[k++] = nums[l] <= nums[r] ? nums[l++] : nums[r++];
        while (l <= mid) 
            sorted[k++] = nums[l++];
        while (r <= high) 
            sorted[k++] = nums[r++];
        for (k = 0; k < size; k++)
            nums[low + k] = sorted[k];
    }

    void mergeSort(vector<int>& nums, int start, int end){
        if(start < end){
            int mid = start + (end - start) / 2;
            mergeSort(nums, start, mid); 
            mergeSort(nums, mid + 1, end);
            merge(start, mid, end, nums);
        }
    }

    vector<int> sortArray(vector<int>& nums) {
        mergeSort(nums, 0, nums.size()-1);
        return nums;
    }
};
"
413,cpp,shortest-path-with-alternating-colors,"class Solution {
public:
    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) 
    {
        multiset<int>temp;
        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);
        for(auto j:redEdges)
        {
            redchilds[j[0]].insert(j[1]);
        }
        for(auto j:blueEdges)
        {
            bluechilds[j[0]].insert(j[1]);
        }
        vector<int>ans(n, -1);
        for(int i=0;i<n;) 
        {
            vector<multiset<int>>reds=redchilds,blues=bluechilds;
            queue<pair<char,int>>visit;
            visit.push({'n',0});
            int steps=0;
            while(!visit.empty())
            {
                bool justbreak=false;
                int n=visit.size();
                for(int j=0;j<n;j++)
                {
                    pair<char,int>x=visit.front();
                    visit.pop();
                    if(x.second==i)
                    {
                        ans[i]=steps;
                        justbreak=true;
                        break;
                    }
                    if(x.first=='n' || x.first == ans[i] % 2 + '0') 
                    {
                        for(auto j:reds[x.second])
                        {
                            visit.push({'r',j});
                            auto itr1=reds[x.second].find(j);
                            reds[x.second].erase(itr1);
                        }
                        for(auto j:blues[x.second])
                        {
                            visit.push({'b',j});
                            auto itr1=blues[x.second].find(j);
                            blues[x.second].erase(itr1);
                        }
                    }
                    else if(x.first=='b')
                    {
                        for(auto j:reds[x.second])
                        {
                            visit.push({'r',j});
                            auto itr1=reds[x.second].find(j);
                            reds[x.second].erase(itr1);
                        }
                    }
                    else if(x.first=='r')
                    {
                        for(auto j:blues[x.second])
                        {
                            visit.push({'b',j});
                            auto itr1=blues[x.second].find(j);
                            blues[x.second].erase(itr1);
                        }
                    }
                }
                if(justbreak)
                {
                    break;
                }
                steps++;
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) 
    {
        unordered_map<int,vector<pair<int,char>>>adj;
        for(auto j:redEdges)
        {
            adj[j[0]].push_back({j[1],'r'});
        }
        for(auto j:blueEdges)
        {
            adj[j[0]].push_back({j[1],'b'});
        }
        vector<int>ans(n, -1);
        queue<pair<int,char>>visit;
        visit.push({0,'n'});
        int steps=0;
        while(!visit.empty())
        {
            int n=visit.size();
            for(int j=0;j<n;j++)
            {
                pair<int,char>x=visit.front();
                visit.pop();
                if(ans[x.first]==-1)
                {
                    ans[x.first]=steps;
                }
                for(auto j:adj[x.first])
                {
                    if(j.second!=x.second && ans[j.first]==-1)
                    {
                        visit.push({j.first,j.second});
                        adj[j.first].erase(find(adj[j.first].begin(),adj[j.first].end(),j));
                    }
                }
            }
            steps++;
        }
        return ans;
    }
};
"
413,cpp,shortest-path-with-alternating-colors,"class Solution {
public:
    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) 
    {
        multiset<int>temp;
        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);
        for(auto j:redEdges)
        {
            redchilds[j[0]].insert(j[1]);
        }
        for(auto j:blueEdges)
        {
            bluechilds[j[0]].insert(j[1]);
        }
        vector<int>ans(n, -1);
        for(int i=0;i<n;) 
        {
            vector<multiset<int>>reds=redchilds,blues=bluechilds;
            queue<pair<char,int>>visit;
            visit.push({'n',0});
            int steps=0;
            while(!visit.empty())
            {
                bool justbreak=false;
                int n=visit.size();
                for(int j=0;j<n;j++)
                {
                    pair<char,int>x=visit.front();
                    visit.pop();
                    if(x.second==i)
                    {
                        ans[i]=steps;
                        justbreak=true;
                        break;
                    }
                    if(x.first=='n' || x.first == ans[i] % 2 + '0') 
                    {
                        for(auto j:reds[x.second])
                        {
                            visit.push({'r',j});
                            auto itr1=reds[x.second].find(j);
                            reds[x.second].erase(itr1);
                        }
                        for(auto j:blues[x.second])
                        {
                            visit.push({'b',j});
                            auto itr1=blues[x.second].find(j);
                            blues[x.second].erase(itr1);
                        }
                    }
                    else if(x.first=='b')
                    {
                        for(auto j:reds[x.second])
                        {
                            visit.push({'r',j});
                            auto itr1=reds[x.second].find(j);
                            reds[x.second].erase(itr1);
                        }
                    }
                    else if(x.first=='r')
                    {
                        for(auto j:blues[x.second])
                        {
                            visit.push({'b',j});
                            auto itr1=blues[x.second].find(j);
                            blues[x.second].erase(itr1);
                        }
                    }
                }
                if(justbreak)
                {
                    break;
                }
                steps++;
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) 
    {
        unordered_map<int,vector<pair<int,char>>>redchilds,bluechilds;
        for(auto j:redEdges)
        {
            redchilds[j[0]].push_back({j[1], 'r'});
        }
        for(auto j:blueEdges)
        {
            bluechilds[j[0]].push_back({j[1], 'b'});
        }
        vector<int>ans(n, -1);
        queue<pair<int,int>>visit;
        visit.push({0, -1});
        int steps=0;
        while(!visit.empty())
        {
            int n=visit.size();
            for(int j=0;j<n;j++)
            {
                auto x=visit.front();
                visit.pop();
                if(ans[x.first]==-1)
                {
                    ans[x.first]=steps;
                }
                if(x.second==-1)
                {
                    for(auto j:redchilds[x.first])
                    {
                        visit.push({j.first, 'r'});
                    }
                    for(auto j:bluechilds[x.first])
                    {
                        visit.push({j.first, 'b'});
                    }
                }
                else if(x.second=='r')
                {
                    for(auto j:bluechilds[x.first])
                    {
                        visit.push({j.first, 'b'});
                    }
                }
                else if(x.second=='b')
                {
                    for(auto j:redchilds[x.first])
                    {
                        visit.push({j.first, 'r'});
                    }
                }
            }
            steps++;
        }
        return ans;
    }
};
"
413,cpp,shortest-path-with-alternating-colors,"class Solution {
public:
    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) 
    {
        multiset<int>temp;
        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);
        for(auto j:redEdges)
        {
            redchilds[j[0]].insert(j[1]);
        }
        for(auto j:blueEdges)
        {
            bluechilds[j[0]].insert(j[1]);
        }
        vector<int>ans(n, -1);
        for(int i=0;i<n;) 
        {
            vector<multiset<int>>reds=redchilds,blues=bluechilds;
            queue<pair<char,int>>visit;
            visit.push({'n',0});
            int steps=0;
            while(!visit.empty())
            {
                bool justbreak=false;
                int n=visit.size();
                for(int j=0;j<n;j++)
                {
                    pair<char,int>x=visit.front();
                    visit.pop();
                    if(x.second==i)
                    {
                        ans[i]=steps;
                        justbreak=true;
                        break;
                    }
                    if(x.first=='n' || x.first == ans[i] % 2 + '0') 
                    {
                        for(auto j:reds[x.second])
                        {
                            visit.push({'r',j});
                            auto itr1=reds[x.second].find(j);
                            reds[x.second].erase(itr1);
                        }
                        for(auto j:blues[x.second])
                        {
                            visit.push({'b',j});
                            auto itr1=blues[x.second].find(j);
                            blues[x.second].erase(itr1);
                        }
                    }
                    else if(x.first=='b')
                    {
                        for(auto j:reds[x.second])
                        {
                            visit.push({'r',j});
                            auto itr1=reds[x.second].find(j);
                            reds[x.second].erase(itr1);
                        }
                    }
                    else if(x.first=='r')
                    {
                        for(auto j:blues[x.second])
                        {
                            visit.push({'b',j});
                            auto itr1=blues[x.second].find(j);
                            blues[x.second].erase(itr1);
                        }
                    }
                }
                if(justbreak)
                {
                    break;
                }
                steps++;
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges, vector<vector<int>>& blueEdges) {
        vector<multiset<int>> redChilds(n), blueChilds(n);

        for (auto& edge : redEdges) {
            redChilds[edge[0]].insert(edge[1]);
        }

        for (auto& edge : blueEdges) {
            blueChilds[edge[0]].insert(edge[1]);
        }

        vector<int> ans(n, -1);

        function<void(int, vector<multiset<int>>&, vector<multiset<int>>&, int)> bfs =
            [&](int node, vector<multiset<int>>& childs, vector<multiset<int>>& otherChilds, int steps) {
                if (ans[node] != -1) {
                    return;
                }

                ans[node] = steps;

                for (auto& child : childs[node]) {
                    for (auto& otherChild : otherChilds[node]) {
                        bfs(child, otherChilds, childs, steps + 1);
                    }
                }
            };

        bfs(0, redChilds, blueChilds, 0);
        bfs(0, blueChilds, redChilds, 0);

        return ans;
    }
};
"
414,cpp,find-peak-element,"class Solution {
public:
    int findPeakElement(vector<int>& nums) {
    int n=nums.size();
    if(n==1)
    {
      return 0;
    } 
    if(nums[0]>nums[1])
    {
      return 0;
    }
    if(nums[n-1]>nums[n-2])
    {
      return n-1;
    }
    int left=1;
    int right=n-2;
    while(left<=right)
    {
      int mid=(left+right)/2;
      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])
      {
        return mid;
      }
      else if(nums[mid]<nums[mid-1])
      {
        left=mid+1;
      }
      else{
        right=mid-1;
      }
    }
return -1;
    }
};",None,"class Solution {
public:
    int findPeakElement(vector<int>& nums) {
    int n=nums.size();
    if(n==1)
    {
      return 0;
    } 
    if(nums[0]>nums[1])
    {
      return 0;
    }
    if(nums[n-1]>nums[n-2])
    {
      return n-1;
    }
    int left=1;
    int right=n-2;
    while(left<right)
    {
      int mid=(left+right)/2;
      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])
      {
        return mid;
      }
      else if(nums[mid]<nums[mid-1])
      {
        left=mid+1;
      }
      else{
        right=mid;
      }
    }
    return left;
    }
};
"
414,cpp,find-peak-element,"class Solution {
public:
    int findPeakElement(vector<int>& nums) {
    int n=nums.size();
    if(n==1)
    {
      return 0;
    } 
    if(nums[0]>nums[1])
    {
      return 0;
    }
    if(nums[n-1]>nums[n-2])
    {
      return n-1;
    }
    int left=1;
    int right=n-2;
    while(left<=right)
    {
      int mid=(left+right)/2;
      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])
      {
        return mid;
      }
      else if(nums[mid]<nums[mid-1])
      {
        left=mid+1;
      }
      else{
        right=mid-1;
      }
    }
return -1;
    }
};",None,"class Solution {
public:
    int findPeakElement(vector<int>& nums) {
    int n=nums.size();
    if(n==1)
    {
      return 0;
    } 
    if(nums[0]>nums[1])
    {
      return 0;
    }
    if(nums[n-1]>nums[n-2])
    {
      return n-1;
    }
    int left=1;
    int right=n-2;
    while(left<right)
    {
      int mid=(left+right)/2;
      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])
      {
        return mid;
      }
      else if(nums[mid]<nums[mid-1])
      {
        left=mid+1;
      }
      else{
        right=mid;
      }
    }
    return left;
    }
};
"
414,cpp,find-peak-element,"class Solution {
public:
    int findPeakElement(vector<int>& nums) {
    int n=nums.size();
    if(n==1)
    {
      return 0;
    } 
    if(nums[0]>nums[1])
    {
      return 0;
    }
    if(nums[n-1]>nums[n-2])
    {
      return n-1;
    }
    int left=1;
    int right=n-2;
    while(left<=right)
    {
      int mid=(left+right)/2;
      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])
      {
        return mid;
      }
      else if(nums[mid]<nums[mid-1])
      {
        left=mid+1;
      }
      else{
        right=mid-1;
      }
    }
return -1;
    }
};",None,"class Solution {
public:
    int findPeakElement(vector<int>& nums) {
    int n=nums.size();
    if(n==1)
    {
      return 0;
    } 
    if(nums[0]>nums[1])
    {
      return 0;
    }
    if(nums[n-1]>nums[n-2])
    {
      return n-1;
    }
    int left=1;
    int right=n-2;
    while(left<right)
    {
      int mid=(left+right)/2;
      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])
      {
        return mid;
      }
      else if(nums[mid]<nums[mid-1])
      {
        left=mid+1;
      }
      else{
        right=mid;
      }
    }
    return left;
    }
};
"
415,cpp,find-the-punishment-number-of-an-integer,"class Solution {
public:
    
    bool valid(int n, string s,int sum){
        if(s=="""") if(sum==n) return true;

        for(int i=1;i<=s.size();i++){
            int x  = stoi(s.substr(0,i));
            if(valid(n, s.substr(i), sum+x)) return false;
        }
        
        return false;
    }
    int punishmentNumber(int n) {
        int ans = 0;

        for(int i=1;i<=n;i++){
            int sq = i*i;
            string x = to_string(sq);
            if(valid(i,x,0)) ans += i*i;
        }
        
        return ans;
        
    }
};",None,"class Solution {
public:
    
    bool valid(int n, string s,int sum){
        if(s=="""") if(sum==n) return true;

        for(int i=1;i<=s.size();i++){
            int x  = stoi(s.substr(0,i));
            if(valid(n, s.substr(i), sum+x)) return false;
        }
        
        return true;
    }
    int punishmentNumber(int n) {
        int ans = 0;

        for(int i=1;i<=n;i++){
            int sq = i*i;
            string x = to_string(sq);
            if(valid(i,x,0)) ans += i*i;
        }
        
        return ans;
        
    }
};
"
415,cpp,find-the-punishment-number-of-an-integer,"class Solution {
public:
    
    bool valid(int n, string s,int sum){
        if(s=="""") if(sum==n) return true;

        for(int i=1;i<=s.size();i++){
            int x  = stoi(s.substr(0,i));
            if(valid(n, s.substr(i), sum+x)) return false;
        }
        
        return false;
    }
    int punishmentNumber(int n) {
        int ans = 0;

        for(int i=1;i<=n;i++){
            int sq = i*i;
            string x = to_string(sq);
            if(valid(i,x,0)) ans += i*i;
        }
        
        return ans;
        
    }
};",None,"class Solution {
public:
    
    bool valid(int n, string s,int sum){
        if(s=="""") if(sum==n) return true;

        for(int i=1;i<=s.size();i++){
            int x  = stoi(s.substr(0,i));
            if(valid(n, s.substr(i), sum+x)) return false;
        }
        
        return true;
    }
    int punishmentNumber(int n) {
        int ans = 0;

        for(int i=1;i<=n;i++){
            int sq = i*i;
            string x = to_string(sq);
            if(valid(i,x,0)) ans += i*i;
        }
        
        return ans;
        
    }
};
"
415,cpp,find-the-punishment-number-of-an-integer,"class Solution {
public:
    
    bool valid(int n, string s,int sum){
        if(s=="""") if(sum==n) return true;

        for(int i=1;i<=s.size();i++){
            int x  = stoi(s.substr(0,i));
            if(valid(n, s.substr(i), sum+x)) return false;
        }
        
        return false;
    }
    int punishmentNumber(int n) {
        int ans = 0;

        for(int i=1;i<=n;i++){
            int sq = i*i;
            string x = to_string(sq);
            if(valid(i,x,0)) ans += i*i;
        }
        
        return ans;
        
    }
};",None,"class Solution {
public:
    
    bool valid(int n, string s,int sum){
        if(s=="""") if(sum==n) return true;

        for(int i=1;i<=s.size();i++){
            int x  = stoi(s.substr(0,i));
            if(valid(n, s.substr(i), sum+x)) return false;
        }
        
        return true;
    }
    int punishmentNumber(int n) {
        int ans = 0;

        for(int i=1;i<=n;i++){
            int sq = i*i;
            string x = to_string(sq);
            if(valid(i,x,0)) ans += i*i;
        }
        
        return ans;
        
    }
};
"
416,cpp,rotate-array,"class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> temp(nums.size());
        for(int i=0;i<n;i++){
            temp[(i+k)%n]=nums[i+1];
        }
        nums=temp;
    }
};",None,"class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n=nums.size();
        k = k % n;
        vector<int> temp(nums.size());
        for(int i=0;i<n;i++){
            temp[(i+k)%n]=nums[i];
        }
        nums=temp;
    }
};
"
416,cpp,rotate-array,"class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> temp(nums.size());
        for(int i=0;i<n;i++){
            temp[(i+k)%n]=nums[i+1];
        }
        nums=temp;
    }
};",None,"class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n=nums.size();
        k = k % n;
        vector<int> temp(nums.size());
        for(int i=0;i<n;i++){
            temp[(i+k)%n]=nums[i];
        }
        nums=temp;
    }
};
"
416,cpp,rotate-array,"class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> temp(nums.size());
        for(int i=0;i<n;i++){
            temp[(i+k)%n]=nums[i+1];
        }
        nums=temp;
    }
};",None,"class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> temp(nums.size());
        for(int i=0;i<n;i++){
            temp[(i+k)%n]=nums[i];
        }
        nums=temp;
    }
};
"
417,cpp,minimum-time-to-complete-trips,"#define ll long long 
class Solution {
public:
    long long minimumTime(vector<int>& time, int totalTrips) {
        ll l = 1, r = 1e14;
        while(l <= r) {
            ll trip = 0, mid = (l + r) / 2;
            for(int i=0; i<time.size(); i++) trip += mid / time[i];
            if(trip <= totalTrips) l = mid + 1;
            else r = mid - 1;
        }
        return l;
    }
};",None,"class Solution {
public:
    long long minimumTime(vector<int>& time, int totalTrips) {
        long long l = 1, r = 1e14;
        while(l < r) {
            long long trip = 0, mid = l + (r - l) / 2;
            for(int i=0; i<time.size(); i++) trip += mid / time[i];
            if(trip <= totalTrips) l = mid + 1;
            else r = mid;
        }
        return l;
    }
};
"
417,cpp,minimum-time-to-complete-trips,"#define ll long long 
class Solution {
public:
    long long minimumTime(vector<int>& time, int totalTrips) {
        ll l = 1, r = 1e14;
        while(l <= r) {
            ll trip = 0, mid = (l + r) / 2;
            for(int i=0; i<time.size(); i++) trip += mid / time[i];
            if(trip <= totalTrips) l = mid + 1;
            else r = mid - 1;
        }
        return l;
    }
};",None,"#define ll long long 
class Solution {
public:
    long long minimumTime(vector<int>& time, int totalTrips) {
        ll l = 1, r = 1e14;
        while(l < r) {
            ll trip = 0, mid = (l + r) / 2;
            for(int i=0; i<time.size(); i++) trip += mid / time[i];
            if(trip <= totalTrips) l = mid + 1;
            else r = mid;
        }
        return l;
    }
};
"
417,cpp,minimum-time-to-complete-trips,"#define ll long long 
class Solution {
public:
    long long minimumTime(vector<int>& time, int totalTrips) {
        ll l = 1, r = 1e14;
        while(l <= r) {
            ll trip = 0, mid = (l + r) / 2;
            for(int i=0; i<time.size(); i++) trip += mid / time[i];
            if(trip <= totalTrips) l = mid + 1;
            else r = mid - 1;
        }
        return l;
    }
};",None,"#define ll long long 
class Solution {
public:
    long long minimumTime(vector<int>& time, int totalTrips) {
        ll l = 1, r = 1e14;
        while(l < r) {
            ll trip = 0, mid = l + (r - l) / 2;
            for(int i=0; i<time.size(); i++) trip += mid / time[i];
            if(trip <= totalTrips) l = mid + 1;
            else r = mid;
        }
        return l;
    }
};
"
418,cpp,moving-stones-until-consecutive-ii,"class Solution {
public:
    vector<int> numMovesStonesII(vector<int>& stones) {
        sort(stones.begin(), stones.end());

        int N = stones.size(), low = N;
        for (int i = 0, j = 0; j < N; ++j) {
            while (stones[j] - stones[i] + 1 > N) {
                ++i;
            }
            if (N - (j - i + 1) == 1 && N - (stones[j] - stones[i] + 1) == 2) {  
                low = min(low, 2);
            } else {
                low = min(low, N - (j - i + 1));
            }
        }

        int high = 1 + max((stones[N - 1] - stones[1] + 1) - N,  
                           (stones[N - 2] - stones[0] + 1) - N);  
        return {low, high};
    }
};",None,"class Solution {
public:
    vector<int> numMovesStonesII(vector<int>& stones) {
        sort(stones.begin(), stones.end());

        int N = stones.size(), low = N;
        for (int i = 0, j = 0; j < N; ++j) {
            while (stones[j] - stones[i] + 1 > N) {
                ++i;
            }
            if (N - (j - i + 1) == 1 && N - (stones[j] - stones[i] + 1) == 2) {  
                low = min(low, 2);
            } else {
                low = min(low, N - (j - i + 1));
            }
        }

        int high = 1 + max(stones[N - 1] - stones[1] + 1 - N,  
                           stones[N - 2] - stones[0] + 1 - N);  
        return {low, high};
    }
};
"
418,cpp,moving-stones-until-consecutive-ii,"class Solution {
public:
    vector<int> numMovesStonesII(vector<int>& stones) {
        sort(stones.begin(), stones.end());

        int N = stones.size(), low = N;
        for (int i = 0, j = 0; j < N; ++j) {
            while (stones[j] - stones[i] + 1 > N) {
                ++i;
            }
            if (N - (j - i + 1) == 1 && N - (stones[j] - stones[i] + 1) == 2) {  
                low = min(low, 2);
            } else {
                low = min(low, N - (j - i + 1));
            }
        }

        int high = 1 + max((stones[N - 1] - stones[1] + 1) - N,  
                           (stones[N - 2] - stones[0] + 1) - N);  
        return {low, high};
    }
};",None,"class Solution {
public:
    vector<int> numMovesStonesII(vector<int>& stones) {
        sort(stones.begin(), stones.end());

        int N = stones.size(), low = N;
        for (int i = 0, j = 0; j < N; ++j) {
            while (stones[j] - stones[i] + 1 > N) {
                ++i;
            }
            if (N - (j - i + 1) == 1 && N - (stones[j] - stones[i] + 1) == 2) {  
                low = min(low, 2);
            } else {
                low = min(low, N - (j - i + 1));
            }
        }

        int high = 1 + max(max(stones[N - 1] - stones[1] + 1 - N, 
                               stones[N - 2] - stones[0] + 1 - N), 0);  
        return {low, high};
    }
};
"
418,cpp,moving-stones-until-consecutive-ii,"class Solution {
public:
    vector<int> numMovesStonesII(vector<int>& stones) {
        sort(stones.begin(), stones.end());

        int N = stones.size(), low = N;
        for (int i = 0, j = 0; j < N; ++j) {
            while (stones[j] - stones[i] + 1 > N) {
                ++i;
            }
            if (N - (j - i + 1) == 1 && N - (stones[j] - stones[i] + 1) == 2) {  
                low = min(low, 2);
            } else {
                low = min(low, N - (j - i + 1));
            }
        }

        int high = 1 + max((stones[N - 1] - stones[1] + 1) - N,  
                           (stones[N - 2] - stones[0] + 1) - N);  
        return {low, high};
    }
};",None,"class Solution {
public:
    vector<int> numMovesStonesII(vector<int>& stones) {
        sort(stones.begin(), stones.end());

        int N = stones.size(), low = N;
        for (int i = 0, j = 0; j < N; ++j) {
            while (stones[j] - stones[i] + 1 > N) {
                ++i;
            }
            if (N - (j - i + 1) == 1 && N - (stones[j] - stones[i] + 1) == 2) {  
                low = min(low, 2);
            } else {
                low = min(low, N - (j - i + 1));
            }
        }

        int high = 1 + max(max(stones[N - 1] - stones[1] + 1 - N,
                           stones[N - 2] - stones[0] + 1 - N), 0);
        return {low, high};
    }
};
"
419,cpp,minimum-incompatibility,"class Solution {
public:
    const int inf = 0x3f3f3f3f;
    int minimumIncompatibility(vector<int>& nums, int k) {
      int n = nums.size();
      int sz = n/k;
      sort(nums.begin(), nums.end());
      int dp[1<<n][n];
      memset(dp, inf, sizeof(dp));
      for (int i = 0; i < n; ++i) { dp[0][i] = 0; }
      for (int m = 0; m < (1<<n)-1; ++m) {
        int cnt = __builtin_popcount(m);
        for (int i = 0; i < n; ++i) {
          if (dp[m][i] == inf) { continue; }
          if (cnt%sz == 0) {
            int j = __builtin_ffs(~m)-1;
            dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]);
          } else {
            for (int j = i+1; j < n; ++j) {
              if (m&(1<<j) && nums[j] == nums[i]) { continue; } 
              dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]+nums[j]-nums[i]);
            }
          }
        }
      }
      return dp[(1<<n)-1][n-1] == inf? -1: dp[(1<<n)-1][n-1];
    }
};",None,"class Solution {
public:
    const int inf = 0x3f3f3f3f;
    int minimumIncompatibility(vector<int>& nums, int k) {
      int n = nums.size();
      int sz = n/k;
      sort(nums.begin(), nums.end());
      int dp[1<<n][n];
      memset(dp, inf, sizeof(dp));
      for (int i = 0; i < n; ++i) { dp[0][i] = 0; }
      for (int m = 0; m < (1<<n)-1; ++m) {
        int cnt = __builtin_popcount(m);
        if (cnt%sz != 0) { continue; }
        for (int i = 0; i < n; ++i) {
          if (dp[m][i] == inf) { continue; }
          for (int j = i+1; j < n; ++j) {
            if (m&(1<<j) && nums[j] == nums[i]) { continue; }
            dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]+nums[j]-nums[i]);
          }
        }
      }
      int ans = inf;
      for (int i = 0; i < n; ++i) {
        ans = min(ans, dp[(1<<n)-1][i]);
      }
      return ans == inf? -1: ans;
    }
};
"
419,cpp,minimum-incompatibility,"class Solution {
public:
    const int inf = 0x3f3f3f3f;
    int minimumIncompatibility(vector<int>& nums, int k) {
      int n = nums.size();
      int sz = n/k;
      sort(nums.begin(), nums.end());
      int dp[1<<n][n];
      memset(dp, inf, sizeof(dp));
      for (int i = 0; i < n; ++i) { dp[0][i] = 0; }
      for (int m = 0; m < (1<<n)-1; ++m) {
        int cnt = __builtin_popcount(m);
        for (int i = 0; i < n; ++i) {
          if (dp[m][i] == inf) { continue; }
          if (cnt%sz == 0) {
            int j = __builtin_ffs(~m)-1;
            dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]);
          } else {
            for (int j = i+1; j < n; ++j) {
              if (m&(1<<j) && nums[j] == nums[i]) { continue; } 
              dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]+nums[j]-nums[i]);
            }
          }
        }
      }
      return dp[(1<<n)-1][n-1] == inf? -1: dp[(1<<n)-1][n-1];
    }
};",None,"class Solution {
public:
    const int inf = 0x3f3f3f3f;
    int minimumIncompatibility(vector<int>& nums, int k) {
      int n = nums.size();
      int sz = n/k;
      sort(nums.begin(), nums.end());
      int dp[1<<n][n];
      memset(dp, inf, sizeof(dp));
      for (int i = 0; i < n; ++i) { dp[0][i] = 0; }
      for (int m = 0; m < (1<<n)-1; ++m) {
        int cnt = __builtin_popcount(m);
        for (int i = 0; i < n; ++i) {
          if (dp[m][i] == inf) { continue; }
          if (cnt%sz == 0) {
            int j = __builtin_ffs(~m)-1;
            dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]);
          } else {
            for (int j = i+1; j < n; ++j) {
              if ((m>>j)&1 && nums[j] == nums[i]) { continue; } 
              dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]+nums[j]-nums[i]);
            }
          }
        }
      }
      return dp[(1<<n)-1][n-1] == inf? -1: dp[(1<<n)-1][n-1];
    }
};
"
419,cpp,minimum-incompatibility,"class Solution {
public:
    const int inf = 0x3f3f3f3f;
    int minimumIncompatibility(vector<int>& nums, int k) {
      int n = nums.size();
      int sz = n/k;
      sort(nums.begin(), nums.end());
      int dp[1<<n][n];
      memset(dp, inf, sizeof(dp));
      for (int i = 0; i < n; ++i) { dp[0][i] = 0; }
      for (int m = 0; m < (1<<n)-1; ++m) {
        int cnt = __builtin_popcount(m);
        for (int i = 0; i < n; ++i) {
          if (dp[m][i] == inf) { continue; }
          if (cnt%sz == 0) {
            int j = __builtin_ffs(~m)-1;
            dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]);
          } else {
            for (int j = i+1; j < n; ++j) {
              if (m&(1<<j) && nums[j] == nums[i]) { continue; } 
              dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]+nums[j]-nums[i]);
            }
          }
        }
      }
      return dp[(1<<n)-1][n-1] == inf? -1: dp[(1<<n)-1][n-1];
    }
};",None,"class Solution {
public:
    const int inf = 0x3f3f3f3f;
    int minimumIncompatibility(vector<int>& nums, int k) {
      int n = nums.size();
      int sz = n/k;
      sort(nums.begin(), nums.end());
      int dp[1<<n][n];
      memset(dp, inf, sizeof(dp));
      for (int i = 0; i < n; ++i) { dp[0][i] = 0; }
      for (int m = 0; m < (1<<n)-1; ++m) {
        int cnt = __builtin_popcount(m);
        for (int i = 0; i < n; ++i) {
          if (dp[m][i] == inf) { continue; }
          if (cnt%sz == 0) {
            int j = __builtin_ffs(~m)-1;
            dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]);
          } else {
            int prev_val = nums[i];
            int new_val = inf;
            int new_j = i;
            for (int j = i+1; j < n; ++j) {
              if (m&(1<<j) && nums[j] == prev_val) { continue; }
              
              if (nums[j] < new_val) {
                new_val = nums[j];
                new_j = j;
              }
            }
            dp[m|(1<<new_j)][new_j] = min(dp[m|(1<<new_j)][new_j],dp[m][i]+new_val-prev_val);
          }
        }
      }
      return dp[(1<<n)-1][n-1] == inf? -1: dp[(1<<n)-1][n-1];
    }
};
"
420,cpp,minimum-moves-to-reach-target-with-rotations,"class Solution {
    int n;
    vector<vector<int>> hmemo, vmemo;
    vector<vector<int>> *gridp;

    int dfs(bool h, int r, int c) {
        vector<vector<int>> & grid = *gridp;
        if (h && r == n-1 && c == n-2)
            return 0;
        int res = INT_MAX-1;
        if (h) {
            if (hmemo[r][c] > 0) {
                return hmemo[r][c];
            }
            hmemo[r][c] = INT_MAX-1;
            if (c+2 < n && grid[r][c+2] == 1) {
                res = min(res, 1+dfs(true, r, c+1));
            }
            if (r+1 < n && grid[r+1][c] == 1 && grid[r+1][c+1] == 1) {
                res = min(res, 1+dfs(true, r+1, c));
                res = min(res, 1+dfs(false, r, c));
            }
            hmemo[r][c] = res;
            return res;
        } else {
            if (vmemo[r][c] > 0) {
                return vmemo[r][c];
            }
            vmemo[r][c] = INT_MAX-1;
            if (r+2 < n && grid[r+2][c] == 1) {
                res = min(res, 1+dfs(false, r+1, c));
            }
            if (c+1 < n && grid[r][c+1] == 1 && grid[r+1][c+1] == 1) {
                res = min(res, 1+dfs(false, r, c+1));
                res = min(res, 1+dfs(true, r, c));
            }
            vmemo[r][c] = res;
            return res;
        }
    }

public:
    int minimumMoves(vector<vector<int>>& grid) {
        this->gridp = &grid;
        n = grid.size();
        hmemo = vector<vector<int>>(n, vector<int>(n, -1));
        vmemo = vector<vector<int>>(n, vector<int>(n, -1));
        int res = dfs(true, 0, 0);
        return res < INT_MAX-1 ? res : -1;
    }
};",None,"class Solution {
    int n;
    vector<vector<int>> hmemo, vmemo;
    vector<vector<int>> *gridp;

    int dfs(bool h, int r, int c) {
        vector<vector<int>> & grid = *gridp;
        if (h && r == n-1 && c == n-2)
            return 0;
        int res = INT_MAX;
        if (h) {
            if (hmemo[r][c] != -1) {
                return hmemo[r][c];
            }
            hmemo[r][c] = INT_MAX;
            if (c+2 < n && grid[r][c+2] == 1) {
                res = min(res, 1+dfs(true, r, c+1));
            }
            if (r+1 < n && grid[r+1][c] == 1 && grid[r+1][c+1] == 1) {
                res = min(res, 1+dfs(true, r+1, c));
                res = min(res, 1+dfs(false, r, c));
            }
            hmemo[r][c] = res == INT_MAX ? -1 : res;
            return res;
        } else {
            if (vmemo[r][c] != -1) {
                return vmemo[r][c];
            }
            vmemo[r][c] = INT_MAX;
            if (r+2 < n && grid[r+2][c] == 1) {
                res = min(res, 1+dfs(false, r+1, c));
            }
            if (c+1 < n && grid[r][c+1] == 1 && grid[r+1][c+1] == 1) {
                res = min(res, 1+dfs(false, r, c+1));
                res = min(res, 1+dfs(true, r, c));
            }
            vmemo[r][c] = res == INT_MAX ? -1 : res;
            return res;
        }
    }

public:
    int minimumMoves(vector<vector<int>>& grid) {
        this->gridp = &grid;
        n = grid.size();
        hmemo = vector<vector<int>>(n, vector<int>(n, -1));
        vmemo = vector<vector<int>>(n, vector<int>(n, -1));
        int res = dfs(true, 0, 0);
        return res == INT_MAX ? -1 : res;
    }
};
"
420,cpp,minimum-moves-to-reach-target-with-rotations,"class Solution {
    int n;
    vector<vector<int>> hmemo, vmemo;
    vector<vector<int>> *gridp;

    int dfs(bool h, int r, int c) {
        vector<vector<int>> & grid = *gridp;
        if (h && r == n-1 && c == n-2)
            return 0;
        int res = INT_MAX-1;
        if (h) {
            if (hmemo[r][c] > 0) {
                return hmemo[r][c];
            }
            hmemo[r][c] = INT_MAX-1;
            if (c+2 < n && grid[r][c+2] == 1) {
                res = min(res, 1+dfs(true, r, c+1));
            }
            if (r+1 < n && grid[r+1][c] == 1 && grid[r+1][c+1] == 1) {
                res = min(res, 1+dfs(true, r+1, c));
                res = min(res, 1+dfs(false, r, c));
            }
            hmemo[r][c] = res;
            return res;
        } else {
            if (vmemo[r][c] > 0) {
                return vmemo[r][c];
            }
            vmemo[r][c] = INT_MAX-1;
            if (r+2 < n && grid[r+2][c] == 1) {
                res = min(res, 1+dfs(false, r+1, c));
            }
            if (c+1 < n && grid[r][c+1] == 1 && grid[r+1][c+1] == 1) {
                res = min(res, 1+dfs(false, r, c+1));
                res = min(res, 1+dfs(true, r, c));
            }
            vmemo[r][c] = res;
            return res;
        }
    }

public:
    int minimumMoves(vector<vector<int>>& grid) {
        this->gridp = &grid;
        n = grid.size();
        hmemo = vector<vector<int>>(n, vector<int>(n, -1));
        vmemo = vector<vector<int>>(n, vector<int>(n, -1));
        int res = dfs(true, 0, 0);
        return res < INT_MAX-1 ? res : -1;
    }
};",None,"class Solution {
    int n;
    vector<vector<int>> hmemo, vmemo;
    vector<vector<int>> *gridp;

    int dfs(bool h, int r, int c) {
        vector<vector<int>> & grid = *gridp;
        if (h && r == n-1 && c == n-2)
            return 0;
        int res = INT_MAX;
        if (h) {
            if (hmemo[r][c] != -1) {
                return hmemo[r][c];
            }
            hmemo[r][c] = INT_MAX;
            if (c+2 < n && grid[r][c+2] == 0) {
                res = min(res, 1+dfs(true, r, c+1));
            }
            if (r+1 < n && grid[r+1][c] == 0 && grid[r+1][c+1] == 0) {
                res = min(res, 1+dfs(true, r+1, c));
                res = min(res, 1+dfs(false, r, c));
            }
            hmemo[r][c] = (res == INT_MAX) ? -1 : res;
            return hmemo[r][c];
        } else {
            if (vmemo[r][c] != -1) {
                return vmemo[r][c];
            }
            vmemo[r][c] = INT_MAX;
            if (r+2 < n && grid[r+2][c] == 0) {
                res = min(res, 1+dfs(false, r+1, c));
            }
            if (c+1 < n && grid[r][c+1] == 0 && grid[r+1][c+1] == 0) {
                res = min(res, 1+dfs(false, r, c+1));
                res = min(res, 1+dfs(true, r, c));
            }
            vmemo[r][c] = (res == INT_MAX) ? -1 : res;
            return vmemo[r][c];
        }
    }

public:
    int minimumMoves(vector<vector<int>>& grid) {
        this->gridp = &grid;
        n = grid.size();
        hmemo = vector<vector<int>>(n, vector<int>(n, -1));
        vmemo = vector<vector<int>>(n, vector<int>(n, -1));
        int res = dfs(true, 0, 0);
        return res != -1 ? res : -1;
    }
};
"
420,cpp,minimum-moves-to-reach-target-with-rotations,"class Solution {
    int n;
    vector<vector<int>> hmemo, vmemo;
    vector<vector<int>> *gridp;

    int dfs(bool h, int r, int c) {
        vector<vector<int>> & grid = *gridp;
        if (h && r == n-1 && c == n-2)
            return 0;
        int res = INT_MAX-1;
        if (h) {
            if (hmemo[r][c] > 0) {
                return hmemo[r][c];
            }
            hmemo[r][c] = INT_MAX-1;
            if (c+2 < n && grid[r][c+2] == 1) {
                res = min(res, 1+dfs(true, r, c+1));
            }
            if (r+1 < n && grid[r+1][c] == 1 && grid[r+1][c+1] == 1) {
                res = min(res, 1+dfs(true, r+1, c));
                res = min(res, 1+dfs(false, r, c));
            }
            hmemo[r][c] = res;
            return res;
        } else {
            if (vmemo[r][c] > 0) {
                return vmemo[r][c];
            }
            vmemo[r][c] = INT_MAX-1;
            if (r+2 < n && grid[r+2][c] == 1) {
                res = min(res, 1+dfs(false, r+1, c));
            }
            if (c+1 < n && grid[r][c+1] == 1 && grid[r+1][c+1] == 1) {
                res = min(res, 1+dfs(false, r, c+1));
                res = min(res, 1+dfs(true, r, c));
            }
            vmemo[r][c] = res;
            return res;
        }
    }

public:
    int minimumMoves(vector<vector<int>>& grid) {
        this->gridp = &grid;
        n = grid.size();
        hmemo = vector<vector<int>>(n, vector<int>(n, -1));
        vmemo = vector<vector<int>>(n, vector<int>(n, -1));
        int res = dfs(true, 0, 0);
        return res < INT_MAX-1 ? res : -1;
    }
};",None,"class Solution {
    int n;
    vector<vector<int>> hmemo, vmemo;
    vector<vector<int>> *gridp;

    int dfs(bool h, int r, int c) {
        vector<vector<int>> & grid = *gridp;
        if (h && r == n-1 && c == n-2)
            return 0;
        int res = INT_MAX;
        if (h) {
            if (hmemo[r][c] != INT_MAX) {
                return hmemo[r][c];
            }
            hmemo[r][c] = INT_MAX;
            if (c+2 < n && grid[r][c+2] == 0) {
                res = min(res, 1+dfs(true, r, c+1));
            }
            if (r+1 < n && grid[r+1][c] == 0 && grid[r+1][c+1] == 0) {
                res = min(res, 1+dfs(true, r+1, c));
                res = min(res, 1+dfs(false, r, c));
            }
            hmemo[r][c] = res == INT_MAX ? -1 : res;
            return hmemo[r][c];
        } else {
            if (vmemo[r][c] != INT_MAX) {
                return vmemo[r][c];
            }
            vmemo[r][c] = INT_MAX;
            if (r+2 < n && grid[r+2][c] == 0) {
                res = min(res, 1+dfs(false, r+1, c));
            }
            if (c+1 < n && grid[r][c+1] == 0 && grid[r+1][c+1] == 0) {
                res = min(res, 1+dfs(false, r, c+1));
                res = min(res, 1+dfs(true, r, c));
            }
            vmemo[r][c] = res == INT_MAX ? -1 : res;
            return vmemo[r][c];
        }
    }

public:
    int minimumMoves(vector<vector<int>>& grid) {
        this->gridp = &grid;
        n = grid.size();
        hmemo = vector<vector<int>>(n, vector<int>(n, INT_MAX));
        vmemo = vector<vector<int>>(n, vector<int>(n, INT_MAX));
        int res = dfs(true, 0, 0);
        return res == INT_MAX ? -1 : res;
    }
};
"
421,cpp,find-the-winner-of-the-circular-game,"class Solution {
public:
    int findTheWinner(int n, int k) {
        queue<int> q;
        for(int i=1;i<=n;i++){
            q.push(i);
        }
        while(q.size()!=1){
            int temp=k-1;
            while(temp>=0){
                int t=q.front();
                q.pop();
                q.push(t);
                temp--;
            }
            q.pop();
        }
        return q.front();
    }
};",None,"class Solution {
public:
    int findTheWinner(int n, int k) {
        queue<int> q;
        for(int i=1;i<=n;i++){
            q.push(i);
        }
        while(q.size()!=1){
            for(int i=1;i<k;i++){
                int t=q.front();
                q.pop();
                q.push(t);
            }
            q.pop();
        }
        return q.front();
    }
};
"
421,cpp,find-the-winner-of-the-circular-game,"class Solution {
public:
    int findTheWinner(int n, int k) {
        queue<int> q;
        for(int i=1;i<=n;i++){
            q.push(i);
        }
        while(q.size()!=1){
            int temp=k-1;
            while(temp>=0){
                int t=q.front();
                q.pop();
                q.push(t);
                temp--;
            }
            q.pop();
        }
        return q.front();
    }
};",None,"class Solution {
public:
    int findTheWinner(int n, int k) {
        queue<int> q;
        for(int i=1;i<=n;i++){
            q.push(i);
        }
        while(q.size()!=1){
            for(int i=1;i<k;i++){
                int t=q.front();
                q.pop();
                q.push(t);
            }
            q.pop();
        }
        return q.front();
    }
};
"
421,cpp,find-the-winner-of-the-circular-game,"class Solution {
public:
    int findTheWinner(int n, int k) {
        queue<int> q;
        for(int i=1;i<=n;i++){
            q.push(i);
        }
        while(q.size()!=1){
            int temp=k-1;
            while(temp>=0){
                int t=q.front();
                q.pop();
                q.push(t);
                temp--;
            }
            q.pop();
        }
        return q.front();
    }
};",None,"class Solution {
public:
    int findTheWinner(int n, int k) {
        queue<int> q;
        for(int i=1;i<=n;i++){
            q.push(i);
        }
        while(q.size()!=1){
            for(int i=1;i<k;i++){
                int t=q.front();
                q.pop();
                q.push(t);
            }
            q.pop();
        }
        return q.front();
    }
};
"
422,cpp,minimum-operations-to-make-the-array-increasing,"class Solution {
public:
    int minOperations(vector<int>& nums) {
       int count = 0; 
       for(int i=0; i<nums.size(); i++) if(nums[i] <= nums[i+1]) { count += nums[i+1]+1-nums[i]; nums[i] = nums[i+1]+1; }

       return count; 
    }
};",None,"class Solution {
public:
    int minOperations(vector<int>& nums) {
       int count = 0; 
       for(int i=0; i<nums.size()-1; i++) {
           if(nums[i] >= nums[i+1]) {
               count += nums[i] - nums[i+1] + 1;
               nums[i+1] = nums[i] + 1;
           }
       }

       return count; 
    }
};
"
422,cpp,minimum-operations-to-make-the-array-increasing,"class Solution {
public:
    int minOperations(vector<int>& nums) {
       int count = 0; 
       for(int i=0; i<nums.size(); i++) if(nums[i] <= nums[i+1]) { count += nums[i+1]+1-nums[i]; nums[i] = nums[i+1]+1; }

       return count; 
    }
};",None,"class Solution {
public:
    int minOperations(vector<int>& nums) {
       int count = 0; 
       for(int i=0; i<nums.size()-1; i++) {
           if(nums[i] >= nums[i+1]) {
               count += nums[i] - nums[i+1] + 1;
               nums[i+1] = nums[i] + 1;
           }
       }

       return count; 
    }
};
"
422,cpp,minimum-operations-to-make-the-array-increasing,"class Solution {
public:
    int minOperations(vector<int>& nums) {
       int count = 0; 
       for(int i=0; i<nums.size(); i++) if(nums[i] <= nums[i+1]) { count += nums[i+1]+1-nums[i]; nums[i] = nums[i+1]+1; }

       return count; 
    }
};",None,"class Solution {
public:
    int minOperations(vector<int>& nums) {
       int count = 0; 
       for(int i=0; i<nums.size()-1; i++) {
           if(nums[i] >= nums[i+1]) {
               int diff = nums[i] - nums[i+1] + 1;
               count += diff;
               nums[i+1] += diff;
           }
       }

       return count; 
    }
};
"
423,cpp,k-closest-points-to-origin,"class Solution {
    class info{
        public:
        int x;
        int y;
        float distance; 
        info(int a , int b)
        {
            x = a;
            y = b;
            distance = sqrt (x*x + y*y);
        }
    };
class compare{
   public:
   bool operator()(info* point1 , info* point2)
   {
       if( point1->distance >= point2->distance)
       {
           return true;
       }
       else{
           return false;
       }
   }
};
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        priority_queue<info*,vector<info*>,compare> minheap;
        for( int i = 0 ; i < points.size() ; i ++)
        {
            int x1 = points[i][0];
            int y1 = points[i][1];
            info* newinfo = new info(x1,y1);
            minheap.push(newinfo);
        }
        vector<vector<int>> ans;
        while(k > 0)
        {
            info* temp = minheap.top();
            minheap.pop();
            int xval = temp->x;
            int yval = temp->y;
            vector<int> temp2 ;
            temp2.push_back(xval);
            temp2.push_back(yval);
            ans.push_back(temp2);
            k--;
        }
        return ans;
    }
};",None,"class Solution {
    class info{
        public:
        int x;
        int y;
        float distance; 
        info(int a , int b)
        {
            x = a;
            y = b;
            distance = sqrt (x*x + y*y);
        }
    };
class compare{
   public:
   bool operator()(info* point1 , info* point2)
   {
       if( point1->distance > point2->distance)
       {
           return true;
       }
       else{
           return false;
       }
   }
};
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        priority_queue<info*,vector<info*>,compare> minheap;
        for( int i = 0 ; i < points.size() ; i ++)
        {
            int x1 = points[i][0];
            int y1 = points[i][1];
            info* newinfo = new info(x1,y1);
            minheap.push(newinfo);
        }
        vector<vector<int>> ans;
        while(k > 0 && !minheap.empty())
        {
            info* temp = minheap.top();
            minheap.pop();
            int xval = temp->x;
            int yval = temp->y;
            vector<int> temp2 ;
            temp2.push_back(xval);
            temp2.push_back(yval);
            ans.push_back(temp2);
            k--;
        }
        return ans;
    }
};
"
423,cpp,k-closest-points-to-origin,"class Solution {
    class info{
        public:
        int x;
        int y;
        float distance; 
        info(int a , int b)
        {
            x = a;
            y = b;
            distance = sqrt (x*x + y*y);
        }
    };
class compare{
   public:
   bool operator()(info* point1 , info* point2)
   {
       if( point1->distance >= point2->distance)
       {
           return true;
       }
       else{
           return false;
       }
   }
};
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        priority_queue<info*,vector<info*>,compare> minheap;
        for( int i = 0 ; i < points.size() ; i ++)
        {
            int x1 = points[i][0];
            int y1 = points[i][1];
            info* newinfo = new info(x1,y1);
            minheap.push(newinfo);
        }
        vector<vector<int>> ans;
        while(k > 0)
        {
            info* temp = minheap.top();
            minheap.pop();
            int xval = temp->x;
            int yval = temp->y;
            vector<int> temp2 ;
            temp2.push_back(xval);
            temp2.push_back(yval);
            ans.push_back(temp2);
            k--;
        }
        return ans;
    }
};",None,"class Solution {
    class info{
        public:
        int x;
        int y;
        float distance; 
        info(int a , int b)
        {
            x = a;
            y = b;
            distance = sqrt (x*x + y*y);
        }
    };
class compare{
   public:
   bool operator()(info* point1 , info* point2)
   {
       if( point1->distance >= point2->distance)
       {
           return true;
       }
       else{
           return false;
       }
   }
};
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        priority_queue<info*,vector<info*>,compare> minheap;
        for( int i = 0 ; i < points.size() ; i ++)
        {
            int x1 = points[i][0];
            int y1 = points[i][1];
            info* newinfo = new info(x1,y1);
            minheap.push(newinfo);
        }
        vector<vector<int>> ans;
        while(k-- > 0)
        {
            info* temp = minheap.top();
            minheap.pop();
            int xval = temp->x;
            int yval = temp->y;
            vector<int> temp2 ;
            temp2.push_back(xval);
            temp2.push_back(yval);
            ans.push_back(temp2);
        }
        return ans;
    }
};
"
423,cpp,k-closest-points-to-origin,"class Solution {
    class info{
        public:
        int x;
        int y;
        float distance; 
        info(int a , int b)
        {
            x = a;
            y = b;
            distance = sqrt (x*x + y*y);
        }
    };
class compare{
   public:
   bool operator()(info* point1 , info* point2)
   {
       if( point1->distance >= point2->distance)
       {
           return true;
       }
       else{
           return false;
       }
   }
};
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        priority_queue<info*,vector<info*>,compare> minheap;
        for( int i = 0 ; i < points.size() ; i ++)
        {
            int x1 = points[i][0];
            int y1 = points[i][1];
            info* newinfo = new info(x1,y1);
            minheap.push(newinfo);
        }
        vector<vector<int>> ans;
        while(k > 0)
        {
            info* temp = minheap.top();
            minheap.pop();
            int xval = temp->x;
            int yval = temp->y;
            vector<int> temp2 ;
            temp2.push_back(xval);
            temp2.push_back(yval);
            ans.push_back(temp2);
            k--;
        }
        return ans;
    }
};",None,"class Solution {
    class info{
        public:
        int x;
        int y;
        float distance; 
        info(int a , int b)
        {
            x = a;
            y = b;
            distance = sqrt (x*x + y*y);
        }
    };
class compare{
   public:
   bool operator()(info* point1 , info* point2)
   {
       if( point1->distance >= point2->distance)
       {
           return true;
       }
       else{
           return false;
       }
   }
};
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        priority_queue<info*,vector<info*>,compare> minheap;
        for( int i = 0 ; i < points.size() ; i ++)
        {
            int x1 = points[i][0];
            int y1 = points[i][1];
            info* newinfo = new info(x1,y1);
            minheap.push(newinfo);
        }
        vector<vector<int>> ans;
        while(k-- > 0)
        {
            info* temp = minheap.top();
            minheap.pop();
            int xval = temp->x;
            int yval = temp->y;
            vector<int> temp2 ;
            temp2.push_back(xval);
            temp2.push_back(yval);
            ans.push_back(temp2);
        }
        return ans;
    }
};
"
424,cpp,most-beautiful-item-for-each-query,"class Solution {
    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {
        int ans = 0, s = 0, e = items.size() - 1;
        while(s <= e) {
            int m = (s + e) / 2;
            if(items[m][0] <= t) ans = beauty[m], s = m + 1;
            else s = m + 1; 
        }
        return ans;
    }

public:
    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {
        sort(items.begin(), items.end());
        vector<int> ans, beauty(items.size(), items[0][1]);

        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);

        for(int i : queries) ans.push_back(bs(items, i, beauty));
        return ans;
    }
};",None,"class Solution {
    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {
        int s = 0, e = items.size() - 1;
        while(s <= e) {
            int m = (s + e) / 2;
            if(items[m][0] <= t) {
                ans = max(ans, beauty[m]);
                s = m + 1;
            }
            else s = m + 1; 
        }
    }

public:
    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {
        sort(items.begin(), items.end());
        vector<int> ans, beauty(items.size());
        beauty[0] = items[0][1];

        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);

        for(int i : queries) ans.push_back(bs(items, i, beauty));
        return ans;
    }
};
"
424,cpp,most-beautiful-item-for-each-query,"class Solution {
    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {
        int ans = 0, s = 0, e = items.size() - 1;
        while(s <= e) {
            int m = (s + e) / 2;
            if(items[m][0] <= t) ans = beauty[m], s = m + 1;
            else s = m + 1; 
        }
        return ans;
    }

public:
    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {
        sort(items.begin(), items.end());
        vector<int> ans, beauty(items.size(), items[0][1]);

        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);

        for(int i : queries) ans.push_back(bs(items, i, beauty));
        return ans;
    }
};",None,"class Solution {
    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {
        int ans = 0, s = 0, e = items.size() - 1;
        while(s <= e) {
            int m = (s + e) / 2;
            if(items[m][0] <= t) ans = max(ans, beauty[m]), s = m + 1;
            else s = m + 1; 
        }
        return ans;
    }

public:
    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {
        sort(items.begin(), items.end());
        vector<int> ans, beauty(items.size());

        beauty[0] = items[0][1];
        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);

        for(int i : queries) ans.push_back(bs(items, i, beauty));
        return ans;
    }
};
"
424,cpp,most-beautiful-item-for-each-query,"class Solution {
    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {
        int ans = 0, s = 0, e = items.size() - 1;
        while(s <= e) {
            int m = (s + e) / 2;
            if(items[m][0] <= t) ans = beauty[m], s = m + 1;
            else s = m + 1; 
        }
        return ans;
    }

public:
    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {
        sort(items.begin(), items.end());
        vector<int> ans, beauty(items.size(), items[0][1]);

        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);

        for(int i : queries) ans.push_back(bs(items, i, beauty));
        return ans;
    }
};",None,"class Solution {
    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {
        int s = 0, e = items.size() - 1;
        while(s <= e) {
            int m = (s + e) / 2;
            if(items[m][0] <= t) {
                ans = max(ans, beauty[m]);
                s = m + 1;
            }
            else {
                e = m - 1;
            }
        }
        return ans;
    }

public:
    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {
        sort(items.begin(), items.end());
        vector<int> ans, beauty(items.size());
        beauty[0] = items[0][1];
        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);

        for(int i : queries) ans.push_back(bs(items, i, beauty));
        return ans;
    }
};
"
425,cpp,sort-list,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        vector<int>vec1;
    ListNode*temp= head;
    while(temp!=NULL){
vec1.push_back(temp->val);
temp= temp->next;
    }
    sort(vec1.begin(),vec1.end());
    ListNode*curr= head;
   for(int i=0;i<vec1.size();i++){
       curr->val=vec1[i+1];
       curr= curr->next;
   }
   return head;
    }
    

};",None,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        vector<int>vec1;
    ListNode*temp= head;
    while(temp!=NULL){
vec1.push_back(temp->val);
temp= temp->next;
    }
    sort(vec1.begin(),vec1.end());
    ListNode*curr= head;
   for(int i=0;i<vec1.size();i++){
       curr->val=vec1[i];
       curr= curr->next;
   }
   return head;
    }
    

};
"
425,cpp,sort-list,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        vector<int>vec1;
    ListNode*temp= head;
    while(temp!=NULL){
vec1.push_back(temp->val);
temp= temp->next;
    }
    sort(vec1.begin(),vec1.end());
    ListNode*curr= head;
   for(int i=0;i<vec1.size();i++){
       curr->val=vec1[i+1];
       curr= curr->next;
   }
   return head;
    }
    

};",None,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        vector<int>vec1;
    ListNode*temp= head;
    while(temp!=NULL){
vec1.push_back(temp->val);
temp= temp->next;
    }
    sort(vec1.begin(),vec1.end());
    ListNode*curr= head;
   for(int i=0;i<vec1.size();i++){
       curr->val=vec1[i];
       curr= curr->next;
   }
   return head;
    }
    

};
"
425,cpp,sort-list,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        vector<int>vec1;
    ListNode*temp= head;
    while(temp!=NULL){
vec1.push_back(temp->val);
temp= temp->next;
    }
    sort(vec1.begin(),vec1.end());
    ListNode*curr= head;
   for(int i=0;i<vec1.size();i++){
       curr->val=vec1[i+1];
       curr= curr->next;
   }
   return head;
    }
    

};",None,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        vector<int>vec1;
    ListNode*temp= head;
    while(temp!=NULL){
vec1.push_back(temp->val);
temp= temp->next;
    }
    sort(vec1.begin(),vec1.end());
    ListNode*curr= head;
   for(int i=0;i<vec1.size();i++){
       curr->val=vec1[i];
       curr= curr->next;
   }
   return head;
    }
    

};
"
426,cpp,find-the-minimum-and-maximum-number-of-nodes-between-critical-points,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        ios_base::sync_with_stdio(false);
 if(head==NULL || head->next==NULL ||head->next->next==NULL){
     return {-1,-1};
 }
        ListNode* temp2=head->next;
        ListNode* temp3=head->next->next;
      vector<int>v;
      int i=2;
      while(head){
          if((head->val<temp2->val)&&(temp3->val<temp2->val)){
              v.push_back(i);
          }
          else if((head->val>temp2->val)&&(temp3->val>temp2->val)){
              v.push_back(i);
          }
          i++;
          head=head->next;
          temp2=temp2->next;
          temp3=temp3->next;
      }
      if(v.size()<2){
           return {-1,-1};
      }
      int mini=INT_MAX;
      for(int i=1;i<v.size();i++){
          mini=min(mini,(v[i]-v[i-1]));
      }
        return {mini,(v[v.size()-1]-v[0])};
    }
};",None,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        if(head==NULL || head->next==NULL ||head->next->next==NULL){
            return {-1,-1};
        }
        ListNode* temp2=head->next;
        ListNode* temp3=head->next->next;
        vector<int>v;
        int i=2;
        while(temp3!=NULL){
            if((head->val<temp2->val)&&(temp3->val<temp2->val)){
                v.push_back(i);
            }
            else if((head->val>temp2->val)&&(temp3->val>temp2->val)){
                v.push_back(i);
            }
            i++;
            head=temp2;
            temp2=temp3;
            temp3=temp3->next;
        }
        if(v.size()<2){
             return {-1,-1};
        }
        int mini=INT_MAX;
        for(int i=1;i<v.size();i++){
            mini=min(mini,(v[i]-v[i-1]));
        }
        return {mini,(v[v.size()-1]-v[0])};
    }
};
"
426,cpp,find-the-minimum-and-maximum-number-of-nodes-between-critical-points,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        ios_base::sync_with_stdio(false);
 if(head==NULL || head->next==NULL ||head->next->next==NULL){
     return {-1,-1};
 }
        ListNode* temp2=head->next;
        ListNode* temp3=head->next->next;
      vector<int>v;
      int i=2;
      while(head){
          if((head->val<temp2->val)&&(temp3->val<temp2->val)){
              v.push_back(i);
          }
          else if((head->val>temp2->val)&&(temp3->val>temp2->val)){
              v.push_back(i);
          }
          i++;
          head=head->next;
          temp2=temp2->next;
          temp3=temp3->next;
      }
      if(v.size()<2){
           return {-1,-1};
      }
      int mini=INT_MAX;
      for(int i=1;i<v.size();i++){
          mini=min(mini,(v[i]-v[i-1]));
      }
        return {mini,(v[v.size()-1]-v[0])};
    }
};",None,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        if(head==NULL || head->next==NULL ||head->next->next==NULL){
            return {-1,-1};
        }
        ListNode* temp2=head->next;
        ListNode* temp3=head->next->next;
        vector<int> v;
        int i=2;
        while(temp3!=NULL){
            if((head->val<temp2->val)&&(temp3->val<temp2->val)){
                v.push_back(i);
            }
            else if((head->val>temp2->val)&&(temp3->val>temp2->val)){
                v.push_back(i);
            }
            i++;
            head=temp2;
            temp2=temp3;
            temp3=temp3->next;
        }
        if(v.size()<2){
             return {-1,-1};
        }
        int mini=INT_MAX;
        for(int i=1;i<v.size();i++){
            mini=min(mini,(v[i]-v[i-1]));
        }
        return {mini,(v[v.size()-1]-v[0])};
    }
};
"
426,cpp,find-the-minimum-and-maximum-number-of-nodes-between-critical-points,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        ios_base::sync_with_stdio(false);
 if(head==NULL || head->next==NULL ||head->next->next==NULL){
     return {-1,-1};
 }
        ListNode* temp2=head->next;
        ListNode* temp3=head->next->next;
      vector<int>v;
      int i=2;
      while(head){
          if((head->val<temp2->val)&&(temp3->val<temp2->val)){
              v.push_back(i);
          }
          else if((head->val>temp2->val)&&(temp3->val>temp2->val)){
              v.push_back(i);
          }
          i++;
          head=head->next;
          temp2=temp2->next;
          temp3=temp3->next;
      }
      if(v.size()<2){
           return {-1,-1};
      }
      int mini=INT_MAX;
      for(int i=1;i<v.size();i++){
          mini=min(mini,(v[i]-v[i-1]));
      }
        return {mini,(v[v.size()-1]-v[0])};
    }
};",None,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        ios_base::sync_with_stdio(false);
        if(head==NULL || head->next==NULL || head->next->next==NULL){
            return {-1,-1};
        }
        ListNode* temp2=head->next;
        ListNode* temp3=head->next->next;
        vector<int> v;
        int i=2;
        while(temp2!=NULL && temp3!=NULL){
            if((head->val<temp2->val && temp2->val<temp3->val) || (head->val>temp2->val && temp2->val>temp3->val)){
                v.push_back(i);
            }
            i++;
            head=head->next;
            temp2=temp2->next;
            temp3=temp3->next;
            if(head==NULL || head->next==NULL || head->next->next==NULL){
                break;
            }
        }
        if(v.size()<2){
             return {-1,-1};
        }
        int mini=INT_MAX;
        for(int i=1;i<v.size();i++){
            mini=min(mini,(v[i]-v[i-1]));
        }
        return {mini,(v[v.size()-1]-v[0])};
    }
};
"
427,cpp,find-the-student-that-will-replace-the-chalk,"class Solution {
public:
    int chalkReplacer(vector<int>& chalk, int k) {
       long long sum =0;
       for(int i=0; i<chalk.size();i++){
           sum+=chalk[i];
       }

       if(k%sum == 0){
           int x = k%sum;
           for(int i=0; i<chalk.size();i++){
               x-=chalk[i];
               if(x<0){
                   return i;
                   break;
               }
           }
       }

       return 0;
    }
};",None,"class Solution {
public:
    int chalkReplacer(vector<int>& chalk, int k) {
       long long sum =0;
       for(int i=0; i<chalk.size();i++){
           sum+=chalk[i];
       }

       if(k%sum == 0){
           k %= sum;
           for(int i=0; i<chalk.size();i++){
               k -= chalk[i];
               if(k<0){
                   return i;
               }
           }
       }

       return 0;
    }
};
"
427,cpp,find-the-student-that-will-replace-the-chalk,"class Solution {
public:
    int chalkReplacer(vector<int>& chalk, int k) {
       long long sum =0;
       for(int i=0; i<chalk.size();i++){
           sum+=chalk[i];
       }

       if(k%sum == 0){
           int x = k%sum;
           for(int i=0; i<chalk.size();i++){
               x-=chalk[i];
               if(x<0){
                   return i;
                   break;
               }
           }
       }

       return 0;
    }
};",None,"class Solution {
public:
    int chalkReplacer(vector<int>& chalk, int k) {
       long long sum =0;
       for(int i=0; i<chalk.size(); i++){
           sum += chalk[i];
       }

       if(k >= sum) {
           k %= sum;
       }

       for(int i=0; i<chalk.size(); i++){
           k -= chalk[i];
           if(k < 0){
               return i;
           }
       }

       return -1; // this line is added to satisfy the compiler
    }
};
"
427,cpp,find-the-student-that-will-replace-the-chalk,"class Solution {
public:
    int chalkReplacer(vector<int>& chalk, int k) {
       long long sum =0;
       for(int i=0; i<chalk.size();i++){
           sum+=chalk[i];
       }

       if(k%sum == 0){
           int x = k%sum;
           for(int i=0; i<chalk.size();i++){
               x-=chalk[i];
               if(x<0){
                   return i;
                   break;
               }
           }
       }

       return 0;
    }
};",None,"class Solution {
public:
    int chalkReplacer(vector<int>& chalk, int k) {
       long long sum =0;
       for(int i=0; i<chalk.size();i++){
           sum+=chalk[i];
       }

       if(k%sum == 0){
           int x = k%sum;
           for(int i=0; i<chalk.size();i++){
               x-=chalk[i];
               if(x<0){
                   return i;
               }
           }
       }

       return k%sum == 0 ? chalk.size() : k%sum;
    }
};
"
428,cpp,extra-characters-in-a-string,"class Solution {
public:
    int rec(int ind,string &s,set<string>&st,vector<int>&dp)
    {
        if (ind==s.size()) return 0;
        if (dp[ind]!=-1) return dp[ind];
        int ans=s.size()-ind;
        for (int i=ind;i<s.size();i++)
        {
           string temp=s.substr(ind,i-ind+1);
           if (st.find(temp)!=st.end())
           {
              ans=min(ans,rec(i+1,s,st,dp));
           }
        }
        ans=min(ans,rec(ind,s,st,dp)); 
        return dp[ind]=ans;
    }
    int minExtraChar(string s, vector<string>& dictionary) 
    {
        set<string>st;
        int n=s.size();
        vector<int>dp(n,-1);
        for (auto it:dictionary)
        {
            st.insert(it);
        }
        return rec(0,s,st,dp);
    }
};",None,"class Solution {
public:
    int rec(int ind,string &s,set<string>&st,vector<int>&dp)
    {
        if (ind==s.size()) return 0;
        if (dp[ind]!=-1) return dp[ind];
        int ans=s.size()-ind;
        for (int i=ind;i<s.size();i++)
        {
           string temp=s.substr(ind,i-ind+1);
           if (st.find(temp)!=st.end())
           {
              ans=min(ans,1+rec(i+1,s,st,dp));
           }
        }
        return dp[ind]=ans;
    }
    int minExtraChar(string s, vector<string>& dictionary) 
    {
        set<string>st;
        int n=s.size();
        vector<int>dp(n,-1);
        for (auto it:dictionary)
        {
            st.insert(it);
        }
        return rec(0,s,st,dp);
    }
};
"
428,cpp,extra-characters-in-a-string,"class Solution {
public:
    int rec(int ind,string &s,set<string>&st,vector<int>&dp)
    {
        if (ind==s.size()) return 0;
        if (dp[ind]!=-1) return dp[ind];
        int ans=s.size()-ind;
        for (int i=ind;i<s.size();i++)
        {
           string temp=s.substr(ind,i-ind+1);
           if (st.find(temp)!=st.end())
           {
              ans=min(ans,rec(i+1,s,st,dp));
           }
        }
        ans=min(ans,rec(ind,s,st,dp)); 
        return dp[ind]=ans;
    }
    int minExtraChar(string s, vector<string>& dictionary) 
    {
        set<string>st;
        int n=s.size();
        vector<int>dp(n,-1);
        for (auto it:dictionary)
        {
            st.insert(it);
        }
        return rec(0,s,st,dp);
    }
};",None,"class Solution {
public:
    int rec(int ind,string &s,set<string>&st,vector<int>&dp)
    {
        if (ind==s.size()) return 0;
        if (dp[ind]!=-1) return dp[ind];
        int ans=s.size()-ind;
        for (int i=ind;i<s.size();i++)
        {
           string temp=s.substr(ind,i-ind+1);
           if (st.find(temp)!=st.end())
           {
              ans=min(ans,1+rec(i+1,s,st,dp));
           }
        }
        return dp[ind]=ans;
    }
    int minExtraChar(string s, vector<string>& dictionary) 
    {
        set<string>st;
        int n=s.size();
        vector<int>dp(n,-1);
        for (auto it:dictionary)
        {
            st.insert(it);
        }
        return rec(0,s,st,dp);
    }
};
"
428,cpp,extra-characters-in-a-string,"class Solution {
public:
    int rec(int ind,string &s,set<string>&st,vector<int>&dp)
    {
        if (ind==s.size()) return 0;
        if (dp[ind]!=-1) return dp[ind];
        int ans=s.size()-ind;
        for (int i=ind;i<s.size();i++)
        {
           string temp=s.substr(ind,i-ind+1);
           if (st.find(temp)!=st.end())
           {
              ans=min(ans,rec(i+1,s,st,dp));
           }
        }
        ans=min(ans,rec(ind,s,st,dp)); 
        return dp[ind]=ans;
    }
    int minExtraChar(string s, vector<string>& dictionary) 
    {
        set<string>st;
        int n=s.size();
        vector<int>dp(n,-1);
        for (auto it:dictionary)
        {
            st.insert(it);
        }
        return rec(0,s,st,dp);
    }
};",None,"class Solution {
public:
    int rec(int ind,string &s,set<string>&st,vector<int>&dp)
    {
        if (ind==s.size()) return 0;
        if (dp[ind]!=-1) return dp[ind];
        int ans=s.size()-ind;
        for (int i=ind;i<s.size();i++)
        {
           string temp=s.substr(ind,i-ind+1);
           if (st.find(temp)!=st.end())
           {
              ans=min(ans,1+rec(i+1,s,st,dp));
           }
        }
        return dp[ind]=ans;
    }
    int minExtraChar(string s, vector<string>& dictionary) 
    {
        set<string>st;
        int n=s.size();
        vector<int>dp(n,-1);
        for (auto it:dictionary)
        {
            st.insert(it);
        }
        return rec(0,s,st,dp);
    }
};
"
429,cpp,number-of-provinces,"class Solution {
    int res,c = 0,n,vis[201]={0};
    void dfs(vector<vector<int>>& isConnected,int start)
    {
        vis[start] = true;c++;
        for(int connection = 0;connection<n;connection++)
        {
            if(!vis[connection] and isConnected[start][connection]) dfs(isConnected,connection);
        }
    }
public:
    int findCircleNum(vector<vector<int>>& isConnected)
     {
        n = isConnected.size();
        for(int i = 0;i<=n;i++) if(!vis[i]) c=0,dfs(isConnected,i),res++;;
        return res;   
    }
};",None,"class Solution {
    int res, c = 0, n;
    vector<bool> vis;
    void dfs(vector<vector<int>>& isConnected, int start) {
        vis[start] = true;
        c++;
        for (int connection = 0; connection < n; connection++) {
            if (!vis[connection] && isConnected[start][connection]) {
                dfs(isConnected, connection);
            }
        }
    }

public:
    int findCircleNum(vector<vector<int>>& isConnected) {
        n = isConnected.size();
        vis.resize(n);

        res = 0;
        for (int i = 0; i < n; i++) {
            if (!vis[i]) {
                c = 0;
                dfs(isConnected, i);
                res++;
            }
        }

        return res;
    }
};
"
429,cpp,number-of-provinces,"class Solution {
    int res,c = 0,n,vis[201]={0};
    void dfs(vector<vector<int>>& isConnected,int start)
    {
        vis[start] = true;c++;
        for(int connection = 0;connection<n;connection++)
        {
            if(!vis[connection] and isConnected[start][connection]) dfs(isConnected,connection);
        }
    }
public:
    int findCircleNum(vector<vector<int>>& isConnected)
     {
        n = isConnected.size();
        for(int i = 0;i<=n;i++) if(!vis[i]) c=0,dfs(isConnected,i),res++;;
        return res;   
    }
};",None,"class Solution {
    int res, c = 0, n;
    vector<bool> vis;

    void dfs(vector<vector<int>>& isConnected, int start) {
        vis[start] = true;
        c++;

        for (int connection = 0; connection < n; connection++) {
            if (!vis[connection] && isConnected[start][connection]) {
                dfs(isConnected, connection);
            }
        }
    }

public:
    int findCircleNum(vector<vector<int>>& isConnected) {
        n = isConnected.size();
        vis.resize(n, false);
        res = 0;

        for (int i = 0; i < n; i++) {
            if (!vis[i]) {
                c = 0;
                dfs(isConnected, i);
                res++;
            }
        }

        return res;
    }
};
"
429,cpp,number-of-provinces,"class Solution {
    int res,c = 0,n,vis[201]={0};
    void dfs(vector<vector<int>>& isConnected,int start)
    {
        vis[start] = true;c++;
        for(int connection = 0;connection<n;connection++)
        {
            if(!vis[connection] and isConnected[start][connection]) dfs(isConnected,connection);
        }
    }
public:
    int findCircleNum(vector<vector<int>>& isConnected)
     {
        n = isConnected.size();
        for(int i = 0;i<=n;i++) if(!vis[i]) c=0,dfs(isConnected,i),res++;;
        return res;   
    }
};",None,"class Solution {
    int res, c = 0, n;
    vector<bool> vis;

    void dfs(vector<vector<int>>& isConnected, int start) {
        vis[start] = true;
        c++;

        for (int connection = 0; connection < n; connection++) {
            if (!vis[connection] && isConnected[start][connection]) {
                dfs(isConnected, connection);
            }
        }
    }

public:
    int findCircleNum(vector<vector<int>>& isConnected) {
        n = isConnected.size();
        vis.resize(n, false);
        res = 0;

        for (int i = 0; i < n; i++) {
            if (!vis[i]) {
                c = 0;
                dfs(isConnected, i);
                res++;
            }
        }

        return res;
    }
};
"
430,cpp,find-the-smallest-divisor-given-a-threshold,"class Solution {
public:

    int SumOfDivisor(vector<int>& nums, int Day){
        int sum = 0;
        for(int i = 1;i<nums.size();i++){
            sum += ceil((double)nums[i]/(double)(Day));
        }
        return sum;
    }
    int smallestDivisor(vector<int>& nums, int threshold) {
        int maxi = INT_MIN;
        for(int i = 0;i<nums.size();i++){
            maxi = max(maxi,nums[i]);
        }
        int low = 1,high = maxi,ans = -1;
        while(low <= high){
            int mid = (low + high)/2;
            if(SumOfDivisor(nums,mid) <= threshold){
                ans = mid;
                high = mid - 1;
            }
            else{
                low = mid + 1;
            }
        }
        return ans;
    }
};",None,"class Solution {
public:

    int SumOfDivisor(vector<int>& nums, int divisor){
        int sum = 0;
        for(int i = 0; i < nums.size(); i++){
            sum += ceil((double)nums[i] / (double)divisor);
        }
        return sum;
    }
    int smallestDivisor(vector<int>& nums, int threshold) {
        int low = 1, high = *max_element(nums.begin(), nums.end());
        while (low < high) {
            int mid = low + (high - low) / 2;
            if (SumOfDivisor(nums, mid) <= threshold) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return low;
    }
};
"
430,cpp,find-the-smallest-divisor-given-a-threshold,"class Solution {
public:

    int SumOfDivisor(vector<int>& nums, int Day){
        int sum = 0;
        for(int i = 1;i<nums.size();i++){
            sum += ceil((double)nums[i]/(double)(Day));
        }
        return sum;
    }
    int smallestDivisor(vector<int>& nums, int threshold) {
        int maxi = INT_MIN;
        for(int i = 0;i<nums.size();i++){
            maxi = max(maxi,nums[i]);
        }
        int low = 1,high = maxi,ans = -1;
        while(low <= high){
            int mid = (low + high)/2;
            if(SumOfDivisor(nums,mid) <= threshold){
                ans = mid;
                high = mid - 1;
            }
            else{
                low = mid + 1;
            }
        }
        return ans;
    }
};",None,"class Solution {
public:

    int SumOfDivisor(vector<int>& nums, int Day){
        int sum = 0;
        for(int i = 0;i<nums.size();i++){
            sum += ceil((double)nums[i]/(double)Day);
        }
        return sum;
    }
    int smallestDivisor(vector<int>& nums, int threshold) {
        int low = 1, high = *max_element(nums.begin(), nums.end()), ans = -1;
        while(low <= high){
            int mid = (low + high)/2;
            if(SumOfDivisor(nums,mid) <= threshold){
                ans = mid;
                high = mid - 1;
            }
            else{
                low = mid + 1;
            }
        }
        return ans;
    }
};
"
430,cpp,find-the-smallest-divisor-given-a-threshold,"class Solution {
public:

    int SumOfDivisor(vector<int>& nums, int Day){
        int sum = 0;
        for(int i = 1;i<nums.size();i++){
            sum += ceil((double)nums[i]/(double)(Day));
        }
        return sum;
    }
    int smallestDivisor(vector<int>& nums, int threshold) {
        int maxi = INT_MIN;
        for(int i = 0;i<nums.size();i++){
            maxi = max(maxi,nums[i]);
        }
        int low = 1,high = maxi,ans = -1;
        while(low <= high){
            int mid = (low + high)/2;
            if(SumOfDivisor(nums,mid) <= threshold){
                ans = mid;
                high = mid - 1;
            }
            else{
                low = mid + 1;
            }
        }
        return ans;
    }
};",None,"class Solution {
public:

    int SumOfDivisor(vector<int>& nums, int Day){
        int sum = 0;
        for(int i = 0;i<nums.size();i++){
            sum += ceil((double)nums[i]/(double)Day);
        }
        return sum;
    }
    int smallestDivisor(vector<int>& nums, int threshold) {
        int low = 1, high = *max_element(nums.begin(), nums.end()), ans = -1;
        while(low <= high){
            int mid = (low + high)/2;
            if(SumOfDivisor(nums,mid) <= threshold){
                ans = mid;
                high = mid - 1;
            }
            else{
                low = mid + 1;
            }
        }
        return ans;
    }
};
"
431,cpp,range-sum-of-bst,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
int sum = 0;
    void Traversal(TreeNode* root,int low,int high)
    {
        if(root==NULL)
        return;
        Traversal(root->left,low,high);
        if(root->val > high && root->val <low)sum+=root->val;
        Traversal(root->right,low,high);
    }
    int rangeSumBST(TreeNode* root, int low, int high) {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        Traversal(root,low,high);
        return sum;
    }
};",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int rangeSumBST(TreeNode* root, int low, int high) {
        if (root == nullptr) {
            return 0;
        }
        if (root->val < low) {
            return rangeSumBST(root->right, low, high);
        }
        if (root->val > high) {
            return rangeSumBST(root->left, low, high);
        }
        return root->val + rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);
    }
};
"
431,cpp,range-sum-of-bst,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
int sum = 0;
    void Traversal(TreeNode* root,int low,int high)
    {
        if(root==NULL)
        return;
        Traversal(root->left,low,high);
        if(root->val > high && root->val <low)sum+=root->val;
        Traversal(root->right,low,high);
    }
    int rangeSumBST(TreeNode* root, int low, int high) {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        Traversal(root,low,high);
        return sum;
    }
};",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int rangeSumBST(TreeNode* root, int low, int high) {
        if (root == nullptr) {
            return 0;
        }
        if (root->val < low) {
            return rangeSumBST(root->right, low, high);
        }
        if (root->val > high) {
            return rangeSumBST(root->left, low, high);
        }
        return root->val + rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);
    }
};
"
431,cpp,range-sum-of-bst,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
int sum = 0;
    void Traversal(TreeNode* root,int low,int high)
    {
        if(root==NULL)
        return;
        Traversal(root->left,low,high);
        if(root->val > high && root->val <low)sum+=root->val;
        Traversal(root->right,low,high);
    }
    int rangeSumBST(TreeNode* root, int low, int high) {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        Traversal(root,low,high);
        return sum;
    }
};",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int rangeSumBST(TreeNode* root, int low, int high) {
        if (root == nullptr) {
            return 0;
        }
        if (root->val < low) {
            return rangeSumBST(root->right, low, high);
        }
        if (root->val > high) {
            return rangeSumBST(root->left, low, high);
        }
        return root->val + rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);
    }
};
"
432,cpp,gray-code,"class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> res;
        res.push_back( 0 );
        for( int k = 0; k<n; k++ ) {
            int i = res.size(), t = (1<<k) ;
            while( i > 1 ) {
                int temp = res[--i] | t;
                res.push_back( temp );
            }
        }
        return res;
    }
};",None,"class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> res;
        res.push_back(0);
        for (int k = 0; k < n; k++) {
            int i = res.size(), t = (1 << k);
            while (i > 0) {
                int temp = res[--i] | t;
                res.push_back(temp);
            }
        }
        return res;
    }
};
"
432,cpp,gray-code,"class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> res;
        res.push_back( 0 );
        for( int k = 0; k<n; k++ ) {
            int i = res.size(), t = (1<<k) ;
            while( i > 1 ) {
                int temp = res[--i] | t;
                res.push_back( temp );
            }
        }
        return res;
    }
};",None,"class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> res;
        res.push_back( 0 );
        for( int k = 0; k<n; k++ ) {
            int i = res.size(), t = (1<<k) ;
            while( i-- ) {
                int temp = res[i] | t;
                res.push_back( temp );
            }
        }
        return res;
    }
};
"
432,cpp,gray-code,"class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> res;
        res.push_back( 0 );
        for( int k = 0; k<n; k++ ) {
            int i = res.size(), t = (1<<k) ;
            while( i > 1 ) {
                int temp = res[--i] | t;
                res.push_back( temp );
            }
        }
        return res;
    }
};",None,"class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> res;
        res.push_back(0);
        for(int k = 0; k < n; k++) {
            int i = res.size(), t = (1 << k);
            while(i > 0) {
                int temp = res[--i] | t;
                res.push_back(temp);
            }
        }
        return res;
    }
};
"
433,cpp,min-cost-climbing-stairs,"class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();

        for(int i=2; i<=n; i++){
            cost[i] = min(cost[i-1],cost[i-2]) + cost[i];
        }

        return min(cost[n-1],cost[n-2]);
    }
};",None,"class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();

        for(int i=2; i<n; i++){
            cost[i] = min(cost[i-1],cost[i-2]) + cost[i];
        }

        return min(cost[n-1],cost[n-2]);
    }
};
"
433,cpp,min-cost-climbing-stairs,"class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();

        for(int i=2; i<=n; i++){
            cost[i] = min(cost[i-1],cost[i-2]) + cost[i];
        }

        return min(cost[n-1],cost[n-2]);
    }
};",None,"class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();

        for(int i=2; i<n; i++){
            cost[i] = min(cost[i-1],cost[i-2]) + cost[i];
        }

        return min(cost[n-1],cost[n-2]);
    }
};
"
433,cpp,min-cost-climbing-stairs,"class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();

        for(int i=2; i<=n; i++){
            cost[i] = min(cost[i-1],cost[i-2]) + cost[i];
        }

        return min(cost[n-1],cost[n-2]);
    }
};",None,"class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();

        for(int i=2; i<n; i++){
            cost[i] = min(cost[i-1],cost[i-2]) + cost[i];
        }

        return min(cost[n-1],cost[n-2]);
    }
};
"
434,cpp,find-if-path-exists-in-graph,"class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) 
    {
        unordered_map<int,vector<int>> mp;
        for(auto i : edges)
        {
            vector<int> temp=i;
            int u=temp[0];
            int v=temp[1];
            mp[u].push_back(v);
            mp[v].push_back(u);
        }
        vector<bool> visited(n+1, false);
        queue<int>q;
        q.push(source);
        visited[source]=true;
        while(!q.empty())
        {
            int u=q.front();
            q.pop();
            for(auto i :mp[u])
            {
                if(visited[i]==false)
                {
                    q.push(i);
                }
            }
        }
        return visited[destination];    
    }
};",None,"class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) 
    {
        unordered_map<int,vector<int>> mp;
        for(auto i : edges)
        {
            vector<int> temp=i;
            int u=temp[0];
            int v=temp[1];
            mp[u].push_back(v);
            mp[v].push_back(u);
        }
        vector<bool> visited(n, false);
        queue<int>q;
        q.push(source);
        visited[source]=true;
        while(!q.empty())
        {
            int u=q.front();
            q.pop();
            for(auto i :mp[u])
            {
                if(!visited[i])
                {
                    q.push(i);
                    visited[i]=true;
                }
            }
        }
        return visited[destination];    
    }
};
"
434,cpp,find-if-path-exists-in-graph,"class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) 
    {
        unordered_map<int,vector<int>> mp;
        for(auto i : edges)
        {
            vector<int> temp=i;
            int u=temp[0];
            int v=temp[1];
            mp[u].push_back(v);
            mp[v].push_back(u);
        }
        vector<bool> visited(n+1, false);
        queue<int>q;
        q.push(source);
        visited[source]=true;
        while(!q.empty())
        {
            int u=q.front();
            q.pop();
            for(auto i :mp[u])
            {
                if(visited[i]==false)
                {
                    q.push(i);
                }
            }
        }
        return visited[destination];    
    }
};",None,"class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) 
    {
        unordered_map<int,vector<int>> mp;
        for(auto i : edges)
        {
            vector<int> temp=i;
            int u=temp[0];
            int v=temp[1];
            mp[u].push_back(v);
            mp[v].push_back(u);
        }
        vector<bool> visited(n, false);
        queue<int>q;
        q.push(source);
        visited[source]=true;
        while(!q.empty())
        {
            int u=q.front();
            q.pop();
            for(auto i :mp[u])
            {
                if(!visited[i])
                {
                    q.push(i);
                    visited[i]=true;
                }
            }
        }
        return visited[destination];    
    }
};
"
434,cpp,find-if-path-exists-in-graph,"class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) 
    {
        unordered_map<int,vector<int>> mp;
        for(auto i : edges)
        {
            vector<int> temp=i;
            int u=temp[0];
            int v=temp[1];
            mp[u].push_back(v);
            mp[v].push_back(u);
        }
        vector<bool> visited(n+1, false);
        queue<int>q;
        q.push(source);
        visited[source]=true;
        while(!q.empty())
        {
            int u=q.front();
            q.pop();
            for(auto i :mp[u])
            {
                if(visited[i]==false)
                {
                    q.push(i);
                }
            }
        }
        return visited[destination];    
    }
};",None,"class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) 
    {
        unordered_map<int,vector<int>> mp;
        for(auto i : edges)
        {
            vector<int> temp=i;
            int u=temp[0];
            int v=temp[1];
            mp[u].push_back(v);
            mp[v].push_back(u);
        }
        vector<bool> visited(n, false);
        queue<int>q;
        q.push(source);
        visited[source]=true;
        while(!q.empty())
        {
            int u=q.front();
            q.pop();
            for(auto i :mp[u])
            {
                if(!visited[i])
                {
                    q.push(i);
                    visited[i]=true;
                }
            }
        }
        return visited[destination];    
    }
};
"
435,cpp,count-pairs-with-xor-in-a-range,"class Solution {
public:
struct Node{
    Node* links[2];
    int cnt=0;
    void put(int ind,Node* node)
    {
        links[ind]=node;
    }
    bool isContains(int ind)
    {
        return links[ind]!=NULL;
    }
    Node* get(int ind)
    {
        return links[ind];
    }
    void incCount()
    {
        cnt++;
    }
    int count()
    {
        return cnt;
    }
};
class Trie
{
    public:
    Node * root;
      Trie()
      {
       root=new Node();
      }
      void insert(int num)
      {
          Node* node=root;
          for (int i=14;i>=0;i--)
          {
              int bit=((num>>i)&1);
              if (!node->isContains(bit))
              {
                 node->put(bit,new Node());
              }
              node=node->get(bit);
              node->incCount();
          }
      }
      int getCount(Node* root)
      {
          if (root==NULL) return 0;
          return root->count();
      }
      int rec(Node* root,int index,int high,int val)
      {
          if (root==NULL) return 0;
           if (index<0) return root->count();
          int valBit=((val>>index)&1);
          int highBit=((high>>index)&1);
          if(valBit==1)
          {
            if (highBit==1) return rec(root->get(0),index-1,high,val) + getCount(root->get(1));
            else return rec(root->get(1),index-1,high,val);
          }
          else
          {
             if (highBit==1) return rec(root->get(0),index-1,high,val)+getCount(root->get(1));
             else return rec(root->get(0),index-1,high,val);
          }
      }

};
    int countPairs(vector<int>& nums, int low, int high) {
        int ans=0;
        Trie * trie=new Trie();
        for (auto & it:nums)
        {
           ans+=trie->rec(trie->root,14,high,it);
           ans-=trie->rec(trie->root,14,low,it);
           trie->insert(it);
        } 
        return ans;
    }
};",None,"class Solution {
public:
struct Node{
    Node* links[2];
    int cnt=0;
    void put(int ind,Node* node)
    {
        links[ind]=node;
    }
    bool isContains(int ind)
    {
        return links[ind]!=NULL;
    }
    Node* get(int ind)
    {
        return links[ind];
    }
    void incCount()
    {
        cnt++;
    }
    int count()
    {
        return cnt;
    }
};
class Trie
{
    public:
    Node * root;
      Trie()
      {
       root=new Node();
      }
      void insert(int num)
      {
          Node* node=root;
          for (int i=14;i>=0;i--)
          {
              int bit=((num>>i)&1);
              if (!node->isContains(bit))
              {
                 node->put(bit,new Node());
              }
              node=node->get(bit);
              node->incCount();
          }
      }
      int getCount(Node* root)
      {
          if (root==NULL) return 0;
          return root->count();
      }
      int rec(Node* root,int index,int high,int val)
      {
          if (root==NULL) return 0;
          if (index<0) return root->count();
          int valBit=((val>>index)&1);
          int highBit=((high>>index)&1);
          if(valBit==1)
          {
             if (highBit==1) return rec(root->get(0),index-1,high,val) + getCount(root->get(1));
             else return rec(root->get(1),index-1,high,val);
          }
          else
          {
             if (highBit==1) return rec(root->get(0),index-1,high,val)+getCount(root->get(1));
             else return rec(root->get(0),index-1,high,val);
          }
      }

};
    int countPairs(vector<int>& nums, int low, int high) {
        int ans=0;
        Trie * trie=new Trie();
        for (auto & it:nums)
        {
           ans+=trie->rec(trie->root,14,high,it);
           ans-=trie->rec(trie->root,14,low-1,it);
           trie->insert(it);
        } 
        return ans;
    }
};
"
435,cpp,count-pairs-with-xor-in-a-range,"class Solution {
public:
struct Node{
    Node* links[2];
    int cnt=0;
    void put(int ind,Node* node)
    {
        links[ind]=node;
    }
    bool isContains(int ind)
    {
        return links[ind]!=NULL;
    }
    Node* get(int ind)
    {
        return links[ind];
    }
    void incCount()
    {
        cnt++;
    }
    int count()
    {
        return cnt;
    }
};
class Trie
{
    public:
    Node * root;
      Trie()
      {
       root=new Node();
      }
      void insert(int num)
      {
          Node* node=root;
          for (int i=14;i>=0;i--)
          {
              int bit=((num>>i)&1);
              if (!node->isContains(bit))
              {
                 node->put(bit,new Node());
              }
              node=node->get(bit);
              node->incCount();
          }
      }
      int getCount(Node* root)
      {
          if (root==NULL) return 0;
          return root->count();
      }
      int rec(Node* root,int index,int high,int val)
      {
          if (root==NULL) return 0;
           if (index<0) return root->count();
          int valBit=((val>>index)&1);
          int highBit=((high>>index)&1);
          if(valBit==1)
          {
            if (highBit==1) return rec(root->get(0),index-1,high,val) + getCount(root->get(1));
            else return rec(root->get(1),index-1,high,val);
          }
          else
          {
             if (highBit==1) return rec(root->get(0),index-1,high,val)+getCount(root->get(1));
             else return rec(root->get(0),index-1,high,val);
          }
      }

};
    int countPairs(vector<int>& nums, int low, int high) {
        int ans=0;
        Trie * trie=new Trie();
        for (auto & it:nums)
        {
           ans+=trie->rec(trie->root,14,high,it);
           ans-=trie->rec(trie->root,14,low,it);
           trie->insert(it);
        } 
        return ans;
    }
};",None,"class Solution {
public:
struct Node{
    Node* links[2];
    int cnt=0;
    void put(int ind,Node* node)
    {
        links[ind]=node;
    }
    bool isContains(int ind)
    {
        return links[ind]!=NULL;
    }
    Node* get(int ind)
    {
        return links[ind];
    }
    void incCount()
    {
        cnt++;
    }
    int count()
    {
        return cnt;
    }
};
class Trie
{
    public:
    Node * root;
      Trie()
      {
       root=new Node();
      }
      void insert(int num)
      {
          Node* node=root;
          for (int i=14;i>=0;i--)
          {
              int bit=((num>>i)&1);
              if (!node->isContains(bit))
              {
                 node->put(bit,new Node());
              }
              node=node->get(bit);
              node->incCount();
          }
      }
      int getCount(Node* root)
      {
          if (root==NULL) return 0;
          return root->count();
      }
      int rec(Node* root,int index,int high,int val)
      {
          if (root==NULL) return 0;
           if (index<0) return root->count();
          int valBit=((val>>index)&1);
          int highBit=((high>>index)&1);
          if(valBit==1)
          {
            if (highBit==1) return rec(root->get(0),index-1,high,val) + getCount(root->get(1));
            else return rec(root->get(1),index-1,high,val);
          }
          else
          {
             if (highBit==1) return rec(root->get(0),index-1,high,val)+getCount(root->get(1));
             else return rec(root->get(0),index-1,high,val);
          }
      }

};
    int countPairs(vector<int>& nums, int low, int high) {
        int ans=0;
        Trie * trie=new Trie();
        for (auto & it:nums)
        {
           ans+=trie->rec(trie->root,14,high,it);
           ans-=trie->rec(trie->root,14,low-1,it);
           trie->insert(it);
        } 
        return ans;
    }
};
"
435,cpp,count-pairs-with-xor-in-a-range,"class Solution {
public:
struct Node{
    Node* links[2];
    int cnt=0;
    void put(int ind,Node* node)
    {
        links[ind]=node;
    }
    bool isContains(int ind)
    {
        return links[ind]!=NULL;
    }
    Node* get(int ind)
    {
        return links[ind];
    }
    void incCount()
    {
        cnt++;
    }
    int count()
    {
        return cnt;
    }
};
class Trie
{
    public:
    Node * root;
      Trie()
      {
       root=new Node();
      }
      void insert(int num)
      {
          Node* node=root;
          for (int i=14;i>=0;i--)
          {
              int bit=((num>>i)&1);
              if (!node->isContains(bit))
              {
                 node->put(bit,new Node());
              }
              node=node->get(bit);
              node->incCount();
          }
      }
      int getCount(Node* root)
      {
          if (root==NULL) return 0;
          return root->count();
      }
      int rec(Node* root,int index,int high,int val)
      {
          if (root==NULL) return 0;
           if (index<0) return root->count();
          int valBit=((val>>index)&1);
          int highBit=((high>>index)&1);
          if(valBit==1)
          {
            if (highBit==1) return rec(root->get(0),index-1,high,val) + getCount(root->get(1));
            else return rec(root->get(1),index-1,high,val);
          }
          else
          {
             if (highBit==1) return rec(root->get(0),index-1,high,val)+getCount(root->get(1));
             else return rec(root->get(0),index-1,high,val);
          }
      }

};
    int countPairs(vector<int>& nums, int low, int high) {
        int ans=0;
        Trie * trie=new Trie();
        for (auto & it:nums)
        {
           ans+=trie->rec(trie->root,14,high,it);
           ans-=trie->rec(trie->root,14,low,it);
           trie->insert(it);
        } 
        return ans;
    }
};",None,"class Solution {
public:
struct Node{
    Node* links[2];
    int cnt=0;
    void put(int ind,Node* node)
    {
        links[ind]=node;
    }
    bool isContains(int ind)
    {
        return links[ind]!=NULL;
    }
    Node* get(int ind)
    {
        return links[ind];
    }
    void incCount()
    {
        cnt++;
    }
    int count()
    {
        return cnt;
    }
};
class Trie
{
    public:
    Node * root;
      Trie()
      {
       root=new Node();
      }
      void insert(int num)
      {
          Node* node=root;
          for (int i=14;i>=0;i--)
          {
              int bit=((num>>i)&1);
              if (!node->isContains(bit))
              {
                 node->put(bit,new Node());
              }
              node=node->get(bit);
              node->incCount();
          }
      }
      int getCount(Node* root)
      {
          if (root==NULL) return 0;
          return root->count();
      }
      int rec(Node* root,int index,int high,int val)
      {
          if (root==NULL) return 0;
           if (index<0) return root->count();
          int valBit=((val>>index)&1);
          int highBit=((high>>index)&1);
          if(valBit==1)
          {
            if (highBit==1) return rec(root->get(0),index-1,high,val) + getCount(root->get(1));
            else return rec(root->get(1),index-1,high,val);
          }
          else
          {
             if (highBit==1) return rec(root->get(0),index-1,high,val)+getCount(root->get(1));
             else return rec(root->get(0),index-1,high,val);
          }
      }

};
    int countPairs(vector<int>& nums, int low, int high) {
        int ans=0;
        Trie * trie=new Trie();
        for (auto & it:nums)
        {
           ans+=trie->rec(trie->root,14,high,it);
           ans-=trie->rec(trie->root,14,low-1,it);
           trie->insert(it);
        } 
        return ans;
    }
};
"
436,cpp,find-all-numbers-disappeared-in-an-array,"class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n = nums.size();
        int i = 0;
        while (i<n) {
            if (nums[i] != nums[nums[i]] && i != nums[i])
                swap(nums[i], nums[nums[i]]);
            else i++;
        }
        
        vector<int> res;
        for (int i=0; i<n; i++) {
            if (nums[i] != i+1) res.push_back(i+1);
        }

        return res;
    }
};",None,"class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n = nums.size();
        for (int i=0; i<n; i++) {
            int index = abs(nums[i]) - 1;
            if (nums[index] > 0) nums[index] *= -1;
        }

        vector<int> res;
        for (int i=0; i<n; i++) {
            if (nums[i] > 0) res.push_back(i+1);
        }

        return res;
    }
};
"
436,cpp,find-all-numbers-disappeared-in-an-array,"class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n = nums.size();
        int i = 0;
        while (i<n) {
            if (nums[i] != nums[nums[i]] && i != nums[i])
                swap(nums[i], nums[nums[i]]);
            else i++;
        }
        
        vector<int> res;
        for (int i=0; i<n; i++) {
            if (nums[i] != i+1) res.push_back(i+1);
        }

        return res;
    }
};",None,"class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            if (nums[i] <= 0 || nums[i] > n) {
                nums[i] = n + 1;
            }
        }

        for (int i = 0; i < n; i++) {
            int num = abs(nums[i]);
            if (nums[num - 1] > 0) {
                nums[num - 1] *= -1;
            }
        }

        vector<int> res;
        for (int i = 0; i < n; i++) {
            if (nums[i] > 0) {
                res.push_back(i + 1);
            }
        }

        return res;
    }
};
"
436,cpp,find-all-numbers-disappeared-in-an-array,"class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n = nums.size();
        int i = 0;
        while (i<n) {
            if (nums[i] != nums[nums[i]] && i != nums[i])
                swap(nums[i], nums[nums[i]]);
            else i++;
        }
        
        vector<int> res;
        for (int i=0; i<n; i++) {
            if (nums[i] != i+1) res.push_back(i+1);
        }

        return res;
    }
};",None,"class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n = nums.size();
        int i = 0;
        while (i<n) {
            if (nums[i] != nums[nums[i]-1] && i != nums[i]-1)
                swap(nums[i], nums[nums[i]-1]);
            else i++;
        }

        vector<int> res;
        for (int i=0; i<n; i++) {
            if (nums[i] != i+1) res.push_back(i+1);
        }

        return res;
    }
};
"
824,cpp,fibonacci-number,"class Solution {
    int dp[33];
public:
    int fibon(int n) {
        cout<<n<<endl;
        if(n==1)return 1;
        if(n<=0)return 0;

        int& ans = dp[n];
        if(ans!=-1)return ans;

        return ans = fibon(n-1) + fibon(n+2);
    }

    int fib(int n){
        for(int i = 0 ; i < 33 ; i++)dp[i]=-1;
        int ans = fibon(n);
        cout<<ans<<endl;
        return ans;
    }
};",None,"class Solution {
    int dp[33];
public:
    int fibon(int n) {
        if(n==0)return 0;
        if(n==1)return 1;

        int& ans = dp[n];
        if(ans!=-1)return ans;

        return ans = fibon(n-1) + fibon(n-2);
    }

    int fib(int n){
        for(int i = 0 ; i < 33 ; i++)dp[i]=-1;
        int ans = fibon(n);
        cout<<ans<<endl;
        return ans;
    }
};
"
824,cpp,fibonacci-number,"class Solution {
    int dp[33];
public:
    int fibon(int n) {
        cout<<n<<endl;
        if(n==1)return 1;
        if(n<=0)return 0;

        int& ans = dp[n];
        if(ans!=-1)return ans;

        return ans = fibon(n-1) + fibon(n+2);
    }

    int fib(int n){
        for(int i = 0 ; i < 33 ; i++)dp[i]=-1;
        int ans = fibon(n);
        cout<<ans<<endl;
        return ans;
    }
};",None,"class Solution {
    int dp[33];
public:
    int fibon(int n) {
        if(n==0)return 0;
        if(n==1)return 1;

        int& ans = dp[n];
        if(ans!=-1)return ans;

        return ans = fibon(n-1) + fibon(n-2);
    }

    int fib(int n){
        for(int i = 0 ; i < 33 ; i++)dp[i]=-1;
        int ans = fibon(n);
        return ans;
    }
};
"
824,cpp,fibonacci-number,"class Solution {
    int dp[33];
public:
    int fibon(int n) {
        cout<<n<<endl;
        if(n==1)return 1;
        if(n<=0)return 0;

        int& ans = dp[n];
        if(ans!=-1)return ans;

        return ans = fibon(n-1) + fibon(n+2);
    }

    int fib(int n){
        for(int i = 0 ; i < 33 ; i++)dp[i]=-1;
        int ans = fibon(n);
        cout<<ans<<endl;
        return ans;
    }
};",None,"class Solution {
    int dp[33];
public:
    int fibon(int n) {
        if(n==1)return 1;
        if(n<=0)return 0;

        int& ans = dp[n];
        if(ans!=-1)return ans;

        return ans = fibon(n-1) + fibon(n-2);
    }

    int fib(int n){
        for(int i = 0 ; i < 33 ; i++)dp[i]=-1;
        int ans = fibon(n);
        cout<<ans<<endl;
        return ans;
    }
};
"
825,cpp,shortest-subarray-to-be-removed-to-make-array-sorted,"class Solution {
public:
    int findLengthOfShortestSubarray(vector<int>& arr) {

        int n =(int) arr.size();
        int h = n-1 , l=0 ;
        
        for(int i=h;i>=1;i--)  
        {
            if(arr[i]>=arr[i-1] && h>0)
            {
                h--;
            }
            else break;
        }

        int res=h;

       for( l=0 ; l<h && (l==0 || arr[l-1]<=arr[l])  ;l++)
       {
             
             while(h<n && arr[l]>arr[h])
              {
                 h++;
              }

           res = min(res,h);

        
           
       }
      return res;
      
    }
};",None,"class Solution {
public:
    int findLengthOfShortestSubarray(vector<int>& arr) {

        int n = (int) arr.size();
        int h = n-1, l=0;
        
        for(int i=h; i>=1; i--) {
            if(arr[i] >= arr[i-1] && h > 0) {
                h--;
            }
            else {
                break;
            }
        }

        int res = h;

        for(l=0; l<h && (l==0 || arr[l-1] <= arr[l]); l++) {

            while(h<n && arr[l] > arr[h]) {
                h++;
            }

            res = min(res, h-l);

        }

        return res;
    }
};
"
825,cpp,shortest-subarray-to-be-removed-to-make-array-sorted,"class Solution {
public:
    int findLengthOfShortestSubarray(vector<int>& arr) {

        int n =(int) arr.size();
        int h = n-1 , l=0 ;
        
        for(int i=h;i>=1;i--)  
        {
            if(arr[i]>=arr[i-1] && h>0)
            {
                h--;
            }
            else break;
        }

        int res=h;

       for( l=0 ; l<h && (l==0 || arr[l-1]<=arr[l])  ;l++)
       {
             
             while(h<n && arr[l]>arr[h])
              {
                 h++;
              }

           res = min(res,h);

        
           
       }
      return res;
      
    }
};",None,"class Solution {
public:
    int findLengthOfShortestSubarray(vector<int>& arr) {

        int n =(int) arr.size();
        int h = n-1 , l=0 ;
        
        for(int i=h;i>=0;i--)  
        {
            if(i==0 || arr[i]>=arr[i-1])
            {
                h = i;
                break;
            }
        }

        int res=h;

       for( l=0 ; l<h ;l++)
       {
             
             while(h<n && arr[l]>=arr[h])
              {
                 h++;
              }

           res = min(res,h-l);

        
           
       }
      return res;
      
    }
};
"
825,cpp,shortest-subarray-to-be-removed-to-make-array-sorted,"class Solution {
public:
    int findLengthOfShortestSubarray(vector<int>& arr) {

        int n =(int) arr.size();
        int h = n-1 , l=0 ;
        
        for(int i=h;i>=1;i--)  
        {
            if(arr[i]>=arr[i-1] && h>0)
            {
                h--;
            }
            else break;
        }

        int res=h;

       for( l=0 ; l<h && (l==0 || arr[l-1]<=arr[l])  ;l++)
       {
             
             while(h<n && arr[l]>arr[h])
              {
                 h++;
              }

           res = min(res,h);

        
           
       }
      return res;
      
    }
};",None,"class Solution {
public:
    int findLengthOfShortestSubarray(vector<int>& arr) {

        int n =(int) arr.size();
        int h = n-1 , l=0 ;
        
        for(int i=h;i>=1;i--)  
        {
            if(arr[i]>=arr[i-1] && h>0)
            {
                h--;
            }
            else break;
        }

        int res=h;

       for( l=0 ; l<h && l<n && (l==0 || arr[l-1]<=arr[l])  ;l++)
       {
             
             while(h<n && h<l+res && arr[l]<=arr[h])
              {
                 h++;
              }

           res = min(res,h-l);

        
           
       }
      return res;
      
    }
};
"
826,cpp,sum-multiples,"class Solution {
public:
    int sumOfMultiples(int n,int count=0) {

       for (int i=1;i<=n;i++)
       {
         if (i%3==0 || i%5==0 ||i%7==0)
           count+=i;
       }
    return count-1;

    }
};",None,"class Solution {
public:
    int sumOfMultiples(int n) {
        int count = 0;

        for (int i=1;i<=n;i++)
        {
            if (i%3==0 || i%5==0 ||i%7==0)
                count+=i;
        }
        return count;
    }
};
"
826,cpp,sum-multiples,"class Solution {
public:
    int sumOfMultiples(int n,int count=0) {

       for (int i=1;i<=n;i++)
       {
         if (i%3==0 || i%5==0 ||i%7==0)
           count+=i;
       }
    return count-1;

    }
};",None,"class Solution {
public:
    int sumOfMultiples(int n) {
        int count = 0;

        for (int i=1;i<=n;i++)
        {
            if (i%3==0 || i%5==0 ||i%7==0)
                count+=i;
        }

        return count;
    }
};
"
826,cpp,sum-multiples,"class Solution {
public:
    int sumOfMultiples(int n,int count=0) {

       for (int i=1;i<=n;i++)
       {
         if (i%3==0 || i%5==0 ||i%7==0)
           count+=i;
       }
    return count-1;

    }
};",None,"class Solution {
public:
    int sumOfMultiples(int n) {
        int count = 0;
        for (int i=1;i<=n;i++)
        {
            if (i%3==0 || i%5==0 ||i%7==0)
                count+=i;
        }
        return count;
    }
};
"
827,cpp,product-of-array-except-self,"class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int>prefVector(nums.size(),1);
        vector<int>suffVector(nums.size(),1);
        int prefPro=1;
        for(int i=0;i<nums.size();i++){
            prefVector[i]=prefPro;
            prefPro*=nums[i];
        }
        int suffPro=1;
        for(int i=nums.size()-1;i>=0;i--){
            suffVector[i]=suffPro;
            suffPro*=nums[i+1];
        }
        vector<int>ans(nums.size());
        for(int i=0;i<nums.size();i++){
            ans[i]=prefVector[i]*suffVector[i];
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int>prefVector(nums.size(),1);
        vector<int>suffVector(nums.size(),1);
        int prefPro=1;
        for(int i=0;i<nums.size();i++){
            prefVector[i]=prefPro;
            prefPro*=nums[i];
        }
        int suffPro=1;
        for(int i=nums.size()-1;i>=0;i--){
            suffVector[i]=suffPro;
            suffPro*=nums[i];
        }
        vector<int>ans(nums.size());
        for(int i=0;i<nums.size();i++){
            ans[i]=prefVector[i]*suffVector[i];
        }
        return ans;
    }
};
"
827,cpp,product-of-array-except-self,"class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int>prefVector(nums.size(),1);
        vector<int>suffVector(nums.size(),1);
        int prefPro=1;
        for(int i=0;i<nums.size();i++){
            prefVector[i]=prefPro;
            prefPro*=nums[i];
        }
        int suffPro=1;
        for(int i=nums.size()-1;i>=0;i--){
            suffVector[i]=suffPro;
            suffPro*=nums[i+1];
        }
        vector<int>ans(nums.size());
        for(int i=0;i<nums.size();i++){
            ans[i]=prefVector[i]*suffVector[i];
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int>prefVector(nums.size(),1);
        vector<int>suffVector(nums.size(),1);
        int prefPro=1;
        for(int i=0;i<nums.size();i++){
            prefVector[i]=prefPro;
            prefPro*=nums[i];
        }
        int suffPro=1;
        for(int i=nums.size()-1;i>=0;i--){
            suffVector[i]=suffPro;
            suffPro*=nums[i];
        }
        vector<int>ans(nums.size());
        for(int i=0;i<nums.size();i++){
            ans[i]=prefVector[i]*suffVector[i];
        }
        return ans;
    }
};
"
827,cpp,product-of-array-except-self,"class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int>prefVector(nums.size(),1);
        vector<int>suffVector(nums.size(),1);
        int prefPro=1;
        for(int i=0;i<nums.size();i++){
            prefVector[i]=prefPro;
            prefPro*=nums[i];
        }
        int suffPro=1;
        for(int i=nums.size()-1;i>=0;i--){
            suffVector[i]=suffPro;
            suffPro*=nums[i+1];
        }
        vector<int>ans(nums.size());
        for(int i=0;i<nums.size();i++){
            ans[i]=prefVector[i]*suffVector[i];
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int>prefVector(nums.size(),1);
        vector<int>suffVector(nums.size(),1);
        int prefPro=1;
        for(int i=0;i<nums.size();i++){
            prefVector[i]=prefPro;
            prefPro*=nums[i];
        }
        int suffPro=1;
        for(int i=nums.size()-1;i>=0;i--){
            suffVector[i]=suffPro;
            suffPro*=nums[i];
        }
        vector<int>ans(nums.size());
        for(int i=0;i<nums.size();i++){
            ans[i]=prefVector[i]*suffVector[i];
        }
        return ans;
    }
};
"
828,cpp,largest-rectangle-in-histogram,"#include<stack>
 
class Solution {
public:
    vector<int> nextSmallNumberIndex(vector<int>& v){
        int n=v.size(),num=0;
        vector<int> ans(n);
        stack<int> s;
        s.push(-1);
        for(int i=n-1;i>=0;i--){
            num=v[i];
            while(s.top()!=-1 && v[s.top()]>=num){
                s.pop();
            }
            ans[i]=s.top();
            s.push(i);
        }
        return ans;

    }
    vector<int> prevSmallNumberIndex(vector<int>& v){
        int n=v.size(),num=0;
        vector<int> ans(n);
        stack<int> s;
        s.push(-1);
        for(int i=0;i<n;i++){
            num=v[i];
            while(s.top()!=-1 && v[s.top()]>=num){
                s.pop();
            }
            ans[i]=s.top();
            s.push(i);
        }
        return ans;

    }
    int largestRectangleArea(vector<int>& heights) {
        int size=heights.size(),h,l,area=0,curArea;
        vector<int> next=nextSmallNumberIndex(heights);
        vector<int> prev=prevSmallNumberIndex(heights);
        for(int i=0;i<size;i++){
            h=heights[i];
            if(next[i]==-1)next[i]=size;
            l=next[i]-prev[i]-1;
            curArea=l*h;
            area=max(area,curArea);
        }
        return area*2;        
    }
};",None,"#include<stack>
 
class Solution {
public:
    vector<int> nextSmallNumberIndex(vector<int>& v){
        int n=v.size(),num=0;
        vector<int> ans(n);
        stack<int> s;
        s.push(-1);
        for(int i=n-1;i>=0;i--){
            num=v[i];
            while(s.top()!=-1 && v[s.top()]>=num){
                s.pop();
            }
            ans[i]=s.top();
            s.push(i);
        }
        return ans;

    }
    vector<int> prevSmallNumberIndex(vector<int>& v){
        int n=v.size(),num=0;
        vector<int> ans(n);
        stack<int> s;
        s.push(-1);
        for(int i=0;i<n;i++){
            num=v[i];
            while(s.top()!=-1 && v[s.top()]>=num){
                s.pop();
            }
            ans[i]=s.top();
            s.push(i);
        }
        return ans;

    }
    int largestRectangleArea(vector<int>& heights) {
        int size=heights.size(),h,l,area=0,curArea;
        vector<int> next=nextSmallNumberIndex(heights);
        vector<int> prev=prevSmallNumberIndex(heights);
        for(int i=0;i<size;i++){
            h=heights[i];
            if(next[i]==size)next[i]=size;
            l=next[i]-prev[i]-1;
            curArea=l*h;
            area=max(area,curArea);
        }
        return area;        
    }
};
"
828,cpp,largest-rectangle-in-histogram,"#include<stack>
 
class Solution {
public:
    vector<int> nextSmallNumberIndex(vector<int>& v){
        int n=v.size(),num=0;
        vector<int> ans(n);
        stack<int> s;
        s.push(-1);
        for(int i=n-1;i>=0;i--){
            num=v[i];
            while(s.top()!=-1 && v[s.top()]>=num){
                s.pop();
            }
            ans[i]=s.top();
            s.push(i);
        }
        return ans;

    }
    vector<int> prevSmallNumberIndex(vector<int>& v){
        int n=v.size(),num=0;
        vector<int> ans(n);
        stack<int> s;
        s.push(-1);
        for(int i=0;i<n;i++){
            num=v[i];
            while(s.top()!=-1 && v[s.top()]>=num){
                s.pop();
            }
            ans[i]=s.top();
            s.push(i);
        }
        return ans;

    }
    int largestRectangleArea(vector<int>& heights) {
        int size=heights.size(),h,l,area=0,curArea;
        vector<int> next=nextSmallNumberIndex(heights);
        vector<int> prev=prevSmallNumberIndex(heights);
        for(int i=0;i<size;i++){
            h=heights[i];
            if(next[i]==-1)next[i]=size;
            l=next[i]-prev[i]-1;
            curArea=l*h;
            area=max(area,curArea);
        }
        return area*2;        
    }
};",None,"#include<stack>
 
class Solution {
public:
    vector<int> nextSmallNumberIndex(vector<int>& v){
        int n=v.size(),num=0;
        vector<int> ans(n);
        stack<int> s;
        s.push(-1);
        for(int i=n-1;i>=0;i--){
            num=v[i];
            while(s.top()!=-1 && v[s.top()]>=num){
                s.pop();
            }
            ans[i]=s.top();
            s.push(i);
        }
        return ans;

    }
    vector<int> prevSmallNumberIndex(vector<int>& v){
        int n=v.size(),num=0;
        vector<int> ans(n);
        stack<int> s;
        s.push(-1);
        for(int i=0;i<n;i++){
            num=v[i];
            while(s.top()!=-1 && v[s.top()]>=num){
                s.pop();
            }
            ans[i]=s.top();
            s.push(i);
        }
        return ans;

    }
    int largestRectangleArea(vector<int>& heights) {
        int size=heights.size(),h,l,area=0,curArea;
        vector<int> next=nextSmallNumberIndex(heights);
        vector<int> prev=prevSmallNumberIndex(heights);
        for(int i=0;i<size;i++){
            h=heights[i];
            if(next[i]==size)next[i]=size;
            l=next[i]-prev[i]-1;
            curArea=l*h;
            area=max(area,curArea);
        }
        return area;        
    }
};
"
828,cpp,largest-rectangle-in-histogram,"#include<stack>
 
class Solution {
public:
    vector<int> nextSmallNumberIndex(vector<int>& v){
        int n=v.size(),num=0;
        vector<int> ans(n);
        stack<int> s;
        s.push(-1);
        for(int i=n-1;i>=0;i--){
            num=v[i];
            while(s.top()!=-1 && v[s.top()]>=num){
                s.pop();
            }
            ans[i]=s.top();
            s.push(i);
        }
        return ans;

    }
    vector<int> prevSmallNumberIndex(vector<int>& v){
        int n=v.size(),num=0;
        vector<int> ans(n);
        stack<int> s;
        s.push(-1);
        for(int i=0;i<n;i++){
            num=v[i];
            while(s.top()!=-1 && v[s.top()]>=num){
                s.pop();
            }
            ans[i]=s.top();
            s.push(i);
        }
        return ans;

    }
    int largestRectangleArea(vector<int>& heights) {
        int size=heights.size(),h,l,area=0,curArea;
        vector<int> next=nextSmallNumberIndex(heights);
        vector<int> prev=prevSmallNumberIndex(heights);
        for(int i=0;i<size;i++){
            h=heights[i];
            if(next[i]==-1)next[i]=size;
            l=next[i]-prev[i]-1;
            curArea=l*h;
            area=max(area,curArea);
        }
        return area*2;        
    }
};",None,"#include<stack>
 
class Solution {
public:
    vector<int> nextSmallNumberIndex(vector<int>& v){
        int n=v.size(),num=0;
        vector<int> ans(n);
        stack<int> s;
        s.push(-1);
        for(int i=n-1;i>=0;i--){
            num=v[i];
            while(s.top()!=-1 && v[s.top()]>=num){
                s.pop();
            }
            ans[i]=s.top();
            s.push(i);
        }
        return ans;

    }
    vector<int> prevSmallNumberIndex(vector<int>& v){
        int n=v.size(),num=0;
        vector<int> ans(n);
        stack<int> s;
        s.push(-1);
        for(int i=0;i<n;i++){
            num=v[i];
            while(s.top()!=-1 && v[s.top()]>=num){
                s.pop();
            }
            ans[i]=s.top();
            s.push(i);
        }
        return ans;

    }
    int largestRectangleArea(vector<int>& heights) {
        int size=heights.size(),h,l,area=0,curArea;
        vector<int> next=nextSmallNumberIndex(heights);
        vector<int> prev=prevSmallNumberIndex(heights);
        for(int i=0;i<size;i++){
            h=heights[i];
            if(next[i]==size)next[i]=size;
            l=next[i]-prev[i]-1;
            curArea=l*h;
            area=max(area,curArea);
        }
        return area;        
    }
};
"
829,cpp,perfect-rectangle,"class Solution {
public:
    bool isRectangleCover(vector<vector<int>>& rectangles) {
        map<pair<int,int>,int>m;
        for(auto it:rectangles){
            m[{it[0],it[1]}]++;
            m[{it[2],it[3]}]++;
            m[{it[0],it[3]}]++;
            m[{it[2],it[1]}]++;
        }
        int cnt=0;
        for( auto it=m.begin();it!=m.end();it++){
            if(abs(it->second)==1){
                cnt++;
            }
            else if(abs(it->second)!=1&&it->second!=0){
                return false;
            }
        }
        return cnt==4;
    }
};",None,"class Solution {
public:
    bool isRectangleCover(vector<vector<int>>& rectangles) {
        map<pair<int,int>,int>m;
        int total_points = 0;
        for(auto it:rectangles){
            m[{it[0],it[1]}]++;
            m[{it[2],it[3]}]++;
            m[{it[0],it[3]}]--;
            m[{it[2],it[1]}]--;
            total_points += (it[2]-it[0]) * (it[3]-it[1]);
        }
        int cnt=0;
        for( auto it=m.begin();it!=m.end();it++){
            if(it->second!=0){
                return false;
            }
        }
        return total_points != 0;
    }
};
"
829,cpp,perfect-rectangle,"class Solution {
public:
    bool isRectangleCover(vector<vector<int>>& rectangles) {
        map<pair<int,int>,int>m;
        for(auto it:rectangles){
            m[{it[0],it[1]}]++;
            m[{it[2],it[3]}]++;
            m[{it[0],it[3]}]++;
            m[{it[2],it[1]}]++;
        }
        int cnt=0;
        for( auto it=m.begin();it!=m.end();it++){
            if(abs(it->second)==1){
                cnt++;
            }
            else if(abs(it->second)!=1&&it->second!=0){
                return false;
            }
        }
        return cnt==4;
    }
};",None,"class Solution {
public:
    bool isRectangleCover(vector<vector<int>>& rectangles) {
        map<pair<int,int>,int>m;
        int area = 0;
        for(auto it:rectangles){
            m[{it[0],it[1]}]++;
            m[{it[2],it[3]}]--;
            m[{it[0],it[3]}]--;
            m[{it[2],it[1]}]++;
            area += (it[2]-it[0])*(it[3]-it[1]);
        }
        int prevArea = 0;
        for( auto it=m.begin();it!=m.end();it++){
            if(it->second != 0){
                return false;
            }
            prevArea += (it->first.second - it->first.first)*(it->second);
        }
        return prevArea == area;
    }
};
"
829,cpp,perfect-rectangle,"class Solution {
public:
    bool isRectangleCover(vector<vector<int>>& rectangles) {
        map<pair<int,int>,int>m;
        for(auto it:rectangles){
            m[{it[0],it[1]}]++;
            m[{it[2],it[3]}]++;
            m[{it[0],it[3]}]++;
            m[{it[2],it[1]}]++;
        }
        int cnt=0;
        for( auto it=m.begin();it!=m.end();it++){
            if(abs(it->second)==1){
                cnt++;
            }
            else if(abs(it->second)!=1&&it->second!=0){
                return false;
            }
        }
        return cnt==4;
    }
};",None,"class Solution {
public:
    bool isRectangleCover(vector<vector<int>>& rectangles) {
        map<pair<int,int>,int>m;
        int area = 0;
        for(auto it:rectangles){
            m[{it[0],it[1]}]++;
            m[{it[2],it[3]}]--;
            m[{it[0],it[3]}]--;
            m[{it[2],it[1]}]++;
            area += (it[2]-it[0])*(it[3]-it[1]);
        }
        int prevArea = 0;
        for( auto it=m.begin();it!=m.end();it++){
            if(it->second != 0){
                return false;
            }
            prevArea += (it->first.second-it->first.first)*(it->first.second-it->first.first);
        }
        return prevArea == area;
    }
};
"
830,cpp,buddy-strings,"class Solution {
public:
    bool buddyStrings(string s, string p) {
        int n=s.length(), m=p.length();
        if(n!=m) return false;
        
        vector<int> freq(26,0);
        
        int first=-1, second=-1;
        for(int i=0;i<n;i++){
            if(s[i] != p[i]){
                if(first==-1){
                    first=i;
                }else if(second==-1){
                    second=i;
                }else{
                    return false;
                }
            }
            freq[s[i]-'z']++; 
        }
        
        if(first == -1 && second == -1){
            for(int i=0;i<26;i++) if(freq[i] > 1) return true;
            return false;
        }else if(second == -1){
            return false;
        }
        
        return (s[first]==p[second] && s[second]==p[first]);
    }
};",None,"class Solution {
public:
    bool buddyStrings(string s, string p) {
        int n=s.length(), m=p.length();
        if(n!=m) return false;
        
        vector<int> freq(26,0);
        
        int first=-1, second=-1;
        for(int i=0;i<n;i++){
            if(s[i] != p[i]){
                if(first==-1){
                    first=i;
                }else if(second==-1){
                    second=i;
                }else{
                    return false;
                }
            }
            freq[s[i]-'a']++; 
        }
        
        if(first == -1 && second == -1){
            for(int i=0;i<26;i++) if(freq[i] > 1) return true;
            return false;
        }else if(second == -1){
            return false;
        }
        
        return (s[first]==p[second] && s[second]==p[first]);
    }
};
"
830,cpp,buddy-strings,"class Solution {
public:
    bool buddyStrings(string s, string p) {
        int n=s.length(), m=p.length();
        if(n!=m) return false;
        
        vector<int> freq(26,0);
        
        int first=-1, second=-1;
        for(int i=0;i<n;i++){
            if(s[i] != p[i]){
                if(first==-1){
                    first=i;
                }else if(second==-1){
                    second=i;
                }else{
                    return false;
                }
            }
            freq[s[i]-'z']++; 
        }
        
        if(first == -1 && second == -1){
            for(int i=0;i<26;i++) if(freq[i] > 1) return true;
            return false;
        }else if(second == -1){
            return false;
        }
        
        return (s[first]==p[second] && s[second]==p[first]);
    }
};",None,"class Solution {
public:
    bool buddyStrings(string s, string p) {
        int n=s.length(), m=p.length();
        if(n!=m) return false;
        
        vector<int> freq(26,0);
        
        int first=-1, second=-1;
        for(int i=0;i<n;i++){
            if(s[i] != p[i]){
                if(first==-1){
                    first=i;
                }else if(second==-1){
                    second=i;
                }else{
                    return false;
                }
            }
            freq[s[i]-'a']++; 
        }
        
        if(first == -1 && second == -1){
            for(int i=0;i<26;i++) if(freq[i] > 1) return true;
            return false;
        }else if(second == -1){
            return false;
        }
        
        return (s[first]==p[second] && s[second]==p[first]);
    }
};
"
830,cpp,buddy-strings,"class Solution {
public:
    bool buddyStrings(string s, string p) {
        int n=s.length(), m=p.length();
        if(n!=m) return false;
        
        vector<int> freq(26,0);
        
        int first=-1, second=-1;
        for(int i=0;i<n;i++){
            if(s[i] != p[i]){
                if(first==-1){
                    first=i;
                }else if(second==-1){
                    second=i;
                }else{
                    return false;
                }
            }
            freq[s[i]-'z']++; 
        }
        
        if(first == -1 && second == -1){
            for(int i=0;i<26;i++) if(freq[i] > 1) return true;
            return false;
        }else if(second == -1){
            return false;
        }
        
        return (s[first]==p[second] && s[second]==p[first]);
    }
};",None,"class Solution {
public:
    bool buddyStrings(string s, string p) {
        int n=s.length(), m=p.length();
        if(n!=m) return false;
        
        vector<int> freq(26,0);
        
        int first=-1, second=-1;
        for(int i=0;i<n;i++){
            if(s[i] != p[i]){
                if(first==-1){
                    first=i;
                }else if(second==-1){
                    second=i;
                }else{
                    return false;
                }
            }
            freq[s[i]-'a']++; 
        }
        
        if(first == -1 && second == -1){
            for(int i=0;i<26;i++) if(freq[i] > 1) return true;
            return false;
        }else if(second == -1){
            return false;
        }
        
        return (s[first]==p[second] && s[second]==p[first]);
    }
};
"
831,cpp,kth-ancestor-of-a-tree-node,"class TreeAncestor {
public:
    int n;

    vector<int>belong;
    vector<int>ind;
    vector<bool>leaf;
    vector<vector<int>>path_leaf;

    TreeAncestor(int n, vector<int>& parent) {
        this->n=n;
        path_leaf.resize(n);
        belong.resize(n,-1);
        ind.resize(n,-1);
        leaf.resize(n,1);

        for(int i=0;i<n;i++){
            if(parent[i]!=-1)   
            leaf[parent[i]]=0;
        }
        
        for(int i=0;i<n;i++){
            if(!leaf[i]) continue;
            int curr=i;
            belong[curr]=curr;
            while(curr!=-1){
                curr=parent[curr];
                path_leaf[i].push_back(curr);
                if(curr!=-1){
                    belong[curr]=i;
                    ind[curr]=path_leaf[i].size()-1;
                }
            }
        }

    }
    
    int getKthAncestor(int node, int k) {
        return path_leaf[belong[node]][max(k+ind[node],(int)path_leaf[belong[node]].size()-1)];
    }
};",None,"class TreeAncestor {
public:
    int n;

    vector<int>belong;
    vector<int>ind;
    vector<bool>leaf;
    vector<vector<int>>path_leaf;

    TreeAncestor(int n, vector<int>& parent) {
        this->n=n;
        path_leaf.resize(n);
        belong.resize(n,-1);
        ind.resize(n,-1);
        leaf.resize(n,true);

        for(int i=0;i<n;i++){
            if(parent[i]!=-1)   
            {
                leaf[parent[i]]=false;
            }
        }
        
        for(int i=0;i<n;i++){
            if(leaf[i]) continue;
            int curr=i;
            belong[curr]=curr;
            while(curr!=-1){
                curr=parent[curr];
                path_leaf[i].push_back(curr);
                if(curr!=-1){
                    belong[curr]=i;
                    ind[curr]=path_leaf[i].size()-1;
                }
            }
        }

    }
    
    int getKthAncestor(int node, int k) {
        if(k>=path_leaf[belong[node]].size())   
            return -1;
        return path_leaf[belong[node]][ind[node]+k];
    }
};
"
831,cpp,kth-ancestor-of-a-tree-node,"class TreeAncestor {
public:
    int n;

    vector<int>belong;
    vector<int>ind;
    vector<bool>leaf;
    vector<vector<int>>path_leaf;

    TreeAncestor(int n, vector<int>& parent) {
        this->n=n;
        path_leaf.resize(n);
        belong.resize(n,-1);
        ind.resize(n,-1);
        leaf.resize(n,1);

        for(int i=0;i<n;i++){
            if(parent[i]!=-1)   
            leaf[parent[i]]=0;
        }
        
        for(int i=0;i<n;i++){
            if(!leaf[i]) continue;
            int curr=i;
            belong[curr]=curr;
            while(curr!=-1){
                curr=parent[curr];
                path_leaf[i].push_back(curr);
                if(curr!=-1){
                    belong[curr]=i;
                    ind[curr]=path_leaf[i].size()-1;
                }
            }
        }

    }
    
    int getKthAncestor(int node, int k) {
        return path_leaf[belong[node]][max(k+ind[node],(int)path_leaf[belong[node]].size()-1)];
    }
};",None,"class TreeAncestor {
public:
    int n;

    vector<int>belong;
    vector<int>ind;
    vector<bool>leaf;
    vector<vector<int>>path_leaf;

    TreeAncestor(int n, vector<int>& parent) {
        this->n=n;
        path_leaf.resize(n);
        belong.resize(n,-1);
        ind.resize(n,-1);
        leaf.resize(n,1);

        for(int i=0;i<n;i++){
            if(parent[i]!=-1)   
            leaf[parent[i]]=0;
        }
        
        for(int i=0;i<n;i++){
            if(!leaf[i]) continue;
            int curr=i;
            belong[curr]=curr;
            while(curr!=-1){
                curr=parent[curr];
                path_leaf[curr].push_back(belong[curr]);
                if(curr!=-1){
                    belong[curr]=i;
                    ind[curr]=path_leaf[curr].size()-1;
                }
            }
        }

    }
    
    int getKthAncestor(int node, int k) {
        if (k > path_leaf[node].size() - 1) return -1;
        return path_leaf[node][ind[node] + k];
    }
};
"
831,cpp,kth-ancestor-of-a-tree-node,"class TreeAncestor {
public:
    int n;

    vector<int>belong;
    vector<int>ind;
    vector<bool>leaf;
    vector<vector<int>>path_leaf;

    TreeAncestor(int n, vector<int>& parent) {
        this->n=n;
        path_leaf.resize(n);
        belong.resize(n,-1);
        ind.resize(n,-1);
        leaf.resize(n,1);

        for(int i=0;i<n;i++){
            if(parent[i]!=-1)   
            leaf[parent[i]]=0;
        }
        
        for(int i=0;i<n;i++){
            if(!leaf[i]) continue;
            int curr=i;
            belong[curr]=curr;
            while(curr!=-1){
                curr=parent[curr];
                path_leaf[i].push_back(curr);
                if(curr!=-1){
                    belong[curr]=i;
                    ind[curr]=path_leaf[i].size()-1;
                }
            }
        }

    }
    
    int getKthAncestor(int node, int k) {
        return path_leaf[belong[node]][max(k+ind[node],(int)path_leaf[belong[node]].size()-1)];
    }
};",None,"class TreeAncestor {
public:
    int n;

    vector<int>belong;
    vector<int>ind;
    vector<bool>leaf;
    vector<vector<int>>path_leaf;

    TreeAncestor(int n, vector<int>& parent) {
        this->n=n;
        path_leaf.resize(n);
        belong.resize(n,-1);
        ind.resize(n,-1);
        leaf.resize(n,1);

        for(int i=0;i<n;i++){
            if(parent[i]!=-1)   
            leaf[parent[i]]=0;
        }
        
        for(int i=0;i<n;i++){
            if(!leaf[i]) continue;
            int curr=i;
            belong[curr]=curr;
            while(curr!=-1){
                curr=parent[curr];
                path_leaf[curr].push_back(belong[curr]);
                if(curr!=-1){
                    belong[curr]=i;
                    ind[curr]=path_leaf[curr].size()-1;
                }
            }
        }

    }
    
    int getKthAncestor(int node, int k) {
        if (k >= path_leaf[node].size()) {
            return -1;
        }
        return path_leaf[node][ind[node] + k];
    }
};
"
832,cpp,find-the-longest-valid-obstacle-course-at-each-position,"class Solution {
public:
    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {
        
        int n = nums.size();
        
        
        vector<int> lis;
        
        
        
        vector<int> ans;

        for(int i = 0; i < n; i++)
        {
            int idx = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();
                
            ans.push_back(idx + 2);
            
            if(idx == lis.size())
                lis.push_back(nums[i]);
            
            else
            {
                lis[idx] = nums[i];
            }
        }
        
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {
        
        int n = nums.size();
        
        vector<int> lis;
        
        vector<int> ans;

        for(int i = 0; i < n; i++)
        {
            int idx = lower_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();
                
            ans.push_back(idx + 1);
            
            if(idx == lis.size())
                lis.push_back(nums[i]);
            else
                lis[idx] = nums[i];
        }
        
        return ans;
    }
};
"
832,cpp,find-the-longest-valid-obstacle-course-at-each-position,"class Solution {
public:
    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {
        
        int n = nums.size();
        
        
        vector<int> lis;
        
        
        
        vector<int> ans;

        for(int i = 0; i < n; i++)
        {
            int idx = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();
                
            ans.push_back(idx + 2);
            
            if(idx == lis.size())
                lis.push_back(nums[i]);
            
            else
            {
                lis[idx] = nums[i];
            }
        }
        
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {
        
        int n = nums.size();
        
        
        vector<int> lis;
        
        
        
        vector<int> ans(n);

        for(int i = 0; i < n; i++)
        {
            int idx = lower_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();
                
            ans[i] = idx + 1;
            
            if(idx == lis.size())
                lis.push_back(nums[i]);
            else
                lis[idx] = nums[i];
        }
        
        return ans;
    }
};
"
832,cpp,find-the-longest-valid-obstacle-course-at-each-position,"class Solution {
public:
    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {
        
        int n = nums.size();
        
        
        vector<int> lis;
        
        
        
        vector<int> ans;

        for(int i = 0; i < n; i++)
        {
            int idx = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();
                
            ans.push_back(idx + 2);
            
            if(idx == lis.size())
                lis.push_back(nums[i]);
            
            else
            {
                lis[idx] = nums[i];
            }
        }
        
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {
        
        int n = nums.size();
        
        vector<int> lis;
        
        vector<int> ans(n);

        for(int i = 0; i < n; i++)
        {
            int idx = lower_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();
                
            ans[i] = idx + 1;
            
            if(idx == lis.size())
                lis.push_back(nums[i]);
            else
                lis[idx] = nums[i];
        }
        
        return ans;
    }
};
"
833,cpp,queries-on-number-of-points-inside-a-circle,"class Solution {
public:

    bool Manhattan(int x1,int x2,int y1,int y2,int r){
        int dist= abs(x2-x1) + abs(y2-y1);

        if(dist<=r*r) return true;
        return false;
    }
    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {

        vector<int> ans;

        for( auto c: queries){
            int x1=c[0];
            int y1=c[1];
            int r=c[2];
            int temp=0;
            
            for(auto i:points){
                int x2=i[0];
                int y2=i[1];

                if(Manhattan(x1,x2,y1,y2,r)){
                    temp++;
                }

            }

            ans.push_back(temp);

        }
        return ans;

    }
};",None,"class Solution {
public:

    bool Manhattan(int x1, int x2, int y1, int y2, int r) {
        int dist = abs(x2 - x1) + abs(y2 - y1);

        if (dist <= r) {
            return true;
        }
        return false;
    }

    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {

        vector<int> ans;

        for (auto c : queries) {
            int x1 = c[0];
            int y1 = c[1];
            int r = c[2];
            int temp = 0;

            for (auto i : points) {
                int x2 = i[0];
                int y2 = i[1];

                if (Manhattan(x1, x2, y1, y2, r)) {
                    temp++;
                }

            }

            ans.push_back(temp);

        }
        return ans;

    }
};
"
833,cpp,queries-on-number-of-points-inside-a-circle,"class Solution {
public:

    bool Manhattan(int x1,int x2,int y1,int y2,int r){
        int dist= abs(x2-x1) + abs(y2-y1);

        if(dist<=r*r) return true;
        return false;
    }
    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {

        vector<int> ans;

        for( auto c: queries){
            int x1=c[0];
            int y1=c[1];
            int r=c[2];
            int temp=0;
            
            for(auto i:points){
                int x2=i[0];
                int y2=i[1];

                if(Manhattan(x1,x2,y1,y2,r)){
                    temp++;
                }

            }

            ans.push_back(temp);

        }
        return ans;

    }
};",None,"class Solution {
public:

    bool Manhattan(int x1, int x2, int y1, int y2, int r) {
        int dist = abs(x2 - x1) + abs(y2 - y1);

        if (dist <= r)
            return true;
        return false;
    }

    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {

        vector<int> ans;

        for (auto c : queries) {
            int x1 = c[0];
            int y1 = c[1];
            int r = c[2];
            int temp = 0;

            for (auto i : points) {
                int x2 = i[0];
                int y2 = i[1];

                if (Manhattan(x1, x2, y1, y2, r)) {
                    temp++;
                }

            }

            ans.push_back(temp);

        }
        return ans;

    }
};
"
833,cpp,queries-on-number-of-points-inside-a-circle,"class Solution {
public:

    bool Manhattan(int x1,int x2,int y1,int y2,int r){
        int dist= abs(x2-x1) + abs(y2-y1);

        if(dist<=r*r) return true;
        return false;
    }
    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {

        vector<int> ans;

        for( auto c: queries){
            int x1=c[0];
            int y1=c[1];
            int r=c[2];
            int temp=0;
            
            for(auto i:points){
                int x2=i[0];
                int y2=i[1];

                if(Manhattan(x1,x2,y1,y2,r)){
                    temp++;
                }

            }

            ans.push_back(temp);

        }
        return ans;

    }
};",None,"class Solution {
public:

    bool Manhattan(int x1, int x2, int y1, int y2, int r) {
        int dist = abs(x2 - x1) + abs(y2 - y1);
        return dist * dist <= r * r;
    }

    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {

        vector<int> ans;

        for (auto c : queries) {
            int x1 = c[0];
            int y1 = c[1];
            int r = c[2];
            int temp = 0;

            for (auto i : points) {
                int x2 = i[0];
                int y2 = i[1];

                if (Manhattan(x1, x2, y1, y2, r)) {
                    temp++;
                }
            }

            ans.push_back(temp);
        }

        return ans;

    }
};
"
834,cpp,integer-to-roman,"class Solution {
public:
    string intToRoman(int num) {
        string ones[] = {"""",""I"",""II"",""III"",""IV"",""V"",""VI"",""VII"",""VIII"",""IX""};
        string tens[] = {"""",""X"",""XX"",""XXX"",""XL"",""L"",""LX"",""LXX"",""LXXX"",""XC""};
        string hrns[] = {"""",""C"",""CC"",""CCC"",""CD"",""D"",""DC"",""DCC"",""DCCC"",""CM""};
        string ths[]={"""",""M"",""MM"",""MMM""};

        return ths[num/10000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];
    }
};",None,"class Solution {
public:
    string intToRoman(int num) {
        string ones[] = {"""",""I"",""II"",""III"",""IV"",""V"",""VI"",""VII"",""VIII"",""IX""};
        string tens[] = {"""",""X"",""XX"",""XXX"",""XL"",""L"",""LX"",""LXX"",""LXXX"",""XC""};
        string hundreds[] = {"""",""C"",""CC"",""CCC"",""CD"",""D"",""DC"",""DCC"",""DCCC"",""CM""};
        string thousands[]={"""",""M"",""MM"",""MMM""};

        return thousands[num/1000] + hundreds[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];
    }
};
"
834,cpp,integer-to-roman,"class Solution {
public:
    string intToRoman(int num) {
        string ones[] = {"""",""I"",""II"",""III"",""IV"",""V"",""VI"",""VII"",""VIII"",""IX""};
        string tens[] = {"""",""X"",""XX"",""XXX"",""XL"",""L"",""LX"",""LXX"",""LXXX"",""XC""};
        string hrns[] = {"""",""C"",""CC"",""CCC"",""CD"",""D"",""DC"",""DCC"",""DCCC"",""CM""};
        string ths[]={"""",""M"",""MM"",""MMM""};

        return ths[num/10000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];
    }
};",None,"class Solution {
public:
    string intToRoman(int num) {
        string ones[] = {"""",""I"",""II"",""III"",""IV"",""V"",""VI"",""VII"",""VIII"",""IX""};
        string tens[] = {"""",""X"",""XX"",""XXX"",""XL"",""L"",""LX"",""LXX"",""LXXX"",""XC""};
        string hunds[] = {"""",""C"",""CC"",""CCC"",""CD"",""D"",""DC"",""DCC"",""DCCC"",""CM""};
        string thos[]={"""",""M"",""MM"",""MMM""};

        return thos[num/1000] + hunds[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];
    }
};
"
834,cpp,integer-to-roman,"class Solution {
public:
    string intToRoman(int num) {
        string ones[] = {"""",""I"",""II"",""III"",""IV"",""V"",""VI"",""VII"",""VIII"",""IX""};
        string tens[] = {"""",""X"",""XX"",""XXX"",""XL"",""L"",""LX"",""LXX"",""LXXX"",""XC""};
        string hrns[] = {"""",""C"",""CC"",""CCC"",""CD"",""D"",""DC"",""DCC"",""DCCC"",""CM""};
        string ths[]={"""",""M"",""MM"",""MMM""};

        return ths[num/10000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];
    }
};",None,"class Solution {
public:
    string intToRoman(int num) {
        string ones[] = {"""",""I"",""II"",""III"",""IV"",""V"",""VI"",""VII"",""VIII"",""IX""};
        string tens[] = {"""",""X"",""XX"",""XXX"",""XL"",""L"",""LX"",""LXX"",""LXXX"",""XC""};
        string hundreds[] = {"""",""C"",""CC"",""CCC"",""CD"",""D"",""DC"",""DCC"",""DCCC"",""CM""};
        string thousands[]={"""",""M"",""MM"",""MMM""};

        return thousands[num/1000] + hundreds[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];
    }
};
"
835,cpp,minimum-number-of-swaps-to-make-the-string-balanced,"class Solution {
public:
    int minSwaps(string s) {
        int size=0;
        for(char &ch:s){
          if(ch=='[')  size++;
          else if(size) size--;
        }
        return (size+2)/2;
    }
};",None,"class Solution {
public:
    int minSwaps(string s) {
        int size = 0;
        for (char &ch : s) {
            if (ch == '[') {
                size++;
            } else if (size > 0) {
                size--;
            }
        }
        return (size + 1) / 2;
    }
};
"
835,cpp,minimum-number-of-swaps-to-make-the-string-balanced,"class Solution {
public:
    int minSwaps(string s) {
        int size=0;
        for(char &ch:s){
          if(ch=='[')  size++;
          else if(size) size--;
        }
        return (size+2)/2;
    }
};",None,"class Solution {
public:
    int minSwaps(string s) {
        int open = 0, close = 0, swaps = 0;
        for(char c: s) {
            if(c == '[') open++;
            else close++;
        }

        int extra_close = abs(open - close);
        swaps = extra_close / 2;

        if(open < close) {
            string temp = s;
            for(int i = 0; i < temp.size(); i++) {
                if(temp[i] == ']' && open > 0) {
                    temp[i] = '[';
                    temp[--open] = ']';
                    swaps--;
                }
            }
        } else if (open > close) {
            string temp = s;
            for(int i = 0; i < temp.size(); i++) {
                if(temp[i] == '[' && close > 0) {
                    temp[i] = ']';
                    temp[--close] = '[';
                    swaps--;
                }
            }
        }

        return swaps;
    }
};
"
835,cpp,minimum-number-of-swaps-to-make-the-string-balanced,"class Solution {
public:
    int minSwaps(string s) {
        int size=0;
        for(char &ch:s){
          if(ch=='[')  size++;
          else if(size) size--;
        }
        return (size+2)/2;
    }
};",None,"class Solution {
public:
    int minSwaps(string s) {
        int count_open = 0, count_close = 0, ans = 0;
        for (char &ch : s) {
            if (ch == '[')
                count_open++;
            else
                count_close++;
        }

        int target = (count_open + count_close) / 2;
        for (char &ch : s) {
            if (ch == ']' && count_open < target) {
                count_open++;
                count_close--;
                ans++;
            } else if (ch == '[') {
                count_open++;
            } else {
                count_close++;
            }
        }

        if (count_open != target)
            ans = -1;

        return ans;
    }
};
"
836,cpp,number-of-matching-subsequences,"class Solution {
public:
map<char,vector<int>> count;
    int numMatchingSubseq(string s, vector<string>& words) {
        for(int i=0;i<s.size();i++){
            count[s[i]].push_back(i);
        }
        int z=0;
        for(auto& x:words){
            int p=-1;
            int r=0;
            for(int j=0;j<x.size();j++){
                if(count.find(x[j])==count.end()){r=1;break;}
                if(upper_bound(count[x[j]].begin(),count[x[j]].end(),p)==count[x[j]].end()){r=1;break;}
                p=upper_bound(count[x[j]].begin(),count[x[j]].end(),p)-count[x[j]].begin();
                }
            if(r==0)z+=1;
        }
        return z;
    }
};",None,"class Solution {
public:
map<char,vector<int>> count;
    int numMatchingSubseq(string s, vector<string>& words) {
        for(int i=0;i<s.size();i++){
            count[s[i]].push_back(i);
        }
        int z=0;
        for(auto& x:words){
            int p=-1;
            int r=0;
            for(int j=0;j<x.size();j++){
                if(count.find(x[j])==count.end()){r=1;break;}
                auto it = upper_bound(count[x[j]].begin(),count[x[j]].end(),p);
                if(it==count[x[j]].end()){r=1;break;}
                p=distance(count[x[j]].begin(), it);
            }
            if(r==0)z+=1;
        }
        return z;
    }
};
"
836,cpp,number-of-matching-subsequences,"class Solution {
public:
map<char,vector<int>> count;
    int numMatchingSubseq(string s, vector<string>& words) {
        for(int i=0;i<s.size();i++){
            count[s[i]].push_back(i);
        }
        int z=0;
        for(auto& x:words){
            int p=-1;
            int r=0;
            for(int j=0;j<x.size();j++){
                if(count.find(x[j])==count.end()){r=1;break;}
                if(upper_bound(count[x[j]].begin(),count[x[j]].end(),p)==count[x[j]].end()){r=1;break;}
                p=upper_bound(count[x[j]].begin(),count[x[j]].end(),p)-count[x[j]].begin();
                }
            if(r==0)z+=1;
        }
        return z;
    }
};",None,"class Solution {
public:
map<char,vector<int>> count;
    int numMatchingSubseq(string s, vector<string>& words) {
        for(int i=0;i<s.size();i++){
            count[s[i]].push_back(i);
        }
        int z=0;
        for(auto& x:words){
            int p=-1;
            int r=0;
            for(int j=0;j<x.size();j++){
                if(count.find(x[j])==count.end()){r=1;break;}
                auto it = upper_bound(count[x[j]].begin(),count[x[j]].end(),p);
                if(it==count[x[j]].end()){r=1;break;}
                p=distance(count[x[j]].begin(),it);
                }
            if(r==0)z+=1;
        }
        return z;
    }
};
"
836,cpp,number-of-matching-subsequences,"class Solution {
public:
map<char,vector<int>> count;
    int numMatchingSubseq(string s, vector<string>& words) {
        for(int i=0;i<s.size();i++){
            count[s[i]].push_back(i);
        }
        int z=0;
        for(auto& x:words){
            int p=-1;
            int r=0;
            for(int j=0;j<x.size();j++){
                if(count.find(x[j])==count.end()){r=1;break;}
                if(upper_bound(count[x[j]].begin(),count[x[j]].end(),p)==count[x[j]].end()){r=1;break;}
                p=upper_bound(count[x[j]].begin(),count[x[j]].end(),p)-count[x[j]].begin();
                }
            if(r==0)z+=1;
        }
        return z;
    }
};",None,"class Solution {
public:
map<char, vector<int>> count;
    int numMatchingSubseq(string s, vector<string>& words) {
        for (int i = 0; i < s.size(); i++) {
            count[s[i]].push_back(i);
        }

        int countSubseq = 0;
        for (auto& word : words) {
            if (count.find(word.back()) == count.end()) continue;
            bool isSubseq = true;
            int prevIndex = -1;
            for (char c : word) {
                auto it = upper_bound(count[c].begin(), count[c].end(), prevIndex);
                if (it == count[c].end()) {
                    isSubseq = false;
                    break;
                }
                prevIndex = *it;
            }

            if (isSubseq) {
                countSubseq++;
            }
        }

        return countSubseq;
    }
};
"
837,cpp,smallest-string-starting-from-leaf,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    string BFS(TreeNode* root)
    {
        if(!root) return """";
        queue<pair<TreeNode*,string>> q;
        vector<string> ans;
        string s = """";
        s+=root->val+96; 
        q.push({root,s});
        while(!q.empty())
        {
            TreeNode* node = q.front().first;
            string str = q.front().second;
            q.pop();
            if(!node->left && !node->right)
            {
                reverse(str.begin(),str.end());
                ans.push_back(str);
            }
            if(node->left)
            {
                string tmp = str;
                tmp+=node->left->val+97;
                q.push({node->left,tmp});
            }
            if(node->right)
            {
                string tmp = str;
                tmp+=node->right->val+97;
                q.push({node->right,tmp});
            }
        }
        sort(ans.begin(),ans.end());
        return ans[0];
    }
    string smallestFromLeaf(TreeNode* root) {
       return BFS(root);
    }
};",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    string BFS(TreeNode* root)
    {
        if(!root) return """";
        queue<pair<TreeNode*,string>> q;
        vector<string> ans;
        string s = """";
        s+=root->val+96; 
        q.push({root,s});
        while(!q.empty())
        {
            TreeNode* node = q.front().first;
            string str = q.front().second;
            q.pop();
            if(!node->left && !node->right)
            {
                ans.push_back(str);
            }
            if(node->left)
            {
                string tmp = str;
                tmp+=node->left->val+97;
                q.push({node->left,tmp});
            }
            if(node->right)
            {
                string tmp = str;
                tmp+=node->right->val+97;
                q.push({node->right,tmp});
            }
        }
        sort(ans.begin(),ans.end());
        return ans.front();
    }
    string smallestFromLeaf(TreeNode* root) {
       return BFS(root);
    }
};
"
837,cpp,smallest-string-starting-from-leaf,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    string BFS(TreeNode* root)
    {
        if(!root) return """";
        queue<pair<TreeNode*,string>> q;
        vector<string> ans;
        string s = """";
        s+=root->val+96; 
        q.push({root,s});
        while(!q.empty())
        {
            TreeNode* node = q.front().first;
            string str = q.front().second;
            q.pop();
            if(!node->left && !node->right)
            {
                reverse(str.begin(),str.end());
                ans.push_back(str);
            }
            if(node->left)
            {
                string tmp = str;
                tmp+=node->left->val+97;
                q.push({node->left,tmp});
            }
            if(node->right)
            {
                string tmp = str;
                tmp+=node->right->val+97;
                q.push({node->right,tmp});
            }
        }
        sort(ans.begin(),ans.end());
        return ans[0];
    }
    string smallestFromLeaf(TreeNode* root) {
       return BFS(root);
    }
};",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    string BFS(TreeNode* root)
    {
        if(!root) return """";
        queue<pair<TreeNode*,string>> q;
        vector<string> ans;
        string s = """";
        s+=root->val+96; 
        q.push({root,s});
        while(!q.empty())
        {
            TreeNode* node = q.front().first;
            string str = q.front().second;
            q.pop();
            if(!node->left && !node->right)
            {
                ans.push_back(str);
            }
            if(node->left)
            {
                string tmp = str;
                tmp+=node->left->val+97;
                q.push({node->left,tmp});
            }
            if(node->right)
            {
                string tmp = str;
                tmp+=node->right->val+97;
                q.push({node->right,tmp});
            }
        }
        if(ans.empty()) return """";
        sort(ans.begin(),ans.end());
        return ans[0];
    }
    string smallestFromLeaf(TreeNode* root) {
       return BFS(root);
    }
};
"
837,cpp,smallest-string-starting-from-leaf,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    string BFS(TreeNode* root)
    {
        if(!root) return """";
        queue<pair<TreeNode*,string>> q;
        vector<string> ans;
        string s = """";
        s+=root->val+96; 
        q.push({root,s});
        while(!q.empty())
        {
            TreeNode* node = q.front().first;
            string str = q.front().second;
            q.pop();
            if(!node->left && !node->right)
            {
                reverse(str.begin(),str.end());
                ans.push_back(str);
            }
            if(node->left)
            {
                string tmp = str;
                tmp+=node->left->val+97;
                q.push({node->left,tmp});
            }
            if(node->right)
            {
                string tmp = str;
                tmp+=node->right->val+97;
                q.push({node->right,tmp});
            }
        }
        sort(ans.begin(),ans.end());
        return ans[0];
    }
    string smallestFromLeaf(TreeNode* root) {
       return BFS(root);
    }
};",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    string BFS(TreeNode* root)
    {
        if(!root) return """";
        queue<pair<TreeNode*,string>> q;
        vector<string> ans;
        string s = """";
        s+=root->val+96; 
        q.push({root,s});
        while(!q.empty())
        {
            TreeNode* node = q.front().first;
            string str = q.front().second;
            q.pop();
            if(!node->left && !node->right)
            {
                ans.push_back(str);
            }
            if(node->left)
            {
                string tmp = str;
                tmp+=node->left->val+97;
                q.push({node->left,tmp});
            }
            if(node->right)
            {
                string tmp = str;
                tmp+=node->right->val+97;
                q.push({node->right,tmp});
            }
        }
        sort(ans.begin(),ans.end());
        return ans[0];
    }
    string smallestFromLeaf(TreeNode* root) {
       return BFS(root);
    }
};
"
838,cpp,mean-of-array-after-removing-some-elements,"class Solution {
public:
    double trimMean(vector<int>& arr) {
        int i, k;
        double mean;
        sort(arr.begin(), arr.end());
        k = 0.05*arr.size();
        for(i=0 ; i<k ; i++)
        {
            arr.erase(arr.begin()+0);
            arr.erase(arr.begin()+arr.size());
        }
        mean = (double)accumulate(arr.begin(), arr.end(), 0)/arr.size();
        return mean;
    }
};",None,"class Solution {
public:
    double trimMean(vector<int>& arr) {
        int i, k;
        double mean;
        sort(arr.begin(), arr.end());
        k = arr.size() * 0.05;
        for(i=0 ; i<k ; i++)
        {
            arr.erase(arr.begin());
            arr.pop_back();
        }
        mean = accumulate(arr.begin(), arr.end(), 0.0) / arr.size();
        return mean;
    }
};
"
838,cpp,mean-of-array-after-removing-some-elements,"class Solution {
public:
    double trimMean(vector<int>& arr) {
        int i, k;
        double mean;
        sort(arr.begin(), arr.end());
        k = 0.05*arr.size();
        for(i=0 ; i<k ; i++)
        {
            arr.erase(arr.begin()+0);
            arr.erase(arr.begin()+arr.size());
        }
        mean = (double)accumulate(arr.begin(), arr.end(), 0)/arr.size();
        return mean;
    }
};",None,"class Solution {
public:
    double trimMean(vector<int>& arr) {
        int i, k;
        double mean;
        sort(arr.begin(), arr.end());
        k = arr.size() * 0.05;
        for(i=0 ; i<k ; i++)
        {
            arr.erase(arr.begin());
            arr.pop_back();
        }
        if(arr.empty())
            return 0;
        mean = accumulate(arr.begin(), arr.end(), 0.0) / arr.size();
        return mean;
    }
};
"
838,cpp,mean-of-array-after-removing-some-elements,"class Solution {
public:
    double trimMean(vector<int>& arr) {
        int i, k;
        double mean;
        sort(arr.begin(), arr.end());
        k = 0.05*arr.size();
        for(i=0 ; i<k ; i++)
        {
            arr.erase(arr.begin()+0);
            arr.erase(arr.begin()+arr.size());
        }
        mean = (double)accumulate(arr.begin(), arr.end(), 0)/arr.size();
        return mean;
    }
};",None,"class Solution {
public:
    double trimMean(vector<int>& arr) {
        int i, k;
        double mean;
        sort(arr.begin(), arr.end());
        k = arr.size() * 0.05;
        for(i=0 ; i<k ; i++)
        {
            arr.erase(arr.begin());
            arr.pop_back();
        }
        mean = accumulate(arr.begin(), arr.end(), 0.0) / arr.size();
        return mean;
    }
};
"
839,cpp,the-k-strongest-values-in-an-array,"class Solution {
public:
    vector<int> getStrongest(vector<int>& arr, int k) {
        vector<pair<int,int>>v;
        int sum=0,n=arr.size();
        sort(arr.begin(),arr.end());
        int median=arr[(n-2)/2]; 
        for(int i=0;i<arr.size();i++)
        {
            v.push_back({abs(arr[i]-median),arr[i]});
        }
        sort(v.begin(),v.end());
        reverse(v.begin(),v.end());
        vector<int>ans;
        for(int i=0;i<k;i++)
        {
            ans.push_back(v[i].second);
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> getStrongest(vector<int>& arr, int k) {
        vector<pair<int,int>>v;
        int sum=0,n=arr.size();
        sort(arr.begin(),arr.end());
        int median=arr[(n-1)/2]; 
        for(int i=0;i<arr.size();i++)
        {
            v.push_back({abs(arr[i]-median),arr[i]});
        }
        sort(v.begin(),v.end());
        reverse(v.begin(),v.end());
        vector<int>ans;
        for(int i=0;i<k;i++)
        {
            ans.push_back(v[i].second);
        }
        return ans;
    }
};
"
839,cpp,the-k-strongest-values-in-an-array,"class Solution {
public:
    vector<int> getStrongest(vector<int>& arr, int k) {
        vector<pair<int,int>>v;
        int sum=0,n=arr.size();
        sort(arr.begin(),arr.end());
        int median=arr[(n-2)/2]; 
        for(int i=0;i<arr.size();i++)
        {
            v.push_back({abs(arr[i]-median),arr[i]});
        }
        sort(v.begin(),v.end());
        reverse(v.begin(),v.end());
        vector<int>ans;
        for(int i=0;i<k;i++)
        {
            ans.push_back(v[i].second);
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> getStrongest(vector<int>& arr, int k) {
        vector<pair<int,int>>v;
        int sum=0,n=arr.size();
        sort(arr.begin(),arr.end());
        int median=arr[(n-1)/2]; 
        for(int i=0;i<arr.size();i++)
        {
            v.push_back({abs(arr[i]-median),arr[i]});
        }
        sort(v.begin(),v.end());
        vector<int>ans;
        for(int i=0;i<k;i++)
        {
            ans.push_back(v[i].second);
        }
        return ans;
    }
};
"
839,cpp,the-k-strongest-values-in-an-array,"class Solution {
public:
    vector<int> getStrongest(vector<int>& arr, int k) {
        vector<pair<int,int>>v;
        int sum=0,n=arr.size();
        sort(arr.begin(),arr.end());
        int median=arr[(n-2)/2]; 
        for(int i=0;i<arr.size();i++)
        {
            v.push_back({abs(arr[i]-median),arr[i]});
        }
        sort(v.begin(),v.end());
        reverse(v.begin(),v.end());
        vector<int>ans;
        for(int i=0;i<k;i++)
        {
            ans.push_back(v[i].second);
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<int> getStrongest(vector<int>& arr, int k) {
        vector<pair<int,int>>v;
        int sum=0,n=arr.size();
        sort(arr.begin(),arr.end());
        int median=arr[n/2]; 
        for(int i=0;i<arr.size();i++)
        {
            v.push_back({abs(arr[i]-median),arr[i]});
        }
        sort(v.begin(),v.end());
        vector<int>ans;
        for(int i=0;i<k;i++)
        {
            ans.push_back(v[i].second);
        }
        return ans;
    }
};
"
840,cpp,score-after-flipping-matrix,"class Solution {
public:
    void fliprow(int &r,vector<vector<int>>& grid)
    {
        for(int i=0; i<grid[0].size(); i++){
            grid[r][i]=1-grid[r][i];
        }
    }

    void flipcol(int &c,vector<vector<int>>& grid){
        for(int j=0; j<grid.size(); j++){
            grid[j][c]=1-grid[j][c];
        }
    }

    int matrixScore(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        for(int i=0; i<n; i++){
            if(grid[i][0]==0){    
                fliprow(i,grid);
            }
        }
        for(int j=0; j<m; j++){
            int cnt0=0;
            int cnt1=0;
            for(int i=0; i<n; i++){
                if(grid[i][j]==1) cnt0++;
                else cnt1++;
            }
            if(cnt0>cnt1){
                flipcol(j,grid);
            }
        }
        int sum=0;
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(grid[i][j]==1){
                    sum+= (1<<(m-j-1));
                }
            }
        }
        return sum;
        

    }
};",None,"class Solution {
public:
    void fliprow(int &r,vector<vector<int>>& grid)
    {
        for(int i=0; i<grid[0].size(); i++){
            grid[r][i]=1-grid[r][i];
        }
    }

    void flipcol(int &c,vector<vector<int>>& grid){
        for(int j=0; j<grid.size(); j++){
            grid[j][c]=1-grid[j][c];
        }
    }

    int matrixScore(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        for(int i=0; i<n; i++){
            if(grid[i][0]==0){    
                fliprow(i,grid);
            }
        }
        for(int j=0; j<m; j++){
            int cnt0=0;
            int cnt1=0;
            for(int i=0; i<n; i++){
                if(grid[i][j]==1) cnt0++;
                else cnt1++;
            }
            if(cnt0<n-cnt0){ //change this line
                flipcol(j,grid);
            }
        }
        int sum=0;
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(grid[i][j]==1){
                    sum+= (1<<(m-j-1));
                }
            }
        }
        return sum;
        

    }
};
"
840,cpp,score-after-flipping-matrix,"class Solution {
public:
    void fliprow(int &r,vector<vector<int>>& grid)
    {
        for(int i=0; i<grid[0].size(); i++){
            grid[r][i]=1-grid[r][i];
        }
    }

    void flipcol(int &c,vector<vector<int>>& grid){
        for(int j=0; j<grid.size(); j++){
            grid[j][c]=1-grid[j][c];
        }
    }

    int matrixScore(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        for(int i=0; i<n; i++){
            if(grid[i][0]==0){    
                fliprow(i,grid);
            }
        }
        for(int j=0; j<m; j++){
            int cnt0=0;
            int cnt1=0;
            for(int i=0; i<n; i++){
                if(grid[i][j]==1) cnt0++;
                else cnt1++;
            }
            if(cnt0>cnt1){
                flipcol(j,grid);
            }
        }
        int sum=0;
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(grid[i][j]==1){
                    sum+= (1<<(m-j-1));
                }
            }
        }
        return sum;
        

    }
};",None,"class Solution {
public:
    void fliprow(int &r,vector<vector<int>>& grid)
    {
        for(int i=0; i<grid[0].size(); i++){
            grid[r][i]=1-grid[r][i];
        }
    }

    void flipcol(int &c,vector<vector<int>>& grid){
        for(int j=0; j<grid.size(); j++){
            grid[j][c]=1-grid[j][c];
        }
    }

    int matrixScore(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        for(int i=0; i<n; i++){
            if(grid[i][0]==0){    
                fliprow(i,grid);
            }
        }
        for(int j=0; j<m; j++){
            int cnt0=0;
            int cnt1=0;
            for(int i=0; i<n; i++){
                if(grid[i][j]==0) cnt0++;
                else cnt1++;
            }
            if(cnt0>cnt1){
                flipcol(j,grid);
            }
        }
        int sum=0;
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(grid[i][j]==1){
                    sum+= (1<<(m-j-1));
                }
            }
        }
        return sum;
        

    }
};
"
840,cpp,score-after-flipping-matrix,"class Solution {
public:
    void fliprow(int &r,vector<vector<int>>& grid)
    {
        for(int i=0; i<grid[0].size(); i++){
            grid[r][i]=1-grid[r][i];
        }
    }

    void flipcol(int &c,vector<vector<int>>& grid){
        for(int j=0; j<grid.size(); j++){
            grid[j][c]=1-grid[j][c];
        }
    }

    int matrixScore(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        for(int i=0; i<n; i++){
            if(grid[i][0]==0){    
                fliprow(i,grid);
            }
        }
        for(int j=0; j<m; j++){
            int cnt0=0;
            int cnt1=0;
            for(int i=0; i<n; i++){
                if(grid[i][j]==1) cnt0++;
                else cnt1++;
            }
            if(cnt0>cnt1){
                flipcol(j,grid);
            }
        }
        int sum=0;
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(grid[i][j]==1){
                    sum+= (1<<(m-j-1));
                }
            }
        }
        return sum;
        

    }
};",None,"class Solution {
public:
    void fliprow(int &r,vector<vector<int>>& grid)
    {
        for(int i=0; i<grid[0].size(); i++){
            grid[r][i]=1-grid[r][i];
        }
    }

    void flipcol(int &c,vector<vector<int>>& grid){
        for(int j=0; j<grid.size(); j++){
            grid[j][c]=1-grid[j][c];
        }
    }

    int matrixScore(vector<vector<int>>& grid) {
        int n=grid.size();
        int m=grid[0].size();
        for(int i=0; i<n; i++){
            if(grid[i][0]==0){    
                fliprow(i,grid);
            }
        }
        for(int j=0; j<m; j++){
            int cnt0=0;
            int cnt1=0;
            for(int i=0; i<n; i++){
                if(grid[i][j]==0) cnt0++;
                else cnt1++;
            }
            if(cnt0>cnt1){
                flipcol(j,grid);
            }
        }
        int sum=0;
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(grid[i][j]==1){
                    sum+= (1<<(m-j-1));
                }
            }
        }
        return sum;
        

    }
};
"
841,cpp,percentage-of-letter-in-string,"class Solution {
public:
    int percentageLetter(string s, char letter) {
        int count = 0;
        for(int i=0; i<s.length(); i++){
            if(s[i] == letter){
                count = count + 2;
            }
        }
        int ans = ((count*100)/s.length()); 
        return ans;
    }
};",None,"class Solution {
public:
    int percentageLetter(string s, char letter) {
        int count = 0;
        for(int i=0; i<s.length(); i++){
            if(s[i] == letter){
                count++;
            }
        }
        int ans = (count*100)/s.length(); 
        return ans;
    }
};
"
841,cpp,percentage-of-letter-in-string,"class Solution {
public:
    int percentageLetter(string s, char letter) {
        int count = 0;
        for(int i=0; i<s.length(); i++){
            if(s[i] == letter){
                count = count + 2;
            }
        }
        int ans = ((count*100)/s.length()); 
        return ans;
    }
};",None,"class Solution {
public:
    int percentageLetter(string s, char letter) {
        int count = 0;
        for(int i=0; i<s.length(); i++){
            if(s[i] == letter){
                count++;
            }
        }
        if(count == 0) return 0;
        int ans = (count*100)/s.length();
        return ans;
    }
};
"
841,cpp,percentage-of-letter-in-string,"class Solution {
public:
    int percentageLetter(string s, char letter) {
        int count = 0;
        for(int i=0; i<s.length(); i++){
            if(s[i] == letter){
                count = count + 2;
            }
        }
        int ans = ((count*100)/s.length()); 
        return ans;
    }
};",None,"class Solution {
public:
    int percentageLetter(string s, char letter) {
        int count = 0;
        for(int i=0; i<s.length(); i++){
            if(s[i] == letter)
                count++;
        }
        if(count == 0)
            return 0;
        double ans = (static_cast<double>(count)*100)/s.length(); 
        return static_cast<int>(ans);
    }
};
"
842,cpp,minimum-changes-to-make-alternating-binary-string,"class Solution {
public:
    int minOperations(string s) {
        int n=s.size(), ans=0;
        for(int i=0;i<n;i++)
        {
            if(s[i]-'0' != i%2)
            ans++;
        }
        return min(ans, n+ans);
    }
};",None,"class Solution {
public:
    int minOperations(string s) {
        int n=s.size(), ones=0, zeros=0;

        // Count the number of '1's and '0's that do not fit the alternating pattern
        for(int i=0;i<n;i++)
        {
            if(s[i]-'0' != i%2)
            {
                if(s[i] == '1')
                    ones++;
                else
                    zeros++;
            }
        }

        // The minimum number of operations is the minimum number of '1's and '0's that do not fit the alternating pattern
        return min(ones, zeros);
    }
};
"
842,cpp,minimum-changes-to-make-alternating-binary-string,"class Solution {
public:
    int minOperations(string s) {
        int n=s.size(), ans=0;
        for(int i=0;i<n;i++)
        {
            if(s[i]-'0' != i%2)
            ans++;
        }
        return min(ans, n+ans);
    }
};",None,"class Solution {
public:
    int minOperations(string s) {
        int n=s.size(), one_count=0, zero_count=0;
        for(int i=0;i<n;i++)
        {
            if(s[i]-'0' != i%2)
            {
                if(s[i]=='0')
                    zero_count++;
                else
                    one_count++;
            }
        }
        return min(zero_count, one_count);
    }
};
"
842,cpp,minimum-changes-to-make-alternating-binary-string,"class Solution {
public:
    int minOperations(string s) {
        int n=s.size(), ans=0;
        for(int i=0;i<n;i++)
        {
            if(s[i]-'0' != i%2)
            ans++;
        }
        return min(ans, n+ans);
    }
};",None,"class Solution {
public:
    int minOperations(string s) {
        int n=s.size(), ans=0;
        for(int i=0;i<n;i++)
        {
            if(s[i]-'0' != i%2)
                ans++;
        }
        return min(ans, n-ans);
    }
};
"
843,cpp,length-of-longest-fibonacci-subsequence,"class Solution {
public:
  int f(int curr,int prev,vector<int>& nums,int n){
			int t=nums[curr]+nums[prev];
			int i=lower_bound(nums.begin(),nums.end(),t)-nums.begin();
			if(i<n && nums[i]==t) return 1+f(i,curr,nums,n);
			return 0;
		}

		int lenLongestFibSubseq(vector<int>& nums) {
			int n=nums.size();
			int maxi=0;
			for(int prev2=0;prev2<n;prev2++){
				for(int prev1=prev2+1;prev1<n;prev1++){
					int temp=nums[prev1]+nums[prev2];
					int ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();
					if(ind<n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));
				}
			}
			return maxi;
		}
	};",None,"class Solution {
public:
  int f(int curr, int prev, vector<int>& nums, int n) {
    int t = nums[curr] + nums[prev];
    int i = lower_bound(nums.begin(), nums.end(), t) - nums.begin();
    if (i < n && nums[i] == t) return 1 + f(i, curr, nums, n);
    return 0;
  }

  int lenLongestFibSubseq(vector<int>& nums) {
    int n = nums.size();
    int maxi = 0;
    for (int prev2 = 0; prev2 < n; prev2++) {
      for (int prev1 = prev2 + 1; prev1 < n; prev1++) {
        int temp = nums[prev1] + nums[prev2];
        int ind = lower_bound(nums.begin(), nums.end(), temp) - nums.begin();
        if (ind < n && nums[ind] == temp) maxi = max(maxi, 2 + f(ind, prev1, nums, n));
      }
    }
    return maxi;
  }
};
"
843,cpp,length-of-longest-fibonacci-subsequence,"class Solution {
public:
  int f(int curr,int prev,vector<int>& nums,int n){
			int t=nums[curr]+nums[prev];
			int i=lower_bound(nums.begin(),nums.end(),t)-nums.begin();
			if(i<n && nums[i]==t) return 1+f(i,curr,nums,n);
			return 0;
		}

		int lenLongestFibSubseq(vector<int>& nums) {
			int n=nums.size();
			int maxi=0;
			for(int prev2=0;prev2<n;prev2++){
				for(int prev1=prev2+1;prev1<n;prev1++){
					int temp=nums[prev1]+nums[prev2];
					int ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();
					if(ind<n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));
				}
			}
			return maxi;
		}
	};",None,"class Solution {
public:
  int f(int curr, int prev, vector<int>& nums, int n) {
    int t = nums[curr] + nums[prev];
    int i = lower_bound(nums.begin(), nums.end(), t) - nums.begin();
    if (i < n && nums[i] == t) return 1 + f(i, curr, nums, n);
    return 0;
  }

  int lenLongestFibSubseq(vector<int>& nums) {
    int n = nums.size();
    int maxi = 0;
    for (int prev2 = 0; prev2 < n; prev2++) {
      for (int prev1 = prev2 + 1; prev1 < n; prev1++) {
        int temp = nums[prev1] + nums[prev2];
        int ind = lower_bound(nums.begin(), nums.end(), temp) - nums.begin();
        if (ind < n && nums[ind] == temp) maxi = max(maxi, 2 + f(ind, prev1, nums, n));
      }
    }
    return maxi;
  }
};
"
843,cpp,length-of-longest-fibonacci-subsequence,"class Solution {
public:
  int f(int curr,int prev,vector<int>& nums,int n){
			int t=nums[curr]+nums[prev];
			int i=lower_bound(nums.begin(),nums.end(),t)-nums.begin();
			if(i<n && nums[i]==t) return 1+f(i,curr,nums,n);
			return 0;
		}

		int lenLongestFibSubseq(vector<int>& nums) {
			int n=nums.size();
			int maxi=0;
			for(int prev2=0;prev2<n;prev2++){
				for(int prev1=prev2+1;prev1<n;prev1++){
					int temp=nums[prev1]+nums[prev2];
					int ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();
					if(ind<n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));
				}
			}
			return maxi;
		}
	};",None,"class Solution {
public:
  int f(int curr, int prev, vector<int>& nums, int n) {
    int t = nums[curr] + nums[prev];
    int i = lower_bound(nums.begin(), nums.end(), t) - nums.begin();
    if (i < n && nums[i] == t) return 1 + f(i, curr, nums, n);
    return 0;
  }

  int lenLongestFibSubseq(vector<int>& nums) {
    int n = nums.size();
    int maxi = 0;
    for (int prev2 = 0; prev2 < n; prev2++) {
      for (int prev1 = prev2 + 1; prev1 < n; prev1++) {
        int temp = nums[prev1] + nums[prev2];
        int ind = lower_bound(nums.begin(), nums.end(), temp) - nums.begin();
        if (ind < n && nums[ind] == temp)
          maxi = max(maxi, 2 + f(ind, prev1, nums, n));
      }
    }
    return maxi;
  }
};
"
844,cpp,longest-subarray-of-1s-after-deleting-one-element,"class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right, zeros = 0, ans = 0;

        for (right = 0; right < n; right++) {
            if (nums[right] == 0){
                zeros++;
                }
            if (zeros > 1 && nums[left++] == 0){
                zeros--;
                }
            ans = max(ans, right - left);
        }
        return ans + 1; 
    }
};",None,"class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right, zeros = 0, ans = 0;

        for (right = 0; right < n; right++) {
            if (nums[right] == 0){
                zeros++;
                }
            if (zeros > 1 && nums[left] == 0){
                zeros--;
                left++;
                }
            ans = max(ans, right - left);
        }
        return ans;
    }
};
"
844,cpp,longest-subarray-of-1s-after-deleting-one-element,"class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right, zeros = 0, ans = 0;

        for (right = 0; right < n; right++) {
            if (nums[right] == 0){
                zeros++;
                }
            if (zeros > 1 && nums[left++] == 0){
                zeros--;
                }
            ans = max(ans, right - left);
        }
        return ans + 1; 
    }
};",None,"class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right, zeros = 0, ans = 0;

        for (right = 0; right < n; right++) {
            if (nums[right] == 0){
                zeros++;
                }
            if (zeros > 1 && nums[left++] == 0){
                zeros--;
                }
            ans = max(ans, right - left);
        }
        return ans;
    }
};
"
844,cpp,longest-subarray-of-1s-after-deleting-one-element,"class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right, zeros = 0, ans = 0;

        for (right = 0; right < n; right++) {
            if (nums[right] == 0){
                zeros++;
                }
            if (zeros > 1 && nums[left++] == 0){
                zeros--;
                }
            ans = max(ans, right - left);
        }
        return ans + 1; 
    }
};",None,"class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right, zeros = 0, ans = 0;

        for (right = 0; right < n; right++) {
            if (nums[right] == 0){
                zeros++;
                }
            if (zeros > 1 && nums[left] == 0){
                zeros--;
                left++;
                }
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
};
"
845,cpp,intervals-between-identical-elements,"class Solution {
public:
    vector<long long> getDistances(vector<int>& arr) {
        
        int n = arr.size();
        vector<long long> ans(n);
        unordered_map<long long,long long> sum,freq,currfreq,currsum;

        for(int i = 0;i<n;i++)
        {
           sum[arr[i]]+=i;
           freq[arr[i]]++;
        }

        for(int i = 0;i<n;i++)
        {
           currfreq[arr[i]]++;
           currsum[arr[i]]+=i;

           long long currfrq = currfreq[arr[i]],remfreq = freq[arr[i]]-currfreq[arr[i]];
           long long currsumval = currsum[arr[i]],remsum = sum[arr[i]]-currsum[arr[i]];
           ans[i] =  abs(i*currfrq-(currsumval-i))+abs(i*remfreq-remsum);
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<long long> getDistances(vector<int>& arr) {
        
        int n = arr.size();
        vector<long long> ans(n);
        unordered_map<int,long long> sum,freq,currfreq,currsum;

        for(int i = 0;i<n;i++)
        {
           sum[arr[i]]+=i;
           freq[arr[i]]++;
        }

        for(int i = 0;i<n;i++)
        {
           currfreq[arr[i]]++;
           currsum[arr[i]]+=i;

           long long currfrq = currfreq[arr[i]],remfreq = freq[arr[i]]-currfreq[arr[i]];
           long long currsumval = currsum[arr[i]],remsum = sum[arr[i]]-currsum[arr[i]];
           ans[i] =  abs(i*currfrq-currsumval)+abs(i*remfreq-remsum);
        }
        return ans;
    }
};
"
845,cpp,intervals-between-identical-elements,"class Solution {
public:
    vector<long long> getDistances(vector<int>& arr) {
        
        int n = arr.size();
        vector<long long> ans(n);
        unordered_map<long long,long long> sum,freq,currfreq,currsum;

        for(int i = 0;i<n;i++)
        {
           sum[arr[i]]+=i;
           freq[arr[i]]++;
        }

        for(int i = 0;i<n;i++)
        {
           currfreq[arr[i]]++;
           currsum[arr[i]]+=i;

           long long currfrq = currfreq[arr[i]],remfreq = freq[arr[i]]-currfreq[arr[i]];
           long long currsumval = currsum[arr[i]],remsum = sum[arr[i]]-currsum[arr[i]];
           ans[i] =  abs(i*currfrq-(currsumval-i))+abs(i*remfreq-remsum);
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<long long> getDistances(vector<int>& arr) {
        
        int n = arr.size();
        vector<long long> ans(n);
        unordered_map<int,long long> sum,freq;

        for(int i = 0;i<n;i++)
        {
           sum[arr[i]]+=i;
           freq[arr[i]]++;
        }

        for(int i = 0;i<n;i++)
        {
           long long currfrq = freq[arr[i]],remfreq = freq[arr[i]]-1;
           long long currsumval = sum[arr[i]],remsum = sum[arr[i]]-i-1;
           ans[i] =  abs(i*currfrq-(currsumval-i))+abs(i*remfreq-remsum);
        }
        return ans;
    }
};
"
845,cpp,intervals-between-identical-elements,"class Solution {
public:
    vector<long long> getDistances(vector<int>& arr) {
        
        int n = arr.size();
        vector<long long> ans(n);
        unordered_map<long long,long long> sum,freq,currfreq,currsum;

        for(int i = 0;i<n;i++)
        {
           sum[arr[i]]+=i;
           freq[arr[i]]++;
        }

        for(int i = 0;i<n;i++)
        {
           currfreq[arr[i]]++;
           currsum[arr[i]]+=i;

           long long currfrq = currfreq[arr[i]],remfreq = freq[arr[i]]-currfreq[arr[i]];
           long long currsumval = currsum[arr[i]],remsum = sum[arr[i]]-currsum[arr[i]];
           ans[i] =  abs(i*currfrq-(currsumval-i))+abs(i*remfreq-remsum);
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<long long> getDistances(vector<int>& arr) {
        
        int n = arr.size();
        vector<long long> ans(n);
        unordered_map<int,long long> sum,freq,currfreq,currsum;

        for(int i = 0;i<n;i++)
        {
           sum[arr[i]]+=i;
           freq[arr[i]]++;
        }

        for(int i = 0;i<n;i++)
        {
           currfreq[arr[i]]++;
           currsum[arr[i]]+=i;

           long long currfrq = currfreq[arr[i]],remfreq = freq[arr[i]]-currfreq[arr[i]];
           long long currsumval = currsum[arr[i]],remsum = sum[arr[i]]-currsum[arr[i]];
           ans[i] =  abs(i*currfrq-currsumval)+abs(i*remfreq-remsum);
        }
        return ans;
    }
};
"
846,cpp,count-elements-with-strictly-smaller-and-greater-elements,"class Solution {
public:
    int countElements(vector<int>& nums) {

        if(nums.size() == 1 || nums.size() == 2) return 0;
        int ma = *max_element(nums.begin(),nums.end());
        int countma = count(nums.begin(),nums.end(),ma);
        int mi = *min_element(nums.begin(),nums.end());
        int countmi = count(nums.begin(),nums.end(),mi);
        int ans = nums.size() - (countma+countmi);
        if(ans <= 0) return 0;
        return nums.size() - (countma + countmi - 1);
        
    }
};",None,"class Solution {
public:
    int countElements(vector<int>& nums) {

        if(nums.size() < 3) return 0;
        int ma = *max_element(nums.begin(),nums.end());
        int countma = count(nums.begin(),nums.end(),ma);
        int mi = *min_element(nums.begin(),nums.end());
        int countmi = count(nums.begin(),nums.end(),mi);
        int ans = nums.size() - (countma+countmi);
        if(ans <= 0) return 0;
        return ans - 1;
    }
};
"
846,cpp,count-elements-with-strictly-smaller-and-greater-elements,"class Solution {
public:
    int countElements(vector<int>& nums) {

        if(nums.size() == 1 || nums.size() == 2) return 0;
        int ma = *max_element(nums.begin(),nums.end());
        int countma = count(nums.begin(),nums.end(),ma);
        int mi = *min_element(nums.begin(),nums.end());
        int countmi = count(nums.begin(),nums.end(),mi);
        int ans = nums.size() - (countma+countmi);
        if(ans <= 0) return 0;
        return nums.size() - (countma + countmi - 1);
        
    }
};",None,"class Solution {
public:
    int countElements(vector<int>& nums) {

        if(nums.size() < 3) return 0;
        int ma = *max_element(nums.begin(),nums.end());
        int mi = *min_element(nums.begin(),nums.end());
        int countma = count(nums.begin(),nums.end(),ma);
        int countmi = count(nums.begin(),nums.end(),mi);
        int ans = count(nums.begin(), nums.end(), mi, ma);
        return ans;
    }
};
"
846,cpp,count-elements-with-strictly-smaller-and-greater-elements,"class Solution {
public:
    int countElements(vector<int>& nums) {

        if(nums.size() == 1 || nums.size() == 2) return 0;
        int ma = *max_element(nums.begin(),nums.end());
        int countma = count(nums.begin(),nums.end(),ma);
        int mi = *min_element(nums.begin(),nums.end());
        int countmi = count(nums.begin(),nums.end(),mi);
        int ans = nums.size() - (countma+countmi);
        if(ans <= 0) return 0;
        return nums.size() - (countma + countmi - 1);
        
    }
};",None,"class Solution {
public:
    int countElements(vector<int>& nums) {

        if(nums.size() < 3) return 0;
        int ma = *max_element(nums.begin(),nums.end());
        int mi = *min_element(nums.begin(),nums.end());
        int countma = count(nums.begin(),nums.end(),ma);
        int countmi = count(nums.begin(),nums.end(),mi);
        int ans = count(nums.begin(),nums.end(),ma-1) + count(nums.begin(),nums.end(),mi+1);
        if(ans <= 0) return 0;
        return ans;
        
    }
};
"
847,cpp,smallest-index-with-equal-value,"class Solution {
public:
    int smallestEqual(vector<int>& nums) {
        for (int i = 0 ; i < nums.size() ; i ++)
        {
            if ( (nums[i] % 10) == nums[i] )
            {
                return i ;
            }
        }
        return -1; 
    }
};",None,"class Solution {
public:
    int smallestEqual(vector<int>& nums) {
        for (int i = 0 ; i < nums.size() ; i ++)
        {
            if (i % 10 == nums[i])
            {
                return i ;
            }
        }
        return -1; 
    }
};
"
847,cpp,smallest-index-with-equal-value,"class Solution {
public:
    int smallestEqual(vector<int>& nums) {
        for (int i = 0 ; i < nums.size() ; i ++)
        {
            if ( (nums[i] % 10) == nums[i] )
            {
                return i ;
            }
        }
        return -1; 
    }
};",None,"class Solution {
public:
    int smallestEqual(vector<int>& nums) {
        for (int i = 0 ; i < nums.size() ; i ++)
        {
            if (i % 10 == nums[i])
            {
                return i ;
            }
        }
        return -1; 
    }
};
"
847,cpp,smallest-index-with-equal-value,"class Solution {
public:
    int smallestEqual(vector<int>& nums) {
        for (int i = 0 ; i < nums.size() ; i ++)
        {
            if ( (nums[i] % 10) == nums[i] )
            {
                return i ;
            }
        }
        return -1; 
    }
};",None,"class Solution {
public:
    int smallestEqual(vector<int>& nums) {
        for (int i = 0 ; i < nums.size() ; i ++)
        {
            if (i % 10 == nums[i])
            {
                return i ;
            }
        }
        return -1; 
    }
};
"
848,cpp,middle-of-the-linked-list,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* temp = head;
        ListNode* mid = head;
        while(temp != NULL && temp -> next != NULL){
            mid = mid -> next;
            temp = temp->next;
        }
        return mid;
    }
};",None,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;

        while (fast != NULL && fast->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
        }

        return slow;
    }
};
"
848,cpp,middle-of-the-linked-list,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* temp = head;
        ListNode* mid = head;
        while(temp != NULL && temp -> next != NULL){
            mid = mid -> next;
            temp = temp->next;
        }
        return mid;
    }
};",None,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;
        while(fast != NULL && fast -> next != NULL){
            slow = slow -> next;
            fast = fast->next->next;
        }
        return slow;
    }
};
"
848,cpp,middle-of-the-linked-list,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* temp = head;
        ListNode* mid = head;
        while(temp != NULL && temp -> next != NULL){
            mid = mid -> next;
            temp = temp->next;
        }
        return mid;
    }
};",None,"/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;
        while(fast != NULL && fast -> next != NULL){
            slow = slow -> next;
            fast = fast->next->next;
        }
        return slow;
    }
};
"
849,cpp,shortest-path-to-get-all-keys,"class Solution {
public:

    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};

    int shortestPathAllKeys(vector<string>& grid) {
        
        int m = grid.size();
        int n = grid[0].size();
        queue<pair<pair<int, int>, int>> que;
        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));
        int target = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {
                    target |= 1 << (grid[i][j] - 'a');
                    continue;
                }

                if (grid[i][j] == '@') {
                    que.emplace(pair<int, int>(i, j), 0);
                    mapKey[i][j] = 1;
                }
            }
        }


        int step = 0;
        while (!que.empty()) {
            int size = que.size();
            for (int s = 0; s < size; s++) {
                int i = que.front().first.first;
                int j = que.front().first.second;
                int key = que.front().second;
                que.pop();
                
                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {
                    key |= 1 << (grid[i][j] - 'a');
                    if (key == target)
                        return step;

                    mapKey[i][j] |= 1l << key;
                }

                for (int d = 0; d < 4; d++) {
                    int newi = i + dir[d][0];
                    int newj = j + dir[d][1];
                    
                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))
                        continue;
                        
                    int val = grid[newi][newj];
                    if (val == '#')
                        continue;
                        
                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)
                        continue;
                        
                    if (mapKey[newi][newj] & (1l << key))
                        continue;
                        
                     mapKey[newi][newj] |= 1l << (key+1);  
                     que.emplace(pair<int, int>(newi, newj), key);
                }
            }
            step++;
        }
        return -1;
    }
};",None,M
849,cpp,shortest-path-to-get-all-keys,"class Solution {
public:

    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};

    int shortestPathAllKeys(vector<string>& grid) {
        
        int m = grid.size();
        int n = grid[0].size();
        queue<pair<pair<int, int>, int>> que;
        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));
        int target = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {
                    target |= 1 << (grid[i][j] - 'a');
                    continue;
                }

                if (grid[i][j] == '@') {
                    que.emplace(pair<int, int>(i, j), 0);
                    mapKey[i][j] = 1;
                }
            }
        }


        int step = 0;
        while (!que.empty()) {
            int size = que.size();
            for (int s = 0; s < size; s++) {
                int i = que.front().first.first;
                int j = que.front().first.second;
                int key = que.front().second;
                que.pop();
                
                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {
                    key |= 1 << (grid[i][j] - 'a');
                    if (key == target)
                        return step;

                    mapKey[i][j] |= 1l << key;
                }

                for (int d = 0; d < 4; d++) {
                    int newi = i + dir[d][0];
                    int newj = j + dir[d][1];
                    
                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))
                        continue;
                        
                    int val = grid[newi][newj];
                    if (val == '#')
                        continue;
                        
                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)
                        continue;
                        
                    if (mapKey[newi][newj] & (1l << key))
                        continue;
                        
                     mapKey[newi][newj] |= 1l << (key+1);  
                     que.emplace(pair<int, int>(newi, newj), key);
                }
            }
            step++;
        }
        return -1;
    }
};",None,"class Solution {
public:

    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};

    int shortestPathAllKeys(vector<string>& grid) {
        
        int m = grid.size();
        int n = grid[0].size();
        queue<pair<pair<int, int>, int>> que;
        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));
        int target = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {
                    target |= 1 << (grid[i][j] - 'a');
                    continue;
                }

                if (grid[i][j] == '@') {
                    que.emplace(pair<int, int>(i, j), 0);
                    mapKey[i][j] = 1;
                }
            }
        }


        int step = 0;
        while (!que.empty()) {
            int size = que.size();
            for (int s = 0; s < size; s++) {
                int i = que.front().first.first;
                int j = que.front().first.second;
                int key = que.front().second;
                que.pop();
                
                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {
                    key |= 1 << (grid[i][j] - 'a');
                    if (key == target)
                        return step;
                }

                for (int d = 0; d < 4; d++) {
                    int newi = i + dir[d][0];
                    int newj = j + dir[d][1];
                    
                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))
                        continue;
                        
                    int val = grid[newi][newj];
                    if (val == '#')
                        continue;
                        
                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)
                        continue;
                        
                    if (mapKey[newi][newj] & (1l << key))
                        continue;
                        
                    mapKey[newi][newj] |= 1l << key;  
                    que.emplace(pair<int, int>(newi, newj), key);
                }
            }
            step++;
        }
        return -1;
    }
};
"
849,cpp,shortest-path-to-get-all-keys,"class Solution {
public:

    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};

    int shortestPathAllKeys(vector<string>& grid) {
        
        int m = grid.size();
        int n = grid[0].size();
        queue<pair<pair<int, int>, int>> que;
        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));
        int target = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {
                    target |= 1 << (grid[i][j] - 'a');
                    continue;
                }

                if (grid[i][j] == '@') {
                    que.emplace(pair<int, int>(i, j), 0);
                    mapKey[i][j] = 1;
                }
            }
        }


        int step = 0;
        while (!que.empty()) {
            int size = que.size();
            for (int s = 0; s < size; s++) {
                int i = que.front().first.first;
                int j = que.front().first.second;
                int key = que.front().second;
                que.pop();
                
                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {
                    key |= 1 << (grid[i][j] - 'a');
                    if (key == target)
                        return step;

                    mapKey[i][j] |= 1l << key;
                }

                for (int d = 0; d < 4; d++) {
                    int newi = i + dir[d][0];
                    int newj = j + dir[d][1];
                    
                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))
                        continue;
                        
                    int val = grid[newi][newj];
                    if (val == '#')
                        continue;
                        
                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)
                        continue;
                        
                    if (mapKey[newi][newj] & (1l << key))
                        continue;
                        
                     mapKey[newi][newj] |= 1l << (key+1);  
                     que.emplace(pair<int, int>(newi, newj), key);
                }
            }
            step++;
        }
        return -1;
    }
};",None,"class Solution {
public:

    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};

    int shortestPathAllKeys(vector<string>& grid) {
        
        int m = grid.size();
        int n = grid[0].size();
        queue<pair<pair<int, int>, int>> que;
        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));
        int target = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {
                    target |= 1 << (grid[i][j] - 'a');
                    continue;
                }

                if (grid[i][j] == '@') {
                    que.emplace(pair<int, int>(i, j), 0);
                    mapKey[i][j] = 1;
                }
            }
        }


        int step = 0;
        while (!que.empty()) {
            int size = que.size();
            for (int s = 0; s < size; s++) {
                int i = que.front().first.first;
                int j = que.front().first.second;
                int key = que.front().second;
                que.pop();
                
                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {
                    key |= 1 << (grid[i][j] - 'a');
                    if (key == target)
                        return step;
                }

                for (int d = 0; d < 4; d++) {
                    int newi = i + dir[d][0];
                    int newj = j + dir[d][1];
                    
                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))
                        continue;
                        
                    int val = grid[newi][newj];
                    if (val == '#')
                        continue;
                        
                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)
                        continue;
                        
                    if (mapKey[newi][newj] & (1l << key))
                        continue;
                        
                    mapKey[newi][newj] |= 1l << key;  
                    que.emplace(pair<int, int>(newi, newj), key);
                }
            }
            step++;
        }
        return -1;
    }
};
"
850,cpp,plus-one,"class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int n=digits.size();
        digits[n]++;
        for(int i=n-1;i>=1;i--)
        {
            if(digits[i]>9)
            {
                digits[i]%=10;
                digits[i-1]++;
            }
        }
        if(digits[0]>9)
        {
            digits.insert(digits.begin(),1);
            digits[1]%=10;
        }
        return digits;
    }
};",None,"class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int n=digits.size();
        digits[n-1]++;
        for(int i=n-1;i>=0;i--)
        {
            if(digits[i]>9)
            {
                digits[i]%=10;
                if(i!=0)
                    digits[i-1]++;
                else
                    digits.insert(digits.begin(),1);
            }
        }
        return digits;
    }
};
"
850,cpp,plus-one,"class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int n=digits.size();
        digits[n]++;
        for(int i=n-1;i>=1;i--)
        {
            if(digits[i]>9)
            {
                digits[i]%=10;
                digits[i-1]++;
            }
        }
        if(digits[0]>9)
        {
            digits.insert(digits.begin(),1);
            digits[1]%=10;
        }
        return digits;
    }
};",None,"class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int n=digits.size();
        digits[n-1]++;
        for(int i=n-1;i>=0;i--)
        {
            if(digits[i]>9)
            {
                digits[i]%=10;
                if(i==0)
                    digits.insert(digits.begin(),1);
                else
                    digits[i-1]++;
            }
            else
                break;
        }
        return digits;
    }
};
"
850,cpp,plus-one,"class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int n=digits.size();
        digits[n]++;
        for(int i=n-1;i>=1;i--)
        {
            if(digits[i]>9)
            {
                digits[i]%=10;
                digits[i-1]++;
            }
        }
        if(digits[0]>9)
        {
            digits.insert(digits.begin(),1);
            digits[1]%=10;
        }
        return digits;
    }
};",None,"class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int n=digits.size();
        digits[n-1]++;
        for(int i=n-1;i>=0;i--)
        {
            if(digits[i]>9)
            {
                digits[i]%=10;
                if(i!=0)
                    digits[i-1]++;
                else
                    digits.insert(digits.begin(),1);
            }
        }
        return digits;
    }
};
"
851,cpp,valid-anagram,"class Solution {
public:
    bool isAnagram(string s, string t) {
        if(s.length()!=t.length())
            return false;
        vector<int> freq(26, 0);
        for(int i =0; i<s.length(); i++){
            freq[s[i]-'a']++;
            freq[t[i]-'a']++;
        }
        for(int i =0; i<freq.size(); i++){
            if(freq[i]!=0)
                return false;
        }
        return true;
    }
};",None,"class Solution {
public:
    bool isAnagram(string s, string t) {
        if(s.length()!=t.length())
            return false;
        vector<int> freq(26, 0);
        for(int i =0; i<s.length(); i++){
            freq[s[i]-'a']++;
            freq[t[i]-'a']--;
        }
        for(int i =0; i<freq.size(); i++){
            if(freq[i]!=0)
                return false;
        }
        return true;
    }
};
"
851,cpp,valid-anagram,"class Solution {
public:
    bool isAnagram(string s, string t) {
        if(s.length()!=t.length())
            return false;
        vector<int> freq(26, 0);
        for(int i =0; i<s.length(); i++){
            freq[s[i]-'a']++;
            freq[t[i]-'a']++;
        }
        for(int i =0; i<freq.size(); i++){
            if(freq[i]!=0)
                return false;
        }
        return true;
    }
};",None,"class Solution {
public:
    bool isAnagram(string s, string t) {
        if(s.length()!=t.length())
            return false;
        vector<int> freq(26, 0);
        for(int i =0; i<s.length(); i++){
            freq[s[i]-'a']++;
            freq[t[i]-'a']--;
        }
        for(int i =0; i<freq.size(); i++){
            if(freq[i]!=0)
                return false;
        }
        return true;
    }
};
"
851,cpp,valid-anagram,"class Solution {
public:
    bool isAnagram(string s, string t) {
        if(s.length()!=t.length())
            return false;
        vector<int> freq(26, 0);
        for(int i =0; i<s.length(); i++){
            freq[s[i]-'a']++;
            freq[t[i]-'a']++;
        }
        for(int i =0; i<freq.size(); i++){
            if(freq[i]!=0)
                return false;
        }
        return true;
    }
};",None,"class Solution {
public:
    bool isAnagram(string s, string t) {
        if(s.length()!=t.length())
            return false;
        vector<int> freq(26, 0);
        for(int i =0; i<s.length(); i++){
            freq[s[i]-'a']++;
        }
        for(int i =0; i<t.length(); i++){
            freq[t[i]-'a']--;
        }
        for(int i =0; i<freq.size(); i++){
            if(freq[i]!=0)
                return false;
        }
        return true;
    }
};
"
852,cpp,valid-boomerang,"class Solution {
public:
    bool isBoomerang(vector<vector<int>>& points) {
        float a, b, c, d;
        a = (points[1][1] - points[0][1]);
        b = (points[1][0] - points[0][0]);
        c = (points[2][1] - points[1][1]);
        d = (points[2][0] - points[1][0]);
        if((b != 0 && d != 0 && a * c == b * c) || (b == 0 && d == 0 && points[0][0] == points[1][0]))
        {
            return false;
        }
        if((points[0][0] == points[1][0] && points[0][1] == points[1][1]) || (points[0][0] == points[2][0] && points[0][1] == points[2][1]) || (points[1][0] == points[2][0] && points[1][1] == points[2][1]))
        {
            return false;
        }
        return true;
    }
};",None,"class Solution {
public:
    bool isBoomerang(vector<vector<int>>& points) {
        int a = (points[1][1] - points[0][1]);
        int b = (points[1][0] - points[0][0]);
        int c = (points[2][1] - points[1][1]);
        int d = (points[2][0] - points[1][0]);
        if(b == 0 && d == 0)
            return false;
        if(a * c == b * d)
            return false;
        if(points[0][0] == points[1][0] && points[0][1] == points[1][1])
            return false;
        if(points[0][0] == points[2][0] && points[0][1] == points[2][1])
            return false;
        if(points[1][0] == points[2][0] && points[1][1] == points[2][1])
            return false;
        return true;
    }
};
"
852,cpp,valid-boomerang,"class Solution {
public:
    bool isBoomerang(vector<vector<int>>& points) {
        float a, b, c, d;
        a = (points[1][1] - points[0][1]);
        b = (points[1][0] - points[0][0]);
        c = (points[2][1] - points[1][1]);
        d = (points[2][0] - points[1][0]);
        if((b != 0 && d != 0 && a * c == b * c) || (b == 0 && d == 0 && points[0][0] == points[1][0]))
        {
            return false;
        }
        if((points[0][0] == points[1][0] && points[0][1] == points[1][1]) || (points[0][0] == points[2][0] && points[0][1] == points[2][1]) || (points[1][0] == points[2][0] && points[1][1] == points[2][1]))
        {
            return false;
        }
        return true;
    }
};",None,"class Solution {
public:
    bool isBoomerang(vector<vector<int>>& points) {
        int a = (points[1][1] - points[0][1]);
        int b = (points[1][0] - points[0][0]);
        int c = (points[2][1] - points[1][1]);
        int d = (points[2][0] - points[1][0]);
        if(a * d == b * c)
        {
            return false;
        }
        if(points[0][0] == points[1][0] && points[0][1] == points[1][1])
        {
            return false;
        }
        if(points[0][0] == points[2][0] && points[0][1] == points[2][1])
        {
            return false;
        }
        if(points[1][0] == points[2][0] && points[1][1] == points[2][1])
        {
            return false;
        }
        return true;
    }
};
"
852,cpp,valid-boomerang,"class Solution {
public:
    bool isBoomerang(vector<vector<int>>& points) {
        float a, b, c, d;
        a = (points[1][1] - points[0][1]);
        b = (points[1][0] - points[0][0]);
        c = (points[2][1] - points[1][1]);
        d = (points[2][0] - points[1][0]);
        if((b != 0 && d != 0 && a * c == b * c) || (b == 0 && d == 0 && points[0][0] == points[1][0]))
        {
            return false;
        }
        if((points[0][0] == points[1][0] && points[0][1] == points[1][1]) || (points[0][0] == points[2][0] && points[0][1] == points[2][1]) || (points[1][0] == points[2][0] && points[1][1] == points[2][1]))
        {
            return false;
        }
        return true;
    }
};",None,"class Solution {
public:
    bool isBoomerang(vector<vector<int>>& points) {
        int a = (points[1][1] - points[0][1]);
        int b = (points[1][0] - points[0][0]);
        int c = (points[2][1] - points[1][1]);
        int d = (points[2][0] - points[1][0]);
        if(b == 0 && d == 0) return false;
        if(a * c != b * d) return true;
        if(points[0][0] == points[1][0] && points[0][1] == points[1][1]) return false;
        if(points[0][0] == points[2][0] && points[0][1] == points[2][1]) return false;
        if(points[1][0] == points[2][0] && points[1][1] == points[2][1]) return false;
        return false;
    }
};
"
853,cpp,frequency-tracker,"class FrequencyTracker {
public:
    unordered_map<int,int> x,y;
    void add(int number) {
        x[number]++;
        if(x[number]!=1) y[x[number]-1]--;
        y[x[number]]--;
    }
    void deleteOne(int number) {
        if(x[number]!=0){
            x[number]--;
            y[x[number]+1]--;
            y[x[number]]++;
        }
    }
    bool hasFrequency(int frequency) {
        if(y[frequency]!=0) return true;
        return false;
    }
};",None,"class FrequencyTracker {
public:
    unordered_map<int,int> x,y;
    void add(int number) {
        x[number]++;
        if(x[number]!=1) y[x[number]-1]--;
        y[x[number]]++;
    }
    void deleteOne(int number) {
        if(x[number]!=0){
            x[number]--;
            y[x[number]]--;
            if(x[number]>0) y[x[number]]++;
        }
    }
    bool hasFrequency(int frequency) {
        if(y[frequency]!=0) return true;
        return false;
    }
};
"
853,cpp,frequency-tracker,"class FrequencyTracker {
public:
    unordered_map<int,int> x,y;
    void add(int number) {
        x[number]++;
        if(x[number]!=1) y[x[number]-1]--;
        y[x[number]]--;
    }
    void deleteOne(int number) {
        if(x[number]!=0){
            x[number]--;
            y[x[number]+1]--;
            y[x[number]]++;
        }
    }
    bool hasFrequency(int frequency) {
        if(y[frequency]!=0) return true;
        return false;
    }
};",None,"class FrequencyTracker {
public:
    unordered_map<int,int> x,y;
    void add(int number) {
        x[number]++;
        if(x[number]!=1) y[x[number]-1]--;
        y[x[number]]++;
    }
    void deleteOne(int number) {
        if(x[number]!=0){
            x[number]--;
            y[x[number]+1]--;
            y[x[number]]++;
        }
    }
    bool hasFrequency(int frequency) {
        if(y[frequency]!=0) return true;
        return false;
    }
};
"
853,cpp,frequency-tracker,"class FrequencyTracker {
public:
    unordered_map<int,int> x,y;
    void add(int number) {
        x[number]++;
        if(x[number]!=1) y[x[number]-1]--;
        y[x[number]]--;
    }
    void deleteOne(int number) {
        if(x[number]!=0){
            x[number]--;
            y[x[number]+1]--;
            y[x[number]]++;
        }
    }
    bool hasFrequency(int frequency) {
        if(y[frequency]!=0) return true;
        return false;
    }
};",None,"class FrequencyTracker {
public:
    unordered_map<int,int> x,y;
    void add(int number) {
        x[number]++;
        if(x[number]!=1) y[x[number]-1]--;
        y[x[number]]--;
    }
    void deleteOne(int number) {
        if(x[number]!=0){
            x[number]--;
            y[x[number]]++;
            y[x[number]+1]--;
        }
    }
    bool hasFrequency(int frequency) {
        if(y[frequency]!=0) return true;
        return false;
    }
};
"
854,cpp,single-number,"class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_map<int,int> mp;
        for(int i=0;i<nums.size();i++){
            mp[nums[i]] = 1;
        }
        for(auto m:mp){
            if(m.second==1){
                return m.first;
            }
        }
        return -1;
    }
};",None,"class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int result = 0;
        for(int i=0;i<nums.size();i++){
            result ^= nums[i];
        }
        return result;
    }
};
"
854,cpp,single-number,"class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_map<int,int> mp;
        for(int i=0;i<nums.size();i++){
            mp[nums[i]] = 1;
        }
        for(auto m:mp){
            if(m.second==1){
                return m.first;
            }
        }
        return -1;
    }
};",None,"class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int result = 0;
        for(int i=0;i<nums.size();i++){
            result ^= nums[i];
        }
        return result;
    }
};
"
854,cpp,single-number,"class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_map<int,int> mp;
        for(int i=0;i<nums.size();i++){
            mp[nums[i]] = 1;
        }
        for(auto m:mp){
            if(m.second==1){
                return m.first;
            }
        }
        return -1;
    }
};",None,"class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int result = 0;
        for(int i=0;i<nums.size();i++){
            result ^= nums[i];
        }
        return result;
    }
};
"
855,cpp,factorial-trailing-zeroes,"class Solution {
public:
    unordered_map<long long int,long long int>mp;
    int trailingZeroes(int n) {
        for(int i=n;i>=1;i--)
         fun(i);
         
		 return max(mp[2],mp[5]); 
    }
     void fun(int n)
    {
         for(int i=2;i*i<=n;i++)
         {
         	while((n%i) == 0)
         	{
         	    mp[i]++;
				n = n / i;	
			}
		 }
		 if(n > 1)
		 mp[n]++;
    }
};",None,"class Solution {
public:
    int trailingZeroes(int n) {
        int count = 0;
        for (int i = 5; i <= n; i += 5) {
            int temp = i;
            while (temp % 5 == 0) {
                temp /= 5;
                count++;
            }
        }
        return count;
    }
};
"
855,cpp,factorial-trailing-zeroes,"class Solution {
public:
    unordered_map<long long int,long long int>mp;
    int trailingZeroes(int n) {
        for(int i=n;i>=1;i--)
         fun(i);
         
		 return max(mp[2],mp[5]); 
    }
     void fun(int n)
    {
         for(int i=2;i*i<=n;i++)
         {
         	while((n%i) == 0)
         	{
         	    mp[i]++;
				n = n / i;	
			}
		 }
		 if(n > 1)
		 mp[n]++;
    }
};",None,"class Solution {
public:
    int trailingZeroes(int n) {
        int count = 0;
        for (int i = 5; i <= n; i += 5) {
            int power = 0;
            for (int j = i; j % 5 == 0; j /= 5) {
                power++;
            }
            count += power;
        }
        return count;
    }
};
"
855,cpp,factorial-trailing-zeroes,"class Solution {
public:
    unordered_map<long long int,long long int>mp;
    int trailingZeroes(int n) {
        for(int i=n;i>=1;i--)
         fun(i);
         
		 return max(mp[2],mp[5]); 
    }
     void fun(int n)
    {
         for(int i=2;i*i<=n;i++)
         {
         	while((n%i) == 0)
         	{
         	    mp[i]++;
				n = n / i;	
			}
		 }
		 if(n > 1)
		 mp[n]++;
    }
};",None,"class Solution {
public:
    int trailingZeroes(int n) {
        int count = 0;
        for (; n >= 5; n /= 5) {
            count += n / 5;
        }
        return count;
    }
};
"
856,cpp,unique-paths-iii,"class Solution {
public:
   int count = 0 ; 
   int zeroes = 0 ; 

   void creator(vector<vector<int>>& grid, int row, int col, int length) {
       if (row < 0 || col < 0 || row >= grid.size() || col >= grid[0].size() || grid[row][col] == 3 || grid[row][col] == -1)
           return; 

       if (grid[row][col] == 2 && zeroes == length) {
           count++;
           return;
       }

       int org = grid[row][col]; 
       grid[row][col] = 3; 

       creator(grid, row + 1, col, length + 1);
       creator(grid, row - 1, col, length + 1);
       creator(grid, row, col + 1, length + 1);
       creator(grid, row, col - 1, length + 1);
       
       grid[row][col] = org; 
       return;
   }

   int uniquePathsIII(vector<vector<int>>& grid) {
       int row = 0; 
       int col = 0; 
       int free = 0;

       for (int i = 0; i < grid.size(); i++) {
           for (int j = 0; j < grid[0].size(); j++) {
               if (grid[i][j] == 1) {
                   row = i; 
                   col = j;
                   free++;
               } else if (grid[i][j] == 0 || grid[i][j] == 2) {
                   free += 2;
               }
           }
       }
       
       zeroes = free; 
       
       creator(grid, row, col, 1);
       
       return count;
   }
};",None,"class Solution {
public:
    int count = 0;
    int zeroes = 0;

    void creator(vector<vector<int>>& grid, int row, int col, int length) {
        if (row < 0 || col < 0 || row >= grid.size() || col >= grid[0].size() || grid[row][col] == -1)
            return;

        if (grid[row][col] == 2 && zeroes == length + 1) {
            count++;
            return;
        }

        int org = grid[row][col];
        grid[row][col] = 3;

        creator(grid, row + 1, col, length + 1);
        creator(grid, row - 1, col, length + 1);
        creator(grid, row, col + 1, length + 1);
        creator(grid, row, col - 1, length + 1);

        grid[row][col] = org;
    }

    int uniquePathsIII(vector<vector<int>>& grid) {
        int row = 0;
        int col = 0;
        int free = 0;

        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid[0].size(); j++) {
                if (grid[i][j] == 1) {
                    row = i;
                    col = j;
                } else if (grid[i][j] == 0 || grid[i][j] == 2) {
                    free++;
                }
            }
        }

        zeroes = free;
        creator(grid, row, col, 1);

        return count;
    }
};
"
856,cpp,unique-paths-iii,"class Solution {
public:
   int count = 0 ; 
   int zeroes = 0 ; 

   void creator(vector<vector<int>>& grid, int row, int col, int length) {
       if (row < 0 || col < 0 || row >= grid.size() || col >= grid[0].size() || grid[row][col] == 3 || grid[row][col] == -1)
           return; 

       if (grid[row][col] == 2 && zeroes == length) {
           count++;
           return;
       }

       int org = grid[row][col]; 
       grid[row][col] = 3; 

       creator(grid, row + 1, col, length + 1);
       creator(grid, row - 1, col, length + 1);
       creator(grid, row, col + 1, length + 1);
       creator(grid, row, col - 1, length + 1);
       
       grid[row][col] = org; 
       return;
   }

   int uniquePathsIII(vector<vector<int>>& grid) {
       int row = 0; 
       int col = 0; 
       int free = 0;

       for (int i = 0; i < grid.size(); i++) {
           for (int j = 0; j < grid[0].size(); j++) {
               if (grid[i][j] == 1) {
                   row = i; 
                   col = j;
                   free++;
               } else if (grid[i][j] == 0 || grid[i][j] == 2) {
                   free += 2;
               }
           }
       }
       
       zeroes = free; 
       
       creator(grid, row, col, 1);
       
       return count;
   }
};",None,"class Solution {
public:
   int count = 0 ; 
   int zeroes = 0 ; 

   void creator(vector<vector<int>>& grid, int row, int col, int length) {
       if (row < 0 || col < 0 || row >= grid.size() || col >= grid[0].size() || grid[row][col] == -1)
           return; 

       if (grid[row][col] == 2 && zeroes == length) {
           count++;
           return;
       }

       int org = grid[row][col]; 
       grid[row][col] = 3; 

       creator(grid, row + 1, col, length + 1);
       creator(grid, row - 1, col, length + 1);
       creator(grid, row, col + 1, length + 1);
       creator(grid, row, col - 1, length + 1);
       
       grid[row][col] = org; 
       return;
   }

   int uniquePathsIII(vector<vector<int>>& grid) {
       int row = 0; 
       int col = 0;
       int free = 0;

       for (int i = 0; i < grid.size(); i++) {
           for (int j = 0; j < grid[0].size(); j++) {
               if (grid[i][j] == 1) {
                   row = i; 
                   col = j;
               } else if (grid[i][j] == 0 || grid[i][j] == 2) {
                   free++;
               }
           }
       }
       
       zeroes = free; 
       
       creator(grid, row, col, 1);
       
       return count;
   }
};
"
856,cpp,unique-paths-iii,"class Solution {
public:
   int count = 0 ; 
   int zeroes = 0 ; 

   void creator(vector<vector<int>>& grid, int row, int col, int length) {
       if (row < 0 || col < 0 || row >= grid.size() || col >= grid[0].size() || grid[row][col] == 3 || grid[row][col] == -1)
           return; 

       if (grid[row][col] == 2 && zeroes == length) {
           count++;
           return;
       }

       int org = grid[row][col]; 
       grid[row][col] = 3; 

       creator(grid, row + 1, col, length + 1);
       creator(grid, row - 1, col, length + 1);
       creator(grid, row, col + 1, length + 1);
       creator(grid, row, col - 1, length + 1);
       
       grid[row][col] = org; 
       return;
   }

   int uniquePathsIII(vector<vector<int>>& grid) {
       int row = 0; 
       int col = 0; 
       int free = 0;

       for (int i = 0; i < grid.size(); i++) {
           for (int j = 0; j < grid[0].size(); j++) {
               if (grid[i][j] == 1) {
                   row = i; 
                   col = j;
                   free++;
               } else if (grid[i][j] == 0 || grid[i][j] == 2) {
                   free += 2;
               }
           }
       }
       
       zeroes = free; 
       
       creator(grid, row, col, 1);
       
       return count;
   }
};",None,"class Solution {
public:
   int count = 0 ; 
   int zeroes = 0 ; 

   void creator(vector<vector<int>>& grid, int row, int col, int length) {
       if (row < 0 || col < 0 || row >= grid.size() || col >= grid[0].size() || grid[row][col] == -1)
           return; 

       if (grid[row][col] == 2 && zeroes == length) {
           count++;
           return;
       }

       int org = grid[row][col]; 
       grid[row][col] = 3; 

       creator(grid, row + 1, col, length + 1);
       creator(grid, row - 1, col, length + 1);
       creator(grid, row, col + 1, length + 1);
       creator(grid, row, col - 1, length + 1);
       
       grid[row][col] = org; 
       return;
   }

   int uniquePathsIII(vector<vector<int>>& grid) {
       int row = 0; 
       int col = 0;
       int free = 0;

       for (int i = 0; i < grid.size(); i++) {
           for (int j = 0; j < grid[0].size(); j++) {
               if (grid[i][j] == 1) {
                   row = i; 
                   col = j;
               } else if (grid[i][j] == 0 || grid[i][j] == 2) {
                   free++;
               }
           }
       }
       
       zeroes = free - 1;  // minus one because starting point is also a zero
       
       creator(grid, row, col, 1);
       
       return count;
   }
};
"
857,cpp,check-if-point-is-reachable,"class Solution {
public:
    bool isReachable(int x, int y) {
        while(!(x&1)){
            x >>= 1;
        }
        while(!(y&1)){
            y >>= 1;
        }
        return __gcd(x,y)==0;
    }
};",None,"class Solution {
public:
    bool isReachable(int targetX, int targetY) {
        if (targetX == 1 && targetY == 1) {
            return true;
        }
        if (targetX == 1 || targetY == 1) {
            return targetX == 1 ? isReachable(targetX, targetY / 2) : isReachable(targetX / 2, targetY);
        }
        if (targetX % 2 == 0 && targetY % 2 == 0) {
            return isReachable(targetX / 2, targetY / 2) || isReachable(targetX / 2, targetY) || isReachable(targetX, targetY / 2);
        }
        return false;
    }
};
"
857,cpp,check-if-point-is-reachable,"class Solution {
public:
    bool isReachable(int x, int y) {
        while(!(x&1)){
            x >>= 1;
        }
        while(!(y&1)){
            y >>= 1;
        }
        return __gcd(x,y)==0;
    }
};",None,"class Solution {
public:
    bool isReachable(int targetX, int targetY) {
        if (targetX == 1 && targetY == 1) {
            return true;
        }
        if (targetX == 1 || targetY == 1) {
            return targetX == 1 ? isReachable(targetX, targetY / 2) : isReachable(targetX / 2, targetY);
        }
        if (targetX % 2 == 0 && targetY % 2 == 0) {
            return isReachable(targetX / 2, targetY / 2) || isReachable(targetX / 2, targetY) || isReachable(targetX, targetY / 2);
        }
        return false;
    }
};
"
857,cpp,check-if-point-is-reachable,"class Solution {
public:
    bool isReachable(int x, int y) {
        while(!(x&1)){
            x >>= 1;
        }
        while(!(y&1)){
            y >>= 1;
        }
        return __gcd(x,y)==0;
    }
};",None,"class Solution {
public:
    bool isReachable(int targetX, int targetY) {
        if (targetX == 1 && targetY == 1) {
            return true;
        }
        if (targetX == 1 || targetY == 1) {
            return targetX * targetY != 1;
        }
        while (targetX % 2 == 0) {
            targetX /= 2;
        }
        while (targetY % 2 == 0) {
            targetY /= 2;
        }
        return __gcd(targetX, targetY) == 1;
    }
};
"
858,cpp,check-knight-tour-configuration,"class Solution {
private:
    bool helper(vector<vector<int>>& grid, int row, int col, int num){
        int n = grid.size();
        if(num == n*n) return true;
        int i = row-2;
        int j = col+1;
        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row-2;
        j = col-1;
        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+2);

        i = row + 2;
        j = col - 1;
        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 2;
        j = col + 1;
        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 1;
        j = col + 2;
        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row - 1;
        j = col + 2;
        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row - 1;
        j = col - 2;
        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 1;
        j = col - 2;
        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        return false;
    }
public:
    bool checkValidGrid(vector<vector<int>>& grid) {
        ios::sync_with_stdio(false);
        cin.tie(0);
        cout.tie(0);
        if(grid[0][0] != 0) return false;
        return helper(grid,0,0,1);
    }
};",None,"class Solution {
private:
    bool helper(vector<vector<int>>& grid, int row, int col, int num){
        int n = grid.size();
        if(num == n*n) return true;
        int dx[8] = {-2, -2, 2, 2, -1, 1, -1, 1};
        int dy[8] = {-1, 1, -1, 1, -2, -2, 2, 2};
        for (int i = 0; i < 8; i++) {
            int newRow = row + dx[i];
            int newCol = col + dy[i];
            if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == num)
                if (helper(grid, newRow, newCol, num + 1))
                    return true;
        }
        return false;
    }
public:
    bool checkValidGrid(vector<vector<int>>& grid) {
        if(grid[0][0] != 0) return false;
        return helper(grid, 0, 0, 1);
    }
};
"
858,cpp,check-knight-tour-configuration,"class Solution {
private:
    bool helper(vector<vector<int>>& grid, int row, int col, int num){
        int n = grid.size();
        if(num == n*n) return true;
        int i = row-2;
        int j = col+1;
        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row-2;
        j = col-1;
        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+2);

        i = row + 2;
        j = col - 1;
        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 2;
        j = col + 1;
        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 1;
        j = col + 2;
        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row - 1;
        j = col + 2;
        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row - 1;
        j = col - 2;
        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 1;
        j = col - 2;
        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        return false;
    }
public:
    bool checkValidGrid(vector<vector<int>>& grid) {
        ios::sync_with_stdio(false);
        cin.tie(0);
        cout.tie(0);
        if(grid[0][0] != 0) return false;
        return helper(grid,0,0,1);
    }
};",None,"class Solution {
private:
    bool helper(vector<vector<int>>& grid, int row, int col, int num){
        int n = grid.size();
        if(num == n*n) return true;
        vector<pair<int, int>> moves = {{row-2, col+1}, {row-2, col-1}, {row+2, col-1}, {row+2, col+1}, {row+1, col+2}, {row-1, col+2}, {row-1, col-2}, {row+1, col-2}};
        for(auto& [x, y] : moves){
            if(x >= 0 && x < n && y >= 0 && y < n && grid[x][y] == num)
                if(helper(grid, x, y, num+1)) return true;
        }
        return false;
    }
public:
    bool checkValidGrid(vector<vector<int>>& grid) {
        int n = grid.size();
        if(grid[0][0] != 0) return false;
        return helper(grid, 0, 0, 1);
    }
};
"
858,cpp,check-knight-tour-configuration,"class Solution {
private:
    bool helper(vector<vector<int>>& grid, int row, int col, int num){
        int n = grid.size();
        if(num == n*n) return true;
        int i = row-2;
        int j = col+1;
        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row-2;
        j = col-1;
        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+2);

        i = row + 2;
        j = col - 1;
        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 2;
        j = col + 1;
        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 1;
        j = col + 2;
        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row - 1;
        j = col + 2;
        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row - 1;
        j = col - 2;
        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        i = row + 1;
        j = col - 2;
        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);

        return false;
    }
public:
    bool checkValidGrid(vector<vector<int>>& grid) {
        ios::sync_with_stdio(false);
        cin.tie(0);
        cout.tie(0);
        if(grid[0][0] != 0) return false;
        return helper(grid,0,0,1);
    }
};",None,"class Solution {
private:
    bool helper(vector<vector<int>>& grid, int row, int col, int num){
        int n = grid.size();
        if(num == n*n) return true;
        vector<pair<int, int>> moves = {{row-2, col+1}, {row-2, col-1}, {row+2, col-1}, {row+2, col+1}, {row+1, col+2}, {row-1, col+2}, {row-1, col-2}, {row+1, col-2}};
        for(auto& move : moves){
            int newRow = move.first;
            int newCol = move.second;
            if(newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == num)
                if(helper(grid, newRow, newCol, num + 1))
                    return true;
        }
        return false;
    }
public:
    bool checkValidGrid(vector<vector<int>>& grid) {
        if(grid[0][0] != 0) return false;
        return helper(grid, 0, 0, 1);
    }
};
"
859,cpp,climbing-stairs,"class Solution {
public:
    int solve(int n,vector<int> &dp){
        if(n<=2)
          return n;
        
        if(dp[n]!=-1) 
          return dp[n]; 
        
        dp[n]=solve(n-1,dp)+solve(n-3,dp); 
        return dp[n];
    }
    int climbStairs(int n) {
        if(n<=2)
         return n;
        vector<int> dp(n+1);
        for(int i=0;i<=n;i++)
         dp[i]=-1;
        
        return solve(n,dp);
    }
};",None,"class Solution {
public:
    int solve(int n,vector<int> &dp){
        if(n<=2)
          return n;
        
        if(dp[n]!=0) 
          return dp[n]; 
        
        dp[n]=solve(n-1,dp)+solve(n-2,dp); 
        return dp[n];
    }
    int climbStairs(int n) {
        if(n<=2)
         return n;
        vector<int> dp(n+1, 0);
        
        return solve(n,dp);
    }
};
"
859,cpp,climbing-stairs,"class Solution {
public:
    int solve(int n,vector<int> &dp){
        if(n<=2)
          return n;
        
        if(dp[n]!=-1) 
          return dp[n]; 
        
        dp[n]=solve(n-1,dp)+solve(n-3,dp); 
        return dp[n];
    }
    int climbStairs(int n) {
        if(n<=2)
         return n;
        vector<int> dp(n+1);
        for(int i=0;i<=n;i++)
         dp[i]=-1;
        
        return solve(n,dp);
    }
};",None,"class Solution {
public:
    int climbStairs(int n) {
        if(n <= 2)
            return n;
        vector<int> dp(n+1, -1);
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
};
"
859,cpp,climbing-stairs,"class Solution {
public:
    int solve(int n,vector<int> &dp){
        if(n<=2)
          return n;
        
        if(dp[n]!=-1) 
          return dp[n]; 
        
        dp[n]=solve(n-1,dp)+solve(n-3,dp); 
        return dp[n];
    }
    int climbStairs(int n) {
        if(n<=2)
         return n;
        vector<int> dp(n+1);
        for(int i=0;i<=n;i++)
         dp[i]=-1;
        
        return solve(n,dp);
    }
};",None,"class Solution {
public:
    int solve(int n,vector<int> &dp){
        if(n<=2)
          return n;
        
        if(dp[n]!=0) 
          return dp[n]; 
        
        dp[n]=solve(n-1,dp)+solve(n-2,dp); 
        return dp[n];
    }
    int climbStairs(int n) {
        if(n<=2)
         return n;
        vector<int> dp(n+1,0);
        
        return solve(n,dp);
    }
};
"
860,cpp,minimum-cost-to-split-an-array,"class Solution {
public:
    int minCost(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> dp(n,INT_MAX);
        dp[0]=k;
        unordered_map<int,int> freq;

        for(int i=1;i<n;i++)
        {
            int val=0;
            freq.clear();
            for(int j=i;j>=0;j--)
            {
                freq[nums[j]]++;
                if(freq[nums[j]]==2)
                val+=2;
                else if(freq[nums[j]]>2) 
                val++;
                dp[i]=min(dp[i],(j>0?dp[j]:0)+k+val);
            }
        }
        return dp[n];
    }
};",None,"class Solution {
public:
    int minCost(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> dp(n,INT_MAX);
        dp[0]=k;
        unordered_map<int,int> freq;

        for(int i=1;i<n;i++)
        {
            int val=0;
            freq.clear();
            for(int j=i;j>=0;j--)
            {
                freq[nums[j]]++;
                if(freq[nums[j]]==2)
                    val+=2;
                else if(freq[nums[j]]>2)
                    val++;
                if(j>0)
                    dp[i]=min(dp[i],dp[j-1]+k+val);
                else
                    dp[i]=min(dp[i],k+val);
            }
        }
        return dp[n-1];
    }
};
"
860,cpp,minimum-cost-to-split-an-array,"class Solution {
public:
    int minCost(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> dp(n,INT_MAX);
        dp[0]=k;
        unordered_map<int,int> freq;

        for(int i=1;i<n;i++)
        {
            int val=0;
            freq.clear();
            for(int j=i;j>=0;j--)
            {
                freq[nums[j]]++;
                if(freq[nums[j]]==2)
                val+=2;
                else if(freq[nums[j]]>2) 
                val++;
                dp[i]=min(dp[i],(j>0?dp[j]:0)+k+val);
            }
        }
        return dp[n];
    }
};",None,"class Solution {
public:
    int minCost(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> dp(n, INT_MAX);
        dp[0] = k;
        unordered_map<int, int> freq;

        for (int i = 1; i < n; i++) {
            freq.clear();
            int val = 0;
            for (int j = i; j >= 0; j--) {
                freq[nums[j]]++;
                if (freq[nums[j]] == 2)
                    val += 2;
                else if (freq[nums[j]] > 2)
                    val++;

                // Adjust dp[i] calculation to consider the importance value
                dp[i] = min(dp[i], (j > 0 ? dp[j - 1] : 0) + k + val);
            }
        }
        return dp[n - 1];
    }
};
"
860,cpp,minimum-cost-to-split-an-array,"class Solution {
public:
    int minCost(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> dp(n,INT_MAX);
        dp[0]=k;
        unordered_map<int,int> freq;

        for(int i=1;i<n;i++)
        {
            int val=0;
            freq.clear();
            for(int j=i;j>=0;j--)
            {
                freq[nums[j]]++;
                if(freq[nums[j]]==2)
                val+=2;
                else if(freq[nums[j]]>2) 
                val++;
                dp[i]=min(dp[i],(j>0?dp[j]:0)+k+val);
            }
        }
        return dp[n];
    }
};",None,"class Solution {
public:
    int minCost(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> dp(n,INT_MAX);
        dp[0]=k;
        unordered_map<int,int> freq;

        for(int i=1;i<n;i++)
        {
            int val=0;
            freq.clear();
            for(int j=i;j>=0;j--)
            {
                freq[nums[j]]++;
                if(freq[nums[j]]==2)
                    val+=2;
                else if(freq[nums[j]]>2)
                    val++;
                if(j > 0)
                    dp[i]=min(dp[i], dp[j-1] + k + val);
                else
                    dp[i]=min(dp[i], k + val);
            }
        }
        return dp[n-1];
    }
};
"
861,cpp,maximum-number-of-ways-to-partition-an-array,"class Solution {
public:
     long long int getSum(vector<int> &nums){
        long long int temp = 0;
        for(auto &i : nums) temp += i-1;
        return temp;
    }

    bool check(unordered_map<long long int, pair<int, int>> &mp, long long int val, int pivot, bool flag){
        
        if(flag){
            if(mp[val].second >= pivot) return true;
            return false;
        }

        else{
            if(mp[val].first < pivot) return true;
            return false;
        }
    }

    int waysToPartition(vector<int>& nums, int k) {
        unordered_map<long long int, pair<int, int>> mp;
        unordered_map<long long int, pair<int, int>> count;

        for(int i=0; i<nums.size(); i++){
            if(mp.find(nums[i]) == mp.end()){
                mp[nums[i]].first = i;
            }
            mp[nums[i]].second = i;
        }

        long long int totSum = getSum(nums);
        long long int left = nums[0];
        int ans = 0;

        for(int i=1; i<nums.size(); i++){
            long long int right = totSum - left;

            if(left == right){
                ans++;
            }
            else{
                long long int diff = left - right;

                long long int num = k - diff;

                if(mp.find(num) != mp.end()){
                    if(check(mp, num, i, 1)){

                        count[num].second++;
                    }
                }

                diff = right - left;
                num = k - diff;

                if(mp.find(num) != mp.end()){
                    if(check(mp, num, i, 0)){

                        count[num].first++; 
                    }
                }
            }

            left += nums[i];

            count[nums[i]].first = max(count[nums[i]].first, count[nums[i]].second);
        }

        int maxi = INT_MIN;
        for(auto [i,j] : count){
            maxi = max(maxi, max(j.first, j.second));
        }

        return max(maxi, ans);
    }
};",None,"class Solution {
public:
     long long int getSum(vector<int> &nums){
        long long int temp = 0;
        for(auto &i : nums) temp += i;
        return temp;
    }

    bool check(unordered_map<long long int, pair<int, int>> &mp, long long int val, int pivot, bool flag){
        
        if(flag){
            if(mp[val].second >= pivot) return true;
            return false;
        }

        else{
            if(mp[val].first < pivot) return true;
            return false;
        }
    }

    int waysToPartition(vector<int>& nums, int k) {
        unordered_map<long long int, pair<int, int>> mp;
        unordered_map<long long int, pair<int, int>> count;

        for(int i=0; i<nums.size(); i++){
            if(mp.find(nums[i]) == mp.end()){
                mp[nums[i]] = {i, i};
            }
            else{
                mp[nums[i]].second = i;
            }
        }

        long long int totSum = getSum(nums);
        long long int left = nums[0];
        int ans = 0;

        for(int i=1; i<nums.size(); i++){
            long long int right = totSum - left - nums[i];

            if(left == right){
                ans++;
            }
            else{
                long long int diff = left - right;

                long long int num = k - diff;

                if(mp.find(num) != mp.end()){
                    if(check(mp, num, i, 1)){

                        count[num]++;
                    }
                }

                diff = right - left;
                num = k - diff;

                if(mp.find(num) != mp.end()){
                    if(check(mp, num, i, 0)){

                        count[num]++; 
                    }
                }
            }

            left += nums[i];

            count[nums[i]] = max(count[nums[i]], 1);
        }

        int maxi = INT_MIN;
        for(auto [i,j] : count){
            maxi = max(maxi, j);
        }

        return max(maxi, ans);
    }
};
"
861,cpp,maximum-number-of-ways-to-partition-an-array,"class Solution {
public:
     long long int getSum(vector<int> &nums){
        long long int temp = 0;
        for(auto &i : nums) temp += i-1;
        return temp;
    }

    bool check(unordered_map<long long int, pair<int, int>> &mp, long long int val, int pivot, bool flag){
        
        if(flag){
            if(mp[val].second >= pivot) return true;
            return false;
        }

        else{
            if(mp[val].first < pivot) return true;
            return false;
        }
    }

    int waysToPartition(vector<int>& nums, int k) {
        unordered_map<long long int, pair<int, int>> mp;
        unordered_map<long long int, pair<int, int>> count;

        for(int i=0; i<nums.size(); i++){
            if(mp.find(nums[i]) == mp.end()){
                mp[nums[i]].first = i;
            }
            mp[nums[i]].second = i;
        }

        long long int totSum = getSum(nums);
        long long int left = nums[0];
        int ans = 0;

        for(int i=1; i<nums.size(); i++){
            long long int right = totSum - left;

            if(left == right){
                ans++;
            }
            else{
                long long int diff = left - right;

                long long int num = k - diff;

                if(mp.find(num) != mp.end()){
                    if(check(mp, num, i, 1)){

                        count[num].second++;
                    }
                }

                diff = right - left;
                num = k - diff;

                if(mp.find(num) != mp.end()){
                    if(check(mp, num, i, 0)){

                        count[num].first++; 
                    }
                }
            }

            left += nums[i];

            count[nums[i]].first = max(count[nums[i]].first, count[nums[i]].second);
        }

        int maxi = INT_MIN;
        for(auto [i,j] : count){
            maxi = max(maxi, max(j.first, j.second));
        }

        return max(maxi, ans);
    }
};",None,"class Solution {
public:
    long long getSum(vector<int>& nums) {
        long long sum = 0;
        for (int i = 0; i < nums.size(); i++) {
            sum += nums[i];
        }
        return sum;
    }

    bool check(unordered_map<long long, pair<int, int>>& mp, long long val, int pivot, bool is_right) {
        if (is_right) {
            return mp[val].second >= pivot;
        } else {
            return mp[val].first < pivot;
        }
    }

    int waysToPartition(vector<int>& nums, int k) {
        unordered_map<long long, pair<int, int>> mp, count;

        for (int i = 0; i < nums.size(); i++) {
            if (mp.find(nums[i]) == mp.end()) {
                mp[nums[i]] = {i, i};
            } else {
                mp[nums[i]].second = i;
            }
        }

        long long total_sum = getSum(nums);
        long long left_sum = nums[0];
        int result = 0;

        for (int i = 1; i < nums.size(); i++) {
            long long right_sum = total_sum - left_sum;

            if (left_sum == right_sum) {
                result++;
            } else {
                long long diff = left_sum - right_sum;

                long long num = k - diff;

                if (mp.find(num) != mp.end()) {
                    if (check(mp, num, i, true)) {
                        count[num].second++;
                    }
                }

                diff = right_sum - left_sum;
                num = k - diff;

                if (mp.find(num) != mp.end()) {
                    if (check(mp, num, i, false)) {
                        count[num].first++;
                    }
                }
            }

            left_sum += nums[i];

            count[nums[i]] = {max(count[nums[i]].first, count[nums[i]].second), 0};
        }

        int max_count = INT_MIN;
        for (auto& [num, pair_count] : count) {
            max_count = max(max_count, max(pair_count.first, pair_count.second));
        }

        return max(max_count, result);
    }
};
"
861,cpp,maximum-number-of-ways-to-partition-an-array,"class Solution {
public:
     long long int getSum(vector<int> &nums){
        long long int temp = 0;
        for(auto &i : nums) temp += i-1;
        return temp;
    }

    bool check(unordered_map<long long int, pair<int, int>> &mp, long long int val, int pivot, bool flag){
        
        if(flag){
            if(mp[val].second >= pivot) return true;
            return false;
        }

        else{
            if(mp[val].first < pivot) return true;
            return false;
        }
    }

    int waysToPartition(vector<int>& nums, int k) {
        unordered_map<long long int, pair<int, int>> mp;
        unordered_map<long long int, pair<int, int>> count;

        for(int i=0; i<nums.size(); i++){
            if(mp.find(nums[i]) == mp.end()){
                mp[nums[i]].first = i;
            }
            mp[nums[i]].second = i;
        }

        long long int totSum = getSum(nums);
        long long int left = nums[0];
        int ans = 0;

        for(int i=1; i<nums.size(); i++){
            long long int right = totSum - left;

            if(left == right){
                ans++;
            }
            else{
                long long int diff = left - right;

                long long int num = k - diff;

                if(mp.find(num) != mp.end()){
                    if(check(mp, num, i, 1)){

                        count[num].second++;
                    }
                }

                diff = right - left;
                num = k - diff;

                if(mp.find(num) != mp.end()){
                    if(check(mp, num, i, 0)){

                        count[num].first++; 
                    }
                }
            }

            left += nums[i];

            count[nums[i]].first = max(count[nums[i]].first, count[nums[i]].second);
        }

        int maxi = INT_MIN;
        for(auto [i,j] : count){
            maxi = max(maxi, max(j.first, j.second));
        }

        return max(maxi, ans);
    }
};",None,"class Solution {
public:
    long long int getSum(vector<int> &nums){
        long long int temp = 0;
        for(auto &i : nums) temp += i;
        return temp;
    }

    bool check(unordered_map<long long int, pair<int, int>> &mp, long long int val, int pivot, bool flag){
        
        if(flag){
            if(mp[val].second >= pivot) return true;
            return false;
        }

        else{
            if(mp[val].first < pivot) return true;
            return false;
        }
    }

    int waysToPartition(vector<int>& nums, int k) {
        unordered_map<long long int, pair<int, int>> mp;
        unordered_map<long long int, pair<int, int>> count;

        for(int i=0; i<nums.size(); i++){
            if(mp.find(nums[i]) == mp.end()){
                mp[nums[i]] = {i, i};
            }
            else{
                mp[nums[i]].second = i;
            }
        }

        long long int totSum = getSum(nums);
        long long int left = nums[0];
        int ans = 0;

        for(int i=1; i<nums.size(); i++){
            long long int right = totSum - left - nums[i];

            if(left == right){
                ans++;
            }
            else{
                long long int diff = left - right;

                long long int num = k - diff;

                if(mp.find(num) != mp.end()){
                    if(check(mp, num, i, 1)){

                        count[num].second++;
                    }
                }

                diff = right - left;
                num = k - diff;

                if(mp.find(num) != mp.end()){
                    if(check(mp, num, i, 0)){

                        count[num].first++; 
                    }
                }
            }

            left += nums[i];

            count[nums[i]] = {max(count[nums[i]].first, count[nums[i]].second), count[nums[i]].first};
        }

        int maxi = INT_MIN;
        for(auto [i,j] : count){
            maxi = max(maxi, max(j.first, j.second));
        }

        return max(maxi, ans);
    }
};
"
862,cpp,shortest-cycle-in-a-graph,"class Solution {
public:
    int f(int ind, unordered_map<int, vector<pair<int, int>>> &mp, int a, int b)
    {
        queue<pair<int, int>> q;
        unordered_map<int, int> vis;
        q.push({a, 0});
        vis[a]=1;
        while(!q.empty())
        {
            int curr = q.front().first;
            int dis = q.front().second;
            q.pop();
            for(auto &x: mp[curr])
            {
                if(x.second==ind || vis[x.first]==1)
                    continue;
                if(x.first == b)
                    return dis;
                q.push({x.first, dis+1});
                vis[x.first]=1;
            }
        }
        return 10000;
    }
    int findShortestCycle(int n, vector<vector<int>>& edges) {
        unordered_map<int, vector<pair<int, int>>> mp;
        for(int i=0; i<edges.size(); i++)
        {
            mp[edges[i][0]].push_back({edges[i][1], i});
            mp[edges[i][1]].push_back({edges[i][0], i});
        }
        int mn = 10000;
        for(int i=0; i<edges.size(); i++)
            mn = min(mn, f(i, mp, edges[i][0], edges[i][1]));
        if(mn>=10000)
            return -1;
        return mn+1;
    }
};",None,"class Solution {
public:
    int f(int ind, unordered_map<int, vector<pair<int, int>>> &mp, int a, int b)
    {
        queue<pair<int, int>> q;
        unordered_map<int, bool> vis;
        q.push({a, 0});
        vis[a]=true;
        while(!q.empty())
        {
            int curr = q.front().first;
            int dis = q.front().second;
            q.pop();
            for(auto &x: mp[curr])
            {
                if(x.second==ind || vis[x.first])
                    continue;
                if(x.first == b)
                    return dis;
                q.push({x.first, dis+1});
                vis[x.first]=true;
            }
        }
        return 10000;
    }
    int findShortestCycle(int n, vector<vector<int>>& edges) {
        unordered_map<int, vector<pair<int, int>>> mp;
        for(int i=0; i<edges.size(); i++)
        {
            mp[edges[i][0]].push_back({edges[i][1], i});
            mp[edges[i][1]].push_back({edges[i][0], i});
        }
        int mn = 10000;
        for(int i=0; i<edges.size(); i++)
            mn = min(mn, f(i, mp, edges[i][0], edges[i][1]));
        if(mn>=10000)
            return -1;
        return mn+1;
    }
};
"
862,cpp,shortest-cycle-in-a-graph,"class Solution {
public:
    int f(int ind, unordered_map<int, vector<pair<int, int>>> &mp, int a, int b)
    {
        queue<pair<int, int>> q;
        unordered_map<int, int> vis;
        q.push({a, 0});
        vis[a]=1;
        while(!q.empty())
        {
            int curr = q.front().first;
            int dis = q.front().second;
            q.pop();
            for(auto &x: mp[curr])
            {
                if(x.second==ind || vis[x.first]==1)
                    continue;
                if(x.first == b)
                    return dis;
                q.push({x.first, dis+1});
                vis[x.first]=1;
            }
        }
        return 10000;
    }
    int findShortestCycle(int n, vector<vector<int>>& edges) {
        unordered_map<int, vector<pair<int, int>>> mp;
        for(int i=0; i<edges.size(); i++)
        {
            mp[edges[i][0]].push_back({edges[i][1], i});
            mp[edges[i][1]].push_back({edges[i][0], i});
        }
        int mn = 10000;
        for(int i=0; i<edges.size(); i++)
            mn = min(mn, f(i, mp, edges[i][0], edges[i][1]));
        if(mn>=10000)
            return -1;
        return mn+1;
    }
};",None,"class Solution {
public:
    int f(int ind, unordered_map<int, vector<pair<int, int>>> &mp, int a, int b)
    {
        queue<pair<int, int>> q;
        unordered_map<int, bool> vis;
        q.push({a, 0});
        vis[a]=true;
        while(!q.empty())
        {
            int curr = q.front().first;
            int dis = q.front().second;
            q.pop();
            for(auto &x: mp[curr])
            {
                if(x.second==ind || vis[x.first])
                    continue;
                if(x.first == b)
                    return dis;
                q.push({x.first, dis+1});
                vis[x.first]=true;
            }
        }
        return 10000;
    }
    int findShortestCycle(int n, vector<vector<int>>& edges) {
        unordered_map<int, vector<pair<int, int>>> mp;
        for(int i=0; i<edges.size(); i++)
        {
            mp[edges[i][0]].push_back({edges[i][1], i});
            mp[edges[i][1]].push_back({edges[i][0], i});
        }
        int mn = 10000;
        for(int i=0; i<edges.size(); i++)
            mn = min(mn, f(i, mp, edges[i][0], edges[i][1]));
        if(mn>=10000)
            return -1;
        return mn+1;
    }
};
"
862,cpp,shortest-cycle-in-a-graph,"class Solution {
public:
    int f(int ind, unordered_map<int, vector<pair<int, int>>> &mp, int a, int b)
    {
        queue<pair<int, int>> q;
        unordered_map<int, int> vis;
        q.push({a, 0});
        vis[a]=1;
        while(!q.empty())
        {
            int curr = q.front().first;
            int dis = q.front().second;
            q.pop();
            for(auto &x: mp[curr])
            {
                if(x.second==ind || vis[x.first]==1)
                    continue;
                if(x.first == b)
                    return dis;
                q.push({x.first, dis+1});
                vis[x.first]=1;
            }
        }
        return 10000;
    }
    int findShortestCycle(int n, vector<vector<int>>& edges) {
        unordered_map<int, vector<pair<int, int>>> mp;
        for(int i=0; i<edges.size(); i++)
        {
            mp[edges[i][0]].push_back({edges[i][1], i});
            mp[edges[i][1]].push_back({edges[i][0], i});
        }
        int mn = 10000;
        for(int i=0; i<edges.size(); i++)
            mn = min(mn, f(i, mp, edges[i][0], edges[i][1]));
        if(mn>=10000)
            return -1;
        return mn+1;
    }
};",None,"class Solution {
public:
    int f(int ind, unordered_map<int, vector<pair<int, int>>> &mp, int a, int b)
    {
        queue<pair<int, int>> q;
        unordered_map<int, bool> vis;
        q.push({a, 0});
        vis[a]=true;
        while(!q.empty())
        {
            int curr = q.front().first;
            int dis = q.front().second;
            q.pop();
            for(auto &x: mp[curr])
            {
                if(x.second==ind || vis[x.first])
                    continue;
                if(x.first == b)
                    return dis;
                q.push({x.first, dis+1});
                vis[x.first]=true;
            }
        }
        return 10000;
    }
    int findShortestCycle(int n, vector<vector<int>>& edges) {
        unordered_map<int, vector<pair<int, int>>> mp;
        for(int i=0; i<edges.size(); i++)
        {
            mp[edges[i][0]].push_back({edges[i][1], i});
            mp[edges[i][1]].push_back({edges[i][0], i});
        }
        int mn = 10000;
        for(int i=0; i<edges.size(); i++)
            mn = min(mn, f(i, mp, edges[i][0], edges[i][1]));
        if(mn>=10000)
            return -1;
        return mn+1;
    }
};
"
863,cpp,average-salary-excluding-the-minimum-and-maximum-salary,"class Solution {
public:
    double average(vector<int>& salary) {
        int n=salary.size(),sum=0,Min=INT_MAX,Max=INT_MIN;
        for(int i:salary){
            Max = Max < i ? i : 0 ;
            Min = Min > i ? i : Min ;
            sum += i;
        }
        sum -= (Min + Max);
        return sum/(n-2.0);
    }
};",None,"class Solution {
public:
    double average(vector<int>& salary) {
        int n=salary.size(),sum=0,Min=INT_MAX,Max=INT_MIN;
        for(int i:salary){
            Min = min(Min, i);
            Max = max(Max, i);
            sum += i;
        }
        sum -= (Min + Max);
        return sum/(double)(n-2);
    }
};
"
863,cpp,average-salary-excluding-the-minimum-and-maximum-salary,"class Solution {
public:
    double average(vector<int>& salary) {
        int n=salary.size(),sum=0,Min=INT_MAX,Max=INT_MIN;
        for(int i:salary){
            Max = Max < i ? i : 0 ;
            Min = Min > i ? i : Min ;
            sum += i;
        }
        sum -= (Min + Max);
        return sum/(n-2.0);
    }
};",None,"class Solution {
public:
    double average(vector<int>& salary) {
        int n=salary.size(),sum=0,Min=INT_MAX,Max=INT_MIN;
        for(int i:salary){
            Min = min(Min, i);
            Max = max(Max, i);
            sum += i;
        }
        sum -= (Min + Max);
        return sum/(double)(n-2);
    }
};
"
863,cpp,average-salary-excluding-the-minimum-and-maximum-salary,"class Solution {
public:
    double average(vector<int>& salary) {
        int n=salary.size(),sum=0,Min=INT_MAX,Max=INT_MIN;
        for(int i:salary){
            Max = Max < i ? i : 0 ;
            Min = Min > i ? i : Min ;
            sum += i;
        }
        sum -= (Min + Max);
        return sum/(n-2.0);
    }
};",None,"class Solution {
public:
    double average(vector<int>& salary) {
        int n=salary.size(),sum=0,Min=INT_MAX,Max=INT_MIN;
        for(int i:salary){
            Min = min(Min, i);
            Max = max(Max, i);
            sum += i;
        }
        sum -= (Min + Max);
        return sum/(double)(n-2);
    }
};
"
864,cpp,01-matrix,"class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int n=mat.size();
        int m=mat[0].size();
        vector<vector<int>>dp(n,vector<int>(m,INT_MAX-2));
        for (int i=0;i<n;i++){
            for (int j=0;j<m;j++){
                if (mat[i][j]==0) dp[i][j]=0;
                else {
                    if (i>0) dp[i][j]= min (dp[i][j], dp[i-1][j]+1);
                    if (j>0) dp[i][j]=min (dp[i][j],dp[i][j-1]+1);
                }
            }
        }

        for (int i=n-1;i>=0;i--){
            for (int j=m-1;j>=0;j--){
                if (mat[i][j]==0) dp[i][j]=INT_MAX-1;
                else {
                    if (i<n-1) dp[i][j]= min (dp[i][j], dp[i+1][j]+1);
                    if (j<m-1) dp[i][j]=min (dp[i][j],dp[i][j+1]+1);
                }
            }
        }
        return dp;
    }
};",None,"class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int n=mat.size();
        int m=mat[0].size();
        vector<vector<int>>dp(n,vector<int>(m,INT_MAX));
        for (int i=0;i<n;i++){
            for (int j=0;j<m;j++){
                if (mat[i][j]==0) dp[i][j]=0;
                else {
                    if (i>0) dp[i][j]= min (dp[i][j], dp[i-1][j]+1);
                    if (j>0) dp[i][j]=min (dp[i][j],dp[i][j-1]+1);
                }
            }
        }

        for (int i=n-1;i>=0;i--){
            for (int j=m-1;j>=0;j--){
                if (mat[i][j]==0) continue;
                else {
                    if (i<n-1) dp[i][j]= min (dp[i][j], dp[i+1][j]+1);
                    if (j<m-1) dp[i][j]=min (dp[i][j],dp[i][j+1]+1);
                }
            }
        }
        return dp;
    }
};
"
864,cpp,01-matrix,"class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int n=mat.size();
        int m=mat[0].size();
        vector<vector<int>>dp(n,vector<int>(m,INT_MAX-2));
        for (int i=0;i<n;i++){
            for (int j=0;j<m;j++){
                if (mat[i][j]==0) dp[i][j]=0;
                else {
                    if (i>0) dp[i][j]= min (dp[i][j], dp[i-1][j]+1);
                    if (j>0) dp[i][j]=min (dp[i][j],dp[i][j-1]+1);
                }
            }
        }

        for (int i=n-1;i>=0;i--){
            for (int j=m-1;j>=0;j--){
                if (mat[i][j]==0) dp[i][j]=INT_MAX-1;
                else {
                    if (i<n-1) dp[i][j]= min (dp[i][j], dp[i+1][j]+1);
                    if (j<m-1) dp[i][j]=min (dp[i][j],dp[i][j+1]+1);
                }
            }
        }
        return dp;
    }
};",None,"class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int n=mat.size();
        int m=mat[0].size();
        vector<vector<int>>dp(n,vector<int>(m,INT_MAX));
        for (int i=0;i<n;i++){
            for (int j=0;j<m;j++){
                if (mat[i][j]==0) dp[i][j]=0;
                else {
                    if (i>0) dp[i][j]= min (dp[i][j], dp[i-1][j]+1);
                    if (j>0) dp[i][j]=min (dp[i][j],dp[i][j-1]+1);
                }
            }
        }

        for (int i=n-1;i>=0;i--){
            for (int j=m-1;j>=0;j--){
                if (mat[i][j]==0) continue;
                else {
                    if (i<n-1) dp[i][j]= min (dp[i][j], dp[i+1][j]+1);
                    if (j<m-1) dp[i][j]=min (dp[i][j],dp[i][j+1]+1);
                }
            }
        }
        return dp;
    }
};
"
864,cpp,01-matrix,"class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int n=mat.size();
        int m=mat[0].size();
        vector<vector<int>>dp(n,vector<int>(m,INT_MAX-2));
        for (int i=0;i<n;i++){
            for (int j=0;j<m;j++){
                if (mat[i][j]==0) dp[i][j]=0;
                else {
                    if (i>0) dp[i][j]= min (dp[i][j], dp[i-1][j]+1);
                    if (j>0) dp[i][j]=min (dp[i][j],dp[i][j-1]+1);
                }
            }
        }

        for (int i=n-1;i>=0;i--){
            for (int j=m-1;j>=0;j--){
                if (mat[i][j]==0) dp[i][j]=INT_MAX-1;
                else {
                    if (i<n-1) dp[i][j]= min (dp[i][j], dp[i+1][j]+1);
                    if (j<m-1) dp[i][j]=min (dp[i][j],dp[i][j+1]+1);
                }
            }
        }
        return dp;
    }
};",None,"class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int n=mat.size();
        int m=mat[0].size();
        vector<vector<int>>dp(n,vector<int>(m,INT_MAX));
        for (int i=0;i<n;i++){
            for (int j=0;j<m;j++){
                if (mat[i][j]==0) dp[i][j]=0;
                else {
                    if (i>0) dp[i][j]= min (dp[i][j], dp[i-1][j]+1);
                    if (j>0) dp[i][j]=min (dp[i][j],dp[i][j-1]+1);
                }
            }
        }

        for (int i=n-1;i>=0;i--){
            for (int j=m-1;j>=0;j--){
                if (mat[i][j]==0) continue;
                else {
                    if (i<n-1) dp[i][j]= min (dp[i][j], dp[i+1][j]+1);
                    if (j<m-1) dp[i][j]=min (dp[i][j],dp[i][j+1]+1);
                }
            }
        }
        return dp;
    }
};
"
865,cpp,find-the-winner-of-the-circular-game,"class Solution {
public:
    int findTheWinner(int n, int k) {
        vector<int> v;
        for (int i=1; i<=n; i++)v.push_back(i);
        int i=0;
        while (v.size() != 1){
            i= (i+k)%(v.size());
            v.erase(v.begin()+i);
        }
        return v[0];
    }
};",None,"class Solution {
public:
    int findTheWinner(int n, int k) {
        vector<int> v(n);
        iota(v.begin(), v.end(), 1);
        int i = 0;
        while (v.size() != 1) {
            i = (i + k) % v.size();
            v.erase(v.begin() + i);
        }
        return v[0];
    }
};
"
865,cpp,find-the-winner-of-the-circular-game,"class Solution {
public:
    int findTheWinner(int n, int k) {
        vector<int> v;
        for (int i=1; i<=n; i++)v.push_back(i);
        int i=0;
        while (v.size() != 1){
            i= (i+k)%(v.size());
            v.erase(v.begin()+i);
        }
        return v[0];
    }
};",None,"class Solution {
public:
    int findTheWinner(int n, int k) {
        vector<int> v;
        for (int i=0; i<n; i++)v.push_back(i+1);
        int i=0;
        while (v.size() != 1){
            i=(i+k-1)%v.size();
            v.erase(v.begin()+i);
        }
        return v[0];
    }
};
"
865,cpp,find-the-winner-of-the-circular-game,"class Solution {
public:
    int findTheWinner(int n, int k) {
        vector<int> v;
        for (int i=1; i<=n; i++)v.push_back(i);
        int i=0;
        while (v.size() != 1){
            i= (i+k)%(v.size());
            v.erase(v.begin()+i);
        }
        return v[0];
    }
};",None,"class Solution {
public:
    int findTheWinner(int n, int k) {
        vector<int> v;
        for (int i=1; i<=n; i++)v.push_back(i);
        int i=0;
        while (v.size() > 1){
            i= (i+k-1)%v.size();
            v.erase(v.begin()+i);
        }
        return v[0];
    }
};
"
866,cpp,length-of-the-longest-valid-substring,"class Solution {
public:
    int longestValidSubstring(string word, vector<string>& forbidden) {
        vector<int> ends(word.size() , -1);
        unordered_map<string, int> forbidden_word;
        for(auto it : forbidden) forbidden_word[it] = 1;
        int n = word.size();
        for(int i = 0; i<n; i++){
            string temp = """";
            for(int j = i; j<i+10 && j<n; j++){
                temp += word[j];
                if(forbidden_word.find(temp) != forbidden_word.end()) {
                    ends[j] = i;
                }
            }
        }
        
        int i = 0, j = 0;
        int ans = INT_MIN;
        while(j < n){
            
            if(ends[j] != -1){
                int st = ends[j];
                if(st < i){
                    ans = max(ans, j-i+1);
                }
                else{
                    i = st+1;
                    ans = max(ans, j-i);
                }
            }
            else ans = max(ans,j-i+1);
            j++;
        }
        return ans;
    }
};",None,"class Solution {
public:
    int longestValidSubstring(string word, vector<string>& forbidden) {
        vector<int> ends(word.size() , -1);
        unordered_map<string, int> forbidden_word;
        for(auto it : forbidden) forbidden_word[it] = 1;
        int n = word.size();
        for(int i = 0; i<n; i++){
            string temp = """";
            for(int j = i; j<i+10 && j<n; j++){
                temp += word[j];
                if(forbidden_word.find(temp) != forbidden_word.end()) {
                    ends[j] = i;
                    break;
                }
            }
        }
        
        int i = 0, j = 0;
        int ans = 0;
        while(j < n){
            
            if(ends[j] != -1){
                int st = ends[j];
                if(st < i){
                    ans = max(ans, j-i+1);
                }
                else{
                    i = st+1;
                    ans = max(ans, j-i+1);
                }
            }
            else ans = max(ans,j-i+1);
            j++;
        }
        return ans;
    }
};
"
866,cpp,length-of-the-longest-valid-substring,"class Solution {
public:
    int longestValidSubstring(string word, vector<string>& forbidden) {
        vector<int> ends(word.size() , -1);
        unordered_map<string, int> forbidden_word;
        for(auto it : forbidden) forbidden_word[it] = 1;
        int n = word.size();
        for(int i = 0; i<n; i++){
            string temp = """";
            for(int j = i; j<i+10 && j<n; j++){
                temp += word[j];
                if(forbidden_word.find(temp) != forbidden_word.end()) {
                    ends[j] = i;
                }
            }
        }
        
        int i = 0, j = 0;
        int ans = INT_MIN;
        while(j < n){
            
            if(ends[j] != -1){
                int st = ends[j];
                if(st < i){
                    ans = max(ans, j-i+1);
                }
                else{
                    i = st+1;
                    ans = max(ans, j-i);
                }
            }
            else ans = max(ans,j-i+1);
            j++;
        }
        return ans;
    }
};",None,"class Solution {
public:
    int longestValidSubstring(string word, vector<string>& forbidden) {
        vector<int> ends(word.size() , -1);
        unordered_map<string, int> forbidden_word;
        for(auto it : forbidden) forbidden_word[it] = 1;
        int n = word.size();
        for(int i = 0; i<n; i++){
            string temp = """";
            for(int j = i; j<i+10 && j<n; j++){
                temp += word[j];
                if(forbidden_word.find(temp) != forbidden_word.end()) {
                    ends[j] = i;
                    break;
                }
            }
        }
        
        int i = 0, j = 0;
        int ans = INT_MIN;
        while(j < n){
            
            if(ends[j] != -1){
                int st = ends[j];
                if(st < i){
                    ans = max(ans, j-i+1);
                }
                else{
                    i = st+1;
                    ans = max(ans, j-i+1);
                }
            }
            else ans = max(ans,j-i+1);
            j++;
        }
        return ans;
    }
};
"
866,cpp,length-of-the-longest-valid-substring,"class Solution {
public:
    int longestValidSubstring(string word, vector<string>& forbidden) {
        vector<int> ends(word.size() , -1);
        unordered_map<string, int> forbidden_word;
        for(auto it : forbidden) forbidden_word[it] = 1;
        int n = word.size();
        for(int i = 0; i<n; i++){
            string temp = """";
            for(int j = i; j<i+10 && j<n; j++){
                temp += word[j];
                if(forbidden_word.find(temp) != forbidden_word.end()) {
                    ends[j] = i;
                }
            }
        }
        
        int i = 0, j = 0;
        int ans = INT_MIN;
        while(j < n){
            
            if(ends[j] != -1){
                int st = ends[j];
                if(st < i){
                    ans = max(ans, j-i+1);
                }
                else{
                    i = st+1;
                    ans = max(ans, j-i);
                }
            }
            else ans = max(ans,j-i+1);
            j++;
        }
        return ans;
    }
};",None,"class Solution {
public:
    int longestValidSubstring(string word, vector<string>& forbidden) {
        vector<int> ends(word.size() , -1);
        unordered_map<string, int> forbidden_word;
        for(auto it : forbidden) forbidden_word[it] = 1;
        int n = word.size();
        for(int i = 0; i<n; i++){
            string temp = """";
            for(int j = i; j<i+10 && j<n; j++){
                temp += word[j];
                if(forbidden_word.find(temp) != forbidden_word.end()) {
                    ends[j] = i;
                    break;
                }
            }
        }
        
        int i = 0, j = 0;
        int ans = 0;
        while(j < n){
            
            if(ends[j] != -1){
                int st = ends[j];
                if(st < i){
                    ans = max(ans, j-i);
                }
                else{
                    i = st+1;
                    ans = max(ans, j-i+1);
                }
            }
            else ans = max(ans,j-i+1);
            j++;
        }
        return ans;
    }
};
"
867,cpp,maximum-strictly-increasing-cells-in-a-matrix,"class Solution {
public:
    int maxIncreasingCells(vector<vector<int>>& mat) {
        int n = mat.size(), m = mat[0].size();
        vector<int> row_max(n), col_max(m);
        
        map<int, vector<pair<int, int>>, greater<int>> pos;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                pos[mat[i][j]].push_back({i, j});
            }
        }
        
        int ans = 0;
        for (auto& [num, cells]: pos) {
            int k = cells.size();
            vector<int> next(k);
            for (int i = 0; i < k; ++i) {
                int r = cells[i].first, c = cells[i].second;
                next[i] = min(row_max[r], col_max[c]) + 1;
                ans = max(ans, next[i]);
            }
            for (int i = 0; i < k; ++i) {
                int r = cells[i].first, c = cells[i].second;
                row_max[r] = max(row_max[r], next[i]);
                col_max[c] = max(col_max[c], next[i]);
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    int maxIncreasingCells(vector<vector<int>>& mat) {
        int n = mat.size(), m = mat[0].size();
        vector<int> row_max(n), col_max(m);
        
        map<int, vector<pair<int, int>>, greater<int>> pos;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                pos[mat[i][j]].push_back({i, j});
            }
        }
        
        int ans = 0;
        for (auto& [num, cells]: pos) {
            int k = cells.size();
            vector<int> next(k);
            for (int i = 0; i < k; ++i) {
                int r = cells[i].first, c = cells[i].second;
                next[i] = min(row_max[r], col_max[c]) + 1;
                ans = max(ans, next[i]);
            }
            for (int i = 0; i < k; ++i) {
                int r = cells[i].first, c = cells[i].second;
                row_max[r] = max(row_max[r], next[i]);
                col_max[c] = max(col_max[c], next[i]);
            }
        }
        return ans;
    }
};
"
867,cpp,maximum-strictly-increasing-cells-in-a-matrix,"class Solution {
public:
    int maxIncreasingCells(vector<vector<int>>& mat) {
        int n = mat.size(), m = mat[0].size();
        vector<int> row_max(n), col_max(m);
        
        map<int, vector<pair<int, int>>, greater<int>> pos;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                pos[mat[i][j]].push_back({i, j});
            }
        }
        
        int ans = 0;
        for (auto& [num, cells]: pos) {
            int k = cells.size();
            vector<int> next(k);
            for (int i = 0; i < k; ++i) {
                int r = cells[i].first, c = cells[i].second;
                next[i] = min(row_max[r], col_max[c]) + 1;
                ans = max(ans, next[i]);
            }
            for (int i = 0; i < k; ++i) {
                int r = cells[i].first, c = cells[i].second;
                row_max[r] = max(row_max[r], next[i]);
                col_max[c] = max(col_max[c], next[i]);
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    int maxIncreasingCells(vector<vector<int>>& mat) {
        int n = mat.size(), m = mat[0].size();
        vector<int> row_max(n), col_max(m);
        
        map<int, vector<pair<int, int>>, greater<int>> pos;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                pos[mat[i][j]].push_back({i, j});
            }
        }
        
        int ans = 0;
        for (auto& [num, cells]: pos) {
            int k = cells.size();
            vector<int> next(k);
            for (int i = 0; i < k; ++i) {
                int r = cells[i].first, c = cells[i].second;
                next[i] = min(row_max[r], col_max[c]) + 1;
                ans = max(ans, next[i]);
            }
            for (int i = 0; i < k; ++i) {
                int r = cells[i].first, c = cells[i].second;
                row_max[r] = max(row_max[r], next[i]);
                col_max[c] = max(col_max[c], next[i]);
            }
        }
        return ans;
    }
};
"
867,cpp,maximum-strictly-increasing-cells-in-a-matrix,"class Solution {
public:
    int maxIncreasingCells(vector<vector<int>>& mat) {
        int n = mat.size(), m = mat[0].size();
        vector<int> row_max(n), col_max(m);
        
        map<int, vector<pair<int, int>>, greater<int>> pos;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                pos[mat[i][j]].push_back({i, j});
            }
        }
        
        int ans = 0;
        for (auto& [num, cells]: pos) {
            int k = cells.size();
            vector<int> next(k);
            for (int i = 0; i < k; ++i) {
                int r = cells[i].first, c = cells[i].second;
                next[i] = min(row_max[r], col_max[c]) + 1;
                ans = max(ans, next[i]);
            }
            for (int i = 0; i < k; ++i) {
                int r = cells[i].first, c = cells[i].second;
                row_max[r] = max(row_max[r], next[i]);
                col_max[c] = max(col_max[c], next[i]);
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    int maxIncreasingCells(vector<vector<int>>& mat) {
        int n = mat.size(), m = mat[0].size();
        vector<int> row_max(n), col_max(m);
        
        map<int, vector<pair<int, int>>, greater<int>> pos;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                pos[mat[i][j]].push_back({i, j});
            }
        }
        
        int ans = 0;
        for (auto& [num, cells]: pos) {
            int k = cells.size();
            vector<int> next(k);
            for (int i = 0; i < k; ++i) {
                int r = cells[i].first, c = cells[i].second;
                next[i] = min(row_max[r], col_max[c]) + 1;
                ans = max(ans, next[i]);
            }
            for (int i = 0; i < k; ++i) {
                int r = cells[i].first, c = cells[i].second;
                row_max[r] = max(row_max[r], next[i]);
                col_max[c] = max(col_max[c], next[i]);
            }
        }
        return ans;
    }
};
"
868,cpp,find-the-minimum-and-maximum-number-of-nodes-between-critical-points,"class Solution {
public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        vector<int> ans={-1,-1};
        ListNode* prev=head;
        if(!prev) return ans;
        ListNode* curr=prev->next;
        if(!curr) return ans;
        ListNode* next=curr->next;
        if(!next) return ans;

        int first=-1;
        int last=-1;
        int mind=INT_MAX;
        int i=1;
        while(next){
            bool iscp=((curr->val>prev->val && curr->val>next->val)||(curr->val<prev->val&&curr->val<next->val))?true:false;
            if(iscp&&first==-1){
                first=i;
                last=i;
            }
            else if(iscp){
                mind=min(mind,i-last);
                last=i;
            }
            i++;
            prev=curr;
            curr=next;
            next=next->next;
        }
        if(first==last)
         return ans;
         else
         {
             ans[0]=mind;
             ans[1]=last+first;
         }
         return ans;
    }
};",None,"class Solution {
public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        vector<int> ans={-1,-1};
        ListNode* prev=head;
        if(!prev) return ans;
        ListNode* curr=prev->next;
        if(!curr) return ans;
        ListNode* next=curr->next;
        if(!next) return ans;

        int first=-1;
        int last=-1;
        int mind=INT_MAX;
        int i=1;
        while(next){
            bool iscp=((curr->val>prev->val && curr->val>next->val)||(curr->val<prev->val&&curr->val<next->val))?true:false;
            if(iscp){
                if(first==-1){
                    first=i;
                }
                last=i;
            }
            if(iscp && first!=-1){
                mind=min(mind,i-last);
            }
            i++;
            prev=curr;
            curr=next;
            next=next->next;
        }
        if(first==-1)
         return ans;
         else
         {
             ans[0]=mind;
             ans[1]=last-first;
         }
         return ans;
    }
};
"
868,cpp,find-the-minimum-and-maximum-number-of-nodes-between-critical-points,"class Solution {
public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        vector<int> ans={-1,-1};
        ListNode* prev=head;
        if(!prev) return ans;
        ListNode* curr=prev->next;
        if(!curr) return ans;
        ListNode* next=curr->next;
        if(!next) return ans;

        int first=-1;
        int last=-1;
        int mind=INT_MAX;
        int i=1;
        while(next){
            bool iscp=((curr->val>prev->val && curr->val>next->val)||(curr->val<prev->val&&curr->val<next->val))?true:false;
            if(iscp&&first==-1){
                first=i;
                last=i;
            }
            else if(iscp){
                mind=min(mind,i-last);
                last=i;
            }
            i++;
            prev=curr;
            curr=next;
            next=next->next;
        }
        if(first==last)
         return ans;
         else
         {
             ans[0]=mind;
             ans[1]=last+first;
         }
         return ans;
    }
};",None,"class Solution {
public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        vector<int> ans={-1,-1};
        ListNode* prev=head;
        if(!prev) return ans;
        ListNode* curr=prev->next;
        if(!curr) return ans;
        ListNode* next=curr->next;
        if(!next) return ans;

        int first=-1;
        int last=-1;
        int mind=INT_MAX;
        int i=1;
        while(next){
            bool iscp=((curr->val>prev->val && curr->val>next->val)||(curr->val<prev->val&&curr->val<next->val))?true:false;
            if(iscp&&first==-1){
                first=i;
                last=i;
            }
            else if(iscp){
                mind=min(mind,i-last);
                last=i;
            }
            if(iscp && next->next==NULL){
                ans[0]=mind;
                ans[1]=last-first;
            }
            i++;
            prev=curr;
            curr=next;
            next=next->next;
        }
        return ans;
    }
};
"
868,cpp,find-the-minimum-and-maximum-number-of-nodes-between-critical-points,"class Solution {
public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        vector<int> ans={-1,-1};
        ListNode* prev=head;
        if(!prev) return ans;
        ListNode* curr=prev->next;
        if(!curr) return ans;
        ListNode* next=curr->next;
        if(!next) return ans;

        int first=-1;
        int last=-1;
        int mind=INT_MAX;
        int i=1;
        while(next){
            bool iscp=((curr->val>prev->val && curr->val>next->val)||(curr->val<prev->val&&curr->val<next->val))?true:false;
            if(iscp&&first==-1){
                first=i;
                last=i;
            }
            else if(iscp){
                mind=min(mind,i-last);
                last=i;
            }
            i++;
            prev=curr;
            curr=next;
            next=next->next;
        }
        if(first==last)
         return ans;
         else
         {
             ans[0]=mind;
             ans[1]=last+first;
         }
         return ans;
    }
};",None,"class Solution {
public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        vector<int> ans={-1,-1};
        ListNode* prev=head;
        if(!prev) return ans;
        ListNode* curr=prev->next;
        if(!curr) return ans;
        ListNode* next=curr->next;
        if(!next) return ans;

        int first=-1;
        int last=-1;
        int mind=INT_MAX;
        int i=1;
        while(next){
            bool iscp=((curr->val>prev->val && curr->val>next->val)||(curr->val<prev->val&&curr->val<next->val))?true:false;
            if(iscp){
                if(first==-1){
                    first=i;
                }
                last=i;
            }
            if(iscp && first!=-1){
                mind=min(mind,i-last);
            }
            i++;
            prev=curr;
            curr=next;
            next=next->next;
        }
        if(first==-1)
         return ans;
         else
         {
             ans[0]=mind;
             ans[1]=last-first;
         }
         return ans;
    }
};
"
869,cpp,widest-vertical-area-between-two-points-containing-no-points,"class Solution {
public:
  int maxWidthOfVerticalArea(vector<vector<int>>& points) {
    set<int> x;
    int res = 0;
    for (auto &p : points)
        x.insert(p[0]);
    for (auto it = next(begin(x)); it != end(x); ++it)
        res = max(res, *it - *prev(it));
    return ++res;
}
};",None,"class Solution {
public:
  int maxWidthOfVerticalArea(vector<vector<int>>& points) {
    set<int> x;
    int res = 0;
    for (auto &p : points)
        x.insert(p[0]);
    for (auto it = next(begin(x)); it != end(x); ++it)
        res = max(res, *it - *prev(it));
    return res;
  }
};
"
869,cpp,widest-vertical-area-between-two-points-containing-no-points,"class Solution {
public:
  int maxWidthOfVerticalArea(vector<vector<int>>& points) {
    set<int> x;
    int res = 0;
    for (auto &p : points)
        x.insert(p[0]);
    for (auto it = next(begin(x)); it != end(x); ++it)
        res = max(res, *it - *prev(it));
    return ++res;
}
};",None,"class Solution {
public:
  int maxWidthOfVerticalArea(vector<vector<int>>& points) {
    set<int> x;
    int res = 0;
    for (auto &p : points)
        x.insert(p[0]);
    for (auto it = next(begin(x)); it != end(x); ++it)
        res = max(res, *it - *prev(it));
    return res;
  }
};
"
869,cpp,widest-vertical-area-between-two-points-containing-no-points,"class Solution {
public:
  int maxWidthOfVerticalArea(vector<vector<int>>& points) {
    set<int> x;
    int res = 0;
    for (auto &p : points)
        x.insert(p[0]);
    for (auto it = next(begin(x)); it != end(x); ++it)
        res = max(res, *it - *prev(it));
    return ++res;
}
};",None,"class Solution {
public:
  int maxWidthOfVerticalArea(vector<vector<int>>& points) {
    set<int> x;
    int res = 0;
    for (auto &p : points)
        x.insert(p[0]);
    for (auto it = next(begin(x)); it != end(x); ++it)
        res = max(res, *it - *prev(it));
    return res;
  }
};
"
870,cpp,calculate-money-in-leetcode-bank,"class Solution {
public:
    int Rem(int a)
    {
        return (a * (a+1) )/2;
    }
    int totalMoney(int n) {
        int ans = 0,dif=28;
        int a = 0;

        a = n/7;
        
        for(int i=0;i<a;i++)
        {
            ans+=dif;
            dif+=7;
        }

        int b = n%7;
        int ad = Rem(b);
        ad+= a*b;

        ans-=ad; 


        return ans;
    }
};",None,"class Solution {
public:
    int Rem(int a)
    {
        return (a * (a+1) )/2;
    }
    int totalMoney(int n) {
        int ans = 0,dif=1;
        int a = 0;

        a = n/7;
        
        for(int i=0;i<a;i++)
        {
            ans+=dif;
            dif++;
        }

        int b = n%7;
        int ad = Rem(b);
        ad+= a*(b+1);

        ans+=ad; 


        return ans;
    }
};
"
870,cpp,calculate-money-in-leetcode-bank,"class Solution {
public:
    int Rem(int a)
    {
        return (a * (a+1) )/2;
    }
    int totalMoney(int n) {
        int ans = 0,dif=28;
        int a = 0;

        a = n/7;
        
        for(int i=0;i<a;i++)
        {
            ans+=dif;
            dif+=7;
        }

        int b = n%7;
        int ad = Rem(b);
        ad+= a*b;

        ans-=ad; 


        return ans;
    }
};",None,"class Solution {
public:
    int Rem(int a)
    {
        return (a * (a+1) )/2;
    }
    int totalMoney(int n) {
        int ans = 0,dif=1;
        int a = 0;

        a = n/7;
        
        for(int i=0;i<a;i++)
        {
            ans+=dif;
            dif+=7;
        }

        int b = n%7;
        int ad = Rem(b);
        ad+= a*(b+1);

        ans+=ad; 

        return ans;
    }
};
"
870,cpp,calculate-money-in-leetcode-bank,"class Solution {
public:
    int Rem(int a)
    {
        return (a * (a+1) )/2;
    }
    int totalMoney(int n) {
        int ans = 0,dif=28;
        int a = 0;

        a = n/7;
        
        for(int i=0;i<a;i++)
        {
            ans+=dif;
            dif+=7;
        }

        int b = n%7;
        int ad = Rem(b);
        ad+= a*b;

        ans-=ad; 


        return ans;
    }
};",None,"class Solution {
public:
    int totalMoney(int n) {
        int ans = 0, day = 1;

        for(int i=0; i<n; i++) {
            if(day <= 7) {
                ans += i + 1;
            } else {
                ans += day;
            }

            if(day % 7 == 0) {
                day = 1;
            } else {
                day++;
            }
        }

        return ans;
    }
};
"
871,cpp,divide-array-in-sets-of-k-consecutive-numbers,"class Solution {
public:
    bool isPossibleDivide(vector<int>& nums, int k) {
        unordered_map<int,int> mpp;
        sort(nums.begin(), nums.end());
        if(nums.size()%k!=0){
            return false;
        }


        for(int i=0; i<nums.size(); i++){
            mpp[nums[i]]++;
        }
        for(int i=0; i<nums.size(); i++){
            if(mpp[nums[i]]<=0){
                continue;
            }
            for(int j=nums[i] ; j<nums[i]+ k - 1; j++){ 
                if(mpp[j]<=0){
                    return false;
                }
                
                    mpp[j]--;
                
            }
        }
        return true;
    }
};",None,"class Solution {
public:
    bool isPossibleDivide(vector<int>& nums, int k) {
        unordered_map<int, int> mpp;
        sort(nums.begin(), nums.end());
        if (nums.size() % k != 0) {
            return false;
        }

        for (int i = 0; i < nums.size(); i++) {
            mpp[nums[i]]++;
        }
        for (int i = 0; i < nums.size(); i++) {
            if (mpp[nums[i]] <= 0) {
                continue;
            }
            for (int j = nums[i]; j < nums[i] + k; j++) {
                if (mpp[j] <= 0) {
                    return false;
                }
                mpp[j]--;
            }
        }
        return true;
    }
};
"
871,cpp,divide-array-in-sets-of-k-consecutive-numbers,"class Solution {
public:
    bool isPossibleDivide(vector<int>& nums, int k) {
        unordered_map<int,int> mpp;
        sort(nums.begin(), nums.end());
        if(nums.size()%k!=0){
            return false;
        }


        for(int i=0; i<nums.size(); i++){
            mpp[nums[i]]++;
        }
        for(int i=0; i<nums.size(); i++){
            if(mpp[nums[i]]<=0){
                continue;
            }
            for(int j=nums[i] ; j<nums[i]+ k - 1; j++){ 
                if(mpp[j]<=0){
                    return false;
                }
                
                    mpp[j]--;
                
            }
        }
        return true;
    }
};",None,"class Solution {
public:
    bool isPossibleDivide(vector<int>& nums, int k) {
        unordered_map<int,int> mpp;
        sort(nums.begin(), nums.end());
        if(nums.size()%k!=0){
            return false;
        }

        for(int i=0; i<nums.size(); i++){
            mpp[nums[i]]++;
        }
        for(int i=0; i<nums.size(); i++){
            if(mpp[nums[i]]<=0){
                continue;
            }
            for(int j=nums[i] ; j<nums[i]+ k ; j++){ 
                if(mpp[j]<=0){
                    return false;
                }
                
                    mpp[j]--;
                
            }
        }
        return true;
    }
};
"
871,cpp,divide-array-in-sets-of-k-consecutive-numbers,"class Solution {
public:
    bool isPossibleDivide(vector<int>& nums, int k) {
        unordered_map<int,int> mpp;
        sort(nums.begin(), nums.end());
        if(nums.size()%k!=0){
            return false;
        }


        for(int i=0; i<nums.size(); i++){
            mpp[nums[i]]++;
        }
        for(int i=0; i<nums.size(); i++){
            if(mpp[nums[i]]<=0){
                continue;
            }
            for(int j=nums[i] ; j<nums[i]+ k - 1; j++){ 
                if(mpp[j]<=0){
                    return false;
                }
                
                    mpp[j]--;
                
            }
        }
        return true;
    }
};",None,"class Solution {
public:
    bool isPossibleDivide(vector<int>& nums, int k) {
        unordered_map<int,int> mpp;
        sort(nums.begin(), nums.end());
        if(nums.size()%k!=0){
            return false;
        }

        for(int i=0; i<nums.size(); i++){
            mpp[nums[i]]++;
        }
        for(int i=0; i<nums.size(); i++){
            if(mpp[nums[i]]<=0){
                continue;
            }
            for(int j=nums[i] ; j<nums[i]+ k ; j++){ 
                if(mpp[j]<=0 || nums[i] + k <= j){
                    return false;
                }
                
                    mpp[j]--;
                
            }
        }
        return true;
    }
};
"
872,cpp,my-calendar-i,"class MyCalendar {
public:
    map<int,int> m;
    MyCalendar() {
        
    }
    
    bool book(int start, int end) {
        auto p= m.upper_bound(start);
        if(p== m.end() || end <= p->second) 
        {
            m[start]=end; 
            return true;
        } 
        return false;
    }
};",None,"class MyCalendar {
public:
    map<int, int> m;
    MyCalendar() {
        
    }
    
    bool book(int start, int end) {
        auto p = m.upper_bound(start);
        if (p == m.begin() || (--p)->second < start) {
            m[start] = end;
            return true;
        }
        return false;
    }
};
"
872,cpp,my-calendar-i,"class MyCalendar {
public:
    map<int,int> m;
    MyCalendar() {
        
    }
    
    bool book(int start, int end) {
        auto p= m.upper_bound(start);
        if(p== m.end() || end <= p->second) 
        {
            m[start]=end; 
            return true;
        } 
        return false;
    }
};",None,"class MyCalendar {
public:
    map<int, int> m;
    MyCalendar() {
        
    }
    
    bool book(int start, int end) {
        auto p = m.upper_bound(start);
        if (p == m.begin() || (--p)->second < start) {
            m[start] = end;
            return true;
        }
        return false;
    }
};
"
872,cpp,my-calendar-i,"class MyCalendar {
public:
    map<int,int> m;
    MyCalendar() {
        
    }
    
    bool book(int start, int end) {
        auto p= m.upper_bound(start);
        if(p== m.end() || end <= p->second) 
        {
            m[start]=end; 
            return true;
        } 
        return false;
    }
};",None,"class MyCalendar {
public:
    map<int, int> m;
    MyCalendar() {
        
    }
    
    bool book(int start, int end) {
        auto p = m.upper_bound(start);
        if (p != m.begin() && (start < (--p)->second)) {
            return false;
        }
        if (p != m.end() && (end > p->first)) {
            return false;
        }
        m[start] = end;
        return true;
    }
};
"
873,cpp,find-elements-in-a-contaminated-binary-tree,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class FindElements {
  unordered_set<int> set;
public:
    void recover(TreeNode* root, int x) {
        if (!root) return;
        root->val = x;
        set.emplace(x);
        recover(root->left, 2 * x + 1);
        recover(root->right, 2 * x + 2);
    }
    
    FindElements(TreeNode* root) {
        recover(root, 0);
    }
    
    bool find(int target) {
        return set.count(target - 1);
    }
};

/**
 * Your FindElements object will be instantiated and called as such:
 * FindElements* obj = new FindElements(root);
 * bool param_1 = obj->find(target);
 */",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class FindElements {
  unordered_set<int> set;
public:
    void recover(TreeNode* root, int x) {
        if (!root) return;
        root->val = x;
        set.insert(x);
        recover(root->left, 2 * x + 1);
        recover(root->right, 2 * x + 2);
    }
    
    FindElements(TreeNode* root) {
        recover(root, 0);
    }
    
    bool find(int target) {
        return set.find(target) != set.end();
    }
};

/**
 * Your FindElements object will be instantiated and called as such:
 * FindElements* obj = new FindElements(root);
 * bool param_1 = obj->find(target);
 */
"
873,cpp,find-elements-in-a-contaminated-binary-tree,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class FindElements {
  unordered_set<int> set;
public:
    void recover(TreeNode* root, int x) {
        if (!root) return;
        root->val = x;
        set.emplace(x);
        recover(root->left, 2 * x + 1);
        recover(root->right, 2 * x + 2);
    }
    
    FindElements(TreeNode* root) {
        recover(root, 0);
    }
    
    bool find(int target) {
        return set.count(target - 1);
    }
};

/**
 * Your FindElements object will be instantiated and called as such:
 * FindElements* obj = new FindElements(root);
 * bool param_1 = obj->find(target);
 */",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class FindElements {
  unordered_set<int> set;
public:
    void recover(TreeNode* root, int x) {
        if (!root) return;
        root->val = x;
        set.emplace(x);
        recover(root->left, 2 * x + 1);
        recover(root->right, 2 * x + 2);
    }
    
    FindElements(TreeNode* root) {
        recover(root, 0);
    }
    
    bool find(int target) {
        return set.count(target);
    }
};

/**
 * Your FindElements object will be instantiated and called as such:
 * FindElements* obj = new FindElements(root);
 * bool param_1 = obj->find(target);
 */
"
873,cpp,find-elements-in-a-contaminated-binary-tree,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class FindElements {
  unordered_set<int> set;
public:
    void recover(TreeNode* root, int x) {
        if (!root) return;
        root->val = x;
        set.emplace(x);
        recover(root->left, 2 * x + 1);
        recover(root->right, 2 * x + 2);
    }
    
    FindElements(TreeNode* root) {
        recover(root, 0);
    }
    
    bool find(int target) {
        return set.count(target - 1);
    }
};

/**
 * Your FindElements object will be instantiated and called as such:
 * FindElements* obj = new FindElements(root);
 * bool param_1 = obj->find(target);
 */",None,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class FindElements {
  unordered_set<int> set;
public:
    void recover(TreeNode* root, int x) {
        if (!root) return;
        root->val = x;
        set.emplace(x);
        recover(root->left, 2 * x + 1);
        recover(root->right, 2 * x + 2);
    }
    
    FindElements(TreeNode* root) {
        recover(root, 0);
    }
    
    bool find(int target) {
        return set.count(target); // corrected here
    }
};

/**
 * Your FindElements object will be instantiated and called as such:
 * FindElements* obj = new FindElements(root);
 * bool param_1 = obj->find(target);
 */
"
874,cpp,group-anagrams,"class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string,int> m;
        vector<vector<string>> ans;
        for(int i=0; i<strs.size(); i++) {
            string str = strs[i];
            sort(str.begin(),str.end());

            if(m.find(str) != m.end()) {
                ans[m[str]].push_back(str);
            }
            else {
                m[str] = ans.size(); 
                ans.push_back({strs[i]});
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string,vector<string>> m;
        for(int i=0; i<strs.size(); i++) {
            string str = strs[i];
            sort(str.begin(),str.end());

            m[str].push_back(strs[i]);
        }
        return vector<vector<string>>(m.begin(), m.end());
    }
};
"
874,cpp,group-anagrams,"class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string,int> m;
        vector<vector<string>> ans;
        for(int i=0; i<strs.size(); i++) {
            string str = strs[i];
            sort(str.begin(),str.end());

            if(m.find(str) != m.end()) {
                ans[m[str]].push_back(str);
            }
            else {
                m[str] = ans.size(); 
                ans.push_back({strs[i]});
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> m;
        for(int i=0; i<strs.size(); i++) {
            string str = strs[i];
            sort(str.begin(),str.end());

            m[str].push_back(strs[i]);
        }
        return vector<vector<string>>(m.begin(), m.end());
    }
};
"
874,cpp,group-anagrams,"class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string,int> m;
        vector<vector<string>> ans;
        for(int i=0; i<strs.size(); i++) {
            string str = strs[i];
            sort(str.begin(),str.end());

            if(m.find(str) != m.end()) {
                ans[m[str]].push_back(str);
            }
            else {
                m[str] = ans.size(); 
                ans.push_back({strs[i]});
            }
        }
        return ans;
    }
};",None,"class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> m;
        for(int i=0; i<strs.size(); i++) {
            string str = strs[i];
            sort(str.begin(),str.end());

            m[str].push_back(strs[i]);
        }
        return vector<vector<string>>(m.begin(), m.end());
    }
};
"
875,cpp,knight-probability-in-chessboard,"class Solution {
public:
    double f(int i,int j,int k,int n,vector<vector<vector<double>>> &dp){
        if(k==0) return 1.0;

        if(dp[i][j][k]!=-1.0) return dp[i][j][k];
        int dx[]={-2,-2,-1,1,2,2,1,-1},dy[]={-1,1,2,2,1,-1,-2,-2};
        double ans = 0.0;
        for(int t=0;t<8;t++){
            int nx=i+dx[t],ny=j+dy[t];
            if(nx>=0 && nx<n && ny>=0 && ny<n){
                ans += f(nx,ny,k-1,n,dp);
            }
        }

        return dp[i][j][k]=ans/8;
    }
    double knightProbability(int n, int k, int row, int column) {
        vector<vector<vector<double>>> dp(n,vector<vector<double>>(n,vector<double>(k+1,-1.0)));
        double ct=f(row,column,k,n,dp);
        for(int i=0;i<k;i++){
            ct = ct/8;
        }

        return ct;
    }
};",None,"class Solution {
public:
    double f(int i,int j,int k,int n){
        if(k==0) return 1.0;
        double ans = 0.0;
        for(int t=0;t<8;t++){
            int x = i + dx[t], y = j + dy[t];
            if(x >= 0 && x < n && y >= 0 && y < n) {
                ans += f(x, y, k - 1, n);
            }
        }

        return ans / 8;
    }
    double knightProbability(int n, int k, int row, int column) {
        double ct = f(row, column, k, n);

        return ct;
    }
private:
    int dx[8] = {-2, -2, -1, 1, 2, 2, 1, -1};
    int dy[8] = {-1, 1, 2, 2, 1, -1, -2, -2};
};
"
875,cpp,knight-probability-in-chessboard,"class Solution {
public:
    double f(int i,int j,int k,int n,vector<vector<vector<double>>> &dp){
        if(k==0) return 1.0;

        if(dp[i][j][k]!=-1.0) return dp[i][j][k];
        int dx[]={-2,-2,-1,1,2,2,1,-1},dy[]={-1,1,2,2,1,-1,-2,-2};
        double ans = 0.0;
        for(int t=0;t<8;t++){
            int nx=i+dx[t],ny=j+dy[t];
            if(nx>=0 && nx<n && ny>=0 && ny<n){
                ans += f(nx,ny,k-1,n,dp);
            }
        }

        return dp[i][j][k]=ans/8;
    }
    double knightProbability(int n, int k, int row, int column) {
        vector<vector<vector<double>>> dp(n,vector<vector<double>>(n,vector<double>(k+1,-1.0)));
        double ct=f(row,column,k,n,dp);
        for(int i=0;i<k;i++){
            ct = ct/8;
        }

        return ct;
    }
};",None,"class Solution {
public:
    double f(int i,int j,int k,int n){
        if(k==0) return 1.0;
        double ans = 0.0;
        for(int t=0;t<8;t++){
            int x=i+dx[t],y=j+dy[t];
            if(x>=0 && x<n && y>=0 && y<n){
                ans += f(x,y,k-1,n);
            }
        }

        return ans/8;
    }
    double knightProbability(int n, int k, int row, int column) {
        double ct=f(row,column,k,n);

        return ct;
    }
private:
    int dx[8] = {-2,-2,-1,1,2,2,1,-1};
    int dy[8] = {-1,1,2,2,1,-1,-2,-2};
};
"
875,cpp,knight-probability-in-chessboard,"class Solution {
public:
    double f(int i,int j,int k,int n,vector<vector<vector<double>>> &dp){
        if(k==0) return 1.0;

        if(dp[i][j][k]!=-1.0) return dp[i][j][k];
        int dx[]={-2,-2,-1,1,2,2,1,-1},dy[]={-1,1,2,2,1,-1,-2,-2};
        double ans = 0.0;
        for(int t=0;t<8;t++){
            int nx=i+dx[t],ny=j+dy[t];
            if(nx>=0 && nx<n && ny>=0 && ny<n){
                ans += f(nx,ny,k-1,n,dp);
            }
        }

        return dp[i][j][k]=ans/8;
    }
    double knightProbability(int n, int k, int row, int column) {
        vector<vector<vector<double>>> dp(n,vector<vector<double>>(n,vector<double>(k+1,-1.0)));
        double ct=f(row,column,k,n,dp);
        for(int i=0;i<k;i++){
            ct = ct/8;
        }

        return ct;
    }
};",None,"class Solution {
public:
    double f(int i,int j,int k,int n){
        if(k==0) return 1.0;
        double ans = 0.0;
        for(int t=0;t<8;t++){
            int x = i + dx[t], y = j + dy[t];
            if(x >= 0 && x < n && y >= 0 && y < n)
                ans += f(x, y, k - 1, n);
        }

        return ans / 8;
    }
    double knightProbability(int n, int k, int row, int column) {
        double ct = f(row, column, k, n);
        for(int i = 1; i < k; i++)
            ct /= 8;

        return ct;
    }
private:
    int dx[8] = {-2,-2,-1,1,2,2,1,-1};
    int dy[8] = {-1,1,2,2,1,-1,-2,-2};
};
"
876,cpp,neighboring-bitwise-xor,"class Solution {
public:
    bool doesValidArrayExist(vector<int>& derived) {
        int xoor = 0;
        for (auto i: derived) xoor += i;
        return !xoor;
    }
};",None,"class Solution {
public:
    bool doesValidArrayExist(vector<int>& derived) {
        int n = derived.size();
        if (n == 1) return derived[0] == 0;

        int xor1 = derived[0] ^ derived[n-1];
        for (int i = 1; i < n-1; i++) {
            int xor2 = derived[i] ^ xor1;
            if (xor2 != derived[i]) return false;
        }
        return true;
    }
};
"
876,cpp,neighboring-bitwise-xor,"class Solution {
public:
    bool doesValidArrayExist(vector<int>& derived) {
        int xoor = 0;
        for (auto i: derived) xoor += i;
        return !xoor;
    }
};",None,"class Solution {
public:
    bool doesValidArrayExist(vector<int>& derived) {
        int n = derived.size();
        if (n == 1) {
            return derived[0] == 0;
        }
        int xorVal = derived[0] ^ derived[n - 1];
        for (int i = 1; i < n - 1; i++) {
            if ((derived[i] ^ derived[i - 1]) != xorVal) {
                return false;
            }
        }
        return true;
    }
};
"
876,cpp,neighboring-bitwise-xor,"class Solution {
public:
    bool doesValidArrayExist(vector<int>& derived) {
        int xoor = 0;
        for (auto i: derived) xoor += i;
        return !xoor;
    }
};",None,"class Solution {
public:
    bool doesValidArrayExist(vector<int>& derived) {
        int n = derived.size();
        int xorFirstLast = derived[0] ^ derived[n - 1];

        for (int i = 1; i < n - 1; i++) {
            if ((derived[i] ^ derived[i - 1]) != derived[i] && (derived[i] ^ derived[i + 1]) != derived[i]) {
                return false;
            }
        }

        return xorFirstLast == 0;
    }
};
"
877,cpp,maximize-grid-happiness,"class Solution {
public:
   int dp[25][7][7][64][64] = {};
int nCost(int m, int n, int i, int j, int mask_in, int mask_ex, int d) {
    int diff = 0, up = (1 << (n - 1));
    if (j > 0 && (mask_in & 1))
        diff += d - 30;
    if (i > 0 && (mask_in & up))
        diff += d - 30;
    if (j > 0 && (mask_ex & 1))
        diff += d + 20;
    if (i > 0 && (mask_ex & up))
        diff += d + 20;
    return diff;
}
int dfs(int m, int n, int p, int in, int ex, int mask_in, int mask_ex) {
    int i = p / n, j = p % n;
    if (i >= m)
        return 0;
    if (dp[p][in][ex][mask_in][mask_ex])
        return dp[p][in][ex][mask_in][mask_ex] - 1;
    int n_mask_in = (mask_in << 1) & 63, n_mask_ex = (mask_ex << 1) & 63;
    int res = dfs(m, n, p + 1, in, ex, n_mask_in, n_mask_ex);
    if (in > 0) {
        int diff = 120 + nCost(m, n, i, j, mask_in, mask_ex, -30);
        res = max(res, diff + dfs(m, n, p + 1, in - 1, ex, n_mask_in + 1, n_mask_ex));
    }
    if (ex > 0) {
        int diff = 40 + nCost(m, n, i, j, mask_in, mask_ex, +30);
        res = max(res, diff + dfs(m, n, p + 1, in, ex - 1, n_mask_in, n_mask_ex + 1));
    }
    dp[p][in][ex][mask_in][mask_ex] = res + 1;
    return res;
}
int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {
    return dfs(m, n, 0, introvertsCount, extrovertsCount, 0, 0);
}
};",None,M
877,cpp,maximize-grid-happiness,"class Solution {
public:
   int dp[25][7][7][64][64] = {};
int nCost(int m, int n, int i, int j, int mask_in, int mask_ex, int d) {
    int diff = 0, up = (1 << (n - 1));
    if (j > 0 && (mask_in & 1))
        diff += d - 30;
    if (i > 0 && (mask_in & up))
        diff += d - 30;
    if (j > 0 && (mask_ex & 1))
        diff += d + 20;
    if (i > 0 && (mask_ex & up))
        diff += d + 20;
    return diff;
}
int dfs(int m, int n, int p, int in, int ex, int mask_in, int mask_ex) {
    int i = p / n, j = p % n;
    if (i >= m)
        return 0;
    if (dp[p][in][ex][mask_in][mask_ex])
        return dp[p][in][ex][mask_in][mask_ex] - 1;
    int n_mask_in = (mask_in << 1) & 63, n_mask_ex = (mask_ex << 1) & 63;
    int res = dfs(m, n, p + 1, in, ex, n_mask_in, n_mask_ex);
    if (in > 0) {
        int diff = 120 + nCost(m, n, i, j, mask_in, mask_ex, -30);
        res = max(res, diff + dfs(m, n, p + 1, in - 1, ex, n_mask_in + 1, n_mask_ex));
    }
    if (ex > 0) {
        int diff = 40 + nCost(m, n, i, j, mask_in, mask_ex, +30);
        res = max(res, diff + dfs(m, n, p + 1, in, ex - 1, n_mask_in, n_mask_ex + 1));
    }
    dp[p][in][ex][mask_in][mask_ex] = res + 1;
    return res;
}
int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {
    return dfs(m, n, 0, introvertsCount, extrovertsCount, 0, 0);
}
};",None,"class Solution {
public:
   int dp[25][7][7][64][64][64] = {};
int nCost(int m, int n, int i, int j, int mask_in, int mask_ex, int d) {
    int diff = 0, up = (1 << (n - 1));
    if (j > 0 && (mask_in & 1))
        diff += d - 30;
    if (i > 0 && (mask_in & up))
        diff += d - 30;
    if (j > 0 && (mask_ex & 1))
        diff += d + 20;
    if (i > 0 && (mask_ex & up))
        diff += d + 20;
    return diff;
}
int dfs(int m, int n, int p, int in, int ex, int mask_in, int mask_ex, int prev_mask_in, int prev_mask_ex) {
    int i = p / n, j = p % n;
    if (i >= m)
        return 0;
    if (dp[p][in][ex][mask_in][mask_ex][prev_mask_in + prev_mask_ex])
        return dp[p][in][ex][mask_in][mask_ex][prev_mask_in + prev_mask_ex] - 1;
    int n_mask_in = (mask_in << 1) & 63, n_mask_ex = (mask_ex << 1) & 63;
    int res = dfs(m, n, p + 1, in, ex, n_mask_in, n_mask_ex, prev_mask_in, prev_mask_ex);
    if (in > 0) {
        int diff = 120 + nCost(m, n, i, j, mask_in, mask_ex, -30);
        res = max(res, diff + dfs(m, n, p + 1, in - 1, ex, n_mask_in + 1, n_mask_ex, prev_mask_in, prev_mask_ex));
    }
    if (ex > 0) {
        int diff = 40 + nCost(m, n, i, j, mask_in, mask_ex, +30);
        res = max(res, diff + dfs(m, n, p + 1, in, ex - 1, n_mask_in, n_mask_ex + 1, prev_mask_in, prev_mask_ex));
    }
    dp[p][in][ex][mask_in][mask_ex][prev_mask_in + prev_mask_ex] = res + 1;
    return res;
}
int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {
    return dfs(m, n, 0, introvertsCount, extrovertsCount, 0, 0, 0, 0);
}
};
"
877,cpp,maximize-grid-happiness,"class Solution {
public:
   int dp[25][7][7][64][64] = {};
int nCost(int m, int n, int i, int j, int mask_in, int mask_ex, int d) {
    int diff = 0, up = (1 << (n - 1));
    if (j > 0 && (mask_in & 1))
        diff += d - 30;
    if (i > 0 && (mask_in & up))
        diff += d - 30;
    if (j > 0 && (mask_ex & 1))
        diff += d + 20;
    if (i > 0 && (mask_ex & up))
        diff += d + 20;
    return diff;
}
int dfs(int m, int n, int p, int in, int ex, int mask_in, int mask_ex) {
    int i = p / n, j = p % n;
    if (i >= m)
        return 0;
    if (dp[p][in][ex][mask_in][mask_ex])
        return dp[p][in][ex][mask_in][mask_ex] - 1;
    int n_mask_in = (mask_in << 1) & 63, n_mask_ex = (mask_ex << 1) & 63;
    int res = dfs(m, n, p + 1, in, ex, n_mask_in, n_mask_ex);
    if (in > 0) {
        int diff = 120 + nCost(m, n, i, j, mask_in, mask_ex, -30);
        res = max(res, diff + dfs(m, n, p + 1, in - 1, ex, n_mask_in + 1, n_mask_ex));
    }
    if (ex > 0) {
        int diff = 40 + nCost(m, n, i, j, mask_in, mask_ex, +30);
        res = max(res, diff + dfs(m, n, p + 1, in, ex - 1, n_mask_in, n_mask_ex + 1));
    }
    dp[p][in][ex][mask_in][mask_ex] = res + 1;
    return res;
}
int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {
    return dfs(m, n, 0, introvertsCount, extrovertsCount, 0, 0);
}
};",None,"class Solution {
public:
    const int INT_MAX_VALUE = 2147483647;
    const int INT_MIN_VALUE = -2147483647;

    int dp[25][7][7][64][64] = {};

    int nCost(int m, int n, int i, int j, int mask_in, int mask_ex, int d) {
        int diff = 0, up = (1 << (n - 1));
        if (j > 0 && (mask_in & 1))
            diff += d - 30;
        if (i > 0 && (mask_in & up))
            diff += d - 30;
        if (j > 0 && (mask_ex & 1))
            diff += d + 20;
        if (i > 0 && (mask_ex & up))
            diff += d + 20;
        return diff;
    }

    int dfs(int m, int n, int p, int in, int ex, int mask_in, int mask_ex) {
        int i = p / n, j = p % n;
        if (i >= m)
            return 0;
        if (dp[p][in][ex][mask_in][mask_ex])
            return dp[p][in][ex][mask_in][mask_ex] - 1;

        int res = dfs(m, n, p + 1, in, ex, mask_in << 1, mask_ex << 1);

        if (in > 0) {
            int diff = 120 + nCost(m, n, i, j, mask_in, mask_ex, -30);
            if (diff > INT_MAX_VALUE || diff < INT_MIN_VALUE)
                return INT_MIN_VALUE;
            res = max(res, diff + dfs(m, n, p + 1, in - 1, ex, (mask_in << 1) | 1, mask_ex << 1));
        }

        if (ex > 0) {
            int diff = 40 + nCost(m, n, i, j, mask_in, mask_ex, +30);
            if (diff > INT_MAX_VALUE || diff < INT_MIN_VALUE)
                return INT_MIN_VALUE;
            res = max(res, diff + dfs(m, n, p + 1, in, ex - 1, mask_in << 1, (mask_ex << 1) | 1));
        }

        dp[p][in][ex][mask_in][mask_ex] = res + 1;
        return res;
    }

    int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {
        if (m <= 0 || n <= 0 || introvertsCount < 0 || extrovertsCount < 0 ||
            introvertsCount > m * n || extrovertsCount > m * n) {
            return INT_MIN_VALUE;
        }
        return dfs(m, n, 0, introvertsCount, extrovertsCount, 0, 0);
    }
};
"
1160,cpp,detect-cycles-in-2d-grid,"class Solution {
public:
   vector<int> dir = { 0, 1, 0, -1, 0 }; 
    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)
    {
        visited[i][j] = false;
        for(int d = 0; d < 4; ++d)
        {
            int a = i+dir[d];
            int b = j+dir[d+1];
            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))
                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))
                    return true;
        }
        return false;
    }
    bool containsCycle(vector<vector<char>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> visited(n, vector<bool>(m, false));
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < m; ++j)
                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))
                    return true;
        return false;
    }
};",None,"class Solution {
public:
   vector<int> dir = { 0, 1, 0, -1, 0 }; 
    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)
    {
        visited[i][j] = false;
        for(int d = 0; d < 4; ++d)
        {
            int a = i+dir[d];
            int b = j+dir[d+1];
            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))
                if(visited[a][b])
                    return true;
        }
        return false;
    }
    bool containsCycle(vector<vector<char>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> visited(n, vector<bool>(m, true));
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < m; ++j)
                if(isCyclic(grid, visited, i, j, -1, -1))
                    return true;
        return false;
    }
};
"
1160,cpp,detect-cycles-in-2d-grid,"class Solution {
public:
   vector<int> dir = { 0, 1, 0, -1, 0 }; 
    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)
    {
        visited[i][j] = false;
        for(int d = 0; d < 4; ++d)
        {
            int a = i+dir[d];
            int b = j+dir[d+1];
            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))
                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))
                    return true;
        }
        return false;
    }
    bool containsCycle(vector<vector<char>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> visited(n, vector<bool>(m, false));
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < m; ++j)
                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))
                    return true;
        return false;
    }
};",None,"class Solution {
public:
   vector<int> dir = { 0, 1, 0, -1, 0 }; 
    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)
    {
        visited[i][j] = false;
        for(int d = 0; d < 4; ++d)
        {
            int a = i+dir[d];
            int b = j+dir[d+1];
            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))
                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))
                    return true;
        }
        visited[i][j] = true; //mark the current cell as visited before returning
        return false;
    }
    bool containsCycle(vector<vector<char>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> visited(n, vector<bool>(m, false));
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < m; ++j)
                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))
                    return true;
        return false;
    }
};
"
1160,cpp,detect-cycles-in-2d-grid,"class Solution {
public:
   vector<int> dir = { 0, 1, 0, -1, 0 }; 
    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)
    {
        visited[i][j] = false;
        for(int d = 0; d < 4; ++d)
        {
            int a = i+dir[d];
            int b = j+dir[d+1];
            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))
                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))
                    return true;
        }
        return false;
    }
    bool containsCycle(vector<vector<char>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> visited(n, vector<bool>(m, false));
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < m; ++j)
                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))
                    return true;
        return false;
    }
};",None,"class Solution {
public:
   vector<int> dir = { 0, 1, 0, -1, 0 }; 
    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)
    {
        visited[i][j] = false;
        for(int d = 0; d < 4; ++d)
        {
            int a = i+dir[d];
            int b = j+dir[d+1];
            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))
                if(visited[a][b])
                    return true;
        }
        return false;
    }
    bool containsCycle(vector<vector<char>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> visited(n, vector<bool>(m, true)); // Initialize all cells to true
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < m; ++j)
                if(isCyclic(grid, visited, i, j, -1, -1))
                    return true;
        return false;
    }
};
"
1161,cpp,a-number-after-a-double-reversal,"class Solution {
public:
    bool isSameAfterReversals(int num) {
        string ans=to_string(num);
        reverse(ans.begin(), ans.end());
        int ab=stoi(ans);
        string ans2=to_string(ab);
        
        reverse(ans.begin(), ans.end());
        int ba=stoi(ans2);
        if(ba==num) return true;
        return false;
    }
};",None,"class Solution {
public:
    bool isSameAfterReversals(int num) {
        int reversed1 = reverseInt(num);
        int reversed2 = reverseInt(reversed1);
        return reversed2 == num;
    }

private:
    int reverseInt(int num) {
        string numStr = to_string(num);
        reverse(numStr.begin(), numStr.end());
        return stoi(numStr);
    }
};
"
1161,cpp,a-number-after-a-double-reversal,"class Solution {
public:
    bool isSameAfterReversals(int num) {
        string ans=to_string(num);
        reverse(ans.begin(), ans.end());
        int ab=stoi(ans);
        string ans2=to_string(ab);
        
        reverse(ans.begin(), ans.end());
        int ba=stoi(ans2);
        if(ba==num) return true;
        return false;
    }
};",None,"class Solution {
public:
    bool isSameAfterReversals(int num) {
        string ans=to_string(num);
        reverse(ans.begin(), ans.end());
        int reversed1 = stoi(ans);

        reverse(ans.begin(), ans.end());
        int reversed2 = stoi(ans);

        return reversed2 == num;
    }
};
"
1161,cpp,a-number-after-a-double-reversal,"class Solution {
public:
    bool isSameAfterReversals(int num) {
        string ans=to_string(num);
        reverse(ans.begin(), ans.end());
        int ab=stoi(ans);
        string ans2=to_string(ab);
        
        reverse(ans.begin(), ans.end());
        int ba=stoi(ans2);
        if(ba==num) return true;
        return false;
    }
};",None,"class Solution {
public:
    bool isSameAfterReversals(int num) {
        string str = to_string(num);
        reverse(str.begin(), str.end());
        int reversed1 = stoi(str);
        reverse(str.begin(), str.end());
        int reversed2 = stoi(str);
        return reversed2 == num;
    }
};
"
1162,cpp,maximum-rows-covered-by-columns,"class Solution {
public:
    vector<vector<int>>comb;
    
    int find(vector<vector<int>>& mat1)
    {
        int c = 0;
        for(int i = 0; i < mat1.size(); i++)
        {
            int flg = 0;
            for(int j = 0; j < mat1[0].size(); j++)
                if(mat1[i][j] == 1)
                    flg = 1;
            if(flg == 0)
                c++;
        }
        return c;
    }
    
    
    int find_ans(vector<vector<int>>& mat)
    {
        int ans = 0;
        for(int i = 0; i < comb.size(); i++)
        {
            vector<int>temp = comb[i];
            vector<vector<int>> mat1 = mat;
            for(int j = 0; j < temp.size(); j++)
            {
                int col_val = temp[j];
                for(int k = 0; k < mat1.size(); k++)
                    mat1[k][col_val] = 1;
            }
            ans = max(ans, find(mat1));
        }
        return ans;
    }
    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)
    {
        int col = mat[0].size();
        if(count == cols)
        {
            comb.push_back(tans);
            return;
        }
        if(idx >= col)
            return;
        
        helper(mat, cols, count, idx+1, tans);
        tans.push_back(idx);
        helper(mat, cols, count+1, idx+1, tans);
    }
    
    int maximumRows(vector<vector<int>>& mat, int cols) {
        
        vector<int>tans;
        helper(mat, cols, 0, 0, tans);
        return find_ans(mat);
    }
};",None,"class Solution {
public:
    vector<vector<int>> combinations;

    int countRowsWithNoOnes(vector<vector<int>>& matrix, vector<int>& selectedColumns) {
        int count = 0;
        for (int i = 0; i < matrix.size(); i++) {
            bool rowHasOnes = false;
            for (int j = 0; j < matrix[i].size(); j++) {
                if (matrix[i][j] == 1 && find(selectedColumns, j) == -1) {
                    rowHasOnes = true;
                    break;
                }
            }
            if (!rowHasOnes) {
                count++;
            }
        }
        return count;
    }

    int find(vector<int>& arr, int target) {
        for (int i = 0; i < arr.size(); i++) {
            if (arr[i] == target) {
                return i;
            }
        }
        return -1;
    }

    void generateCombinations(vector<vector<int>>& matrix, int numColumns, int index, vector<int>& currentCombination) {
        if (currentCombination.size() == numColumns) {
            combinations.push_back(currentCombination);
            return;
        }

        if (index == matrix[0].size()) {
            return;
        }

        // Include the current column
        currentCombination.push_back(index);
        generateCombinations(matrix, numColumns, index + 1, currentCombination);
        currentCombination.pop_back();

        // Exclude the current column
        generateCombinations(matrix, numColumns, index + 1, currentCombination);
    }

    int maximumRows(vector<vector<int>>& matrix, int numSelect) {
        int m = matrix.size();
        int n = matrix[0].size();

        generateCombinations(matrix, numSelect, 0, {});

        int maxCount = 0;
        for (const auto& combination : combinations) {
            int count = countRowsWithNoOnes(matrix, combination);
            maxCount = max(maxCount, count);
        }

        return maxCount;
    }
};
"
1162,cpp,maximum-rows-covered-by-columns,"class Solution {
public:
    vector<vector<int>>comb;
    
    int find(vector<vector<int>>& mat1)
    {
        int c = 0;
        for(int i = 0; i < mat1.size(); i++)
        {
            int flg = 0;
            for(int j = 0; j < mat1[0].size(); j++)
                if(mat1[i][j] == 1)
                    flg = 1;
            if(flg == 0)
                c++;
        }
        return c;
    }
    
    
    int find_ans(vector<vector<int>>& mat)
    {
        int ans = 0;
        for(int i = 0; i < comb.size(); i++)
        {
            vector<int>temp = comb[i];
            vector<vector<int>> mat1 = mat;
            for(int j = 0; j < temp.size(); j++)
            {
                int col_val = temp[j];
                for(int k = 0; k < mat1.size(); k++)
                    mat1[k][col_val] = 1;
            }
            ans = max(ans, find(mat1));
        }
        return ans;
    }
    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)
    {
        int col = mat[0].size();
        if(count == cols)
        {
            comb.push_back(tans);
            return;
        }
        if(idx >= col)
            return;
        
        helper(mat, cols, count, idx+1, tans);
        tans.push_back(idx);
        helper(mat, cols, count+1, idx+1, tans);
    }
    
    int maximumRows(vector<vector<int>>& mat, int cols) {
        
        vector<int>tans;
        helper(mat, cols, 0, 0, tans);
        return find_ans(mat);
    }
};",None,"class Solution {
public:
    int maximumRows(vector<vector<int>>& mat, int cols) {
        int m = mat.size(), n = mat[0].size();
        vector<bool> selected(n, false);
        function<int(int)> dfs = [&](int idx) -> int {
            if (idx == m) return 0;
            int res = 0;
            for (int i = 0; i < n; i++) {
                if (!selected[i] && mat[idx][i] == 1) {
                    selected[i] = true;
                    res = max(res, 1 + dfs(idx + 1));
                    selected[i] = false;
                }
            }
            if (!res) res = dfs(idx + 1);
            return res;
        };
        for (int i = 0; i < cols; i++) {
            int max_val = -1;
            int idx = -1;
            for (int j = 0; j < n; j++) {
                if (!selected[j] && mat[0][j] == 1) {
                    if (mat[1][j] > max_val) {
                        max_val = mat[1][j];
                        idx = j;
                    }
                }
            }
            selected[idx] = true;
        }
        return dfs(1);
    }
};
"
1162,cpp,maximum-rows-covered-by-columns,"class Solution {
public:
    vector<vector<int>>comb;
    
    int find(vector<vector<int>>& mat1)
    {
        int c = 0;
        for(int i = 0; i < mat1.size(); i++)
        {
            int flg = 0;
            for(int j = 0; j < mat1[0].size(); j++)
                if(mat1[i][j] == 1)
                    flg = 1;
            if(flg == 0)
                c++;
        }
        return c;
    }
    
    
    int find_ans(vector<vector<int>>& mat)
    {
        int ans = 0;
        for(int i = 0; i < comb.size(); i++)
        {
            vector<int>temp = comb[i];
            vector<vector<int>> mat1 = mat;
            for(int j = 0; j < temp.size(); j++)
            {
                int col_val = temp[j];
                for(int k = 0; k < mat1.size(); k++)
                    mat1[k][col_val] = 1;
            }
            ans = max(ans, find(mat1));
        }
        return ans;
    }
    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)
    {
        int col = mat[0].size();
        if(count == cols)
        {
            comb.push_back(tans);
            return;
        }
        if(idx >= col)
            return;
        
        helper(mat, cols, count, idx+1, tans);
        tans.push_back(idx);
        helper(mat, cols, count+1, idx+1, tans);
    }
    
    int maximumRows(vector<vector<int>>& mat, int cols) {
        
        vector<int>tans;
        helper(mat, cols, 0, 0, tans);
        return find_ans(mat);
    }
};",None,"class Solution {
public:
    vector<vector<int>>comb;
    
    int find(vector<vector<int>>& mat1)
    {
        int c = 0;
        for(int i = 0; i < mat1.size(); i++)
        {
            int flg = 0;
            for(int j = 0; j < mat1[0].size(); j++)
                if(mat1[i][j] == 1)
                    flg = 1;
            if(flg == 0)
                c++;
        }
        return c;
    }
    
    
    int find_ans(vector<vector<int>>& mat)
    {
        int ans = 0;
        for(int i = 0; i < comb.size(); i++)
        {
            vector<int>temp = comb[i];
            vector<vector<int>> mat1 = mat;
            for(int j = 0; j < temp.size(); j++)
            {
                int col_val = temp[j];
                for(int k = 0; k < mat1.size(); k++)
                    mat1[k][col_val] = 1;
            }
            ans = max(ans, find(mat1));
        }
        return ans;
    }
    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>& tans)
    {
        int col = mat[0].size();
        if(count == cols)
        {
            comb.push_back(tans);
            return;
        }
        if(idx >= col)
            return;
        
        helper(mat, cols, count, idx+1, tans);
        tans.push_back(idx);
        helper(mat, cols, count+1, idx+1, tans);
        tans.pop_back();
    }
    
    int maximumRows(vector<vector<int>>& mat, int cols) {
        
        vector<int>tans;
        helper(mat, cols, 0, 0, tans);
        return find_ans(mat);
    }
};
"
1163,cpp,check-if-there-is-a-valid-path-in-a-grid,"class DisjointSet{
public:
    vector<int>par,size;
    DisjointSet(int n){
        par.resize(n+1);
        size.resize(n+1,1);
        for(int i=0; i<=n; i++){
            par[i] = i;
        }
    }
    int findpar(int u){
        if(u == par[u]) return u;
        return par[u] = findpar(par[u]);
    }

    void unionBySize(int u, int v){
        u = findpar(u);
        v = findpar(v);

        if(u == v) return;

        if(size[u] >= size[v]){
            par[v] = v;
            size[u] += size[v];
        }
        else{
            par[u] = u;
            size[v] += size[u];
        }
    }
    
};
class Solution {
public:
    bool hasValidPath(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        DisjointSet ds(n*m);
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                int p = i * m + j;
                int p1 = (i-1)*m + j;
                int p2 = (i+1)*m + j;
                int p3 = i*m + (j+1);
                int p4 = i*m + (j-1);

                if(grid[i][j] == 1){
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                }
                else if(grid[i][j] == 2){
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }

                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                }
                else if(grid[i][j] == 3){
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }
                }
                else if(grid[i][j] == 4){
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }
                }
                else if(grid[i][j] == 5){
                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                }
                else if(grid[i][j] == 6){
                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                }
            }
        }
        return ds.findpar(0) == ds.findpar(n*m-1);
    }
};",None,"class DisjointSet {
public:
    vector<int> par, size;
    DisjointSet(int n) {
        par.resize(n + 1);
        size.resize(n + 1, 1);
        for (int i = 0; i <= n; i++) {
            par[i] = i;
        }
    }
    int findpar(int u) {
        if (u == par[u])
            return u;
        return par[u] = findpar(par[u]);
    }

    void unionBySize(int u, int v) {
        u = findpar(u);
        v = findpar(v);

        if (u == v)
            return;

        if (size[u] >= size[v]) {
            par[v] = v;
            size[u] += size[v];
        } else {
            par[u] = u;
            size[v] += size[u];
        }
    }
};

class Solution {
public:
    bool hasValidPath(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        DisjointSet ds(n * m);

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                int p = i * m + j;
                if (i - 1 >= 0 && grid[i - 1][j] != 0) {
                    int p1 = (i - 1) * m + j;
                    if (grid[i][j] == 1 || grid[i][j] == 5) {
                        ds.unionBySize(p, p1);
                    }
                }
                if (j - 1 >= 0 && grid[i][j - 1] != 0) {
                    int p2 = i * m + (j - 1);
                    if (grid[i][j] == 1 || grid[i][j] == 4) {
                        ds.unionBySize(p, p2);
                    }
                }
                if (i + 1 < n && grid[i + 1][j] != 0) {
                    int p3 = (i + 1) * m + j;
                    if (grid[i][j] == 2 || grid[i][j] == 6) {
                        ds.unionBySize(p, p3);
                    }
                }
                if (j + 1 < m && grid[i][j + 1] != 0) {
                    int p4 = i * m + (j + 1);
                    if (grid[i][j] == 3 || grid[i][j] == 6) {
                        ds.unionBySize(p, p4);
                    }
                }
            }
        }
        return ds.findpar(0) == ds.findpar(n * m - 1);
    }
};
"
1163,cpp,check-if-there-is-a-valid-path-in-a-grid,"class DisjointSet{
public:
    vector<int>par,size;
    DisjointSet(int n){
        par.resize(n+1);
        size.resize(n+1,1);
        for(int i=0; i<=n; i++){
            par[i] = i;
        }
    }
    int findpar(int u){
        if(u == par[u]) return u;
        return par[u] = findpar(par[u]);
    }

    void unionBySize(int u, int v){
        u = findpar(u);
        v = findpar(v);

        if(u == v) return;

        if(size[u] >= size[v]){
            par[v] = v;
            size[u] += size[v];
        }
        else{
            par[u] = u;
            size[v] += size[u];
        }
    }
    
};
class Solution {
public:
    bool hasValidPath(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        DisjointSet ds(n*m);
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                int p = i * m + j;
                int p1 = (i-1)*m + j;
                int p2 = (i+1)*m + j;
                int p3 = i*m + (j+1);
                int p4 = i*m + (j-1);

                if(grid[i][j] == 1){
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                }
                else if(grid[i][j] == 2){
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }

                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                }
                else if(grid[i][j] == 3){
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }
                }
                else if(grid[i][j] == 4){
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }
                }
                else if(grid[i][j] == 5){
                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                }
                else if(grid[i][j] == 6){
                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                }
            }
        }
        return ds.findpar(0) == ds.findpar(n*m-1);
    }
};",None,"class DisjointSet{
public:
    vector<int>par,size;
    DisjointSet(int n){
        par.resize(n+1);
        size.resize(n+1,1);
        for(int i=0; i<=n; i++){
            par[i] = i;
        }
    }
    int findpar(int u){
        if(u == par[u]) return u;
        return par[u] = findpar(par[u]);
    }

    void unionBySize(int u, int v){
        u = findpar(u);
        v = findpar(v);

        if(u == v) return;

        if(size[u] >= size[v]){
            par[v] = v;
            size[u] += size[v];
        }
        else{
            par[u] = u;
            size[v] += size[u];
        }
    }
    
};
class Solution {
public:
    bool hasValidPath(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        DisjointSet ds(n*m);
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                int p = i * m + j;
                int p1 = (i-1)*m + j;
                int p2 = (i+1)*m + j;
                int p3 = i*m + (j+1);
                int p4 = i*m + (j-1);

                if(grid[i][j] == 1){
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                }
                else if(grid[i][j] == 2){
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }

                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                }
                else if(grid[i][j] == 3){
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }
                }
                else if(grid[i][j] == 4){
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }
                }
                else if(grid[i][j] == 5){
                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                }
                else if(grid[i][j] == 6){
                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                }
            }
        }
        return ds.findpar(0) == ds.findpar(n*m-1);
    }
};
"
1163,cpp,check-if-there-is-a-valid-path-in-a-grid,"class DisjointSet{
public:
    vector<int>par,size;
    DisjointSet(int n){
        par.resize(n+1);
        size.resize(n+1,1);
        for(int i=0; i<=n; i++){
            par[i] = i;
        }
    }
    int findpar(int u){
        if(u == par[u]) return u;
        return par[u] = findpar(par[u]);
    }

    void unionBySize(int u, int v){
        u = findpar(u);
        v = findpar(v);

        if(u == v) return;

        if(size[u] >= size[v]){
            par[v] = v;
            size[u] += size[v];
        }
        else{
            par[u] = u;
            size[v] += size[u];
        }
    }
    
};
class Solution {
public:
    bool hasValidPath(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        DisjointSet ds(n*m);
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                int p = i * m + j;
                int p1 = (i-1)*m + j;
                int p2 = (i+1)*m + j;
                int p3 = i*m + (j+1);
                int p4 = i*m + (j-1);

                if(grid[i][j] == 1){
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                }
                else if(grid[i][j] == 2){
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }

                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                }
                else if(grid[i][j] == 3){
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }
                }
                else if(grid[i][j] == 4){
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){
                        ds.unionBySize(p,p2);
                    }
                }
                else if(grid[i][j] == 5){
                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){
                        ds.unionBySize(p,p4);
                    }
                }
                else if(grid[i][j] == 6){
                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){
                        ds.unionBySize(p,p1);
                    }
                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){
                        ds.unionBySize(p,p3);
                    }
                }
            }
        }
        return ds.findpar(0) == ds.findpar(n*m-1);
    }
};",None,"class DisjointSet{
public:
    vector<int>par,size;
    DisjointSet(int n){
        par.resize(n+1);
        size.resize(n+1,1);
        for(int i=0; i<=n; i++){
            par[i] = i;
        }
    }
    int findpar(int u){
        if(u == par[u]) return u;
        return par[u] = findpar(par[u]);
    }

    void unionBySize(int u, int v){
        u = findpar(u);
        v = findpar(v);

        if(u == v) return;

        if(size[u] >= size[v]){
            par[v] = v;
            size[u] += size[v];
        }
        else{
            par[u] = u;
            size[v] += size[u];
        }
    }
    
};
class Solution {
public:
    bool hasValidPath(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        DisjointSet ds(n*m);
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                int p = i * m + j;
                if(i-1 >= 0 && grid[i-1][j] == 2){
                    int p1 = (i-1)*m + j;
                    ds.unionBySize(p,p1);
                }
                if(i+1 < n && grid[i+1][j] == 2){
                    int p2 = (i+1)*m + j;
                    ds.unionBySize(p,p2);
                }
                if(j-1 >= 0 && grid[i][j-1] == 1){
                    int p3 = i*m + (j-1);
                    ds.unionBySize(p,p3);
                }
                if(j+1 < m && grid[i][j+1] == 1){
                    int p4 = i*m + (j+1);
                    ds.unionBySize(p,p4);
                }
            }
        }
        return ds.findpar(0) == ds.findpar(n*m-1);
    }
};
"
1164,cpp,reverse-only-letters,"class Solution {
public:
    string reverseOnlyLetters(string s) 
    {
      int i=0,j=s.length()-1;
      while(i<=j)
      {
        if(isalpha(s[i])&&isalpha(s[j]))
        {
            swap(s[i],s[j]);
            i--;
            j++;
        }
        else
        {
            if(!isalpha(s[i]))
            {
                i++;
            }
            if(!isalpha(s[j]))
            {
                j--;
            }
        }
      }
      return s;
    }
};",None,"class Solution {
public:
    string reverseOnlyLetters(string s) 
    {
      int i=0,j=s.length()-1;
      while(i<j)
      {
        if(isalpha(s[i])&&isalpha(s[j]))
        {
            swap(s[i],s[j]);
            i++;
            j--;
        }
        else
        {
            if(!isalpha(s[i]))
            {
                i++;
            }
            if(!isalpha(s[j]))
            {
                j--;
            }
            else
            {
                j--;
            }
        }
      }
      return s;
    }
};
"
1164,cpp,reverse-only-letters,"class Solution {
public:
    string reverseOnlyLetters(string s) 
    {
      int i=0,j=s.length()-1;
      while(i<=j)
      {
        if(isalpha(s[i])&&isalpha(s[j]))
        {
            swap(s[i],s[j]);
            i--;
            j++;
        }
        else
        {
            if(!isalpha(s[i]))
            {
                i++;
            }
            if(!isalpha(s[j]))
            {
                j--;
            }
        }
      }
      return s;
    }
};",None,"class Solution {
public:
    string reverseOnlyLetters(string s) 
    {
      int i=0,j=s.length()-1;
      while(i<j)
      {
        if(isalpha(s[i])&&isalpha(s[j]))
        {
            swap(s[i],s[j]);
            i++;
            j--;
        }
        else
        {
            if(!isalpha(s[i]))
            {
                i++;
            }
            if(!isalpha(s[j]))
            {
                j--;
            }
            else
            {
                j--;
            }
        }
      }
      return s;
    }
};
"
1164,cpp,reverse-only-letters,"class Solution {
public:
    string reverseOnlyLetters(string s) 
    {
      int i=0,j=s.length()-1;
      while(i<=j)
      {
        if(isalpha(s[i])&&isalpha(s[j]))
        {
            swap(s[i],s[j]);
            i--;
            j++;
        }
        else
        {
            if(!isalpha(s[i]))
            {
                i++;
            }
            if(!isalpha(s[j]))
            {
                j--;
            }
        }
      }
      return s;
    }
};",None,"class Solution {
public:
    string reverseOnlyLetters(string s) 
    {
      int i=0,j=s.length()-1;
      while(i<j)
      {
        if(isalpha(s[i])&&isalpha(s[j]))
        {
            swap(s[i],s[j]);
            i++;
            j--;
        }
        else
        {
            if(!isalpha(s[i]))
            {
                i++;
            }
            if(!isalpha(s[j]))
            {
                j--;
            }
            else
            {
                j--;
            }
        }
      }
      return s;
    }
};
"
1165,cpp,minimum-impossible-or,"class Solution {
public:
    int minImpossibleOR(vector<int>& nums) {
        unordered_set<int> s(nums.begin(),nums.end());
        int temp=2;
        for(int i=1;i<32;i++){
            if(s.find(temp)==s.end()) return temp;
            temp=temp*2;
        }
        return temp; 
    }
};",None,"class Solution {
public:
    int minImpossibleOR(vector<int>& nums) {
        unordered_set<int> s(nums.begin(), nums.end());
        int temp = 1;
        while (s.find(temp) != s.end()) {
            temp = temp << 1 | 1;
        }
        return temp;
    }
};
"
1165,cpp,minimum-impossible-or,"class Solution {
public:
    int minImpossibleOR(vector<int>& nums) {
        unordered_set<int> s(nums.begin(),nums.end());
        int temp=2;
        for(int i=1;i<32;i++){
            if(s.find(temp)==s.end()) return temp;
            temp=temp*2;
        }
        return temp; 
    }
};",None,"class Solution {
public:
    int minImpossibleOR(vector<int>& nums) {
        unordered_set<int> s(nums.begin(),nums.end());
        int temp=1;
        while(true){
            if(s.find(temp)==s.end()) return temp;
            temp = temp << 1 | 1;
        }
        return temp;
    }
};
"
1165,cpp,minimum-impossible-or,"class Solution {
public:
    int minImpossibleOR(vector<int>& nums) {
        unordered_set<int> s(nums.begin(),nums.end());
        int temp=2;
        for(int i=1;i<32;i++){
            if(s.find(temp)==s.end()) return temp;
            temp=temp*2;
        }
        return temp; 
    }
};",None,"class Solution {
public:
    int minImpossibleOR(vector<int>& nums) {
        unordered_set<int> s(nums.begin(), nums.end());
        int temp = 1;
        while (s.find(temp) != s.end()) {
            temp = temp << 1;
        }
        return temp;
    }
};
"
1166,cpp,search-insert-position,"class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int l=0;
        int r=nums.size()-1;
        int m;
        while(l<=r){
            m=(l+r)/2;
            if(nums[m]==target){
                return m;
            }else if(nums[m]>target){
                r=m;
            }
            else{
                l=m;
            }
        }
        return l;
    }
};",None,"class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int l=0;
        int r=nums.size()-1;
        int m;
        while(l<=r){
            m=(l+r)/2;
            if(nums[m]==target){
                return m;
            }else if(nums[m]>target){
                r=m-1;
            }
            else{
                l=m+1;
            }
        }
        return l;
    }
};
"
1166,cpp,search-insert-position,"class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int l=0;
        int r=nums.size()-1;
        int m;
        while(l<=r){
            m=(l+r)/2;
            if(nums[m]==target){
                return m;
            }else if(nums[m]>target){
                r=m;
            }
            else{
                l=m;
            }
        }
        return l;
    }
};",None,"class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int l=0;
        int r=nums.size()-1;
        int m;
        while(l<=r){
            m=(l+r)/2;
            if(nums[m]==target){
                return m;
            }else if(nums[m]>target){
                r=m-1;
            }
            else{
                l=m+1;
            }
        }
        return l;
    }
};
"
1166,cpp,search-insert-position,"class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int l=0;
        int r=nums.size()-1;
        int m;
        while(l<=r){
            m=(l+r)/2;
            if(nums[m]==target){
                return m;
            }else if(nums[m]>target){
                r=m;
            }
            else{
                l=m;
            }
        }
        return l;
    }
};",None,"class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int l=0;
        int r=nums.size()-1;
        int m;
        while(l<=r){
            m=(l+r)/2;
            if(nums[m]==target){
                return m;
            }else if(nums[m]>target){
                r=m-1;
            }
            else{
                l=m+1;
            }
        }
        return l;
    }
};
"
1167,cpp,filter-restaurants-by-vegan-friendly-price-and-distance,"class Solution {
public:
    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {
        if(veganFriendly == 1){
            for(int i = 0; i<restaurants.size(); i++){
                if(restaurants[i][2] != veganFriendly){
                    restaurants[i][0] = -1;
                }
            }
        }

        for(int i = 0; i<restaurants.size(); i++){
            if(restaurants[i][3] > maxPrice || restaurants[i][4] > maxDistance){  
                restaurants[i][0]=-1;
            }
        }

        vector<int> id;
        vector<int>rating;
        for(int i=0; i<restaurants.size(); i++){
            if(restaurants[i][0]>0){
                id.push_back(restaurants[i][0]);
                rating.push_back(restaurants[i][1]);
            }
            
        }

        for(int i=0; i<rating.size(); i++){
            for(int j=i+1; j<rating.size(); j++){
                if(rating[i] < rating[j]){
                    swap(rating[i], rating[j]);
                    swap(id[i], id[j]);
                }
            }
        }

        for(int i=0; i<rating.size(); i++){
            for(int j=i+1; j<rating.size(); j++){
                if(rating[i] == rating[j] && id[i] < id[j]){
                    swap(id[i], id[j]);
                }
            }
        }

        return rating;
    }
};",None,"class Solution {
public:
    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {
        vector<vector<int>> filteredRestaurants;

        for(const auto& restaurant : restaurants) {
            if(restaurant[2] != veganFriendly) continue;
            if(restaurant[3] > maxPrice || restaurant[4] > maxDistance) continue;
            filteredRestaurants.push_back(restaurant);
        }

        vector<pair<int, int>> filteredRestaurantsWithId;

        for(const auto& restaurant : filteredRestaurants) {
            filteredRestaurantsWithId.push_back({restaurant[1], restaurant[0]});
        }

        sort(filteredRestaurantsWithId.begin(), filteredRestaurantsWithId.end(), greater<>());

        vector<int> result;

        for(const auto& [rating, id] : filteredRestaurantsWithId) {
            result.push_back(id);
        }

        return result;
    }
};
"
1167,cpp,filter-restaurants-by-vegan-friendly-price-and-distance,"class Solution {
public:
    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {
        if(veganFriendly == 1){
            for(int i = 0; i<restaurants.size(); i++){
                if(restaurants[i][2] != veganFriendly){
                    restaurants[i][0] = -1;
                }
            }
        }

        for(int i = 0; i<restaurants.size(); i++){
            if(restaurants[i][3] > maxPrice || restaurants[i][4] > maxDistance){  
                restaurants[i][0]=-1;
            }
        }

        vector<int> id;
        vector<int>rating;
        for(int i=0; i<restaurants.size(); i++){
            if(restaurants[i][0]>0){
                id.push_back(restaurants[i][0]);
                rating.push_back(restaurants[i][1]);
            }
            
        }

        for(int i=0; i<rating.size(); i++){
            for(int j=i+1; j<rating.size(); j++){
                if(rating[i] < rating[j]){
                    swap(rating[i], rating[j]);
                    swap(id[i], id[j]);
                }
            }
        }

        for(int i=0; i<rating.size(); i++){
            for(int j=i+1; j<rating.size(); j++){
                if(rating[i] == rating[j] && id[i] < id[j]){
                    swap(id[i], id[j]);
                }
            }
        }

        return rating;
    }
};",None,"class Solution {
public:
    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {
        vector<vector<int>> filteredRestaurants;

        for(int i = 0; i<restaurants.size(); i++){
            if((veganFriendly == 0 || restaurants[i][2] == veganFriendly) && restaurants[i][3] <= maxPrice && restaurants[i][4] <= maxDistance){
                filteredRestaurants.push_back(restaurants[i]);
            }
        }

        sort(filteredRestaurants.begin(), filteredRestaurants.end(), [](const vector<int>& a, const vector<int>& b){
            return (a[1] > b[1] || (a[1] == b[1] && a[0] > b[0]));
        });

        vector<int> ids;
        for(int i = 0; i<filteredRestaurants.size(); i++){
            ids.push_back(filteredRestaurants[i][0]);
        }
        return ids;
    }
};
"
1167,cpp,filter-restaurants-by-vegan-friendly-price-and-distance,"class Solution {
public:
    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {
        if(veganFriendly == 1){
            for(int i = 0; i<restaurants.size(); i++){
                if(restaurants[i][2] != veganFriendly){
                    restaurants[i][0] = -1;
                }
            }
        }

        for(int i = 0; i<restaurants.size(); i++){
            if(restaurants[i][3] > maxPrice || restaurants[i][4] > maxDistance){  
                restaurants[i][0]=-1;
            }
        }

        vector<int> id;
        vector<int>rating;
        for(int i=0; i<restaurants.size(); i++){
            if(restaurants[i][0]>0){
                id.push_back(restaurants[i][0]);
                rating.push_back(restaurants[i][1]);
            }
            
        }

        for(int i=0; i<rating.size(); i++){
            for(int j=i+1; j<rating.size(); j++){
                if(rating[i] < rating[j]){
                    swap(rating[i], rating[j]);
                    swap(id[i], id[j]);
                }
            }
        }

        for(int i=0; i<rating.size(); i++){
            for(int j=i+1; j<rating.size(); j++){
                if(rating[i] == rating[j] && id[i] < id[j]){
                    swap(id[i], id[j]);
                }
            }
        }

        return rating;
    }
};",None,"class Solution {
public:
    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {
        vector<vector<int>> filtered;
        for(auto &restaurant : restaurants) {
            if(restaurant[2] != veganFriendly) continue;
            if(restaurant[3] > maxPrice || restaurant[4] > maxDistance) continue;
            filtered.push_back(restaurant);
        }

        vector<int> result;
        sort(filtered.begin(), filtered.end(),
             [](const auto &a, const auto &b) {
                 return a[1] > b[1] || (a[1] == b[1] && a[0] > b[0]);
             });

        for(auto &restaurant : filtered) {
            result.push_back(restaurant[0]);
        }

        return result;
    }
};
"
1168,cpp,divide-players-into-teams-of-equal-skill,"class Solution {
public:
    long long dividePlayers(vector<int>& skill) {
        int n=skill.size();
        sort(skill.begin(), skill.end());
        long long ans=0;
        int low=1, high=n-1;
        int skl=skill[low]+skill[high];

        while(low<=high){
            if( (skill[low]+skill[high])!=skl) return -1;
            ans+=skill[low]*skill[high];
            low++;
            high--;
        }

        return ans;
    }
};",None,"class Solution {
public:
    long long dividePlayers(vector<int>& skill) {
        int n=skill.size();
        sort(skill.begin(), skill.end());
        long long ans=0;
        int low=0, high=n-1;
        int skl=skill[low]+skill[high];

        while(low<high){
            if( (skill[low]+skill[high])!=skl) return -1;
            ans+=skill[low]*skill[high];
            low++;
            high--;
        }

        return ans;
    }
};
"
1168,cpp,divide-players-into-teams-of-equal-skill,"class Solution {
public:
    long long dividePlayers(vector<int>& skill) {
        int n=skill.size();
        sort(skill.begin(), skill.end());
        long long ans=0;
        int low=1, high=n-1;
        int skl=skill[low]+skill[high];

        while(low<=high){
            if( (skill[low]+skill[high])!=skl) return -1;
            ans+=skill[low]*skill[high];
            low++;
            high--;
        }

        return ans;
    }
};",None,"class Solution {
public:
    long long dividePlayers(vector<int>& skill) {
        int n=skill.size();
        sort(skill.begin(), skill.end());
        long long ans=0;
        int low=0, high=n-1;
        int skl=skill[low]+skill[high];

        while(low<high){
            if( (skill[low]+skill[high])!=skl) return -1;
            ans+=skill[low]*skill[high];
            low++;
            high--;
        }

        return ans;
    }
};
"
1168,cpp,divide-players-into-teams-of-equal-skill,"class Solution {
public:
    long long dividePlayers(vector<int>& skill) {
        int n=skill.size();
        sort(skill.begin(), skill.end());
        long long ans=0;
        int low=1, high=n-1;
        int skl=skill[low]+skill[high];

        while(low<=high){
            if( (skill[low]+skill[high])!=skl) return -1;
            ans+=skill[low]*skill[high];
            low++;
            high--;
        }

        return ans;
    }
};",None,"class Solution {
public:
    long long dividePlayers(vector<int>& skill) {
        int n=skill.size();
        sort(skill.begin(), skill.end());
        long long ans=0;
        int low=0, high=n-1;
        int skl=skill[low]+skill[high];

        while(low<high){
            if( (skill[low]+skill[high])!=skl) return -1;
            ans+=skill[low]*skill[high];
            low++;
            high--;
        }

        return ans;
    }
};
"
1169,cpp,minimum-time-visiting-all-points,"#include <cstdlib>
class Solution {
public:
    int minTimeToVisitAllPoints(vector<vector<int>>& points) {
        int ans=0;
        for(int i=0;i<points.size();i++)
        {
            int temp1=points[i][0]-points[i-1][0];
            int temp2=points[i][1]-points[i-1][1];
            temp1=abs(temp1);
            temp2=abs(temp2);
            int res = max(temp1,temp2);
            cout<<res;
            ans += res;
        }
        return ans;
    }
};",None,"#include <cstdlib>
class Solution {
public:
    int minTimeToVisitAllPoints(vector<vector<int>>& points) {
        int ans=0;
        for(int i=1;i<points.size();i++)
        {
            int temp1=points[i][0]-points[i-1][0];
            int temp2=points[i][1]-points[i-1][1];
            int res = max(abs(temp1), abs(temp2));
            ans += res;
        }
        return ans;
    }
};
"
1169,cpp,minimum-time-visiting-all-points,"#include <cstdlib>
class Solution {
public:
    int minTimeToVisitAllPoints(vector<vector<int>>& points) {
        int ans=0;
        for(int i=0;i<points.size();i++)
        {
            int temp1=points[i][0]-points[i-1][0];
            int temp2=points[i][1]-points[i-1][1];
            temp1=abs(temp1);
            temp2=abs(temp2);
            int res = max(temp1,temp2);
            cout<<res;
            ans += res;
        }
        return ans;
    }
};",None,"#include <cstdlib>
class Solution {
public:
    int minTimeToVisitAllPoints(vector<vector<int>>& points) {
        int ans=0;
        for(int i=0;i<points.size();i++)
        {
            int temp1=abs(points[i][0]-points[i-1][0]);
            int temp2=abs(points[i][1]-points[i-1][1]);
            int res = max(temp1,temp2);
            ans += res;
        }
        return ans;
    }
};
"
1169,cpp,minimum-time-visiting-all-points,"#include <cstdlib>
class Solution {
public:
    int minTimeToVisitAllPoints(vector<vector<int>>& points) {
        int ans=0;
        for(int i=0;i<points.size();i++)
        {
            int temp1=points[i][0]-points[i-1][0];
            int temp2=points[i][1]-points[i-1][1];
            temp1=abs(temp1);
            temp2=abs(temp2);
            int res = max(temp1,temp2);
            cout<<res;
            ans += res;
        }
        return ans;
    }
};",None,"#include <cstdlib>
class Solution {
public:
    int minTimeToVisitAllPoints(vector<vector<int>>& points) {
        int ans=0;
        for(int i=1;i<points.size();i++)
        {
            int temp1=points[i][0]-points[i-1][0];
            int temp2=points[i][1]-points[i-1][1];
            int res = max(abs(temp1), abs(temp2));
            ans += res;
        }
        return ans;
    }
};
"
1170,cpp,distance-between-bus-stops,"class Solution {
public:
    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {
        int i, dis1=0, dis2=0, j, temp;

        if(start>destination)
        {
            temp = start;
            start = destination;
            destination = temp;
        }

        for(i=start ; i<destination ; i++)
        {
            dis1 += distance[i];
        }

        i = start;
        j = distance.size()-destination+start;
        while(j>0)
        {
            if(i<0)
            {
                dis2 += distance[distance.size()+i];
            }
            else
                dis2 += distance[i];
            i--;
            j--;
        }

        if(dis1<dis2)
            return dis1;
        return dis2;
    }
};",None,"class Solution {
public:
    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {
        int i, dis1=0, dis2=0, j, temp;

        if(start>destination)
        {
            temp = start;
            start = destination;
            destination = temp;
        }

        for(i=start ; i<destination ; i++)
        {
            dis1 += distance[i];
        }

        i = start;
        j = distance.size()-destination+start;
        while(j>0)
        {
            i = (i+1)%distance.size();
            dis2 += distance[i];
            j--;
        }

        if(dis1<dis2)
            return dis1;
        return dis2;
    }
};
"
1170,cpp,distance-between-bus-stops,"class Solution {
public:
    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {
        int i, dis1=0, dis2=0, j, temp;

        if(start>destination)
        {
            temp = start;
            start = destination;
            destination = temp;
        }

        for(i=start ; i<destination ; i++)
        {
            dis1 += distance[i];
        }

        i = start;
        j = distance.size()-destination+start;
        while(j>0)
        {
            if(i<0)
            {
                dis2 += distance[distance.size()+i];
            }
            else
                dis2 += distance[i];
            i--;
            j--;
        }

        if(dis1<dis2)
            return dis1;
        return dis2;
    }
};",None,"class Solution {
public:
    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {
        int i, dis1=0, dis2=0;

        if(start>destination)
        {
            swap(start, destination);
        }

        for(i=start ; i<destination ; i++)
        {
            dis1 += distance[i];
        }

        i = start;
        for(int j = distance.size()-destination+start; j>0; j--)
        {
            dis2 += distance[i];
            i = (i+1) % distance.size();
        }

        return min(dis1, dis2);
    }
};
"
1170,cpp,distance-between-bus-stops,"class Solution {
public:
    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {
        int i, dis1=0, dis2=0, j, temp;

        if(start>destination)
        {
            temp = start;
            start = destination;
            destination = temp;
        }

        for(i=start ; i<destination ; i++)
        {
            dis1 += distance[i];
        }

        i = start;
        j = distance.size()-destination+start;
        while(j>0)
        {
            if(i<0)
            {
                dis2 += distance[distance.size()+i];
            }
            else
                dis2 += distance[i];
            i--;
            j--;
        }

        if(dis1<dis2)
            return dis1;
        return dis2;
    }
};",None,"class Solution {
public:
    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {
        int i, dis1=0, dis2=0, j, temp;

        if(start>destination)
        {
            temp = start;
            start = destination;
            destination = temp;
        }

        for(i=start ; i<destination ; i++)
        {
            dis1 += distance[i];
        }

        i = start;
        j = distance.size()-destination+start;
        while(j>0)
        {
            i = (i+1) % distance.size();
            dis2 += distance[i];
            j--;
        }

        if(dis1<dis2)
            return dis1;
        return dis2;
    }
};
"
1171,cpp,shortest-bridge,"class Solution {
public:

int r[4] = {-1 , 0, 1, 0};
int c[4] = {0 ,1 , 0 , -1};

void dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)
{
    int n = grid[0].size();
    vis[row][col] = 1;
    v.push_back({row , col});
    for(int i=0; i<4; i++)
    {
        int nrow = row + r[i];
        int ncol = col + c[i];

        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)
        {
            dfs(nrow , ncol , v , vis , grid);
        }
    }

}

    int shortestBridge(vector<vector<int>>& grid) {
        
        vector<pair<int,int>> v;
        vector<pair<int,int>> v1;
        vector<pair<int,int>> v2;
        int n = grid.size();
        vector<vector<int>> vis(n , vector<int>(n , 0));
        bool flag = 0;
        for(int i=0; i<n; i++)
        {
            for(int j=0; j<n; j++)
            {
                if(grid[i][j] == 1 and vis[i][j] == 0)
                {
                    dfs(i , j , v , vis, grid);
                    if(flag == 0)
                    {
                        v1 = v;
                        flag = 1;
                        v.clear();
                    }
                    else
                    {
                        v2 = v;
                    }
                }
            
            }
           
        }

        int ans = 1e9;


        for(auto it: v1)
        {
            int row1 = it.first;
            int col1 = it.second;

            for(auto itt: v2)
            {
                int row2 = itt.first;
                int col2 = itt.second;

                int dist = abs(row1 - row2) + abs(col1 - col2);
                ans = min(ans , dist);
            }
        }
    
        return ans;
    }
};",None,"class Solution {
public:

int r[4] = {-1 , 0, 1, 0};
int c[4] = {0 ,1 , 0 , -1};

void dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)
{
    int n = grid.size();
    vis[row][col] = 1;
    v.push_back({row , col});
    for(int i=0; i<4; i++)
    {
        int nrow = row + r[i];
        int ncol = col + c[i];

        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)
        {
            dfs(nrow , ncol , v , vis , grid);
        }
    }

}

    int shortestBridge(vector<vector<int>>& grid) {
        
        vector<pair<int,int>> v1;
        vector<pair<int,int>> v2;
        int n = grid.size();
        vector<vector<int>> vis(n , vector<int>(n , 0));
        bool flag = 0;
        for(int i=0; i<n; i++)
        {
            for(int j=0; j<n; j++)
            {
                if(grid[i][j] == 1 and vis[i][j] == 0)
                {
                    dfs(i , j , v1 , vis, grid);
                    if(flag == 0)
                    {
                        flag = 1;
                        vis.assign(n , vector<int>(n , 0));
                    }
                    else
                    {
                        dfs(i , j , v2 , vis, grid);
                        break;
                    }
                }
            
            }
           
        }

        int ans = 1e9;


        for(int i=0; i<v1.size(); i++)
        {
            int row1 = v1[i].first;
            int col1 = v1[i].second;

            for(int j=0; j<v2.size(); j++)
            {
                int row2 = v2[j].first;
                int col2 = v2[j].second;

                int dist = abs(row1 - row2) + abs(col1 - col2);
                ans = min(ans , dist);
            }
        }
    
        return ans;
    }
};
"
1171,cpp,shortest-bridge,"class Solution {
public:

int r[4] = {-1 , 0, 1, 0};
int c[4] = {0 ,1 , 0 , -1};

void dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)
{
    int n = grid[0].size();
    vis[row][col] = 1;
    v.push_back({row , col});
    for(int i=0; i<4; i++)
    {
        int nrow = row + r[i];
        int ncol = col + c[i];

        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)
        {
            dfs(nrow , ncol , v , vis , grid);
        }
    }

}

    int shortestBridge(vector<vector<int>>& grid) {
        
        vector<pair<int,int>> v;
        vector<pair<int,int>> v1;
        vector<pair<int,int>> v2;
        int n = grid.size();
        vector<vector<int>> vis(n , vector<int>(n , 0));
        bool flag = 0;
        for(int i=0; i<n; i++)
        {
            for(int j=0; j<n; j++)
            {
                if(grid[i][j] == 1 and vis[i][j] == 0)
                {
                    dfs(i , j , v , vis, grid);
                    if(flag == 0)
                    {
                        v1 = v;
                        flag = 1;
                        v.clear();
                    }
                    else
                    {
                        v2 = v;
                    }
                }
            
            }
           
        }

        int ans = 1e9;


        for(auto it: v1)
        {
            int row1 = it.first;
            int col1 = it.second;

            for(auto itt: v2)
            {
                int row2 = itt.first;
                int col2 = itt.second;

                int dist = abs(row1 - row2) + abs(col1 - col2);
                ans = min(ans , dist);
            }
        }
    
        return ans;
    }
};",None,"class Solution {
public:

int r[4] = {-1 , 0, 1, 0};
int c[4] = {0 ,1 , 0 , -1};

void dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)
{
    int n = grid.size();
    vis[row][col] = 1;
    v.push_back({row , col});
    for(int i=0; i<4; i++)
    {
        int nrow = row + r[i];
        int ncol = col + c[i];

        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)
        {
            dfs(nrow , ncol , v , vis , grid);
        }
    }

}

    int shortestBridge(vector<vector<int>>& grid) {
        
        vector<pair<int,int>> v1;
        vector<pair<int,int>> v2;
        int n = grid.size();
        vector<vector<int>> vis(n , vector<int>(n , 0));
        bool flag = 0;
        for(int i=0; i<n; i++)
        {
            for(int j=0; j<n; j++)
            {
                if(grid[i][j] == 1 and vis[i][j] == 0)
                {
                    dfs(i , j , v1 , vis, grid);
                    if(flag == 0)
                    {
                        flag = 1;
                    }
                    else
                    {
                        bfs(v1 , v2 , grid);
                        return steps-1;
                    }
                    v1.clear();
                }
            
            }
           
        }
    
        return -1;
    }

    void bfs(vector<pair<int,int>>& v1 , vector<pair<int,int>>& v2 , vector<vector<int>>& grid)
    {
        int n = grid.size();
        vector<pair<int,int>> v;
        queue<pair<int,int>> q;
        for(auto it: v1)
        {
            q.push(it);
        }

        int steps = 0;
        while(!q.empty())
        {
            int sz = q.size();
            steps++;
            while(sz--)
            {
                auto it = q.front();
                q.pop();
                int row = it.first;
                int col = it.second;

                for(int i=0; i<4; i++)
                {
                    int nrow = row + r[i];
                    int ncol = col + c[i];

                    if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0)
                    {
                        if(grid[nrow][ncol] == 1)
                        {
                            v2 = v;
                            v.clear();
                            v.push_back(it);
                            vis[nrow][ncol] = 1;
                            q.push({nrow , ncol});
                        }
                        else
                        {
                            vis[nrow][ncol] = 1;
                            v.push_back(it);
                            q.push({nrow , ncol});
                        }
                    }
                }
            }
        }
    }
};
"
1171,cpp,shortest-bridge,"class Solution {
public:

int r[4] = {-1 , 0, 1, 0};
int c[4] = {0 ,1 , 0 , -1};

void dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)
{
    int n = grid[0].size();
    vis[row][col] = 1;
    v.push_back({row , col});
    for(int i=0; i<4; i++)
    {
        int nrow = row + r[i];
        int ncol = col + c[i];

        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)
        {
            dfs(nrow , ncol , v , vis , grid);
        }
    }

}

    int shortestBridge(vector<vector<int>>& grid) {
        
        vector<pair<int,int>> v;
        vector<pair<int,int>> v1;
        vector<pair<int,int>> v2;
        int n = grid.size();
        vector<vector<int>> vis(n , vector<int>(n , 0));
        bool flag = 0;
        for(int i=0; i<n; i++)
        {
            for(int j=0; j<n; j++)
            {
                if(grid[i][j] == 1 and vis[i][j] == 0)
                {
                    dfs(i , j , v , vis, grid);
                    if(flag == 0)
                    {
                        v1 = v;
                        flag = 1;
                        v.clear();
                    }
                    else
                    {
                        v2 = v;
                    }
                }
            
            }
           
        }

        int ans = 1e9;


        for(auto it: v1)
        {
            int row1 = it.first;
            int col1 = it.second;

            for(auto itt: v2)
            {
                int row2 = itt.first;
                int col2 = itt.second;

                int dist = abs(row1 - row2) + abs(col1 - col2);
                ans = min(ans , dist);
            }
        }
    
        return ans;
    }
};",None,"class Solution {
public:

int r[4] = {-1 , 0, 1, 0};
int c[4] = {0 ,1 , 0 , -1};

void dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)
{
    int n = grid.size();
    vis[row][col] = 1;
    v.push_back({row , col});
    for(int i=0; i<4; i++)
    {
        int nrow = row + r[i];
        int ncol = col + c[i];

        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)
        {
            dfs(nrow , ncol , v , vis , grid);
        }
    }

}

    int shortestBridge(vector<vector<int>>& grid) {
        
        vector<pair<int,int>> v1;
        vector<pair<int,int>> v2;
        int n = grid.size();
        vector<vector<int>> vis(n , vector<int>(n , 0));
        bool flag = 0;
        for(int i=0; i<n; i++)
        {
            for(int j=0; j<n; j++)
            {
                if(grid[i][j] == 1 and vis[i][j] == 0)
                {
                    dfs(i , j , v1 , vis, grid);
                    if(flag == 0)
                    {
                        flag = 1;
                    }
                    else
                    {
                        bfs(v1 , v2 , grid);
                        return steps-1;
                    }
                    v1.clear();
                }
            
            }
           
        }
        return -1;
    }

    void bfs(vector<pair<int,int>>& v1, vector<pair<int,int>>& v2, vector<vector<int>>& grid)
    {
        int n = grid.size();
        queue<pair<int,int>> q;
        for(auto it: v1)
        {
            q.push(it);
        }

        vector<pair<int,int>> v;
        int steps = 0;
        while(!q.empty())
        {
            int size = q.size();
            while(size--)
            {
                auto it = q.front();
                q.pop();

                int row = it.first;
                int col = it.second;

                for(int i=0; i<4; i++)
                {
                    int nrow = row + r[i];
                    int ncol = col + c[i];

                    if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and grid[nrow][ncol] == 1)
                    {
                        grid[nrow][ncol] = 0;
                        q.push({nrow , ncol});
                        v.push_back({nrow , ncol});
                    }
                }
            }
            steps++;
            v1 = v2;
            v2 = v;
            v.clear();
        }
    }
};
"
1172,cpp,count-stepping-numbers-in-range,"class Solution {
public:
    #define mod 1000000007
    long long dp[102][10][2][2];
    long long f(string &r,int n,int pre,int leadingZero,int tight){
        if(n==0) return 1;
        
        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];
        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;
        
        if(leadingZero){
            for(int i=0;i<=up;i++){
                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; 
            }
        } else {
            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;
            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;
        }
        
        
        return dp[n][pre][leadingZero][tight]=ans;
    }
    int countSteppingNumbers(string low, string high) {
        int n=high.size();
        memset(dp,-1,sizeof(dp));
        long long r= f(high,high.size(),0,1,0);  
        memset(dp,-1,sizeof(dp));
        for(int i=low.size()-1;i>=0;i--){
            if((low[i]-'0')>0){
                low[i]--;break;
            } else {
                low[i]='9';
            }
        }
        
        long long l= f(low,low.size(),0,1,1);
        cout<<l<<"" ""<<r<<endl;
        return (r-l+mod)%mod;
    }
};",None,"class Solution {
public:
    const int mod = 1000000007;
    long long dp[102][10][2][2];
    long long f(string &r, int n, int pre, int leadingZero, int tight) {
        if (n == 0) return 1;
        if (dp[n][pre][leadingZero][tight] != -1) return dp[n][pre][leadingZero][tight];
        long long up = tight ? (r[r.size() - n] - '0') : 9, ans = 0;
        if (leadingZero) {
            for (int i = 0; i <= up; i++) {
                ans = (ans + f(r, n - 1, i, (i == 0), tight & (i == up))) % mod;
            }
        } else {
            if (pre - 1 >= 0 && pre - 1 <= up) ans = (ans + f(r, n - 1, pre - 1, 0, tight & (pre - 1 == up))) % mod;
            if (pre + 1 <= up) ans = (ans + f(r, n - 1, pre + 1, 0, tight & (pre + 1 == up))) % mod;
        }
        return dp[n][pre][leadingZero][tight] = ans;
    }
    int countSteppingNumbers(string low, string high) {
        int n = high.size();
        memset(dp, -1, sizeof(dp));
        long long r = f(high, high.size(), 0, 1, 0);
        memset(dp, -1, sizeof(dp));
        for (int i = low.size() - 1; i >= 0; i--) {
            if (low[i] != '0') {
                low[i]--;
                break;
            } else {
                low[i] = '9';
            }
        }
        long long l = f(low, low.size(), 0, 1, 1);
        return (r - l + mod) % mod;
    }
};
"
1172,cpp,count-stepping-numbers-in-range,"class Solution {
public:
    #define mod 1000000007
    long long dp[102][10][2][2];
    long long f(string &r,int n,int pre,int leadingZero,int tight){
        if(n==0) return 1;
        
        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];
        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;
        
        if(leadingZero){
            for(int i=0;i<=up;i++){
                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; 
            }
        } else {
            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;
            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;
        }
        
        
        return dp[n][pre][leadingZero][tight]=ans;
    }
    int countSteppingNumbers(string low, string high) {
        int n=high.size();
        memset(dp,-1,sizeof(dp));
        long long r= f(high,high.size(),0,1,0);  
        memset(dp,-1,sizeof(dp));
        for(int i=low.size()-1;i>=0;i--){
            if((low[i]-'0')>0){
                low[i]--;break;
            } else {
                low[i]='9';
            }
        }
        
        long long l= f(low,low.size(),0,1,1);
        cout<<l<<"" ""<<r<<endl;
        return (r-l+mod)%mod;
    }
};",None,"class Solution {
public:
    #define mod 1000000007
    long long dp[102][10][2][2];
    long long f(const string &r,int n,int pre,int leadingZero,int tight){
        if(n==0) return 1;
        
        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];
        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;
        
        if(leadingZero){
            for(int i=0;i<=up;i++){
                if(i==0 || i==pre || abs(i-pre)!=1) continue;
                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; 
            }
        } else {
            if(pre-1>=0 && pre-1<=up && abs(pre-up)!=1) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;
            if(pre+1<=up && abs(pre-up)!=1) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;
        }
        
        
        return dp[n][pre][leadingZero][tight]=ans;
    }
    int countSteppingNumbers(string low, string high) {
        int n=high.size();
        memset(dp,-1,sizeof(dp));
        long long r= f(high,high.size(),0,1,0);  
        memset(dp,-1,sizeof(dp));
        for(int i=low.size()-1;i>=0;i--){
            if((low[i]-'0')>0){
                low[i]--;break;
            } else {
                low[i]='9';
            }
        }
        
        long long l= f(low,low.size(),0,1,1);
        cout<<l<<"" ""<<r<<endl;
        return (r-l+mod)%mod;
    }
};
"
1172,cpp,count-stepping-numbers-in-range,"class Solution {
public:
    #define mod 1000000007
    long long dp[102][10][2][2];
    long long f(string &r,int n,int pre,int leadingZero,int tight){
        if(n==0) return 1;
        
        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];
        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;
        
        if(leadingZero){
            for(int i=0;i<=up;i++){
                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; 
            }
        } else {
            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;
            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;
        }
        
        
        return dp[n][pre][leadingZero][tight]=ans;
    }
    int countSteppingNumbers(string low, string high) {
        int n=high.size();
        memset(dp,-1,sizeof(dp));
        long long r= f(high,high.size(),0,1,0);  
        memset(dp,-1,sizeof(dp));
        for(int i=low.size()-1;i>=0;i--){
            if((low[i]-'0')>0){
                low[i]--;break;
            } else {
                low[i]='9';
            }
        }
        
        long long l= f(low,low.size(),0,1,1);
        cout<<l<<"" ""<<r<<endl;
        return (r-l+mod)%mod;
    }
};",None,"class Solution {
public:
    #define mod 1000000007
    long long dp[102][10][2][2];
    long long f(string &r,int n,int pre,int leadingZero,int tight){
        if(n==0) return 1;
        
        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];
        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;
        
        if(leadingZero){
            for(int i=0;i<=up;i++){
                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; 
            }
        } else {
            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;
            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;
        }
        
        
        return dp[n][pre][leadingZero][tight]=ans;
    }
    int countSteppingNumbers(string low, string high) {
        int n=high.size();
        memset(dp,-1,sizeof(dp));
        long long r= f(high,high.size(),0,0,0);  
        memset(dp,-1,sizeof(dp));
        for(int i=low.size()-1;i>=0;i--){
            if((low[i]-'0')>0){
                break;
            } else {
                low[i]='1';
            }
        }
        
        long long l= f(low,low.size(),0,0,1);
        cout<<l<<"" ""<<r<<endl;
        return (r-l+mod)%mod;
    }
};
"
1173,cpp,brace-expansion-ii,"class Solution {
public:
    
    vector<string> multiply(vector<string>& a, vector<string>& b){
        if(a.empty()) return b;
        if(b.empty()) return a;
        vector<string> ans;
        for(auto&i:a){
            for(auto&j:b) ans.push_back(i+j);
        }
        return ans;
    }
    
    vector<string> braceExpansionII(string expression) {
        vector<string>  res, curr;
        stack<vector<string>> st;
        for(auto&x:expression){
            if(x >= 'a' and x <= 'z'){
                if(curr.size()) for(auto&i:curr) i += x;
                else curr.push_back(string(1, x));
            }
            else if(x == '{'){
                st.push(res); st.push(curr);
                res.clear(), curr.clear();
            }
            else if(x == '}'){
                vector<string> preCurr = st.top(); st.pop();
                vector<string> preRes = st.top(); st.pop();
                for(auto&i:curr) res.push_back(i);
                res = multiply(preCurr, res);
                curr = preRes;
            }
            else if(x == ','){
                for(auto&i:curr) res.push_back(i);
                curr.clear();
            }
        }
        for(auto&i:curr) res.push_back(i);
        sort(res.begin(), res.end());
        return vector<string>(res.begin(), unique(res.begin(), res.end()));
    }
};",None,"class Solution {
public:
    
    vector<string> multiply(vector<string>& a, vector<string>& b){
        if(a.empty()) return b;
        if(b.empty()) return a;
        vector<string> ans;
        for(auto&i:a){
            for(auto&j:b) ans.push_back(i+j);
        }
        return ans;
    }
    
    vector<string> braceExpansionII(string expression) {
        vector<string>  res, curr;
        stack<vector<string>> st;
        for(auto&x:expression){
            if(x >= 'a' and x <= 'z'){
                if(curr.size()) for(auto&i:curr) i += x;
                else curr.push_back(string(1, x));
            }
            else if(x == '{'){
                st.push(res); st.push(curr);
                res.clear(), curr.clear();
            }
            else if(x == '}'){
                vector<string> preCurr = st.top(); st.pop();
                vector<string> preRes = st.top(); st.pop();
                for(auto&i:curr) preRes.push_back(i);
                res = multiply(preCurr, preRes);
                curr = preRes;
            }
            else if(x == ','){
                for(auto&i:curr) res.push_back(i);
                curr.clear();
            }
        }
        for(auto&i:curr) res.push_back(i);
        sort(res.begin(), res.end());
        return vector<string>(res.begin(), unique(res.begin(), res.end()));
    }
};
"
1173,cpp,brace-expansion-ii,"class Solution {
public:
    
    vector<string> multiply(vector<string>& a, vector<string>& b){
        if(a.empty()) return b;
        if(b.empty()) return a;
        vector<string> ans;
        for(auto&i:a){
            for(auto&j:b) ans.push_back(i+j);
        }
        return ans;
    }
    
    vector<string> braceExpansionII(string expression) {
        vector<string>  res, curr;
        stack<vector<string>> st;
        for(auto&x:expression){
            if(x >= 'a' and x <= 'z'){
                if(curr.size()) for(auto&i:curr) i += x;
                else curr.push_back(string(1, x));
            }
            else if(x == '{'){
                st.push(res); st.push(curr);
                res.clear(), curr.clear();
            }
            else if(x == '}'){
                vector<string> preCurr = st.top(); st.pop();
                vector<string> preRes = st.top(); st.pop();
                for(auto&i:curr) res.push_back(i);
                res = multiply(preCurr, res);
                curr = preRes;
            }
            else if(x == ','){
                for(auto&i:curr) res.push_back(i);
                curr.clear();
            }
        }
        for(auto&i:curr) res.push_back(i);
        sort(res.begin(), res.end());
        return vector<string>(res.begin(), unique(res.begin(), res.end()));
    }
};",None,"class Solution {
public:
    
    vector<string> multiply(vector<string>& a, vector<string>& b){
        if(a.empty()) return b;
        if(b.empty()) return a;
        vector<string> ans;
        for(auto&i:a){
            for(auto&j:b) ans.push_back(i+j);
        }
        return ans;
    }
    
    vector<string> braceExpansionII(string expression) {
        vector<string>  res, curr;
        stack<vector<string>> st;
        for(auto&x:expression){
            if(x >= 'a' and x <= 'z'){
                if(curr.size()) for(auto&i:curr) i += x;
                else curr.push_back(string(1, x));
            }
            else if(x == '{'){
                st.push(res); st.push(curr);
                res.clear(), curr.clear();
            }
            else if(x == '}'){
                vector<string> preCurr = st.top(); st.pop();
                vector<string> preRes = st.top(); st.pop();
                for(auto&i:curr) preRes.push_back(i);
                res = multiply(preCurr, preRes);
                curr = preRes;
            }
            else if(x == ','){
                for(auto&i:curr) res.push_back(i);
                curr.clear();
            }
        }
        for(auto&i:curr) res.push_back(i);
        sort(res.begin(), res.end());
        return vector<string>(res.begin(), unique(res.begin(), res.end()));
    }
};
"
1173,cpp,brace-expansion-ii,"class Solution {
public:
    
    vector<string> multiply(vector<string>& a, vector<string>& b){
        if(a.empty()) return b;
        if(b.empty()) return a;
        vector<string> ans;
        for(auto&i:a){
            for(auto&j:b) ans.push_back(i+j);
        }
        return ans;
    }
    
    vector<string> braceExpansionII(string expression) {
        vector<string>  res, curr;
        stack<vector<string>> st;
        for(auto&x:expression){
            if(x >= 'a' and x <= 'z'){
                if(curr.size()) for(auto&i:curr) i += x;
                else curr.push_back(string(1, x));
            }
            else if(x == '{'){
                st.push(res); st.push(curr);
                res.clear(), curr.clear();
            }
            else if(x == '}'){
                vector<string> preCurr = st.top(); st.pop();
                vector<string> preRes = st.top(); st.pop();
                for(auto&i:curr) res.push_back(i);
                res = multiply(preCurr, res);
                curr = preRes;
            }
            else if(x == ','){
                for(auto&i:curr) res.push_back(i);
                curr.clear();
            }
        }
        for(auto&i:curr) res.push_back(i);
        sort(res.begin(), res.end());
        return vector<string>(res.begin(), unique(res.begin(), res.end()));
    }
};",None,"class Solution {
public:
    vector<string> multiply(vector<string>& a, vector<string>& b) {
        vector<string> ans;
        for (auto& i : a) {
            for (auto& j : b) {
                ans.push_back(i + j);
            }
        }
        return ans;
    }

    vector<string> braceExpansionII(string expression) {
        vector<string> res, curr;
        stack<vector<string>> st;

        for (auto& x : expression) {
            if (x >= 'a' && x <= 'z') {
                if (curr.size()) {
                    for (auto& i : curr) {
                        i += x;
                    }
                } else {
                    curr.push_back(string(1, x));
                }
            } else if (x == '{') {
                st.push(res);
                st.push(curr);
                res.clear();
                curr.clear();
            } else if (x == '}') {
                vector<string> preCurr = st.top();
                st.pop();
                vector<string> preRes = st.top();
                st.pop();

                for (auto& i : curr) {
                    preRes.push_back(i);
                }

                sort(preRes.begin(), preRes.end());
                res = multiply(preCurr, preRes);
                curr = preRes;
            } else if (x == ',') {
                for (auto& i : curr) {
                    res.push_back(i);
                }
                curr.clear();
            }
        }

        for (auto& i : curr) {
            res.push_back(i);
        }

        sort(res.begin(), res.end());
        res.erase(unique(res.begin(), res.end()), res.end());

        return res;
    }
};
"
1174,cpp,longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit,"class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
        int ans=1,l=0,h=0,count=0;
        map<int,int> mp;
        mp[nums[l]]++;
        
        while(h<nums.size()){
            mp[nums[h]]++;
            count++;
            
            if(prev(mp.end())->first - mp.begin()->first <= limit){
                ans=max(ans,count);
            }else{
                while(prev(mp.end())->first - mp.begin()->first > limit && l<h){
                    if(mp[nums[l]]>1)mp[nums[l]]--;
                    else mp.erase(nums[l]);
                    count--;
                    l++;
                }
            }
            h++;
        }
        return ans;
    }
};",None,"class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
        int ans=1,l=0,h=0,count=0;
        map<int,int> mp;
        mp[nums[l]]++;
        
        while(h<nums.size()){
            mp[nums[h]]++;
            count++;
            
            while(prev(mp.end())->first - mp.begin()->first > limit && l<h){
                mp[nums[l]]--;
                if(mp[nums[l]]==0)mp.erase(nums[l]);
                l++;
                count--;
            }
            h++;
            ans = max(ans, count);
        }
        return ans;
    }
};
"
1174,cpp,longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit,"class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
        int ans=1,l=0,h=0,count=0;
        map<int,int> mp;
        mp[nums[l]]++;
        
        while(h<nums.size()){
            mp[nums[h]]++;
            count++;
            
            if(prev(mp.end())->first - mp.begin()->first <= limit){
                ans=max(ans,count);
            }else{
                while(prev(mp.end())->first - mp.begin()->first > limit && l<h){
                    if(mp[nums[l]]>1)mp[nums[l]]--;
                    else mp.erase(nums[l]);
                    count--;
                    l++;
                }
            }
            h++;
        }
        return ans;
    }
};",None,"class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
        int ans=1,l=0,h=0,count=0;
        map<int,int> mp;
        mp[nums[l]]++;
        
        while(h<nums.size()){
            mp[nums[h]]++;
            count++;
            
            auto it = prev(mp.end());
            if(it->first - mp.begin()->first <= limit){
                ans=max(ans,count);
            }else{
                while(it->first - mp.begin()->first > limit && l<h){
                    if(mp[nums[l]]>1)mp[nums[l]]--;
                    else mp.erase(nums[l]);
                    count--;
                    l++;
                    it = prev(mp.end());
                }
            }
            h++;
        }
        return ans;
    }
};
"
1174,cpp,longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit,"class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
        int ans=1,l=0,h=0,count=0;
        map<int,int> mp;
        mp[nums[l]]++;
        
        while(h<nums.size()){
            mp[nums[h]]++;
            count++;
            
            if(prev(mp.end())->first - mp.begin()->first <= limit){
                ans=max(ans,count);
            }else{
                while(prev(mp.end())->first - mp.begin()->first > limit && l<h){
                    if(mp[nums[l]]>1)mp[nums[l]]--;
                    else mp.erase(nums[l]);
                    count--;
                    l++;
                }
            }
            h++;
        }
        return ans;
    }
};",None,"class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
        int ans=1,l=0,h=0,count=0;
        map<int,int> mp;
        mp[nums[l]]++;
        
        while(h<nums.size()){
            mp[nums[h]]++;
            count++;
            
            if(prev(mp.end())->first - mp.begin()->first <= limit){
                ans=max(ans,count);
            }else{
                while(prev(mp.end())->first - mp.begin()->first > limit && l<h){
                    mp[nums[l]]--;
                    if(mp[nums[l]]==0)mp.erase(nums[l]);
                    count--;
                    l++;
                }
            }
            h++;
        }
        return ans;
    }
};
"
1175,cpp,construct-binary-tree-from-preorder-and-inorder-traversal,"class Solution {
public:
    int find(vector<int>& inorder, int k) {
        for (int i = 0; i < inorder.size(); i++) if (inorder[i] == k) return i;
        return -1;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int preIndex = 0, inStart = 0, inend = inorder.size();
        return build(preorder, inorder, preIndex, inStart, inend);
    }

    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int& preIndex, int inStart, int inend) {
        if (inStart > inend) {
            return NULL;
        }

        int ele = preorder[preIndex++];
        TreeNode* root = new TreeNode(ele);
        int pos_in_inorder = find(inorder, ele);

        root->left = build(preorder, inorder, preIndex, inStart, pos_in_inorder - 1);
        root->right = build(preorder, inorder, preIndex, pos_in_inorder + 1, inend);
        return root;
    }
};",None,"class Solution {
public:
    int find(vector<int>& inorder, int k) {
        for (int i = 0; i < inorder.size(); i++) if (inorder[i] == k) return i;
        return -1;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int preIndex = 0, inStart = 0, inend = inorder.size() - 1;
        return build(preorder, inorder, preIndex, inStart, inend);
    }

    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int& preIndex, int inStart, int inend) {
        if (inStart > inend) {
            return NULL;
        }

        int ele = preorder[preIndex++];
        TreeNode* root = new TreeNode(ele);
        int pos_in_inorder = find(inorder, ele);

        root->left = build(preorder, inorder, preIndex, inStart, pos_in_inorder - 1);
        root->right = build(preorder, inorder, preIndex, pos_in_inorder + 1, inend);
        return root;
    }
};
"
1175,cpp,construct-binary-tree-from-preorder-and-inorder-traversal,"class Solution {
public:
    int find(vector<int>& inorder, int k) {
        for (int i = 0; i < inorder.size(); i++) if (inorder[i] == k) return i;
        return -1;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int preIndex = 0, inStart = 0, inend = inorder.size();
        return build(preorder, inorder, preIndex, inStart, inend);
    }

    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int& preIndex, int inStart, int inend) {
        if (inStart > inend) {
            return NULL;
        }

        int ele = preorder[preIndex++];
        TreeNode* root = new TreeNode(ele);
        int pos_in_inorder = find(inorder, ele);

        root->left = build(preorder, inorder, preIndex, inStart, pos_in_inorder - 1);
        root->right = build(preorder, inorder, preIndex, pos_in_inorder + 1, inend);
        return root;
    }
};",None,"class Solution {
public:
    int find(vector<int>& inorder, int k) {
        for (int i = 0; i < inorder.size(); i++) if (inorder[i] == k) return i;
        return -1;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int preIndex = 0, inStart = 0, inend = inorder.size() - 1;
        return build(preorder, inorder, preIndex, inStart, inend);
    }

    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int& preIndex, int inStart, int inend) {
        if (inStart > inend) {
            return NULL;
        }

        int ele = preorder[preIndex++];
        TreeNode* root = new TreeNode(ele);
        int pos_in_inorder = find(inorder, ele);

        root->left = build(preorder, inorder, preIndex, inStart, pos_in_inorder - 1);
        root->right = build(preorder, inorder, preIndex, pos_in_inorder + 1, inend);
        return root;
    }
};
"
1175,cpp,construct-binary-tree-from-preorder-and-inorder-traversal,"class Solution {
public:
    int find(vector<int>& inorder, int k) {
        for (int i = 0; i < inorder.size(); i++) if (inorder[i] == k) return i;
        return -1;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int preIndex = 0, inStart = 0, inend = inorder.size();
        return build(preorder, inorder, preIndex, inStart, inend);
    }

    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int& preIndex, int inStart, int inend) {
        if (inStart > inend) {
            return NULL;
        }

        int ele = preorder[preIndex++];
        TreeNode* root = new TreeNode(ele);
        int pos_in_inorder = find(inorder, ele);

        root->left = build(preorder, inorder, preIndex, inStart, pos_in_inorder - 1);
        root->right = build(preorder, inorder, preIndex, pos_in_inorder + 1, inend);
        return root;
    }
};",None,"class Solution {
public:
    int find(vector<int>& inorder, int k) {
        for (int i = 0; i < inorder.size(); i++) if (inorder[i] == k) return i;
        return -1;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int preIndex = 0, inStart = 0, inend = inorder.size() - 1;
        return build(preorder, inorder, preIndex, inStart, inend);
    }

    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int& preIndex, int inStart, int inend) {
        if (inStart > inend) {
            return NULL;
        }

        int ele = preorder[preIndex++];
        TreeNode* root = new TreeNode(ele);
        int pos_in_inorder = find(inorder, ele);

        root->left = build(preorder, inorder, preIndex, inStart, pos_in_inorder - 1);
        root->right = build(preorder, inorder, preIndex, pos_in_inorder + 1, inend);
        return root;
    }
};
"
1176,cpp,tallest-billboard,"class Solution {
public:

    int build_board(vector<int> &rods, int balance, int i, vector<vector<int>> &memo)
    {
        if(i>=rods.size() && balance==0)
            return 0;
        if(i>=rods.size() && balance!=0)
            return INT_MIN;

        if(memo[i][balance+5000]!=-1)
            return memo[i][balance+5000];
        int left= build_board(rods,balance+rods[i],i+1,memo);
        int right= build_board(rods,balance-rods[i],i+1,memo);

        int ans= rods[i+1]+max(left,right);

        int skip= build_board(rods,balance,i+1,memo);

        ans= max(ans,skip);

        memo[i][balance+5000]=ans;
        return ans;

    }

    int tallestBillboard(vector<int>& rods) {
        
        vector<vector<int>> memo(rods.size(),vector<int>(10001,-1));
        int ans= build_board(rods,0,0,memo);

        if(ans<=0)
            return 0;
        else
            return ans/2;
    }
};",None,"class Solution {
public:

    int build_board(vector<int> &rods, int balance, int i, vector<vector<int>> &memo)
    {
        if(i>=rods.size() && balance==0)
            return 0;
        if(i>=rods.size() && balance!=0)
            return INT_MIN;

        if(memo[i][balance]!=-1)
            return memo[i][balance];
        int left= build_board(rods,balance+rods[i],i+1,memo);
        int right= build_board(rods,balance-rods[i],i+1,memo);

        int ans= max(left, right);

        int skip= build_board(rods,balance,i+1,memo);

        ans= max(ans,skip);

        memo[i][balance]=ans;
        return ans;

    }

    int tallestBillboard(vector<int>& rods) {
        
        vector<vector<int>> memo(rods.size(),vector<int>(5001,-1));
        int ans= build_board(rods,0,0,memo);

        if(ans<=0)
            return 0;
        else
            return ans/2;
    }
};
"
1176,cpp,tallest-billboard,"class Solution {
public:

    int build_board(vector<int> &rods, int balance, int i, vector<vector<int>> &memo)
    {
        if(i>=rods.size() && balance==0)
            return 0;
        if(i>=rods.size() && balance!=0)
            return INT_MIN;

        if(memo[i][balance+5000]!=-1)
            return memo[i][balance+5000];
        int left= build_board(rods,balance+rods[i],i+1,memo);
        int right= build_board(rods,balance-rods[i],i+1,memo);

        int ans= rods[i+1]+max(left,right);

        int skip= build_board(rods,balance,i+1,memo);

        ans= max(ans,skip);

        memo[i][balance+5000]=ans;
        return ans;

    }

    int tallestBillboard(vector<int>& rods) {
        
        vector<vector<int>> memo(rods.size(),vector<int>(10001,-1));
        int ans= build_board(rods,0,0,memo);

        if(ans<=0)
            return 0;
        else
            return ans/2;
    }
};",None,"class Solution {
public:

    int build_board(vector<int> &rods, int balance, int i, vector<vector<int>> &memo)
    {
        if(i>=rods.size() && balance==0)
            return 0;
        if(i>=rods.size() && balance!=0)
            return INT_MIN;

        if(memo[i][balance]!=-1)
            return memo[i][balance];
        int left= build_board(rods,balance+rods[i],i+1,memo);
        int right= build_board(rods,balance-rods[i],i+1,memo);

        int ans= max(left, right);

        int skip= build_board(rods,balance,i+1,memo);

        ans= max(ans,skip);

        memo[i][balance]=ans;
        return ans;

    }

    int tallestBillboard(vector<int>& rods) {
        
        vector<vector<int>> memo(rods.size(),vector<int>(5001,-1));
        int ans= build_board(rods,0,0,memo);

        if(ans<=0)
            return 0;
        else
            return ans/2;
    }
};
"
1176,cpp,tallest-billboard,"class Solution {
public:

    int build_board(vector<int> &rods, int balance, int i, vector<vector<int>> &memo)
    {
        if(i>=rods.size() && balance==0)
            return 0;
        if(i>=rods.size() && balance!=0)
            return INT_MIN;

        if(memo[i][balance+5000]!=-1)
            return memo[i][balance+5000];
        int left= build_board(rods,balance+rods[i],i+1,memo);
        int right= build_board(rods,balance-rods[i],i+1,memo);

        int ans= rods[i+1]+max(left,right);

        int skip= build_board(rods,balance,i+1,memo);

        ans= max(ans,skip);

        memo[i][balance+5000]=ans;
        return ans;

    }

    int tallestBillboard(vector<int>& rods) {
        
        vector<vector<int>> memo(rods.size(),vector<int>(10001,-1));
        int ans= build_board(rods,0,0,memo);

        if(ans<=0)
            return 0;
        else
            return ans/2;
    }
};",None,"class Solution {
public:

    int build_board(vector<int> &rods, int balance, int i, vector<vector<int>> &memo)
    {
        if(i>=rods.size() && balance==0)
            return 0;
        if(i>=rods.size() && balance!=0)
            return INT_MIN;

        if(memo[i][balance]!=-1)
            return memo[i][balance];
        int left= build_board(rods,balance+rods[i],i+1,memo);
        int right= build_board(rods,balance-rods[i],i+1,memo);

        int ans= max(left, right);

        int skip= build_board(rods,balance,i+1,memo);

        ans= max(ans,skip);

        memo[i][balance]=ans;
        return ans;

    }

    int tallestBillboard(vector<int>& rods) {
        
        vector<vector<int>> memo(rods.size(),vector<int>(5001,-1));
        int ans= build_board(rods,0,0,memo);

        if(ans<=0)
            return 0;
        else
            return ans/2;
    }
};
"
1177,cpp,maximum-number-of-removable-characters,"class Solution {
 int rm[100001] = {};
    bool valid(string &s, string &p, vector<int> &A, int k) {
        memset(rm, 0, sizeof(rm));
        for (int i = 0; i < k; ++i) rm[A[i]] = 1; 
        int N = s.size(), M = p.size(), j = 0; 
        for (int i = 0; i < N && j < M; ++i) {
            if (rm[i] == 1) continue; 
            if (s[i] == p[j]) ++j; 
        }
        return j == N; 
    }
public:
    int maximumRemovals(string s, string p, vector<int>& A) {
        int L = 0, R = A.size();
        while (L <= R) {
            int M = (L + R) / 2;
            if (valid(s, p, A, M)) L = M + 1;
            else R = M - 1;
        }
        return R;
    }
};",None,"class Solution {
 int rm[100001] = {};
    bool valid(string &s, string &p, vector<int> &A, int k) {
        memset(rm, 0, sizeof(rm));
        for (int i = 0; i < k; ++i) rm[A[i]] = 1; 
        int N = s.size(), M = p.size(), j = 0; 
        for (int i = 0; i < N && j < M; ++i) {
            if (rm[i] == 1) continue; 
            if (s[i] == p[j]) ++j; 
        }
        return j == M; 
    }
public:
    int maximumRemovals(string s, string p, vector<int>& A) {
        int L = 0, R = A.size();
        while (L <= R) {
            int M = (L + R) / 2;
            if (valid(s, p, A, M)) L = M + 1;
            else R = M - 1;
        }
        return R;
    }
};
"
1177,cpp,maximum-number-of-removable-characters,"class Solution {
 int rm[100001] = {};
    bool valid(string &s, string &p, vector<int> &A, int k) {
        memset(rm, 0, sizeof(rm));
        for (int i = 0; i < k; ++i) rm[A[i]] = 1; 
        int N = s.size(), M = p.size(), j = 0; 
        for (int i = 0; i < N && j < M; ++i) {
            if (rm[i] == 1) continue; 
            if (s[i] == p[j]) ++j; 
        }
        return j == N; 
    }
public:
    int maximumRemovals(string s, string p, vector<int>& A) {
        int L = 0, R = A.size();
        while (L <= R) {
            int M = (L + R) / 2;
            if (valid(s, p, A, M)) L = M + 1;
            else R = M - 1;
        }
        return R;
    }
};",None,"class Solution {
    bool valid(string &s, string &p, vector<int> &A, int k) {
        memset(rm, 0, sizeof(rm));
        for (int i = 0; i < k; ++i) rm[A[i]] = 1; 
        int N = s.size(), M = p.size(), j = 0; 
        for (int i = 0; i < N && j < M; ++i) {
            if (rm[i] == 1) continue; 
            if (s[i] == p[j]) ++j; 
        }
        return j == M; 
    }
public:
    int maximumRemovals(string s, string p, vector<int>& A) {
        int L = 0, R = A.size();
        while (L <= R) {
            int M = (L + R) / 2;
            if (valid(s, p, A, M)) L = M + 1;
            else R = M - 1;
        }
        return R;
    }
};
"
1177,cpp,maximum-number-of-removable-characters,"class Solution {
 int rm[100001] = {};
    bool valid(string &s, string &p, vector<int> &A, int k) {
        memset(rm, 0, sizeof(rm));
        for (int i = 0; i < k; ++i) rm[A[i]] = 1; 
        int N = s.size(), M = p.size(), j = 0; 
        for (int i = 0; i < N && j < M; ++i) {
            if (rm[i] == 1) continue; 
            if (s[i] == p[j]) ++j; 
        }
        return j == N; 
    }
public:
    int maximumRemovals(string s, string p, vector<int>& A) {
        int L = 0, R = A.size();
        while (L <= R) {
            int M = (L + R) / 2;
            if (valid(s, p, A, M)) L = M + 1;
            else R = M - 1;
        }
        return R;
    }
};",None,"class Solution {
    bool valid(string &s, string &p, vector<int> &A, int k) {
        memset(rm, 0, sizeof(rm));
        for (int i = 0; i < k; ++i) rm[A[i]] = 1; 
        int N = s.size(), M = p.size(), j = 0; 
        for (int i = 0; i < N && j < M; ++i) {
            if (rm[i] == 1) continue; 
            if (s[i] == p[j]) ++j; 
        }
        return j == M; 
    }
public:
    int maximumRemovals(string s, string p, vector<int>& A) {
        int L = 0, R = A.size();
        while (L <= R) {
            int M = (L + R) / 2;
            if (valid(s, p, A, M)) L = M + 1;
            else R = M - 1;
        }
        return R;
    }
};
"
1178,cpp,kth-ancestor-of-a-tree-node,"class TreeAncestor {
public:
    vector<vector<int>>v;
    TreeAncestor(int n, vector<int>& parent) {
        vector<vector<int>> par(n, vector<int>(20));
        for (int i = 0; i < n; i++) par[i][0] = i; 
        for (int j = 1; j < 20; j++) {
            for (int i = 0; i < n; i++) {
                if (par[i][j - 1] == -1) par[i][j] = -1;
                else par[i][j] = par[par[i][j - 1]][j - 1];
            }
        }
        swap(v, par);
    }
    int getKthAncestor(int node, int k) {
        for (int i = 0; i < 20; i++) {
            if ((k >> i) & 1) {
                node = v[node][i];
                if (node == -1) return -1;
            }
        }
        return node;
    }
};",None,"class TreeAncestor {
public:
    vector<vector<int>>v;
    TreeAncestor(int n, vector<int>& parent) {
        vector<vector<int>> par(n, vector<int>(20));
        for (int i = 0; i < n; i++) par[i][0] = parent[i]; 
        for (int j = 1; j < 20; j++) {
            for (int i = 0; i < n; i++) {
                if (par[i][j - 1] == -1) par[i][j] = -1;
                else par[i][j] = par[par[i][j - 1]][j - 1];
            }
        }
        swap(v, par);
    }
    int getKthAncestor(int node, int k) {
        for (int i = 0; i < 20; i++) {
            if ((k >> i) & 1) {
                node = v[node][i];
                if (node == -1) return -1;
            }
        }
        return node;
    }
};
"
1178,cpp,kth-ancestor-of-a-tree-node,"class TreeAncestor {
public:
    vector<vector<int>>v;
    TreeAncestor(int n, vector<int>& parent) {
        vector<vector<int>> par(n, vector<int>(20));
        for (int i = 0; i < n; i++) par[i][0] = i; 
        for (int j = 1; j < 20; j++) {
            for (int i = 0; i < n; i++) {
                if (par[i][j - 1] == -1) par[i][j] = -1;
                else par[i][j] = par[par[i][j - 1]][j - 1];
            }
        }
        swap(v, par);
    }
    int getKthAncestor(int node, int k) {
        for (int i = 0; i < 20; i++) {
            if ((k >> i) & 1) {
                node = v[node][i];
                if (node == -1) return -1;
            }
        }
        return node;
    }
};",None,"class TreeAncestor {
public:
    vector<vector<int>>v;
    TreeAncestor(int n, vector<int>& parent) {
        vector<vector<int>> par(n, vector<int>(20));
        for (int i = 0; i < n; i++) par[i][0] = parent[i]; 
        for (int j = 1; j < 20; j++) {
            for (int i = 0; i < n; i++) {
                if (par[i][j - 1] == -1) par[i][j] = -1;
                else par[i][j] = par[par[i][j - 1]][j - 1];
            }
        }
        swap(v, par);
    }
    int getKthAncestor(int node, int k) {
        for (int i = 0; i < 20; i++) {
            if ((k >> i) & 1) {
                if (node == -1) return -1;
                node = v[node][i];
            }
        }
        return node;
    }
};
"
1178,cpp,kth-ancestor-of-a-tree-node,"class TreeAncestor {
public:
    vector<vector<int>>v;
    TreeAncestor(int n, vector<int>& parent) {
        vector<vector<int>> par(n, vector<int>(20));
        for (int i = 0; i < n; i++) par[i][0] = i; 
        for (int j = 1; j < 20; j++) {
            for (int i = 0; i < n; i++) {
                if (par[i][j - 1] == -1) par[i][j] = -1;
                else par[i][j] = par[par[i][j - 1]][j - 1];
            }
        }
        swap(v, par);
    }
    int getKthAncestor(int node, int k) {
        for (int i = 0; i < 20; i++) {
            if ((k >> i) & 1) {
                node = v[node][i];
                if (node == -1) return -1;
            }
        }
        return node;
    }
};",None,"class TreeAncestor {
public:
    vector<vector<int>>v;
    TreeAncestor(int n, vector<int>& parent) {
        vector<vector<int>> par(n, vector<int>(20));
        for (int i = 0; i < n; i++) par[i][0] = parent[i]; 
        for (int j = 1; j < 20; j++) {
            for (int i = 0; i < n; i++) {
                if (par[i][j - 1] == -1) par[i][j] = -1;
                else par[i][j] = par[par[i][j - 1]][j - 1];
            }
        }
        swap(v, par);
    }
    int getKthAncestor(int node, int k) {
        for (int i = 0; i < 20; i++) {
            if ((k >> i) & 1) {
                node = v[node][i];
                if (node == -1) return -1;
            }
        }
        return node;
    }
};
"
1179,cpp,find-players-with-zero-or-one-losses,"class Solution {
public:
    map<int,int>mp1;
    map<int,int>mp2;
    vector<vector<int>> findWinners(vector<vector<int>>& matches) {
        for(int i=0;i<matches.size();i++)
        {
            mp1[matches[i][0]]++;
            mp2[matches[i][1]];
        }
        vector<vector<int>>ans;
        vector<int>temp1;
        for(auto it: mp1)
        {
            if(mp2.find(it.first)==mp2.end()) 
            {
                temp1.push_back(it.first);
            }
        }
        ans.push_back(temp1);
        vector<int>temp2;
        for(auto it: mp2)
        {
            if(it.second==1)
            {
                temp2.push_back(it.first);
            }
        }
        ans.push_back(temp2);
        return ans;
    }
};",None,"class Solution {
public:
    map<int,int>mp1;
    map<int,int>mp2;
    vector<vector<int>> findWinners(vector<vector<int>>& matches) {
        for(int i=0;i<matches.size();i++)
        {
            mp1[matches[i][0]]++;
            if(mp2.find(matches[i][1])!=mp2.end())
                mp2[matches[i][1]]++;
        }
        vector<vector<int>>ans;
        vector<int>temp1;
        for(auto it: mp1)
        {
            if(mp2.find(it.first)==mp2.end() || mp2[it.first] == 0)
            {
                temp1.push_back(it.first);
            }
        }
        ans.push_back(temp1);
        vector<int>temp2;
        for(auto it: mp2)
        {
            if(it.second==1)
            {
                temp2.push_back(it.first);
            }
        }
        ans.push_back(temp2);
        return ans;
    }
};
"
1179,cpp,find-players-with-zero-or-one-losses,"class Solution {
public:
    map<int,int>mp1;
    map<int,int>mp2;
    vector<vector<int>> findWinners(vector<vector<int>>& matches) {
        for(int i=0;i<matches.size();i++)
        {
            mp1[matches[i][0]]++;
            mp2[matches[i][1]];
        }
        vector<vector<int>>ans;
        vector<int>temp1;
        for(auto it: mp1)
        {
            if(mp2.find(it.first)==mp2.end()) 
            {
                temp1.push_back(it.first);
            }
        }
        ans.push_back(temp1);
        vector<int>temp2;
        for(auto it: mp2)
        {
            if(it.second==1)
            {
                temp2.push_back(it.first);
            }
        }
        ans.push_back(temp2);
        return ans;
    }
};",None,"class Solution {
public:
    map<int,int>mp1;
    map<int,int>mp2;
    vector<vector<int>> findWinners(vector<vector<int>>& matches) {
        for(int i=0;i<matches.size();i++)
        {
            mp1[matches[i][0]]++;
            if(mp2.find(matches[i][1])!=mp2.end())
                mp2[matches[i][1]]++;
        }
        vector<vector<int>>ans;
        vector<int>temp1;
        for(auto it: mp1)
        {
            if(mp2.find(it.first)==mp2.end() || mp2[it.first] == 0)
            {
                temp1.push_back(it.first);
            }
        }
        ans.push_back(temp1);
        vector<int>temp2;
        for(auto it: mp2)
        {
            if(it.second == 1)
            {
                temp2.push_back(it.first);
            }
        }
        ans.push_back(temp2);
        return ans;
    }
};
"
1179,cpp,find-players-with-zero-or-one-losses,"class Solution {
public:
    map<int,int>mp1;
    map<int,int>mp2;
    vector<vector<int>> findWinners(vector<vector<int>>& matches) {
        for(int i=0;i<matches.size();i++)
        {
            mp1[matches[i][0]]++;
            mp2[matches[i][1]];
        }
        vector<vector<int>>ans;
        vector<int>temp1;
        for(auto it: mp1)
        {
            if(mp2.find(it.first)==mp2.end()) 
            {
                temp1.push_back(it.first);
            }
        }
        ans.push_back(temp1);
        vector<int>temp2;
        for(auto it: mp2)
        {
            if(it.second==1)
            {
                temp2.push_back(it.first);
            }
        }
        ans.push_back(temp2);
        return ans;
    }
};",None,"class Solution {
public:
    map<int,int>mp1;
    map<int,int>mp2;
    vector<vector<int>> findWinners(vector<vector<int>>& matches) {
        for(int i=0;i<matches.size();i++)
        {
            mp1[matches[i][0]]++;
            if(mp2.find(matches[i][1]) != mp2.end())
                mp2[matches[i][1]]++;
            else
                mp2[matches[i][1]] = 1;
        }
        vector<vector<int>>ans;
        vector<int>temp1;
        for(auto it: mp1)
        {
            if(mp2.find(it.first)==mp2.end() || mp2[it.first] == 0)
            {
                temp1.push_back(it.first);
            }
        }
        ans.push_back(temp1);
        vector<int>temp2;
        for(auto it: mp2)
        {
            if(it.second==1)
            {
                temp2.push_back(it.first);
            }
        }
        ans.push_back(temp2);
        return ans;
    }
};
"
1180,cpp,max-number-of-k-sum-pairs,"class Solution {
public:
    int maxOperations(vector<int>& nums, int k) {
        sort(nums.begin(),nums.end());
        int i=0;
        int j=nums.size();
        int count=0;
        while(j>i)
        {
            if(nums[i]+nums[j]==k)
            {
                i++;
                j--;
                count++;
            }
            else if(nums[i]+nums[j]<k)
            {
                i++;
            }
            else
            {
                j--;
            }
        }
        return count;

    }
};",None,"class Solution {
public:
    int maxOperations(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        int i = 0, j = nums.size() - 1, count = 0;
        while (i < j) {
            if (nums[i] + nums[j] == k) {
                i++;
                j--;
                count++;
            } else if (nums[i] + nums[j] < k) {
                i++;
            } else {
                j--;
            }
        }
        return count;
    }
};
"
1180,cpp,max-number-of-k-sum-pairs,"class Solution {
public:
    int maxOperations(vector<int>& nums, int k) {
        sort(nums.begin(),nums.end());
        int i=0;
        int j=nums.size();
        int count=0;
        while(j>i)
        {
            if(nums[i]+nums[j]==k)
            {
                i++;
                j--;
                count++;
            }
            else if(nums[i]+nums[j]<k)
            {
                i++;
            }
            else
            {
                j--;
            }
        }
        return count;

    }
};",None,"class Solution {
public:
    int maxOperations(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        int i = 0;
        int j = nums.size() - 1;
        int count = 0;
        while (i < j) {
            if (nums[i] + nums[j] == k) {
                i++;
                j--;
                count++;
            } else if (nums[i] + nums[j] < k) {
                i++;
            } else {
                j--;
            }
        }
        return count;
    }
};
"
1180,cpp,max-number-of-k-sum-pairs,"class Solution {
public:
    int maxOperations(vector<int>& nums, int k) {
        sort(nums.begin(),nums.end());
        int i=0;
        int j=nums.size();
        int count=0;
        while(j>i)
        {
            if(nums[i]+nums[j]==k)
            {
                i++;
                j--;
                count++;
            }
            else if(nums[i]+nums[j]<k)
            {
                i++;
            }
            else
            {
                j--;
            }
        }
        return count;

    }
};",None,"class Solution {
public:
    int maxOperations(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        int i = 0;
        int j = nums.size() - 1;
        int count = 0;
        while (i < j) {
            if (nums[i] + nums[j] == k) {
                i++;
                j--;
                count++;
            } else if (nums[i] + nums[j] < k) {
                i++;
            } else {
                j--;
            }
        }
        return count;
    }
};
"
1181,cpp,minimum-cost-for-tickets,"class Solution {
public:
    int helper(vector<int>&costs,vector<int>&days,int ind,vector<int>&dp){
        if(ind<0){return 0;}
        if(dp[days[ind]]!=-1){return dp[days[ind]];}
        int daypoint=costs[0]+helper(costs,days,ind-1,dp);
        int indweek=upper_bound(days.begin(),days.end(),days[ind-1]-7)-days.begin();
        indweek--;
        int weekpoint=costs[1]+helper(costs,days,indweek,dp);
        int indmonth=upper_bound(days.begin(),days.end(),days[ind-1]-30)-days.begin();
        indmonth--;
        int monthpoint=costs[2]+helper(costs,days,indmonth,dp);
        return dp[days[ind]]=min({daypoint,weekpoint,monthpoint});
    }

    int mincostTickets(vector<int>& days, vector<int>& costs) {
        int n=days.size();
        vector<int>dp(366,-1);
        return helper(costs,days,n-1,dp);
    }
};",None,"class Solution {
public:
    int helper(vector<int>&costs,vector<int>&days,int ind,vector<int>&dp){
        if(ind<0){return 0;}
        if(dp[ind]!=-1){return dp[ind];}
        int daypoint=costs[0]+helper(costs,days,ind-1,dp);
        int indweek=upper_bound(days.begin(),days.end(),days[ind]-7)-days.begin();
        indweek--;
        int weekpoint=costs[1]+helper(costs,days,indweek,dp);
        int indmonth=upper_bound(days.begin(),days.end(),days[ind]-30)-days.begin();
        indmonth--;
        int monthpoint=costs[2]+helper(costs,days,indmonth,dp);
        return dp[ind]=min({daypoint,weekpoint,monthpoint});
    }

    int mincostTickets(vector<int>& days, vector<int>& costs) {
        int n=days.size();
        vector<int>dp(n,-1);
        return helper(costs,days,n-1,dp);
    }
};
"
1181,cpp,minimum-cost-for-tickets,"class Solution {
public:
    int helper(vector<int>&costs,vector<int>&days,int ind,vector<int>&dp){
        if(ind<0){return 0;}
        if(dp[days[ind]]!=-1){return dp[days[ind]];}
        int daypoint=costs[0]+helper(costs,days,ind-1,dp);
        int indweek=upper_bound(days.begin(),days.end(),days[ind-1]-7)-days.begin();
        indweek--;
        int weekpoint=costs[1]+helper(costs,days,indweek,dp);
        int indmonth=upper_bound(days.begin(),days.end(),days[ind-1]-30)-days.begin();
        indmonth--;
        int monthpoint=costs[2]+helper(costs,days,indmonth,dp);
        return dp[days[ind]]=min({daypoint,weekpoint,monthpoint});
    }

    int mincostTickets(vector<int>& days, vector<int>& costs) {
        int n=days.size();
        vector<int>dp(366,-1);
        return helper(costs,days,n-1,dp);
    }
};",None,"class Solution {
public:
    int helper(vector<int>&costs,vector<int>&days,int ind,vector<int>&dp){
        if(ind<0){return 0;}
        if(dp[ind]!=-1){return dp[ind];}
        int daypoint=costs[0]+helper(costs,days,ind-1,dp);
        int indweek=upper_bound(days.begin(),days.end(),days[ind]-7)-days.begin();
        indweek--;
        int weekpoint=costs[1]+helper(costs,days,indweek,dp);
        int indmonth=upper_bound(days.begin(),days.end(),days[ind]-30)-days.begin();
        indmonth--;
        int monthpoint=costs[2]+helper(costs,days,indmonth,dp);
        return dp[ind]=min({daypoint,weekpoint,monthpoint});
    }

    int mincostTickets(vector<int>& days, vector<int>& costs) {
        int n=days.size();
        vector<int>dp(n+1,-1);
        return helper(costs,days,n,dp);
    }
};
"
1181,cpp,minimum-cost-for-tickets,"class Solution {
public:
    int helper(vector<int>&costs,vector<int>&days,int ind,vector<int>&dp){
        if(ind<0){return 0;}
        if(dp[days[ind]]!=-1){return dp[days[ind]];}
        int daypoint=costs[0]+helper(costs,days,ind-1,dp);
        int indweek=upper_bound(days.begin(),days.end(),days[ind-1]-7)-days.begin();
        indweek--;
        int weekpoint=costs[1]+helper(costs,days,indweek,dp);
        int indmonth=upper_bound(days.begin(),days.end(),days[ind-1]-30)-days.begin();
        indmonth--;
        int monthpoint=costs[2]+helper(costs,days,indmonth,dp);
        return dp[days[ind]]=min({daypoint,weekpoint,monthpoint});
    }

    int mincostTickets(vector<int>& days, vector<int>& costs) {
        int n=days.size();
        vector<int>dp(366,-1);
        return helper(costs,days,n-1,dp);
    }
};",None,"class Solution {
public:
    int helper(vector<int>&costs,vector<int>&days,int ind,vector<int>&dp){
        if(ind<0){return 0;}
        if(dp[ind]!=-1){return dp[ind];}
        int daypoint=costs[0]+helper(costs,days,ind-1,dp);
        int indweek=upper_bound(days.begin(),days.end(),days[ind]-7)-days.begin();
        indweek--;
        int weekpoint=costs[1]+helper(costs,days,indweek,dp);
        int indmonth=upper_bound(days.begin(),days.end(),days[ind]-30)-days.begin();
        indmonth--;
        int monthpoint=costs[2]+helper(costs,days,indmonth,dp);
        return dp[ind]=min({daypoint,weekpoint,monthpoint});
    }

    int mincostTickets(vector<int>& days, vector<int>& costs) {
        int n=days.size();
        vector<int>dp(n,-1);
        return helper(costs,days,n-1,dp);
    }
};
"
1182,cpp,find-first-palindromic-string-in-the-array,"class Solution {
public:
    bool check(string &word)
    {
        int l = 0;
        int r = word.size();

        while(l<r)
        {
            if(word[l] != word[r])
            {
                return false;
            }
            l++;
             r--;
        }
        return true;

    }
    string firstPalindrome(vector<string>& words) {
        for(int i=0;i<words.size();i++)
        {
            if(check(words[i]))
            return words[i];
        }

        return """";
        
    }
};",None,"class Solution {
public:
    bool check(string &word)
    {
        int l = 0;
        int r = word.size() - 1;

        while(l<r)
        {
            if(word[l] != word[r])
            {
                return false;
            }
            l++;
            r--;
        }
        return true;

    }
    string firstPalindrome(vector<string>& words) {
        for(int i=0;i<words.size();i++)
        {
            if(check(words[i]))
            return words[i];
        }

        return """";
        
    }
};
"
1182,cpp,find-first-palindromic-string-in-the-array,"class Solution {
public:
    bool check(string &word)
    {
        int l = 0;
        int r = word.size();

        while(l<r)
        {
            if(word[l] != word[r])
            {
                return false;
            }
            l++;
             r--;
        }
        return true;

    }
    string firstPalindrome(vector<string>& words) {
        for(int i=0;i<words.size();i++)
        {
            if(check(words[i]))
            return words[i];
        }

        return """";
        
    }
};",None,"class Solution {
public:
    bool check(string &word)
    {
        int l = 0;
        int r = word.size() - 1; // corrected the end index

        while(l<r)
        {
            if(word[l] != word[r])
            {
                return false;
            }
            l++;
            r--;
        }
        return true;
    }

    string firstPalindrome(vector<string>& words) {
        for(int i=0;i<words.size();i++)
        {
            if(check(words[i]))
                return words[i];
        }

        return """";
    }
};
"
1182,cpp,find-first-palindromic-string-in-the-array,"class Solution {
public:
    bool check(string &word)
    {
        int l = 0;
        int r = word.size();

        while(l<r)
        {
            if(word[l] != word[r])
            {
                return false;
            }
            l++;
             r--;
        }
        return true;

    }
    string firstPalindrome(vector<string>& words) {
        for(int i=0;i<words.size();i++)
        {
            if(check(words[i]))
            return words[i];
        }

        return """";
        
    }
};",None,"class Solution {
public:
    bool check(string &word)
    {
        int l = 0;
        int r = word.size() - 1;

        while(l<r)
        {
            if(word[l] != word[r])
            {
                return false;
            }
            l++;
            r--;
        }
        return true;

    }
    string firstPalindrome(vector<string>& words) {
        for(int i=0;i<words.size();i++)
        {
            if(check(words[i]))
            return words[i];
        }

        return """";
    }
};
"
1183,cpp,most-profit-assigning-work,"class Solution {
public:
    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker){
        int n=difficulty.size();
        vector<pair<int,int>> nums;

        for(int i=0;i<n;i++){
            nums.push_back({profit[i],difficulty[i]});
        }
        sort(nums.begin(),nums.end());
        int index=n;
        int ans=0;
        sort(worker.begin(),worker.end());
        
        for(int i=worker.size()-1;i>=0;i--){
            while(index>=0 && nums[index].second>worker[i]) index--;
            if(index==-1) continue;
            ans+=nums[index].first;
        }
        return ans;        
    }
};",None,"class Solution {
public:
    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker){
        int n=difficulty.size();
        vector<pair<int,int>> nums;

        for(int i=0;i<n;i++){
            nums.push_back({profit[i],difficulty[i]});
        }
        sort(nums.begin(),nums.end());
        int index=n-1;
        int ans=0;
        sort(worker.begin(),worker.end());
        
        for(int i=0;i<worker.size();i++){
            while(index>=0 && nums[index].second>worker[i]) index--;
            if(index==-1) continue;
            ans+=nums[index].first;
        }
        return ans;        
    }
};
"
1183,cpp,most-profit-assigning-work,"class Solution {
public:
    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker){
        int n=difficulty.size();
        vector<pair<int,int>> nums;

        for(int i=0;i<n;i++){
            nums.push_back({profit[i],difficulty[i]});
        }
        sort(nums.begin(),nums.end());
        int index=n;
        int ans=0;
        sort(worker.begin(),worker.end());
        
        for(int i=worker.size()-1;i>=0;i--){
            while(index>=0 && nums[index].second>worker[i]) index--;
            if(index==-1) continue;
            ans+=nums[index].first;
        }
        return ans;        
    }
};",None,"class Solution {
public:
    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker){
        int n=difficulty.size();
        vector<pair<int,int>> nums;

        for(int i=0;i<n;i++){
            nums.push_back({profit[i],difficulty[i]});
        }
        sort(nums.begin(),nums.end());
        int index=n-1;
        int ans=0;
        sort(worker.begin(),worker.end());
        
        for(int i=0;i<worker.size();i++){
            while(index>=0 && nums[index].second>worker[i]) index--;
            if(index==-1) continue;
            ans+=nums[index].first;
        }
        return ans;        
    }
};
"
1183,cpp,most-profit-assigning-work,"class Solution {
public:
    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker){
        int n=difficulty.size();
        vector<pair<int,int>> nums;

        for(int i=0;i<n;i++){
            nums.push_back({profit[i],difficulty[i]});
        }
        sort(nums.begin(),nums.end());
        int index=n;
        int ans=0;
        sort(worker.begin(),worker.end());
        
        for(int i=worker.size()-1;i>=0;i--){
            while(index>=0 && nums[index].second>worker[i]) index--;
            if(index==-1) continue;
            ans+=nums[index].first;
        }
        return ans;        
    }
};",None,"class Solution {
public:
    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker){
        int n=difficulty.size();
        vector<pair<int,int>> nums;

        for(int i=0;i<n;i++){
            nums.push_back({profit[i],difficulty[i]});
        }
        sort(nums.begin(),nums.end());
        int index=n-1;
        int ans=0;
        sort(worker.begin(),worker.end());
        
        for(int i=0;i<worker.size();i++){
            while(index>=0 && nums[index].second>worker[i]) index--;
            if(index==-1) continue;
            ans+=nums[index].first;
            index--;
        }
        return ans;        
    }
};
"
1184,cpp,lru-cache,"class LRUCache {
public:
class node
{
  public:
  int key;
  int val;
  node* next;
  node* prev;
  node(int _key,int _val)
  {
    key = _key;
    val = _val;
  }
};
node* head = new node(-1,-1);
node* tail = new node(-1,-1);

int size;
unordered_map<int,node*>mpp;
    LRUCache(int capacity) {
       size = capacity; 
       head->next = tail;
       tail->prev = head;  
    }

    void addNode(node* newNode){
       
       node* temp = head->next;
       newNode->next = temp;
       newNode->prev = head;
       head->next = newNode;
       temp->prev = newNode;
    }

    void deleteNode(node* delNode){
         
       node* delprev = delNode->prev;
       node* delnext = delNode->next;
       delprev->next = delnext;
       delnext->prev = delprev;
    }
    
    int get(int _key) {
        
        if(mpp.count(_key))
        {
          node* nde = mpp[_key];
          int curr = nde->val;
          mpp.erase(_key);
          deleteNode(nde);
          addNode(nde);
          mpp[_key] = head->next;
          return curr;
        }
        return -1;
    }
    
    void put(int _key, int value) {
        
        if(mpp.count(_key))
        {
           node* nde = mpp[_key];
           mpp.erase(_key);
           deleteNode(nde);
        }
        if(mpp.size()==size)
        {
           mpp.erase(tail->prev->key);
           deleteNode(tail->prev);
        }
        addNode(new node(_key,value));
        mpp[_key] = tail->next;
    }
};",None,"class LRUCache {
public:
class node
{
  public:
  int key;
  int val;
  node* next;
  node* prev;
  node(int _key,int _val)
  {
    key = _key;
    val = _val;
  }
};
node* head = new node(-1,-1);
node* tail = new node(-1,-1);

int size;
unordered_map<int,node*>mpp;
    LRUCache(int capacity) {
       size = capacity; 
       head->next = tail;
       tail->prev = head;  
    }

    void addNode(node* newNode){
       
       node* temp = head->next;
       newNode->next = temp;
       newNode->prev = head;
       head->next = newNode;
       temp->prev = newNode;
    }

    void deleteNode(node* delNode){
         
       node* delprev = delNode->prev;
       node* delnext = delNode->next;
       delprev->next = delnext;
       delnext->prev = delprev;
    }
    
    int get(int _key) {
        
        if(mpp.count(_key))
        {
          node* nde = mpp[_key];
          int curr = nde->val;
          mpp.erase(_key);
          deleteNode(nde);
          addNode(nde);
          mpp[_key] = head->next;
          return curr;
        }
        return -1;
    }
    
    void put(int _key, int value) {
        
        if(mpp.count(_key))
        {
           node* nde = mpp[_key];
           mpp.erase(_key);
           deleteNode(nde);
        }
        if(mpp.size()==size)
        {
           mpp.erase(tail->prev->key);
           deleteNode(tail->prev);
        }
        addNode(new node(_key,value));
        mpp[_key] = tail->prev;
    }
};
"
1184,cpp,lru-cache,"class LRUCache {
public:
class node
{
  public:
  int key;
  int val;
  node* next;
  node* prev;
  node(int _key,int _val)
  {
    key = _key;
    val = _val;
  }
};
node* head = new node(-1,-1);
node* tail = new node(-1,-1);

int size;
unordered_map<int,node*>mpp;
    LRUCache(int capacity) {
       size = capacity; 
       head->next = tail;
       tail->prev = head;  
    }

    void addNode(node* newNode){
       
       node* temp = head->next;
       newNode->next = temp;
       newNode->prev = head;
       head->next = newNode;
       temp->prev = newNode;
    }

    void deleteNode(node* delNode){
         
       node* delprev = delNode->prev;
       node* delnext = delNode->next;
       delprev->next = delnext;
       delnext->prev = delprev;
    }
    
    int get(int _key) {
        
        if(mpp.count(_key))
        {
          node* nde = mpp[_key];
          int curr = nde->val;
          mpp.erase(_key);
          deleteNode(nde);
          addNode(nde);
          mpp[_key] = head->next;
          return curr;
        }
        return -1;
    }
    
    void put(int _key, int value) {
        
        if(mpp.count(_key))
        {
           node* nde = mpp[_key];
           mpp.erase(_key);
           deleteNode(nde);
        }
        if(mpp.size()==size)
        {
           mpp.erase(tail->prev->key);
           deleteNode(tail->prev);
        }
        addNode(new node(_key,value));
        mpp[_key] = tail->next;
    }
};",None,"class LRUCache {
public:
class node
{
  public:
  int key;
  int val;
  node* next;
  node* prev;
  node(int _key,int _val)
  {
    key = _key;
    val = _val;
  }
};
node* head = new node(-1,-1);
node* tail = new node(-1,-1);

int size;
unordered_map<int,node*>mpp;
    LRUCache(int capacity) {
       size = capacity; 
       head->next = tail;
       tail->prev = head;  
    }

    void addNode(node* newNode){
       
       newNode->next = head->next;
       newNode->prev = head;
       head->next->prev = newNode;
       head->next = newNode;
    }

    void deleteNode(node* delNode){
         
       node* delprev = delNode->prev;
       node* delnext = delNode->next;
       delprev->next = delnext;
       delnext->prev = delprev;
    }
    
    int get(int _key) {
        
        if(mpp.count(_key))
        {
          node* nde = mpp[_key];
          int curr = nde->val;
          mpp.erase(_key);
          deleteNode(nde);
          addNode(nde);
          mpp[_key] = head->next;
          return curr;
        }
        return -1;
    }
    
    void put(int _key, int value) {
        
        if(mpp.count(_key))
        {
           node* nde = mpp[_key];
           mpp.erase(_key);
           deleteNode(nde);
        }
        if(mpp.size()==size)
        {
           mpp.erase(tail->prev->key);
           deleteNode(tail->prev);
        }
        addNode(new node(_key,value));
        mpp[_key] = tail->prev;
    }
};
"
1184,cpp,lru-cache,"class LRUCache {
public:
class node
{
  public:
  int key;
  int val;
  node* next;
  node* prev;
  node(int _key,int _val)
  {
    key = _key;
    val = _val;
  }
};
node* head = new node(-1,-1);
node* tail = new node(-1,-1);

int size;
unordered_map<int,node*>mpp;
    LRUCache(int capacity) {
       size = capacity; 
       head->next = tail;
       tail->prev = head;  
    }

    void addNode(node* newNode){
       
       node* temp = head->next;
       newNode->next = temp;
       newNode->prev = head;
       head->next = newNode;
       temp->prev = newNode;
    }

    void deleteNode(node* delNode){
         
       node* delprev = delNode->prev;
       node* delnext = delNode->next;
       delprev->next = delnext;
       delnext->prev = delprev;
    }
    
    int get(int _key) {
        
        if(mpp.count(_key))
        {
          node* nde = mpp[_key];
          int curr = nde->val;
          mpp.erase(_key);
          deleteNode(nde);
          addNode(nde);
          mpp[_key] = head->next;
          return curr;
        }
        return -1;
    }
    
    void put(int _key, int value) {
        
        if(mpp.count(_key))
        {
           node* nde = mpp[_key];
           mpp.erase(_key);
           deleteNode(nde);
        }
        if(mpp.size()==size)
        {
           mpp.erase(tail->prev->key);
           deleteNode(tail->prev);
        }
        addNode(new node(_key,value));
        mpp[_key] = tail->next;
    }
};",None,"class LRUCache {
public:
class node
{
  public:
  int key;
  int val;
  node* next;
  node* prev;
  node(int _key,int _val)
  {
    key = _key;
    val = _val;
  }
};
node* head = new node(-1,-1);
node* tail = new node(-1,-1);

int size;
unordered_map<int,node*>mpp;
    LRUCache(int capacity) {
       size = capacity; 
       head->next = tail;
       tail->prev = head;  
    }

    void addNode(node* newNode){
       
       node* temp = head->next;
       newNode->next = temp;
       newNode->prev = head;
       head->next = newNode;
       temp->prev = newNode;
    }

    void deleteNode(node* delNode){
         
       node* delprev = delNode->prev;
       node* delnext = delNode->next;
       delprev->next = delnext;
       delnext->prev = delprev;
    }
    
    int get(int _key) {
        
        if(mpp.count(_key))
        {
          node* nde = mpp[_key];
          int curr = nde->val;
          mpp.erase(_key);
          deleteNode(nde);
          addNode(nde);
          mpp[_key] = head->next;
          return curr;
        }
        return -1;
    }
    
    void put(int _key, int value) {
        
        if(mpp.count(_key))
        {
           node* nde = mpp[_key];
           mpp.erase(_key);
           deleteNode(nde);
        }
        if(mpp.size()==size)
        {
           mpp.erase(tail->prev->key);
           deleteNode(tail->prev);
        }
        addNode(new node(_key,value));
        mpp[_key] = tail->prev;
    }
};
"
1185,cpp,all-ancestors-of-a-node-in-a-directed-acyclic-graph,"class Solution {
public:
   
    void dfs(int i,int ansc,vector<vector<int>>&ans,vector<int>&vis,vector<vector<int>>&res){
        
        vis[i]=1;
        
        for(auto t:ans[i]){
            if(!vis[t]){
                dfs(t,ansc,ans,vis,res);
            }
        }
       
        if(i!=ansc)
            res[i].push_back(ansc);
    }
    
    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {
        
        vector<vector<int>>ans(n),result(n);
        
        for(auto a:edges){
            ans[a[0]].push_back(a[1]);
        }

        vector<int>visited(n);

        for(int i=0;i<n;i++){
            dfs(i,i,ans,visited,result);
        }
      
        return result;
    }
};",None,"class Solution {
public:

    void dfs(int i, int ansc, vector<vector<int>>& ans, vector<int>& vis, vector<vector<int>>& res) {
        vis[i] = 1;

        for (auto t : ans[i]) {
            if (!vis[t]) {
                dfs(t, ansc, ans, vis, res);
            }
        }

        if (i != ansc) {
            res[i].push_back(ansc);
        }
    }

    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {

        vector<vector<int>> ans(n, vector<int>()), result(n);

        for (auto a : edges) {
            ans[a[1]].push_back(a[0]);
        }

        vector<int> vis(n, 0);

        for (int i = 0; i < n; i++) {
            dfs(i, i, ans, vis, result);
        }

        return result;
    }
};
"
1185,cpp,all-ancestors-of-a-node-in-a-directed-acyclic-graph,"class Solution {
public:
   
    void dfs(int i,int ansc,vector<vector<int>>&ans,vector<int>&vis,vector<vector<int>>&res){
        
        vis[i]=1;
        
        for(auto t:ans[i]){
            if(!vis[t]){
                dfs(t,ansc,ans,vis,res);
            }
        }
       
        if(i!=ansc)
            res[i].push_back(ansc);
    }
    
    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {
        
        vector<vector<int>>ans(n),result(n);
        
        for(auto a:edges){
            ans[a[0]].push_back(a[1]);
        }

        vector<int>visited(n);

        for(int i=0;i<n;i++){
            dfs(i,i,ans,visited,result);
        }
      
        return result;
    }
};",None,"class Solution {
public:

    void dfs(int i, int ansc, vector<vector<int>>& ans, vector<int>& vis, vector<vector<int>>& res) {
        vis[i] = 1;

        for (auto t : ans[i]) {
            if (!vis[t]) {
                dfs(t, ansc, ans, vis, res);
            }
        }

        if (i != ansc)
            res[i].push_back(ansc);
    }

    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {

        vector<vector<int>> ans(n), result(n);

        for (auto a : edges) {
            ans[a[1]].push_back(a[0]);
        }

        vector<int> vis(n);

        for (int i = 0; i < n; i++) {
            dfs(i, i, ans, vis, result);
        }

        return result;
    }
};
"
1185,cpp,all-ancestors-of-a-node-in-a-directed-acyclic-graph,"class Solution {
public:
   
    void dfs(int i,int ansc,vector<vector<int>>&ans,vector<int>&vis,vector<vector<int>>&res){
        
        vis[i]=1;
        
        for(auto t:ans[i]){
            if(!vis[t]){
                dfs(t,ansc,ans,vis,res);
            }
        }
       
        if(i!=ansc)
            res[i].push_back(ansc);
    }
    
    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {
        
        vector<vector<int>>ans(n),result(n);
        
        for(auto a:edges){
            ans[a[0]].push_back(a[1]);
        }

        vector<int>visited(n);

        for(int i=0;i<n;i++){
            dfs(i,i,ans,visited,result);
        }
      
        return result;
    }
};",None,"class Solution {
public:

    void dfs(int i,int ansc,vector<vector<int>>&ans,vector<int>&vis,vector<vector<int>>&res){
        vis[i]=1;
        res[i].push_back(ansc);
        for(auto t:ans[i]){
            if(!vis[t]){
                dfs(t,i,ans,vis,res);
            }
        }
    }

    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {
        vector<vector<int>>ans(n),result(n);

        for(auto a:edges){
            ans[a[1]].push_back(a[0]);
        }

        vector<int>visited(n,0);

        for(int i=0;i<n;i++){
            if(!visited[i]){
                dfs(i,-1,ans,visited,result);
            }
        }

        return result;
    }
};
"
1186,cpp,find-the-winner-of-the-circular-game,"class Solution {
public:
    int findTheWinner(int n, int k) {
        queue<int> q;
        for(int i=1;i<=n;i++){
            q.push(i);
        }
        while(q.size() != 1){
            int i = 0;
            while(i < k){
                int f = q.front();
                q.pop();
                q.push(f);
                i++;
            }
            q.pop();
        }

        return q.front();
    }
};",None,"class Solution {
public:
    int findTheWinner(int n, int k) {
        queue<int> q;
        for(int i=1;i<=n;i++){
            q.push(i);
        }
        while(q.size() > 1){
            for(int i = 0; i < k-1; i++){
                int f = q.front();
                q.pop();
                q.push(f);
            }
            q.pop();
        }

        return q.front();
    }
};
"
1186,cpp,find-the-winner-of-the-circular-game,"class Solution {
public:
    int findTheWinner(int n, int k) {
        queue<int> q;
        for(int i=1;i<=n;i++){
            q.push(i);
        }
        while(q.size() != 1){
            int i = 0;
            while(i < k){
                int f = q.front();
                q.pop();
                q.push(f);
                i++;
            }
            q.pop();
        }

        return q.front();
    }
};",None,"class Solution {
public:
    int findTheWinner(int n, int k) {
        queue<int> q;
        for(int i=1;i<=n;i++){
            q.push(i);
        }
        while(q.size() > 1){
            for(int i=1;i<k;i++){
                int f = q.front();
                q.pop();
                q.push(f);
            }
            q.pop();
        }

        return q.front();
    }
};
"
1186,cpp,find-the-winner-of-the-circular-game,"class Solution {
public:
    int findTheWinner(int n, int k) {
        queue<int> q;
        for(int i=1;i<=n;i++){
            q.push(i);
        }
        while(q.size() != 1){
            int i = 0;
            while(i < k){
                int f = q.front();
                q.pop();
                q.push(f);
                i++;
            }
            q.pop();
        }

        return q.front();
    }
};",None,"class Solution {
public:
    int findTheWinner(int n, int k) {
        vector<int> q;
        for(int i=1;i<=n;i++){
            q.push_back(i);
        }
        int size = n;
        while(size != 1){
            int i = 0;
            int f = q[0];
            q.erase(q.begin());
            while(i < k-1){
                f = q[0];
                q.erase(q.begin());
                q.push_back(f);
                i++;
            }
            q.erase(q.begin());
            size--;
        }

        return q[0];
    }
};
"
1187,cpp,longest-ideal-subsequence,"class Solution {

   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)
   {
       if(index == s.length())
       return 0;

       if(dp[index][prev] != -1)
       return dp[index][prev];

       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);

       int op2 = 0 ;

       if(prev == 26)
       op2 = 1 + SolveByMemo(s, k , index+1 , prev , dp);
       else if(abs(s[index]-'a' - prev) <= k)
       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);

       return dp[index][prev] = max(op1 , op2);
   }

   int SolveByTab(string &s , int &k )
   {
        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));
       
        for(int index = s.length()-1 ; index>=0 ; index--)
        {
            for(int prev = 0 ; prev<= 26 ; prev++)
            {
                int op1 = 0 + dp[index+1][prev];
                int op2 = 0 ;

               if(prev == 26)
               op2 = 1 + dp[index+1][prev];
               else if(abs(s[index]-'a' - prev) <= k)
               op2 = 1 + dp[index+1][s[index]-'a'];

               dp[index][prev] = max(op1 , op2);
            }
        }

       return max(dp[0][s[0]-'a'] , dp[0][26]);
   }
public:
    int longestIdealString(string s, int k) {
        

        return SolveByTab(s, k);
    }
};",None,"class Solution {

   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)
   {
       if(index == s.length())
       return 0;

       if(dp[index][prev] != -1)
       return dp[index][prev];

       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);

       int op2 = 0 ;

       if(prev == 26 || index == s.length()-1)
       op2 = 1 + SolveByMemo(s, k , index+1 , prev , dp);
       else if(abs(s[index]-s[index+1]) <= k)
       op2 = 1 + SolveByMemo(s, k , index+1 , s[index] , dp);

       return dp[index][prev] = max(op1 , op2);
   }

   int SolveByTab(string &s , int &k )
   {
        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));
        dp[s.length()][26] = 1;
        for(int index = s.length()-1 ; index>=0 ; index--)
        {
            for(int prev = 0 ; prev<= 26 ; prev++)
            {
                int op1 = 0 + dp[index+1][prev];
                int op2 = 0 ;

               if(prev == 26 || index == s.length()-1)
               op2 = 1 + dp[index+1][prev];
               else if(abs(s[index]-s[index+1]) <= k)
               op2 = 1 + dp[index+1][s[index]];

               dp[index][prev] = max(op1 , op2);
            }
        }

       return max(dp[0][s[0]-'a'] , dp[0][26]);
   }
public:
    int longestIdealString(string s, int k) {
        

        return SolveByTab(s, k);
    }
};
"
1187,cpp,longest-ideal-subsequence,"class Solution {

   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)
   {
       if(index == s.length())
       return 0;

       if(dp[index][prev] != -1)
       return dp[index][prev];

       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);

       int op2 = 0 ;

       if(prev == 26)
       op2 = 1 + SolveByMemo(s, k , index+1 , prev , dp);
       else if(abs(s[index]-'a' - prev) <= k)
       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);

       return dp[index][prev] = max(op1 , op2);
   }

   int SolveByTab(string &s , int &k )
   {
        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));
       
        for(int index = s.length()-1 ; index>=0 ; index--)
        {
            for(int prev = 0 ; prev<= 26 ; prev++)
            {
                int op1 = 0 + dp[index+1][prev];
                int op2 = 0 ;

               if(prev == 26)
               op2 = 1 + dp[index+1][prev];
               else if(abs(s[index]-'a' - prev) <= k)
               op2 = 1 + dp[index+1][s[index]-'a'];

               dp[index][prev] = max(op1 , op2);
            }
        }

       return max(dp[0][s[0]-'a'] , dp[0][26]);
   }
public:
    int longestIdealString(string s, int k) {
        

        return SolveByTab(s, k);
    }
};",None,"class Solution {

   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)
   {
       if(index == s.length())
       return 0;

       if(dp[index][prev] != -1)
       return dp[index][prev];

       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);

       int op2 = 0 ;

       if(prev == 26 || index == s.length()-1)
       op2 = 1;
       else if(abs(s[index]-s[index+1]) <= k)
       op2 = 1 + SolveByMemo(s, k , index+1 , s[index] , dp);

       return dp[index][prev] = max(op1 , op2);
   }

   int SolveByTab(string &s , int &k )
   {
        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));
        vector<int> curr(27, 0);
        curr[26] = 1;

        for(int index = s.length()-1 ; index>=0 ; index--)
        {
            for(int prev = 0 ; prev<= 26 ; prev++)
            {
                int op1 = 0 + dp[index+1][prev];
                int op2 = 0 ;

               if(prev == 26 || index == s.length()-1)
               op2 = 1;
               else if(abs(s[index]-s[index+1]) <= k)
               op2 = 1 + curr[s[index]];

               curr[prev] = op2;
               dp[index][prev] = max(op1 , op2);
            }
        }

       return max(dp[0][s[0]-'a'] , *max_element(curr.begin(), curr.end()));
   }
public:
    int longestIdealString(string s, int k) {
        

        return SolveByTab(s, k);
    }
};
"
1187,cpp,longest-ideal-subsequence,"class Solution {

   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)
   {
       if(index == s.length())
       return 0;

       if(dp[index][prev] != -1)
       return dp[index][prev];

       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);

       int op2 = 0 ;

       if(prev == 26)
       op2 = 1 + SolveByMemo(s, k , index+1 , prev , dp);
       else if(abs(s[index]-'a' - prev) <= k)
       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);

       return dp[index][prev] = max(op1 , op2);
   }

   int SolveByTab(string &s , int &k )
   {
        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));
       
        for(int index = s.length()-1 ; index>=0 ; index--)
        {
            for(int prev = 0 ; prev<= 26 ; prev++)
            {
                int op1 = 0 + dp[index+1][prev];
                int op2 = 0 ;

               if(prev == 26)
               op2 = 1 + dp[index+1][prev];
               else if(abs(s[index]-'a' - prev) <= k)
               op2 = 1 + dp[index+1][s[index]-'a'];

               dp[index][prev] = max(op1 , op2);
            }
        }

       return max(dp[0][s[0]-'a'] , dp[0][26]);
   }
public:
    int longestIdealString(string s, int k) {
        

        return SolveByTab(s, k);
    }
};",None,"class Solution {

   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)
   {
       if(index == s.length())
       return 0;

       if(dp[index][prev] != -1)
       return dp[index][prev];

       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);

       int op2 = 0 ;

       if(prev == 26 || index == s.length()-1)
       op2 = 1 + SolveByMemo(s, k , index+1 , prev , dp);
       else if(abs(s[index]-s[index+1]) <= k)
       op2 = 1 + SolveByMemo(s, k , index+1 , s[index] , dp);

       return dp[index][prev] = max(op1 , op2);
   }

   int SolveByTab(string &s , int &k )
   {
        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));
       
        for(int index = s.length()-1 ; index>=0 ; index--)
        {
            for(int prev = 0 ; prev<= 26 ; prev++)
            {
                int op1 = 0 + dp[index+1][prev];
                int op2 = 0 ;

               if(prev == 26 || index == s.length()-1)
               op2 = 1 + dp[index+1][prev];
               else if(abs(s[index]-s[index+1]) <= k)
               op2 = 1 + dp[index+1][s[index]];

               dp[index][prev] = max(op1 , op2);
            }
        }

       return max(dp[0][s[0]-'a'] , dp[0][26]);
   }
public:
    int longestIdealString(string s, int k) {
        

        return SolveByTab(s, k);
    }
};
"
1188,cpp,closest-prime-numbers-in-range,"class Solution {
public:
    vector<int> closestPrimes(int left, int right) {
        if(left==1)left++;
        vector<bool> v(right+1,true);
        for(int i = 2; i <= sqrt(right); i++){
            if(v[i]){
                for(int j = i*i; j <= right; j += i){
                    v[j] = false;
                }
            }
        }
        int i = left;
        int j;
        int a = -1, b = -1, k = INT_MAX;
        while(i<= right){
            if(v[i])break;
            i++;
        }
        j = i;
        while(j<=right){
            if(v[j]){
                if(j-i<k){
                    k = j-i;
                    a = i,b = j;
                }
                    i = j;
            }
            j++;
        }
        return {a,b};
    }
};",None,"class Solution {
public:
    vector<int> closestPrimes(int left, int right) {
        if(left==1)left++;
        vector<bool> v(right+1,true);
        for(int i = 2; i <= sqrt(right); i++){
            if(v[i]){
                for(int j = i*i; j <= right; j += i){
                    v[j] = false;
                }
            }
        }
        int i = left;
        int j;
        int a = -1, b = -1, k = INT_MAX;
        if(i > right) return {a, b};
        while(i<= right){
            if(v[i])break;
            i++;
        }
        j = i;
        while(j<=right){
            if(v[j]){
                if(j-i<k){
                    k = j-i;
                    a = i,b = j;
                }
                i = j;
            }
            j++;
        }
        return {a,b};
    }
};
"
1188,cpp,closest-prime-numbers-in-range,"class Solution {
public:
    vector<int> closestPrimes(int left, int right) {
        if(left==1)left++;
        vector<bool> v(right+1,true);
        for(int i = 2; i <= sqrt(right); i++){
            if(v[i]){
                for(int j = i*i; j <= right; j += i){
                    v[j] = false;
                }
            }
        }
        int i = left;
        int j;
        int a = -1, b = -1, k = INT_MAX;
        while(i<= right){
            if(v[i])break;
            i++;
        }
        j = i;
        while(j<=right){
            if(v[j]){
                if(j-i<k){
                    k = j-i;
                    a = i,b = j;
                }
                    i = j;
            }
            j++;
        }
        return {a,b};
    }
};",None,"class Solution {
public:
    vector<int> closestPrimes(int left, int right) {
        if(left == 1) left++;
        vector<bool> v(right+1,true);
        for(int i = 2; i <= sqrt(right); i++){
            if(v[i]){
                for(int j = i*i; j <= right; j += i){
                    v[j] = false;
                }
            }
        }
        int i = left;
        int j;
        int a = -1, b = -1, k = INT_MAX;
        if(i > right) return {a,b};
        while(i <= right){
            if(v[i]) break;
            i++;
        }
        j = i;
        while(j <= right){
            if(v[j]){
                if(j - i < k){
                    k = j - i;
                    a = i;
                    b = j;
                }
                i = j;
            }
            j++;
        }
        return {a,b};
    }
};
"
1188,cpp,closest-prime-numbers-in-range,"class Solution {
public:
    vector<int> closestPrimes(int left, int right) {
        if(left==1)left++;
        vector<bool> v(right+1,true);
        for(int i = 2; i <= sqrt(right); i++){
            if(v[i]){
                for(int j = i*i; j <= right; j += i){
                    v[j] = false;
                }
            }
        }
        int i = left;
        int j;
        int a = -1, b = -1, k = INT_MAX;
        while(i<= right){
            if(v[i])break;
            i++;
        }
        j = i;
        while(j<=right){
            if(v[j]){
                if(j-i<k){
                    k = j-i;
                    a = i,b = j;
                }
                    i = j;
            }
            j++;
        }
        return {a,b};
    }
};",None,"class Solution {
public:
    vector<int> closestPrimes(int left, int right) {
        if(left==1)left++;
        vector<bool> v(right+1,true);
        for(int i = 2; i <= sqrt(right); i++){
            if(v[i]){
                for(int j = i*i; j <= right; j += i){
                    v[j] = false;
                }
            }
        }
        int i = left;
        int j;
        int a = -1, b = -1, k = INT_MAX;
        if(i > right) return {a,b};
        while(i<= right){
            if(v[i])break;
            i++;
        }
        j = i;
        while(j<=right){
            if(v[j]){
                if(j-i<k){
                    k = j-i;
                    a = i,b = j;
                }
            }
            if(j == right && !v[j]) j++; // if j reaches the end of the range and it's not a prime, increment j to check the next number
            else i = j; // if j is a prime or reached the end of the range, reset i to j to check the next pair
        }
        return {a,b};
    }
};
"
1189,cpp,design-twitter,"class Twitter {
    int timer = INT_MAX;
    map<int, map<int, bool>> friends;
    map<int, pair<int, int>> tweets;

public:
    Twitter() {
    }
    
    void postTweet(int userId, int tweetId) {
        tweets[timer--] = {userId, tweetId};
    }
    
    vector<int> getNewsFeed(int userId) {
        vector<int> ans;
        for(auto it: tweets){
            if(it.second.first == userId || friends[userId].find(it.second.first)!=friends[userId].end())
                ans.push_back(it.second.second);
            if(ans.size() == 10) break;
        }
        return ans;
    }
    
    void follow(int followerId, int followeeId) {
        friends[followerId][followerId] = true;
    }
    
    void unfollow(int followerId, int followeeId) {
        friends[followerId].erase(followeeId);
    }
};",None,"class Twitter {
    int timer = INT_MAX;
    map<int, map<int, bool>> friends;
    map<int, pair<int, int>> tweets;

public:
    Twitter() {
    }
    
    void postTweet(int userId, int tweetId) {
        tweets[timer--] = {userId, tweetId};
    }
    
    vector<int> getNewsFeed(int userId) {
        vector<int> ans;
        for(auto it=tweets.rbegin(); it!=tweets.rend() && ans.size()<10; it++){
            if(it->second.first == userId || friends[userId].find(it->second.first)!=friends[userId].end())
                ans.push_back(it->second.second);
        }
        return ans;
    }
    
    void follow(int followerId, int followeeId) {
        friends[followerId][followeeId] = true;
    }
    
    void unfollow(int followerId, int followeeId) {
        friends[followerId].erase(followeeId);
    }
};
"
1189,cpp,design-twitter,"class Twitter {
    int timer = INT_MAX;
    map<int, map<int, bool>> friends;
    map<int, pair<int, int>> tweets;

public:
    Twitter() {
    }
    
    void postTweet(int userId, int tweetId) {
        tweets[timer--] = {userId, tweetId};
    }
    
    vector<int> getNewsFeed(int userId) {
        vector<int> ans;
        for(auto it: tweets){
            if(it.second.first == userId || friends[userId].find(it.second.first)!=friends[userId].end())
                ans.push_back(it.second.second);
            if(ans.size() == 10) break;
        }
        return ans;
    }
    
    void follow(int followerId, int followeeId) {
        friends[followerId][followerId] = true;
    }
    
    void unfollow(int followerId, int followeeId) {
        friends[followerId].erase(followeeId);
    }
};",None,"class Twitter {
    int timer = INT_MAX;
    map<int, map<int, bool>> friends;
    map<int, pair<int, int>> tweets;

public:
    Twitter() {
    }
    
    void postTweet(int userId, int tweetId) {
        tweets[timer--] = {userId, tweetId};
    }
    
    vector<int> getNewsFeed(int userId) {
        vector<int> ans;
        for(auto it=tweets.rbegin(); it!=tweets.rend() && ans.size() < 10; it++){
            auto tweet = *it;
            if(tweet.second.first == userId || friends[userId].find(tweet.second.first)!=friends[userId].end())
                ans.push_back(tweet.second.second);
        }
        return ans;
    }
    
    void follow(int followerId, int followeeId) {
        friends[followerId][followeeId] = true;
    }
    
    void unfollow(int followerId, int followeeId) {
        friends[followerId].erase(followeeId);
    }
};
"
1189,cpp,design-twitter,"class Twitter {
    int timer = INT_MAX;
    map<int, map<int, bool>> friends;
    map<int, pair<int, int>> tweets;

public:
    Twitter() {
    }
    
    void postTweet(int userId, int tweetId) {
        tweets[timer--] = {userId, tweetId};
    }
    
    vector<int> getNewsFeed(int userId) {
        vector<int> ans;
        for(auto it: tweets){
            if(it.second.first == userId || friends[userId].find(it.second.first)!=friends[userId].end())
                ans.push_back(it.second.second);
            if(ans.size() == 10) break;
        }
        return ans;
    }
    
    void follow(int followerId, int followeeId) {
        friends[followerId][followerId] = true;
    }
    
    void unfollow(int followerId, int followeeId) {
        friends[followerId].erase(followeeId);
    }
};",None,"class Twitter {
    int timer = INT_MAX;
    map<int, map<int, bool>> friends;
    map<int, pair<int, int>> tweets;

public:
    Twitter() {
    }
    
    void postTweet(int userId, int tweetId) {
        tweets[timer--] = {userId, tweetId};
    }
    
    vector<int> getNewsFeed(int userId) {
        vector<int> ans;
        for(auto it=tweets.rbegin(); it!=tweets.rend() && ans.size() < 10; it++){
            if(it->second.first == userId || friends[userId].find(it->second.first)!=friends[userId].end())
                ans.push_back(it->second.second);
        }
        return ans;
    }
    
    void follow(int followerId, int followeeId) {
        friends[followerId][followeeId] = true;
    }
    
    void unfollow(int followerId, int followeeId) {
        friends[followerId].erase(followeeId);
    }
};
"
1190,cpp,count-all-possible-routes,"class Solution {
    private:
    int mod = 7+1e9;
public:
    int countRoutes(vector<int>& locations, int start, int finish, int fuel) {
        vector<vector<int>>dp(locations.size()+1, vector<int>(fuel+1, -1));
        return solve(locations, start, finish, fuel, dp);
    }

    int solve(vector<int>& locations, int current, int& finish, int currentfuel, vector<vector<int>>& dp)
    {
        int ans = 0;
        if(current == finish)
        {
            ans = 1;
        }
        if(currentfuel == 0)
        {
            return ans;
        }
        if(dp[current][currentfuel] != -1)
        {
            return dp[finish][currentfuel];
        }
        for(int i = 0;i < locations.size(); i++)
        {
            if(i != current && (currentfuel - abs(locations[current]-locations[i])) >= 0)
            {
                ans = (ans + (solve(locations, i, finish, currentfuel-abs(locations[current]-locations[i]), dp))%mod)%mod;
            }
        }
        return dp[current][currentfuel] = ans%mod;
    }
};",None,"class Solution {
    private:
    const int mod = 1e9 + 7;

public:
    int countRoutes(vector<int>& locations, int start, int finish, int fuel) {
        vector<vector<int>>dp(locations.size()+1, vector<int>(fuel+1, -1));
        return solve(locations, start, finish, fuel, dp);
    }

    int solve(vector<int>& locations, int current, int finish, int currentfuel, vector<vector<int>>& dp)
    {
        int ans = 0;
        if(current == finish)
        {
            ans = 1;
        }
        if(currentfuel == 0)
        {
            return ans;
        }
        if(dp[current][currentfuel] != -1)
        {
            return dp[current][currentfuel];
        }
        for(int i = 0;i < locations.size(); i++)
        {
            if(i != current && (currentfuel - abs(locations[current]-locations[i])) >= 0)
            {
                ans = (ans + solve(locations, i, finish, currentfuel-abs(locations[current]-locations[i]), dp))%mod;
            }
        }
        return dp[current][currentfuel] = ans;
    }
};
"
1190,cpp,count-all-possible-routes,"class Solution {
    private:
    int mod = 7+1e9;
public:
    int countRoutes(vector<int>& locations, int start, int finish, int fuel) {
        vector<vector<int>>dp(locations.size()+1, vector<int>(fuel+1, -1));
        return solve(locations, start, finish, fuel, dp);
    }

    int solve(vector<int>& locations, int current, int& finish, int currentfuel, vector<vector<int>>& dp)
    {
        int ans = 0;
        if(current == finish)
        {
            ans = 1;
        }
        if(currentfuel == 0)
        {
            return ans;
        }
        if(dp[current][currentfuel] != -1)
        {
            return dp[finish][currentfuel];
        }
        for(int i = 0;i < locations.size(); i++)
        {
            if(i != current && (currentfuel - abs(locations[current]-locations[i])) >= 0)
            {
                ans = (ans + (solve(locations, i, finish, currentfuel-abs(locations[current]-locations[i]), dp))%mod)%mod;
            }
        }
        return dp[current][currentfuel] = ans%mod;
    }
};",None,"class Solution {
    private:
    const int mod = 1e9 + 7;

public:
    int countRoutes(vector<int>& locations, int start, int finish, int fuel) {
        vector<vector<int>>dp(locations.size()+1, vector<int>(fuel+1, -1));
        return solve(locations, start, finish, fuel, dp);
    }

    int solve(vector<int>& locations, int current, int finish, int currentfuel, vector<vector<int>>& dp)
    {
        int ans = 0;
        if(current == finish)
        {
            ans = 1;
        }
        if(currentfuel == 0)
        {
            return ans;
        }
        if(dp[current][currentfuel] != -1)
        {
            return dp[current][currentfuel];
        }
        for(int i = 0;i < locations.size(); i++)
        {
            if(i != current && (currentfuel - abs(locations[current]-locations[i])) >= 0)
            {
                ans = (ans + solve(locations, i, finish, currentfuel-abs(locations[current]-locations[i]), dp))%mod;
            }
        }
        return dp[current][currentfuel] = ans%mod;
    }
};
"
1190,cpp,count-all-possible-routes,"class Solution {
    private:
    int mod = 7+1e9;
public:
    int countRoutes(vector<int>& locations, int start, int finish, int fuel) {
        vector<vector<int>>dp(locations.size()+1, vector<int>(fuel+1, -1));
        return solve(locations, start, finish, fuel, dp);
    }

    int solve(vector<int>& locations, int current, int& finish, int currentfuel, vector<vector<int>>& dp)
    {
        int ans = 0;
        if(current == finish)
        {
            ans = 1;
        }
        if(currentfuel == 0)
        {
            return ans;
        }
        if(dp[current][currentfuel] != -1)
        {
            return dp[finish][currentfuel];
        }
        for(int i = 0;i < locations.size(); i++)
        {
            if(i != current && (currentfuel - abs(locations[current]-locations[i])) >= 0)
            {
                ans = (ans + (solve(locations, i, finish, currentfuel-abs(locations[current]-locations[i]), dp))%mod)%mod;
            }
        }
        return dp[current][currentfuel] = ans%mod;
    }
};",None,"class Solution {
    private:
    int mod = 1e9 + 7;
public:
    int countRoutes(vector<int>& locations, int start, int finish, int fuel) {
        vector<vector<int>>dp(locations.size()+1, vector<int>(fuel+1, -1));
        return solve(locations, start, finish, fuel, dp);
    }

    int solve(vector<int>& locations, int current, int finish, int currentfuel, vector<vector<int>>& dp)
    {
        int ans = 0;
        if(current == finish)
        {
            ans = 1;
        }
        if(currentfuel == 0)
        {
            return ans;
        }
        if(dp[current][currentfuel] != -1)
        {
            return dp[current][currentfuel];
        }
        for(int i = 0;i < locations.size(); i++)
        {
            if(i != current && (currentfuel - abs(locations[current]-locations[i])) >= 0)
            {
                ans = (ans + solve(locations, i, finish, currentfuel-abs(locations[current]-locations[i]), dp))%mod;
            }
        }
        return dp[current][currentfuel] = ans%mod;
    }
};
"
1191,cpp,find-the-array-concatenation-value,"class Solution {
public:
    long long findTheArrayConcVal(vector<int>& nums) {
        int i = 0,j=nums.size()-1,x,y;
        long long int ans=0;
        while(i<j){
            x = nums[i];
            y = 0;
            while(x){
                y++;
                x /= 10;
            }
            ans += (nums[i]*1LL*pow(10,y)+nums[j]);
            i++;
            j--;
        }
        if(i==j){
            ans += nums[i];
        }
        return ans;
    }
};",None,"class Solution {
public:
    long long findTheArrayConcVal(vector<int>& nums) {
        int i = 0,j=nums.size()-1,x,y;
        long long int ans=0;
        while(i<j){
            x = nums[i];
            y = nums[j];
            ans += x*1LL*pow(10,(int)log10(x)) + y;
            i++;
            j--;
        }
        if(i==j){
            ans += nums[i];
        }
        return ans;
    }
};
"
1191,cpp,find-the-array-concatenation-value,"class Solution {
public:
    long long findTheArrayConcVal(vector<int>& nums) {
        int i = 0,j=nums.size()-1,x,y;
        long long int ans=0;
        while(i<j){
            x = nums[i];
            y = 0;
            while(x){
                y++;
                x /= 10;
            }
            ans += (nums[i]*1LL*pow(10,y)+nums[j]);
            i++;
            j--;
        }
        if(i==j){
            ans += nums[i];
        }
        return ans;
    }
};",None,"class Solution {
public:
    long long findTheArrayConcVal(vector<int>& nums) {
        int i = 0,j=nums.size()-1;
        long long int ans=0;
        while(i<j){
            ans += (nums[i]*1LL*pow(10,getLength(nums[i]))+nums[j]);
            i++;
            j--;
        }
        if(i==j){
            ans += nums[i];
        }
        return ans;
    }
    int getLength(int num){
        int length = 0;
        while(num){
            length++;
            num /= 10;
        }
        return length;
    }
};
"
1191,cpp,find-the-array-concatenation-value,"class Solution {
public:
    long long findTheArrayConcVal(vector<int>& nums) {
        int i = 0,j=nums.size()-1,x,y;
        long long int ans=0;
        while(i<j){
            x = nums[i];
            y = 0;
            while(x){
                y++;
                x /= 10;
            }
            ans += (nums[i]*1LL*pow(10,y)+nums[j]);
            i++;
            j--;
        }
        if(i==j){
            ans += nums[i];
        }
        return ans;
    }
};",None,"class Solution {
public:
    long long findTheArrayConcVal(vector<int>& nums) {
        int i = 0,j=nums.size()-1,x,y;
        long long int ans=0;
        while(i<j){
            x = nums[i];
            y = nums[j];
            ans += (x*1LL*pow(10,to_string(x).size()) + y);
            i++;
            j--;
        }
        if(i==j){
            ans += nums[i];
        }
        return ans;
    }
};
"
1192,cpp,count-good-numbers,"class Solution {
public:
    int mod=1e9+7;
    int binExpo(long long x,long long n){
        int ans=1;
        while(n){
            if(n&1){
                ans=(ans*x)%mod;
            }
            x=(x*x)%mod;
            n=1;
        }
        return ans;
    }
    int countGoodNumbers(long long n) {
        long long even=n/2+n%2,odd=n/2;
        int even_val=binExpo(5,even);
        int odd_val=binExpo(4,odd);
        return (1ll*even_val*odd_val)%mod;
    }
};",None,"class Solution {
public:
    const int mod = 1e9 + 7;
    int binExpo(long long x, long long n) {
        int ans = 1;
        while (n) {
            if (n & 1) {
                ans = (ans * x) % mod;
            }
            x = (x * x) % mod;
            n >>= 1;
        }
        return ans;
    }

    int countGoodNumbers(long long n) {
        long long even = n / 2 + n % 2, odd = n / 2;
        int even_val = binExpo(5, even);
        int odd_val = binExpo(4, odd);
        return (1ll * even_val * odd_val) % mod;
    }
};
"
1192,cpp,count-good-numbers,"class Solution {
public:
    int mod=1e9+7;
    int binExpo(long long x,long long n){
        int ans=1;
        while(n){
            if(n&1){
                ans=(ans*x)%mod;
            }
            x=(x*x)%mod;
            n=1;
        }
        return ans;
    }
    int countGoodNumbers(long long n) {
        long long even=n/2+n%2,odd=n/2;
        int even_val=binExpo(5,even);
        int odd_val=binExpo(4,odd);
        return (1ll*even_val*odd_val)%mod;
    }
};",None,"class Solution {
public:
    const int mod = 1e9 + 7;
    int binExpo(int x, int n) {
        int ans = 1;
        while (n) {
            if (n & 1) {
                ans = (1ll * ans * x) % mod;
            }
            x = (1ll * x * x) % mod;
            n >>= 1;
        }
        return ans;
    }
    int countGoodNumbers(long long n) {
        long long even = n / 2 + n % 2, odd = n / 2;
        int even_val = binExpo(5, even);
        int odd_val = binExpo(4, odd);
        return (1ll * even_val * odd_val) % mod;
    }
};
"
1192,cpp,count-good-numbers,"class Solution {
public:
    int mod=1e9+7;
    int binExpo(long long x,long long n){
        int ans=1;
        while(n){
            if(n&1){
                ans=(ans*x)%mod;
            }
            x=(x*x)%mod;
            n=1;
        }
        return ans;
    }
    int countGoodNumbers(long long n) {
        long long even=n/2+n%2,odd=n/2;
        int even_val=binExpo(5,even);
        int odd_val=binExpo(4,odd);
        return (1ll*even_val*odd_val)%mod;
    }
};",None,"class Solution {
public:
    const int mod = 1e9 + 7;
    int binExpo(int x, int n) {
        int ans = 1;
        while (n) {
            if (n & 1) {
                ans = (1ll * ans * x) % mod;
            }
            x = (1ll * x * x) % mod;
            n >>= 1;
        }
        return ans;
    }

    int countGoodNumbers(long long n) {
        long long even = n / 2 + n % 2, odd = n / 2;
        int even_val = binExpo(5, even);
        int odd_val = binExpo(4, odd);
        return (1ll * even_val * odd_val) % mod;
    }
};
"
1193,cpp,number-of-subarrays-with-gcd-equal-to-k,"class Solution {
public:
    int subarrayGCD(vector<int>& nums, int k) {
        
        int result = 0;
        
        int n = nums.size();
        
        for (int l = 0; l < n; l++)
        {
            int current_gcd = nums[l];
            for (int r = l; r < n; r++)
            {
                /* 
                We update our current_gcd value in the inner loop. 
                If we somehow reach to k at some point, we'll draw an arrow from our left anchor to the that point. 
                If we found a subarray that has elements with gcd k, increment result.
                We repeat that steps for each left anchor.
                */ 
                current_gcd = gcd(nums[l], nums[r]); 
                if (current_gcd == k)
                    result++;
            }
        }
        return result;
    }
};",None,"class Solution {
public:
    int subarrayGCD(vector<int>& nums, int k) {
        
        int result = 0;
        
        int n = nums.size();
        
        for (int l = 0; l < n; l++)
        {
            int current_gcd = nums[l];
            for (int r = l; r < n; r++)
            {
                current_gcd = gcd(current_gcd, nums[r]);
                if (current_gcd == k)
                    result++;
                else if (current_gcd < k)
                    break;
            }
        }
        return result;
    }
};
"
1193,cpp,number-of-subarrays-with-gcd-equal-to-k,"class Solution {
public:
    int subarrayGCD(vector<int>& nums, int k) {
        
        int result = 0;
        
        int n = nums.size();
        
        for (int l = 0; l < n; l++)
        {
            int current_gcd = nums[l];
            for (int r = l; r < n; r++)
            {
                /* 
                We update our current_gcd value in the inner loop. 
                If we somehow reach to k at some point, we'll draw an arrow from our left anchor to the that point. 
                If we found a subarray that has elements with gcd k, increment result.
                We repeat that steps for each left anchor.
                */ 
                current_gcd = gcd(nums[l], nums[r]); 
                if (current_gcd == k)
                    result++;
            }
        }
        return result;
    }
};",None,"class Solution {
public:
    int subarrayGCD(vector<int>& nums, int k) {
        
        int result = 0;
        
        int n = nums.size();
        
        for (int l = 0; l < n; l++)
        {
            int current_gcd = nums[l];
            for (int r = l; r < n; r++)
            {
                current_gcd = gcd(current_gcd, nums[r]);
                if (current_gcd == k)
                    result++;
                else if (current_gcd < k)
                    break;
            }
        }
        return result;
    }
};
"
1193,cpp,number-of-subarrays-with-gcd-equal-to-k,"class Solution {
public:
    int subarrayGCD(vector<int>& nums, int k) {
        
        int result = 0;
        
        int n = nums.size();
        
        for (int l = 0; l < n; l++)
        {
            int current_gcd = nums[l];
            for (int r = l; r < n; r++)
            {
                /* 
                We update our current_gcd value in the inner loop. 
                If we somehow reach to k at some point, we'll draw an arrow from our left anchor to the that point. 
                If we found a subarray that has elements with gcd k, increment result.
                We repeat that steps for each left anchor.
                */ 
                current_gcd = gcd(nums[l], nums[r]); 
                if (current_gcd == k)
                    result++;
            }
        }
        return result;
    }
};",None,"class Solution {
public:
    int subarrayGCD(vector<int>& nums, int k) {
        
        int result = 0;
        
        int n = nums.size();
        
        for (int l = 0; l < n; l++)
        {
            int current_gcd = nums[l];
            for (int r = l; r < n && current_gcd == k; r++)
            {
                current_gcd = gcd(current_gcd, nums[r]);
                if (current_gcd == k)
                    result++;
            }
        }
        return result;
    }
};
"
1194,cpp,special-array-with-x-elements-greater-than-or-equal-x,"class Solution {
public:
    int specialArray(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(),nums.end(),greater<int>());
        for(int i=1;i<=n;i++){
            int cnt=n;
            for(int j=0;j<n;j++){
                if(nums[j]>=i){
                    cnt++;
                }
            }
            if(cnt==i){
                return i;
            }
        }
        return -1;
    }
};",None,"class Solution {
public:
    int specialArray(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(), nums.end(), greater<int>());
        for (int i = 1; i <= n; i++) {
            if (nums[n - i] < i) {
                return -1;
            }
            if (i == n - i + 1) {
                return i;
            }
        }
        return -1;
    }
};
"
1194,cpp,special-array-with-x-elements-greater-than-or-equal-x,"class Solution {
public:
    int specialArray(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(),nums.end(),greater<int>());
        for(int i=1;i<=n;i++){
            int cnt=n;
            for(int j=0;j<n;j++){
                if(nums[j]>=i){
                    cnt++;
                }
            }
            if(cnt==i){
                return i;
            }
        }
        return -1;
    }
};",None,"class Solution {
public:
    int specialArray(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(), nums.end(), greater<int>());
        for (int i = 1; i <= n; i++) {
            if (nums[n - i] >= i && n - i + 1 >= i) {
                return i;
            }
        }
        return -1;
    }
};
"
1194,cpp,special-array-with-x-elements-greater-than-or-equal-x,"class Solution {
public:
    int specialArray(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(),nums.end(),greater<int>());
        for(int i=1;i<=n;i++){
            int cnt=n;
            for(int j=0;j<n;j++){
                if(nums[j]>=i){
                    cnt++;
                }
            }
            if(cnt==i){
                return i;
            }
        }
        return -1;
    }
};",None,"class Solution {
public:
    int specialArray(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(), nums.end(), greater<int>());
        for(int i=1; i<=n; i++){
            int cnt = 0;
            for(int j=0; j<n; j++){
                if(nums[j]>=i){
                    cnt++;
                }
            }
            if(cnt==i){
                return i;
            }
        }
        return -1;
    }
};
"
1195,cpp,total-appeal-of-a-string,"class Solution {
public:
    long long appealSum(string s) {
        long long int x = 1, y = 1, k = 0;
        vector<int> v(26,-1);

        v[s[0]-'a'] = 1; 
        for(int i = 1; i < s.length(); i++){
            x += i+1;
            if(v[s[i]-'a'] > 0){
                x -= v[s[i]-'a'];
            }
            y += x;
            v[s[i]-'a'] = 0;
        }
        return y;
    }
};",None,"class Solution {
public:
    long long appealSum(string s) {
        long long int x = 1, y = 1, k = 0;
        vector<int> v(26,0);

        v[s[0]-'a']++; 
        for(int i = 1; i < s.length(); i++){
            x += i+1;
            if(v[s[i]-'a'] > 0){
                x -= v[s[i]-'a'];
            }
            y += x;
            v[s[i]-'a']++;
        }
        return y;
    }
};
"
1195,cpp,total-appeal-of-a-string,"class Solution {
public:
    long long appealSum(string s) {
        long long int x = 1, y = 1, k = 0;
        vector<int> v(26,-1);

        v[s[0]-'a'] = 1; 
        for(int i = 1; i < s.length(); i++){
            x += i+1;
            if(v[s[i]-'a'] > 0){
                x -= v[s[i]-'a'];
            }
            y += x;
            v[s[i]-'a'] = 0;
        }
        return y;
    }
};",None,"class Solution {
public:
    long long appealSum(string s) {
        long long int x = 1, y = 1, k = 0;
        vector<int> v(26,-1);

        v[s[0]-'a'] = 1; 
        for(int i = 1; i < s.length(); i++){
            x += i+1;
            if(v[s[i]-'a'] != -1){
                x -= v[s[i]-'a'] + 1;
            }
            y += x;
            v[s[i]-'a'] = i;
        }
        return y;
    }
};
"
1195,cpp,total-appeal-of-a-string,"class Solution {
public:
    long long appealSum(string s) {
        long long int x = 1, y = 1, k = 0;
        vector<int> v(26,-1);

        v[s[0]-'a'] = 1; 
        for(int i = 1; i < s.length(); i++){
            x += i+1;
            if(v[s[i]-'a'] > 0){
                x -= v[s[i]-'a'];
            }
            y += x;
            v[s[i]-'a'] = 0;
        }
        return y;
    }
};",None,"class Solution {
public:
    long long appealSum(string s) {
        long long int x = 1, y = 1, k = 0;
        vector<int> v(26,0);

        v[s[0]-'a']++; 
        for(int i = 1; i < s.length(); i++){
            x += i+1;
            if(v[s[i]-'a'] > 0){
                x -= v[s[i]-'a'];
            }
            y += x;
            v[s[i]-'a']++;
        }
        return y;
    }
};
"
1196,cpp,destination-city,"class Solution {
public:
    string destCity(vector<vector<string>>& paths) {
        unordered_set<string> st;
        for (auto row : paths)st.insert(row[0]); 
        for (auto row : paths)if(st.count(row[0]) > 0) st.erase(row[0]);
        return *st.begin();
    }
};",None,"class Solution {
public:
    string destCity(vector<vector<string>>& paths) {
        unordered_set<string> st;
        for (auto row : paths)st.insert(row[1]); 
        for (auto row : paths)st.erase(row[0]);
        return *st.begin();
    }
};
"
1196,cpp,destination-city,"class Solution {
public:
    string destCity(vector<vector<string>>& paths) {
        unordered_set<string> st;
        for (auto row : paths)st.insert(row[0]); 
        for (auto row : paths)if(st.count(row[0]) > 0) st.erase(row[0]);
        return *st.begin();
    }
};",None,"class Solution {
public:
    string destCity(vector<vector<string>>& paths) {
        unordered_set<string> st;
        for (auto row : paths)st.insert(row[1]); 
        for (auto row : paths)st.erase(row[0]);
        return *st.begin();
    }
};
"
1196,cpp,destination-city,"class Solution {
public:
    string destCity(vector<vector<string>>& paths) {
        unordered_set<string> st;
        for (auto row : paths)st.insert(row[0]); 
        for (auto row : paths)if(st.count(row[0]) > 0) st.erase(row[0]);
        return *st.begin();
    }
};",None,"class Solution {
public:
    string destCity(vector<vector<string>>& paths) {
        unordered_set<string> st;
        for (auto row : paths) st.insert(row[1]);
        for (auto row : paths) {
            if (st.count(row[0]) > 0) {
                st.erase(row[0]);
            }
        }
        return *st.begin();
    }
};
"
1197,cpp,reduction-operations-to-make-the-array-elements-equal,"class Solution {
public:
    int reductionOperations(vector<int>& nums) {
        int ans = 0;
        map<int,int> mp;
        for(auto &i: nums){
            mp[i]++;
        }
        auto it = mp.begin();
        while(mp.begin() != --it){
            auto x = it;
            --x;
            ans += it->second;
            x->second += it->second;
        }
        return ans;
    }
};",None,"class Solution {
public:
    int reductionOperations(vector<int>& nums) {
        int ans = 0;
        map<int,int> mp;
        for(auto &i: nums){
            mp[i]++;
        }
        auto it = mp.rbegin();
        while(it != mp.rend()){
            auto x = it;
            ++x;
            ans += it->second;
            if(x != mp.rend()){
                x->second += it->second;
            }
            it++;
        }
        return ans;
    }
};
"
1197,cpp,reduction-operations-to-make-the-array-elements-equal,"class Solution {
public:
    int reductionOperations(vector<int>& nums) {
        int ans = 0;
        map<int,int> mp;
        for(auto &i: nums){
            mp[i]++;
        }
        auto it = mp.begin();
        while(mp.begin() != --it){
            auto x = it;
            --x;
            ans += it->second;
            x->second += it->second;
        }
        return ans;
    }
};",None,"class Solution {
public:
    int reductionOperations(vector<int>& nums) {
        int ans = 0;
        map<int,int> mp;
        for(auto &i: nums){
            mp[i]++;
        }
        auto it = mp.rbegin();
        while(it != mp.rend()){
            auto x = it;
            ++x;
            ans += it->second;
            x->second += it->second;
            it++;
        }
        return ans;
    }
};
"
1197,cpp,reduction-operations-to-make-the-array-elements-equal,"class Solution {
public:
    int reductionOperations(vector<int>& nums) {
        int ans = 0;
        map<int,int> mp;
        for(auto &i: nums){
            mp[i]++;
        }
        auto it = mp.begin();
        while(mp.begin() != --it){
            auto x = it;
            --x;
            ans += it->second;
            x->second += it->second;
        }
        return ans;
    }
};",None,"class Solution {
public:
    int reductionOperations(vector<int>& nums) {
        int ans = 0;
        map<int,int> mp;
        for(auto &i: nums){
            mp[i]++;
        }
        auto it = mp.rbegin();
        while(mp.rbegin() != --it){
            auto x = it;
            --x;
            ans += it->second;
            x->second += it->second;
        }
        return ans;
    }
};
"
1198,cpp,greatest-common-divisor-of-strings,"class Solution {
public:
    string gcdOfStrings(string str1, string str2) {

        if(str1+str2==str2+str1)
        {
            return str1.substr(0,gcd(str1.length(),str2.length()));
        }
        else{
            return "" "";
        }
        
    }
};",None,"class Solution {
public:
    string gcdOfStrings(string str1, string str2) {
        if(str1+str2 != str2+str1) {
            return """";
        }
        return str1.substr(0, gcd(str1.length(), str2.length()));
    }
};
"
1198,cpp,greatest-common-divisor-of-strings,"class Solution {
public:
    string gcdOfStrings(string str1, string str2) {

        if(str1+str2==str2+str1)
        {
            return str1.substr(0,gcd(str1.length(),str2.length()));
        }
        else{
            return "" "";
        }
        
    }
};",None,"class Solution {
public:
    string gcdOfStrings(string str1, string str2) {

        string longer = str1.length() > str2.length() ? str1 : str2;
        string shorter = str1.length() > str2.length() ? str2 : str1;

        while (shorter.length() > 0) {
            string temp = longer.substr(0, shorter.length());
            if (longer.length() % shorter.length() != 0 || longer != temp * (longer.length() / shorter.length())) {
                return """";
            }
            longer = temp;
            string temp2 = shorter;
            shorter = longer;
            longer = temp2;
        }
        return longer;
    }
};
"
1198,cpp,greatest-common-divisor-of-strings,"class Solution {
public:
    string gcdOfStrings(string str1, string str2) {

        if(str1+str2==str2+str1)
        {
            return str1.substr(0,gcd(str1.length(),str2.length()));
        }
        else{
            return "" "";
        }
        
    }
};",None,"class Solution {
public:
    string gcdOfStrings(string str1, string str2) {
        if(str1+str2!=str2+str1)
            return """";
        return str1.substr(0, gcd(str1.length(), str2.length()));
    }
};
"
1438,java,relative-sort-array,"import java.util.Arrays;

class Solution {
    public int[] relativeSortArray(int[] arr1, int[] arr2) {
        Arrays.sort(arr1);
        int[] ans = new int[arr1.length];
        int start = 0;
        int end = arr1.length - 1;
        int index = 0;

        for (int i = 0; i < arr2.length; i++) {
            int target = arr2[i];
            start = 0;
            end = arr1.length - 1;

            while (end >= start) {
                int mid = start + (end - start) / 2;
                if (arr1[mid] == target) {
                    for (int j = start; j <= end; j++) {
                        if (arr1[j] == target) {
                            ans[index++] = arr1[j];
                            arr1[j] = -1;
                        }
                    }
                    break;
                }
                if (arr1[mid] < target) {
                    start = mid + 1;
                } else {
                    end = mid - 1;
                }
            }
        }

        Arrays.sort(arr1);

        for (int i = 0; i < arr1.length; i++) {
            if (index == arr1.length) {
                break;
            }
            boolean found = false;
            for (int num : arr2) {
                if (arr1[i] == num) {
                    found = true;
                    break;
                }
            }
            if (!found && arr1[i] != -1) {
                ans[index++] = arr1[i];
            }
        }

        return ans;
    }
}",None,"import java.util.Arrays;

class Solution {
    public int[] relativeSortArray(int[] arr1, int[] arr2) {
        int[] count = new int[1001];
        for (int num : arr1) {
            count[num]++;
        }
        int[] ans = new int[arr1.length];
        int index = 0;

        for (int num : arr2) {
            while (count[num]-- > 0) {
                ans[index++] = num;
            }
        }

        for (int i = 0; i < count.length; i++) {
            while (count[i]-- > 0) {
                ans[index++] = i;
            }
        }

        return ans;
    }
}
"
1438,java,relative-sort-array,"import java.util.Arrays;

class Solution {
    public int[] relativeSortArray(int[] arr1, int[] arr2) {
        Arrays.sort(arr1);
        int[] ans = new int[arr1.length];
        int start = 0;
        int end = arr1.length - 1;
        int index = 0;

        for (int i = 0; i < arr2.length; i++) {
            int target = arr2[i];
            start = 0;
            end = arr1.length - 1;

            while (end >= start) {
                int mid = start + (end - start) / 2;
                if (arr1[mid] == target) {
                    for (int j = start; j <= end; j++) {
                        if (arr1[j] == target) {
                            ans[index++] = arr1[j];
                            arr1[j] = -1;
                        }
                    }
                    break;
                }
                if (arr1[mid] < target) {
                    start = mid + 1;
                } else {
                    end = mid - 1;
                }
            }
        }

        Arrays.sort(arr1);

        for (int i = 0; i < arr1.length; i++) {
            if (index == arr1.length) {
                break;
            }
            boolean found = false;
            for (int num : arr2) {
                if (arr1[i] == num) {
                    found = true;
                    break;
                }
            }
            if (!found && arr1[i] != -1) {
                ans[index++] = arr1[i];
            }
        }

        return ans;
    }
}",None,"import java.util.Arrays;

class Solution {
    public int[] relativeSortArray(int[] arr1, int[] arr2) {
        int[] count = new int[1001];
        for (int num : arr1) {
            count[num]++;
        }

        int[] ans = new int[arr1.length];
        int index = 0;
        for (int num : arr2) {
            for (int i = 0; i < count[num]; i++) {
                ans[index++] = num;
            }
            count[num] = 0;
        }

        for (int i = 0; i < count.length; i++) {
            if (count[i] > 0) {
                for (int j = 0; j < count[i]; j++) {
                    ans[index++] = i;
                }
            }
        }

        return ans;
    }
}
"
1438,java,relative-sort-array,"import java.util.Arrays;

class Solution {
    public int[] relativeSortArray(int[] arr1, int[] arr2) {
        Arrays.sort(arr1);
        int[] ans = new int[arr1.length];
        int start = 0;
        int end = arr1.length - 1;
        int index = 0;

        for (int i = 0; i < arr2.length; i++) {
            int target = arr2[i];
            start = 0;
            end = arr1.length - 1;

            while (end >= start) {
                int mid = start + (end - start) / 2;
                if (arr1[mid] == target) {
                    for (int j = start; j <= end; j++) {
                        if (arr1[j] == target) {
                            ans[index++] = arr1[j];
                            arr1[j] = -1;
                        }
                    }
                    break;
                }
                if (arr1[mid] < target) {
                    start = mid + 1;
                } else {
                    end = mid - 1;
                }
            }
        }

        Arrays.sort(arr1);

        for (int i = 0; i < arr1.length; i++) {
            if (index == arr1.length) {
                break;
            }
            boolean found = false;
            for (int num : arr2) {
                if (arr1[i] == num) {
                    found = true;
                    break;
                }
            }
            if (!found && arr1[i] != -1) {
                ans[index++] = arr1[i];
            }
        }

        return ans;
    }
}",None,"import java.util.Arrays;

class Solution {
    public int[] relativeSortArray(int[] arr1, int[] arr2) {
        int[] count = new int[1001];
        for (int num : arr1) {
            count[num]++;
        }

        int[] ans = new int[arr1.length];
        int index = 0;
        for (int num : arr2) {
            while (count[num]-- > 0) {
                ans[index++] = num;
            }
        }

        for (int i = 0; i < count.length; i++) {
            while (count[i]-- > 0) {
                ans[index++] = i;
            }
        }

        return ans;
    }
}
"
1439,java,maximum-product-of-splitted-binary-tree,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        def dfs(node):
            if node:
                dfs(node.left)
                dfs(node.right)
                if node.left and node.right:
                    node.val += node.left.val + node.right.val
                elif node.left and not node.right:
                    node.val += node.left.val
                elif node.right:
                    node.val += node.right.val
                elif node.val:
                    node.val += node.val
        dfs(root)

        ans, val = 0, root.val
        def f(node):
            nonlocal ans
            if node:
                ans = max(ans, (val - node.val) * node.val)
                f(node.left)
                f(node.right)
        f(root)
        return ans % 1000000007",None,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        self.total = 0
        def dfs(node):
            if node:
                dfs(node.left)
                dfs(node.right)
                if node.left and node.right:
                    node.val = node.left.val + node.right.val + node.val
                    self.total += node.val
                elif node.left and not node.right:
                    node.val += node.left.val
                    self.total += node.val
                elif node.right:
                    node.val += node.right.val
                    self.total += node.val
                elif node.val:
                    self.total += node.val

        dfs(root)

        def dfs2(node):
            if not node:
                return 0
            prod = (self.total - node.val) * node.val
            return max(prod, dfs2(node.left), dfs2(node.right))

        return dfs2(root) % 1000000007
"
1439,java,maximum-product-of-splitted-binary-tree,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        def dfs(node):
            if node:
                dfs(node.left)
                dfs(node.right)
                if node.left and node.right:
                    node.val += node.left.val + node.right.val
                elif node.left and not node.right:
                    node.val += node.left.val
                elif node.right:
                    node.val += node.right.val
                elif node.val:
                    node.val += node.val
        dfs(root)

        ans, val = 0, root.val
        def f(node):
            nonlocal ans
            if node:
                ans = max(ans, (val - node.val) * node.val)
                f(node.left)
                f(node.right)
        f(root)
        return ans % 1000000007",None,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        self.total = 0
        def dfs(node):
            if not node:
                return 0
            left_sum = dfs(node.left)
            right_sum = dfs(node.right)
            self.total += node.val
            return node.val + left_sum + right_sum

        dfs(root)

        def dfs(node):
            if not node:
                return 0
            left_sum = dfs(node.left)
            right_sum = dfs(node.right)
            nonlocal ans
            ans = max(ans, (self.total - node.val - left_sum - right_sum) * (node.val + left_sum + right_sum))
            return node.val + left_sum + right_sum

        ans = 0
        dfs(root)
        return ans % 1000000007
"
1439,java,maximum-product-of-splitted-binary-tree,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        def dfs(node):
            if node:
                dfs(node.left)
                dfs(node.right)
                if node.left and node.right:
                    node.val += node.left.val + node.right.val
                elif node.left and not node.right:
                    node.val += node.left.val
                elif node.right:
                    node.val += node.right.val
                elif node.val:
                    node.val += node.val
        dfs(root)

        ans, val = 0, root.val
        def f(node):
            nonlocal ans
            if node:
                ans = max(ans, (val - node.val) * node.val)
                f(node.left)
                f(node.right)
        f(root)
        return ans % 1000000007",None,"class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        self.total = 0
        def dfs(node):
            if not node:
                return 0
            val = node.val + dfs(node.left) + dfs(node.right)
            self.total += val
            return val
        dfs(root)

        def dfs(node):
            if not node:
                return 0
            left_val = dfs(node.left)
            right_val = dfs(node.right)
            self.ans = max(self.ans, (self.total - left_val - right_val) * (left_val + right_val))
            return left_val + right_val + node.val
        dfs(root)
        return self.ans % 1000000007
"
1440,java,count-negative-numbers-in-a-sorted-matrix,"class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        ROWS, COLS = len(grid), len(grid[0])
        negatives = 0
        col = 0
        for row in range(ROWS - 1, -1, -1):
            while col < COLS and grid[row][col] >= 0:
                col += 1
            negatives += COLS
        return negatives",None,"class Solution {
    public int countNegatives(int[][] grid) {
        int ROWS = grid.length;
        int COLS = grid[0].length;
        int negatives = 0;
        int col = 0;
        for (int row = ROWS - 1; row >= 0; row--) {
            while (col < COLS && grid[row][col] >= 0) {
                col++;
            }
            negatives += (COLS - col);
        }
        return negatives;
    }
}
"
1440,java,count-negative-numbers-in-a-sorted-matrix,"class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        ROWS, COLS = len(grid), len(grid[0])
        negatives = 0
        col = 0
        for row in range(ROWS - 1, -1, -1):
            while col < COLS and grid[row][col] >= 0:
                col += 1
            negatives += COLS
        return negatives",None,"class Solution {
    public int countNegatives(int[][] grid) {
        int ROWS = grid.length;
        int COLS = grid[0].length;
        int negatives = 0;
        int col = 0;
        for (int row = ROWS - 1; row >= 0; row--) {
            while (col < COLS && grid[row][col] >= 0) {
                col++;
            }
            negatives += COLS - col;
        }
        return negatives;
    }
}
"
1440,java,count-negative-numbers-in-a-sorted-matrix,"class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        ROWS, COLS = len(grid), len(grid[0])
        negatives = 0
        col = 0
        for row in range(ROWS - 1, -1, -1):
            while col < COLS and grid[row][col] >= 0:
                col += 1
            negatives += COLS
        return negatives",None,"class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        ROWS, COLS = len(grid), len(grid[0])
        negatives = 0
        col = 0
        for row in range(ROWS - 1, -1, -1):
            while col < COLS and grid[row][col] >= 0:
                col += 1
            negatives += COLS - col
        return negatives
"
1441,java,rearrange-characters-to-make-target-string,"class Solution {
    public int rearrangeCharacters(String s, String target) {
        int[] cnt1 = new int[26];
        int[] cnt2 = new int[26];
        for (int i = 0; i < s.length(); ++i) {
            ++cnt1[s.charAt(i) - 'a'];
        }
        for (int i = 0; i < target.length(); ++i) {
            ++cnt2[target.charAt(i) - 'a'];
        }
        int ans = 100;
        for (int i = 0; i < 26; ++i) {
            if (cnt2[i] > 0) {
                ans = Math.min(ans, cnt1[i]);
            }
        }
        return ans;
    }
}",None,"class Solution {
    public int rearrangeCharacters(String s, String target) {
        int[] cnt1 = new int[26];
        int[] cnt2 = new int[26];
        for (int i = 0; i < s.length(); ++i) {
            ++cnt1[s.charAt(i) - 'a'];
        }
        for (int i = 0; i < target.length(); ++i) {
            ++cnt2[target.charAt(i) - 'a'];
        }
        int ans = Integer.MAX_VALUE;
        for (int i = 0; i < 26; ++i) {
            if (cnt2[i] > 0) {
                ans = Math.min(ans, cnt1[i] / cnt2[i]);
            }
        }
        return ans;
    }
}
"
1441,java,rearrange-characters-to-make-target-string,"class Solution {
    public int rearrangeCharacters(String s, String target) {
        int[] cnt1 = new int[26];
        int[] cnt2 = new int[26];
        for (int i = 0; i < s.length(); ++i) {
            ++cnt1[s.charAt(i) - 'a'];
        }
        for (int i = 0; i < target.length(); ++i) {
            ++cnt2[target.charAt(i) - 'a'];
        }
        int ans = 100;
        for (int i = 0; i < 26; ++i) {
            if (cnt2[i] > 0) {
                ans = Math.min(ans, cnt1[i]);
            }
        }
        return ans;
    }
}",None,"class Solution {
    public int rearrangeCharacters(String s, String target) {
        int[] cnt1 = new int[26];
        int[] cnt2 = new int[26];
        for (int i = 0; i < s.length(); ++i) {
            ++cnt1[s.charAt(i) - 'a'];
        }
        for (int i = 0; i < target.length(); ++i) {
            ++cnt2[target.charAt(i) - 'a'];
        }
        int ans = Integer.MAX_VALUE;
        for (int i = 0; i < 26; ++i) {
            if (cnt2[i] > 0) {
                ans = Math.min(ans, cnt1[i] / cnt2[i]);
            }
        }
        return ans;
    }
}
"
1441,java,rearrange-characters-to-make-target-string,"class Solution {
    public int rearrangeCharacters(String s, String target) {
        int[] cnt1 = new int[26];
        int[] cnt2 = new int[26];
        for (int i = 0; i < s.length(); ++i) {
            ++cnt1[s.charAt(i) - 'a'];
        }
        for (int i = 0; i < target.length(); ++i) {
            ++cnt2[target.charAt(i) - 'a'];
        }
        int ans = 100;
        for (int i = 0; i < 26; ++i) {
            if (cnt2[i] > 0) {
                ans = Math.min(ans, cnt1[i]);
            }
        }
        return ans;
    }
}",None,"class Solution {
    public int rearrangeCharacters(String s, String target) {
        int[] cnt1 = new int[26];
        int[] cnt2 = new int[26];
        for (int i = 0; i < s.length(); ++i) {
            ++cnt1[s.charAt(i) - 'a'];
        }
        for (int i = 0; i < target.length(); ++i) {
            ++cnt2[target.charAt(i) - 'a'];
        }
        int ans = Integer.MAX_VALUE;
        for (int i = 0; i < 26; ++i) {
            if (cnt2[i] > 0) {
                ans = Math.min(ans, cnt1[i] / cnt2[i]);
            }
        }
        return ans;
    }
}
"
1442,java,pass-the-pillow,"class Solution {
    public int passThePillow(int n, int time) {
        int num=(time/(n-1));
        if(n>time){
            return time;
        }
        if(num%2==1){
            return n-((time%(n-1)));
        }
            
        return (time%(n-1))+1;
    }
}",None,"class Solution {
    public int passThePillow(int n, int time) {
        int num=(time/(n-1));
        if(n>time){
            return time%n;
        }
        if(num%2==1){
            return n-((time%(n-1)));
        }
        return (time%(n-1))+1;
    }
}
"
1442,java,pass-the-pillow,"class Solution {
    public int passThePillow(int n, int time) {
        int num=(time/(n-1));
        if(n>time){
            return time;
        }
        if(num%2==1){
            return n-((time%(n-1)));
        }
            
        return (time%(n-1))+1;
    }
}",None,"class Solution {
    public int passThePillow(int n, int time) {
        int num=(time/(n-1));
        if(n>time){
            return time;
        }
        if(num%2==1){
            return n-((time%(n-1))+1);
        }
            
        return (time%(n-1))+1;
    }
}
"
1442,java,pass-the-pillow,"class Solution {
    public int passThePillow(int n, int time) {
        int num=(time/(n-1));
        if(n>time){
            return time;
        }
        if(num%2==1){
            return n-((time%(n-1)));
        }
            
        return (time%(n-1))+1;
    }
}",None,"class Solution {
    public int passThePillow(int n, int time) {
        int num=(time/(n-1));
        if(n>time){
            return time;
        }
        if(num%2==1){
            return n-((time%(n-1))+1);
        }
        return (time%(n-1))+1;
    }
}
"
1443,java,add-binary,"import java.math.BigInteger;
class Solution {
    public String addBinary(String a, String b) {
        BigInteger A=new BigInteger(a,2);
        BigInteger B=new BigInteger(b,2);
        BigInteger c=A.add(B);
        return c.toString(10);
    }
}",None,"import java.math.BigInteger;
class Solution {
    public String addBinary(String a, String b) {
        BigInteger A=new BigInteger(a,2);
        BigInteger B=new BigInteger(b,2);
        BigInteger c=A.add(B);
        return c.toString(2);
    }
}
"
1443,java,add-binary,"import java.math.BigInteger;
class Solution {
    public String addBinary(String a, String b) {
        BigInteger A=new BigInteger(a,2);
        BigInteger B=new BigInteger(b,2);
        BigInteger c=A.add(B);
        return c.toString(10);
    }
}",None,"import java.math.BigInteger;
class Solution {
    public String addBinary(String a, String b) {
        BigInteger A=new BigInteger(a,2);
        BigInteger B=new BigInteger(b,2);
        BigInteger c=A.add(B);
        return c.toString(2);
    }
}
"
1443,java,add-binary,"import java.math.BigInteger;
class Solution {
    public String addBinary(String a, String b) {
        BigInteger A=new BigInteger(a,2);
        BigInteger B=new BigInteger(b,2);
        BigInteger c=A.add(B);
        return c.toString(10);
    }
}",None,"import java.math.BigInteger;
class Solution {
    public String addBinary(String a, String b) {
        BigInteger A=new BigInteger(a,2);
        BigInteger B=new BigInteger(b,2);
        BigInteger c=A.add(B);
        return c.toString(2);
    }
}
"
1444,java,design-authentication-manager,"class AuthenticationManager {

    int time=0;

    HashMap<String,Integer>mp=new HashMap<>();

    public AuthenticationManager(int timeToLive) {
        
    time=timeToLive;

    }
    
    public void generate(String tokenId, int currentTime) {
        
    mp.put(tokenId,currentTime);

    }
    
    public void renew(String tokenId, int currentTime) {
        
    if(!mp.containsKey(tokenId)||mp.get(tokenId)<=currentTime)
    {
    return;
    }

    mp.put(tokenId,currentTime+time);

    }
    
    public int countUnexpiredTokens(int currentTime) {
    
    List<String>lr=new ArrayList<>(mp.keySet());
    
    for(int i=0;i<lr.size();i++){
    
    if(mp.get(lr.get(i))<=currentTime)mp.remove(lr.get(i));

    }

    return mp.size();
    
    }
}
/**
 * Your AuthenticationManager object will be instantiated and called as such:
 * AuthenticationManager obj = new AuthenticationManager(timeToLive);
 * obj.generate(tokenId,currentTime);
 * obj.renew(tokenId,currentTime);
 * int param_3 = obj.countUnexpiredTokens(currentTime);
 */",None,"class AuthenticationManager {

    int time=0;

    HashMap<String,Integer>mp=new HashMap<>();

    public AuthenticationManager(int timeToLive) {
        
        time=timeToLive;

    }
    
    public void generate(String tokenId, int currentTime) {
        
        mp.put(tokenId,currentTime+time);

    }
    
    public void renew(String tokenId, int currentTime) {
        
        if(!mp.containsKey(tokenId)||mp.get(tokenId)<=currentTime)
        {
            return;
        }

        mp.put(tokenId,currentTime+time);

    }
    
    public int countUnexpiredTokens(int currentTime) {
        
        List<String>lr=new ArrayList<>(mp.keySet());

        for(int i=0;i<lr.size();i++){
            
            if(mp.get(lr.get(i))<=currentTime)
                mp.remove(lr.get(i));

        }

        return mp.size();
        
    }
}
"
1444,java,design-authentication-manager,"class AuthenticationManager {

    int time=0;

    HashMap<String,Integer>mp=new HashMap<>();

    public AuthenticationManager(int timeToLive) {
        
    time=timeToLive;

    }
    
    public void generate(String tokenId, int currentTime) {
        
    mp.put(tokenId,currentTime);

    }
    
    public void renew(String tokenId, int currentTime) {
        
    if(!mp.containsKey(tokenId)||mp.get(tokenId)<=currentTime)
    {
    return;
    }

    mp.put(tokenId,currentTime+time);

    }
    
    public int countUnexpiredTokens(int currentTime) {
    
    List<String>lr=new ArrayList<>(mp.keySet());
    
    for(int i=0;i<lr.size();i++){
    
    if(mp.get(lr.get(i))<=currentTime)mp.remove(lr.get(i));

    }

    return mp.size();
    
    }
}
/**
 * Your AuthenticationManager object will be instantiated and called as such:
 * AuthenticationManager obj = new AuthenticationManager(timeToLive);
 * obj.generate(tokenId,currentTime);
 * obj.renew(tokenId,currentTime);
 * int param_3 = obj.countUnexpiredTokens(currentTime);
 */",None,"class AuthenticationManager {

    int time=0;
    HashMap<String,Integer>mp=new HashMap<>();

    public AuthenticationManager(int timeToLive) {
        time=timeToLive;
    }
    
    public void generate(String tokenId, int currentTime) {
        mp.put(tokenId,currentTime + time);
    }
    
    public void renew(String tokenId, int currentTime) {
        if(!mp.containsKey(tokenId)||mp.get(tokenId)<=currentTime) {
            return;
        }
        mp.put(tokenId,currentTime + time);
    }
    
    public int countUnexpiredTokens(int currentTime) {
        List<String>lr=new ArrayList<>(mp.keySet());
        int count=0;
        for(int i=0;i<lr.size();i++){
            if(mp.get(lr.get(i))>currentTime)
            count++;
            else mp.remove(lr.get(i));
        }
        return count;
    }
}
"
1444,java,design-authentication-manager,"class AuthenticationManager {

    int time=0;

    HashMap<String,Integer>mp=new HashMap<>();

    public AuthenticationManager(int timeToLive) {
        
    time=timeToLive;

    }
    
    public void generate(String tokenId, int currentTime) {
        
    mp.put(tokenId,currentTime);

    }
    
    public void renew(String tokenId, int currentTime) {
        
    if(!mp.containsKey(tokenId)||mp.get(tokenId)<=currentTime)
    {
    return;
    }

    mp.put(tokenId,currentTime+time);

    }
    
    public int countUnexpiredTokens(int currentTime) {
    
    List<String>lr=new ArrayList<>(mp.keySet());
    
    for(int i=0;i<lr.size();i++){
    
    if(mp.get(lr.get(i))<=currentTime)mp.remove(lr.get(i));

    }

    return mp.size();
    
    }
}
/**
 * Your AuthenticationManager object will be instantiated and called as such:
 * AuthenticationManager obj = new AuthenticationManager(timeToLive);
 * obj.generate(tokenId,currentTime);
 * obj.renew(tokenId,currentTime);
 * int param_3 = obj.countUnexpiredTokens(currentTime);
 */",None,"class AuthenticationManager {

    int time=0;

    HashMap<String,Integer>mp=new HashMap<>();

    public AuthenticationManager(int timeToLive) {
        
        time=timeToLive;

    }
    
    public void generate(String tokenId, int currentTime) {
        
        mp.put(tokenId,currentTime+time);

    }
    
    public void renew(String tokenId, int currentTime) {
        
        if(!mp.containsKey(tokenId)||mp.get(tokenId)<=currentTime)
        {
            return;
        }

        mp.put(tokenId,currentTime+time);

    }
    
    public int countUnexpiredTokens(int currentTime) {
        
        List<String>lr=new ArrayList<>(mp.keySet());
        
        for(int i=0;i<lr.size();i++){
        
            if(mp.get(lr.get(i))<=currentTime)
            {
                mp.remove(lr.get(i));
            }

        }

        return mp.size();
        
    }
}
"
1445,java,design-a-stack-with-increment-operation,"class CustomStack:

    def __init__(self, maxSize: int):
        self.arr = []
        self.m = maxSize
        self.top = -1

    def push(self, x: int) -> None:
        if self.top < self.m - 1:
            self.arr.append(x)
            self.top += 1

    def pop(self) -> int:
        if self.top == -1: return -1
        self.top -= 1
        return(self.arr.pop(self.top))

    def increment(self, k: int, val: int) -> None:
        for i in range(min(k, self.top + 1)): self.arr[i] += val",None,"class CustomStack:

    def __init__(self, maxSize: int):
        self.arr = []
        self.m = maxSize
        self.top = -1

    def push(self, x: int) -> None:
        if self.top < self.m - 1:
            self.arr.append(x)
            self.top += 1

    def pop(self) -> int:
        if self.top == -1: return -1
        self.top -= 1
        return self.arr.pop()

    def increment(self, k: int, val: int) -> None:
        for i in range(min(k, self.top + 1)):
            self.arr[i] += val
"
1445,java,design-a-stack-with-increment-operation,"class CustomStack:

    def __init__(self, maxSize: int):
        self.arr = []
        self.m = maxSize
        self.top = -1

    def push(self, x: int) -> None:
        if self.top < self.m - 1:
            self.arr.append(x)
            self.top += 1

    def pop(self) -> int:
        if self.top == -1: return -1
        self.top -= 1
        return(self.arr.pop(self.top))

    def increment(self, k: int, val: int) -> None:
        for i in range(min(k, self.top + 1)): self.arr[i] += val",None,"class CustomStack:

    def __init__(self, maxSize: int):
        self.arr = []
        self.m = maxSize
        self.top = -1

    def push(self, x: int) -> None:
        if self.top < self.m - 1:
            self.arr.append(x)
            self.top += 1

    def pop(self) -> int:
        if self.top == -1: return -1
        self.top -= 1
        return(self.arr[self.top + 1])

    def increment(self, k: int, val: int) -> None:
        for i in range(min(k, self.top + 1)): self.arr[i] += val
"
1445,java,design-a-stack-with-increment-operation,"class CustomStack:

    def __init__(self, maxSize: int):
        self.arr = []
        self.m = maxSize
        self.top = -1

    def push(self, x: int) -> None:
        if self.top < self.m - 1:
            self.arr.append(x)
            self.top += 1

    def pop(self) -> int:
        if self.top == -1: return -1
        self.top -= 1
        return(self.arr.pop(self.top))

    def increment(self, k: int, val: int) -> None:
        for i in range(min(k, self.top + 1)): self.arr[i] += val",None,"class CustomStack:

    def __init__(self, maxSize: int):
        self.arr = []
        self.m = maxSize
        self.top = -1

    def push(self, x: int) -> None:
        if self.top < self.m - 1:
            self.arr.append(x)
            self.top += 1

    def pop(self) -> int:
        if self.top == -1: return -1
        self.top -= 1
        return(self.arr[self.top + 1])

    def increment(self, k: int, val: int) -> None:
        for i in range(min(k, self.top + 1)): self.arr[i] += val
"
1446,java,n-th-tribonacci-number,"class Solution {
    public int tribonacci(int n) {
        if(n==0)return 0;
        if(n==1||n==2) return 1;
        int dp[]=new int[n+1];
        dp[0]=0;
        dp[1]=1;
        dp[2]=1;
        for(int i=3;i<=n;i++){
            dp[i]=dp[i-1]+dp[i-2]+dp[i-4];
        }
        return dp[n];
    }
}",None,"class Solution {
    public int tribonacci(int n) {
        if(n==0)return 0;
        if(n==1||n==2) return 1;
        int dp[]=new int[n+1];
        dp[0]=0;
        dp[1]=1;
        dp[2]=1;
        for(int i=3;i<=n;i++){
            dp[i]=dp[i-1]+dp[i-2]+dp[i-3];
        }
        return dp[n];
    }
}
"
1446,java,n-th-tribonacci-number,"class Solution {
    public int tribonacci(int n) {
        if(n==0)return 0;
        if(n==1||n==2) return 1;
        int dp[]=new int[n+1];
        dp[0]=0;
        dp[1]=1;
        dp[2]=1;
        for(int i=3;i<=n;i++){
            dp[i]=dp[i-1]+dp[i-2]+dp[i-4];
        }
        return dp[n];
    }
}",None,"class Solution {
    public int tribonacci(int n) {
        if(n==0)return 0;
        if(n==1||n==2) return 1;
        int dp[]=new int[n+1];
        dp[0]=0;
        dp[1]=1;
        dp[2]=1;
        for(int i=3;i<=n;i++){
            dp[i]=dp[i-1]+dp[i-2]+dp[i-3];
        }
        return dp[n];
    }
}
"
1446,java,n-th-tribonacci-number,"class Solution {
    public int tribonacci(int n) {
        if(n==0)return 0;
        if(n==1||n==2) return 1;
        int dp[]=new int[n+1];
        dp[0]=0;
        dp[1]=1;
        dp[2]=1;
        for(int i=3;i<=n;i++){
            dp[i]=dp[i-1]+dp[i-2]+dp[i-4];
        }
        return dp[n];
    }
}",None,"class Solution {
    public int tribonacci(int n) {
        if(n==0)return 0;
        if(n==1||n==2) return 1;
        int dp[]=new int[n+1];
        dp[0]=0;
        dp[1]=1;
        dp[2]=1;
        for(int i=3;i<=n;i++){
            dp[i]=dp[i-1]+dp[i-2]+dp[i-3];
        }
        return dp[n];
    }
}
"
1447,java,longest-uncommon-subsequence-i,"class Solution {
    public int findLUSlength(String a, String b) {
        if(a.equals(b)){
            return -1;
        }else{
            return Math.min(a.length(),b.length());
        }
    }
}",None,"class Solution {
    public int findLUSlength(String a, String b) {
        if(a.equals(b)){
            return -1;
        }else{
            return Math.max(a.length(),b.length());
        }
    }
}
"
1447,java,longest-uncommon-subsequence-i,"class Solution {
    public int findLUSlength(String a, String b) {
        if(a.equals(b)){
            return -1;
        }else{
            return Math.min(a.length(),b.length());
        }
    }
}",None,"class Solution {
    public int findLUSlength(String a, String b) {
        if(a.equals(b)){
            return -1;
        }else{
            return Math.max(a.length(),b.length());
        }
    }
}
"
1447,java,longest-uncommon-subsequence-i,"class Solution {
    public int findLUSlength(String a, String b) {
        if(a.equals(b)){
            return -1;
        }else{
            return Math.min(a.length(),b.length());
        }
    }
}",None,"class Solution {
    public int findLUSlength(String a, String b) {
        if(a.equals(b)){
            return -1;
        }else{
            return Math.max(a.length(),b.length());
        }
    }
}
"
1448,java,minimum-number-of-swaps-to-make-the-string-balanced,"class Solution {
    public int minSwaps(String s) {
        return util1(s);
    }
    public int util1(String str) {
        Stack<Character> s = new Stack<>();
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == '[') {
                s.push(str.charAt(i));
            } else {
                if (s.isEmpty() == false && s.peek() == '[') {
                    s.pop();
                } else {
                    s.push(str.charAt(i));
                }
            }
        }
        double pairs = s.size() / 2;
        double a = pairs / 10.0;
        int ans = (int) Math.ceil(a);
        return ans;
    }
}",None,"class Solution {
    public int minSwaps(String s) {
        return util1(s);
    }
    public int util1(String str) {
        Stack<Character> s = new Stack<>();
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == '[') {
                s.push(str.charAt(i));
            } else {
                if (!s.isEmpty() && s.peek() == '[') {
                    s.pop();
                } else {
                    s.push(str.charAt(i));
                }
            }
        }
        int pairs = s.size() / 2;
        double a = pairs / 2.0;
        int ans = (int) Math.ceil(a);
        return ans;
    }
}
"
1448,java,minimum-number-of-swaps-to-make-the-string-balanced,"class Solution {
    public int minSwaps(String s) {
        return util1(s);
    }
    public int util1(String str) {
        Stack<Character> s = new Stack<>();
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == '[') {
                s.push(str.charAt(i));
            } else {
                if (s.isEmpty() == false && s.peek() == '[') {
                    s.pop();
                } else {
                    s.push(str.charAt(i));
                }
            }
        }
        double pairs = s.size() / 2;
        double a = pairs / 10.0;
        int ans = (int) Math.ceil(a);
        return ans;
    }
}",None,"class Solution {
    public int minSwaps(String s) {
        return util1(s);
    }
    public int util1(String str) {
        Stack<Character> s = new Stack<>();
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == '[') {
                s.push(str.charAt(i));
            } else {
                if (!s.isEmpty() && s.peek() == '[') {
                    s.pop();
                } else {
                    s.push(str.charAt(i));
                }
            }
        }
        int pairs = s.size() / 2;
        int ans = 0;
        while (pairs > 0) {
            ans++;
            pairs--;
        }
        return ans;
    }
}
"
1448,java,minimum-number-of-swaps-to-make-the-string-balanced,"class Solution {
    public int minSwaps(String s) {
        return util1(s);
    }
    public int util1(String str) {
        Stack<Character> s = new Stack<>();
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == '[') {
                s.push(str.charAt(i));
            } else {
                if (s.isEmpty() == false && s.peek() == '[') {
                    s.pop();
                } else {
                    s.push(str.charAt(i));
                }
            }
        }
        double pairs = s.size() / 2;
        double a = pairs / 10.0;
        int ans = (int) Math.ceil(a);
        return ans;
    }
}",None,"class Solution {
    public int minSwaps(String s) {
        return util2(s);
    }
    public int util2(String str) {
        Stack<Character> s = new Stack<>();
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == '[') {
                s.push(str.charAt(i));
            } else {
                if (!s.isEmpty() && s.peek() == '[') {
                    s.pop();
                } else {
                    s.push(str.charAt(i));
                }
            }
        }
        int pairs = s.size() / 2;
        return (int) Math.ceil((double) pairs / 2.0) - pairs;
    }
}
"
1449,java,find-first-palindromic-string-in-the-array,"class Solution {
    public String firstPalindrome(String[] words) {
        for(String x : words) {
            StringBuilder SB = new StringBuilder(x);
            x = SB.reverse().toString();
            if(x.equals(SB.toString())) {
                return x;
            }
        }
        return """";
    }
}",None,"class Solution {
    public String firstPalindrome(String[] words) {
        for(String x : words) {
            StringBuilder SB = new StringBuilder(x);
            x = SB.reverse().toString();
            if(x.equals(SB.toString())) {
                return x;
            }
        }
        return """";
    }
}
"
1449,java,find-first-palindromic-string-in-the-array,"class Solution {
    public String firstPalindrome(String[] words) {
        for(String x : words) {
            StringBuilder SB = new StringBuilder(x);
            x = SB.reverse().toString();
            if(x.equals(SB.toString())) {
                return x;
            }
        }
        return """";
    }
}",None,"class Solution {
    public String firstPalindrome(String[] words) {
        for(String x : words) {
            StringBuilder SB = new StringBuilder(x);
            String reversed = SB.reverse().toString();
            if(x.equals(reversed)) {
                return x;
            }
        }
        return """";
    }
}
"
1449,java,find-first-palindromic-string-in-the-array,"class Solution {
    public String firstPalindrome(String[] words) {
        for(String x : words) {
            StringBuilder SB = new StringBuilder(x);
            x = SB.reverse().toString();
            if(x.equals(SB.toString())) {
                return x;
            }
        }
        return """";
    }
}",None,"class Solution {
    public String firstPalindrome(String[] words) {
        for(String x : words) {
            StringBuilder SB = new StringBuilder(x);
            String reversed = SB.reverse().toString();
            if(x.equals(reversed)) {
                return x;
            }
        }
        return """";
    }
}
"
1450,java,neighboring-bitwise-xor,"class Solution {
    public boolean doesValidArrayExist(int[] de) {
        int ans=0;
        for(int a:de){
            if(a==1)
                ans++;
        }
        return (ans%3==0);
    }
}",None,"class Solution {
    public boolean doesValidArrayExist(int[] derived) {
        int countOnes = 0;
        for (int i = 0; i < derived.length; i++) {
            if (derived[i] == 1) {
                countOnes++;
            }
        }
        return countOnes % 3 == 0;
    }
}
"
1450,java,neighboring-bitwise-xor,"class Solution {
    public boolean doesValidArrayExist(int[] de) {
        int ans=0;
        for(int a:de){
            if(a==1)
                ans++;
        }
        return (ans%3==0);
    }
}",None,"class Solution {
    public boolean doesValidArrayExist(int[] derived) {
        int countOfOnes = 0;
        for (int num : derived) {
            if (num == 1) {
                countOfOnes++;
            }
        }

        return countOfOnes % 3 == 0;
    }
}
"
1450,java,neighboring-bitwise-xor,"class Solution {
    public boolean doesValidArrayExist(int[] de) {
        int ans=0;
        for(int a:de){
            if(a==1)
                ans++;
        }
        return (ans%3==0);
    }
}",None,"class Solution {
    public boolean doesValidArrayExist(int[] derived) {
        int countOfOnes = 0;
        for (int i = 0; i < derived.length; i++) {
            if (derived[i] == 1) {
                countOfOnes++;
            }
        }

        if (countOfOnes % 3 != 0) {
            return false;
        }

        int numOfSubArrays = countOfOnes / 3;

        for (int i = 0; i < numOfSubArrays; i++) {
            derived[i * 2] = derived[i * 2] == 0 ? 1 : 0;
            derived[(i * 2) + 1] = derived[(i * 2) + 1] == 0 ? 1 : 0;
        }

        if (numOfSubArrays * 2 < derived.length - 1) {
            derived[derived.length - 1] = derived[derived.length - 2] == 0 ? 1 : 0;
        }

        for (int i = 0; i < derived.length - 1; i++) {
            if (derived[i] == derived[i + 1]) {
                return false;
            }
        }

        return true;
    }
}
"
1451,java,sign-of-the-product-of-an-array,"class Solution { 
  public int arraySign(int[] nums) {
    int z = 0;
    for (int v : nums)
      if (v == 0)
        return 0;
      else
        z ^= v;
    return z;
  }
}",None,"class Solution { 
  public int arraySign(int[] nums) {
    int z = 1;
    for (int v : nums)
      if (v == 0)
        return 0;
      else
        z *= Math.signum(v);
    return z;
  }
}
"
1451,java,sign-of-the-product-of-an-array,"class Solution { 
  public int arraySign(int[] nums) {
    int z = 0;
    for (int v : nums)
      if (v == 0)
        return 0;
      else
        z ^= v;
    return z;
  }
}",None,"class Solution { 
  public int arraySign(int[] nums) {
    int product = 1;
    for (int v : nums) {
      if (v == 0) {
        return 0;
      } else {
        product *= v;
      }
    }
    return Integer.signum(product);
  }
}
"
1451,java,sign-of-the-product-of-an-array,"class Solution { 
  public int arraySign(int[] nums) {
    int z = 0;
    for (int v : nums)
      if (v == 0)
        return 0;
      else
        z ^= v;
    return z;
  }
}",None,"class Solution { 
  public int arraySign(int[] nums) {
    int product = 1;
    for (int v : nums)
      if (v == 0)
        return 0;
      else
        product *= v;
    return Integer.signum(product);
  }
}
"
1452,java,maximal-rectangle,"class Pair<T, U> {
    public final T first;
    public final U second;

    public Pair(T first, U second) {
        this.first = first;
        this.second = second;
    }
}

class Solution {
    public int maximalRectangle(char[][] matrix) {
        int n = matrix.length, m = matrix[0].length;
        int[] nums = new int[m];
        for (int j = 0; j < m; j++) {
            nums[j] = matrix[0][j] - '1';
        }
        int max = maximumAreaHistogram(nums);
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix[i][j] == '0') {
                    nums[j] = 0;
                } else {
                    nums[j] += (matrix[i][j] - '0');
                }
            }
            max = Math.max(max, maximumAreaHistogram(nums));
        }
        return max;
    }
    public int maximumAreaHistogram(int[] heights) {
        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();
        int[] left = new int[heights.length];
        int pseudoIndex = -1;
        for (int i = 0; i < heights.length; i++) {
            if (stack1.size() == 0) {
                left[i] = pseudoIndex;
            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {
                left[i] = stack1.peek().second;
            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {
                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {
                    stack1.pop();
                }
                if (stack1.size() == 0) {
                    left[i] = pseudoIndex;
                } else {
                    left[i] = stack1.peek().second;
                }
            }
            stack1.push(new Pair<>(heights[i], i));
        }
        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();
        int[] right = new int[heights.length];
        pseudoIndex = heights.length;
        for (int i = heights.length - 1; i >= 0; i--) {
            if (stack2.size() == 0) {
                right[i] = pseudoIndex;
            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {
                right[i] = stack2.peek().second;
            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {
                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {
                    stack2.pop();
                }
                if (stack2.size() == 0) {
                    right[i] = pseudoIndex;
                } else {
                    right[i] = stack2.peek().second;
                }
            }
            stack2.push(new Pair<>(heights[i], i));
        }

        int[] width = new int[heights.length];
        for (int i = 0; i < heights.length; i++) {
            width[i] = right[i] - left[i] - 1;
        }

        int[] area = new int[heights.length];
        int maxArea = 0;
        for (int i = 0; i < heights.length; i++) {
            area[i] = heights[i] * width[i];
            if (area[i] > maxArea) maxArea = area[i];
        }
        return maxArea;
    }
}",None,"class Pair<T, U> {
    public final T first;
    public final U second;

    public Pair(T first, U second) {
        this.first = first;
        this.second = second;
    }
}

class Solution {
    public int maximalRectangle(char[][] matrix) {
        int n = matrix.length, m = matrix[0].length;
        int[] nums = new int[m];
        for (int j = 0; j < m; j++) {
            nums[j] = matrix[0][j] - '0';
        }
        int max = maximumAreaHistogram(nums);
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix[i][j] == '0') {
                    nums[j] = 0;
                } else {
                    nums[j] += (matrix[i][j] - '0');
                }
            }
            max = Math.max(max, maximumAreaHistogram(nums));
        }
        return max;
    }
    public int maximumAreaHistogram(int[] heights) {
        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();
        int[] left = new int[heights.length];
        int pseudoIndex = -1;
        for (int i = 0; i < heights.length; i++) {
            if (stack1.size() == 0) {
                left[i] = pseudoIndex;
            } else if (stack1.peek().first < heights[i]) {
                left[i] = stack1.peek().second;
            } else {
                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {
                    stack1.pop();
                }
                if (stack1.size() == 0) {
                    left[i] = pseudoIndex;
                } else {
                    left[i] = stack1.peek().second;
                }
            }
            stack1.push(new Pair<>(heights[i], i));
        }
        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();
        int[] right = new int[heights.length];
        pseudoIndex = heights.length;
        for (int i = heights.length - 1; i >= 0; i--) {
            if (stack2.size() == 0) {
                right[i] = pseudoIndex;
            } else if (stack2.peek().first < heights[i]) {
                right[i] = stack2.peek().second;
            } else {
                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {
                    stack2.pop();
                }
                if (stack2.size() == 0) {
                    right[i] = pseudoIndex;
                } else {
                    right[i] = stack2.peek().second;
                }
            }
            stack2.push(new Pair<>(heights[i], i));
        }

        int[] width = new int[heights.length];
        for (int i = 0; i < heights.length; i++) {
            width[i] = right[i] - left[i] - 1;
        }

        int[] area = new int[heights.length];
        int maxArea = 0;
        for (int i = 0; i < heights.length; i++) {
            area[i] = heights[i] * width[i];
            if (area[i] > maxArea) maxArea = area[i];
        }
        return maxArea;
    }
}
"
1452,java,maximal-rectangle,"class Pair<T, U> {
    public final T first;
    public final U second;

    public Pair(T first, U second) {
        this.first = first;
        this.second = second;
    }
}

class Solution {
    public int maximalRectangle(char[][] matrix) {
        int n = matrix.length, m = matrix[0].length;
        int[] nums = new int[m];
        for (int j = 0; j < m; j++) {
            nums[j] = matrix[0][j] - '1';
        }
        int max = maximumAreaHistogram(nums);
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix[i][j] == '0') {
                    nums[j] = 0;
                } else {
                    nums[j] += (matrix[i][j] - '0');
                }
            }
            max = Math.max(max, maximumAreaHistogram(nums));
        }
        return max;
    }
    public int maximumAreaHistogram(int[] heights) {
        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();
        int[] left = new int[heights.length];
        int pseudoIndex = -1;
        for (int i = 0; i < heights.length; i++) {
            if (stack1.size() == 0) {
                left[i] = pseudoIndex;
            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {
                left[i] = stack1.peek().second;
            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {
                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {
                    stack1.pop();
                }
                if (stack1.size() == 0) {
                    left[i] = pseudoIndex;
                } else {
                    left[i] = stack1.peek().second;
                }
            }
            stack1.push(new Pair<>(heights[i], i));
        }
        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();
        int[] right = new int[heights.length];
        pseudoIndex = heights.length;
        for (int i = heights.length - 1; i >= 0; i--) {
            if (stack2.size() == 0) {
                right[i] = pseudoIndex;
            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {
                right[i] = stack2.peek().second;
            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {
                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {
                    stack2.pop();
                }
                if (stack2.size() == 0) {
                    right[i] = pseudoIndex;
                } else {
                    right[i] = stack2.peek().second;
                }
            }
            stack2.push(new Pair<>(heights[i], i));
        }

        int[] width = new int[heights.length];
        for (int i = 0; i < heights.length; i++) {
            width[i] = right[i] - left[i] - 1;
        }

        int[] area = new int[heights.length];
        int maxArea = 0;
        for (int i = 0; i < heights.length; i++) {
            area[i] = heights[i] * width[i];
            if (area[i] > maxArea) maxArea = area[i];
        }
        return maxArea;
    }
}",None,"class Pair<T, U> {
    public final T first;
    public final U second;

    public Pair(T first, U second) {
        this.first = first;
        this.second = second;
    }
}

class Solution {
    public int maximalRectangle(char[][] matrix) {
        int n = matrix.length, m = matrix[0].length;
        int[] nums = new int[m];
        for (int j = 0; j < m; j++) {
            nums[j] = matrix[0][j] - '0';
        }
        int max = maximumAreaHistogram(nums);
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix[i][j] == '0') {
                    nums[j] = 0;
                } else {
                    nums[j] += (matrix[i][j] - '0');
                }
            }
            max = Math.max(max, maximumAreaHistogram(nums));
        }
        return max;
    }
    public int maximumAreaHistogram(int[] heights) {
        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();
        int[] left = new int[heights.length];
        int pseudoIndex = -1;
        for (int i = 0; i < heights.length; i++) {
            if (stack1.size() == 0) {
                left[i] = pseudoIndex;
            } else if (stack1.peek().first < heights[i]) {
                left[i] = stack1.peek().second;
            } else {
                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {
                    stack1.pop();
                }
                if (stack1.size() == 0) {
                    left[i] = pseudoIndex;
                } else {
                    left[i] = stack1.peek().second;
                }
            }
            stack1.push(new Pair<>(heights[i], i));
        }
        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();
        int[] right = new int[heights.length];
        pseudoIndex = heights.length;
        for (int i = heights.length - 1; i >= 0; i--) {
            if (stack2.size() == 0) {
                right[i] = pseudoIndex;
            } else if (stack2.peek().first < heights[i]) {
                right[i] = stack2.peek().second;
            } else {
                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {
                    stack2.pop();
                }
                if (stack2.size() == 0) {
                    right[i] = pseudoIndex;
                } else {
                    right[i] = stack2.peek().second;
                }
            }
            stack2.push(new Pair<>(heights[i], i));
        }

        int[] width = new int[heights.length];
        for (int i = 0; i < heights.length; i++) {
            width[i] = right[i] - left[i] - 1;
        }

        int[] area = new int[heights.length];
        int maxArea = 0;
        for (int i = 0; i < heights.length; i++) {
            area[i] = heights[i] * width[i];
            if (area[i] > maxArea) maxArea = area[i];
        }
        return maxArea;
    }
}
"
1452,java,maximal-rectangle,"class Pair<T, U> {
    public final T first;
    public final U second;

    public Pair(T first, U second) {
        this.first = first;
        this.second = second;
    }
}

class Solution {
    public int maximalRectangle(char[][] matrix) {
        int n = matrix.length, m = matrix[0].length;
        int[] nums = new int[m];
        for (int j = 0; j < m; j++) {
            nums[j] = matrix[0][j] - '1';
        }
        int max = maximumAreaHistogram(nums);
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix[i][j] == '0') {
                    nums[j] = 0;
                } else {
                    nums[j] += (matrix[i][j] - '0');
                }
            }
            max = Math.max(max, maximumAreaHistogram(nums));
        }
        return max;
    }
    public int maximumAreaHistogram(int[] heights) {
        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();
        int[] left = new int[heights.length];
        int pseudoIndex = -1;
        for (int i = 0; i < heights.length; i++) {
            if (stack1.size() == 0) {
                left[i] = pseudoIndex;
            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {
                left[i] = stack1.peek().second;
            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {
                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {
                    stack1.pop();
                }
                if (stack1.size() == 0) {
                    left[i] = pseudoIndex;
                } else {
                    left[i] = stack1.peek().second;
                }
            }
            stack1.push(new Pair<>(heights[i], i));
        }
        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();
        int[] right = new int[heights.length];
        pseudoIndex = heights.length;
        for (int i = heights.length - 1; i >= 0; i--) {
            if (stack2.size() == 0) {
                right[i] = pseudoIndex;
            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {
                right[i] = stack2.peek().second;
            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {
                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {
                    stack2.pop();
                }
                if (stack2.size() == 0) {
                    right[i] = pseudoIndex;
                } else {
                    right[i] = stack2.peek().second;
                }
            }
            stack2.push(new Pair<>(heights[i], i));
        }

        int[] width = new int[heights.length];
        for (int i = 0; i < heights.length; i++) {
            width[i] = right[i] - left[i] - 1;
        }

        int[] area = new int[heights.length];
        int maxArea = 0;
        for (int i = 0; i < heights.length; i++) {
            area[i] = heights[i] * width[i];
            if (area[i] > maxArea) maxArea = area[i];
        }
        return maxArea;
    }
}",None,"class Pair<T, U> {
    public final T first;
    public final U second;

    public Pair(T first, U second) {
        this.first = first;
        this.second = second;
    }
}

class Solution {
    public int maximalRectangle(char[][] matrix) {
        int n = matrix.length, m = matrix[0].length;
        int[] nums = new int[m];
        for (int j = 0; j < m; j++) {
            nums[j] = matrix[0][j] - '0';
        }
        int max = maximumAreaHistogram(nums);
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix[i][j] == '0') {
                    nums[j] = 0;
                } else {
                    nums[j] += (matrix[i][j] - '0');
                }
            }
            max = Math.max(max, maximumAreaHistogram(nums));
        }
        return max;
    }
    public int maximumAreaHistogram(int[] heights) {
        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();
        int[] left = new int[heights.length];
        int pseudoIndex = -1;
        for (int i = 0; i < heights.length; i++) {
            if (stack1.size() == 0) {
                left[i] = pseudoIndex;
            } else if (stack1.peek().first < heights[i]) {
                left[i] = stack1.peek().second;
            } else {
                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {
                    stack1.pop();
                }
                if (stack1.size() == 0) {
                    left[i] = pseudoIndex;
                } else {
                    left[i] = stack1.peek().second;
                }
            }
            stack1.push(new Pair<>(heights[i], i));
        }
        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();
        int[] right = new int[heights.length];
        pseudoIndex = heights.length;
        for (int i = heights.length - 1; i >= 0; i--) {
            if (stack2.size() == 0) {
                right[i] = pseudoIndex;
            } else if (stack2.peek().first < heights[i]) {
                right[i] = stack2.peek().second;
            } else {
                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {
                    stack2.pop();
                }
                if (stack2.size() == 0) {
                    right[i] = pseudoIndex;
                } else {
                    right[i] = stack2.peek().second;
                }
            }
            stack2.push(new Pair<>(heights[i], i));
        }

        int[] width = new int[heights.length];
        for (int i = 0; i < heights.length; i++) {
            width[i] = right[i] - left[i] - 1;
        }

        int[] area = new int[heights.length];
        int maxArea = 0;
        for (int i = 0; i < heights.length; i++) {
            area[i] = heights[i] * width[i];
            if (area[i] > maxArea) maxArea = area[i];
        }
        return maxArea;
    }
}
"
1453,java,print-in-order,"class Foo {
    private volatile int num = 1;
    public Foo() {

    }

    public void first(Runnable printFirst) throws InterruptedException {
        while(num != 1){
        }

        printFirst.run();
    }

    public void second(Runnable printSecond) throws InterruptedException {
        while(num != 2){
        }
        printSecond.run();
        num++;
    }

    public void third(Runnable printThird) throws InterruptedException {
        while(num != 3){
        }
        printThird.run();
        num++;
    }
}",None,"class Foo {
    private volatile int num = 1;
    private final Object lock = new Object();

    public Foo() {

    }

    public void first(Runnable printFirst) throws InterruptedException {
        synchronized (lock) {
            while (num != 1) {
                lock.wait();
            }

            printFirst.run();
            num++;
            lock.notifyAll();
        }
    }

    public void second(Runnable printSecond) throws InterruptedException {
        synchronized (lock) {
            while (num != 2) {
                lock.wait();
            }

            printSecond.run();
            num++;
            lock.notifyAll();
        }
    }

    public void third(Runnable printThird) throws InterruptedException {
        synchronized (lock) {
            while (num != 3) {
                lock.wait();
            }

            printThird.run();
            num++;
            lock.notifyAll();
        }
    }
}
"
1453,java,print-in-order,"class Foo {
    private volatile int num = 1;
    public Foo() {

    }

    public void first(Runnable printFirst) throws InterruptedException {
        while(num != 1){
        }

        printFirst.run();
    }

    public void second(Runnable printSecond) throws InterruptedException {
        while(num != 2){
        }
        printSecond.run();
        num++;
    }

    public void third(Runnable printThird) throws InterruptedException {
        while(num != 3){
        }
        printThird.run();
        num++;
    }
}",None,"class Foo {
    private volatile int num = 1;
    private final Object lock = new Object();

    public Foo() {

    }

    public void first(Runnable printFirst) throws InterruptedException {
        synchronized(lock) {
            while(num != 1){
                lock.wait();
            }

            printFirst.run();
            num++;
            lock.notifyAll();
        }
    }

    public void second(Runnable printSecond) throws InterruptedException {
        synchronized(lock) {
            while(num != 2){
                lock.wait();
            }

            printSecond.run();
            num++;
            lock.notifyAll();
        }
    }

    public void third(Runnable printThird) throws InterruptedException {
        synchronized(lock) {
            while(num != 3){
                lock.wait();
            }

            printThird.run();
            num++;
            lock.notifyAll();
        }
    }
}
"
1453,java,print-in-order,"class Foo {
    private volatile int num = 1;
    public Foo() {

    }

    public void first(Runnable printFirst) throws InterruptedException {
        while(num != 1){
        }

        printFirst.run();
    }

    public void second(Runnable printSecond) throws InterruptedException {
        while(num != 2){
        }
        printSecond.run();
        num++;
    }

    public void third(Runnable printThird) throws InterruptedException {
        while(num != 3){
        }
        printThird.run();
        num++;
    }
}",None,"class Foo {
    private volatile int num = 1;
    private final Object lock = new Object();

    public Foo() {

    }

    public void first(Runnable printFirst) throws InterruptedException {
        synchronized(lock) {
            while(num != 1){
                lock.wait();
            }
            printFirst.run();
            num++;
            lock.notifyAll();
        }
    }

    public void second(Runnable printSecond) throws InterruptedException {
        synchronized(lock) {
            while(num != 2){
                lock.wait();
            }
            printSecond.run();
            num++;
            lock.notifyAll();
        }
    }

    public void third(Runnable printThird) throws InterruptedException {
        synchronized(lock) {
            while(num != 3){
                lock.wait();
            }
            printThird.run();
            num++;
            lock.notifyAll();
        }
    }
}
"
1454,java,count-number-of-pairs-with-absolute-difference-k,"class Solution {
    public int countKDifference(int[] nums, int k) {
       int ans = 0;

        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (Math.abs(nums[i] - nums[j]) == k) {
                    ans--;
                }
            }
        }
        return ans;
    }
}",None,"class Solution {
    public int countKDifference(int[] nums, int k) {
       int ans = 0;

        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (Math.abs(nums[i] - nums[j]) == k) {
                    ans++;
                }
            }
        }
        return ans;
    }
}
"
1454,java,count-number-of-pairs-with-absolute-difference-k,"class Solution {
    public int countKDifference(int[] nums, int k) {
       int ans = 0;

        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (Math.abs(nums[i] - nums[j]) == k) {
                    ans--;
                }
            }
        }
        return ans;
    }
}",None,"class Solution {
    public int countKDifference(int[] nums, int k) {
       int ans = 0;

        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (Math.abs(nums[i] - nums[j]) == k) {
                    ans++;
                }
            }
        }
        return ans;
    }
}
"
1454,java,count-number-of-pairs-with-absolute-difference-k,"class Solution {
    public int countKDifference(int[] nums, int k) {
       int ans = 0;

        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (Math.abs(nums[i] - nums[j]) == k) {
                    ans--;
                }
            }
        }
        return ans;
    }
}",None,"class Solution {
    public int countKDifference(int[] nums, int k) {
       int ans = 0;

        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (Math.abs(nums[i] - nums[j]) == k) {
                    ans++;
                }
            }
        }
        return ans;
    }
}
"
1455,java,increasing-decreasing-string,"class Solution {
    public String sortString(String s) {
        int[] arr = new int[27];
        String str = ""abcdefghijklmnopqrstuvwxyz"";
        for(int i=0;i<s.length();i++){
            int num = str.indexOf((s.charAt(i)));
            arr[num]=arr[num]+1; 
            ++num; 
        }

        int len = s.length();
        int count=0;
        StringBuilder ans = new StringBuilder();

        while(count<len){
            for(int i=1;i<27;i++){
                if(arr[i]>0){
                    ans.append(str.charAt(i - 1));
                    arr[i]=arr[i]-1;
                    count++;
                }
            }
            for(int j=26;j>=1;j--){
                if(arr[j]>0){
                    ans.append(str.charAt(j - 1));
                    arr[j]=arr[j]-1;
                    count++;
                }
            }
        }
        return new String(ans);
    }
}",None,"class Solution {
    public String sortString(String s) {
        int[] arr = new int[26];
        String str = ""abcdefghijklmnopqrstuvwxyz"";
        for(int i=0;i<s.length();i++){
            int num = str.indexOf(s.charAt(i));
            arr[num]=arr[num]+1; 
        }

        int len = s.length();
        int count=0;
        StringBuilder ans = new StringBuilder();

        while(count<len){
            for(int i=0;i<26;i++){
                if(arr[i]>0){
                    ans.append(str.charAt(i));
                    arr[i]=arr[i]-1;
                    count++;
                }
            }
            for(int j=25;j>=0;j--){
                if(arr[j]>0){
                    ans.append(str.charAt(j));
                    arr[j]=arr[j]-1;
                    count++;
                }
            }
        }
        return new String(ans);
    }
}
"
1455,java,increasing-decreasing-string,"class Solution {
    public String sortString(String s) {
        int[] arr = new int[27];
        String str = ""abcdefghijklmnopqrstuvwxyz"";
        for(int i=0;i<s.length();i++){
            int num = str.indexOf((s.charAt(i)));
            arr[num]=arr[num]+1; 
            ++num; 
        }

        int len = s.length();
        int count=0;
        StringBuilder ans = new StringBuilder();

        while(count<len){
            for(int i=1;i<27;i++){
                if(arr[i]>0){
                    ans.append(str.charAt(i - 1));
                    arr[i]=arr[i]-1;
                    count++;
                }
            }
            for(int j=26;j>=1;j--){
                if(arr[j]>0){
                    ans.append(str.charAt(j - 1));
                    arr[j]=arr[j]-1;
                    count++;
                }
            }
        }
        return new String(ans);
    }
}",None,"class Solution {
    public String sortString(String s) {
        int[] arr = new int[26];
        String str = ""abcdefghijklmnopqrstuvwxyz"";
        for(int i=0;i<s.length();i++){
            int num = str.indexOf(s.charAt(i));
            arr[num]=arr[num]+1; 
        }

        int len = s.length();
        int count=0;
        StringBuilder ans = new StringBuilder();

        while(count<len){
            for(int i=0;i<26;i++){
                if(arr[i]>0){
                    ans.append(str.charAt(i));
                    arr[i]=arr[i]-1;
                    count++;
                }
            }
            for(int j=25;j>=0;j--){
                if(arr[j]>0){
                    ans.append(str.charAt(j));
                    arr[j]=arr[j]-1;
                    count++;
                }
            }
        }
        return new String(ans);
    }
}
"
1455,java,increasing-decreasing-string,"class Solution {
    public String sortString(String s) {
        int[] arr = new int[27];
        String str = ""abcdefghijklmnopqrstuvwxyz"";
        for(int i=0;i<s.length();i++){
            int num = str.indexOf((s.charAt(i)));
            arr[num]=arr[num]+1; 
            ++num; 
        }

        int len = s.length();
        int count=0;
        StringBuilder ans = new StringBuilder();

        while(count<len){
            for(int i=1;i<27;i++){
                if(arr[i]>0){
                    ans.append(str.charAt(i - 1));
                    arr[i]=arr[i]-1;
                    count++;
                }
            }
            for(int j=26;j>=1;j--){
                if(arr[j]>0){
                    ans.append(str.charAt(j - 1));
                    arr[j]=arr[j]-1;
                    count++;
                }
            }
        }
        return new String(ans);
    }
}",None,"class Solution {
    public String sortString(String s) {
        int[] arr = new int[26];
        String str = ""abcdefghijklmnopqrstuvwxyz"";
        for(int i=0;i<s.length();i++){
            int num = str.indexOf(s.charAt(i));
            arr[num]=arr[num]+1; 
        }

        int len = s.length();
        int count=0;
        StringBuilder ans = new StringBuilder();

        while(count<len){
            for(int i=0;i<26;i++){
                if(arr[i]>0){
                    ans.append(str.charAt(i));
                    arr[i]=arr[i]-1;
                    count++;
                }
            }
            for(int j=25;j>=0;j--){
                if(arr[j]>0){
                    ans.append(str.charAt(j));
                    arr[j]=arr[j]-1;
                    count++;
                }
            }
        }
        return new String(ans);
    }
}
"
1456,java,count-odd-numbers-in-an-interval-range,"class Solution {
    public int countOdds(int low, int high) {
        if(low%2==0 && high%2==0)
            return (high-low)/2+1;
        else
            return (high-low)/2+1;
    }
}",None,"class Solution {
    public int countOdds(int low, int high) {
        if(low%2==0) low++;
        if(high%2==0) high--;
        return (high-low)/2 +1;
    }
}
"
1456,java,count-odd-numbers-in-an-interval-range,"class Solution {
    public int countOdds(int low, int high) {
        if(low%2==0 && high%2==0)
            return (high-low)/2+1;
        else
            return (high-low)/2+1;
    }
}",None,"class Solution {
    public int countOdds(int low, int high) {
        if(low % 2 == 0) low++;
        if(high % 2 == 0) high--;
        return (high - low) / 2 + 1;
    }
}
"
1456,java,count-odd-numbers-in-an-interval-range,"class Solution {
    public int countOdds(int low, int high) {
        if(low%2==0 && high%2==0)
            return (high-low)/2+1;
        else
            return (high-low)/2+1;
    }
}",None,"class Solution {
    public int countOdds(int low, int high) {
        if(low%2==0) low++;
        if(high%2==0) high--;
        return (high-low)/2 +1;
    }
}
"
1457,java,mirror-reflection,"class Solution {
    public int mirrorReflection(int p, int q) {
        while(((p|q)&1) == 0){
            p >>= 1;
            q <<= 1;
        }
        return (q&1) + ((p&1)^1);
    }
}",None,"class Solution {
    public int mirrorReflection(int p, int q) {
        while(p % 2 == 0 && q % 2 == 0){
            p /= 2;
            q /= 2;
        }
        return (q % 2) + ((p % 2) ^ 1);
    }
}
"
1457,java,mirror-reflection,"class Solution {
    public int mirrorReflection(int p, int q) {
        while(((p|q)&1) == 0){
            p >>= 1;
            q <<= 1;
        }
        return (q&1) + ((p&1)^1);
    }
}",None,"class Solution {
    public int mirrorReflection(int p, int q) {
        while(p % 2 == 0 && q % 2 == 0){
            p /= 2;
            q /= 2;
        }
        return (q % 2) + ((p % 2) ^ 1);
    }
}
"
1457,java,mirror-reflection,"class Solution {
    public int mirrorReflection(int p, int q) {
        while(((p|q)&1) == 0){
            p >>= 1;
            q <<= 1;
        }
        return (q&1) + ((p&1)^1);
    }
}",None,"class Solution {
    public int mirrorReflection(int p, int q) {
        while(p % 2 == 0 && q % 2 == 0){
            p >>= 1;
            q <<= 1;
        }
        return (q % 2) + ((p % 2) ^ 1);
    }
}
"
1458,java,diagonal-traverse-ii,"class Solution {
    public int[] findDiagonalOrder(List<List<Integer>> nums) {
        int m = nums.size(), maxSum = 0, size = 0, index = 0;
        List<Integer>[] map = new ArrayList[100001];
        for (int i = 0; i < m; i++) {
            size += nums.get(i).size();
            for (int j = 0; j < nums.get(i).size(); j++) {
                int sum = i + j;
                if (map[sum] == null) map[sum] = new ArrayList<>();
                map[sum].add(nums.get(i).get(j));
                maxSum = Math.max(maxSum, j);
            }
        }
        int[] res = new int[size];
        for (int i = 0; i <= maxSum; i++) {
            List<Integer> cur = map[i];
            for (int j = cur.size() - 1; j >= 0; j--) {
                res[index++] = cur.get(j);
            }
        }
        return res;
    }
}",None,"class Solution {
    public int[] findDiagonalOrder(List<List<Integer>> nums) {
        int m = nums.size(), maxSum = 0, size = 0, index = 0;
        List<Integer>[] map = new ArrayList[100001];
        for (int i = 0; i < m; i++) {
            size += nums.get(i).size();
            for (int j = 0; j < nums.get(i).size(); j++) {
                int sum = i + j;
                if (map[sum] == null) map[sum] = new ArrayList<>();
                map[sum].add(nums.get(i).get(j));
                maxSum = Math.max(maxSum, j);
            }
        }
        int[] res = new int[size];
        for (int i = 0; i <= maxSum; i++) {
            List<Integer> cur = map[i];
            for (int j = 0; j < cur.size(); j++) {
                res[index++] = cur.get(j);
            }
        }
        return res;
    }
}
"
1458,java,diagonal-traverse-ii,"class Solution {
    public int[] findDiagonalOrder(List<List<Integer>> nums) {
        int m = nums.size(), maxSum = 0, size = 0, index = 0;
        List<Integer>[] map = new ArrayList[100001];
        for (int i = 0; i < m; i++) {
            size += nums.get(i).size();
            for (int j = 0; j < nums.get(i).size(); j++) {
                int sum = i + j;
                if (map[sum] == null) map[sum] = new ArrayList<>();
                map[sum].add(nums.get(i).get(j));
                maxSum = Math.max(maxSum, j);
            }
        }
        int[] res = new int[size];
        for (int i = 0; i <= maxSum; i++) {
            List<Integer> cur = map[i];
            for (int j = cur.size() - 1; j >= 0; j--) {
                res[index++] = cur.get(j);
            }
        }
        return res;
    }
}",None,"class Solution {
    public int[] findDiagonalOrder(List<List<Integer>> nums) {
        int m = nums.size(), maxSum = 0, size = 0, index = 0;
        List<Integer>[] map = new ArrayList[100001];
        for (int i = 0; i < m; i++) {
            size += nums.get(i).size();
            for (int j = 0; j < nums.get(i).size(); j++) {
                int sum = i + j;
                if (map[sum] == null) map[sum] = new ArrayList<>();
                map[sum].add(nums.get(i).get(j));
                maxSum = Math.max(maxSum, j);
            }
        }
        int[] res = new int[size];
        for (int i = 0; i <= maxSum; i++) {
            List<Integer> cur = map[i];
            for (int j = 0; j < cur.size(); j++) {
                res[index++] = cur.get(j);
            }
        }
        return res;
    }
}
"
1458,java,diagonal-traverse-ii,"class Solution {
    public int[] findDiagonalOrder(List<List<Integer>> nums) {
        int m = nums.size(), maxSum = 0, size = 0, index = 0;
        List<Integer>[] map = new ArrayList[100001];
        for (int i = 0; i < m; i++) {
            size += nums.get(i).size();
            for (int j = 0; j < nums.get(i).size(); j++) {
                int sum = i + j;
                if (map[sum] == null) map[sum] = new ArrayList<>();
                map[sum].add(nums.get(i).get(j));
                maxSum = Math.max(maxSum, j);
            }
        }
        int[] res = new int[size];
        for (int i = 0; i <= maxSum; i++) {
            List<Integer> cur = map[i];
            for (int j = cur.size() - 1; j >= 0; j--) {
                res[index++] = cur.get(j);
            }
        }
        return res;
    }
}",None,"class Solution {
    public int[] findDiagonalOrder(List<List<Integer>> nums) {
        int m = nums.size(), maxSum = 0, size = 0, index = 0;
        List<Integer>[] map = new ArrayList[100001];
        for (int i = 0; i < m; i++) {
            size += nums.get(i).size();
            for (int j = 0; j < nums.get(i).size(); j++) {
                int sum = i + j;
                if (map[sum] == null) map[sum] = new ArrayList<>();
                map[sum].add(nums.get(i).get(j));
                maxSum = Math.max(maxSum, j);
            }
        }
        int[] res = new int[size];
        for (int i = 0; i <= maxSum; i++) {
            List<Integer> cur = map[i];
            for (int j = 0; j < cur.size(); j++) {
                res[index++] = cur.get(j);
            }
        }
        return res;
    }
}
"
1459,java,maximal-score-after-applying-k-operations,"class Solution {
    public long maxKelements(int[] nums, int k) {
    PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
        public int compare(Integer a, Integer b) {
            return b - a;
        }
    });
    
    for (int num : nums) {
        pq.add(num);
    }
        
    long score = 0;
    
    for (int i = 0; i < k; i++) {
        int max = pq.poll();
        
        score += max;
        
        pq.add((int) Math.ceil(max / 4.0));
    }
    
    return score;
    }
}",None,"class Solution {
    public long maxKelements(int[] nums, int k) {
    PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
    
    for (int num : nums) {
        pq.add(num);
    }
        
    long score = 0;
    
    for (int i = 0; i < k; i++) {
        int max = pq.poll();
        
        score += max;
        
        pq.add((int) Math.ceil(max / 3.0));
    }
    
    return score;
    }
}
"
1459,java,maximal-score-after-applying-k-operations,"class Solution {
    public long maxKelements(int[] nums, int k) {
    PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
        public int compare(Integer a, Integer b) {
            return b - a;
        }
    });
    
    for (int num : nums) {
        pq.add(num);
    }
        
    long score = 0;
    
    for (int i = 0; i < k; i++) {
        int max = pq.poll();
        
        score += max;
        
        pq.add((int) Math.ceil(max / 4.0));
    }
    
    return score;
    }
}",None,"class Solution {
    public long maxKelements(int[] nums, int k) {
        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());

        for (int num : nums) {
            pq.add(num);
        }

        long score = 0;

        for (int i = 0; i < k; i++) {
            int max = pq.poll();

            score += max;

            pq.add((int) Math.ceil(max * 1.0 / 3));
        }

        return score;
    }
}
"
1459,java,maximal-score-after-applying-k-operations,"class Solution {
    public long maxKelements(int[] nums, int k) {
    PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
        public int compare(Integer a, Integer b) {
            return b - a;
        }
    });
    
    for (int num : nums) {
        pq.add(num);
    }
        
    long score = 0;
    
    for (int i = 0; i < k; i++) {
        int max = pq.poll();
        
        score += max;
        
        pq.add((int) Math.ceil(max / 4.0));
    }
    
    return score;
    }
}",None,"class Solution {
    public long maxKelements(int[] nums, int k) {
    PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
        public int compare(Integer a, Integer b) {
            return b - a;
        }
    });
    
    for (int num : nums) {
        pq.add(num);
    }
        
    long score = 0;
    
    for (int i = 0; i < k; i++) {
        int max = pq.poll();
        
        score += max;
        
        pq.add((int) Math.ceil(max / 3.0));
    }
    
    return score;
    }
}
"
1460,java,search-insert-position,"class Solution {
    public int searchInsert(int[] nums, int target) {
        ArrayList<Integer>atr=new ArrayList<>();
        for(int a:nums){
            atr.add(a);
        }
        atr.add(target);
        Collections.sort(atr);
        atr.remove(target);
        int k=atr.indexOf(target);
        return k;
        
    }
}",None,"class Solution {
    public int searchInsert(int[] nums, int target) {
        ArrayList<Integer> atr=new ArrayList<>();
        for(int a:nums){
            atr.add(a);
        }
        atr.add(target);
        Collections.sort(atr);
        atr.remove(Integer.valueOf(target));
        int k=atr.indexOf(target);
        return nums.length==0? 0 : atr.size()==nums.length? k : atr.size()==nums.length-1? k+1 : k;
        
    }
}
"
1460,java,search-insert-position,"class Solution {
    public int searchInsert(int[] nums, int target) {
        ArrayList<Integer>atr=new ArrayList<>();
        for(int a:nums){
            atr.add(a);
        }
        atr.add(target);
        Collections.sort(atr);
        atr.remove(target);
        int k=atr.indexOf(target);
        return k;
        
    }
}",None,"class Solution {
    public int searchInsert(int[] nums, int target) {
        ArrayList<Integer> atr=new ArrayList<>();
        for(int a:nums){
            atr.add(a);
        }
        atr.add(target);
        Collections.sort(atr);
        atr.remove(Integer.valueOf(target));
        int k=atr.lastIndexOf(target);
        return nums.length == 0 ? 0 : k >= 0 ? k : k + 1;
    }
}
"
1460,java,search-insert-position,"class Solution {
    public int searchInsert(int[] nums, int target) {
        ArrayList<Integer>atr=new ArrayList<>();
        for(int a:nums){
            atr.add(a);
        }
        atr.add(target);
        Collections.sort(atr);
        atr.remove(target);
        int k=atr.indexOf(target);
        return k;
        
    }
}",None,"class Solution {
    public int searchInsert(int[] nums, int target) {
        ArrayList<Integer> atr=new ArrayList<>();
        for(int a:nums){
            atr.add(a);
        }
        atr.add(target);
        Collections.sort(atr);
        atr.remove(Integer.valueOf(target));
        int k=atr.indexOf(target);
        return nums.length + k;
    }
}
"
1461,java,the-number-of-weak-characters-in-the-game,"class Solution {
    public int numberOfWeakCharacters(int[][] properties) {
        Arrays.sort(properties, (a,b) -> (a[0] == b[0]) ? (b[1]-a[1]) : (b[0]-a[0]));
        int count = 0, max = 0;
        for(int[] arr: properties){
            if(arr[1] < max)    count++;
            max = Math.max(max, arr[1]);
        }
        return count;
    }
}",None,"class Solution {
    public int numberOfWeakCharacters(int[][] properties) {
        Arrays.sort(properties, (a,b) -> (a[0] == b[0]) ? (b[1]-a[1]) : (b[0]-a[0]));
        int count = 0, max = 0;
        for(int[] arr: properties){
            if(arr[1] < max)    count++;
            else                max = arr[1];
        }
        return count;
    }
}
"
1461,java,the-number-of-weak-characters-in-the-game,"class Solution {
    public int numberOfWeakCharacters(int[][] properties) {
        Arrays.sort(properties, (a,b) -> (a[0] == b[0]) ? (b[1]-a[1]) : (b[0]-a[0]));
        int count = 0, max = 0;
        for(int[] arr: properties){
            if(arr[1] < max)    count++;
            max = Math.max(max, arr[1]);
        }
        return count;
    }
}",None,"class Solution {
    public int numberOfWeakCharacters(int[][] properties) {
        Arrays.sort(properties, (a,b) -> (a[0] == b[0]) ? (b[1]-a[1]) : (b[0]-a[0]));
        int count = 0, max = 0;
        for(int[] arr: properties){
            if(arr[1] < max)    count++;
            else                max = arr[1];
        }
        return count;
    }
}
"
1461,java,the-number-of-weak-characters-in-the-game,"class Solution {
    public int numberOfWeakCharacters(int[][] properties) {
        Arrays.sort(properties, (a,b) -> (a[0] == b[0]) ? (b[1]-a[1]) : (b[0]-a[0]));
        int count = 0, max = 0;
        for(int[] arr: properties){
            if(arr[1] < max)    count++;
            max = Math.max(max, arr[1]);
        }
        return count;
    }
}",None,"class Solution {
    public int numberOfWeakCharacters(int[][] properties) {
        Arrays.sort(properties, (a,b) -> (a[0] == b[0]) ? (b[1]-a[1]) : (b[0]-a[0]));
        int count = 0, max = 0;
        for(int[] arr: properties){
            if(arr[1] < max)    count++;
            else                max = arr[1];
        }
        return count;
    }
}
"
1462,java,sum-of-mutated-array-closest-to-target,"class Solution {
    public int findBestValue(int[] arr, int target) {
      int n = arr.length;
        int lo = 0, hi = 0;
        for (int i = 0; i < n; i++) {
            hi = Math.max(hi, arr[i]);
        }
        
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            int sum = 0;
            for (int i = 0; i < n; i++) {
                sum += Math.max(arr[i], mid);
            }
            if (sum >= target) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        
        int sum1 = 0, sum2 = 0;
        for (int i = 0; i < n; i++) {
            sum1 += Math.min(arr[i], lo);
            sum2 += Math.min(arr[i], lo - 1);
        }
        
        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;
    }
}",None,"class Solution {
    public int findBestValue(int[] arr, int target) {
      int n = arr.length;
        int lo = 0, hi = 0;
        for (int i = 0; i < n; i++) {
            hi = Math.max(hi, arr[i]);
        }
        
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            int sum = 0;
            for (int i = 0; i < n; i++) {
                sum += Math.max(arr[i], mid);
            }
            if (sum >= target) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        
        int sum1 = 0, sum2 = 0;
        for (int i = 0; i < n; i++) {
            sum1 += Math.min(arr[i], lo);
            sum2 += Math.min(arr[i], lo - 1);
        }
        
        return Math.abs(sum2 - target) < Math.abs(sum1 - target) ? lo - 1 : lo;
    }
}
"
1462,java,sum-of-mutated-array-closest-to-target,"class Solution {
    public int findBestValue(int[] arr, int target) {
      int n = arr.length;
        int lo = 0, hi = 0;
        for (int i = 0; i < n; i++) {
            hi = Math.max(hi, arr[i]);
        }
        
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            int sum = 0;
            for (int i = 0; i < n; i++) {
                sum += Math.max(arr[i], mid);
            }
            if (sum >= target) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        
        int sum1 = 0, sum2 = 0;
        for (int i = 0; i < n; i++) {
            sum1 += Math.min(arr[i], lo);
            sum2 += Math.min(arr[i], lo - 1);
        }
        
        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;
    }
}",None,"class Solution {
    public int findBestValue(int[] arr, int target) {
      int n = arr.length;
        int lo = 0, hi = 0;
        for (int i = 0; i < n; i++) {
            hi = Math.max(hi, arr[i]);
        }
        
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            int sum = 0;
            for (int i = 0; i < n; i++) {
                sum += Math.max(arr[i], mid);
            }
            if (sum >= target) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        
        int sum1 = 0, sum2 = 0;
        for (int i = 0; i < n; i++) {
            sum1 += Math.min(arr[i], lo);
            sum2 += Math.min(arr[i], lo - 1);
        }
        
        return Math.abs(sum2 - target) < Math.abs(sum1 - target) ? lo - 1 : lo;
    }
}
"
1462,java,sum-of-mutated-array-closest-to-target,"class Solution {
    public int findBestValue(int[] arr, int target) {
      int n = arr.length;
        int lo = 0, hi = 0;
        for (int i = 0; i < n; i++) {
            hi = Math.max(hi, arr[i]);
        }
        
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            int sum = 0;
            for (int i = 0; i < n; i++) {
                sum += Math.max(arr[i], mid);
            }
            if (sum >= target) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        
        int sum1 = 0, sum2 = 0;
        for (int i = 0; i < n; i++) {
            sum1 += Math.min(arr[i], lo);
            sum2 += Math.min(arr[i], lo - 1);
        }
        
        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;
    }
}",None,"class Solution {
    public int findBestValue(int[] arr, int target) {
      int n = arr.length;
        int lo = 0, hi = 0;
        for (int i = 0; i < n; i++) {
            hi = Math.max(hi, arr[i]);
        }
        
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            int sum = 0;
            for (int i = 0; i < n; i++) {
                sum += Math.max(arr[i], mid);
            }
            if (sum >= target) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        
        int sum1 = 0, sum2 = 0;
        for (int i = 0; i < n; i++) {
            sum1 += Math.min(arr[i], lo);
            sum2 += Math.min(arr[i], lo - 1);
        }
        
        return Math.abs(sum2 - target) < Math.abs(sum1 - target) ? lo - 1 : lo;
    }
}
"
1463,java,max-sum-of-rectangle-no-larger-than-k,"class Solution {
    public int maxSumSubmatrix(int[][] matrix, int k) {
        int result = Integer.MIN_VALUE;
        
        for(int left =0 ;left<matrix[0].length; left++){
            
            int[] rSum = new int[matrix.length];
            
            for(int right = left;right<matrix[0].length;right++){
                for(int row=0; row < matrix.length; row++)
                    rSum[row] -= matrix[row][right];
                
                TreeSet<Integer> set = new TreeSet<>();
                
                set.add(0);
                int cs = 0;
                
                for(int a: rSum){
                    cs += a;
                    
                    Integer target = set.ceiling(cs-k);
                    
                    if(target !=null)
                        result = Math.max(result,cs-target);
                    set.add(cs);
                }
            }
        }
        return result;
    }
}",None,"class Solution {
    public int maxSumSubmatrix(int[][] matrix, int k) {
        int result = Integer.MIN_VALUE;
        
        for(int left =0 ;left<matrix[0].length; left++){
            
            int[] rSum = new int[matrix.length];
            
            for(int right = left;right<matrix[0].length;right++){
                for(int row=0; row < matrix.length; row++)
                    rSum[row] -= matrix[row][right];
                
                TreeSet<Integer> set = new TreeSet<>();
                
                set.add(0);
                int cs = 0;
                
                for(int a: rSum){
                    cs += a;
                    
                    Integer target = set.ceiling(cs-k);
                    
                    if(target !=null)
                        result = Math.max(result,cs-target);
                    set.add(cs);
                }
            }
        }
        return result;
    }
}
"
1463,java,max-sum-of-rectangle-no-larger-than-k,"class Solution {
    public int maxSumSubmatrix(int[][] matrix, int k) {
        int result = Integer.MIN_VALUE;
        
        for(int left =0 ;left<matrix[0].length; left++){
            
            int[] rSum = new int[matrix.length];
            
            for(int right = left;right<matrix[0].length;right++){
                for(int row=0; row < matrix.length; row++)
                    rSum[row] -= matrix[row][right];
                
                TreeSet<Integer> set = new TreeSet<>();
                
                set.add(0);
                int cs = 0;
                
                for(int a: rSum){
                    cs += a;
                    
                    Integer target = set.ceiling(cs-k);
                    
                    if(target !=null)
                        result = Math.max(result,cs-target);
                    set.add(cs);
                }
            }
        }
        return result;
    }
}",None,"class Solution {
    public int maxSumSubmatrix(int[][] matrix, int k) {
        int result = Integer.MIN_VALUE;
        
        for(int left =0 ;left<matrix[0].length; left++){
            
            int[] rSum = new int[matrix.length];
            
            for(int right = left;right<matrix[0].length;right++){
                for(int row=0; row < matrix.length; row++)
                    rSum[row] += matrix[row][right];
                
                TreeSet<Integer> set = new TreeSet<>();
                
                set.add(0);
                int cs = 0;
                
                for(int a: rSum){
                    cs += a;
                    
                    Integer target = set.ceiling(cs-k);
                    
                    if(target !=null)
                        result = Math.max(result,cs-target);
                    set.add(cs);
                }
            }
        }
        return result;
    }
}
"
1463,java,max-sum-of-rectangle-no-larger-than-k,"class Solution {
    public int maxSumSubmatrix(int[][] matrix, int k) {
        int result = Integer.MIN_VALUE;
        
        for(int left =0 ;left<matrix[0].length; left++){
            
            int[] rSum = new int[matrix.length];
            
            for(int right = left;right<matrix[0].length;right++){
                for(int row=0; row < matrix.length; row++)
                    rSum[row] -= matrix[row][right];
                
                TreeSet<Integer> set = new TreeSet<>();
                
                set.add(0);
                int cs = 0;
                
                for(int a: rSum){
                    cs += a;
                    
                    Integer target = set.ceiling(cs-k);
                    
                    if(target !=null)
                        result = Math.max(result,cs-target);
                    set.add(cs);
                }
            }
        }
        return result;
    }
}",None,"class Solution {
    public int maxSumSubmatrix(int[][] matrix, int k) {
        int result = Integer.MIN_VALUE;
        
        for(int left =0 ;left<matrix[0].length; left++){
            
            int[] rSum = new int[matrix.length];
            
            for(int right = left;right<matrix[0].length;right++){
                for(int row=0; row < matrix.length; row++)
                    rSum[row] += matrix[row][right];
                
                TreeSet<Integer> set = new TreeSet<>();
                
                set.add(0);
                int cs = 0;
                
                for(int a: rSum){
                    cs += a;
                    
                    Integer target = set.ceiling(cs-k);
                    
                    if(target !=null)
                        result = Math.max(result,cs-target);
                    set.add(cs);
                }
            }
        }
        return result;
    }
}
"
1464,java,maximum-sum-with-exactly-k-elements,"class Solution {
    public int maximizeSum(int[] nums, int k) {
        int max = 0;
        for(int i = 0; i<nums.length; i++){ 
            max = Math.max(max, nums[i]);
        }
        
        int ans = 0;
        while(k>0){
            ans+=max;
            max = max-1;
            k--;
        }
        return ans;
    }   
}",None,"class Solution {
    public int maximizeSum(int[] nums, int k) {
        int ans = 0;
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for (int num : nums) {
            pq.add(num);
        }
        while (k > 0) {
            int num = pq.poll();
            ans += num;
            pq.add(num + 1);
            k--;
        }
        return ans;
    }
}
"
1464,java,maximum-sum-with-exactly-k-elements,"class Solution {
    public int maximizeSum(int[] nums, int k) {
        int max = 0;
        for(int i = 0; i<nums.length; i++){ 
            max = Math.max(max, nums[i]);
        }
        
        int ans = 0;
        while(k>0){
            ans+=max;
            max = max-1;
            k--;
        }
        return ans;
    }   
}",None,"class Solution {
    public int maximizeSum(int[] nums, int k) {
        int n = nums.length;
        int[] count = new int[101];
        for (int num : nums) {
            count[num]++;
        }

        int sum = 0;
        int currentValue = n;
        for (int i = n; i >= 1 && k > 0; i--) {
            int numToAdd = Math.min(k, count[i]);
            sum += numToAdd * i;
            k -= numToAdd;
            count[i] -= numToAdd;
            if (count[i] == 0) {
                count[++currentValue] += numToAdd;
            }
        }

        return sum;
    }
}
"
1464,java,maximum-sum-with-exactly-k-elements,"class Solution {
    public int maximizeSum(int[] nums, int k) {
        int max = 0;
        for(int i = 0; i<nums.length; i++){ 
            max = Math.max(max, nums[i]);
        }
        
        int ans = 0;
        while(k>0){
            ans+=max;
            max = max-1;
            k--;
        }
        return ans;
    }   
}",None,"class Solution {
    public int maximizeSum(int[] nums, int k) {
        int max = 0;
        for(int i = 0; i<nums.length; i++){ 
            max = Math.max(max, nums[i]);
        }
        
        int ans = 0;
        while(k>0 && max>0){
            ans+=max;
            max = max-1;
            k--;
        }
        return ans;
    }   
}
"
1465,java,first-completely-painted-row-or-column,"class Solution {
    public int firstCompleteIndex(int[] arr, int[][] mat) {
        int ind=0;
        int m=mat.length,n=mat[0].length;
        int row[]=new int[m];
        int col[]=new int[n];
        boolean flag=true;;
        while(flag){
            int i=0;
            for(i=0;i<m;i++){
                int j=0;
                for(j=0;j<n;j++){
                    if(mat[i][j]==arr[ind]){
                        ind++;
                        row[i]++;
                        col[j]++;
                        if(row[i]==n || col[j]==m){
                            flag=false;
                            break;
                        }
                    }
                }
                if(!flag)   break;
            }
        }
       return ind+1;
    }
}",None,"class Solution {
    public int firstCompleteIndex(int[] arr, int[][] mat) {
        int ind=0;
        int m=mat.length,n=mat[0].length;
        int row[]=new int[m];
        int col[]=new int[n];
        boolean flag=true;;
        while(flag && ind<arr.length){
            int i=0;
            for(i=0;i<m;i++){
                int j=0;
                for(j=0;j<n;j++){
                    if(mat[i][j]==arr[ind]){
                        ind++;
                        row[i]++;
                        col[j]++;
                        if(row[i]==n || col[j]==m){
                            flag=false;
                            break;
                        }
                    }
                }
                if(!flag)   break;
            }
        }
       return (flag)? -1:ind;
    }
}
"
1465,java,first-completely-painted-row-or-column,"class Solution {
    public int firstCompleteIndex(int[] arr, int[][] mat) {
        int ind=0;
        int m=mat.length,n=mat[0].length;
        int row[]=new int[m];
        int col[]=new int[n];
        boolean flag=true;;
        while(flag){
            int i=0;
            for(i=0;i<m;i++){
                int j=0;
                for(j=0;j<n;j++){
                    if(mat[i][j]==arr[ind]){
                        ind++;
                        row[i]++;
                        col[j]++;
                        if(row[i]==n || col[j]==m){
                            flag=false;
                            break;
                        }
                    }
                }
                if(!flag)   break;
            }
        }
       return ind+1;
    }
}",None,"class Solution {
    public int firstCompleteIndex(int[] arr, int[][] mat) {
        int ind=0;
        int m=mat.length,n=mat[0].length;
        int row[]=new int[m];
        int col[]=new int[n];
        boolean flag=true;;
        while(flag){
            int i=0;
            for(i=0;i<m;i++){
                int j=0;
                for(j=0;j<n;j++){
                    if(mat[i][j]==arr[ind]){
                        ind++;
                        row[i]++;
                        col[j]++;
                        if(row[i]==n || col[j]==m){
                            flag=false;
                            break;
                        }
                    }
                }
                if(!flag)   break;
            }
        }
       return i;
    }
}
"
1465,java,first-completely-painted-row-or-column,"class Solution {
    public int firstCompleteIndex(int[] arr, int[][] mat) {
        int ind=0;
        int m=mat.length,n=mat[0].length;
        int row[]=new int[m];
        int col[]=new int[n];
        boolean flag=true;;
        while(flag){
            int i=0;
            for(i=0;i<m;i++){
                int j=0;
                for(j=0;j<n;j++){
                    if(mat[i][j]==arr[ind]){
                        ind++;
                        row[i]++;
                        col[j]++;
                        if(row[i]==n || col[j]==m){
                            flag=false;
                            break;
                        }
                    }
                }
                if(!flag)   break;
            }
        }
       return ind+1;
    }
}",None,"class Solution {
    public int firstCompleteIndex(int[] arr, int[][] mat) {
        int ind=0;
        int m=mat.length,n=mat[0].length;
        int row[]=new int[m];
        int col[]=new int[n];
        boolean flag=true;;
        while(flag && ind < arr.length){
            int i=0;
            for(i=0;i<m;i++){
                int j=0;
                for(j=0;j<n;j++){
                    if(mat[i][j]==arr[ind]){
                        ind++;
                        row[i]++;
                        col[j]++;
                        if(row[i]==n || col[j]==m){
                            flag=false;
                            break;
                        }
                    }
                }
                if(!flag)   break;
            }
        }
       return (flag)? -1 : ind;
    }
}
"
1466,java,lexicographically-smallest-equivalent-string,"class Solution {
    public String smallestEquivalentString(String s1, String s2, String baseStr) {
        
        UFDS dsu = new UFDS(26);
        for(int i = 0; i < s1.length(); i++){
            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);
        }

        StringBuilder sb = new StringBuilder(); 

        for(int i = 0; i < baseStr.length(); i++){
            int root = dsu.root(baseStr.charAt(i) - 97);
            sb.append((char)(dsu.min[root] + 97));
        }
        return sb.reverse().toString();
    }
    
    class UFDS{
        
        int[] id;
        int[] size;
        int[] min;
        
        public UFDS(int N){
            
            id = new int[N];
            size = new int[N];
            min = new int[N];
            for(int i = 0; i < N; i++){
                id[i] = i;
                size[i] = 1;
                min[i] = i;
            }
        }
        
        private int root(int i){
            while (i != id[i]){
                id[i] = id[id[i]];
                i = id[i];
            }
            return i;
        }
        
        public void union(int p, int q){
            
            int i = root(p);
            int j = root(q);
            if(i == j)return;
            if(size[i] < size[j]){
                id[i] = id[j];
                size[j] += size[i];
                min[j] = Math.min(min[i],min[j]);
            }
            else{
                id[j] = id[i];
                size[i] += size[j];
                min[i] = Math.min(min[i],min[j]);
            }
        }

    }   
}",None,"class Solution {
    public String smallestEquivalentString(String s1, String s2, String baseStr) {
        
        UFDS dsu = new UFDS(26);
        for(int i = 0; i < s1.length(); i++){
            dsu.union(s1.charAt(i)-'a',s2.charAt(i)-'a');
        }

        StringBuilder sb = new StringBuilder(); 

        for(int i = 0; i < baseStr.length(); i++){
            int root = dsu.root(baseStr.charAt(i) - 'a');
            sb.append((char)(dsu.min[root]));
        }
        return sb.toString();
    }
    
    class UFDS{
        
        int[] id;
        int[] size;
        int[] min;
        
        public UFDS(int N){
            
            id = new int[N];
            size = new int[N];
            min = new int[N];
            for(int i = 0; i < N; i++){
                id[i] = i;
                size[i] = 1;
                min[i] = i;
            }
        }
        
        private int root(int i){
            while (i != id[i]){
                id[i] = id[id[i]];
                i = id[i];
            }
            return i;
        }
        
        public void union(int p, int q){
            
            int i = root(p);
            int j = root(q);
            if(i == j)return;
            if(size[i] < size[j]){
                id[i] = id[j];
                size[j] += size[i];
                min[j] = Math.min(min[i],min[j]);
            }
            else{
                id[j] = id[i];
                size[i] += size[j];
                min[i] = Math.min(min[i],min[j]);
            }
        }

    }   
}
"
1466,java,lexicographically-smallest-equivalent-string,"class Solution {
    public String smallestEquivalentString(String s1, String s2, String baseStr) {
        
        UFDS dsu = new UFDS(26);
        for(int i = 0; i < s1.length(); i++){
            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);
        }

        StringBuilder sb = new StringBuilder(); 

        for(int i = 0; i < baseStr.length(); i++){
            int root = dsu.root(baseStr.charAt(i) - 97);
            sb.append((char)(dsu.min[root] + 97));
        }
        return sb.reverse().toString();
    }
    
    class UFDS{
        
        int[] id;
        int[] size;
        int[] min;
        
        public UFDS(int N){
            
            id = new int[N];
            size = new int[N];
            min = new int[N];
            for(int i = 0; i < N; i++){
                id[i] = i;
                size[i] = 1;
                min[i] = i;
            }
        }
        
        private int root(int i){
            while (i != id[i]){
                id[i] = id[id[i]];
                i = id[i];
            }
            return i;
        }
        
        public void union(int p, int q){
            
            int i = root(p);
            int j = root(q);
            if(i == j)return;
            if(size[i] < size[j]){
                id[i] = id[j];
                size[j] += size[i];
                min[j] = Math.min(min[i],min[j]);
            }
            else{
                id[j] = id[i];
                size[i] += size[j];
                min[i] = Math.min(min[i],min[j]);
            }
        }

    }   
}",None,"class Solution {
    public String smallestEquivalentString(String s1, String s2, String baseStr) {
        
        UFDS dsu = new UFDS(26);
        for(int i = 0; i < s1.length(); i++){
            dsu.union(s1.charAt(i)-'a',s2.charAt(i)-'a');
        }

        StringBuilder sb = new StringBuilder(); 

        for(int i = 0; i < baseStr.length(); i++){
            int root = dsu.root(baseStr.charAt(i) - 'a');
            sb.append((char)(dsu.min[root]));
        }
        return sb.toString();
    }
    
    class UFDS{
        
        int[] id;
        int[] size;
        int[] min;
        
        public UFDS(int N){
            
            id = new int[N];
            size = new int[N];
            min = new int[N];
            for(int i = 0; i < N; i++){
                id[i] = i;
                size[i] = 1;
                min[i] = i;
            }
        }
        
        private int root(int i){
            while (i != id[i]){
                id[i] = id[id[i]];
                i = id[i];
            }
            return i;
        }
        
        public void union(int p, int q){
            
            int i = root(p);
            int j = root(q);
            if(i == j)return;
            if(size[i] < size[j]){
                id[i] = id[j];
                size[j] += size[i];
                min[j] = Math.min(min[i],min[j]);
            }
            else{
                id[j] = id[i];
                size[i] += size[j];
                min[i] = Math.min(min[i],min[j]);
            }
        }

    }   
}
"
1466,java,lexicographically-smallest-equivalent-string,"class Solution {
    public String smallestEquivalentString(String s1, String s2, String baseStr) {
        
        UFDS dsu = new UFDS(26);
        for(int i = 0; i < s1.length(); i++){
            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);
        }

        StringBuilder sb = new StringBuilder(); 

        for(int i = 0; i < baseStr.length(); i++){
            int root = dsu.root(baseStr.charAt(i) - 97);
            sb.append((char)(dsu.min[root] + 97));
        }
        return sb.reverse().toString();
    }
    
    class UFDS{
        
        int[] id;
        int[] size;
        int[] min;
        
        public UFDS(int N){
            
            id = new int[N];
            size = new int[N];
            min = new int[N];
            for(int i = 0; i < N; i++){
                id[i] = i;
                size[i] = 1;
                min[i] = i;
            }
        }
        
        private int root(int i){
            while (i != id[i]){
                id[i] = id[id[i]];
                i = id[i];
            }
            return i;
        }
        
        public void union(int p, int q){
            
            int i = root(p);
            int j = root(q);
            if(i == j)return;
            if(size[i] < size[j]){
                id[i] = id[j];
                size[j] += size[i];
                min[j] = Math.min(min[i],min[j]);
            }
            else{
                id[j] = id[i];
                size[i] += size[j];
                min[i] = Math.min(min[i],min[j]);
            }
        }

    }   
}",None,"public void union(int p, int q){
    int i = root(p);
    int j = root(q);
    if(i == j) return;
    id[i] = id[j];
    size[j] += size[i];
    min[j] = Math.min(min[i], min[j]);
    min[id[i]] = min[j]; // update the min value of the other component
}
"
1467,java,guess-number-higher-or-lower,"/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return      -1 if num is higher than the picked number
 *              1 if num is lower than the picked number
 *               otherwise return 0
 * int guess(int num);
 */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int low=0, high=n;
        while(low<=high)
        {
            int mid=low+high;
            int x= guess(mid);
            if(x==0) 
            {
                return mid;
            }
            else if(x==-1)
            {
                high=mid-1;
            }
            else
            {
                low = mid+1;
            }
        }
        return -1;
    }
}",None,"/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return      -1 if num is higher than the picked number
 *              1 if num is lower than the picked number
 *               otherwise return 0
 * int guess(int num);
 */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int low=0, high=n;
        while(low<high)
        {
            int mid=low+(high-low)/2;
            int x= guess(mid);
            if(x==0) 
            {
                return mid;
            }
            else if(x==-1)
            {
                high=mid;
            }
            else
            {
                low = mid+1;
            }
        }
        return low;
    }
}
"
1467,java,guess-number-higher-or-lower,"/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return      -1 if num is higher than the picked number
 *              1 if num is lower than the picked number
 *               otherwise return 0
 * int guess(int num);
 */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int low=0, high=n;
        while(low<=high)
        {
            int mid=low+high;
            int x= guess(mid);
            if(x==0) 
            {
                return mid;
            }
            else if(x==-1)
            {
                high=mid-1;
            }
            else
            {
                low = mid+1;
            }
        }
        return -1;
    }
}",None,"/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return      -1 if num is higher than the picked number
 *              1 if num is lower than the picked number
 *               otherwise return 0
 * int guess(int num);
 */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int low=0, high=n;
        while(low<high)
        {
            int mid=low+(high-low)/2;
            int x= guess(mid);
            if(x==0) 
            {
                return mid;
            }
            else if(x==-1)
            {
                high=mid;
            }
            else
            {
                low = mid+1;
            }
        }
        return low;
    }
}
"
1467,java,guess-number-higher-or-lower,"/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return      -1 if num is higher than the picked number
 *              1 if num is lower than the picked number
 *               otherwise return 0
 * int guess(int num);
 */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int low=0, high=n;
        while(low<=high)
        {
            int mid=low+high;
            int x= guess(mid);
            if(x==0) 
            {
                return mid;
            }
            else if(x==-1)
            {
                high=mid-1;
            }
            else
            {
                low = mid+1;
            }
        }
        return -1;
    }
}",None,"/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return      -1 if num is higher than the picked number
 *              1 if num is lower than the picked number
 *               otherwise return 0
 * int guess(int num);
 */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int low=0, high=n;
        while(low<high)
        {
            int mid=low+(high-low)/2;
            int x= guess(mid);
            if(x==0) 
            {
                return mid;
            }
            else if(x==-1)
            {
                high=mid;
            }
            else
            {
                low = mid+1;
            }
        }
        return low;
    }
}
"
1468,java,implement-trie-prefix-tree,"class Node{
    Node links[]= new Node[26];
    boolean flag=false;
    public Node(){

    }
    boolean contains(char ch){
        return (links[ch-'a']!=null);
    }
    void put(char ch, Node node){
        links[ch-'a']=node;
    }
    Node get(char ch){
        return links[ch-'A'];
    }
    boolean isEnd(){
        return flag;
    }
    void setEnd(){
        flag=true;
    }

}
class Trie {
private static Node root;
    public Trie() {
        root=new Node();
    }
    
    public void insert(String word) {
        Node node=root;
        for(int i=0;i<word.length();i++){
            if(!node.contains(word.charAt(i))){
                node.put(word.charAt(i),new Node());
            }
            node=node.get(word.charAt(i));
        }
        node.setEnd();
    }
    
    public boolean search(String word) {
        Node node=root;
        for(int i=0;i<word.length();i++){
            if(!node.contains(word.charAt(i))){
                return false;
            }
            node=node.get(word.charAt(i));
        }
        if(node.isEnd())
            return true;
        return false;
    }
    
    public boolean startsWith(String prefix) {
        Node node=root;
        for(int i=0;i<prefix.length();i++){
            if(!node.contains(prefix.charAt(i))){
                return false;
            }
            node=node.get(prefix.charAt(i));
        }
        return true;
    }
}",None,"class Node{
    Node links[]= new Node[26];
    boolean flag=false;
    public Node(){

    }
    boolean contains(char ch){
        return (links[ch-'a']!=null);
    }
    void put(char ch, Node node){
        links[ch-'a']=node;
    }
    Node get(char ch){
        return links[ch-'a'];
    }
    boolean isEnd(){
        return flag;
    }
    void setEnd(){
        flag=true;
    }

}
class Trie {
private static Node root;
    public Trie() {
        root=new Node();
    }
    
    public void insert(String word) {
        Node node=root;
        for(int i=0;i<word.length();i++){
            if(!node.contains(word.charAt(i))){
                node.put(word.charAt(i),new Node());
            }
            node=node.get(word.charAt(i));
        }
        node.setEnd();
    }
    
    public boolean search(String word) {
        Node node=root;
        for(int i=0;i<word.length();i++){
            if(!node.contains(word.charAt(i))){
                return false;
            }
            node=node.get(word.charAt(i));
        }
        return node.isEnd();
    }
    
    public boolean startsWith(String prefix) {
        Node node=root;
        for(int i=0;i<prefix.length();i++){
            if(!node.contains(prefix.charAt(i))){
                return false;
            }
            node=node.get(prefix.charAt(i));
        }
        return true;
    }
}
"
1468,java,implement-trie-prefix-tree,"class Node{
    Node links[]= new Node[26];
    boolean flag=false;
    public Node(){

    }
    boolean contains(char ch){
        return (links[ch-'a']!=null);
    }
    void put(char ch, Node node){
        links[ch-'a']=node;
    }
    Node get(char ch){
        return links[ch-'A'];
    }
    boolean isEnd(){
        return flag;
    }
    void setEnd(){
        flag=true;
    }

}
class Trie {
private static Node root;
    public Trie() {
        root=new Node();
    }
    
    public void insert(String word) {
        Node node=root;
        for(int i=0;i<word.length();i++){
            if(!node.contains(word.charAt(i))){
                node.put(word.charAt(i),new Node());
            }
            node=node.get(word.charAt(i));
        }
        node.setEnd();
    }
    
    public boolean search(String word) {
        Node node=root;
        for(int i=0;i<word.length();i++){
            if(!node.contains(word.charAt(i))){
                return false;
            }
            node=node.get(word.charAt(i));
        }
        if(node.isEnd())
            return true;
        return false;
    }
    
    public boolean startsWith(String prefix) {
        Node node=root;
        for(int i=0;i<prefix.length();i++){
            if(!node.contains(prefix.charAt(i))){
                return false;
            }
            node=node.get(prefix.charAt(i));
        }
        return true;
    }
}",None,"class Node{
    Node links[]= new Node[26];
    boolean flag=false;
    public Node(){

    }
    boolean contains(char ch){
        return (links[ch-'a']!=null);
    }
    void put(char ch, Node node){
        links[ch-'a']=node;
    }
    Node get(char ch){
        return links[ch-'a'];
    }
    boolean isEnd(){
        return flag;
    }
    void setEnd(){
        flag=true;
    }

}
class Trie {
private static Node root;
    public Trie() {
        root=new Node();
    }
    
    public void insert(String word) {
        Node node=root;
        for(int i=0;i<word.length();i++){
            if(!node.contains(word.charAt(i))){
                node.put(word.charAt(i),new Node());
            }
            node=node.get(word.charAt(i));
        }
        node.setEnd();
    }
    
    public boolean search(String word) {
        Node node=root;
        for(int i=0;i<word.length();i++){
            if(!node.contains(word.charAt(i))){
                return false;
            }
            node=node.get(word.charAt(i));
        }
        if(node.isEnd())
            return true;
        return false;
    }
    
    public boolean startsWith(String prefix) {
        Node node=root;
        for(int i=0;i<prefix.length();i++){
            if(!node.contains(prefix.charAt(i))){
                return false;
            }
            node=node.get(prefix.charAt(i));
        }
        return true;
    }
}
"
1468,java,implement-trie-prefix-tree,"class Node{
    Node links[]= new Node[26];
    boolean flag=false;
    public Node(){

    }
    boolean contains(char ch){
        return (links[ch-'a']!=null);
    }
    void put(char ch, Node node){
        links[ch-'a']=node;
    }
    Node get(char ch){
        return links[ch-'A'];
    }
    boolean isEnd(){
        return flag;
    }
    void setEnd(){
        flag=true;
    }

}
class Trie {
private static Node root;
    public Trie() {
        root=new Node();
    }
    
    public void insert(String word) {
        Node node=root;
        for(int i=0;i<word.length();i++){
            if(!node.contains(word.charAt(i))){
                node.put(word.charAt(i),new Node());
            }
            node=node.get(word.charAt(i));
        }
        node.setEnd();
    }
    
    public boolean search(String word) {
        Node node=root;
        for(int i=0;i<word.length();i++){
            if(!node.contains(word.charAt(i))){
                return false;
            }
            node=node.get(word.charAt(i));
        }
        if(node.isEnd())
            return true;
        return false;
    }
    
    public boolean startsWith(String prefix) {
        Node node=root;
        for(int i=0;i<prefix.length();i++){
            if(!node.contains(prefix.charAt(i))){
                return false;
            }
            node=node.get(prefix.charAt(i));
        }
        return true;
    }
}",None,"class Node{
    Node links[]= new Node[26];
    boolean flag=false;
    public Node(){

    }
    boolean contains(char ch){
        return (links[ch-'a']!=null);
    }
    void put(char ch, Node node){
        links[ch-'a']=node;
    }
    Node get(char ch){
        return links[ch-'a'];
    }
    boolean isEnd(){
        return flag;
    }
    void setEnd(){
        flag=true;
    }

}
"
1469,java,account-balance-after-rounded-purchase,"class Solution {
    public int accountBalanceAfterPurchase(int amt) {
        if(amt%10 == 0)
        {
            return 100-amt;
        }
        int ans=100+amt;
        return amt%10 >= 5 ? (ans/10)*10 : ((ans/10)+1)*10;
    }
}",None,"class Solution {
    public int accountBalanceAfterPurchase(int amt) {
        if(amt%10 == 0)
        {
            return 100-amt;
        }
        int roundedAmount = (amt + 5) / 10 * 10;
        return 100 - roundedAmount;
    }
}
"
1469,java,account-balance-after-rounded-purchase,"class Solution {
    public int accountBalanceAfterPurchase(int amt) {
        if(amt%10 == 0)
        {
            return 100-amt;
        }
        int ans=100+amt;
        return amt%10 >= 5 ? (ans/10)*10 : ((ans/10)+1)*10;
    }
}",None,"class Solution {
    public int accountBalanceAfterPurchase(int amt) {
        if(amt%10 == 0)
        {
            return 100-amt;
        }
        int roundedAmt = (amt/10 + (amt%10 >= 5 ? 1 : 0)) * 10;
        return 100 - roundedAmt;
    }
}
"
1469,java,account-balance-after-rounded-purchase,"class Solution {
    public int accountBalanceAfterPurchase(int amt) {
        if(amt%10 == 0)
        {
            return 100-amt;
        }
        int ans=100+amt;
        return amt%10 >= 5 ? (ans/10)*10 : ((ans/10)+1)*10;
    }
}",None,"class Solution {
    public int accountBalanceAfterPurchase(int amt) {
        if(amt%10 == 0)
        {
            return 100-amt;
        }
        int remainder = amt % 10;
        if(remainder >= 5) {
            amt -= remainder;
            amt += 10;
        }
        return 100 - amt;
    }
}
"
1470,java,n-repeated-element-in-size-2n-array,"class Solution {
    public int repeatedNTimes(int[] nums) {
        HashSet<Integer>set=new HashSet<>();
        for(int n:nums){
            if(!set.contains(n)){
                set.add(n);
            }else{
                return n+1;
            }
        }
        return 0;
    }
}",None,"class Solution {
    public int repeatedNTimes(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int n : nums) {
            if (set.contains(n)) {
                return n;
            } else {
                set.add(n);
            }
        }
        return -1; // This return statement is added to handle the case when the input is incorrect.
    }
}
"
1470,java,n-repeated-element-in-size-2n-array,"class Solution {
    public int repeatedNTimes(int[] nums) {
        HashSet<Integer>set=new HashSet<>();
        for(int n:nums){
            if(!set.contains(n)){
                set.add(n);
            }else{
                return n+1;
            }
        }
        return 0;
    }
}",None,"class Solution {
    public int repeatedNTimes(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int n : nums) {
            if (set.contains(n)) {
                return n;
            } else {
                set.add(n);
            }
        }
        return -1;
    }
}
"
1470,java,n-repeated-element-in-size-2n-array,"class Solution {
    public int repeatedNTimes(int[] nums) {
        HashSet<Integer>set=new HashSet<>();
        for(int n:nums){
            if(!set.contains(n)){
                set.add(n);
            }else{
                return n+1;
            }
        }
        return 0;
    }
}",None,"class Solution {
    public int repeatedNTimes(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int n : nums) {
            if (set.contains(n)) {
                return n;
            } else {
                set.add(n);
            }
        }
        return -1;
    }
}
"
1471,java,relative-ranks,"class Solution {
    public String[] findRelativeRanks(int[] score) {
         int n = score.length;
        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);
        for(int i=0;i<n;i++) pq.add(i);
        String[] ans = new String[n];
                int i=1;
        while(!pq.isEmpty()){
            int idx=pq.poll();
         if(i==1)   { ans[idx]=""Gold Medal""; i++;}
         else if(i==2)   { ans[idx]=""Silver Medal""; i++;}
         else if(i==3)   { ans[idx]=""Bronze Medal""; i++;}
         else ans[idx]=Integer.toString(i++);
        }
        return ans;  
    }
}",None,"class Solution {
    public String[] findRelativeRanks(int[] score) {
         int n = score.length;
        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);
        for(int i=0;i<n;i++) pq.add(i);
        String[] ans = new String[n];
        int i=1;
        while(!pq.isEmpty()){
            int idx=pq.poll();
            if(i==1) { ans[idx]=""Gold Medal""; i++;}
            else if(i==2) { ans[idx]=""Silver Medal""; i++;}
            else if(i==3) { ans[idx]=""Bronze Medal""; i++;}
            else ans[idx]=Integer.toString(i++);
        }
        return ans;  
    }
}
"
1471,java,relative-ranks,"class Solution {
    public String[] findRelativeRanks(int[] score) {
         int n = score.length;
        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);
        for(int i=0;i<n;i++) pq.add(i);
        String[] ans = new String[n];
                int i=1;
        while(!pq.isEmpty()){
            int idx=pq.poll();
         if(i==1)   { ans[idx]=""Gold Medal""; i++;}
         else if(i==2)   { ans[idx]=""Silver Medal""; i++;}
         else if(i==3)   { ans[idx]=""Bronze Medal""; i++;}
         else ans[idx]=Integer.toString(i++);
        }
        return ans;  
    }
}",None,"class Solution {
    public String[] findRelativeRanks(int[] score) {
         int n = score.length;
        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);
        for(int i=0;i<n;i++) pq.add(i);
        String[] ans = new String[n];
        int i=1;
        while(!pq.isEmpty()){
            int idx=pq.poll();
            if(i==1) { ans[idx]=""Gold Medal""; i++;} 
            else if(i==2) { ans[idx]=""Silver Medal""; i++;} 
            else if(i==3) { ans[idx]=""Bronze Medal""; i++;} 
            else ans[idx]=Integer.toString(i++);
        }
        return ans;  
    }
}
"
1471,java,relative-ranks,"class Solution {
    public String[] findRelativeRanks(int[] score) {
         int n = score.length;
        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);
        for(int i=0;i<n;i++) pq.add(i);
        String[] ans = new String[n];
                int i=1;
        while(!pq.isEmpty()){
            int idx=pq.poll();
         if(i==1)   { ans[idx]=""Gold Medal""; i++;}
         else if(i==2)   { ans[idx]=""Silver Medal""; i++;}
         else if(i==3)   { ans[idx]=""Bronze Medal""; i++;}
         else ans[idx]=Integer.toString(i++);
        }
        return ans;  
    }
}",None,"class Solution {
    public String[] findRelativeRanks(int[] score) {
         int n = score.length;
        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);
        for(int i=0;i<n;i++) pq.add(i);
        String[] ans = new String[n];
        int i=1;
        while(!pq.isEmpty()){
            int idx=pq.poll();
            if(i==1) { ans[idx]=""Gold Medal""; i++;}
            else if(i==2) { ans[idx]=""Silver Medal""; i++;}
            else if(i==3) { ans[idx]=""Bronze Medal""; i++;}
            else ans[idx]=Integer.toString(i++);
        }
        return ans;  
    }
}
"
1472,java,tuple-with-same-product,"class Solution {
    public int tupleSameProduct(int[] nums) {
        int m = nums.length;
        int factor = 0;
        HashMap<Integer, Integer> hm = new HashMap<>();
        for(int i = 0; i < m - 1; i ++) {
            for(int j = i + 1; j < m; j ++) {
                int curNumber = nums[i] * nums[j];
                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;
                hm.put(curNumber, curNumberCount);
            }
        }
        
        
		
        for(Integer key: hm.keySet()) {
            int count = hm.get(key);
            if(count == 1) continue;
            factor += (count - 1) / 2; 
        }
        return factor * 8;
    }
}",None,"class Solution {
    public int tupleSameProduct(int[] nums) {
        int m = nums.length;
        int factor = 0;
        HashMap<Integer, Integer> hm = new HashMap<>();
        for(int i = 0; i < m - 1; i ++) {
            for(int j = i + 1; j < m; j ++) {
                int curNumber = nums[i] * nums[j];
                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;
                hm.put(curNumber, curNumberCount);
            }
        }
        for(Integer key: hm.keySet()) {
            int count = hm.get(key);
            if(count == 1) continue;
            factor += (count - 1) * 2; 
        }
        return factor / 2;
    }
}
"
1472,java,tuple-with-same-product,"class Solution {
    public int tupleSameProduct(int[] nums) {
        int m = nums.length;
        int factor = 0;
        HashMap<Integer, Integer> hm = new HashMap<>();
        for(int i = 0; i < m - 1; i ++) {
            for(int j = i + 1; j < m; j ++) {
                int curNumber = nums[i] * nums[j];
                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;
                hm.put(curNumber, curNumberCount);
            }
        }
        
        
		
        for(Integer key: hm.keySet()) {
            int count = hm.get(key);
            if(count == 1) continue;
            factor += (count - 1) / 2; 
        }
        return factor * 8;
    }
}",None,"class Solution {
    public int tupleSameProduct(int[] nums) {
        int m = nums.length;
        int factor = 0;
        HashMap<Integer, Integer> hm = new HashMap<>();
        for(int i = 0; i < m - 1; i ++) {
            for(int j = i + 1; j < m; j ++) {
                int curNumber = nums[i] * nums[j];
                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;
                hm.put(curNumber, curNumberCount);
            }
        }
        
        for(Integer key: hm.keySet()) {
            int count = hm.get(key);
            if(count == 1) continue;
            factor += (count - 1) * 2; 
        }
        return factor / 2 * 8;
    }
}
"
1472,java,tuple-with-same-product,"class Solution {
    public int tupleSameProduct(int[] nums) {
        int m = nums.length;
        int factor = 0;
        HashMap<Integer, Integer> hm = new HashMap<>();
        for(int i = 0; i < m - 1; i ++) {
            for(int j = i + 1; j < m; j ++) {
                int curNumber = nums[i] * nums[j];
                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;
                hm.put(curNumber, curNumberCount);
            }
        }
        
        
		
        for(Integer key: hm.keySet()) {
            int count = hm.get(key);
            if(count == 1) continue;
            factor += (count - 1) / 2; 
        }
        return factor * 8;
    }
}",None,"class Solution {
    public int tupleSameProduct(int[] nums) {
        int m = nums.length;
        int factor = 0;
        HashMap<Integer, Integer> hm = new HashMap<>();
        for(int i = 0; i < m - 1; i ++) {
            for(int j = i + 1; j < m; j ++) {
                int curNumber = nums[i] * nums[j];
                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;
                hm.put(curNumber, curNumberCount);
            }
        }

        for(Integer key: hm.keySet()) {
            int count = hm.get(key);
            if(count == 1) continue;
            factor += (count - 1) * 2; 
        }
        return factor / 2 * 8;
    }
}
"
1473,java,probability-of-a-two-boxes-having-the-same-number-of-distinct-balls,"class Solution {
    double possible = 0.0;
    double valid = 0.0;
    
    public double getProbability(int[] balls) {
        int[] first = new int[balls.length];
        int[] second = new int[balls.length];
        dfs(balls, first, second, 0, 0, 0);
        return valid / possible;
    }
    
    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {
        if (idx == balls.length) {
            if (num1 == num2) {
                double distrib = permFake(first) * permFake(second);
                possible += distrib;
                if (unique(first) == unique(second)) {
                    valid += distrib + 1;    
                }
            }
            return;
        }
        for (int b = 0; b <= balls[idx]; b++) {
            first[idx] = b;
            second[idx] = balls[idx] - b;
            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);
        }
    }
    
    private int unique(int[] balls) {
        int unique = 0;
        for (int b: balls)
            unique += b > 0 ? 1 : 0;
        return unique;
    }
    
    private double permFake(int[] balls) {
        double ret = 1.0;
        for (int b: balls)
            ret /= factorial(b);
        return ret;
    }
    
    private int factorial(int n){
        int ret = 1;
        while (n > 0) {
            ret *= n;
            n--;
        }
        return ret;
    }
}",None,"class Solution {
    double possible = 0.0;
    double valid = 0.0;

    public double getProbability(int[] balls) {
        int[] first = new int[balls.length];
        int[] second = new int[balls.length];
        dfs(balls, first, second, 0, 0, 0);
        return valid / possible;
    }

    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {
        if (idx == balls.length) {
            if (num1 == num2) {
                double distrib = permFake(first) * permFake(second);
                possible += distrib;
                if (unique(first) == unique(second)) {
                    valid += distrib;
                }
            }
            return;
        }
        for (int b = 0; b <= balls[idx]; b++) {
            first[idx] = b;
            second[idx] = balls[idx] - b;
            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);
        }
    }

    private int unique(int[] balls) {
        int unique = 0;
        for (int b: balls)
            unique += b > 0 ? 1 : 0;
        return unique;
    }

    private double permFake(int[] balls) {
        double ret = 1.0;
        for (int b: balls)
            ret *= b > 0 ? factorial(b) : 1;
        return ret;
    }

    private int factorial(int n){
        int ret = 1;
        while (n > 1) {
            ret *= n;
            n--;
        }
        return ret;
    }
}
"
1473,java,probability-of-a-two-boxes-having-the-same-number-of-distinct-balls,"class Solution {
    double possible = 0.0;
    double valid = 0.0;
    
    public double getProbability(int[] balls) {
        int[] first = new int[balls.length];
        int[] second = new int[balls.length];
        dfs(balls, first, second, 0, 0, 0);
        return valid / possible;
    }
    
    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {
        if (idx == balls.length) {
            if (num1 == num2) {
                double distrib = permFake(first) * permFake(second);
                possible += distrib;
                if (unique(first) == unique(second)) {
                    valid += distrib + 1;    
                }
            }
            return;
        }
        for (int b = 0; b <= balls[idx]; b++) {
            first[idx] = b;
            second[idx] = balls[idx] - b;
            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);
        }
    }
    
    private int unique(int[] balls) {
        int unique = 0;
        for (int b: balls)
            unique += b > 0 ? 1 : 0;
        return unique;
    }
    
    private double permFake(int[] balls) {
        double ret = 1.0;
        for (int b: balls)
            ret /= factorial(b);
        return ret;
    }
    
    private int factorial(int n){
        int ret = 1;
        while (n > 0) {
            ret *= n;
            n--;
        }
        return ret;
    }
}",None,"class Solution {
    double possible = 0.0;
    double valid = 0.0;
    
    public double getProbability(int[] balls) {
        int[] first = new int[balls.length];
        int[] second = new int[balls.length];
        dfs(balls, first, second, 0, 0, 0);
        return valid / possible;
    }
    
    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {
        if (idx == balls.length) {
            if (num1 == num2) {
                double distrib = permFake(first) * permFake(second);
                possible += distrib;
                if (unique(first) == unique(second)) {
                    valid += distrib;    
                }
            }
            return;
        }
        for (int b = 0; b <= balls[idx]; b++) {
            first[idx] = b;
            second[idx] = balls[idx] - b;
            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);
        }
    }
    
    private int unique(int[] balls) {
        int unique = 0;
        for (int b: balls)
            unique += b > 0 ? 1 : 0;
        return unique;
    }
    
    private double permFake(int[] balls) {
        double ret = 1.0;
        for (int b: balls)
            ret *= fact(b);
        return ret;
    }
    
    private int fact(int n){
        if(n==0)
            return 1;
        return n*fact(n-1);
    }
}
"
1473,java,probability-of-a-two-boxes-having-the-same-number-of-distinct-balls,"class Solution {
    double possible = 0.0;
    double valid = 0.0;
    
    public double getProbability(int[] balls) {
        int[] first = new int[balls.length];
        int[] second = new int[balls.length];
        dfs(balls, first, second, 0, 0, 0);
        return valid / possible;
    }
    
    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {
        if (idx == balls.length) {
            if (num1 == num2) {
                double distrib = permFake(first) * permFake(second);
                possible += distrib;
                if (unique(first) == unique(second)) {
                    valid += distrib + 1;    
                }
            }
            return;
        }
        for (int b = 0; b <= balls[idx]; b++) {
            first[idx] = b;
            second[idx] = balls[idx] - b;
            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);
        }
    }
    
    private int unique(int[] balls) {
        int unique = 0;
        for (int b: balls)
            unique += b > 0 ? 1 : 0;
        return unique;
    }
    
    private double permFake(int[] balls) {
        double ret = 1.0;
        for (int b: balls)
            ret /= factorial(b);
        return ret;
    }
    
    private int factorial(int n){
        int ret = 1;
        while (n > 0) {
            ret *= n;
            n--;
        }
        return ret;
    }
}",None,"class Solution {
    double possible = 0.0;
    double valid = 0.0;
    
    public double getProbability(int[] balls) {
        int[] first = new int[balls.length];
        int[] second = new int[balls.length];
        dfs(balls, first, second, 0, 0, 0);
        return valid / possible;
    }
    
    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {
        if (idx == balls.length) {
            if (num1 == num2) {
                double distrib = permFake(first) * permFake(second);
                possible += distrib;
                if (unique(first) == unique(second)) {
                    valid += distrib;    
                }
            }
            return;
        }
        for (int b = 0; b <= balls[idx]; b++) {
            first[idx] = b;
            second[idx] = balls[idx] - b;
            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);
        }
    }
    
    private int unique(int[] balls) {
        int unique = 0;
        for (int b: balls)
            unique += b > 0 ? 1 : 0;
        return unique;
    }
    
    private double permFake(int[] balls) {
        double ret = 1.0;
        for (int b: balls)
            ret *= factorial(b);
        return ret;
    }
    
    private int factorial(int n){
        int ret = 1;
        while (n > 1) {
            ret *= n;
            n--;
        }
        return ret;
    }
}
"
1474,java,domino-and-tromino-tiling,"class Solution {
    private long[] dp;
    int MOD = (int)Math.pow(10 , 9) + 7;
    public long solve(int n){
        if(n==0) return 1;
        if(n<3) return n;

        if(dp[n]!=-1) return dp[n];

        return dp[n] = 2*solve(n-1)%MOD+solve(n-2)%MOD;
    }
    public int numTilings(int n) {
        this.dp = new long[n+1];
        Arrays.fill(dp , -1);

        return (int)solve(n)%MOD;
    }
}",None,"class Solution {
    private long[] dp;
    int MOD = (int)Math.pow(10 , 9) + 7;
    public long solve(int n){
        if(n==0) return 1;
        if(n<3) return n;

        if(dp[n]!=0) return dp[n];

        return dp[n] = (2*solve(n-1)%MOD+solve(n-2)%MOD)%MOD;
    }
    public int numTilings(int n) {
        this.dp = new long[n+1];
        dp[0] = 1;
        dp[1] = 1;
        dp[2] = 2;

        return (int)solve(n)%MOD;
    }
}
"
1474,java,domino-and-tromino-tiling,"class Solution {
    private long[] dp;
    int MOD = (int)Math.pow(10 , 9) + 7;
    public long solve(int n){
        if(n==0) return 1;
        if(n<3) return n;

        if(dp[n]!=-1) return dp[n];

        return dp[n] = 2*solve(n-1)%MOD+solve(n-2)%MOD;
    }
    public int numTilings(int n) {
        this.dp = new long[n+1];
        Arrays.fill(dp , -1);

        return (int)solve(n)%MOD;
    }
}",None,"class Solution {
    private long[] dp;
    int MOD = (int)Math.pow(10 , 9) + 7;
    public long solve(int n){
        if(n==0) return 1;
        if(n<3) return n;

        if(dp[n]!=0) return dp[n];

        return dp[n] = (2*solve(n-1)%MOD+solve(n-2)%MOD)%MOD;
    }
    public int numTilings(int n) {
        this.dp = new long[n+1];
        Arrays.fill(dp , -1);

        return (int)solve(n);
    }
}
"
1474,java,domino-and-tromino-tiling,"class Solution {
    private long[] dp;
    int MOD = (int)Math.pow(10 , 9) + 7;
    public long solve(int n){
        if(n==0) return 1;
        if(n<3) return n;

        if(dp[n]!=-1) return dp[n];

        return dp[n] = 2*solve(n-1)%MOD+solve(n-2)%MOD;
    }
    public int numTilings(int n) {
        this.dp = new long[n+1];
        Arrays.fill(dp , -1);

        return (int)solve(n)%MOD;
    }
}",None,"class Solution {
    private long[] dp;
    int MOD = (int)Math.pow(10 , 9) + 7;
    public long solve(int n){
        if(n==0) return 1;
        if(n<3) return n;

        if(dp[n]!=0) return dp[n];

        return dp[n] = 2*solve(n-1)%MOD+solve(n-3)%MOD;
    }
    public int numTilings(int n) {
        this.dp = new long[n+1];
        Arrays.fill(dp , 0);

        return (int)solve(n)%MOD;
    }
}
"
1475,java,make-array-strictly-increasing,"class Solution { 
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        Arrays.sort(arr2);
        
        int answer = helper(0, -1, arr1, arr2);
        
        return answer < Integer.MAX_VALUE-100 ? answer : -1;
    }
    
    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();
    private int helper(int i, int prev, int[] arr1, int[] arr2) {
        if (i == arr1.length) {
            return 0;
        }
        if (dp.containsKey(new Pair<>(i, prev))) {
            return dp.get(new Pair<>(i, prev));
        }

        int operation = Integer.MAX_VALUE-100;

        
        if (arr1[i] > prev) {
            operation = helper(i + 1, arr1[i], arr1, arr2);
        }

       
        int idx = binarySearch(arr2, prev);

        
        if (idx < arr2.length) {
            operation = helper(i + 1, arr2[idx], arr1, arr2);
        }

        dp.put(new Pair<>(i, prev),operation);
        return operation;
    }
    
    private static int binarySearch(int[] arr, int value) {
        int left = 0, right = arr.length-1;
        while (left <= right) {
            int mid = left+(right-left) / 2;
            if (arr[mid] <= value) {
                left = mid + 1;
            } else {
                right = mid-1;
            }
        }
        return left;
    } 
}",None,"class Solution { 
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        Arrays.sort(arr2);
        
        int answer = helper(0, Integer.MIN_VALUE, arr1, arr2);
        
        return answer >= Integer.MAX_VALUE ? -1 : answer;
    }
    
    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();
    private int helper(int i, int prev, int[] arr1, int[] arr2) {
        if (i == arr1.length) {
            return 0;
        }
        if (dp.containsKey(new Pair<>(i, prev))) {
            return dp.get(new Pair<>(i, prev));
        }

        int operation = Integer.MAX_VALUE;

        if (arr1[i] > prev) {
            operation = helper(i + 1, arr1[i], arr1, arr2);
        }

        int idx = binarySearch(arr2, prev);

        if (idx < arr2.length) {
            operation = Math.min(operation, helper(i + 1, arr2[idx], arr1, arr2) + 1);
        }

        dp.put(new Pair<>(i, prev),operation);
        return operation;
    }
    
    private static int binarySearch(int[] arr, int value) {
        int left = 0, right = arr.length;
        while (left < right) {
            int mid = left+(right-left) / 2;
            if (arr[mid] >= value) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    } 
}
"
1475,java,make-array-strictly-increasing,"class Solution { 
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        Arrays.sort(arr2);
        
        int answer = helper(0, -1, arr1, arr2);
        
        return answer < Integer.MAX_VALUE-100 ? answer : -1;
    }
    
    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();
    private int helper(int i, int prev, int[] arr1, int[] arr2) {
        if (i == arr1.length) {
            return 0;
        }
        if (dp.containsKey(new Pair<>(i, prev))) {
            return dp.get(new Pair<>(i, prev));
        }

        int operation = Integer.MAX_VALUE-100;

        
        if (arr1[i] > prev) {
            operation = helper(i + 1, arr1[i], arr1, arr2);
        }

       
        int idx = binarySearch(arr2, prev);

        
        if (idx < arr2.length) {
            operation = helper(i + 1, arr2[idx], arr1, arr2);
        }

        dp.put(new Pair<>(i, prev),operation);
        return operation;
    }
    
    private static int binarySearch(int[] arr, int value) {
        int left = 0, right = arr.length-1;
        while (left <= right) {
            int mid = left+(right-left) / 2;
            if (arr[mid] <= value) {
                left = mid + 1;
            } else {
                right = mid-1;
            }
        }
        return left;
    } 
}",None,"class Solution { 
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        Arrays.sort(arr2);
        
        int answer = helper(0, Integer.MIN_VALUE, arr1, arr2);
        
        return answer < Integer.MAX_VALUE-100 ? answer : -1;
    }
    
    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();
    private int helper(int i, int prev, int[] arr1, int[] arr2) {
        if (i == arr1.length) {
            return 0;
        }
        if (dp.containsKey(new Pair<>(i, prev))) {
            return dp.get(new Pair<>(i, prev));
        }

        int operation = Integer.MAX_VALUE;

        if (arr1[i] > prev) {
            operation = helper(i + 1, arr1[i], arr1, arr2);
        }

        int idx = binarySearch(arr2, prev);

        if (idx < arr2.length) {
            operation = Math.min(operation, helper(i + 1, arr2[idx], arr1, arr2));
        }

        dp.put(new Pair<>(i, prev),operation);
        return operation;
    }
    
    private static int binarySearch(int[] arr, int value) {
        int left = 0, right = arr.length;
        while (left < right) {
            int mid = left+(right-left) / 2;
            if (arr[mid] >= value) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    } 
}
"
1475,java,make-array-strictly-increasing,"class Solution { 
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        Arrays.sort(arr2);
        
        int answer = helper(0, -1, arr1, arr2);
        
        return answer < Integer.MAX_VALUE-100 ? answer : -1;
    }
    
    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();
    private int helper(int i, int prev, int[] arr1, int[] arr2) {
        if (i == arr1.length) {
            return 0;
        }
        if (dp.containsKey(new Pair<>(i, prev))) {
            return dp.get(new Pair<>(i, prev));
        }

        int operation = Integer.MAX_VALUE-100;

        
        if (arr1[i] > prev) {
            operation = helper(i + 1, arr1[i], arr1, arr2);
        }

       
        int idx = binarySearch(arr2, prev);

        
        if (idx < arr2.length) {
            operation = helper(i + 1, arr2[idx], arr1, arr2);
        }

        dp.put(new Pair<>(i, prev),operation);
        return operation;
    }
    
    private static int binarySearch(int[] arr, int value) {
        int left = 0, right = arr.length-1;
        while (left <= right) {
            int mid = left+(right-left) / 2;
            if (arr[mid] <= value) {
                left = mid + 1;
            } else {
                right = mid-1;
            }
        }
        return left;
    } 
}",None,"class Solution { 
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        Arrays.sort(arr2);
        
        int answer = helper(0, Integer.MIN_VALUE, arr1, arr2);
        
        return answer < Integer.MAX_VALUE-100 ? answer : -1;
    }
    
    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();
    private int helper(int i, int prev, int[] arr1, int[] arr2) {
        if (i == arr1.length) {
            return 0;
        }
        if (dp.containsKey(new Pair<>(i, prev))) {
            return dp.get(new Pair<>(i, prev));
        }

        int operation = Integer.MAX_VALUE;

        if (arr1[i] > prev) {
            operation = helper(i + 1, arr1[i], arr1, arr2);
        }

        int idx = binarySearch(arr2, prev);

        if (idx < arr2.length) {
            operation = Math.min(operation, helper(i + 1, arr2[idx], arr1, arr2) + 1);
        }

        dp.put(new Pair<>(i, prev),operation);
        return operation;
    }
    
    private static int binarySearch(int[] arr, int value) {
        int left = 0, right = arr.length;
        while (left < right) {
            int mid = left+(right-left) / 2;
            if (arr[mid] <= value) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    } 
}
"
1476,java,queens-that-can-attack-the-king,"class Solution {
    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {
        boolean[][] q = new boolean[8][8];
        for (int[] queen: queens) {
            q[queen[0]][queen[1]] = true;
        }
        List<List<Integer>> output = new ArrayList<>();
        int[][] moves = {{-1,-1}, {0,-1}, {1,-1},{1,0}, {1,1}, {0,1}, {-1,1}, {-1,0}};
        for(int i = 0; i < moves.length; i++){
            int k = king[0] + moves[i][0];
            int l = king[1] + moves[i][1];
            while(k >= 0 && l >=0 && k < 8 && l < 8){
                if(q[k][l]){
                    List<Integer> pair = new ArrayList<>();
                    pair.add(k);
                    pair.add(l);
                    output.add(pair);
                    break;
                }
                k = k + moves[i][1]; 
                l = l + moves[i][1];
            }
        }
        
        return output;
    }
}",None,"class Solution {
    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {
        boolean[][] q = new boolean[8][8];
        for (int[] queen: queens) {
            q[queen[0]][queen[1]] = true;
        }
        List<List<Integer>> output = new ArrayList<>();
        int[][] moves = {{-1,-1}, {0,-1}, {1,-1},{1,0}, {1,1}, {0,1}, {-1,1}, {-1,0}};
        for(int i = 0; i < moves.length; i++){
            int k = king[0] + moves[i][0];
            int l = king[1] + moves[i][1];
            while(k >= 0 && l >=0 && k < 8 && l < 8){
                if(q[k][l]){
                    List<Integer> pair = new ArrayList<>();
                    pair.add(k);
                    pair.add(l);
                    output.add(pair);
                    break;
                }
                k += moves[i][0]; 
                l += moves[i][1];
            }
        }
        
        return output;
    }
}
"
1476,java,queens-that-can-attack-the-king,"class Solution {
    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {
        boolean[][] q = new boolean[8][8];
        for (int[] queen: queens) {
            q[queen[0]][queen[1]] = true;
        }
        List<List<Integer>> output = new ArrayList<>();
        int[][] moves = {{-1,-1}, {0,-1}, {1,-1},{1,0}, {1,1}, {0,1}, {-1,1}, {-1,0}};
        for(int i = 0; i < moves.length; i++){
            int k = king[0] + moves[i][0];
            int l = king[1] + moves[i][1];
            while(k >= 0 && l >=0 && k < 8 && l < 8){
                if(q[k][l]){
                    List<Integer> pair = new ArrayList<>();
                    pair.add(k);
                    pair.add(l);
                    output.add(pair);
                    break;
                }
                k = k + moves[i][1]; 
                l = l + moves[i][1];
            }
        }
        
        return output;
    }
}",None,"class Solution {
    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {
        boolean[][] q = new boolean[8][8];
        for (int[] queen: queens) {
            q[queen[0]][queen[1]] = true;
        }
        List<List<Integer>> output = new ArrayList<>();
        int[][] moves = {{-1,-1}, {0,-1}, {1,-1},{1,0}, {1,1}, {0,1}, {-1,1}, {-1,0}};
        for(int i = 0; i < moves.length; i++){
            int k = king[0] + moves[i][0];
            int l = king[1] + moves[i][1];
            while(k >= 0 && l >=0 && k < 8 && l < 8){
                if(q[k][l]){
                    List<Integer> pair = new ArrayList<>();
                    pair.add(k);
                    pair.add(l);
                    output.add(pair);
                    break;
                }
                k += moves[i][0]; 
                l += moves[i][1];
            }
        }
        
        return output;
    }
}
"
1476,java,queens-that-can-attack-the-king,"class Solution {
    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {
        boolean[][] q = new boolean[8][8];
        for (int[] queen: queens) {
            q[queen[0]][queen[1]] = true;
        }
        List<List<Integer>> output = new ArrayList<>();
        int[][] moves = {{-1,-1}, {0,-1}, {1,-1},{1,0}, {1,1}, {0,1}, {-1,1}, {-1,0}};
        for(int i = 0; i < moves.length; i++){
            int k = king[0] + moves[i][0];
            int l = king[1] + moves[i][1];
            while(k >= 0 && l >=0 && k < 8 && l < 8){
                if(q[k][l]){
                    List<Integer> pair = new ArrayList<>();
                    pair.add(k);
                    pair.add(l);
                    output.add(pair);
                    break;
                }
                k = k + moves[i][1]; 
                l = l + moves[i][1];
            }
        }
        
        return output;
    }
}",None,"class Solution {
    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {
        boolean[][] q = new boolean[8][8];
        for (int[] queen: queens) {
            q[queen[0]][queen[1]] = true;
        }
        List<List<Integer>> output = new ArrayList<>();
        int[][] moves = {{-1,-1}, {0,-1}, {1,-1},{1,0}, {1,1}, {0,1}, {-1,1}, {-1,0}};
        for(int i = 0; i < moves.length; i++){
            int k = king[0] + moves[i][0];
            int l = king[1] + moves[i][1];
            while(k >= 0 && l >=0 && k < 8 && l < 8){
                if(q[k][l]){
                    List<Integer> pair = new ArrayList<>();
                    pair.add(k);
                    pair.add(l);
                    output.add(pair);
                    break;
                }
                k += moves[i][0]; 
                l += moves[i][1];
            }
        }
        
        return output;
    }
}
"
1477,java,maximize-number-of-subsequences-in-a-string,"class Solution {

    public long maximumSubsequenceCount(String s, String p) {
        long ans = 0, max = 0;
        int cnt = 1;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == p.charAt(1)) ans += cnt;
            if (s.charAt(i) == p.charAt(0)) cnt--;
        }
        max = Math.max(max, ans);
        ans = 0; cnt = 1;
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == p.charAt(0)) ans += cnt;
            if (s.charAt(i) == p.charAt(1)) cnt++;
        }
        max = Math.max(max, ans);
        return max;
    }
}",None,"class Solution {

    public long maximumSubsequenceCount(String s, String p) {
        long ans = 0, max = 0;
        int cnt = 1;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == p.charAt(1)) ans += cnt;
            if (s.charAt(i) == p.charAt(0)) cnt--;
        }
        max = Math.max(max, ans);
        ans = 0; cnt = 1;
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == p.charAt(0)) ans += cnt;
            if (s.charAt(i) == p.charAt(1)) cnt++;
        }
        max = Math.max(max, ans);
        return max;
    }
}
"
1477,java,maximize-number-of-subsequences-in-a-string,"class Solution {

    public long maximumSubsequenceCount(String s, String p) {
        long ans = 0, max = 0;
        int cnt = 1;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == p.charAt(1)) ans += cnt;
            if (s.charAt(i) == p.charAt(0)) cnt--;
        }
        max = Math.max(max, ans);
        ans = 0; cnt = 1;
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == p.charAt(0)) ans += cnt;
            if (s.charAt(i) == p.charAt(1)) cnt++;
        }
        max = Math.max(max, ans);
        return max;
    }
}",None,"class Solution {

    public long maximumSubsequenceCount(String s, String p) {
        long ans = 0, max = 0;
        int cnt = 1;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == p.charAt(1)) ans += cnt;
            if (s.charAt(i) == p.charAt(0)) cnt--;
            else if (s.charAt(i) == p.charAt(1)) cnt++;
        }
        max = Math.max(max, ans);
        ans = 0; cnt = 1;
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == p.charAt(0)) ans += cnt;
            if (s.charAt(i) == p.charAt(1)) cnt++;
        }
        max = Math.max(max, ans);
        return max;
    }
}
"
1477,java,maximize-number-of-subsequences-in-a-string,"class Solution {

    public long maximumSubsequenceCount(String s, String p) {
        long ans = 0, max = 0;
        int cnt = 1;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == p.charAt(1)) ans += cnt;
            if (s.charAt(i) == p.charAt(0)) cnt--;
        }
        max = Math.max(max, ans);
        ans = 0; cnt = 1;
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == p.charAt(0)) ans += cnt;
            if (s.charAt(i) == p.charAt(1)) cnt++;
        }
        max = Math.max(max, ans);
        return max;
    }
}",None,"class Solution {

    public long maximumSubsequenceCount(String s, String p) {
        long ans = 0, max = 0;
        int cnt = 1;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == p.charAt(1)) ans += cnt;
            if (s.charAt(i) == p.charAt(0)) cnt--;
            if (cnt < 0) cnt = 0; // fix the bug here
        }
        max = Math.max(max, ans);
        ans = 0; cnt = 1;
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == p.charAt(0)) ans += cnt;
            if (s.charAt(i) == p.charAt(1)) cnt++;
        }
        max = Math.max(max, ans);
        return max;
    }
}
"
1478,java,destroying-asteroids,"class Solution {
    public boolean asteroidsDestroyed(int mass, int[] asteroids) {
        Arrays.sort(asteroids);
        int c=0;
        long s=(long)mass;
        for(int i=0;i<asteroids.length;i++)
        {
            long d=(long)asteroids[i];
            if(s>=d)
            {
                c-=1;
                s+=d;
            }
        }
        if(c==asteroids.length)return true;
        else return false;
    }
}",None,"class Solution {
    public boolean asteroidsDestroyed(int mass, int[] asteroids) {
        Arrays.sort(asteroids);
        long s=(long)mass;
        for(int i=0;i<asteroids.length;i++)
        {
            long d=(long)asteroids[i];
            if(s<d)
            {
                return false;
            }
            s+=d;
        }
        return true;
    }
}
"
1478,java,destroying-asteroids,"class Solution {
    public boolean asteroidsDestroyed(int mass, int[] asteroids) {
        Arrays.sort(asteroids);
        int c=0;
        long s=(long)mass;
        for(int i=0;i<asteroids.length;i++)
        {
            long d=(long)asteroids[i];
            if(s>=d)
            {
                c-=1;
                s+=d;
            }
        }
        if(c==asteroids.length)return true;
        else return false;
    }
}",None,"class Solution {
    public boolean asteroidsDestroyed(int mass, int[] asteroids) {
        Arrays.sort(asteroids);
        long s=(long)mass;
        for(int i=0;i<asteroids.length;i++)
        {
            long d=(long)asteroids[i];
            if(s<d)
            {
                return false;
            }
            s+=d;
        }
        return true;
    }
}
"
1478,java,destroying-asteroids,"class Solution {
    public boolean asteroidsDestroyed(int mass, int[] asteroids) {
        Arrays.sort(asteroids);
        int c=0;
        long s=(long)mass;
        for(int i=0;i<asteroids.length;i++)
        {
            long d=(long)asteroids[i];
            if(s>=d)
            {
                c-=1;
                s+=d;
            }
        }
        if(c==asteroids.length)return true;
        else return false;
    }
}",None,"class Solution {
    public boolean asteroidsDestroyed(int mass, int[] asteroids) {
        Arrays.sort(asteroids);
        int c=0;
        long s=(long)mass;
        for(int i=0;i<asteroids.length;i++)
        {
            long d=(long)asteroids[i];
            if(s>=d)
            {
                s+=d;
            }
            else
            {
                return false;
            }
        }
        return true;
    }
}
"
1479,java,maximum-number-of-achievable-transfer-requests,"class Solution:
    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:
        l=len(requests)
        for i in range(l,0,-1):
            for j in combinations(requests,i):
                if Counter(x for x ,y in j)==Counter(y for x,y in j):
                    return i-1
        return 0",None,"import itertools
from collections import Counter

class Solution:
    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:
        for i in range(len(requests), 0, -1):
            for combination in itertools.combinations(requests, i):
                in_out = Counter(x for x, y in combination)
                if in_out == Counter(y for x, y in combination):
                    return i
        return 0
"
1479,java,maximum-number-of-achievable-transfer-requests,"class Solution:
    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:
        l=len(requests)
        for i in range(l,0,-1):
            for j in combinations(requests,i):
                if Counter(x for x ,y in j)==Counter(y for x,y in j):
                    return i-1
        return 0",None,"from collections import Counter
from itertools import combinations

class Solution:
    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:
        l=len(requests)
        for i in range(l,0,-1):
            for j in combinations(requests,i):
                if Counter(x for x, y in j) == Counter(y for x, y in j):
                    return i
        return 0
"
1479,java,maximum-number-of-achievable-transfer-requests,"class Solution:
    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:
        l=len(requests)
        for i in range(l,0,-1):
            for j in combinations(requests,i):
                if Counter(x for x ,y in j)==Counter(y for x,y in j):
                    return i-1
        return 0",None,"import itertools
from collections import Counter

class Solution:
    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:
        for i in range(len(requests), 0, -1):
            for j in itertools.combinations(requests, i):
                in_out = Counter(x for x, y in j)
                if in_out == Counter(y for x, y in j):
                    return i
        return 0
"
1480,java,orderly-queue,"class Solution {
    public String orderlyQueue(String s, int k) {
        if(k>1){
            char ch[]=s.toCharArray();  
            Arrays.sort(ch);
            return String.valueOf(ch);
        }
        else{
             String str2=new String(s);
             for(int i=0;i<s.length();i++){
                s=s.substring(2)+s.charAt(1); 
                if(str2.compareTo(s)>0){
                    str2=s;
                } 
             }
             return str2;
        }     
    }
}",None,"class Solution {
    public String orderlyQueue(String s, int k) {
        if(k>1){
            char ch[]=s.toCharArray();  
            Arrays.sort(ch);
            return String.valueOf(ch);
        }
        else{
             String str2=new String(s);
             for(int i=0;i<s.length()-1;i++){
                s=s.substring(1) + s.charAt(0); 
                if(str2.compareTo(s)>0){
                    str2=s;
                } 
             }
             return str2;
        }     
    }
}
"
1480,java,orderly-queue,"class Solution {
    public String orderlyQueue(String s, int k) {
        if(k>1){
            char ch[]=s.toCharArray();  
            Arrays.sort(ch);
            return String.valueOf(ch);
        }
        else{
             String str2=new String(s);
             for(int i=0;i<s.length();i++){
                s=s.substring(2)+s.charAt(1); 
                if(str2.compareTo(s)>0){
                    str2=s;
                } 
             }
             return str2;
        }     
    }
}",None,"class Solution {
    public String orderlyQueue(String s, int k) {
        if(k>1){
            char ch[]=s.toCharArray();  
            Arrays.sort(ch);
            return String.valueOf(ch);
        }
        else{
            String str2=new String(s);
            for(int i=0;i<s.length()-1;i++){
                s=s.substring(1) + s.charAt(0); 
                if(str2.compareTo(s)>0){
                    str2=s;
                } 
            }
            return str2;
        }     
    }
}
"
1480,java,orderly-queue,"class Solution {
    public String orderlyQueue(String s, int k) {
        if(k>1){
            char ch[]=s.toCharArray();  
            Arrays.sort(ch);
            return String.valueOf(ch);
        }
        else{
             String str2=new String(s);
             for(int i=0;i<s.length();i++){
                s=s.substring(2)+s.charAt(1); 
                if(str2.compareTo(s)>0){
                    str2=s;
                } 
             }
             return str2;
        }     
    }
}",None,"class Solution {
    public String orderlyQueue(String s, int k) {
        if(k>1){
            char ch[]=s.toCharArray();  
            Arrays.sort(ch);
            return String.valueOf(ch);
        }
        else{
            String str2=new String(s);
            for(int i=0;i<s.length()-1;i++){
                s=s.substring(1) + s.charAt(0); 
                if(str2.compareTo(s)>0){
                    str2=s;
                } 
            }
            return str2;
        }     
    }
}
"
1481,java,find-palindrome-with-fixed-length,"class Solution {
    public long[] kthPalindrome(int[] queries, int intLength) {
        int n=queries.length;
        long ans[]=new long[n];
        int ans_i=0;
        
        
        int palindrome_present = ( intLength+1 )/2 ;
        
        long l=(long)Math.pow(10,palindrome_present-1);
        long r=(long)Math.pow(10,palindrome_present)-1;
        for(int q:queries){
            
            if(q<=(r-l+1)){
                String left_half=Long.toString(l+q-1);
                String right_half=(new StringBuilder(left_half)).reverse().toString();
                ans[ans_i]=-1; 
                
            }
            else{
                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );
            }
            
            ans_i++;
        }
        
        return ans;
    }
}",None,"class Solution {
    public long[] kthPalindrome(int[] queries, int intLength) {
        int n=queries.length;
        long ans[]=new long[n];
        int ans_i=0;
        
        int palindrome_present = ( intLength+1 )/2 ;
        
        long l=(long)Math.pow(10,palindrome_present-1);
        long r=(long)Math.pow(10,palindrome_present)-1;
        for(int q:queries){
            if(q <= r-l+1){
                String left_half = Long.toString(l + q - 1);
                String right_half = (new StringBuilder(left_half)).reverse().toString();
                ans[ans_i] = -1; 
            }
            else{
                long mid = (long) Math.pow(10, (intLength % 2 == 0) ? palindrome_present - 1 : palindrome_present);
                ans[ans_i] = mid * (long) Math.pow(10, palindrome_present - 1) + Long.parseLong(new StringBuilder(left_half).reverse().toString());
            }
            ans_i++;
        }
        
        return ans;
    }
}
"
1481,java,find-palindrome-with-fixed-length,"class Solution {
    public long[] kthPalindrome(int[] queries, int intLength) {
        int n=queries.length;
        long ans[]=new long[n];
        int ans_i=0;
        
        
        int palindrome_present = ( intLength+1 )/2 ;
        
        long l=(long)Math.pow(10,palindrome_present-1);
        long r=(long)Math.pow(10,palindrome_present)-1;
        for(int q:queries){
            
            if(q<=(r-l+1)){
                String left_half=Long.toString(l+q-1);
                String right_half=(new StringBuilder(left_half)).reverse().toString();
                ans[ans_i]=-1; 
                
            }
            else{
                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );
            }
            
            ans_i++;
        }
        
        return ans;
    }
}",None,"class Solution {
    public long[] kthPalindrome(int[] queries, int intLength) {
        int n=queries.length;
        long ans[]=new long[n];
        int ans_i=0;
        
        int palindrome_present = ( intLength+1 )/2 ;
        
        long l=(long)Math.pow(10,palindrome_present-1);
        long r=(long)Math.pow(10,palindrome_present)-1;
        for(int q:queries){
            
            if(q<=(r-l+1)){
                String left_half=Long.toString(l+q-1);
                String right_half=(new StringBuilder(left_half)).reverse().toString();
                ans[ans_i]=-1; 
            }
            else{
                String left_half = String.valueOf(q - (r - l + 1));
                String right_half = String.valueOf(q - (r - l + 1));
                while (left_half.length() < palindrome_present - 1) {
                    left_half = ""0"" + left_half;
                }
                ans[ans_i] = Long.parseLong(left_half + right_half);
            }
            
            ans_i++;
        }
        
        return ans;
    }
}
"
1481,java,find-palindrome-with-fixed-length,"class Solution {
    public long[] kthPalindrome(int[] queries, int intLength) {
        int n=queries.length;
        long ans[]=new long[n];
        int ans_i=0;
        
        
        int palindrome_present = ( intLength+1 )/2 ;
        
        long l=(long)Math.pow(10,palindrome_present-1);
        long r=(long)Math.pow(10,palindrome_present)-1;
        for(int q:queries){
            
            if(q<=(r-l+1)){
                String left_half=Long.toString(l+q-1);
                String right_half=(new StringBuilder(left_half)).reverse().toString();
                ans[ans_i]=-1; 
                
            }
            else{
                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );
            }
            
            ans_i++;
        }
        
        return ans;
    }
}",None,"class Solution {
    public long[] kthPalindrome(int[] queries, int intLength) {
        int n=queries.length;
        long ans[]=new long[n];
        int ans_i=0;
        
        int palindrome_present = ( intLength+1 )/2 ;
        
        long l=(long)Math.pow(10,palindrome_present-1);
        long r=(long)Math.pow(10,palindrome_present)-1;
        for(int q:queries){
            if(q <= (r-l+1)){
                String left_half=Long.toString(l+q-1);
                String right_half=(new StringBuilder(left_half)).reverse().toString();
                ans[ans_i] = -1;
            }
            else{
                String left_half = String.valueOf(q - (r - l + 1));
                String right_half = String.valueOf(q - (r - l + 1));
                while(left_half.length() < palindrome_present - 1) left_half = ""0"" + left_half;
                ans[ans_i] = Long.parseLong(left_half + right_half);
            }
            ans_i++;
        }
        
        return ans;
    }
}
"
1482,java,maximum-product-difference-between-two-pairs,"class Solution {
    public int maxProductDifference(int[] nums) {
        Arrays.sort(nums);
        int n =nums.length;
    return nums[n-1]*nums[n-3]-nums[0]*nums[1];
    }
}",None,"class Solution {
    public int maxProductDifference(int[] nums) {
        Arrays.sort(nums);
        int n =nums.length;
        return nums[n-1]*nums[n-2]-nums[0]*nums[1];
    }
}
"
1482,java,maximum-product-difference-between-two-pairs,"class Solution {
    public int maxProductDifference(int[] nums) {
        Arrays.sort(nums);
        int n =nums.length;
    return nums[n-1]*nums[n-3]-nums[0]*nums[1];
    }
}",None,"class Solution {
    public int maxProductDifference(int[] nums) {
        Arrays.sort(nums);
        int n =nums.length;
        return nums[n-1]*nums[n-2]-nums[0]*nums[1];
    }
}
"
1482,java,maximum-product-difference-between-two-pairs,"class Solution {
    public int maxProductDifference(int[] nums) {
        Arrays.sort(nums);
        int n =nums.length;
    return nums[n-1]*nums[n-3]-nums[0]*nums[1];
    }
}",None,"class Solution {
    public int maxProductDifference(int[] nums) {
        Arrays.sort(nums);
        int n =nums.length;
        return nums[n-1]*nums[n-2]-nums[0]*nums[1];
    }
}
"
1483,java,arithmetic-slices-ii-subsequence,"class Solution {
	public int numberOfArithmeticSlices(int[] arr) {
		int n = arr.length;
		HashMap<Integer, Integer>[] map = new HashMap[n];
		for (int i = 0; i < n; i++) {
			map[i] = new HashMap<>();
		}
		int ans = 0;
		for (int i = 1; i < n; i++) {
			for (int j = 0; j < i; j++) {
				long cd = (long) arr[i] - (long) arr[j];
				if (cd <= Integer.MIN_VALUE || cd >= Integer.MAX_VALUE)
					continue;
				int asj = map[j].getOrDefault((int) cd, 0);
				int asi = map[i].getOrDefault((int) cd, 0);
				ans += asj;
				map[i].put((int) cd, asi + 1); 
			}
		}
		return ans;
	}
}",None,"class Solution {
	public int numberOfArithmeticSlices(int[] arr) {
		int n = arr.length;
		HashMap<Integer, Integer>[] map = new HashMap[n];
		for (int i = 0; i < n; i++) {
			map[i] = new HashMap<>();
		}
		int ans = 0;
		for (int i = 1; i < n; i++) {
			for (int j = 0; j < i; j++) {
				long cd = (long) arr[i] - (long) arr[j];
				if (cd < Integer.MIN_VALUE || cd > Integer.MAX_VALUE)
					continue;
				int asj = map[j].getOrDefault((int) cd, 0);
				int asi = map[i].getOrDefault((int) cd, 0);
				ans += asj;
				map[i].put((int) cd, asi + 1); 
			}
		}
		return ans;
	}
}
"
1483,java,arithmetic-slices-ii-subsequence,"class Solution {
	public int numberOfArithmeticSlices(int[] arr) {
		int n = arr.length;
		HashMap<Integer, Integer>[] map = new HashMap[n];
		for (int i = 0; i < n; i++) {
			map[i] = new HashMap<>();
		}
		int ans = 0;
		for (int i = 1; i < n; i++) {
			for (int j = 0; j < i; j++) {
				long cd = (long) arr[i] - (long) arr[j];
				if (cd <= Integer.MIN_VALUE || cd >= Integer.MAX_VALUE)
					continue;
				int asj = map[j].getOrDefault((int) cd, 0);
				int asi = map[i].getOrDefault((int) cd, 0);
				ans += asj;
				map[i].put((int) cd, asi + 1); 
			}
		}
		return ans;
	}
}",None,"class Solution {
	public int numberOfArithmeticSlices(int[] arr) {
		int n = arr.length;
		HashMap<Integer, Integer>[] map = new HashMap[n];
		for (int i = 0; i < n; i++) {
			map[i] = new HashMap<>();
		}
		int ans = 0;
		for (int i = 1; i < n; i++) {
			for (int j = 0; j < i; j++) {
				long cd = (long) arr[i] - (long) arr[j];
				if (cd < Integer.MIN_VALUE || cd > Integer.MAX_VALUE)
					continue;
				int asj = map[j].getOrDefault((int) cd, 0);
				int asi = map[i].getOrDefault((int) cd, 0);
				ans += asj;
				map[i].put((int) cd, asi + 1); 
			}
		}
		return ans;
	}
}
"
1483,java,arithmetic-slices-ii-subsequence,"class Solution {
	public int numberOfArithmeticSlices(int[] arr) {
		int n = arr.length;
		HashMap<Integer, Integer>[] map = new HashMap[n];
		for (int i = 0; i < n; i++) {
			map[i] = new HashMap<>();
		}
		int ans = 0;
		for (int i = 1; i < n; i++) {
			for (int j = 0; j < i; j++) {
				long cd = (long) arr[i] - (long) arr[j];
				if (cd <= Integer.MIN_VALUE || cd >= Integer.MAX_VALUE)
					continue;
				int asj = map[j].getOrDefault((int) cd, 0);
				int asi = map[i].getOrDefault((int) cd, 0);
				ans += asj;
				map[i].put((int) cd, asi + 1); 
			}
		}
		return ans;
	}
}",None,"class Solution {
	public int numberOfArithmeticSlices(int[] arr) {
		int n = arr.length;
		HashMap<Integer, Integer>[] map = new HashMap[n];
		for (int i = 0; i < n; i++) {
			map[i] = new HashMap<>();
		}
		int ans = 0;
		for (int i = 1; i < n; i++) {
			for (int j = 0; j < i; j++) {
				long cd = (long) arr[i] - (long) arr[j];
				if (cd < Integer.MIN_VALUE || cd > Integer.MAX_VALUE)
					continue;
				int asj = map[j].getOrDefault((int) cd, 0);
				int asi = map[i].getOrDefault((int) cd, 0);
				ans += asj;
				map[i].put((int) cd, asi + 1); 
			}
		}
		return ans;
	}
}
"
1484,java,largest-substring-between-two-equal-characters,"class Solution {
    public int maxLengthBetweenEqualCharacters(String s) {
        int res=-1;
        HashMap<Character,Integer> hm=new HashMap<>();
        for(int i=0;i<s.length();i++){
            char c=s.charAt(i);
            if(hm.containsKey(c))
                res=Math.max(res,i-hm.get(c)+1); 
            else
                hm.put(c,i);
        }

        return res;
    }
}",None,"class Solution {
    public int maxLengthBetweenEqualCharacters(String s) {
        int res=-1;
        HashMap<Character,Integer> hm=new HashMap<>();
        for(int i=0;i<s.length();i++){
            char c=s.charAt(i);
            if(hm.containsKey(c))
                res=Math.max(res,i-hm.get(c)-1); 
            else
                hm.put(c,i);
        }

        return res;
    }
}
"
1484,java,largest-substring-between-two-equal-characters,"class Solution {
    public int maxLengthBetweenEqualCharacters(String s) {
        int res=-1;
        HashMap<Character,Integer> hm=new HashMap<>();
        for(int i=0;i<s.length();i++){
            char c=s.charAt(i);
            if(hm.containsKey(c))
                res=Math.max(res,i-hm.get(c)+1); 
            else
                hm.put(c,i);
        }

        return res;
    }
}",None,"class Solution {
    public int maxLengthBetweenEqualCharacters(String s) {
        int res=-1;
        HashMap<Character,Integer> hm=new HashMap<>();
        for(int i=0;i<s.length();i++){
            char c=s.charAt(i);
            if(hm.containsKey(c))
                res=Math.max(res,i-hm.get(c)-1); 
            else
                hm.put(c,i);
        }

        return res;
    }
}
"
1484,java,largest-substring-between-two-equal-characters,"class Solution {
    public int maxLengthBetweenEqualCharacters(String s) {
        int res=-1;
        HashMap<Character,Integer> hm=new HashMap<>();
        for(int i=0;i<s.length();i++){
            char c=s.charAt(i);
            if(hm.containsKey(c))
                res=Math.max(res,i-hm.get(c)+1); 
            else
                hm.put(c,i);
        }

        return res;
    }
}",None,"class Solution {
    public int maxLengthBetweenEqualCharacters(String s) {
        int res=-1;
        HashMap<Character,Integer> hm=new HashMap<>();
        for(int i=0;i<s.length();i++){
            char c=s.charAt(i);
            if(hm.containsKey(c))
                res=Math.max(res,i-hm.get(c)-1); 
            else
                hm.put(c,i);
        }

        return res;
    }
}
"
1485,java,difference-between-element-sum-and-digit-sum-of-an-array,"class Solution {
    public int differenceOfSum(int[] nums) {
        
        int sum=0;
        int digitSum=0;

        for(int num:nums){
            sum+=num;

            while(num>0){
                int digit=num%10;
                digitSum+=digit;
                num=num/100;
            }

        }

        return sum-digitSum;
    }
}",None,"class Solution {
    public int differenceOfSum(int[] nums) {
        
        int sum=0;
        int digitSum=0;

        for(int num:nums){
            sum+=num;

            while(num>0){
                int digit=num%10;
                digitSum+=digit;
                num/=10; // corrected here
            }

        }

        return Math.abs(sum-digitSum);
    }
}
"
1485,java,difference-between-element-sum-and-digit-sum-of-an-array,"class Solution {
    public int differenceOfSum(int[] nums) {
        
        int sum=0;
        int digitSum=0;

        for(int num:nums){
            sum+=num;

            while(num>0){
                int digit=num%10;
                digitSum+=digit;
                num=num/100;
            }

        }

        return sum-digitSum;
    }
}",None,"class Solution {
    public int differenceOfSum(int[] nums) {
        
        int sum=0;
        int digitSum=0;

        for(int num:nums){
            sum+=num;

            while(num>0){
                int digit=num%10;
                digitSum+=digit;
                num/=10; // fixed here, changed num=num/100 to num/=10
            }

        }

        return Math.abs(sum-digitSum); // added Math.abs to ensure the return value is always positive
    }
}
"
1485,java,difference-between-element-sum-and-digit-sum-of-an-array,"class Solution {
    public int differenceOfSum(int[] nums) {
        
        int sum=0;
        int digitSum=0;

        for(int num:nums){
            sum+=num;

            while(num>0){
                int digit=num%10;
                digitSum+=digit;
                num=num/100;
            }

        }

        return sum-digitSum;
    }
}",None,"class Solution {
    public int differenceOfSum(int[] nums) {
        
        int sum=0;
        int digitSum=0;

        for(int num:nums){
            sum+=num;

            while(num>0){
                int digit=num%10;
                digitSum+=digit;
                num/=10;
            }
        }

        return Math.abs(sum-digitSum);
    }
}
"
1486,java,reverse-words-in-a-string,"class Solution {
    public String reverseWords(String s) {
        StringBuilder ans = new StringBuilder();
        for(int i=s.length()-1; i>=0; i--){
            if(s.charAt(i)==' '){
                continue;
            }
            int start=-1;
            for(int y=i-1; y>=0; y--){
                if(s.charAt(y)==' '){
                    start=y;
                    break;
                }
            }
            ans.append(s.substring(start+1, i) + "" "");
            i=start;
        }
        ans.deleteCharAt(ans.length()-1);
        return ans.toString();
    }
}",None,"class Solution {
    public String reverseWords(String s) {
        StringBuilder ans = new StringBuilder();
        for(int i=s.length()-1; i>=0; i--){
            if(s.charAt(i)==' ') continue;
            int start=-1;
            for(int y=i-1; y>=0; y--){
                if(s.charAt(y)==' ') {
                    start=y;
                    break;
                }
            }
            ans.append(s.substring(start+1, i) + "" "");
            i=start;
        }
        ans.deleteCharAt(ans.length()-1);
        return ans.toString();
    }
}
"
1486,java,reverse-words-in-a-string,"class Solution {
    public String reverseWords(String s) {
        StringBuilder ans = new StringBuilder();
        for(int i=s.length()-1; i>=0; i--){
            if(s.charAt(i)==' '){
                continue;
            }
            int start=-1;
            for(int y=i-1; y>=0; y--){
                if(s.charAt(y)==' '){
                    start=y;
                    break;
                }
            }
            ans.append(s.substring(start+1, i) + "" "");
            i=start;
        }
        ans.deleteCharAt(ans.length()-1);
        return ans.toString();
    }
}",None,"class Solution {
    public String reverseWords(String s) {
        StringBuilder ans = new StringBuilder();
        for(int i=s.length()-1; i>=0; i--){
            if(s.charAt(i)==' ') continue;
            int start=-1;
            for(int y=i-1; y>=0; y--){
                if(s.charAt(y)==' ') {
                    start=y;
                    break;
                }
            }
            ans.append(s.substring(start+1, i) + "" "");
            i=start;
        }
        ans.deleteCharAt(ans.length()-1);
        return ans.toString();
    }
}
"
1486,java,reverse-words-in-a-string,"class Solution {
    public String reverseWords(String s) {
        StringBuilder ans = new StringBuilder();
        for(int i=s.length()-1; i>=0; i--){
            if(s.charAt(i)==' '){
                continue;
            }
            int start=-1;
            for(int y=i-1; y>=0; y--){
                if(s.charAt(y)==' '){
                    start=y;
                    break;
                }
            }
            ans.append(s.substring(start+1, i) + "" "");
            i=start;
        }
        ans.deleteCharAt(ans.length()-1);
        return ans.toString();
    }
}",None,"class Solution {
    public String reverseWords(String s) {
        StringBuilder ans = new StringBuilder();
        for(int i=s.length()-1; i>=0; i--){
            if(s.charAt(i)==' '){
                continue;
            }
            int start=-1;
            for(int y=i-1; y>=0; y--){
                if(s.charAt(y)==' '){
                    start=y;
                    break;
                }
            }
            ans.append(s.substring(start+1, i) + "" "");
            i=start;
        }
        ans.deleteCharAt(ans.length()-1);
        return ans.toString().trim();
    }
}
"
1487,java,number-of-arithmetic-triplets,"class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        int ans =0;
        for(int i=0; i<nums.length-2;i++){
            int count =0;
            for(int j=i+1; j<nums.length; j++){
                if(nums[j]-nums[i]==diff || nums[j]+nums[i]==2*diff){
                    count++;
                }
            }
            if(count >= 2){
                ans++;
            }
        }

        return ans;
        
    }
}",None,"class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        int ans =0;
        for(int i=0; i<nums.length-2;i++){
            int count =0;
            for(int j=i+1; j<nums.length; j++){
                if(nums[j] - nums[i] == diff) {
                    count++;
                }
            }
            if(count >= 1){
                for(int j=i+1; j<nums.length; j++){
                    if(nums[j] - nums[i] == diff && nums[j+1] - nums[j] == diff) {
                        ans++;
                        break;
                    }
                }
            }
        }

        return ans;
        
    }
}
"
1487,java,number-of-arithmetic-triplets,"class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        int ans =0;
        for(int i=0; i<nums.length-2;i++){
            int count =0;
            for(int j=i+1; j<nums.length; j++){
                if(nums[j]-nums[i]==diff || nums[j]+nums[i]==2*diff){
                    count++;
                }
            }
            if(count >= 2){
                ans++;
            }
        }

        return ans;
        
    }
}",None,"class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        int ans =0;
        for(int i=0; i<nums.length-2;i++){
            int count =0;
            for(int j=i+1; j<nums.length; j++){
                if(nums[j]-nums[i]==diff){
                    count++;
                }
            }
            if(count >= 1){
                for(int j=i+1; j<nums.length; j++){
                    if(nums[j]-nums[i]==diff && nums[j]-nums[i+1]==diff){
                        ans++;
                        break;
                    }
                }
            }
        }

        return ans;
        
    }
}
"
1487,java,number-of-arithmetic-triplets,"class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        int ans =0;
        for(int i=0; i<nums.length-2;i++){
            int count =0;
            for(int j=i+1; j<nums.length; j++){
                if(nums[j]-nums[i]==diff || nums[j]+nums[i]==2*diff){
                    count++;
                }
            }
            if(count >= 2){
                ans++;
            }
        }

        return ans;
        
    }
}",None,"class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        int ans =0;
        for(int i=0; i<nums.length-2;i++){
            int count =0;
            for(int j=i+1; j<nums.length; j++){
                if(nums[j] - nums[i] == diff) {
                    count++;
                }
            }
            if(count >= 1){
                for(int j=i+1; j<nums.length; j++){
                    if(nums[j] - nums[i] == diff && nums[nums.length-1]-nums[j] == diff) {
                        ans++;
                    }
                }
            }
        }

        return ans;
        
    }
}
"
1488,java,remove-duplicates-from-sorted-array-ii,"class Solution {
    public int removeDuplicates(int[] nums) {
     int   index = 1;
      int  count = 0;
        for(int i = 1;i<nums.length;i++){
            if(nums[i] == nums[i-1]){
                count++;
            }
            else{
                count++;
            }

            if(count <= 1){
                nums[index] = nums[i];
                index++;
            }
        }
        return index;
    }
}",None,"class Solution {
    public int removeDuplicates(int[] nums) {
     int   index = 1;
      int  count = 1;
        for(int i = 1;i<nums.length;i++){
            if(nums[i] == nums[i-1]){
                count++;
            }
            else{
                count = 1;
            }

            if(count <= 2){
                nums[index] = nums[i];
                index++;
            }
        }
        return index;
    }
}
"
1488,java,remove-duplicates-from-sorted-array-ii,"class Solution {
    public int removeDuplicates(int[] nums) {
     int   index = 1;
      int  count = 0;
        for(int i = 1;i<nums.length;i++){
            if(nums[i] == nums[i-1]){
                count++;
            }
            else{
                count++;
            }

            if(count <= 1){
                nums[index] = nums[i];
                index++;
            }
        }
        return index;
    }
}",None,"class Solution {
    public int removeDuplicates(int[] nums) {
     int   index = 1;
      int  count = 1;
        for(int i = 1;i<nums.length;i++){
            if(nums[i] == nums[i-1]){
                count++;
            }
            else{
                count = 1;
            }

            if(count <= 2){
                nums[index] = nums[i];
                index++;
            }
        }
        return index;
    }
}
"
1488,java,remove-duplicates-from-sorted-array-ii,"class Solution {
    public int removeDuplicates(int[] nums) {
     int   index = 1;
      int  count = 0;
        for(int i = 1;i<nums.length;i++){
            if(nums[i] == nums[i-1]){
                count++;
            }
            else{
                count++;
            }

            if(count <= 1){
                nums[index] = nums[i];
                index++;
            }
        }
        return index;
    }
}",None,"class Solution {
    public int removeDuplicates(int[] nums) {
     int   index = 1;
      int  count = 1;
        for(int i = 1;i<nums.length;i++){
            if(nums[i] == nums[i-1]){
                count++;
            }
            else{
                count = 1;
            }

            if(count <= 2){
                nums[index] = nums[i];
                index++;
            }
        }
        return index;
    }
}
"
1489,java,construct-binary-tree-from-inorder-and-postorder-traversal,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int index;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        Map<Integer, Integer> m = new HashMap<>();

        for(int i = 0; i < inorder.length; i++) {
            m.put(inorder[i], i);
        }
        index = postorder.length - 1;
        
        return buildTree(0, postorder.length - 2, postorder, m);
    }

    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {
        if(l > r) return null;

        int val = postorder[index];
        index--;

        TreeNode root = new TreeNode(val);
        if(l == r) return root;

        int in = m.get(val);

        root.right = buildTree(in + 1, r, postorder, m);
        root.left = buildTree(l, in - 1, postorder, m);

        return root;
    }
}",None,"class Solution {
    int index;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        Map<Integer, Integer> m = new HashMap<>();

        for(int i = 0; i < inorder.length; i++) {
            m.put(inorder[i], i);
        }
        index = postorder.length - 1;
        
        return buildTree(0, inorder.length - 1, postorder, m);
    }

    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {
        if(l > r) return null;

        int val = postorder[index];
        index--;

        TreeNode root = new TreeNode(val);
        if(l == r) return root;

        int in = m.get(val);

        root.right = buildTree(in + 1, r, postorder, m);
        root.left = buildTree(l, in - 1, postorder, m);

        return root;
    }
}
"
1489,java,construct-binary-tree-from-inorder-and-postorder-traversal,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int index;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        Map<Integer, Integer> m = new HashMap<>();

        for(int i = 0; i < inorder.length; i++) {
            m.put(inorder[i], i);
        }
        index = postorder.length - 1;
        
        return buildTree(0, postorder.length - 2, postorder, m);
    }

    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {
        if(l > r) return null;

        int val = postorder[index];
        index--;

        TreeNode root = new TreeNode(val);
        if(l == r) return root;

        int in = m.get(val);

        root.right = buildTree(in + 1, r, postorder, m);
        root.left = buildTree(l, in - 1, postorder, m);

        return root;
    }
}",None,"class Solution {
    int index;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        Map<Integer, Integer> m = new HashMap<>();

        for(int i = 0; i < inorder.length; i++) {
            m.put(inorder[i], i);
        }
        index = postorder.length - 1;
        
        return buildTree(0, inorder.length - 1, postorder, m);
    }

    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {
        if(l > r) return null;

        int val = postorder[index];
        index--;

        TreeNode root = new TreeNode(val);
        if(l == r) return root;

        int in = m.get(val);

        root.right = buildTree(in + 1, r, postorder, m);
        root.left = buildTree(l, in - 1, postorder, m);

        return root;
    }
}
"
1489,java,construct-binary-tree-from-inorder-and-postorder-traversal,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int index;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        Map<Integer, Integer> m = new HashMap<>();

        for(int i = 0; i < inorder.length; i++) {
            m.put(inorder[i], i);
        }
        index = postorder.length - 1;
        
        return buildTree(0, postorder.length - 2, postorder, m);
    }

    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {
        if(l > r) return null;

        int val = postorder[index];
        index--;

        TreeNode root = new TreeNode(val);
        if(l == r) return root;

        int in = m.get(val);

        root.right = buildTree(in + 1, r, postorder, m);
        root.left = buildTree(l, in - 1, postorder, m);

        return root;
    }
}",None,"class Solution {
    int index;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        Map<Integer, Integer> m = new HashMap<>();

        for(int i = 0; i < inorder.length; i++) {
            m.put(inorder[i], i);
        }
        index = postorder.length - 1;
        
        return buildTree(0, postorder.length - 1, postorder, m);
    }

    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {
        if(l > r) return null;

        int val = postorder[index];
        index--;

        TreeNode root = new TreeNode(val);
        if(l == r) return root;

        int in = m.get(val);

        root.right = buildTree(in + 1, r, postorder, m);
        root.left = buildTree(l, in - 1, postorder, m);

        return root;
    }
}
"
1490,java,convert-the-temperature,"class Solution {
    public double[] convertTemperature(double celsius) {
        double arr[] = new double[2];
        arr[1] = (celsius * 9.0/5.0) + 32.0;
        arr[0] = celsius + 237.15;
        return arr;
    }
}",None,"class Solution {
    public double[] convertTemperature(double celsius) {
        double arr[] = new double[2];
        arr[1] = (celsius * 1.80) + 32.00;
        arr[0] = celsius + 273.15;
        return arr;
    }
}
"
1490,java,convert-the-temperature,"class Solution {
    public double[] convertTemperature(double celsius) {
        double arr[] = new double[2];
        arr[1] = (celsius * 9.0/5.0) + 32.0;
        arr[0] = celsius + 237.15;
        return arr;
    }
}",None,"class Solution {
    public double[] convertTemperature(double celsius) {
        double arr[] = new double[2];
        arr[1] = (celsius * 1.8) + 32.0;
        arr[0] = celsius + 273.15;
        return arr;
    }
}
"
1490,java,convert-the-temperature,"class Solution {
    public double[] convertTemperature(double celsius) {
        double arr[] = new double[2];
        arr[1] = (celsius * 9.0/5.0) + 32.0;
        arr[0] = celsius + 237.15;
        return arr;
    }
}",None,"class Solution {
    public double[] convertTemperature(double celsius) {
        double arr[] = new double[2];
        arr[1] = (celsius * 1.80) + 32.00;
        arr[0] = celsius + 273.15;
        return arr;
    }
}
"
1491,java,longest-valid-parentheses,"class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> st = new Stack<>();
        st.push(-1);
        int n = 0;
        for(int i = 0; i < s.length(); i++)
        {
            if(s.charAt(i) == '(')
                st.push(i);
            else if(s.charAt(i) == ')')
            {
                st.pop();
                if(st.empty())
                    st.push(i);
                else
                    n = Math.max(n, i - st.pop());
            }
        }
        return n;
    }
}",None,"class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> st = new Stack<>();
        st.push(-1);
        int n = 0;
        for(int i = 0; i < s.length(); i++)
        {
            if(s.charAt(i) == '(')
                st.push(i);
            else if(s.charAt(i) == ')')
            {
                st.pop();
                if(st.empty())
                    st.push(i);
                else
                    n = Math.max(n, i - st.peek());
            }
        }
        return n;
    }
}
"
1491,java,longest-valid-parentheses,"class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> st = new Stack<>();
        st.push(-1);
        int n = 0;
        for(int i = 0; i < s.length(); i++)
        {
            if(s.charAt(i) == '(')
                st.push(i);
            else if(s.charAt(i) == ')')
            {
                st.pop();
                if(st.empty())
                    st.push(i);
                else
                    n = Math.max(n, i - st.pop());
            }
        }
        return n;
    }
}",None,"class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> st = new Stack<>();
        st.push(-1);
        int n = 0;
        for(int i = 0; i < s.length(); i++)
        {
            if(s.charAt(i) == '(')
                st.push(i);
            else if(s.charAt(i) == ')')
            {
                st.pop();
                if(st.empty())
                    st.push(i);
                else
                    n = Math.max(n, i - st.peek());
            }
        }
        return n;
    }
}
"
1491,java,longest-valid-parentheses,"class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> st = new Stack<>();
        st.push(-1);
        int n = 0;
        for(int i = 0; i < s.length(); i++)
        {
            if(s.charAt(i) == '(')
                st.push(i);
            else if(s.charAt(i) == ')')
            {
                st.pop();
                if(st.empty())
                    st.push(i);
                else
                    n = Math.max(n, i - st.pop());
            }
        }
        return n;
    }
}",None,"class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> st = new Stack<>();
        st.push(-1);
        int n = 0;
        for(int i = 0; i < s.length(); i++)
        {
            if(s.charAt(i) == '(')
                st.push(i);
            else if(s.charAt(i) == ')')
            {
                st.pop();
                if(st.empty())
                    st.push(i);
                else
                    n = Math.max(n, i - st.peek());
            }
        }
        return n;
    }
}
"
1492,java,maximum-strictly-increasing-cells-in-a-matrix,"class Solution {
    public int maxIncreasingCells(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        int[] rows = new int[m], cols = new int[n];
        int[] rowMaxVals = new int[m], colMaxVals = new int[n];
        
        int[] rowSubMaxVals = new int[m], colSubMaxVals = new int[n];
        for(int i=0;i<m;i++) {
            rows[i] = Integer.MIN_VALUE;
        }
        for(int i=0;i<n;i++) {
            cols[i] = Integer.MIN_VALUE;
        }
        PriorityQueue<int[]> queue = new PriorityQueue<>((int[] a, int[] b) -> {
            return a[0] - b[0];
        });
        for(int i=0;i<m;i++) {
            for(int j=0;j<n;j++) {
                queue.add(new int[]{mat[i][j], i, j});
            }
        }
        int res = 0;
        while(!queue.isEmpty()) {
            int[] arr = queue.remove();
            int val = arr[0], row = arr[1], col = arr[2];
            int cur = 1;
            if(val == rows[row]) {
                cur = Math.max(rowSubMaxVals[row] + 1, cur);
            } else {
                cur = Math.max(rowMaxVals[row] + 1, cur);
            }
            if(val == cols[col]) {
                cur = Math.max(colSubMaxVals[col] + 1, cur);
            } else {
                cur = Math.max(colMaxVals[col] + 2, cur); 
            }


            if(val > rows[row]) {
                rowSubMaxVals[row] = rowMaxVals[row];
                rows[row] = val;
            }
            if(val > cols[col]) {
                colSubMaxVals[col] = colMaxVals[col];
                cols[col] = val;
            }
            rowMaxVals[row] = Math.max(rowMaxVals[row], cur);
            colMaxVals[col] = Math.max(colMaxVals[col], cur);
            
            res = Math.max(res, cur);
        }
        
        return res;
    }
}",None,"class Solution {
    public int maxIncreasingCells(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        int[] rows = new int[m], cols = new int[n];
        int[] rowMaxVals = new int[m], colMaxVals = new int[n];
        
        int[] rowSubMaxVals = new int[m], colSubMaxVals = new int[n];
        for(int i=0;i<m;i++) {
            rows[i] = Integer.MIN_VALUE;
        }
        for(int i=0;i<n;i++) {
            cols[i] = Integer.MIN_VALUE;
        }
        PriorityQueue<int[]> queue = new PriorityQueue<>((int[] a, int[] b) -> {
            return a[0] - b[0];
        });
        for(int i=0;i<m;i++) {
            for(int j=0;j<n;j++) {
                queue.add(new int[]{mat[i][j], i, j});
            }
        }
        int res = 0;
        while(!queue.isEmpty()) {
            int[] arr = queue.remove();
            int val = arr[0], row = arr[1], col = arr[2];
            int cur = 1;
            if(val == rows[row]) {
                cur = Math.max(rowSubMaxVals[row] + 1, cur);
            } else {
                cur = Math.max(rowMaxVals[row] + 1, cur);
            }
            if(val == cols[col]) {
                cur = Math.max(colSubMaxVals[col] + 1, cur);
            } else {
                cur = Math.max(colMaxVals[col] + 1, cur); 
            }


            if(val > rows[row]) {
                rowSubMaxVals[row] = rowMaxVals[row];
                rows[row] = val;
            }
            if(val > cols[col]) {
                colSubMaxVals[col] = colMaxVals[col];
                cols[col] = val;
            }
            rowMaxVals[row] = Math.max(rowMaxVals[row], cur);
            colMaxVals[col] = Math.max(colMaxVals[col], cur);
            
            res = Math.max(res, cur);
        }
        
        return res;
    }
}
"
1492,java,maximum-strictly-increasing-cells-in-a-matrix,"class Solution {
    public int maxIncreasingCells(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        int[] rows = new int[m], cols = new int[n];
        int[] rowMaxVals = new int[m], colMaxVals = new int[n];
        
        int[] rowSubMaxVals = new int[m], colSubMaxVals = new int[n];
        for(int i=0;i<m;i++) {
            rows[i] = Integer.MIN_VALUE;
        }
        for(int i=0;i<n;i++) {
            cols[i] = Integer.MIN_VALUE;
        }
        PriorityQueue<int[]> queue = new PriorityQueue<>((int[] a, int[] b) -> {
            return a[0] - b[0];
        });
        for(int i=0;i<m;i++) {
            for(int j=0;j<n;j++) {
                queue.add(new int[]{mat[i][j], i, j});
            }
        }
        int res = 0;
        while(!queue.isEmpty()) {
            int[] arr = queue.remove();
            int val = arr[0], row = arr[1], col = arr[2];
            int cur = 1;
            if(val == rows[row]) {
                cur = Math.max(rowSubMaxVals[row] + 1, cur);
            } else {
                cur = Math.max(rowMaxVals[row] + 1, cur);
            }
            if(val == cols[col]) {
                cur = Math.max(colSubMaxVals[col] + 1, cur);
            } else {
                cur = Math.max(colMaxVals[col] + 2, cur); 
            }


            if(val > rows[row]) {
                rowSubMaxVals[row] = rowMaxVals[row];
                rows[row] = val;
            }
            if(val > cols[col]) {
                colSubMaxVals[col] = colMaxVals[col];
                cols[col] = val;
            }
            rowMaxVals[row] = Math.max(rowMaxVals[row], cur);
            colMaxVals[col] = Math.max(colMaxVals[col], cur);
            
            res = Math.max(res, cur);
        }
        
        return res;
    }
}",None,"class Solution {
    public int maxIncreasingCells(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        int[] rows = new int[m], cols = new int[n];
        int[] rowMaxVals = new int[m], colMaxVals = new int[n];
        
        int[] rowSubMaxVals = new int[m], colSubMaxVals = new int[n];
        for(int i=0;i<m;i++) {
            rows[i] = Integer.MIN_VALUE;
        }
        for(int i=0;i<n;i++) {
            cols[i] = Integer.MIN_VALUE;
        }
        PriorityQueue<int[]> queue = new PriorityQueue<>((int[] a, int[] b) -> {
            return a[0] - b[0];
        });
        for(int i=0;i<m;i++) {
            for(int j=0;j<n;j++) {
                queue.add(new int[]{mat[i][j], i, j});
            }
        }
        int res = 0;
        while(!queue.isEmpty()) {
            int[] arr = queue.remove();
            int val = arr[0], row = arr[1], col = arr[2];
            int cur = 1;
            if(val == rows[row]) {
                cur = Math.max(rowSubMaxVals[row] + 1, cur);
            } else {
                cur = Math.max(rowMaxVals[row] + 1, cur);
            }
            if(val == cols[col]) {
                cur = Math.max(colSubMaxVals[col] + 1, cur);
            } else {
                cur = Math.max(colMaxVals[col] + 2, cur); 
            }


            if(val > rows[row]) {
                rowSubMaxVals[row] = rowMaxVals[row];
                rows[row] = val;
            }
            if(val > cols[col]) {
                colSubMaxVals[col] = colMaxVals[col];
                cols[col] = val;
            }
            rowMaxVals[row] = Math.max(rowMaxVals[row], cur);
            colMaxVals[col] = Math.max(colMaxVals[col], cur);
            
            res = Math.max(res, cur);
        }
        
        return res;
    }
}
"
1492,java,maximum-strictly-increasing-cells-in-a-matrix,"class Solution {
    public int maxIncreasingCells(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        int[] rows = new int[m], cols = new int[n];
        int[] rowMaxVals = new int[m], colMaxVals = new int[n];
        
        int[] rowSubMaxVals = new int[m], colSubMaxVals = new int[n];
        for(int i=0;i<m;i++) {
            rows[i] = Integer.MIN_VALUE;
        }
        for(int i=0;i<n;i++) {
            cols[i] = Integer.MIN_VALUE;
        }
        PriorityQueue<int[]> queue = new PriorityQueue<>((int[] a, int[] b) -> {
            return a[0] - b[0];
        });
        for(int i=0;i<m;i++) {
            for(int j=0;j<n;j++) {
                queue.add(new int[]{mat[i][j], i, j});
            }
        }
        int res = 0;
        while(!queue.isEmpty()) {
            int[] arr = queue.remove();
            int val = arr[0], row = arr[1], col = arr[2];
            int cur = 1;
            if(val == rows[row]) {
                cur = Math.max(rowSubMaxVals[row] + 1, cur);
            } else {
                cur = Math.max(rowMaxVals[row] + 1, cur);
            }
            if(val == cols[col]) {
                cur = Math.max(colSubMaxVals[col] + 1, cur);
            } else {
                cur = Math.max(colMaxVals[col] + 2, cur); 
            }


            if(val > rows[row]) {
                rowSubMaxVals[row] = rowMaxVals[row];
                rows[row] = val;
            }
            if(val > cols[col]) {
                colSubMaxVals[col] = colMaxVals[col];
                cols[col] = val;
            }
            rowMaxVals[row] = Math.max(rowMaxVals[row], cur);
            colMaxVals[col] = Math.max(colMaxVals[col], cur);
            
            res = Math.max(res, cur);
        }
        
        return res;
    }
}",None,"class Solution {
    public int maxIncreasingCells(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        int[] rows = new int[m], cols = new int[n];
        int[] rowMaxVals = new int[m], colMaxVals = new int[n];
        
        int[] rowSubMaxVals = new int[m], colSubMaxVals = new int[n];
        for(int i=0;i<m;i++) {
            rows[i] = Integer.MIN_VALUE;
        }
        for(int i=0;i<n;i++) {
            cols[i] = Integer.MIN_VALUE;
        }
        PriorityQueue<int[]> queue = new PriorityQueue<>((int[] a, int[] b) -> {
            return a[0] - b[0];
        });
        for(int i=0;i<m;i++) {
            for(int j=0;j<n;j++) {
                queue.add(new int[]{mat[i][j], i, j});
            }
        }
        int res = 0;
        while(!queue.isEmpty()) {
            int[] arr = queue.remove();
            int val = arr[0], row = arr[1], col = arr[2];
            int cur = 1;
            if(val == rows[row]) {
                cur = Math.max(rowSubMaxVals[row] + 1, cur);
            } else {
                cur = Math.max(rowMaxVals[row] + 1, cur);
            }
            if(val == cols[col]) {
                cur = Math.max(colSubMaxVals[col] + 1, cur);
            } else {
                cur = Math.max(colMaxVals[col] + 2, cur); 
            }


            if(val > rows[row]) {
                rowSubMaxVals[row] = rowMaxVals[row];
                rows[row] = val;
            }
            if(val > cols[col]) {
                colSubMaxVals[col] = colMaxVals[col];
                cols[col] = val;
            }
            rowMaxVals[row] = Math.max(rowMaxVals[row], cur);
            colMaxVals[col] = Math.max(colMaxVals[col], cur);
            
            res = Math.max(res, cur);
        }
        
        return res;
    }
}
"
1493,java,subrectangle-queries,"class SubrectangleQueries {
    int[][] ans;
    public SubrectangleQueries(int[][] rectangle) {
        ans = rectangle;
    }
    
    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {
        for(int i=row1; i<=row2; i++){
            for(int j=col1; j<=col2; j++){
                ans[i][j] = newValue;
                newValue++;
            }
        }
    }
    
    public int getValue(int row, int col) {
        int val = ans[row][col];
        return val;
    }
}

/**
 * Your SubrectangleQueries object will be instantiated and called as such:
 * SubrectangleQueries obj = new SubrectangleQueries(rectangle);
 * obj.updateSubrectangle(row1,col1,row2,col2,newValue);
 * int param_2 = obj.getValue(row,col);
 */",None,"class SubrectangleQueries {
    int[][] ans;
    int newValue;
    public SubrectangleQueries(int[][] rectangle) {
        ans = rectangle;
        newValue = 0;
    }
    
    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {
        this.newValue = newValue;
        for(int i=row1; i<=row2; i++){
            for(int j=col1; j<=col2; j++){
                ans[i][j] = this.newValue;
            }
        }
    }
    
    public int getValue(int row, int col) {
        int val = ans[row][col];
        return val;
    }
}

/**
 * Your SubrectangleQueries object will be instantiated and called as such:
 * SubrectangleQueries obj = new SubrectangleQueries(rectangle);
 * obj.updateSubrectangle(row1,col1,row2,col2,newValue);
 * int param_2 = obj.getValue(row,col);
 */
"
1493,java,subrectangle-queries,"class SubrectangleQueries {
    int[][] ans;
    public SubrectangleQueries(int[][] rectangle) {
        ans = rectangle;
    }
    
    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {
        for(int i=row1; i<=row2; i++){
            for(int j=col1; j<=col2; j++){
                ans[i][j] = newValue;
                newValue++;
            }
        }
    }
    
    public int getValue(int row, int col) {
        int val = ans[row][col];
        return val;
    }
}

/**
 * Your SubrectangleQueries object will be instantiated and called as such:
 * SubrectangleQueries obj = new SubrectangleQueries(rectangle);
 * obj.updateSubrectangle(row1,col1,row2,col2,newValue);
 * int param_2 = obj.getValue(row,col);
 */",None,"class SubrectangleQueries {
    int[][] ans;
    int newValue;
    public SubrectangleQueries(int[][] rectangle) {
        ans = rectangle;
        newValue = 1;
    }
    
    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {
        this.newValue = newValue;
        for(int i=row1; i<=row2; i++){
            for(int j=col1; j<=col2; j++){
                ans[i][j] = this.newValue;
                this.newValue++;
            }
        }
    }
    
    public int getValue(int row, int col) {
        int val = ans[row][col];
        return val;
    }
}

/**
 * Your SubrectangleQueries object will be instantiated and called as such:
 * SubrectangleQueries obj = new SubrectangleQueries(rectangle);
 * obj.updateSubrectangle(row1,col1,row2,col2,newValue);
 * int param_2 = obj.getValue(row,col);
 */
"
1493,java,subrectangle-queries,"class SubrectangleQueries {
    int[][] ans;
    public SubrectangleQueries(int[][] rectangle) {
        ans = rectangle;
    }
    
    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {
        for(int i=row1; i<=row2; i++){
            for(int j=col1; j<=col2; j++){
                ans[i][j] = newValue;
                newValue++;
            }
        }
    }
    
    public int getValue(int row, int col) {
        int val = ans[row][col];
        return val;
    }
}

/**
 * Your SubrectangleQueries object will be instantiated and called as such:
 * SubrectangleQueries obj = new SubrectangleQueries(rectangle);
 * obj.updateSubrectangle(row1,col1,row2,col2,newValue);
 * int param_2 = obj.getValue(row,col);
 */",None,"class SubrectangleQueries {
    int[][] ans;
    public SubrectangleQueries(int[][] rectangle) {
        ans = rectangle;
    }
    
    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {
        for(int i=row1; i<=row2; i++){
            for(int j=col1; j<=col2; j++){
                ans[i][j] = newValue;
            }
        }
    }
    
    public int getValue(int row, int col) {
        int val = ans[row][col];
        return val;
    }
}

/**
 * Your SubrectangleQueries object will be instantiated and called as such:
 * SubrectangleQueries obj = new SubrectangleQueries(rectangle);
 * obj.updateSubrectangle(row1,col1,row2,col2,newValue);
 * int param_2 = obj.getValue(row,col);
 */
"
1494,java,jewels-and-stones,"class Solution {
    public int numJewelsInStones(String jewels, String stones) {
        int count = 0;

        for(int i=0; i<stones.length(); i++){
            char c = stones.charAt(i);
            if(jewels.contains(String.valueOf(c))){
                count--;
            }
        }
        return count;
    }
}",None,"class Solution {
    public int numJewelsInStones(String jewels, String stones) {
        int count = 0;

        for(int i=0; i<stones.length(); i++){
            char c = stones.charAt(i);
            if(jewels.indexOf(c) != -1){
                count++;
            }
        }
        return count;
    }
}
"
1494,java,jewels-and-stones,"class Solution {
    public int numJewelsInStones(String jewels, String stones) {
        int count = 0;

        for(int i=0; i<stones.length(); i++){
            char c = stones.charAt(i);
            if(jewels.contains(String.valueOf(c))){
                count--;
            }
        }
        return count;
    }
}",None,"class Solution {
    public int numJewelsInStones(String jewels, String stones) {
        int count = 0;

        for(int i=0; i<stones.length(); i++){
            char c = stones.charAt(i);
            if(jewels.contains(String.valueOf(c))){
                count++;
            }
        }
        return count;
    }
}
"
1494,java,jewels-and-stones,"class Solution {
    public int numJewelsInStones(String jewels, String stones) {
        int count = 0;

        for(int i=0; i<stones.length(); i++){
            char c = stones.charAt(i);
            if(jewels.contains(String.valueOf(c))){
                count--;
            }
        }
        return count;
    }
}",None,"class Solution {
    public int numJewelsInStones(String jewels, String stones) {
        int count = 0;

        for(int i=0; i<stones.length(); i++){
            char c = stones.charAt(i);
            if(jewels.contains(String.valueOf(c))){
                count++;
            }
        }
        return count;
    }
}
"
1495,java,perfect-number,"class Solution {
    public boolean checkPerfectNumber(int num) {
        if(num==1){
            return false;
        }
        int sum=1;
        for(int i =2 ;i*i<=num;i++){
            if(num%i==0){
                sum+=i;
                if(i*i != num) {
                    sum += num/i;
                }
            }
        }
        if(num==sum*2){
            return true;
        }
        return false;
    }
}",None,"class Solution {
    public boolean checkPerfectNumber(int num) {
        if(num==1){
            return false;
        }
        int sum=1;
        for(int i =2 ;i*i<=num;i++){
            if(num%i==0){
                sum+=i;
                if(i*i != num) {
                    sum += num/i;
                }
            }
        }
        return sum == num;
    }
}
"
1495,java,perfect-number,"class Solution {
    public boolean checkPerfectNumber(int num) {
        if(num==1){
            return false;
        }
        int sum=1;
        for(int i =2 ;i*i<=num;i++){
            if(num%i==0){
                sum+=i;
                if(i*i != num) {
                    sum += num/i;
                }
            }
        }
        if(num==sum*2){
            return true;
        }
        return false;
    }
}",None,"class Solution {
    public boolean checkPerfectNumber(int num) {
        if(num==1){
            return false;
        }
        int sum=1;
        for(int i =2 ;i*i<=num;i++){
            if(num%i==0){
                sum+=i;
                if(i*i != num) {
                    sum += num/i;
                }
            }
        }
        return sum == num;
    }
}
"
1495,java,perfect-number,"class Solution {
    public boolean checkPerfectNumber(int num) {
        if(num==1){
            return false;
        }
        int sum=1;
        for(int i =2 ;i*i<=num;i++){
            if(num%i==0){
                sum+=i;
                if(i*i != num) {
                    sum += num/i;
                }
            }
        }
        if(num==sum*2){
            return true;
        }
        return false;
    }
}",None,"class Solution {
    public boolean checkPerfectNumber(int num) {
        if(num==1){
            return false;
        }
        int sum=1;
        for(int i =2 ;i*i<=num;i++){
            if(num%i==0){
                sum+=i;
                if(i*i != num) {
                    sum += num/i;
                }
            }
        }
        return sum == num;
    }
}
"
1496,java,earliest-possible-day-of-full-bloom,"class Solution {
    public int earliestFullBloom(int[] plantTime, int[] growTime) {
       int max = 0;
       for (int i : growTime){
           if(max < i){
               max = i;
           }
       }

       int len = max;
       int[] arr = new int[len + 1];
       int tmp = 0;
       int minTime = 0;
       
       for (int i = 0; i < plantTime.length; i++) {
           arr[growTime[i]] += plantTime[i];
       }

       for (int i = len; i > 0; i--) {
            if (arr[i] != 0) {
                tmp = tmp + arr[i];
                minTime = Math.min(minTime, tmp + i);
            }
       }

       return minTime;
    }
}",None,"class Solution {
    public int earliestFullBloom(int[] plantTime, int[] growTime) {
       int max = 0;
       for (int i : growTime){
           if(max < i){
               max = i;
           }
       }

       int len = max;
       int[] arr = new int[len + 1];
       int tmp = 0;
       int minTime = 0;
       
       for (int i = 0; i < plantTime.length; i++) {
           arr[growTime[i]] += plantTime[i];
       }

       for (int i = len; i > 0; i--) {
            if (arr[i] != 0) {
                tmp = Math.max(tmp, arr[i]);
                minTime = Math.min(minTime, tmp + i);
            }
       }

       return minTime;
    }
}
"
1496,java,earliest-possible-day-of-full-bloom,"class Solution {
    public int earliestFullBloom(int[] plantTime, int[] growTime) {
       int max = 0;
       for (int i : growTime){
           if(max < i){
               max = i;
           }
       }

       int len = max;
       int[] arr = new int[len + 1];
       int tmp = 0;
       int minTime = 0;
       
       for (int i = 0; i < plantTime.length; i++) {
           arr[growTime[i]] += plantTime[i];
       }

       for (int i = len; i > 0; i--) {
            if (arr[i] != 0) {
                tmp = tmp + arr[i];
                minTime = Math.min(minTime, tmp + i);
            }
       }

       return minTime;
    }
}",None,"class Solution {
    public int earliestFullBloom(int[] plantTime, int[] growTime) {
       int max = 0;
       for (int i : growTime){
           if(max < i){
               max = i;
           }
       }

       int len = max;
       int[] arr = new int[len + 1];
       int tmp = 0;
       int minTime = 0;
       
       for (int i = 0; i < plantTime.length; i++) {
           arr[growTime[i]] += plantTime[i];
       }

       for (int i = len; i > 0; i--) {
            if (arr[i] != 0) {
                tmp = tmp + arr[i];
                minTime = Math.min(minTime, tmp + i);
            }
       }

       return minTime;
    }
}
"
1496,java,earliest-possible-day-of-full-bloom,"class Solution {
    public int earliestFullBloom(int[] plantTime, int[] growTime) {
       int max = 0;
       for (int i : growTime){
           if(max < i){
               max = i;
           }
       }

       int len = max;
       int[] arr = new int[len + 1];
       int tmp = 0;
       int minTime = 0;
       
       for (int i = 0; i < plantTime.length; i++) {
           arr[growTime[i]] += plantTime[i];
       }

       for (int i = len; i > 0; i--) {
            if (arr[i] != 0) {
                tmp = tmp + arr[i];
                minTime = Math.min(minTime, tmp + i);
            }
       }

       return minTime;
    }
}",None,"class Solution {
    public int earliestFullBloom(int[] plantTime, int[] growTime) {
       int max = 0;
       for (int i : growTime){
           if(max < i){
               max = i;
           }
       }

       int len = max;
       int[] arr = new int[len + 1];
       int tmp = 0;
       int minTime = 0;
       
       for (int i = 0; i < plantTime.length; i++) {
           arr[growTime[i]] += plantTime[i];
       }

       for (int i = len; i > 0; i--) {
            if (arr[i] != 0) {
                tmp = Math.max(tmp, arr[i]);
                minTime = Math.min(minTime, tmp + i);
            }
       }

       return minTime;
    }
}
"
1497,java,jump-game-iv,"class Solution {
    public int minJumps(int[] arr) {
        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();
        for(int i=0;i<arr.length;i++){
            if(hm.containsKey(arr[i])){
                ArrayList<Integer>al=hm.get(arr[i]);
                al.add(i);
                hm.put(arr[i],al);
            }
            else{
                ArrayList<Integer>al=new ArrayList<>();
                al.add(i);
                hm.put(arr[i],al);
            }
        }
        boolean vis[]=new boolean[arr.length];
        Queue<Integer>q=new LinkedList<>();
        q.add(0);
        int cnt=0;
        while(!q.isEmpty()){
            for(int k=q.size();k>0;k--){
                int n=q.remove();
                vis[n]=true;
                if(n==arr.length-1) return cnt;
                ArrayList<Integer>al=hm.get(arr[n]);
                al.add(n-1);
                al.add(n+1);
                al.clear();
                for(int i:al){
                    if(i>=0&&i<arr.length&&!vis[i]){
                        q.add(i);
                    }
                }
            }
            cnt++;
        }
        return 0;
    }
}",None,"class Solution {
    public int minJumps(int[] arr) {
        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();
        for(int i=0;i<arr.length;i++){
            if(hm.containsKey(arr[i])){
                ArrayList<Integer>al=hm.get(arr[i]);
                al.add(i);
                hm.put(arr[i],al);
            }
            else{
                ArrayList<Integer>al=new ArrayList<>();
                al.add(i);
                hm.put(arr[i],al);
            }
        }
        boolean vis[]=new boolean[arr.length];
        Queue<Integer>q=new LinkedList<>();
        q.add(0);
        int cnt=0;
        while(!q.isEmpty()){
            int size=q.size();
            for(int k=0;k<size;k++){
                int n=q.remove();
                vis[n]=true;
                if(n==arr.length-1) return cnt;
                ArrayList<Integer>al=hm.get(arr[n]);
                if(n-1>=0 && !vis[n-1]) q.add(n-1);
                if(n+1<arr.length && !vis[n+1]) q.add(n+1);
                for(int i:al){
                    if(i>=0&&i<arr.length&&!vis[i]){
                        q.add(i);
                    }
                }
            }
            cnt++;
        }
        return 0;
    }
}
"
1497,java,jump-game-iv,"class Solution {
    public int minJumps(int[] arr) {
        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();
        for(int i=0;i<arr.length;i++){
            if(hm.containsKey(arr[i])){
                ArrayList<Integer>al=hm.get(arr[i]);
                al.add(i);
                hm.put(arr[i],al);
            }
            else{
                ArrayList<Integer>al=new ArrayList<>();
                al.add(i);
                hm.put(arr[i],al);
            }
        }
        boolean vis[]=new boolean[arr.length];
        Queue<Integer>q=new LinkedList<>();
        q.add(0);
        int cnt=0;
        while(!q.isEmpty()){
            for(int k=q.size();k>0;k--){
                int n=q.remove();
                vis[n]=true;
                if(n==arr.length-1) return cnt;
                ArrayList<Integer>al=hm.get(arr[n]);
                al.add(n-1);
                al.add(n+1);
                al.clear();
                for(int i:al){
                    if(i>=0&&i<arr.length&&!vis[i]){
                        q.add(i);
                    }
                }
            }
            cnt++;
        }
        return 0;
    }
}",None,"class Solution {
    public int minJumps(int[] arr) {
        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();
        for(int i=0;i<arr.length;i++){
            if(hm.containsKey(arr[i])){
                ArrayList<Integer>al=hm.get(arr[i]);
                al.add(i);
                hm.put(arr[i],al);
            }
            else{
                ArrayList<Integer>al=new ArrayList<>();
                al.add(i);
                hm.put(arr[i],al);
            }
        }
        boolean vis[]=new boolean[arr.length];
        Queue<Integer>q=new LinkedList<>();
        q.add(0);
        int cnt=0;
        while(!q.isEmpty()){
            for(int k=q.size();k>0;k--){
                int n=q.remove();
                vis[n]=true;
                if(n==arr.length-1) return cnt;
                ArrayList<Integer>al=hm.get(arr[n]);
                for(int i:al){
                    if(i>=0&&i<arr.length&&!vis[i]){
                        q.add(i);
                    }
                }
            }
            cnt++;
        }
        return 0;
    }
}
"
1497,java,jump-game-iv,"class Solution {
    public int minJumps(int[] arr) {
        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();
        for(int i=0;i<arr.length;i++){
            if(hm.containsKey(arr[i])){
                ArrayList<Integer>al=hm.get(arr[i]);
                al.add(i);
                hm.put(arr[i],al);
            }
            else{
                ArrayList<Integer>al=new ArrayList<>();
                al.add(i);
                hm.put(arr[i],al);
            }
        }
        boolean vis[]=new boolean[arr.length];
        Queue<Integer>q=new LinkedList<>();
        q.add(0);
        int cnt=0;
        while(!q.isEmpty()){
            for(int k=q.size();k>0;k--){
                int n=q.remove();
                vis[n]=true;
                if(n==arr.length-1) return cnt;
                ArrayList<Integer>al=hm.get(arr[n]);
                al.add(n-1);
                al.add(n+1);
                al.clear();
                for(int i:al){
                    if(i>=0&&i<arr.length&&!vis[i]){
                        q.add(i);
                    }
                }
            }
            cnt++;
        }
        return 0;
    }
}",None,"class Solution {
    public int minJumps(int[] arr) {
        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();
        for(int i=0;i<arr.length;i++){
            if(hm.containsKey(arr[i])){
                ArrayList<Integer>al=hm.get(arr[i]);
                al.add(i);
                hm.put(arr[i],al);
            }
            else{
                ArrayList<Integer>al=new ArrayList<>();
                al.add(i);
                hm.put(arr[i],al);
            }
        }
        boolean vis[]=new boolean[arr.length];
        Queue<Integer>q=new LinkedList<>();
        q.add(0);
        int cnt=0;
        while(!q.isEmpty()){
            int size = q.size();
            while(size > 0) {
                int n = q.remove();
                vis[n] = true;
                if (n == arr.length - 1) return cnt;
                ArrayList<Integer> al = hm.get(arr[n]);
                for (int i : al) {
                    if (i >= 0 && i < arr.length && !vis[i]) {
                        q.add(i);
                    }
                }
                size--;
            }
            cnt++;
        }
        return 0;
    }
}
"
1498,java,new-21-game,"class Solution {
    public double new21Game(int n, int k, int maxPts) {
        if (k == 0 || n >= k + maxPts)
            return 1.0;
    
        double[] dp = new double[n + 1];
        double windowSum = 1.0;
        double probability = 0.0;
    
        dp[0] = 1.0;
    
        for (int i = 1; i <= n; i++) {
            dp[i] = windowSum / maxPts;
        
            if (i < k)
                windowSum += dp[i];
            else
                probability += dp[i-1];
        
            if (i - maxPts >= 0)
                windowSum -= dp[i - maxPts];
        }
    
        return probability;
    }
}",None,"class Solution {
    public double new21Game(int n, int k, int maxPts) {
        if (k == 0 || n >= k + maxPts)
            return 1.0;
    
        double[] dp = new double[n + 1];
        double windowSum = 1.0;
        double probability = 0.0;
    
        dp[0] = 1.0;
    
        for (int i = 1; i <= n; i++) {
            dp[i] = windowSum / maxPts;
        
            if (i < k)
                windowSum += dp[i];
            else
                probability += dp[i-1];
        
            if (i - maxPts >= 0)
                windowSum -= dp[i - maxPts];
        }
    
        return probability;
    }
}
"
1498,java,new-21-game,"class Solution {
    public double new21Game(int n, int k, int maxPts) {
        if (k == 0 || n >= k + maxPts)
            return 1.0;
    
        double[] dp = new double[n + 1];
        double windowSum = 1.0;
        double probability = 0.0;
    
        dp[0] = 1.0;
    
        for (int i = 1; i <= n; i++) {
            dp[i] = windowSum / maxPts;
        
            if (i < k)
                windowSum += dp[i];
            else
                probability += dp[i-1];
        
            if (i - maxPts >= 0)
                windowSum -= dp[i - maxPts];
        }
    
        return probability;
    }
}",None,"class Solution {
    public double new21Game(int n, int k, int maxPts) {
        if (k == 0 || n >= k + maxPts)
            return 1.0;
    
        double[] dp = new double[n + 1];
        double windowSum = 1.0;
        double probability = 0.0;
    
        dp[0] = 1.0;
    
        for (int i = 1; i <= n; i++) {
            dp[i] = windowSum / maxPts;
        
            if (i < k)
                windowSum += dp[i];
            else
                probability += dp[i-1];
        
            if (i - maxPts >= 0)
                windowSum -= dp[i - maxPts];
        }
    
        return probability;
    }
}
"
1498,java,new-21-game,"class Solution {
    public double new21Game(int n, int k, int maxPts) {
        if (k == 0 || n >= k + maxPts)
            return 1.0;
    
        double[] dp = new double[n + 1];
        double windowSum = 1.0;
        double probability = 0.0;
    
        dp[0] = 1.0;
    
        for (int i = 1; i <= n; i++) {
            dp[i] = windowSum / maxPts;
        
            if (i < k)
                windowSum += dp[i];
            else
                probability += dp[i-1];
        
            if (i - maxPts >= 0)
                windowSum -= dp[i - maxPts];
        }
    
        return probability;
    }
}",None,"class Solution {
    public double new21Game(int n, int k, int maxPts) {
        if (k == 0 || n >= k + maxPts)
            return 1.0;
    
        double[] dp = new double[n + 1];
        double windowSum = 1.0;
        double probability = 0.0;
    
        dp[0] = 1.0;
    
        for (int i = 1; i <= n; i++) {
            dp[i] = windowSum / maxPts;
        
            if (i < k)
                windowSum += dp[i];
            else
                probability += dp[i-1];
        
            if (i - maxPts >= 0)
                windowSum -= dp[i - maxPts];
        }
    
        return probability;
    }
}
"
1499,java,hamming-distance,"import java.math.BigInteger;
class Solution {
    public int hammingDistance(int x, int y) {
        String x_bin = Integer.toBinaryString(x);
        String y_bin = Integer.toBinaryString(y);

        int max_len = x_bin.length()>y_bin.length()?x_bin.length():y_bin.length();
        String max_str = x_bin.length()>y_bin.length()?x_bin: y_bin;
        String min_str = x_bin.length()>y_bin.length()?y_bin: x_bin;

        int result = 0;
        BigInteger min_bi;
        min_bi  = new BigInteger(min_str, 2); 
        System.out.println(""min_bi = ""+ min_bi);
        String min_format_str = String.format(""%0""+max_len+""d"", min_bi);
        for(int i=0; i<max_len; i++){
            if(max_str.charAt(i)!=min_format_str.charAt(i))
            {
                result+=1;
            }
        }
        System.out.println(max_str);
        System.out.println(min_format_str);

        return result;
    }
}",None,"import java.math.BigInteger;
class Solution {
    public int hammingDistance(int x, int y) {
        String x_bin = Integer.toBinaryString(x);
        String y_bin = Integer.toBinaryString(y);

        int max_len = x_bin.length()>y_bin.length()?x_bin.length():y_bin.length();
        String max_str = x_bin.length()>y_bin.length()?x_bin: y_bin;
        String min_str = x_bin.length()>y_bin.length()?y_bin: x_bin;

        int result = 0;
        BigInteger min_bi;
        min_bi  = new BigInteger(min_str, 2); 
        String min_format_str = String.format(""%0""+max_len+""d"", min_bi.toString(2));
        for(int i=0; i<max_len; i++){
            if(max_str.charAt(i)!=min_format_str.charAt(i))
            {
                result+=1;
            }
        }

        return result;
    }
}
"
1499,java,hamming-distance,"import java.math.BigInteger;
class Solution {
    public int hammingDistance(int x, int y) {
        String x_bin = Integer.toBinaryString(x);
        String y_bin = Integer.toBinaryString(y);

        int max_len = x_bin.length()>y_bin.length()?x_bin.length():y_bin.length();
        String max_str = x_bin.length()>y_bin.length()?x_bin: y_bin;
        String min_str = x_bin.length()>y_bin.length()?y_bin: x_bin;

        int result = 0;
        BigInteger min_bi;
        min_bi  = new BigInteger(min_str, 2); 
        System.out.println(""min_bi = ""+ min_bi);
        String min_format_str = String.format(""%0""+max_len+""d"", min_bi);
        for(int i=0; i<max_len; i++){
            if(max_str.charAt(i)!=min_format_str.charAt(i))
            {
                result+=1;
            }
        }
        System.out.println(max_str);
        System.out.println(min_format_str);

        return result;
    }
}",None,"import java.math.BigInteger;
class Solution {
    public int hammingDistance(int x, int y) {
        String x_bin = Integer.toBinaryString(x);
        String y_bin = Integer.toBinaryString(y);

        int max_len = x_bin.length()>y_bin.length()?x_bin.length():y_bin.length();
        String max_str = x_bin.length()>y_bin.length()?x_bin: y_bin;
        String min_str = x_bin.length()>y_bin.length()?y_bin: x_bin;

        int result = 0;
        BigInteger min_bi;
        min_bi  = new BigInteger(min_str, 2); 
        String min_format_str = String.format(""%""+max_len+""s"", Integer.toBinaryString(min_bi.intValue())).replace(' ', '0');
        for(int i=0; i<max_len; i++){
            if(max_str.charAt(i)!=min_format_str.charAt(i))
            {
                result+=1;
            }
        }
        return result;
    }
}
"
1499,java,hamming-distance,"import java.math.BigInteger;
class Solution {
    public int hammingDistance(int x, int y) {
        String x_bin = Integer.toBinaryString(x);
        String y_bin = Integer.toBinaryString(y);

        int max_len = x_bin.length()>y_bin.length()?x_bin.length():y_bin.length();
        String max_str = x_bin.length()>y_bin.length()?x_bin: y_bin;
        String min_str = x_bin.length()>y_bin.length()?y_bin: x_bin;

        int result = 0;
        BigInteger min_bi;
        min_bi  = new BigInteger(min_str, 2); 
        System.out.println(""min_bi = ""+ min_bi);
        String min_format_str = String.format(""%0""+max_len+""d"", min_bi);
        for(int i=0; i<max_len; i++){
            if(max_str.charAt(i)!=min_format_str.charAt(i))
            {
                result+=1;
            }
        }
        System.out.println(max_str);
        System.out.println(min_format_str);

        return result;
    }
}",None,"import java.math.BigInteger;
class Solution {
    public int hammingDistance(int x, int y) {
        String x_bin = Integer.toBinaryString(x);
        String y_bin = Integer.toBinaryString(y);

        int max_len = x_bin.length()>y_bin.length()?x_bin.length():y_bin.length();
        String max_str = x_bin.length()>y_bin.length()?x_bin: y_bin;
        String min_str = x_bin.length()>y_bin.length()?y_bin: x_bin;

        int result = 0;
        BigInteger min_bi;
        min_bi  = new BigInteger(min_str, 2); 
        String min_format_str = String.format(""%"" + max_len + ""s"", Integer.toBinaryString(min_bi.intValue())).replace(' ', '0');
        for(int i=0; i<max_len; i++){
            if(max_str.charAt(i)!=min_format_str.charAt(i))
            {
                result+=1;
            }
        }

        return result;
    }
}
"
1500,java,determine-the-winner-of-a-bowling-game,"class Solution {
    public int isWinner(int[] player1, int[] player2) {
        int i=1,j=i-1,k=i-2;
        int p1=player1[0],p2=player2[0];
        while(i<player1.length){
            if((j>=0 && player1[j]==10 ) || (k>=0 && player1[k]==10)){
                p1+=2*player1[i];
            }
            else{
                p1+=player1[i];
            }
            i++;
            j--;
            k--;
        }
        int l=1,m=l-1,n=l-2;
        while(l<player2.length){
            if((m>=0 && player2[m]==10 ) || (n>=0 && player2[n]==10)){
                p2+=2*player2[l];
            }
            else{
                p2+=player2[l];
            }
            l++;
            m--;
            n--;
        }
        if(p1>p2) return 1;
        else if(p1==p2) return 0;
        else return 2;
    }
}",None,"class Solution {
    public int isWinner(int[] player1, int[] player2) {
        int i=1,j=i-1,k=i-2;
        int p1=player1[0],p2=player2[0];
        while(i<player1.length){
            if(j>=0 && player1[j]==10 ) p1+=2*player1[i];
            else p1+=player1[i];
            i++;
            j--;
        }
        int l=1,m=l-1,n=l-2;
        while(l<player2.length){
            if(m>=0 && player2[m]==10 ) p2+=2*player2[l];
            else p2+=player2[l];
            l++;
            m--;
        }
        if(p1>p2) return 1;
        else if(p1==p2) return 0;
        else return 2;
    }
}
"
1500,java,determine-the-winner-of-a-bowling-game,"class Solution {
    public int isWinner(int[] player1, int[] player2) {
        int i=1,j=i-1,k=i-2;
        int p1=player1[0],p2=player2[0];
        while(i<player1.length){
            if((j>=0 && player1[j]==10 ) || (k>=0 && player1[k]==10)){
                p1+=2*player1[i];
            }
            else{
                p1+=player1[i];
            }
            i++;
            j--;
            k--;
        }
        int l=1,m=l-1,n=l-2;
        while(l<player2.length){
            if((m>=0 && player2[m]==10 ) || (n>=0 && player2[n]==10)){
                p2+=2*player2[l];
            }
            else{
                p2+=player2[l];
            }
            l++;
            m--;
            n--;
        }
        if(p1>p2) return 1;
        else if(p1==p2) return 0;
        else return 2;
    }
}",None,"class Solution {
    public int isWinner(int[] player1, int[] player2) {
        int i=1,j=i-1,k=i-2;
        int p1=player1[0],p2=player2[0];
        while(i<player1.length){
            if(j>=0 && player1[j]==10 ){
                p1+=2*player1[i];
            }
            else{
                p1+=player1[i];
            }
            if(k>=0 && player1[k]==10 ){
                p1+=player1[i];
            }
            i++;
            j--;
            k--;
        }
        int l=1,m=l-1,n=l-2;
        while(l<player2.length){
            if(m>=0 && player2[m]==10 ){
                p2+=2*player2[l];
            }
            else{
                p2+=player2[l];
            }
            if(n>=0 && player2[n]==10 ){
                p2+=player2[l];
            }
            l++;
            m--;
            n--;
        }
        if(p1>p2) return 1;
        else if(p1==p2) return 0;
        else return 2;
    }
}
"
1500,java,determine-the-winner-of-a-bowling-game,"class Solution {
    public int isWinner(int[] player1, int[] player2) {
        int i=1,j=i-1,k=i-2;
        int p1=player1[0],p2=player2[0];
        while(i<player1.length){
            if((j>=0 && player1[j]==10 ) || (k>=0 && player1[k]==10)){
                p1+=2*player1[i];
            }
            else{
                p1+=player1[i];
            }
            i++;
            j--;
            k--;
        }
        int l=1,m=l-1,n=l-2;
        while(l<player2.length){
            if((m>=0 && player2[m]==10 ) || (n>=0 && player2[n]==10)){
                p2+=2*player2[l];
            }
            else{
                p2+=player2[l];
            }
            l++;
            m--;
            n--;
        }
        if(p1>p2) return 1;
        else if(p1==p2) return 0;
        else return 2;
    }
}",None,"class Solution {
    public int isWinner(int[] player1, int[] player2) {
        int i=1,j=i-1,k=i-2;
        int p1=player1[0],p2=player2[0];
        while(i<player1.length){
            if(j >= 0 && player1[j] == 10){
                j--;
                if(k >= 0 && player1[k] == 10){
                    k--;
                }
                p1 += 2 * player1[i];
            } else {
                p1 += player1[i];
            }
            i++;
        }
        int l=1,m=l-1,n=l-2;
        while(l<player2.length){
            if(m >= 0 && player2[m] == 10){
                m--;
                if(n >= 0 && player2[n] == 10){
                    n--;
                }
                p2 += 2 * player2[l];
            } else {
                p2 += player2[l];
            }
            l++;
        }
        if(p1>p2) return 1;
        else if(p1==p2) return 0;
        else return 2;
    }
}
"
1501,java,transpose-matrix,"class Solution {
    public int[][] transpose(int[][] matrix) {
        int[][] ans = new int[matrix[0].length][matrix.length];
        int row = 0;
        int col = 0;

        for(int i = 0; i < matrix.length; i++) {
            for(int j = 0; j < matrix[0].length; j++) {
                ans[row][col] = matrix[j][i];

                row++;

                if(row % ans.length == 0) {
                    row = 0;
                    col++;
                }
            }
        }
        return ans;
    }
}",None,"class Solution {
    public int[][] transpose(int[][] matrix) {
        int[][] ans = new int[matrix[0].length][matrix.length];
        int row = 0;
        int col = 0;

        for(int i = 0; i < matrix.length; i++) {
            for(int j = 0; j < matrix[0].length; j++) {
                ans[col][row] = matrix[i][j]; // switch i and j in matrix[i][j]

                col++;

                if(col % ans.length == 0) {
                    col = 0;
                    row++;
                }
            }
        }
        return ans;
    }
}
"
1501,java,transpose-matrix,"class Solution {
    public int[][] transpose(int[][] matrix) {
        int[][] ans = new int[matrix[0].length][matrix.length];
        int row = 0;
        int col = 0;

        for(int i = 0; i < matrix.length; i++) {
            for(int j = 0; j < matrix[0].length; j++) {
                ans[row][col] = matrix[j][i];

                row++;

                if(row % ans.length == 0) {
                    row = 0;
                    col++;
                }
            }
        }
        return ans;
    }
}",None,"class Solution {
    public int[][] transpose(int[][] matrix) {
        int[][] ans = new int[matrix[0].length][matrix.length];
        int row = 0;
        int col = 0;

        for(int i = 0; i < matrix.length; i++) {
            for(int j = 0; j < matrix[0].length; j++) {
                ans[col][row] = matrix[j][i]; // swap row and col here

                if(++col % ans.length == 0) { // increment col first then check
                    col = 0;
                    row++;
                }
            }
        }
        return ans;
    }
}
"
1501,java,transpose-matrix,"class Solution {
    public int[][] transpose(int[][] matrix) {
        int[][] ans = new int[matrix[0].length][matrix.length];
        int row = 0;
        int col = 0;

        for(int i = 0; i < matrix.length; i++) {
            for(int j = 0; j < matrix[0].length; j++) {
                ans[row][col] = matrix[j][i];

                row++;

                if(row % ans.length == 0) {
                    row = 0;
                    col++;
                }
            }
        }
        return ans;
    }
}",None,"class Solution {
    public int[][] transpose(int[][] matrix) {
        int[][] ans = new int[matrix[0].length][matrix.length];
        int row = 0;
        int col = 0;

        for(int i = 0; i < matrix.length; i++) {
            for(int j = 0; j < matrix[0].length; j++) {
                ans[col][row] = matrix[i][j]; // switch i and j here

                col++;

                if(col % ans.length == 0) {
                    col = 0;
                    row++;
                }
            }
        }
        return ans;
    }
}
"
2075,java,populating-next-right-pointers-in-each-node,"class Solution {
    public Node connect(Node node) {
        Map<Integer, List<Node>> map = new HashMap<>();
        goDFS(0, node, map);
        for (int key : map.keySet()) {
            List<Node> list = map.get(key);
            for (int i = 1; i < list.size(); i++) {
                list.get(i - 1).next = list.get(i + 1);
            }
        }
        return node;
    }

    private void goDFS(int lvl, Node node, Map<Integer, List<Node>> map) {
        if (node == null) return;

        List<Node> list = map.computeIfAbsent(lvl, k -> new ArrayList<>());
        list.add(node);
        lvl++;
        goDFS(lvl, node.left, map);
        goDFS(lvl, node.right, map);
    }
}",None,"class Solution {
    public Node connect(Node node) {
        goDFS(0, node, null);
        return node;
    }

    private void goDFS(int lvl, Node node, Node last) {
        if (node == null) return;

        node.next = (last != null && lvl < last.level) ? last.right : null;
        last = node;
        last.level = lvl + 1;

        goDFS(lvl + 1, node.left, last);
        goDFS(lvl + 1, node.right, last);
    }
}
"
2075,java,populating-next-right-pointers-in-each-node,"class Solution {
    public Node connect(Node node) {
        Map<Integer, List<Node>> map = new HashMap<>();
        goDFS(0, node, map);
        for (int key : map.keySet()) {
            List<Node> list = map.get(key);
            for (int i = 1; i < list.size(); i++) {
                list.get(i - 1).next = list.get(i + 1);
            }
        }
        return node;
    }

    private void goDFS(int lvl, Node node, Map<Integer, List<Node>> map) {
        if (node == null) return;

        List<Node> list = map.computeIfAbsent(lvl, k -> new ArrayList<>());
        list.add(node);
        lvl++;
        goDFS(lvl, node.left, map);
        goDFS(lvl, node.right, map);
    }
}",None,"class Solution {
    public Node connect(Node node) {
        Map<Integer, List<Node>> map = new HashMap<>();
        goDFS(0, node, map);
        for (int key : map.keySet()) {
            List<Node> list = map.get(key);
            for (int i = 1; i < list.size(); i++) {
                list.get(i - 1).next = list.get(i);
            }
            if (list.size() > 1) {
                list.get(list.size() - 1).next = null;
            }
        }
        return node;
    }

    private void goDFS(int lvl, Node node, Map<Integer, List<Node>> map) {
        if (node == null) return;

        List<Node> list = map.computeIfAbsent(lvl, k -> new ArrayList<>());
        list.add(node);
        lvl++;
        goDFS(lvl, node.left, map);
        goDFS(lvl, node.right, map);
    }
}
"
2075,java,populating-next-right-pointers-in-each-node,"class Solution {
    public Node connect(Node node) {
        Map<Integer, List<Node>> map = new HashMap<>();
        goDFS(0, node, map);
        for (int key : map.keySet()) {
            List<Node> list = map.get(key);
            for (int i = 1; i < list.size(); i++) {
                list.get(i - 1).next = list.get(i + 1);
            }
        }
        return node;
    }

    private void goDFS(int lvl, Node node, Map<Integer, List<Node>> map) {
        if (node == null) return;

        List<Node> list = map.computeIfAbsent(lvl, k -> new ArrayList<>());
        list.add(node);
        lvl++;
        goDFS(lvl, node.left, map);
        goDFS(lvl, node.right, map);
    }
}",None,"class Solution {
    public Node connect(Node node) {
        Map<Integer, List<Node>> map = new HashMap<>();
        goDFS(0, node, map);
        for (int key : map.keySet()) {
            List<Node> list = map.get(key);
            for (int i = 1; i < list.size(); i++) {
                list.get(i - 1).next = list.get(i);
            }
            if (list.size() > 1) {
                list.get(list.size() - 1).next = null;
            }
        }
        return node;
    }

    private void goDFS(int lvl, Node node, Map<Integer, List<Node>> map) {
        if (node == null) return;

        List<Node> list = map.computeIfAbsent(lvl, k -> new ArrayList<>());
        list.add(node);
        lvl++;
        goDFS(lvl, node.left, map);
        goDFS(lvl, node.right, map);
    }
}
"
2076,java,find-all-lonely-numbers-in-the-array,"class Solution {
    public List<Integer> findLonely(int[] arr) {
        HashMap<Integer, Integer> map = new HashMap<>();
        ArrayList<Integer> list = new ArrayList<>();
        
        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);
        for (int i : arr) if (map.get(i) == 1 && map.containsKey(i - 1) && map.containsKey(i + 1)) list.add(i);
        return list;
    }
}",None,"class Solution {
    public List<Integer> findLonely(int[] arr) {
        HashMap<Integer, Integer> map = new HashMap<>();
        ArrayList<Integer> list = new ArrayList<>();
        
        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);
        for (int i : arr) {
            if (map.get(i) == 1) {
                if (map.containsKey(i - 1) && map.containsKey(i + 1)) {
                    list.add(i);
                }
            }
        }
        return list;
    }
}
"
2076,java,find-all-lonely-numbers-in-the-array,"class Solution {
    public List<Integer> findLonely(int[] arr) {
        HashMap<Integer, Integer> map = new HashMap<>();
        ArrayList<Integer> list = new ArrayList<>();
        
        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);
        for (int i : arr) if (map.get(i) == 1 && map.containsKey(i - 1) && map.containsKey(i + 1)) list.add(i);
        return list;
    }
}",None,"class Solution {
    public List<Integer> findLonely(int[] arr) {
        HashMap<Integer, Integer> map = new HashMap<>();
        ArrayList<Integer> list = new ArrayList<>();
        
        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);
        for (int i : arr) {
            if (map.get(i) == 1 && !map.containsKey(i - 1) && !map.containsKey(i + 1)) {
                list.add(i);
            }
        }
        return list;
    }
}
"
2076,java,find-all-lonely-numbers-in-the-array,"class Solution {
    public List<Integer> findLonely(int[] arr) {
        HashMap<Integer, Integer> map = new HashMap<>();
        ArrayList<Integer> list = new ArrayList<>();
        
        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);
        for (int i : arr) if (map.get(i) == 1 && map.containsKey(i - 1) && map.containsKey(i + 1)) list.add(i);
        return list;
    }
}",None,"class Solution {
    public List<Integer> findLonely(int[] arr) {
        HashMap<Integer, Integer> map = new HashMap<>();
        ArrayList<Integer> list = new ArrayList<>();
        
        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);
        for (int i : arr) {
            if (map.get(i) == 1 && (!map.containsKey(i - 1) || !map.containsKey(i + 1))) {
                list.add(i);
            }
        }
        return list;
    }
}
"
2077,java,find-first-palindromic-string-in-the-array,"class Solution {
    public String firstPalindrome(String[] words) {
        for (String s : words) {
            if (isPalindrome(s)) return s;
        }

        return """";
    }

    public boolean isPalindrome(String s) {
        int i = 0, j = s.length();

        while (i < j) {
            if (s.charAt(i++) != s.charAt(j--)) {
                return false;
            }
        }

        return true;
    }
}",None,"class Solution {
    public String firstPalindrome(String[] words) {
        for (String s : words) {
            if (isPalindrome(s)) return s;
        }

        return """";
    }

    public boolean isPalindrome(String s) {
        int i = 0, j = s.length() - 1; // corrected index j

        while (i < j) {
            if (s.charAt(i++) != s.charAt(j--)) {
                return false;
            }
        }

        return true;
    }
}
"
2077,java,find-first-palindromic-string-in-the-array,"class Solution {
    public String firstPalindrome(String[] words) {
        for (String s : words) {
            if (isPalindrome(s)) return s;
        }

        return """";
    }

    public boolean isPalindrome(String s) {
        int i = 0, j = s.length();

        while (i < j) {
            if (s.charAt(i++) != s.charAt(j--)) {
                return false;
            }
        }

        return true;
    }
}",None,"class Solution {
    public String firstPalindrome(String[] words) {
        for (String s : words) {
            if (isPalindrome(s)) return s;
        }

        return """";
    }

    public boolean isPalindrome(String s) {
        int i = 0, j = s.length() - 1; // corrected the stopping condition of the while loop

        while (i < j) {
            if (s.charAt(i++) != s.charAt(j--)) {
                return false;
            }
        }

        return true;
    }
}
"
2077,java,find-first-palindromic-string-in-the-array,"class Solution {
    public String firstPalindrome(String[] words) {
        for (String s : words) {
            if (isPalindrome(s)) return s;
        }

        return """";
    }

    public boolean isPalindrome(String s) {
        int i = 0, j = s.length();

        while (i < j) {
            if (s.charAt(i++) != s.charAt(j--)) {
                return false;
            }
        }

        return true;
    }
}",None,"class Solution {
    public String firstPalindrome(String[] words) {
        for (String s : words) {
            if (isPalindrome(s)) return s;
        }

        return """";
    }

    public boolean isPalindrome(String s) {
        int i = 0, j = s.length() - 1; // corrected the j initialization

        while (i < j) {
            if (s.charAt(i++) != s.charAt(j--)) {
                return false;
            }
        }

        return true;
    }
}
"
2078,java,missing-number,"class Solution {
    public int missingNumber(int[] nums) {


        int res = 0;
        for (int i = 0; i <= nums.length; i++) {
            res += ((i + 1) - nums[i]);
        }
        return res;

    }
}",None,"class Solution {
    public int missingNumber(int[] nums) {

        int res = 0;
        for (int i = 0; i < nums.length; i++) {
            res += ((i + 1) - nums[i]);
        }
        return res + (nums.length + 1);
    }
}
"
2078,java,missing-number,"class Solution {
    public int missingNumber(int[] nums) {


        int res = 0;
        for (int i = 0; i <= nums.length; i++) {
            res += ((i + 1) - nums[i]);
        }
        return res;

    }
}",None,"class Solution {
    public int missingNumber(int[] nums) {


        int res = 0;
        for (int i = 0; i < nums.length; i++) {
            res += ((i + 1) - nums[i]);
        }
        return res + nums.length + 1;

    }
}
"
2078,java,missing-number,"class Solution {
    public int missingNumber(int[] nums) {


        int res = 0;
        for (int i = 0; i <= nums.length; i++) {
            res += ((i + 1) - nums[i]);
        }
        return res;

    }
}",None,"class Solution {
    public int missingNumber(int[] nums) {

        int res = 0;
        for (int i = 0; i < nums.length; i++) {
            res += ((i + 1) - nums[i]);
        }
        return res + (nums.length + 1);

    }
}
"
2079,java,sum-of-left-leaves,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    static int result;

    public int sumOfLeftLeaves(TreeNode root) {
        result=0;

        task(root.left, true);

        task(root, false);   

        return result;
    }

    static void task(TreeNode root, boolean flag){
        if(root == null) return;

        if(flag && root.left==null && root.right==null) result+=root.val;

        task(root.left, true);
        task(root.right, false);
    }
}",None,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    static int result;

    public int sumOfLeftLeaves(TreeNode root) {
        result=0;

        task(root.left, true);

        task(root, false);   

        return result;
    }

    static void task(TreeNode root, boolean flag){
        if(root == null) return;

        if(flag && root.left==null && root.right==null) result+=root.val;

        task(root.left, flag);
        task(root.right, false);
    }
}
"
2079,java,sum-of-left-leaves,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    static int result;

    public int sumOfLeftLeaves(TreeNode root) {
        result=0;

        task(root.left, true);

        task(root, false);   

        return result;
    }

    static void task(TreeNode root, boolean flag){
        if(root == null) return;

        if(flag && root.left==null && root.right==null) result+=root.val;

        task(root.left, true);
        task(root.right, false);
    }
}",None,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    static int result;

    public int sumOfLeftLeaves(TreeNode root) {
        result=0;

        task(root.left, true);

        task(root, false);   

        return result;
    }

    static void task(TreeNode root, boolean flag){
        if(root == null) return;

        if(flag && root.left==null && root.right==null) result+=root.val;

        task(root.left, flag);
        task(root.right, false);
    }
}
"
2079,java,sum-of-left-leaves,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    static int result;

    public int sumOfLeftLeaves(TreeNode root) {
        result=0;

        task(root.left, true);

        task(root, false);   

        return result;
    }

    static void task(TreeNode root, boolean flag){
        if(root == null) return;

        if(flag && root.left==null && root.right==null) result+=root.val;

        task(root.left, true);
        task(root.right, false);
    }
}",None,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    static int result;

    public int sumOfLeftLeaves(TreeNode root) {
        result=0;

        task(root.left, true);

        task(root.right, false);   

        return result;
    }

    static void task(TreeNode root, boolean flag){
        if(root == null) return;

        if(flag && root.left==null && root.right==null) result+=root.val;

        task(root.left, flag);
        task(root.right, false);
    }
}
"
2080,java,maximum-binary-tree,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        TreeNode root= construct(nums,0,nums.length);
        return root;
    }
    private static TreeNode construct(int arr[], int s, int e){
        if(s>e)return null;
        if(s==e) return new TreeNode(arr[s]);

        int idx=findMax(arr,s,e);
        TreeNode root=new TreeNode(arr[idx]);
        root.left=construct(arr,s,idx-1);
        root.right=construct(arr,idx+1,e);

        return root;
    }

    private static int findMax(int arr[], int s, int e){
        int max=Integer.MIN_VALUE;
        int idx=-1;
        for(int i=s;i<=e; i++)
        {
            if(arr[i]>max){
                max=arr[i];
                idx=i;
            }
        }
        return idx;
    }

}",None,"class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        TreeNode root= construct(nums,0,nums.length-1);
        return root;
    }
    private static TreeNode construct(int arr[], int s, int e){
        if(s>e) return null;

        if(s == e) return new TreeNode(arr[s]);

        int idx=findMax(arr,s,e);
        TreeNode root=new TreeNode(arr[idx]);
        root.left=construct(arr,s,idx-1);
        root.right=construct(arr,idx+1,e);

        return root;
    }

    private static int findMax(int arr[], int s, int e){
        int max=Integer.MIN_VALUE;
        int idx=-1;
        for(int i=s;i<=e; i++)
        {
            if(arr[i]>max){
                max=arr[i];
                idx=i;
            }
        }
        return idx;
    }
}
"
2080,java,maximum-binary-tree,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        TreeNode root= construct(nums,0,nums.length);
        return root;
    }
    private static TreeNode construct(int arr[], int s, int e){
        if(s>e)return null;
        if(s==e) return new TreeNode(arr[s]);

        int idx=findMax(arr,s,e);
        TreeNode root=new TreeNode(arr[idx]);
        root.left=construct(arr,s,idx-1);
        root.right=construct(arr,idx+1,e);

        return root;
    }

    private static int findMax(int arr[], int s, int e){
        int max=Integer.MIN_VALUE;
        int idx=-1;
        for(int i=s;i<=e; i++)
        {
            if(arr[i]>max){
                max=arr[i];
                idx=i;
            }
        }
        return idx;
    }

}",None,"class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        TreeNode root= construct(nums,0,nums.length-1);
        return root;
    }
    private static TreeNode construct(int arr[], int s, int e){
        if(s>e)return null;
        if(s==e) return new TreeNode(arr[s]);

        int idx=findMax(arr,s,e);
        TreeNode root=new TreeNode(arr[idx]);
        root.left=construct(arr,s,idx-1);
        root.right=construct(arr,idx+1,e);

        return root;
    }

    private static int findMax(int arr[], int s, int e){
        int max=Integer.MIN_VALUE;
        int idx=-1;
        for(int i=s;i<=e; i++)
        {
            if(arr[i]>max){
                max=arr[i];
                idx=i;
            }
        }
        return idx;
    }
}
"
2080,java,maximum-binary-tree,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        TreeNode root= construct(nums,0,nums.length);
        return root;
    }
    private static TreeNode construct(int arr[], int s, int e){
        if(s>e)return null;
        if(s==e) return new TreeNode(arr[s]);

        int idx=findMax(arr,s,e);
        TreeNode root=new TreeNode(arr[idx]);
        root.left=construct(arr,s,idx-1);
        root.right=construct(arr,idx+1,e);

        return root;
    }

    private static int findMax(int arr[], int s, int e){
        int max=Integer.MIN_VALUE;
        int idx=-1;
        for(int i=s;i<=e; i++)
        {
            if(arr[i]>max){
                max=arr[i];
                idx=i;
            }
        }
        return idx;
    }

}",None,"class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return construct(nums, 0, nums.length - 1);
    }

    private static TreeNode construct(int[] nums, int start, int end) {
        if (start > end)
            return null;

        int maxIndex = start;
        for (int i = start + 1; i <= end; i++) {
            if (nums[i] > nums[maxIndex]) {
                maxIndex = i;
            }
        }

        TreeNode node = new TreeNode(nums[maxIndex]);
        node.left = construct(nums, start, maxIndex - 1);
        node.right = construct(nums, maxIndex + 1, end);

        return node;
    }
}
"
2081,java,check-completeness-of-a-binary-tree,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isCompleteTree(TreeNode root) {
        boolean end = false;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()) {
            TreeNode currentNode = queue.poll();
            if(currentNode == null) {
                end = true;
            } else {
                if(end) {
                    return false;
                }
                queue.offer(currentNode.right);
                queue.offer(currentNode.left);
            }
        }
        return true;
    }
}",None,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isCompleteTree(TreeNode root) {
        boolean end = false;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()) {
            TreeNode currentNode = queue.poll();
            if(currentNode == null) {
                end = true;
            } else {
                if(end) {
                    return false;
                }
                queue.offer(currentNode.left);
                queue.offer(currentNode.right);
            }
        }
        return true;
    }
}
"
2081,java,check-completeness-of-a-binary-tree,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isCompleteTree(TreeNode root) {
        boolean end = false;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()) {
            TreeNode currentNode = queue.poll();
            if(currentNode == null) {
                end = true;
            } else {
                if(end) {
                    return false;
                }
                queue.offer(currentNode.right);
                queue.offer(currentNode.left);
            }
        }
        return true;
    }
}",None,"class Solution {
    public boolean isCompleteTree(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        boolean isEnd = false;
        while (!queue.isEmpty()) {
            TreeNode currentNode = queue.poll();
            if (currentNode == null) {
                isEnd = true;
            } else {
                if (isEnd) {
                    return false;
                }
                queue.offer(currentNode.left);
                queue.offer(currentNode.right);
            }
        }
        return true;
    }
}
"
2081,java,check-completeness-of-a-binary-tree,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isCompleteTree(TreeNode root) {
        boolean end = false;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()) {
            TreeNode currentNode = queue.poll();
            if(currentNode == null) {
                end = true;
            } else {
                if(end) {
                    return false;
                }
                queue.offer(currentNode.right);
                queue.offer(currentNode.left);
            }
        }
        return true;
    }
}",None,"class Solution {
    public boolean isCompleteTree(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        boolean end = false;
        while (!queue.isEmpty()) {
            TreeNode currentNode = queue.poll();
            if (currentNode == null) {
                end = true;
            } else {
                if (end) {
                    return false;
                }
                queue.offer(currentNode.left);
                queue.offer(currentNode.right);
            }
        }
        return true;
    }
}
"
2082,java,check-if-one-string-swap-can-make-strings-equal,"class Solution {
    public boolean areAlmostEqual(String s1, String s2) {
        if(s1.equals(s2))
        return true;
        ArrayList<Character> ts=new ArrayList<>();
        ArrayList<Character> ts1=new ArrayList<>();
        int count=0;
        for(int i=0;i<s1.length();i++){
            if(s1.charAt(i)!=s2.charAt(i)){
            ts.add(s1.charAt(i));
            ts1.add(s2.charAt(i));    
        }
        }
        for(Character co:ts){
            if(!(ts.contains(co)))
            return false;
        }
        return (ts.size()==2 && ts1.size()==2)?true:false;
    }
}",None,"class Solution {
    public boolean areAlmostEqual(String s1, String s2) {
        if(s1.equals(s2))
            return true;
        List<Character> ts = new ArrayList<>();
        List<Character> ts1 = new ArrayList<>();
        int count = 0;
        for(int i=0;i<s1.length();i++){
            if(s1.charAt(i)!=s2.charAt(i)){
                ts.add(s1.charAt(i));
                ts1.add(s2.charAt(i));
                count++;
            }
        }
        if(count > 2)
            return false;
        Collections.sort(ts);
        Collections.sort(ts1);
        return ts.equals(ts1);
    }
}
"
2082,java,check-if-one-string-swap-can-make-strings-equal,"class Solution {
    public boolean areAlmostEqual(String s1, String s2) {
        if(s1.equals(s2))
        return true;
        ArrayList<Character> ts=new ArrayList<>();
        ArrayList<Character> ts1=new ArrayList<>();
        int count=0;
        for(int i=0;i<s1.length();i++){
            if(s1.charAt(i)!=s2.charAt(i)){
            ts.add(s1.charAt(i));
            ts1.add(s2.charAt(i));    
        }
        }
        for(Character co:ts){
            if(!(ts.contains(co)))
            return false;
        }
        return (ts.size()==2 && ts1.size()==2)?true:false;
    }
}",None,"class Solution {
    public boolean areAlmostEqual(String s1, String s2) {
        if(s1.equals(s2))
            return true;
        List<Character> ts = new ArrayList<>();
        List<Character> ts1 = new ArrayList<>();
        int count = 0;
        for(int i=0;i<s1.length();i++){
            if(s1.charAt(i)!=s2.charAt(i)){
                ts.add(s1.charAt(i));
                ts1.add(s2.charAt(i));
                count++;
            }
        }
        if(count > 2)
            return false;
        else if(count == 0)
            return false;
        else if(count == 2)
            return ts.get(0) == ts1.get(1) && ts.get(1) == ts1.get(0);
        else
            return false;
    }
}
"
2082,java,check-if-one-string-swap-can-make-strings-equal,"class Solution {
    public boolean areAlmostEqual(String s1, String s2) {
        if(s1.equals(s2))
        return true;
        ArrayList<Character> ts=new ArrayList<>();
        ArrayList<Character> ts1=new ArrayList<>();
        int count=0;
        for(int i=0;i<s1.length();i++){
            if(s1.charAt(i)!=s2.charAt(i)){
            ts.add(s1.charAt(i));
            ts1.add(s2.charAt(i));    
        }
        }
        for(Character co:ts){
            if(!(ts.contains(co)))
            return false;
        }
        return (ts.size()==2 && ts1.size()==2)?true:false;
    }
}",None,"class Solution {
    public boolean areAlmostEqual(String s1, String s2) {
        if(s1.equals(s2))
            return true;
        ArrayList<Integer> diffIndices = new ArrayList<>();
        int count = 0;
        for(int i = 0; i < s1.length(); i++){
            if(s1.charAt(i) != s2.charAt(i)){
                diffIndices.add(i);
                count++;
            }
        }
        if(count > 2)
            return false;
        else if(count == 0)
            return false;
        else if(count == 2){
            return s1.charAt(diffIndices.get(0)) == s2.charAt(diffIndices.get(1)) &&
                    s1.charAt(diffIndices.get(1)) == s2.charAt(diffIndices.get(0));
        }
        else{ // count == 1
            return s1.charAt(diffIndices.get(0)) == s2.charAt(diffIndices.get(0));
        }
    }
}
"
2083,java,furthest-building-you-can-reach,"class Solution {
    public int furthestBuilding(int[] heights, int bricks, int ladders) {
        PriorityQueue<Integer> p = new PriorityQueue<>();
        for(int i=1;i<=heights.length;i++){
            int diff = heights[i] - heights[i-1];
            if(diff > 0){
                p.add(diff);
            }
            if(p.size() > ladders){
                bricks -= p.poll();
            }
            if(bricks < 0){
                return i-1;
            }
        }
        if(bricks >= 0) return heights.length-1;
        return -1;
    }
}",None,"class Solution {
    public int furthestBuilding(int[] heights, int bricks, int ladders) {
        PriorityQueue<Integer> p = new PriorityQueue<>();
        for(int i=1;i<heights.length;i++){
            int diff = heights[i] - heights[i-1];
            if(diff > 0){
                p.add(diff);
            }
            if(p.size() > ladders){
                bricks -= p.poll();
                if(bricks < 0){
                    return i-1;
                }
            }
        }
        return heights.length-1;
    }
}
"
2083,java,furthest-building-you-can-reach,"class Solution {
    public int furthestBuilding(int[] heights, int bricks, int ladders) {
        PriorityQueue<Integer> p = new PriorityQueue<>();
        for(int i=1;i<=heights.length;i++){
            int diff = heights[i] - heights[i-1];
            if(diff > 0){
                p.add(diff);
            }
            if(p.size() > ladders){
                bricks -= p.poll();
            }
            if(bricks < 0){
                return i-1;
            }
        }
        if(bricks >= 0) return heights.length-1;
        return -1;
    }
}",None,"class Solution {
    public int furthestBuilding(int[] heights, int bricks, int ladders) {
        PriorityQueue<Integer> p = new PriorityQueue<>();
        for(int i=1;i<heights.length;i++){
            int diff = heights[i] - heights[i-1];
            if(diff > 0){
                p.add(diff);
            }
            if(p.size() > ladders){
                bricks -= p.poll();
                if(bricks < 0){
                    return i-1;
                }
            }
        }
        return heights.length-1;
    }
}
"
2083,java,furthest-building-you-can-reach,"class Solution {
    public int furthestBuilding(int[] heights, int bricks, int ladders) {
        PriorityQueue<Integer> p = new PriorityQueue<>();
        for(int i=1;i<=heights.length;i++){
            int diff = heights[i] - heights[i-1];
            if(diff > 0){
                p.add(diff);
            }
            if(p.size() > ladders){
                bricks -= p.poll();
            }
            if(bricks < 0){
                return i-1;
            }
        }
        if(bricks >= 0) return heights.length-1;
        return -1;
    }
}",None,"class Solution {
    public int furthestBuilding(int[] heights, int bricks, int ladders) {
        PriorityQueue<Integer> p = new PriorityQueue<>((a, b) -> b - a);
        for(int i=1;i<heights.length;i++){
            int diff = heights[i] - heights[i-1];
            if(diff > 0){
                p.add(diff);
            }
            if(p.size() > ladders){
                bricks -= p.poll();
            }
            if(bricks < 0){
                return i-1;
            }
        }
        if(bricks >= 0) return heights.length-1;
        return -1;
    }
}
"
2084,java,h-index-ii,"class Solution {
    public int hIndex(int[] citations) {

        int left = 0, right = citations.length - 1;
        int n = citations.length;
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(citations[mid] == n - mid) return n - mid;
            else if(citations[mid] < n - mid) left = mid;
            else right = mid;
        }
        return n - left;
    }
}",None,"class Solution {
    public int hIndex(int[] citations) {

        int left = 0, right = citations.length - 1;
        int n = citations.length;
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(citations[mid] == n - mid) return n - mid;
            else if(citations[mid] < n - mid) left = mid + 1;
            else right = mid - 1;
        }
        return left;
    }
}
"
2084,java,h-index-ii,"class Solution {
    public int hIndex(int[] citations) {

        int left = 0, right = citations.length - 1;
        int n = citations.length;
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(citations[mid] == n - mid) return n - mid;
            else if(citations[mid] < n - mid) left = mid;
            else right = mid;
        }
        return n - left;
    }
}",None,"class Solution {
    public int hIndex(int[] citations) {

        int left = 0, right = citations.length - 1;
        int n = citations.length;
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(citations[mid] == n - mid) return n - mid;
            else if(citations[mid] < n - mid) left = mid + 1;
            else right = mid - 1;
        }
        return left;
    }
}
"
2084,java,h-index-ii,"class Solution {
    public int hIndex(int[] citations) {

        int left = 0, right = citations.length - 1;
        int n = citations.length;
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(citations[mid] == n - mid) return n - mid;
            else if(citations[mid] < n - mid) left = mid;
            else right = mid;
        }
        return n - left;
    }
}",None,"class Solution {
    public int hIndex(int[] citations) {

        int left = 0, right = citations.length - 1;
        int n = citations.length;
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(citations[mid] == n - mid) return n - mid;
            else if(citations[mid] < n - mid) left = mid + 1;
            else right = mid - 1;
        }
        return left;
    }
}
"
2085,java,maximum-sum-with-exactly-k-elements,"public int maximizeSum(int[] nums, int k) {
        int max = nums[0];
        for (int m: nums)
            max = Math.max(m, max);
        int sum = max++;
        for (int i = 0; i <= k - 1; i++)
            sum += max++;
        return sum;
    }",None,"public int maximizeSum(int[] nums, int k) {
    int sum = 0;
    PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
    for (int num : nums) {
        pq.add(num);
    }
    for (int i = 0; i < k; i++) {
        int cur = pq.poll();
        sum += cur;
        pq.add(cur + 1);
    }
    while (!pq.isEmpty()) {
        sum += pq.poll();
    }
    return sum;
}
"
2085,java,maximum-sum-with-exactly-k-elements,"public int maximizeSum(int[] nums, int k) {
        int max = nums[0];
        for (int m: nums)
            max = Math.max(m, max);
        int sum = max++;
        for (int i = 0; i <= k - 1; i++)
            sum += max++;
        return sum;
    }",None,"public int maximizeSum(int[] nums, int k) {
    int sum = 0;
    PriorityQueue<Integer> pq = new PriorityQueue<>();
    for (int num : nums) {
        pq.offer(num);
    }
    for (int i = 0; i < k; i++) {
        int curr = pq.poll();
        sum += curr;
        pq.offer(curr + 1);
    }
    while (!pq.isEmpty()) {
        sum += pq.poll();
    }
    return sum;
}
"
2085,java,maximum-sum-with-exactly-k-elements,"public int maximizeSum(int[] nums, int k) {
        int max = nums[0];
        for (int m: nums)
            max = Math.max(m, max);
        int sum = max++;
        for (int i = 0; i <= k - 1; i++)
            sum += max++;
        return sum;
    }",None,"public int maximizeSum(int[] nums, int k) {
    int sum = 0;
    PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
    for (int num : nums) {
        pq.add(num);
    }
    for (int i = 0; i < k; i++) {
        int cur = pq.poll();
        sum += cur;
        pq.add(cur + 1);
    }
    return sum;
}
"
2086,java,remove-colored-pieces-if-both-neighbors-are-the-same-color,"class Solution {
    public boolean winnerOfGame(String s) {
        int n = s.length();
    
        int a=0;
        int b=0;
        
        for(int i=1; i<n; i++) 
        {
            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )
            a++;
            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )
            b++;
        }

        if(a<=b)
            return false;
        else
            return true;
    }
}",None,"class Solution {
    public boolean winnerOfGame(String s) {
        int n = s.length();
    
        int a=0;
        int b=0;
        
        for(int i=1; i<n-1; i++) 
        {
            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )
            a++;
            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )
            b++;
        }

        if(a>b)
            return true;
        else
            return false;
    }
}
"
2086,java,remove-colored-pieces-if-both-neighbors-are-the-same-color,"class Solution {
    public boolean winnerOfGame(String s) {
        int n = s.length();
    
        int a=0;
        int b=0;
        
        for(int i=1; i<n; i++) 
        {
            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )
            a++;
            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )
            b++;
        }

        if(a<=b)
            return false;
        else
            return true;
    }
}",None,"class Solution {
    public boolean winnerOfGame(String s) {
        int n = s.length();
    
        int a=0;
        int b=0;
        
        for(int i=1; i<n-1; i++) 
        {
            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )
            a++;
            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )
            b++;
        }

        if(a > b)
            return true;
        else
            return false;
    }
}
"
2086,java,remove-colored-pieces-if-both-neighbors-are-the-same-color,"class Solution {
    public boolean winnerOfGame(String s) {
        int n = s.length();
    
        int a=0;
        int b=0;
        
        for(int i=1; i<n; i++) 
        {
            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )
            a++;
            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )
            b++;
        }

        if(a<=b)
            return false;
        else
            return true;
    }
}",None,"class Solution {
    public boolean winnerOfGame(String s) {
        int n = s.length();
    
        int a=0;
        int b=0;
        
        for(int i=1; i<n-1; i++) 
        {
            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )
            a++;
            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )
            b++;
        }

        if(a>b)
            return true;
        else
            return false;
    }
}
"
2087,java,minimum-suffix-flips,"class Solution {
    public int minFlips(String target) {
        int flips = 0;
        char prev = target.charAt(0);
        if (prev == '1') flips++;

        for (int i = 1; i <= target.length(); i++) {
            char c = target.charAt(i);
            if (c != prev) {
                flips++;
                prev = c;
            }
        }
        return flips;
    }
}",None,"class Solution {
    public int minFlips(String target) {
        int flips = 0;
        char prev = target.charAt(0);
        if (prev == '1') flips++;

        for (int i = 1; i < target.length(); i++) {
            char c = target.charAt(i);
            if (c != prev) {
                flips++;
                prev = c;
            }
        }
        return flips;
    }
}
"
2087,java,minimum-suffix-flips,"class Solution {
    public int minFlips(String target) {
        int flips = 0;
        char prev = target.charAt(0);
        if (prev == '1') flips++;

        for (int i = 1; i <= target.length(); i++) {
            char c = target.charAt(i);
            if (c != prev) {
                flips++;
                prev = c;
            }
        }
        return flips;
    }
}",None,"class Solution {
    public int minFlips(String target) {
        int flips = 0;
        char prev = target.charAt(0);
        if (prev == '1') flips++;

        for (int i = 1; i < target.length(); i++) {
            char c = target.charAt(i);
            if (c != prev) {
                flips++;
                prev = c;
            }
        }
        return flips;
    }
}
"
2087,java,minimum-suffix-flips,"class Solution {
    public int minFlips(String target) {
        int flips = 0;
        char prev = target.charAt(0);
        if (prev == '1') flips++;

        for (int i = 1; i <= target.length(); i++) {
            char c = target.charAt(i);
            if (c != prev) {
                flips++;
                prev = c;
            }
        }
        return flips;
    }
}",None,"class Solution {
    public int minFlips(String target) {
        int flips = 0;
        char prev = target.charAt(0);
        if (prev == '1') flips++;

        for (int i = 1; i < target.length(); i++) {
            char c = target.charAt(i);
            if (c != prev) {
                flips++;
                prev = c;
            }
        }
        return flips;
    }
}
"
2088,java,number-of-arithmetic-triplets,"class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        
        int count=0;
        for(int i=0;i<=nums.length;i++){
            for(int j=i+1;j<=nums.length;j++){
                for(int k=j+1;k<=nums.length;k++){
                    if(nums[j]-nums[i]==diff && nums[k] - nums[j] == diff){
                        count++;
                    }
                }
            }
        }
        
        return count;
    }
}",None,"class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        
        int count=0;
        for(int i=0;i<nums.length-2;i++){
            if(nums[i+2] - nums[i] == diff*2){
                count++;
            }
        }
        
        return count;
    }
}
"
2088,java,number-of-arithmetic-triplets,"class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        
        int count=0;
        for(int i=0;i<=nums.length;i++){
            for(int j=i+1;j<=nums.length;j++){
                for(int k=j+1;k<=nums.length;k++){
                    if(nums[j]-nums[i]==diff && nums[k] - nums[j] == diff){
                        count++;
                    }
                }
            }
        }
        
        return count;
    }
}",None,"class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        int count = 0;
        for (int i = 0; i < nums.length - 2; i++) {
            if (nums[i + 2] - nums[i] == diff * 2) {
                count++;
            }
        }
        return count;
    }
}
"
2088,java,number-of-arithmetic-triplets,"class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        
        int count=0;
        for(int i=0;i<=nums.length;i++){
            for(int j=i+1;j<=nums.length;j++){
                for(int k=j+1;k<=nums.length;k++){
                    if(nums[j]-nums[i]==diff && nums[k] - nums[j] == diff){
                        count++;
                    }
                }
            }
        }
        
        return count;
    }
}",None,"class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        int count=0;
        for(int i=0;i<nums.length-2;i++){
            if(nums[i+2] - nums[i] == 2*diff){
                count++;
            }
        }
        
        return count;
    }
}
"
2089,java,word-search,"class Solution {
    private boolean visited[][];
    public boolean exist(char[][] board, String word) {
        int m=board.length, n=board[0].length;
        visited=new boolean[m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(board[i][j]==word.charAt(0)&&dfs(board,i,j,0,word)) return true;
            }
        }
        return false;

        
    }
    public boolean dfs(char[][] board,int i,int j,int index,String word){
        if(index==word.length()) return true;
        if(i<0||j<0||i>=board.length||j>=board[0].length||board[i][j]!=word.charAt(index)||visited[i][j]){
            return false;
        }
        visited[i][j]=true;
        boolean found= dfs(board,i+1,j,index,word)||dfs(board,i-1,j,index,word)||dfs(board,i,j+1,index,word)||dfs(board,i,j-1,index,word);
        visited[i][j]  = false;
        return found;
    }
}",None,"class Solution {
    private boolean visited[][];
    public boolean exist(char[][] board, String word) {
        int m=board.length, n=board[0].length;
        visited=new boolean[m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(board[i][j]==word.charAt(0)&&dfs(board,i,j,0,word)) return true;
            }
        }
        return false;

        
    }
    public boolean dfs(char[][] board,int i,int j,int index,String word){
        if(index==word.length()) return true;
        if(i<0||j<0||i>=board.length||j>=board[0].length||board[i][j]!=word.charAt(index)||visited[i][j]){
            return false;
        }
        visited[i][j]=true;
        boolean found= dfs(board,i+1,j,index+1,word)||dfs(board,i-1,j,index+1,word)||dfs(board,i,j+1,index+1,word)||dfs(board,i,j-1,index+1,word);
        visited[i][j]  = false;
        return found;
    }
}
"
2089,java,word-search,"class Solution {
    private boolean visited[][];
    public boolean exist(char[][] board, String word) {
        int m=board.length, n=board[0].length;
        visited=new boolean[m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(board[i][j]==word.charAt(0)&&dfs(board,i,j,0,word)) return true;
            }
        }
        return false;

        
    }
    public boolean dfs(char[][] board,int i,int j,int index,String word){
        if(index==word.length()) return true;
        if(i<0||j<0||i>=board.length||j>=board[0].length||board[i][j]!=word.charAt(index)||visited[i][j]){
            return false;
        }
        visited[i][j]=true;
        boolean found= dfs(board,i+1,j,index,word)||dfs(board,i-1,j,index,word)||dfs(board,i,j+1,index,word)||dfs(board,i,j-1,index,word);
        visited[i][j]  = false;
        return found;
    }
}",None,"class Solution {
    private boolean visited[][];
    public boolean exist(char[][] board, String word) {
        int m=board.length, n=board[0].length;
        visited=new boolean[m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(board[i][j]==word.charAt(0)&&dfs(board,i,j,0,word)) return true;
            }
        }
        return false;

        
    }
    public boolean dfs(char[][] board,int i,int j,int index,String word){
        if(index==word.length()) return true;
        if(i<0||j<0||i>=board.length||j>=board[0].length||board[i][j]!=word.charAt(index)||visited[i][j]){
            return false;
        }
        visited[i][j]=true;
        boolean found= dfs(board,i+1,j,index+1,word)||dfs(board,i-1,j,index+1,word)||dfs(board,i,j+1,index+1,word)||dfs(board,i,j-1,index+1,word);
        visited[i][j]  = false;
        return found;
    }
}
"
2089,java,word-search,"class Solution {
    private boolean visited[][];
    public boolean exist(char[][] board, String word) {
        int m=board.length, n=board[0].length;
        visited=new boolean[m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(board[i][j]==word.charAt(0)&&dfs(board,i,j,0,word)) return true;
            }
        }
        return false;

        
    }
    public boolean dfs(char[][] board,int i,int j,int index,String word){
        if(index==word.length()) return true;
        if(i<0||j<0||i>=board.length||j>=board[0].length||board[i][j]!=word.charAt(index)||visited[i][j]){
            return false;
        }
        visited[i][j]=true;
        boolean found= dfs(board,i+1,j,index,word)||dfs(board,i-1,j,index,word)||dfs(board,i,j+1,index,word)||dfs(board,i,j-1,index,word);
        visited[i][j]  = false;
        return found;
    }
}",None,"class Solution {
    private boolean visited[][];
    public boolean exist(char[][] board, String word) {
        int m=board.length, n=board[0].length;
        visited=new boolean[m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(board[i][j]==word.charAt(0)&&dfs(board,i,j,0,word)) return true;
            }
        }
        return false;

        
    }
    public boolean dfs(char[][] board,int i,int j,int index,String word){
        if(index==word.length()) return true;
        if(i<0||j<0||i>=board.length||j>=board[0].length||board[i][j]!=word.charAt(index)||visited[i][j]){
            return false;
        }
        visited[i][j]=true;
        boolean found= dfs(board,i+1,j,index+1,word)||dfs(board,i-1,j,index+1,word)||dfs(board,i,j+1,index+1,word)||dfs(board,i,j-1,index+1,word);
        visited[i][j]  = false;
        return found;
    }
}
"
2090,java,make-costs-of-paths-equal-in-a-binary-tree,"class Solution {
    int res = 0;
    public int minIncrements(int n, int[] cost) {
        dfs(1, cost);
        return res;
    }

    public int dfs(int i, int[] cost) {
        
        if (i >= cost.length) return 0;
        int left = dfs(i * 2, cost), right = dfs(i * 2 + 1, cost);
        res += Math.abs(left - right);
        return cost[i - 1] + Math.max(left, right);
    }
}",None,"class Solution {
    int res = 0;
    public int minIncrements(int n, int[] cost) {
        dfs(1, cost);
        return res;
    }

    public int dfs(int i, int[] cost) {
        if (i >= cost.length) return 0;
        int left = dfs(i * 2, cost), right = dfs(i * 2 + 1, cost);
        int diff = Math.abs(left - right);
        res += diff > 0 ? diff : 0;
        return cost[i - 1] + Math.max(left, right);
    }
}
"
2090,java,make-costs-of-paths-equal-in-a-binary-tree,"class Solution {
    int res = 0;
    public int minIncrements(int n, int[] cost) {
        dfs(1, cost);
        return res;
    }

    public int dfs(int i, int[] cost) {
        
        if (i >= cost.length) return 0;
        int left = dfs(i * 2, cost), right = dfs(i * 2 + 1, cost);
        res += Math.abs(left - right);
        return cost[i - 1] + Math.max(left, right);
    }
}",None,"class Solution {
    int res = 0;
    public int minIncrements(int n, int[] cost) {
        dfs(1, cost);
        return res;
    }

    public int dfs(int i, int[] cost) {
        if (i >= cost.length) return 0;
        int left = dfs(i * 2, cost), right = dfs(i * 2 + 1, cost);
        res += Math.abs(left - right);
        return Math.max(left, right) - cost[i - 1];
    }
}
"
2090,java,make-costs-of-paths-equal-in-a-binary-tree,"class Solution {
    int res = 0;
    public int minIncrements(int n, int[] cost) {
        dfs(1, cost);
        return res;
    }

    public int dfs(int i, int[] cost) {
        
        if (i >= cost.length) return 0;
        int left = dfs(i * 2, cost), right = dfs(i * 2 + 1, cost);
        res += Math.abs(left - right);
        return cost[i - 1] + Math.max(left, right);
    }
}",None,"class Solution {
    int res = 0;
    public int minIncrements(int n, int[] cost) {
        dfs(1, cost);
        return res;
    }

    public int dfs(int i, int[] cost) {
        if (i >= cost.length) return 0;
        int left = dfs(i * 2, cost), right = dfs(i * 2 + 1, cost);
        int curDiff = Math.abs(left - right);
        res += curDiff > 0 ? curDiff : 0;
        return cost[i - 1] + Math.max(left, right);
    }
}
"
2091,java,continuous-subarray-sum,"class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        HashMap<Integer,Integer> hm  = new HashMap<>();
        hm.put(0,0);
        
        int sum = 0;
        for( int  i = 0;i < nums.length; i++){
            int num = nums[i];
            sum+=num;
      
            if(hm.containsKey(sum%k)){
                if(hm.get(sum%k)  <= i )
                    return true;
            }else
                hm.put(sum%k, i+1);
            
        }
        return false;
    }
}",None,"class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        HashMap<Integer,Integer> hm  = new HashMap<>();
        hm.put(0,-1);
        
        int sum = 0;
        for( int  i = 0;i < nums.length; i++){
            int num = nums[i];
            sum+=num;
      
            if(hm.containsKey(sum%k)){
                if(i - hm.get(sum%k) >= 1)
                    return true;
            }else
                hm.put(sum%k, i);
            
        }
        return false;
    }
}
"
2091,java,continuous-subarray-sum,"class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        HashMap<Integer,Integer> hm  = new HashMap<>();
        hm.put(0,0);
        
        int sum = 0;
        for( int  i = 0;i < nums.length; i++){
            int num = nums[i];
            sum+=num;
      
            if(hm.containsKey(sum%k)){
                if(hm.get(sum%k)  <= i )
                    return true;
            }else
                hm.put(sum%k, i+1);
            
        }
        return false;
    }
}",None,"class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        HashMap<Integer,Integer> hm  = new HashMap<>();
        hm.put(0,-1);
        
        int sum = 0;
        for( int  i = 0;i < nums.length; i++){
            int num = nums[i];
            sum+=num;
      
            if(hm.containsKey(sum%k)){
                if(i - hm.get(sum%k) >= 1 )
                    return true;
            }else
                hm.put(sum%k, i);
            
        }
        return false;
    }
}
"
2091,java,continuous-subarray-sum,"class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        HashMap<Integer,Integer> hm  = new HashMap<>();
        hm.put(0,0);
        
        int sum = 0;
        for( int  i = 0;i < nums.length; i++){
            int num = nums[i];
            sum+=num;
      
            if(hm.containsKey(sum%k)){
                if(hm.get(sum%k)  <= i )
                    return true;
            }else
                hm.put(sum%k, i+1);
            
        }
        return false;
    }
}",None,"class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        HashMap<Integer,Integer> hm  = new HashMap<>();
        hm.put(0,-1);
        
        int sum = 0;
        for( int  i = 0;i < nums.length; i++){
            int num = nums[i];
            sum+=num;
      
            if(hm.containsKey(sum%k)){
                if(i - hm.get(sum%k) >= 1)
                    return true;
            }else
                hm.put(sum%k, i);
            
        }
        return false;
    }
}
"
2092,java,count-common-words-with-one-occurrence,"class Solution {
    public int countWords(String[] words1, String[] words2) {
        Map<String, Integer> map1 = new HashMap<>();
        Map<String, Integer> map2 = new HashMap<>();

        for (String s: words1){
            if(map1.containsKey(s)) map1.put(s, map1.get(s)+1);
            else map1.put(s, 1);
        }
        for (String s: words2){
            if(map2.containsKey(s)) map2.put(s, map2.get(s)+1);
            else map2.put(s, 1);
        }
        int count = 0;
        for(String i : words2){
            if(map1.get(i) == 1 && map2.getOrDefault(i,0) == 1 ){
                count++;
            }
        }

        return count;
    }
}",None,"class Solution {
    public int countWords(String[] words1, String[] words2) {
        Map<String, Integer> map1 = new HashMap<>();
        Map<String, Integer> map2 = new HashMap<>();

        for (String s: words1){
            if(map1.containsKey(s)) map1.put(s, map1.get(s)+1);
            else map1.put(s, 1);
        }
        for (String s: words2){
            if(map2.containsKey(s)) map2.put(s, map2.get(s)+1);
            else map2.put(s, 1);
        }
        int count = 0;
        for(String i : words1){
            if(map1.get(i) == 1 && map2.getOrDefault(i,0) == 1 ){
                count++;
            }
        }

        return count;
    }
}
"
2092,java,count-common-words-with-one-occurrence,"class Solution {
    public int countWords(String[] words1, String[] words2) {
        Map<String, Integer> map1 = new HashMap<>();
        Map<String, Integer> map2 = new HashMap<>();

        for (String s: words1){
            if(map1.containsKey(s)) map1.put(s, map1.get(s)+1);
            else map1.put(s, 1);
        }
        for (String s: words2){
            if(map2.containsKey(s)) map2.put(s, map2.get(s)+1);
            else map2.put(s, 1);
        }
        int count = 0;
        for(String i : words2){
            if(map1.get(i) == 1 && map2.getOrDefault(i,0) == 1 ){
                count++;
            }
        }

        return count;
    }
}",None,"class Solution {
    public int countWords(String[] words1, String[] words2) {
        Map<String, Integer> map1 = new HashMap<>();
        Map<String, Integer> map2 = new HashMap<>();

        for (String s: words1){
            map1.put(s, map1.getOrDefault(s, 0) + 1);
        }
        for (String s: words2){
            map2.put(s, map2.getOrDefault(s, 0) + 1);
        }
        int count = 0;
        for(String i : words1){
            if(map1.get(i) == 1 && map2.getOrDefault(i,0) == 1 ){
                count++;
            }
        }

        return count;
    }
}
"
2092,java,count-common-words-with-one-occurrence,"class Solution {
    public int countWords(String[] words1, String[] words2) {
        Map<String, Integer> map1 = new HashMap<>();
        Map<String, Integer> map2 = new HashMap<>();

        for (String s: words1){
            if(map1.containsKey(s)) map1.put(s, map1.get(s)+1);
            else map1.put(s, 1);
        }
        for (String s: words2){
            if(map2.containsKey(s)) map2.put(s, map2.get(s)+1);
            else map2.put(s, 1);
        }
        int count = 0;
        for(String i : words2){
            if(map1.get(i) == 1 && map2.getOrDefault(i,0) == 1 ){
                count++;
            }
        }

        return count;
    }
}",None,"class Solution {
    public int countWords(String[] words1, String[] words2) {
        Map<String, Integer> map1 = new HashMap<>();
        Map<String, Integer> map2 = new HashMap<>();

        for (String s: words1){
            if(map1.containsKey(s)) map1.put(s, map1.get(s)+1);
            else map1.put(s, 1);
        }
        for (String s: words2){
            if(map2.containsKey(s)) map2.put(s, map2.get(s)+1);
            else map2.put(s, 1);
        }
        int count = 0;
        for(String i : words2){
            if(map1.getOrDefault(i, 0) == 1 && map2.get(i) == 1 ){
                count++;
            }
        }

        return count;
    }
}
"
2093,java,n-queens,"class Solution {
    public List<List<String>> solveNQueens(int n) {
        
        char [][] board = new char[n][n];
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board.length; j++) {
                board[i][j] = '.';
            }
        }
        
        List<List<String>> ans = new ArrayList<>();
        queen(board, 0, ans);
        return ans;
    }

    static void queen(char[][] board, int row, List<List<String>> list) {

        if(row == board.length) {

            list.add(construct(board));
            return;
        }

        for (int col = 0; col < board.length - 1; col++) {
            if(isSafe(board, row, col)) {
                board[row][col] = 'Q';
                queen(board, row + 1, list);
                board[row][col] = '.';
            }
        }
    }

    static List<String> construct(char[][] board) {

        List<String> internal = new ArrayList<>();
        for (int i = 0; i < board.length; i++) {
            String row = new String(board[i]);
            internal.add(row);
        }
        return internal;
    }

    static boolean isSafe(char[][] board, int row, int col) {

        for (int i = 0; i < row; i++) {
            if(board[i][col] == 'Q') {
                return false;
            }
        }


        int maxLeft = Math.min(row, col);

        for (int i = 1; i <= maxLeft; i++) {
            if(board[row - i][col - i] == 'Q') {
                return false;
            }
        }


        int maxRight = Math.min(row, board.length - 1 - col);

        for (int i = 1; i <= maxRight; i++) {
            if(board[row - i][col + i] == 'Q') {
                return false;
            }
        }

        return true;
    }
}",None,"class Solution {
    public List<List<String>> solveNQueens(int n) {
        char[][] board = new char[n][n];

        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board.length; j++) {
                board[i][j] = '.';
            }
        }

        List<List<String>> result = new ArrayList<>();
        placeQueens(board, 0, result);
        return result;
    }

    static void placeQueens(char[][] board, int row, List<List<String>> list) {
        if (row == board.length) {
            list.add(constructBoard(board));
            return;
        }

        for (int col = 0; col < board.length; col++) {
            if (isSafe(board, row, col)) {
                board[row][col] = 'Q';
                placeQueens(board, row + 1, list);
                board[row][col] = '.';
            }
        }
    }

    static List<String> constructBoard(char[][] board) {
        List<String> internal = new ArrayList<>();

        for (int i = 0; i < board.length; i++) {
            String row = new String(board[i]);
            internal.add(row);
        }

        return internal;
    }

    static boolean isSafe(char[][] board, int row, int col) {
        for (int i = 0; i < row; i++) {
            if (board[i][col] == 'Q') {
                return false;
            }
        }

        int maxLeft = Math.min(row, col);

        for (int i = 1; i <= maxLeft; i++) {
            if (board[row - i][col - i] == 'Q') {
                return false;
            }
        }

        int maxRight = Math.min(row, board.length - 1 - col);

        for (int i = 1; i <= maxRight; i++) {
            if (board[row - i][col + i] == 'Q') {
                return false;
            }
        }

        return true;
    }
}
"
2093,java,n-queens,"class Solution {
    public List<List<String>> solveNQueens(int n) {
        
        char [][] board = new char[n][n];
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board.length; j++) {
                board[i][j] = '.';
            }
        }
        
        List<List<String>> ans = new ArrayList<>();
        queen(board, 0, ans);
        return ans;
    }

    static void queen(char[][] board, int row, List<List<String>> list) {

        if(row == board.length) {

            list.add(construct(board));
            return;
        }

        for (int col = 0; col < board.length - 1; col++) {
            if(isSafe(board, row, col)) {
                board[row][col] = 'Q';
                queen(board, row + 1, list);
                board[row][col] = '.';
            }
        }
    }

    static List<String> construct(char[][] board) {

        List<String> internal = new ArrayList<>();
        for (int i = 0; i < board.length; i++) {
            String row = new String(board[i]);
            internal.add(row);
        }
        return internal;
    }

    static boolean isSafe(char[][] board, int row, int col) {

        for (int i = 0; i < row; i++) {
            if(board[i][col] == 'Q') {
                return false;
            }
        }


        int maxLeft = Math.min(row, col);

        for (int i = 1; i <= maxLeft; i++) {
            if(board[row - i][col - i] == 'Q') {
                return false;
            }
        }


        int maxRight = Math.min(row, board.length - 1 - col);

        for (int i = 1; i <= maxRight; i++) {
            if(board[row - i][col + i] == 'Q') {
                return false;
            }
        }

        return true;
    }
}",None,"class Solution {
    public List<List<String>> solveNQueens(int n) {
        
        char [][] board = new char[n][n];
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board.length; j++) {
                board[i][j] = '.';
            }
        }
        
        List<List<String>> ans = new ArrayList<>();
        queen(board, 0, ans);
        return ans;
    }

    static void queen(char[][] board, int row, List<List<String>> list) {

        if(row == board.length) {

            list.add(construct(board));
            return;
        }

        for (int col = 0; col < board.length; col++) {
            if(isSafe(board, row, col)) {
                board[row][col] = 'Q';
                queen(board, row + 1, list);
                board[row][col] = '.';
            }
        }
    }

    static List<String> construct(char[][] board) {

        List<String> internal = new ArrayList<>();
        for (int i = 0; i < board.length; i++) {
            String row = new String(board[i]);
            internal.add(row);
        }
        return internal;
    }

    static boolean isSafe(char[][] board, int row, int col) {

        for (int i = 0; i < row; i++) {
            if(board[i][col] == 'Q') {
                return false;
            }
        }


        int maxLeft = Math.min(row, col);

        for (int i = 1; i <= maxLeft; i++) {
            if(board[row - i][col - i] == 'Q') {
                return false;
            }
        }


        int maxRight = Math.min(row, board.length - 1 - col);

        for (int i = 1; i <= maxRight; i++) {
            if(board[row - i][col + i] == 'Q') {
                return false;
            }
        }

        return true;
    }
}
"
2093,java,n-queens,"class Solution {
    public List<List<String>> solveNQueens(int n) {
        
        char [][] board = new char[n][n];
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board.length; j++) {
                board[i][j] = '.';
            }
        }
        
        List<List<String>> ans = new ArrayList<>();
        queen(board, 0, ans);
        return ans;
    }

    static void queen(char[][] board, int row, List<List<String>> list) {

        if(row == board.length) {

            list.add(construct(board));
            return;
        }

        for (int col = 0; col < board.length - 1; col++) {
            if(isSafe(board, row, col)) {
                board[row][col] = 'Q';
                queen(board, row + 1, list);
                board[row][col] = '.';
            }
        }
    }

    static List<String> construct(char[][] board) {

        List<String> internal = new ArrayList<>();
        for (int i = 0; i < board.length; i++) {
            String row = new String(board[i]);
            internal.add(row);
        }
        return internal;
    }

    static boolean isSafe(char[][] board, int row, int col) {

        for (int i = 0; i < row; i++) {
            if(board[i][col] == 'Q') {
                return false;
            }
        }


        int maxLeft = Math.min(row, col);

        for (int i = 1; i <= maxLeft; i++) {
            if(board[row - i][col - i] == 'Q') {
                return false;
            }
        }


        int maxRight = Math.min(row, board.length - 1 - col);

        for (int i = 1; i <= maxRight; i++) {
            if(board[row - i][col + i] == 'Q') {
                return false;
            }
        }

        return true;
    }
}",None,"class Solution {
    public List<List<String>> solveNQueens(int n) {
        
        char [][] board = new char[n][n];
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board.length; j++) {
                board[i][j] = '.';
            }
        }
        
        List<List<String>> ans = new ArrayList<>();
        queen(board, 0, ans);
        return ans;
    }

    static void queen(char[][] board, int row, List<List<String>> list) {

        if(row == board.length) {

            list.add(construct(board));
            return;
        }

        for (int col = 0; col < board.length; col++) {
            if(isSafe(board, row, col)) {
                board[row][col] = 'Q';
                queen(board, row + 1, list);
                board[row][col] = '.';
            }
        }
    }

    static List<String> construct(char[][] board) {

        List<String> internal = new ArrayList<>();
        for (int i = 0; i < board.length; i++) {
            String row = new String(board[i]);
            internal.add(row);
        }
        return internal;
    }

    static boolean isSafe(char[][] board, int row, int col) {

        for (int i = 0; i < row; i++) {
            if(board[i][col] == 'Q') {
                return false;
            }
        }


        int maxLeft = Math.min(row, col);

        for (int i = 1; i <= maxLeft; i++) {
            if(board[row - i][col - i] == 'Q') {
                return false;
            }
        }


        int maxRight = Math.min(row, board.length - 1 - col);

        for (int i = 1; i <= maxRight; i++) {
            if(board[row - i][col + i] == 'Q') {
                return false;
            }
        }

        return true;
    }
}
"
2094,java,next-permutation,"class Solution {
    public void nextPermutation(int[] n) {
       if(  n==null || n.length<=1)return;
		
		int i = n.length-2;

		while(i>=0 && n[i]>=n[i+1])i--;
		
		int j=n.length-1;
		
		if(i>=0) {
			while(n[j]>=n[i])j--;
			swap(n,i,j);
		}
		
		reverse(n,i+1,n.length-1);
		
		for(int p=0;p<n.length;p++) {
			System.out.println(n[p]);
		}
		
	}
	public static void swap(int n[],int i,int j) {
		int temp=n[i];
		n[i]=n[j];
		n[j]=temp;
	}
	public static void reverse(int n[],int i,int j) {
		while(i<j) {
			swap(n,i,j);
			i++;
			j--;
		}
	}
}",None,"class Solution {
    public void nextPermutation(int[] n) {
       if(n == null || n.length <= 1) return;
		
		int i = n.length-2;

		while(i >= 0 && n[i] >= n[i+1]) i--;
		
		if(i >= 0) {
			int j = n.length-1;
			while(n[j] <= n[i]) j--;
			swap(n, i, j);
		}
		
		reverse(n, i+1, n.length-1);
		
		for(int p=0;p<n.length;p++) {
			System.out.println(n[p]);
		}
		
	}
	public static void swap(int[] n, int i, int j) {
		int temp = n[i];
		n[i] = n[j];
		n[j] = temp;
	}
	public static void reverse(int[] n, int i, int j) {
		while(i < j) {
			swap(n, i, j);
			i++;
			j--;
		}
	}
}
"
2094,java,next-permutation,"class Solution {
    public void nextPermutation(int[] n) {
       if(  n==null || n.length<=1)return;
		
		int i = n.length-2;

		while(i>=0 && n[i]>=n[i+1])i--;
		
		int j=n.length-1;
		
		if(i>=0) {
			while(n[j]>=n[i])j--;
			swap(n,i,j);
		}
		
		reverse(n,i+1,n.length-1);
		
		for(int p=0;p<n.length;p++) {
			System.out.println(n[p]);
		}
		
	}
	public static void swap(int n[],int i,int j) {
		int temp=n[i];
		n[i]=n[j];
		n[j]=temp;
	}
	public static void reverse(int n[],int i,int j) {
		while(i<j) {
			swap(n,i,j);
			i++;
			j--;
		}
	}
}",None,"class Solution {
    public void nextPermutation(int[] n) {
       if(n == null || n.length <= 1) return;
		
		int i = n.length-2;

		while(i>=0 && n[i]>=n[i+1])i--;
		
		if(i>=0) {
			int j = n.length-1;
			while(n[j]<=n[i])j--;
			swap(n,i,j);
		}
		
		reverse(n,i+1,n.length-1);
		
		for(int p=0;p<n.length;p++) {
			System.out.println(n[p]);
		}
		
	}
	public static void swap(int n[],int i,int j) {
		int temp=n[i];
		n[i]=n[j];
		n[j]=temp;
	}
	public static void reverse(int n[],int i,int j) {
		while(i<j) {
			swap(n,i,j);
			i++;
			j--;
		}
	}
}
"
2094,java,next-permutation,"class Solution {
    public void nextPermutation(int[] n) {
       if(  n==null || n.length<=1)return;
		
		int i = n.length-2;

		while(i>=0 && n[i]>=n[i+1])i--;
		
		int j=n.length-1;
		
		if(i>=0) {
			while(n[j]>=n[i])j--;
			swap(n,i,j);
		}
		
		reverse(n,i+1,n.length-1);
		
		for(int p=0;p<n.length;p++) {
			System.out.println(n[p]);
		}
		
	}
	public static void swap(int n[],int i,int j) {
		int temp=n[i];
		n[i]=n[j];
		n[j]=temp;
	}
	public static void reverse(int n[],int i,int j) {
		while(i<j) {
			swap(n,i,j);
			i++;
			j--;
		}
	}
}",None,"class Solution {
    public void nextPermutation(int[] n) {
       if(n == null || n.length <= 1) return;
		
		int i = n.length-2;

		while(i >= 0 && n[i] >= n[i+1]) i--;
		
		if(i >= 0) {
			int j = n.length-1;
			while(n[j] <= n[i]) j--;
			swap(n, i, j);
		}
		
		reverse(n, i+1, n.length-1);
		
		for(int p=0;p<n.length;p++) {
			System.out.println(n[p]);
		}
	}
	public static void swap(int n[],int i,int j) {
		int temp=n[i];
		n[i]=n[j];
		n[j]=temp;
	}
	public static void reverse(int n[],int i,int j) {
		while(i < j) {
			swap(n,i,j);
			i++;
			j--;
		}
	}
}
"
2095,java,largest-3-same-digit-number-in-string,"class Solution {
    public String largestGoodInteger(String num) {
        int n=-1;
        StringBuilder sb = new StringBuilder();
        for(int i=0;i<=num.length()-2;i++){
            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){
                sb.append(num.charAt(i));
                sb.append(num.charAt(i));
                sb.append(num.charAt(i));
                if(Integer.parseInt(sb.toString())>n)
                    n=Integer.parseInt(sb.toString());
                sb.setLength(0);
            }
        }
        if(n==-1)
            return """";
        String s = Integer.toString(n);
        if(s.equals(""0""))
            return ""000"";
        return s;
    }
}",None,"class Solution {
    public String largestGoodInteger(String num) {
        int n=-1;
        StringBuilder sb = new StringBuilder();
        for(int i=0;i<=num.length()-3;i++){
            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){
                sb.append(num.charAt(i));
                sb.append(num.charAt(i));
                sb.append(num.charAt(i));
                if(Integer.parseInt(sb.toString())>n)
                    n=Integer.parseInt(sb.toString());
                sb.setLength(0);
            }
        }
        if(n==-1)
            return """";
        String s = Integer.toString(n);
        if(s.equals(""0""))
            return ""000"";
        return s;
    }
}
"
2095,java,largest-3-same-digit-number-in-string,"class Solution {
    public String largestGoodInteger(String num) {
        int n=-1;
        StringBuilder sb = new StringBuilder();
        for(int i=0;i<=num.length()-2;i++){
            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){
                sb.append(num.charAt(i));
                sb.append(num.charAt(i));
                sb.append(num.charAt(i));
                if(Integer.parseInt(sb.toString())>n)
                    n=Integer.parseInt(sb.toString());
                sb.setLength(0);
            }
        }
        if(n==-1)
            return """";
        String s = Integer.toString(n);
        if(s.equals(""0""))
            return ""000"";
        return s;
    }
}",None,"class Solution {
    public String largestGoodInteger(String num) {
        int n=-1;
        StringBuilder sb = new StringBuilder();
        for(int i=0;i<=num.length()-3;i++){
            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){
                sb.append(num.charAt(i));
                sb.append(num.charAt(i));
                sb.append(num.charAt(i));
                if(Integer.parseInt(sb.toString())>n)
                    n=Integer.parseInt(sb.toString());
                sb.setLength(0);
            }
        }
        if(n==-1)
            return """";
        String s = Integer.toString(n);
        if(s.equals(""0""))
            return ""000"";
        return s;
    }
}
"
2095,java,largest-3-same-digit-number-in-string,"class Solution {
    public String largestGoodInteger(String num) {
        int n=-1;
        StringBuilder sb = new StringBuilder();
        for(int i=0;i<=num.length()-2;i++){
            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){
                sb.append(num.charAt(i));
                sb.append(num.charAt(i));
                sb.append(num.charAt(i));
                if(Integer.parseInt(sb.toString())>n)
                    n=Integer.parseInt(sb.toString());
                sb.setLength(0);
            }
        }
        if(n==-1)
            return """";
        String s = Integer.toString(n);
        if(s.equals(""0""))
            return ""000"";
        return s;
    }
}",None,"class Solution {
    public String largestGoodInteger(String num) {
        int n=-1;
        StringBuilder sb = new StringBuilder();
        for(int i=0;i<=num.length()-3;i++){
            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){
                sb.append(num.charAt(i));
                sb.append(num.charAt(i));
                sb.append(num.charAt(i));
                if(Integer.parseInt(sb.toString())>n)
                    n=Integer.parseInt(sb.toString());
                sb.setLength(0);
            }
        }
        if(n==-1)
            return """";
        String s = Integer.toString(n);
        if(s.equals(""0""))
            return ""000"";
        return s;
    }
}
"
2096,java,matrix-block-sum,"class Solution {
    public int[][] matrixBlockSum(int[][] mat, int k) {
        int[][] answer = new int[mat.length][mat[0].length];

        for(int i = 0; i < mat.length; i++) {
            for(int j = 0; j < mat[0].length; j++) {
                int rowStart = i-k;
                int rowEnd = i+k;
                int colStart = j-k;
                int colEnd = j+k;

                if(rowStart < 0) {
                    rowStart = 0;
                }

                if(rowEnd >= mat.length) {
                    rowEnd = mat.length - 1;
                }

                if(colStart < 0) {
                    colStart = 0;
                }

                if(colEnd >= mat[0].length) {
                    colEnd = mat[0].length - 1;
                }

                answer[i][j] = blockSum(mat, rowStart, rowEnd, colStart, colEnd);
            }
        }

        return answer;
    }

    private int blockSum(int[][] mat, int rowStart, int rowEnd, int colStart, int colEnd) {
        int sum = 0;

        for(int i = rowStart; i <= rowEnd; i++) {
            for(int j = colStart; j < colEnd; j++) {
                sum += mat[i][j];
            }
        }
        return sum;
    }
}",None,"class Solution {
    public int[][] matrixBlockSum(int[][] mat, int k) {
        int[][] answer = new int[mat.length][mat[0].length];

        for(int i = 0; i < mat.length; i++) {
            for(int j = 0; j < mat[0].length; j++) {
                int rowStart = Math.max(0, i-k);
                int rowEnd = Math.min(mat.length-1, i+k);
                int colStart = Math.max(0, j-k);
                int colEnd = Math.min(mat[0].length-1, j+k);

                for(int row = rowStart; row <= rowEnd; row++) {
                    for(int col = colStart; col <= colEnd; col++) {
                        answer[i][j] += mat[row][col];
                    }
                }
            }
        }

        return answer;
    }
}
"
2096,java,matrix-block-sum,"class Solution {
    public int[][] matrixBlockSum(int[][] mat, int k) {
        int[][] answer = new int[mat.length][mat[0].length];

        for(int i = 0; i < mat.length; i++) {
            for(int j = 0; j < mat[0].length; j++) {
                int rowStart = i-k;
                int rowEnd = i+k;
                int colStart = j-k;
                int colEnd = j+k;

                if(rowStart < 0) {
                    rowStart = 0;
                }

                if(rowEnd >= mat.length) {
                    rowEnd = mat.length - 1;
                }

                if(colStart < 0) {
                    colStart = 0;
                }

                if(colEnd >= mat[0].length) {
                    colEnd = mat[0].length - 1;
                }

                answer[i][j] = blockSum(mat, rowStart, rowEnd, colStart, colEnd);
            }
        }

        return answer;
    }

    private int blockSum(int[][] mat, int rowStart, int rowEnd, int colStart, int colEnd) {
        int sum = 0;

        for(int i = rowStart; i <= rowEnd; i++) {
            for(int j = colStart; j < colEnd; j++) {
                sum += mat[i][j];
            }
        }
        return sum;
    }
}",None,"class Solution {
    public int[][] matrixBlockSum(int[][] mat, int k) {
        int[][] answer = new int[mat.length][mat[0].length];

        for(int i = 0; i < mat.length; i++) {
            for(int j = 0; j < mat[0].length; j++) {
                int rowStart = Math.max(0, i-k);
                int rowEnd = Math.min(mat.length-1, i+k);
                int colStart = Math.max(0, j-k);
                int colEnd = Math.min(mat[0].length-1, j+k);

                answer[i][j] = blockSum(mat, rowStart, rowEnd, colStart, colEnd);
            }
        }

        return answer;
    }

    private int blockSum(int[][] mat, int rowStart, int rowEnd, int colStart, int colEnd) {
        int sum = 0;

        for(int i = rowStart; i <= rowEnd; i++) {
            for(int j = colStart; j <= colEnd; j++) {
                sum += mat[i][j];
            }
        }
        return sum;
    }
}
"
2096,java,matrix-block-sum,"class Solution {
    public int[][] matrixBlockSum(int[][] mat, int k) {
        int[][] answer = new int[mat.length][mat[0].length];

        for(int i = 0; i < mat.length; i++) {
            for(int j = 0; j < mat[0].length; j++) {
                int rowStart = i-k;
                int rowEnd = i+k;
                int colStart = j-k;
                int colEnd = j+k;

                if(rowStart < 0) {
                    rowStart = 0;
                }

                if(rowEnd >= mat.length) {
                    rowEnd = mat.length - 1;
                }

                if(colStart < 0) {
                    colStart = 0;
                }

                if(colEnd >= mat[0].length) {
                    colEnd = mat[0].length - 1;
                }

                answer[i][j] = blockSum(mat, rowStart, rowEnd, colStart, colEnd);
            }
        }

        return answer;
    }

    private int blockSum(int[][] mat, int rowStart, int rowEnd, int colStart, int colEnd) {
        int sum = 0;

        for(int i = rowStart; i <= rowEnd; i++) {
            for(int j = colStart; j < colEnd; j++) {
                sum += mat[i][j];
            }
        }
        return sum;
    }
}",None,"class Solution {
    public int[][] matrixBlockSum(int[][] mat, int k) {
        int[][] answer = new int[mat.length][mat[0].length];

        for(int i = 0; i < mat.length; i++) {
            for(int j = 0; j < mat[0].length; j++) {
                int rowStart = Math.max(0, i-k);
                int rowEnd = Math.min(mat.length-1, i+k);
                int colStart = Math.max(0, j-k);
                int colEnd = Math.min(mat[0].length-1, j+k);

                for(int row = rowStart; row <= rowEnd; row++) {
                    for(int col = colStart; col <= colEnd; col++) {
                        answer[i][j] += mat[row][col];
                    }
                }
            }
        }

        return answer;
    }
}
"
2097,java,special-array-with-x-elements-greater-than-or-equal-x,"class Solution {
    public int countPossibility(int []nums,int x){
        int cnt=0;
        for(int n:nums) if(n>x) cnt++;
        return cnt;
    }
    public int specialArray(int[] nums) {
        int maxi=Integer.MIN_VALUE,start=1,mid=0;
        for(int x:nums) maxi=Math.max(maxi,x);
        int end = maxi;
        while(start<=end){
            mid = (start+end)/2;
            int check = countPossibility(nums,mid);
            if(check==mid) return mid;
            if(mid<check) start=mid+1;
            else end=mid-1;
        }
        return -1;
    }
}",None,"class Solution {
    public int countPossibility(int []nums,int x){
        int cnt=0;
        for(int n:nums) if(n>=x) cnt++;
        return cnt;
    }
    public int specialArray(int[] nums) {
        int maxi=Integer.MIN_VALUE,start=1,mid=0;
        for(int x:nums) maxi=Math.max(maxi,x);
        int end = maxi;
        while(start<=end){
            mid = start + (end - start) / 2;
            int check = countPossibility(nums,mid);
            if(check==mid) return mid;
            if(mid<check) start=mid+1;
            else end=mid-1;
        }
        return -1;
    }
}
"
2097,java,special-array-with-x-elements-greater-than-or-equal-x,"class Solution {
    public int countPossibility(int []nums,int x){
        int cnt=0;
        for(int n:nums) if(n>x) cnt++;
        return cnt;
    }
    public int specialArray(int[] nums) {
        int maxi=Integer.MIN_VALUE,start=1,mid=0;
        for(int x:nums) maxi=Math.max(maxi,x);
        int end = maxi;
        while(start<=end){
            mid = (start+end)/2;
            int check = countPossibility(nums,mid);
            if(check==mid) return mid;
            if(mid<check) start=mid+1;
            else end=mid-1;
        }
        return -1;
    }
}",None,"class Solution {
    public int countPossibility(int []nums,int x){
        int cnt=0;
        for(int n:nums) if(n>=x) cnt++;
        return cnt;
    }
    public int specialArray(int[] nums) {
        int maxi=Integer.MIN_VALUE,start=1,mid=0;
        for(int x:nums) maxi=Math.max(maxi,x);
        int end = maxi;
        while(start<=end){
            mid = (start+end)/2;
            int check = countPossibility(nums,mid);
            if(check==mid) return mid;
            if(mid<check) start=mid+1;
            else end=mid-1;
        }
        return -1;
    }
}
"
2097,java,special-array-with-x-elements-greater-than-or-equal-x,"class Solution {
    public int countPossibility(int []nums,int x){
        int cnt=0;
        for(int n:nums) if(n>x) cnt++;
        return cnt;
    }
    public int specialArray(int[] nums) {
        int maxi=Integer.MIN_VALUE,start=1,mid=0;
        for(int x:nums) maxi=Math.max(maxi,x);
        int end = maxi;
        while(start<=end){
            mid = (start+end)/2;
            int check = countPossibility(nums,mid);
            if(check==mid) return mid;
            if(mid<check) start=mid+1;
            else end=mid-1;
        }
        return -1;
    }
}",None,"class Solution {
    public int countPossibility(int []nums,int x){
        int cnt=0;
        for(int n:nums) if(n>=x) cnt++;
        return cnt;
    }
    public int specialArray(int[] nums) {
        int maxi=Integer.MIN_VALUE,start=1,mid=0;
        for(int x:nums) maxi=Math.max(maxi,x);
        int end = maxi;
        while(start<=end){
            mid = start + (end - start) / 2;
            int check = countPossibility(nums,mid);
            if(check==mid) return mid;
            if(mid<check) start=mid+1;
            else end=mid-1;
        }
        return -1;
    }
}
"
2098,java,number-of-provinces,"class DSU:
    def __init__(self, n):
        self.par = list(range(n))
        self.rank = [1] * n
        self.size = 1
    def find(self, u):
        if u != self.par[u]:
            self.par[u] = self.find(self.par[u])
        return self.par[u]
    def union(self, u, v):
        uu, vv = self.find(u), self.find(v)
        if uu == vv:
            return False
        if self.rank[uu] > self.rank[vv]:
            self.par[vv] = uu
        elif self.rank[vv] > self.rank[uu]:
            self.par[uu] = vv
        else:
            self.par[uu] = vv
            self.rank[vv] += 1
        self.size += 1
        return True

class Solution:
    def isConnected(self, u, v, G):
        return G[u][v] == 1

    def findCircleNum(self, G: List[List[int]]) -> int:
        n = len(G)
        uf = DSU(n)
        if not G:
            return 0
        for u in range(n):
            for v in range(n):
                if self.isConnected(u, v, G):
                    uf.union(u, v)
        return len(set([uf.find(i) for i in range(n)]))",None,"class DSU:
    def __init__(self, n):
        self.par = list(range(n))
        self.rank = [1] * n
        self.size = 1
    def find(self, u):
        if u != self.par[u]:
            self.par[u] = self.find(self.par[u])
        return self.par[u]
    def union(self, u, v):
        uu, vv = self.find(u), self.find(v)
        if uu == vv:
            return False
        if self.rank[uu] > self.rank[vv]:
            self.par[vv] = uu
        else:
            self.par[uu] = vv
        self.size += 1
        return True

class Solution:
    def isConnected(self, u, v, G):
        return G[u][v] == 1

    def findCircleNum(self, G: List[List[int]]) -> int:
        n = len(G)
        uf = DSU(n)
        if not G:
            return 0
        for u in range(n):
            for v in range(n):
                if u != v and G[u][v] == 1:
                    uf.union(u, v)
        return len(set([uf.find(i) for i in range(n)]))
"
2098,java,number-of-provinces,"class DSU:
    def __init__(self, n):
        self.par = list(range(n))
        self.rank = [1] * n
        self.size = 1
    def find(self, u):
        if u != self.par[u]:
            self.par[u] = self.find(self.par[u])
        return self.par[u]
    def union(self, u, v):
        uu, vv = self.find(u), self.find(v)
        if uu == vv:
            return False
        if self.rank[uu] > self.rank[vv]:
            self.par[vv] = uu
        elif self.rank[vv] > self.rank[uu]:
            self.par[uu] = vv
        else:
            self.par[uu] = vv
            self.rank[vv] += 1
        self.size += 1
        return True

class Solution:
    def isConnected(self, u, v, G):
        return G[u][v] == 1

    def findCircleNum(self, G: List[List[int]]) -> int:
        n = len(G)
        uf = DSU(n)
        if not G:
            return 0
        for u in range(n):
            for v in range(n):
                if self.isConnected(u, v, G):
                    uf.union(u, v)
        return len(set([uf.find(i) for i in range(n)]))",None,"class DSU:
    def __init__(self, n):
        self.par = list(range(n))
        self.rank = [1] * n
        self.size = 1
    def find(self, u):
        if u != self.par[u]:
            self.par[u] = self.find(self.par[u])
        return self.par[u]
    def union(self, u, v):
        uu, vv = self.find(u), self.find(v)
        if uu == vv:
            return False
        if self.rank[uu] > self.rank[vv]:
            self.par[vv] = uu
        else:
            self.par[uu] = vv
        self.rank[vv] += self.rank[uu]
        self.size += 1
        return True

class Solution:
    def isConnected(self, u, v, G):
        return G[u][v] == 1

    def findCircleNum(self, G: List[List[int]]) -> int:
        n = len(G)
        uf = DSU(n)
        if not G:
            return 0
        for u in range(n):
            for v in range(u+1, n):
                if self.isConnected(u, v, G):
                    uf.union(u, v)
        return len(set([uf.find(i) for i in range(n)]))
"
2098,java,number-of-provinces,"class DSU:
    def __init__(self, n):
        self.par = list(range(n))
        self.rank = [1] * n
        self.size = 1
    def find(self, u):
        if u != self.par[u]:
            self.par[u] = self.find(self.par[u])
        return self.par[u]
    def union(self, u, v):
        uu, vv = self.find(u), self.find(v)
        if uu == vv:
            return False
        if self.rank[uu] > self.rank[vv]:
            self.par[vv] = uu
        elif self.rank[vv] > self.rank[uu]:
            self.par[uu] = vv
        else:
            self.par[uu] = vv
            self.rank[vv] += 1
        self.size += 1
        return True

class Solution:
    def isConnected(self, u, v, G):
        return G[u][v] == 1

    def findCircleNum(self, G: List[List[int]]) -> int:
        n = len(G)
        uf = DSU(n)
        if not G:
            return 0
        for u in range(n):
            for v in range(n):
                if self.isConnected(u, v, G):
                    uf.union(u, v)
        return len(set([uf.find(i) for i in range(n)]))",None,"class DSU:
    def __init__(self, n):
        self.par = list(range(n))
        self.rank = [1] * n
        self.size = 1
    def find(self, u):
        if u != self.par[u]:
            self.par[u] = self.find(self.par[u])
        return self.par[u]
    def union(self, u, v):
        uu, vv = self.find(u), self.find(v)
        if uu == vv:
            return False
        if self.rank[uu] > self.rank[vv]:
            self.par[vv] = uu
        else:
            self.par[uu] = vv
        self.size += 1
        return True

class Solution:
    def isConnected(self, u, v, G):
        return G[u][v] == 1

    def findCircleNum(self, G: List[List[int]]) -> int:
        n = len(G)
        uf = DSU(n)
        if not G:
            return 0
        for u in range(n):
            for v in range(n):
                if u != v and G[u][v] == 1:
                    uf.union(u, v)
        return len(set([uf.find(i) for i in range(n)]))
"
2099,java,number-of-senior-citizens,"class Solution {
    public int countSeniors(String[] details) {

     int count=0;
     for(int i=0;i<details.length;i++)
     {
         int a=details[i].charAt(11)-'0';
         a*=10;
         a+=details[i].charAt(12)-'0';
         if(a<60)
         {
             count++;
         }
     }
     return count;    
    }
}",None,"class Solution {
    public int countSeniors(String[] details) {

     int count=0;
     for(int i=0;i<details.length;i++)
     {
         int a=details[i].charAt(11)-'0';
         a*=10;
         a+=(details[i].charAt(12)-'0');
         if(a>60)
         {
             count++;
         }
     }
     return count;    
    }
}
"
2099,java,number-of-senior-citizens,"class Solution {
    public int countSeniors(String[] details) {

     int count=0;
     for(int i=0;i<details.length;i++)
     {
         int a=details[i].charAt(11)-'0';
         a*=10;
         a+=details[i].charAt(12)-'0';
         if(a<60)
         {
             count++;
         }
     }
     return count;    
    }
}",None,"class Solution {
    public int countSeniors(String[] details) {

     int count=0;
     for(int i=0;i<details.length;i++)
     {
         int a=details[i].charAt(11)-'0';
         a*=10;
         a+=(details[i].charAt(12)-'0');
         if(a>60)
         {
             count++;
         }
     }
     return count;    
    }
}
"
2099,java,number-of-senior-citizens,"class Solution {
    public int countSeniors(String[] details) {

     int count=0;
     for(int i=0;i<details.length;i++)
     {
         int a=details[i].charAt(11)-'0';
         a*=10;
         a+=details[i].charAt(12)-'0';
         if(a<60)
         {
             count++;
         }
     }
     return count;    
    }
}",None,"class Solution {
    public int countSeniors(String[] details) {

     int count=0;
     for(int i=0;i<details.length;i++)
     {
         int a=details[i].charAt(11)-'0';
         a*=10;
         a+=details[i].charAt(12)-'0';
         if(a>60)
         {
             count++;
         }
     }
     return count;    
    }
}
"
2100,java,find-nearest-point-that-has-the-same-x-or-y-coordinate,"class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        int minManh = Integer.MAX_VALUE;
        int indMin = -1;
        for (int i = 0; i < points.length; i++)
        {
            int tmpManh = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
            if ((x == points[i][0] && y == points[i][1]) && (tmpManh < minManh))
            {
                minManh = tmpManh;
                indMin = i;
            }
        }
        return indMin;
    }
}",None,"class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        int minManh = Integer.MAX_VALUE;
        int indMin = -1;
        for (int i = 0; i < points.length; i++)
        {
            int tmpManh = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
            if (x == points[i][0] || y == points[i][1])
            {
                if (tmpManh < minManh)
                {
                    minManh = tmpManh;
                    indMin = i;
                }
            }
        }
        return indMin;
    }
}
"
2100,java,find-nearest-point-that-has-the-same-x-or-y-coordinate,"class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        int minManh = Integer.MAX_VALUE;
        int indMin = -1;
        for (int i = 0; i < points.length; i++)
        {
            int tmpManh = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
            if ((x == points[i][0] && y == points[i][1]) && (tmpManh < minManh))
            {
                minManh = tmpManh;
                indMin = i;
            }
        }
        return indMin;
    }
}",None,"class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        int minManh = Integer.MAX_VALUE;
        int indMin = -1;
        for (int i = 0; i < points.length; i++)
        {
            int tmpManh = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
            if (x == points[i][0] || y == points[i][1])
            {
                if (tmpManh < minManh)
                {
                    minManh = tmpManh;
                    indMin = i;
                }
            }
        }
        return indMin;
    }
}
"
2100,java,find-nearest-point-that-has-the-same-x-or-y-coordinate,"class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        int minManh = Integer.MAX_VALUE;
        int indMin = -1;
        for (int i = 0; i < points.length; i++)
        {
            int tmpManh = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
            if ((x == points[i][0] && y == points[i][1]) && (tmpManh < minManh))
            {
                minManh = tmpManh;
                indMin = i;
            }
        }
        return indMin;
    }
}",None,"class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        int minManh = Integer.MAX_VALUE;
        int indMin = -1;
        for (int i = 0; i < points.length; i++)
        {
            int tmpManh = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
            if (x == points[i][0] || y == points[i][1])
            {
                if (tmpManh < minManh)
                {
                    minManh = tmpManh;
                    indMin = i;
                }
            }
        }
        return indMin;
    }
}
"
2101,java,count-and-say,"class Solution {
    String convert(String s)
    {
        char prevCh = s.charAt(0);
        int prevCount = 1;
        StringBuilder ans = new StringBuilder();
        for (int i = 1; i <= s.length(); i++)
        {
            char currCh = s.charAt(i);
            if (currCh != prevCh)   
            {
                ans.append(Integer.toString(prevCount));
                ans.append(prevCh);
                prevCount = 1;
                prevCh = currCh;
            }
            else prevCount++;
        }
        ans.append(Integer.toString(prevCount));
        ans.append(prevCh);
        return ans.toString();
    }
    public String countAndSay(int n) 
    {
        String prevStr = ""1"";
        for (int i = 2; i <= n; i++)
        {
            String cnsNum = convert(prevStr);
            prevStr = cnsNum;
        }
        return prevStr;
        
        
    }
}",None,"class Solution {
    String convert(String s)
    {
        char prevCh = s.charAt(0);
        int prevCount = 1;
        StringBuilder ans = new StringBuilder();
        for (int i = 1; i < s.length(); i++)
        {
            char currCh = s.charAt(i);
            if (currCh != prevCh)   
            {
                ans.append(Integer.toString(prevCount));
                ans.append(prevCh);
                prevCount = 1;
                prevCh = currCh;
            }
            else prevCount++;
        }
        ans.append(Integer.toString(prevCount));
        ans.append(prevCh);
        return ans.toString();
    }
    public String countAndSay(int n) 
    {
        String prevStr = ""1"";
        for (int i = 2; i <= n; i++)
        {
            String cnsNum = convert(prevStr);
            prevStr = cnsNum;
        }
        return prevStr;
        
    }
}
"
2101,java,count-and-say,"class Solution {
    String convert(String s)
    {
        char prevCh = s.charAt(0);
        int prevCount = 1;
        StringBuilder ans = new StringBuilder();
        for (int i = 1; i <= s.length(); i++)
        {
            char currCh = s.charAt(i);
            if (currCh != prevCh)   
            {
                ans.append(Integer.toString(prevCount));
                ans.append(prevCh);
                prevCount = 1;
                prevCh = currCh;
            }
            else prevCount++;
        }
        ans.append(Integer.toString(prevCount));
        ans.append(prevCh);
        return ans.toString();
    }
    public String countAndSay(int n) 
    {
        String prevStr = ""1"";
        for (int i = 2; i <= n; i++)
        {
            String cnsNum = convert(prevStr);
            prevStr = cnsNum;
        }
        return prevStr;
        
        
    }
}",None,"class Solution {
    String convert(String s)
    {
        char prevCh = s.charAt(0);
        int prevCount = 1;
        StringBuilder ans = new StringBuilder();
        for (int i = 1; i < s.length(); i++)
        {
            char currCh = s.charAt(i);
            if (currCh != prevCh)   
            {
                ans.append(Integer.toString(prevCount));
                ans.append(prevCh);
                prevCount = 1;
                prevCh = currCh;
            }
            else prevCount++;
        }
        ans.append(Integer.toString(prevCount));
        ans.append(prevCh);
        return ans.toString();
    }
    public String countAndSay(int n) 
    {
        String prevStr = ""1"";
        for (int i = 2; i <= n; i++)
        {
            String cnsNum = convert(prevStr);
            prevStr = cnsNum;
        }
        return prevStr;
    }
}
"
2101,java,count-and-say,"class Solution {
    String convert(String s)
    {
        char prevCh = s.charAt(0);
        int prevCount = 1;
        StringBuilder ans = new StringBuilder();
        for (int i = 1; i <= s.length(); i++)
        {
            char currCh = s.charAt(i);
            if (currCh != prevCh)   
            {
                ans.append(Integer.toString(prevCount));
                ans.append(prevCh);
                prevCount = 1;
                prevCh = currCh;
            }
            else prevCount++;
        }
        ans.append(Integer.toString(prevCount));
        ans.append(prevCh);
        return ans.toString();
    }
    public String countAndSay(int n) 
    {
        String prevStr = ""1"";
        for (int i = 2; i <= n; i++)
        {
            String cnsNum = convert(prevStr);
            prevStr = cnsNum;
        }
        return prevStr;
        
        
    }
}",None,"class Solution {
    String convert(String s)
    {
        char prevCh = s.charAt(0);
        int prevCount = 1;
        StringBuilder ans = new StringBuilder();
        for (int i = 1; i < s.length(); i++)
        {
            char currCh = s.charAt(i);
            if (currCh != prevCh)   
            {
                ans.append(Integer.toString(prevCount));
                ans.append(prevCh);
                prevCount = 1;
                prevCh = currCh;
            }
            else prevCount++;
        }
        ans.append(Integer.toString(prevCount));
        ans.append(prevCh);
        return ans.toString();
    }
    public String countAndSay(int n) 
    {
        String prevStr = ""1"";
        for (int i = 2; i <= n; i++)
        {
            String cnsNum = convert(prevStr);
            prevStr = cnsNum;
        }
        return prevStr;
    }
}
"
2102,java,sort-array-by-increasing-frequency,"class Solution {
    public int[] frequencySort(int[] a) {
	ArrayList<Integer>al=new ArrayList<>();
	    for(int i=0;i<a.length;i++){
	        al.add(a[i]);
	    }
	    
TreeSet<Integer>t2=new TreeSet<>(al);
int k[]=new int[t2.size()];
int c[]=new int[t2.size()];
int x=0;
	    for(int i:t2){
	        c[x]=i;
	k[x]=Collections.frequency(al,i);
	x++;
	    }
	    for(int i=0;i<k.length;i++){
	        for(int j=i+1;j<k.length;j++){
	            if(k[i]<=k[j]){
	                int t=k[i];
	                k[i]=k[j];
	                k[j]=t;
	                int t1=c[i];
	                c[i]=c[j];
	                c[j]=t1;
	            }
	        }    
	    }
			int ans[]=new int[a.length];
			int r=0;
	    for(int i=0;i<k.length;i++){
	        int l=k[i];
	        while(l>0){
	        ans[r]=c[i];
			r++;
	        l--;
	        }
	    }
return ans;
    }
}",None,"class Solution {
    public int[] frequencySort(int[] a) {
	ArrayList<Integer>al=new ArrayList<>();
	    for(int i=0;i<a.length;i++){
	        al.add(a[i]);
	    }
	    
TreeMap<Integer, Integer>t2=new TreeMap<>(Collections.reverseOrder());
int k[]=new int[t2.size()];
int c[]=new int[t2.size()];
int x=0;
	    for(int i:t2.keySet()){
	        c[x]=i;
	k[x]=t2.get(i);
	x++;
	    }
	    for(int i=0;i<k.length;i++){
	        for(int j=i+1;j<k.length;j++){
	            if(k[i]<k[j]){
	                int t=k[i];
	                k[i]=k[j];
	                k[j]=t;
	                int t1=c[i];
	                c[i]=c[j];
	                c[j]=t1;
	            }
	        }    
	    }
			int ans[]=new int[a.length];
			int r=0;
	    for(int i=0;i<k.length;i++){
	        int l=k[i];
	        while(l>0){
	        ans[r]=c[i];
			r++;
	        l--;
	        }
	    }
return ans;
    }
}
"
2102,java,sort-array-by-increasing-frequency,"class Solution {
    public int[] frequencySort(int[] a) {
	ArrayList<Integer>al=new ArrayList<>();
	    for(int i=0;i<a.length;i++){
	        al.add(a[i]);
	    }
	    
TreeSet<Integer>t2=new TreeSet<>(al);
int k[]=new int[t2.size()];
int c[]=new int[t2.size()];
int x=0;
	    for(int i:t2){
	        c[x]=i;
	k[x]=Collections.frequency(al,i);
	x++;
	    }
	    for(int i=0;i<k.length;i++){
	        for(int j=i+1;j<k.length;j++){
	            if(k[i]<=k[j]){
	                int t=k[i];
	                k[i]=k[j];
	                k[j]=t;
	                int t1=c[i];
	                c[i]=c[j];
	                c[j]=t1;
	            }
	        }    
	    }
			int ans[]=new int[a.length];
			int r=0;
	    for(int i=0;i<k.length;i++){
	        int l=k[i];
	        while(l>0){
	        ans[r]=c[i];
			r++;
	        l--;
	        }
	    }
return ans;
    }
}",None,"class Solution {
    public int[] frequencySort(int[] a) {
	ArrayList<Integer>al=new ArrayList<>();
	    for(int i=0;i<a.length;i++){
	        al.add(a[i]);
	    }
	    
TreeMap<Integer, Integer>t2=new TreeMap<>(Comparator.reverseOrder());
	    for(int i:al){
	        t2.put(i, t2.getOrDefault(i, 0)+1);
	    }
			int ans[]=new int[a.length];
			int r=0;
	    for(Map.Entry<Integer, Integer> entry : t2.entrySet()){
	        int count = entry.getValue();
	        int num = entry.getKey();
	        while(count > 0){
	        ans[r]=num;
			r++;
	        count--;
	        }
	    }
return ans;
    }
}
"
2102,java,sort-array-by-increasing-frequency,"class Solution {
    public int[] frequencySort(int[] a) {
	ArrayList<Integer>al=new ArrayList<>();
	    for(int i=0;i<a.length;i++){
	        al.add(a[i]);
	    }
	    
TreeSet<Integer>t2=new TreeSet<>(al);
int k[]=new int[t2.size()];
int c[]=new int[t2.size()];
int x=0;
	    for(int i:t2){
	        c[x]=i;
	k[x]=Collections.frequency(al,i);
	x++;
	    }
	    for(int i=0;i<k.length;i++){
	        for(int j=i+1;j<k.length;j++){
	            if(k[i]<=k[j]){
	                int t=k[i];
	                k[i]=k[j];
	                k[j]=t;
	                int t1=c[i];
	                c[i]=c[j];
	                c[j]=t1;
	            }
	        }    
	    }
			int ans[]=new int[a.length];
			int r=0;
	    for(int i=0;i<k.length;i++){
	        int l=k[i];
	        while(l>0){
	        ans[r]=c[i];
			r++;
	        l--;
	        }
	    }
return ans;
    }
}",None,"class Solution {
    public int[] frequencySort(int[] a) {
	ArrayList<Integer>al=new ArrayList<>();
	    for(int i=0;i<a.length;i++){
	        al.add(a[i]);
	    }
	    
TreeMap<Integer, Integer>t2=new TreeMap<>(Collections.reverseOrder());
	    for(int i:al){
	        t2.put(i, t2.getOrDefault(i, 0)+1);
	    }
			int ans[]=new int[a.length];
			int r=0;
	    for(int i:t2.keySet()){
	        int l=t2.get(i);
	        while(l>0){
	        ans[r]=i;
			r++;
	        l--;
	        }
	    }
return ans;
    }
}
"
2103,java,similar-string-groups,"class Solution {
    boolean isSimilar(String str1,String str2)
    {
        int count=0;
        for(int i=0;i<str1.length();i++)
        {
            if(str1.charAt(i)!=str2.charAt(i))
            {
                count++;
                if(count>2)
                {
                    return false;
                }
            }
            
        }
        return count==0 || count==2;
    }
    void dfs(String curr, String []strs, Set<String> visited)
    {
        if(visited.contains(curr))
        {
            return;
        }
        visited.add(curr);
        for(int i=0;i<=strs.length;i++)
        {
         if(isSimilar(curr,strs[i]))
         {
             dfs(strs[i],strs,visited);
         }   
        }
    }
    public int numSimilarGroups(String[] strs)
    {
        int count =0;

        if(strs==null ||strs.length ==0)
        {
            return 0;
        }

        Set<String> visited = new HashSet<>();
        for(String s:strs)
        {
            if(!visited.contains(s))
            {
                dfs(s,strs,visited);
                count++;
            }
        }
        return count;
    }
}",None,"class Solution {
    boolean isSimilar(String str1,String str2)
    {
        int count=0;
        for(int i=0;i<str1.length();i++)
        {
            if(str1.charAt(i)!=str2.charAt(i))
            {
                count++;
                if(count>2)
                {
                    return false;
                }
            }
            
        }
        return count==0 || count==2;
    }
    void dfs(String curr, String[] strs, Set<String> visited)
    {
        if(visited.contains(curr))
        {
            return;
        }
        visited.add(curr);
        for(int i=0;i<strs.length;i++) // Change the condition from i<=strs.length to i<strs.length
        {
         if(isSimilar(curr,strs[i]))
         {
             dfs(strs[i],strs,visited);
         }   
        }
    }
    public int numSimilarGroups(String[] strs)
    {
        int count =0;

        if(strs==null ||strs.length ==0)
        {
            return 0;
        }

        Set<String> visited = new HashSet<>();
        for(String s:strs)
        {
            if(!visited.contains(s))
            {
                dfs(s,strs,visited);
                count++;
            }
        }
        return count;
    }
}
"
2103,java,similar-string-groups,"class Solution {
    boolean isSimilar(String str1,String str2)
    {
        int count=0;
        for(int i=0;i<str1.length();i++)
        {
            if(str1.charAt(i)!=str2.charAt(i))
            {
                count++;
                if(count>2)
                {
                    return false;
                }
            }
            
        }
        return count==0 || count==2;
    }
    void dfs(String curr, String []strs, Set<String> visited)
    {
        if(visited.contains(curr))
        {
            return;
        }
        visited.add(curr);
        for(int i=0;i<=strs.length;i++)
        {
         if(isSimilar(curr,strs[i]))
         {
             dfs(strs[i],strs,visited);
         }   
        }
    }
    public int numSimilarGroups(String[] strs)
    {
        int count =0;

        if(strs==null ||strs.length ==0)
        {
            return 0;
        }

        Set<String> visited = new HashSet<>();
        for(String s:strs)
        {
            if(!visited.contains(s))
            {
                dfs(s,strs,visited);
                count++;
            }
        }
        return count;
    }
}",None,"class Solution {
    boolean isSimilar(String str1, String str2) {
        int count = 0;
        for (int i = 0; i < str1.length(); i++) {
            if (str1.charAt(i) != str2.charAt(i)) {
                count++;
                if (count > 2) {
                    return false;
                }
            }
        }
        return count == 0 || count == 2;
    }

    void dfs(String curr, String[] strs, Set<String> visited) {
        if (visited.contains(curr)) {
            return;
        }
        visited.add(curr);
        for (int i = 0; i < strs.length; i++) {
            if (isSimilar(curr, strs[i])) {
                dfs(strs[i], strs, visited);
            }
        }
    }

    public int numSimilarGroups(String[] strs) {
        int count = 0;

        if (strs == null || strs.length == 0) {
            return 0;
        }

        Set<String> visited = new HashSet<>();
        for (String s : strs) {
            if (!visited.contains(s)) {
                dfs(s, strs, visited);
                count++;
            }
        }
        return count;
    }
}
"
2103,java,similar-string-groups,"class Solution {
    boolean isSimilar(String str1,String str2)
    {
        int count=0;
        for(int i=0;i<str1.length();i++)
        {
            if(str1.charAt(i)!=str2.charAt(i))
            {
                count++;
                if(count>2)
                {
                    return false;
                }
            }
            
        }
        return count==0 || count==2;
    }
    void dfs(String curr, String []strs, Set<String> visited)
    {
        if(visited.contains(curr))
        {
            return;
        }
        visited.add(curr);
        for(int i=0;i<=strs.length;i++)
        {
         if(isSimilar(curr,strs[i]))
         {
             dfs(strs[i],strs,visited);
         }   
        }
    }
    public int numSimilarGroups(String[] strs)
    {
        int count =0;

        if(strs==null ||strs.length ==0)
        {
            return 0;
        }

        Set<String> visited = new HashSet<>();
        for(String s:strs)
        {
            if(!visited.contains(s))
            {
                dfs(s,strs,visited);
                count++;
            }
        }
        return count;
    }
}",None,"class Solution {
    boolean isSimilar(String str1,String str2)
    {
        int count=0;
        for(int i=0;i<str1.length();i++)
        {
            if(str1.charAt(i)!=str2.charAt(i))
            {
                count++;
                if(count>2)
                {
                    return false;
                }
            }
            
        }
        return count==0 || count==2;
    }
    void dfs(String curr, String []strs, Set<String> visited)
    {
        if(visited.contains(curr))
        {
            return;
        }
        visited.add(curr);
        for(int i=0;i<strs.length;i++) // Change the condition here from i<=strs.length to i<strs.length
        {
         if(isSimilar(curr,strs[i]))
         {
             dfs(strs[i],strs,visited);
         }   
        }
    }
    public int numSimilarGroups(String[] strs)
    {
        int count =0;

        if(strs==null ||strs.length ==0)
        {
            return 0;
        }

        Set<String> visited = new HashSet<>();
        for(String s:strs)
        {
            if(!visited.contains(s))
            {
                dfs(s,strs,visited);
                count++;
            }
        }
        return count;
    }
}
"
2104,java,remove-element,"class Solution {
    public int removeElement(int[] nums, int val) {
        int i = 0;
        for (int j = 0; j < nums.length; j++) {
            if (nums[j] == val) {
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                i++;
            }
        }
        return i;
    }
}",None,"class Solution {
    public int removeElement(int[] nums, int val) {
        int i = 0;
        for (int j = 0; j < nums.length; j++) {
            if (nums[j] != val) {
                nums[i] = nums[j];
                i++;
            }
        }
        return i;
    }
}
"
2104,java,remove-element,"class Solution {
    public int removeElement(int[] nums, int val) {
        int i = 0;
        for (int j = 0; j < nums.length; j++) {
            if (nums[j] == val) {
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                i++;
            }
        }
        return i;
    }
}",None,"class Solution {
    public int removeElement(int[] nums, int val) {
        int i = 0;
        for (int j = 0; j < nums.length; j++) {
            if (nums[j] != val) {
                nums[i] = nums[j];
                i++;
            }
        }
        return i;
    }
}
"
2104,java,remove-element,"class Solution {
    public int removeElement(int[] nums, int val) {
        int i = 0;
        for (int j = 0; j < nums.length; j++) {
            if (nums[j] == val) {
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                i++;
            }
        }
        return i;
    }
}",None,"class Solution {
    public int removeElement(int[] nums, int val) {
        int i = 0;
        for (int j = 0; j < nums.length; j++) {
            if (nums[j] != val) {
                nums[i] = nums[j];
                i++;
            }
        }
        return i;
    }
}
"
2105,java,max-area-of-island,"class Solution {
    public int max = 0;
    public int sum = 0;
    public int maxAreaOfIsland(int[][] grid) {
        for(int i = 0; i<grid.length;i++)
        {
            for(int j = 0; j<grid[i].length;j++)
            {
                if(grid[i][j]!=0)
                {
                    sum = 0; 
                    dfs(grid,i,j);
                    max  = Math.max(max,sum);
                }
            }
        }

        return max;
    }

    private void dfs(int[][] grid ,int r ,int c)
    {
        if(r>=grid.length || c>=grid[0].length || r<0|| c<0 || grid[r][c]==1)
        {
            return ;
        }

        sum++;
        grid[r][c] = 0;
        dfs(grid,r,c+1);
        dfs(grid,r,c-1);
        dfs(grid,r+1,c);
        dfs(grid,r-1,c);
    }
}",None,"class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int max = 0;
        for(int i = 0; i<grid.length;i++)
        {
            for(int j = 0; j<grid[i].length;j++)
            {
                if(grid[i][j]!=0)
                {
                    int sum = 0; 
                    dfs(grid,i,j, sum);
                    max  = Math.max(max,sum);
                }
            }
        }

        return max;
    }

    private void dfs(int[][] grid ,int r ,int c,int sum)
    {
        if(r>=grid.length || c>=grid[0].length || r<0|| c<0 || grid[r][c]==0)
        {
            return ;
        }

        sum++;
        grid[r][c] = 0;
        dfs(grid,r,c+1,sum);
        dfs(grid,r,c-1,sum);
        dfs(grid,r+1,c,sum);
        dfs(grid,r-1,c,sum);
    }
}
"
2105,java,max-area-of-island,"class Solution {
    public int max = 0;
    public int sum = 0;
    public int maxAreaOfIsland(int[][] grid) {
        for(int i = 0; i<grid.length;i++)
        {
            for(int j = 0; j<grid[i].length;j++)
            {
                if(grid[i][j]!=0)
                {
                    sum = 0; 
                    dfs(grid,i,j);
                    max  = Math.max(max,sum);
                }
            }
        }

        return max;
    }

    private void dfs(int[][] grid ,int r ,int c)
    {
        if(r>=grid.length || c>=grid[0].length || r<0|| c<0 || grid[r][c]==1)
        {
            return ;
        }

        sum++;
        grid[r][c] = 0;
        dfs(grid,r,c+1);
        dfs(grid,r,c-1);
        dfs(grid,r+1,c);
        dfs(grid,r-1,c);
    }
}",None,"class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int max = 0;
        for(int i = 0; i<grid.length;i++)
        {
            for(int j = 0; j<grid[i].length;j++)
            {
                if(grid[i][j]==1)
                {
                    int sum = dfs(grid,i,j);
                    max  = Math.max(max,sum);
                }
            }
        }

        return max;
    }

    private int dfs(int[][] grid ,int r ,int c)
    {
        if(r>=grid.length || c>=grid[0].length || r<0|| c<0 || grid[r][c]==0)
        {
            return 0;
        }

        grid[r][c] = 0;
        int sum = 1;
        sum += dfs(grid,r,c+1);
        sum += dfs(grid,r,c-1);
        sum += dfs(grid,r+1,c);
        sum += dfs(grid,r-1,c);

        return sum;
    }
}
"
2105,java,max-area-of-island,"class Solution {
    public int max = 0;
    public int sum = 0;
    public int maxAreaOfIsland(int[][] grid) {
        for(int i = 0; i<grid.length;i++)
        {
            for(int j = 0; j<grid[i].length;j++)
            {
                if(grid[i][j]!=0)
                {
                    sum = 0; 
                    dfs(grid,i,j);
                    max  = Math.max(max,sum);
                }
            }
        }

        return max;
    }

    private void dfs(int[][] grid ,int r ,int c)
    {
        if(r>=grid.length || c>=grid[0].length || r<0|| c<0 || grid[r][c]==1)
        {
            return ;
        }

        sum++;
        grid[r][c] = 0;
        dfs(grid,r,c+1);
        dfs(grid,r,c-1);
        dfs(grid,r+1,c);
        dfs(grid,r-1,c);
    }
}",None,"class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int max = 0;
        for(int i = 0; i<grid.length;i++)
        {
            for(int j = 0; j<grid[i].length;j++)
            {
                if(grid[i][j]==1)
                {
                    int sum = dfs(grid,i,j);
                    max  = Math.max(max,sum);
                }
            }
        }

        return max;
    }

    private int dfs(int[][] grid ,int r ,int c)
    {
        if(r>=grid.length || c>=grid[0].length || r<0|| c<0 || grid[r][c]==0)
        {
            return 0;
        }

        grid[r][c] = 0;
        int count = 1;
        count += dfs(grid,r,c+1);
        count += dfs(grid,r,c-1);
        count += dfs(grid,r+1,c);
        count += dfs(grid,r-1,c);

        return count;
    }
}
"
2106,java,minimum-distance-to-the-target-element,"class Solution {
    public int getMinDistance(int[] nums, int target, int start) {
     int n = nums.length;
     int min = Integer.MAX_VALUE;
     for(int i=0;i<n;i++){
         if(nums[i]!=target){ 
          if(Math.abs(i-start)<min){
              min = Math.abs(i-start);
          }   
         }
     }
     return min;   
    }
}",None,"class Solution {
    public int getMinDistance(int[] nums, int target, int start) {
     int n = nums.length;
     int min = Integer.MAX_VALUE;
     int idx = -1;
     for(int i=0;i<n;i++){
         if(nums[i]==target){
             if(Math.abs(i-start)<min){
                 min = Math.abs(i-start);
                 idx = i;
             } else if (Math.abs(i-start) == min && i < idx) {
                 min = Math.abs(i-start);
                 idx = i;
             }
         }
     }
     return min;
    }
}
"
2106,java,minimum-distance-to-the-target-element,"class Solution {
    public int getMinDistance(int[] nums, int target, int start) {
     int n = nums.length;
     int min = Integer.MAX_VALUE;
     for(int i=0;i<n;i++){
         if(nums[i]!=target){ 
          if(Math.abs(i-start)<min){
              min = Math.abs(i-start);
          }   
         }
     }
     return min;   
    }
}",None,"class Solution {
    public int getMinDistance(int[] nums, int target, int start) {
     int n = nums.length;
     int min = Integer.MAX_VALUE;
     int targetIdx = -1;
     for(int i=0;i<n;i++){
         if(nums[i]==target){
             targetIdx = i;
             break;
         }
     }
     if(targetIdx != -1){
         min = Math.abs(targetIdx - start);
         for(int i=0;i<n;i++){
             if(nums[i]==target){
                 int dist = Math.abs(i - start);
                 if(dist<min) min = dist;
             }
         }
     }
     return min;   
    }
}
"
2106,java,minimum-distance-to-the-target-element,"class Solution {
    public int getMinDistance(int[] nums, int target, int start) {
     int n = nums.length;
     int min = Integer.MAX_VALUE;
     for(int i=0;i<n;i++){
         if(nums[i]!=target){ 
          if(Math.abs(i-start)<min){
              min = Math.abs(i-start);
          }   
         }
     }
     return min;   
    }
}",None,"class Solution {
    public int getMinDistance(int[] nums, int target, int start) {
     int n = nums.length;
     int min = Integer.MAX_VALUE;
     int min_index = -1;
     for(int i=0;i<n;i++){
         if(nums[i]==target){
              min = Math.abs(i-start);
              min_index = i;
         }
     }
     if(min_index != -1) return min;
     else {
         for(int i=0;i<n;i++){
             if(nums[i]!=target){ 
              if(Math.abs(i-start)<min){
                  min = Math.abs(i-start);
              }   
             }
         }
         return min;
     }
    }
}
"
2107,java,most-frequent-subtree-sum,"class Solution{
    public int[] findFrequentTreeSum(TreeNode root) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        helper(root, map);
        List<Integer> list = new ArrayList();
        
        int max = (Collections.max(map.values()));
        for(Map.Entry<Integer, Integer> entry : map.entrySet()){
            if(entry.getValue() == max){
                list.add(entry.getKey());
            }
        }
        
        int[] arr = new int[list.size()];
        for(int i=0; i<=list.size(); i++){
            arr[i] = list.get(i);
        }
        
        return arr;
    }
    public int helper(TreeNode root, Map<Integer, Integer> map){
        if(root==null) return 0;
        int left = helper(root.left, map);
        int right = helper(root.right, map);
        
        int sum = root.val+left+right;
        if(map.containsKey(sum)){
            map.put(sum, map.get(sum)+1);
        }else{
            map.put(sum, 1);
        }
        
        return sum;
    }
}",None,"class Solution{
    public int[] findFrequentTreeSum(TreeNode root) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        helper(root, map);
        List<Integer> list = new ArrayList();
        
        int max = Collections.max(map.values());
        for(Map.Entry<Integer, Integer> entry : map.entrySet()){
            if(entry.getValue() == max){
                list.add(entry.getKey());
            }
        }
        
        int[] arr = new int[list.size()];
        for(int i=0; i<list.size(); i++){
            arr[i] = list.get(i);
        }
        
        return arr;
    }
    public int helper(TreeNode root, Map<Integer, Integer> map){
        if(root==null) return 0;
        int left = helper(root.left, map);
        int right = helper(root.right, map);
        
        int sum = root.val+left+right;
        if(map.containsKey(sum)){
            map.put(sum, map.get(sum)+1);
        }else{
            map.put(sum, 1);
        }
        
        return sum;
    }
}
"
2107,java,most-frequent-subtree-sum,"class Solution{
    public int[] findFrequentTreeSum(TreeNode root) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        helper(root, map);
        List<Integer> list = new ArrayList();
        
        int max = (Collections.max(map.values()));
        for(Map.Entry<Integer, Integer> entry : map.entrySet()){
            if(entry.getValue() == max){
                list.add(entry.getKey());
            }
        }
        
        int[] arr = new int[list.size()];
        for(int i=0; i<=list.size(); i++){
            arr[i] = list.get(i);
        }
        
        return arr;
    }
    public int helper(TreeNode root, Map<Integer, Integer> map){
        if(root==null) return 0;
        int left = helper(root.left, map);
        int right = helper(root.right, map);
        
        int sum = root.val+left+right;
        if(map.containsKey(sum)){
            map.put(sum, map.get(sum)+1);
        }else{
            map.put(sum, 1);
        }
        
        return sum;
    }
}",None,"class Solution{
    public int[] findFrequentTreeSum(TreeNode root) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        helper(root, map);
        List<Integer> list = new ArrayList();
        
        int max = Collections.max(map.values());
        for(Map.Entry<Integer, Integer> entry : map.entrySet()){
            if(entry.getValue() == max){
                list.add(entry.getKey());
            }
        }
        
        int[] arr = new int[list.size()];
        for(int i=0; i<list.size(); i++){
            arr[i] = list.get(i);
        }
        
        return arr;
    }
    public int helper(TreeNode root, Map<Integer, Integer> map){
        if(root==null) return 0;
        int left = helper(root.left, map);
        int right = helper(root.right, map);
        
        int sum = root.val+left+right;
        if(map.containsKey(sum)){
            map.put(sum, map.get(sum)+1);
        }else{
            map.put(sum, 1);
        }
        
        return sum;
    }
}
"
2107,java,most-frequent-subtree-sum,"class Solution{
    public int[] findFrequentTreeSum(TreeNode root) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        helper(root, map);
        List<Integer> list = new ArrayList();
        
        int max = (Collections.max(map.values()));
        for(Map.Entry<Integer, Integer> entry : map.entrySet()){
            if(entry.getValue() == max){
                list.add(entry.getKey());
            }
        }
        
        int[] arr = new int[list.size()];
        for(int i=0; i<=list.size(); i++){
            arr[i] = list.get(i);
        }
        
        return arr;
    }
    public int helper(TreeNode root, Map<Integer, Integer> map){
        if(root==null) return 0;
        int left = helper(root.left, map);
        int right = helper(root.right, map);
        
        int sum = root.val+left+right;
        if(map.containsKey(sum)){
            map.put(sum, map.get(sum)+1);
        }else{
            map.put(sum, 1);
        }
        
        return sum;
    }
}",None,"class Solution{
    public int[] findFrequentTreeSum(TreeNode root) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        helper(root, map);
        List<Integer> list = new ArrayList();
        
        int max = Collections.max(map.values());
        for(Map.Entry<Integer, Integer> entry : map.entrySet()){
            if(entry.getValue() == max){
                list.add(entry.getKey());
            }
        }
        
        int[] arr = new int[list.size()];
        for(int i=0; i<list.size(); i++){
            arr[i] = list.get(i);
        }
        
        return arr;
    }
    public int helper(TreeNode root, Map<Integer, Integer> map){
        if(root==null) return 0;
        int left = helper(root.left, map);
        int right = helper(root.right, map);
        
        int sum = root.val+left+right;
        if(map.containsKey(sum)){
            map.put(sum, map.get(sum)+1);
        }else{
            map.put(sum, 1);
        }
        
        return sum;
    }
}
"
2108,java,maximum-value-at-a-given-index-in-a-bounded-array,"class Solution {
    public int maxValue(int n, int index, int maxSum) {
        int left = 0, right = maxSum - n;

        while (left < right) {
            int middle = (left + right + 1) / 2;
            if (isPossible(n, index, maxSum - n, middle))
                right = middle;
            else
                left = middle - 1;
        }
        return left + 1;
    }

    private boolean isPossible(int n, int index, int maxSum, int value) {
        int leftValue = Math.max(value - index, 0);
        int rightValue = Math.max(value - ((n - 1) - index), 0);

        long sumBefore = (long) (value + leftValue) * (value - leftValue + 1) / 2;
        long sumAfter = (long) (value + rightValue) * (value - rightValue + 1) / 2;

        return sumBefore + sumAfter - value <= maxSum;
    }
}",None,"class Solution {
    public int maxValue(int n, int index, int maxSum) {
        int left = 0, right = maxSum - n;

        while (left < right) {
            int middle = (left + right + 1) / 2;
            if (isPossible(n, index, maxSum - n, middle))
                left = middle;
            else
                right = middle - 1;
        }
        return left;
    }

    private boolean isPossible(int n, int index, int maxSum, int value) {
        int leftValue = Math.max(value - index, 0);
        int rightValue = Math.max(value - (n - index - 1), 0);

        long sumBefore = (long) (value + leftValue) * (value - leftValue + 1) / 2;
        long sumAfter = (long) (value + rightValue) * (value - rightValue + 1) / 2;

        return sumBefore + sumAfter - value <= maxSum;
    }
}
"
2108,java,maximum-value-at-a-given-index-in-a-bounded-array,"class Solution {
    public int maxValue(int n, int index, int maxSum) {
        int left = 0, right = maxSum - n;

        while (left < right) {
            int middle = (left + right + 1) / 2;
            if (isPossible(n, index, maxSum - n, middle))
                right = middle;
            else
                left = middle - 1;
        }
        return left + 1;
    }

    private boolean isPossible(int n, int index, int maxSum, int value) {
        int leftValue = Math.max(value - index, 0);
        int rightValue = Math.max(value - ((n - 1) - index), 0);

        long sumBefore = (long) (value + leftValue) * (value - leftValue + 1) / 2;
        long sumAfter = (long) (value + rightValue) * (value - rightValue + 1) / 2;

        return sumBefore + sumAfter - value <= maxSum;
    }
}",None,"class Solution {
    public int maxValue(int n, int index, int maxSum) {
        int left = 0, right = maxSum - n;

        while (left < right) {
            int middle = (left + right + 1) / 2;
            if (isPossible(n, index, maxSum - n, middle))
                left = middle;
            else
                right = middle - 1;
        }
        return left;
    }

    private boolean isPossible(int n, int index, int maxSum, int value) {
        int leftValue = Math.max(value - index, 0);
        int rightValue = Math.max(value - (n - 1 - index), 0);

        long sumBefore = (long) (value + leftValue) * (value - leftValue + 1) / 2;
        long sumAfter = (long) (value + rightValue) * (value - rightValue + 1) / 2;

        return sumBefore + sumAfter - value <= maxSum;
    }
}
"
2108,java,maximum-value-at-a-given-index-in-a-bounded-array,"class Solution {
    public int maxValue(int n, int index, int maxSum) {
        int left = 0, right = maxSum - n;

        while (left < right) {
            int middle = (left + right + 1) / 2;
            if (isPossible(n, index, maxSum - n, middle))
                right = middle;
            else
                left = middle - 1;
        }
        return left + 1;
    }

    private boolean isPossible(int n, int index, int maxSum, int value) {
        int leftValue = Math.max(value - index, 0);
        int rightValue = Math.max(value - ((n - 1) - index), 0);

        long sumBefore = (long) (value + leftValue) * (value - leftValue + 1) / 2;
        long sumAfter = (long) (value + rightValue) * (value - rightValue + 1) / 2;

        return sumBefore + sumAfter - value <= maxSum;
    }
}",None,"class Solution {
    public int maxValue(int n, int index, int maxSum) {
        int left = 0, right = maxSum - n;

        while (left < right) {
            int middle = (left + right + 1) / 2;
            if (isPossible(n, index, maxSum - n, middle))
                left = middle;
            else
                right = middle - 1;
        }
        return left;
    }

    private boolean isPossible(int n, int index, int maxSum, int value) {
        int leftValue = Math.max(value - index, 0);
        int rightValue = Math.max(value - (n - 1 - index), 0);

        long sumBefore = (long) (value + leftValue) * (value - leftValue + 1) / 2;
        long sumAfter = (long) (value + rightValue) * (value - rightValue + 1) / 2;

        return sumBefore + sumAfter <= maxSum;
    }
}
"
2109,java,clone-graph,"/*
class Node {
    public int val;
    public List<Node> neighbors;
    public Node() {
        val = 0;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val) {
        val = _val;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val, ArrayList<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}
*/

class Solution {
    public void dfs(Node node, HashMap<Node, Node> dict)
    {
        for (Node nd : node.neighbors) {
            if (!dict.containsKey(nd))
                dict.put(nd, new Node(nd.val));
            dict.get(node).neighbors.add(dict.get(nd));
        }
        for (Node nd : node.neighbors)
        {
            if (dict.get(nd).neighbors.size() == 1)
                dfs(nd, dict);
        }
    }
    public Node cloneGraph(Node node) {
        HashMap<Node, Node> dict = new HashMap<>();
        if (node != null) {
            dict.put(node, new Node(node.val));
            dfs(node, dict);
            return dict.get(node);
        }
        return null;
    }
}",None,"/*
class Node {
    public int val;
    public List<Node> neighbors;
    public Node() {
        val = 0;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val) {
        val = _val;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val, ArrayList<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}
*/

class Solution {
    public void dfs(Node node, HashMap<Node, Node> dict)
    {
        for (Node nd : node.neighbors) {
            if (!dict.containsKey(nd))
                dict.put(nd, new Node(nd.val));
            dict.get(node).neighbors.add(dict.get(nd));
        }
        for (Node nd : node.neighbors)
        {
            if (dict.get(nd).neighbors.size() == 1)
                dfs(nd, dict);
        }
    }
    public Node cloneGraph(Node node) {
        HashMap<Node, Node> dict = new HashMap<>();
        if (node != null) {
            dict.put(node, new Node(node.val));
            dfs(node, dict);
            return dict.get(node);
        }
        return null;
    }
}
"
2109,java,clone-graph,"/*
class Node {
    public int val;
    public List<Node> neighbors;
    public Node() {
        val = 0;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val) {
        val = _val;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val, ArrayList<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}
*/

class Solution {
    public void dfs(Node node, HashMap<Node, Node> dict)
    {
        for (Node nd : node.neighbors) {
            if (!dict.containsKey(nd))
                dict.put(nd, new Node(nd.val));
            dict.get(node).neighbors.add(dict.get(nd));
        }
        for (Node nd : node.neighbors)
        {
            if (dict.get(nd).neighbors.size() == 1)
                dfs(nd, dict);
        }
    }
    public Node cloneGraph(Node node) {
        HashMap<Node, Node> dict = new HashMap<>();
        if (node != null) {
            dict.put(node, new Node(node.val));
            dfs(node, dict);
            return dict.get(node);
        }
        return null;
    }
}",None,"class Node {
    public int val;
    public List<Node> neighbors;
    public Node(int _val) {
        val = _val;
        neighbors = new ArrayList<Node>();
    }
}

class Solution {
    public void dfs(Node node, HashMap<Node, Node> dict)
    {
        for (Node nd : node.neighbors) {
            if (!dict.containsKey(nd))
                dict.put(nd, new Node(nd.val));
            dict.get(node).neighbors.add(dict.get(nd));
        }
        for (Node nd : node.neighbors)
        {
            if (dict.get(nd).neighbors.size() == 1)
                dfs(nd, dict);
        }
    }
    public Node cloneGraph(Node node) {
        HashMap<Node, Node> dict = new HashMap<>();
        if (node != null) {
            dict.put(node, new Node(node.val));
            dfs(node, dict);
            return dict.get(node);
        }
        return null;
    }
}
"
2109,java,clone-graph,"/*
class Node {
    public int val;
    public List<Node> neighbors;
    public Node() {
        val = 0;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val) {
        val = _val;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val, ArrayList<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}
*/

class Solution {
    public void dfs(Node node, HashMap<Node, Node> dict)
    {
        for (Node nd : node.neighbors) {
            if (!dict.containsKey(nd))
                dict.put(nd, new Node(nd.val));
            dict.get(node).neighbors.add(dict.get(nd));
        }
        for (Node nd : node.neighbors)
        {
            if (dict.get(nd).neighbors.size() == 1)
                dfs(nd, dict);
        }
    }
    public Node cloneGraph(Node node) {
        HashMap<Node, Node> dict = new HashMap<>();
        if (node != null) {
            dict.put(node, new Node(node.val));
            dfs(node, dict);
            return dict.get(node);
        }
        return null;
    }
}",None,"/*
class Node {
    public int val;
    public List<Node> neighbors;
    public Node() {
        val = 0;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val) {
        val = _val;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val, ArrayList<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}
*/

class Solution {
    public void dfs(Node node, HashMap<Node, Node> dict)
    {
        for (Node nd : node.neighbors) {
            if (!dict.containsKey(nd))
                dict.put(nd, new Node(nd.val));
            dict.get(node).neighbors.add(dict.get(nd));
        }
        for (Node nd : node.neighbors)
        {
            if (dict.get(nd).neighbors.size() == 1)
                dfs(nd, dict);
        }
    }
    public Node cloneGraph(Node node) {
        HashMap<Node, Node> dict = new HashMap<>();
        if (node != null) {
            dict.put(node, new Node(node.val));
            dfs(node, dict);
            return dict.get(node);
        }
        return null;
    }
}
"
2110,java,maximum-number-of-integers-to-choose-from-a-range-i,"class Solution {
    public int maxCount(int[] banned, int n, int maxSum) {

        Set<Integer> banSet = new HashSet<>();
        for (int num : banned) {
            banSet.add(num);
        }

        int count = 0;
        int sum = 0;

        for (int i = 1; i <= n; i++) {

            if (!banSet.contains(i) && (sum + i < maxSum)) {
                count++;
                sum += i;
            }
        }
    return count;
    }
}",None,"class Solution {
    public int maxCount(int[] banned, int n, int maxSum) {

        Set<Integer> banSet = new HashSet<>();
        for (int num : banned) {
            banSet.add(num);
        }

        int count = 0;
        int sum = 0;

        for (int i = 1; i <= n; i++) {

            if (!banSet.contains(i) && (sum + i <= maxSum)) {
                count++;
                sum += i;
            }
        }
    return count;
    }
}
"
2110,java,maximum-number-of-integers-to-choose-from-a-range-i,"class Solution {
    public int maxCount(int[] banned, int n, int maxSum) {

        Set<Integer> banSet = new HashSet<>();
        for (int num : banned) {
            banSet.add(num);
        }

        int count = 0;
        int sum = 0;

        for (int i = 1; i <= n; i++) {

            if (!banSet.contains(i) && (sum + i < maxSum)) {
                count++;
                sum += i;
            }
        }
    return count;
    }
}",None,"class Solution {
    public int maxCount(int[] banned, int n, int maxSum) {

        Set<Integer> banSet = new HashSet<>();
        for (int num : banned) {
            banSet.add(num);
        }

        int count = 0;
        int sum = 0;

        for (int i = 1; i <= n; i++) {

            if (!banSet.contains(i) && (sum + i <= maxSum)) { // change the operator from < to <=
                count++;
                sum += i;
            }
        }
    return count;
    }
}
"
2110,java,maximum-number-of-integers-to-choose-from-a-range-i,"class Solution {
    public int maxCount(int[] banned, int n, int maxSum) {

        Set<Integer> banSet = new HashSet<>();
        for (int num : banned) {
            banSet.add(num);
        }

        int count = 0;
        int sum = 0;

        for (int i = 1; i <= n; i++) {

            if (!banSet.contains(i) && (sum + i < maxSum)) {
                count++;
                sum += i;
            }
        }
    return count;
    }
}",None,"class Solution {
    public int maxCount(int[] banned, int n, int maxSum) {

        Set<Integer> banSet = new HashSet<>();
        for (int num : banned) {
            banSet.add(num);
        }

        int count = 0;
        int sum = 0;

        for (int i = 1; i <= n; i++) {

            if (!banSet.contains(i) && (sum + i <= maxSum)) {
                count++;
                sum += i;
            }
        }
    return count;
    }
}
"
2111,java,word-ladder-ii,"class Solution {
    String b;

    HashMap < String, Integer > mpp;

    List < List < String >> ans;
    private void dfs(String word, List < String > seq) {

        if (word.equals(b)) {

            List < String > dup = new ArrayList < > (seq);
            Collections.reverse(dup);
            ans.add(dup);
            return;
        }
        int steps = mpp.get(word);
        int sz = word.length();

        for (int i = 0; i < sz; i++) {

            for (char ch = 'a'; ch <= 'y'; ch++) { 
                char replacedCharArray[] = word.toCharArray();
                replacedCharArray[i] = ch;
                String replacedWord = new String(replacedCharArray);
                if (mpp.containsKey(replacedWord) &&
                    mpp.get(replacedWord) + 1 == steps) {

                    seq.add(replacedWord);
                    dfs(replacedWord, seq);

                    seq.remove(seq.size() - 1);
                }
            }
        }
    }
    public List < List < String >> findLadders(String beginWord, String endWord,
        List < String > wordList) {

        Set < String > st = new HashSet < String > ();
        int len = wordList.size();
        for (int i = 0; i < len; i++) {
            st.add(wordList.get(i));
        }
        Queue < String > q = new LinkedList < > ();
        b = beginWord;
        q.add(beginWord);
        mpp = new HashMap < > ();
        mpp.put(beginWord, 1);
        int sizee = beginWord.length();
        st.remove(beginWord);
        while (!q.isEmpty()) {
            String word = q.peek();
            int steps = mpp.get(word);
            q.remove();

            if (word.equals(endWord)) break;

            for (int i = 0; i < sizee; i++) {

                for (char ch = 'a'; ch <= 'y'; ch++) { 
                    char replacedCharArray[] = word.toCharArray();
                    replacedCharArray[i] = ch;
                    String replacedWord = new String(replacedCharArray);
                    if (st.contains(replacedWord) == true) {
                        q.add(replacedWord);
                        st.remove(replacedWord);
                        mpp.put(replacedWord, steps + 1);
                    }
                }
            }
        }
        ans = new ArrayList < > ();

        if (mpp.containsKey(endWord) == true) {
            List < String > seq = new ArrayList < > ();
            seq.add(endWord);
            dfs(endWord, seq);
        }
        return ans;
    }
}",None,"class Solution {
    String b;

    HashMap < String, Integer > mpp;

    List < List < String >> ans;
    private void dfs(String word, List < String > seq) {

        if (word.equals(b)) {

            List < String > dup = new ArrayList < > (seq);
            Collections.reverse(dup);
            ans.add(dup);
            return;
        }
        int steps = mpp.get(word);
        int sz = word.length();

        for (int i = 0; i < sz; i++) {

            for (char ch = 'a'; ch <= 'z'; ch++) {  // changed 'y' to 'z'
                char replacedCharArray[] = word.toCharArray();
                replacedCharArray[i] = ch;
                String replacedWord = new String(replacedCharArray);
                if (mpp.containsKey(replacedWord) &&
                    mpp.get(replacedWord) + 1 == steps) {

                    seq.add(replacedWord);
                    dfs(replacedWord, seq);

                    seq.remove(seq.size() - 1);
                }
            }
        }
    }
    public List < List < String >> findLadders(String beginWord, String endWord,
        List < String > wordList) {

        Set < String > st = new HashSet < String > ();
        int len = wordList.size();
        for (int i = 0; i < len; i++) {
            st.add(wordList.get(i));
        }
        Queue < String > q = new LinkedList < > ();
        b = beginWord;
        q.add(beginWord);
        mpp = new HashMap < > ();
        mpp.put(beginWord, 1);
        int sizee = beginWord.length();
        st.remove(beginWord);
        while (!q.isEmpty()) {
            String word = q.peek();
            int steps = mpp.get(word);
            q.remove();

            if (word.equals(endWord)) break;

            for (int i = 0; i < sizee; i++) {

                for (char ch = 'a'; ch <= 'z'; ch++) {  // changed 'y' to 'z'
                    char replacedCharArray[] = word.toCharArray();
                    replacedCharArray[i] = ch;
                    String replacedWord = new String(replacedCharArray);
                    if (st.contains(replacedWord) == true) {
                        q.add(replacedWord);
                        st.remove(replacedWord);
                        mpp.put(replacedWord, steps + 1);
                    }
                }
            }
        }
        ans = new ArrayList < > ();

        if (mpp.containsKey(endWord) == true) {
            List < String > seq = new ArrayList < > ();
            seq.add(endWord);
            dfs(endWord, seq);
        }
        return ans;
    }
}
"
2111,java,word-ladder-ii,"class Solution {
    String b;

    HashMap < String, Integer > mpp;

    List < List < String >> ans;
    private void dfs(String word, List < String > seq) {

        if (word.equals(b)) {

            List < String > dup = new ArrayList < > (seq);
            Collections.reverse(dup);
            ans.add(dup);
            return;
        }
        int steps = mpp.get(word);
        int sz = word.length();

        for (int i = 0; i < sz; i++) {

            for (char ch = 'a'; ch <= 'y'; ch++) { 
                char replacedCharArray[] = word.toCharArray();
                replacedCharArray[i] = ch;
                String replacedWord = new String(replacedCharArray);
                if (mpp.containsKey(replacedWord) &&
                    mpp.get(replacedWord) + 1 == steps) {

                    seq.add(replacedWord);
                    dfs(replacedWord, seq);

                    seq.remove(seq.size() - 1);
                }
            }
        }
    }
    public List < List < String >> findLadders(String beginWord, String endWord,
        List < String > wordList) {

        Set < String > st = new HashSet < String > ();
        int len = wordList.size();
        for (int i = 0; i < len; i++) {
            st.add(wordList.get(i));
        }
        Queue < String > q = new LinkedList < > ();
        b = beginWord;
        q.add(beginWord);
        mpp = new HashMap < > ();
        mpp.put(beginWord, 1);
        int sizee = beginWord.length();
        st.remove(beginWord);
        while (!q.isEmpty()) {
            String word = q.peek();
            int steps = mpp.get(word);
            q.remove();

            if (word.equals(endWord)) break;

            for (int i = 0; i < sizee; i++) {

                for (char ch = 'a'; ch <= 'y'; ch++) { 
                    char replacedCharArray[] = word.toCharArray();
                    replacedCharArray[i] = ch;
                    String replacedWord = new String(replacedCharArray);
                    if (st.contains(replacedWord) == true) {
                        q.add(replacedWord);
                        st.remove(replacedWord);
                        mpp.put(replacedWord, steps + 1);
                    }
                }
            }
        }
        ans = new ArrayList < > ();

        if (mpp.containsKey(endWord) == true) {
            List < String > seq = new ArrayList < > ();
            seq.add(endWord);
            dfs(endWord, seq);
        }
        return ans;
    }
}",None,"class Solution {
    String b;

    HashMap < String, Integer > mpp;

    List < List < String >> ans;
    private void dfs(String word, List < String > seq) {

        if (word.equals(b)) {

            List < String > dup = new ArrayList < > (seq);
            Collections.reverse(dup);
            ans.add(dup);
            return;
        }
        int steps = mpp.get(word);
        int sz = word.length();

        for (int i = 0; i < sz; i++) {

            for (char ch = 'a'; ch <= 'z'; ch++) {  // changed 'y' to 'z' to include all lowercase English letters
                char replacedCharArray[] = word.toCharArray();
                replacedCharArray[i] = ch;
                String replacedWord = new String(replacedCharArray);
                if (mpp.containsKey(replacedWord) &&
                    mpp.get(replacedWord) == steps + 1) { // changed '==' to '==' for correct comparison
                    seq.add(replacedWord);
                    dfs(replacedWord, seq);
                    seq.remove(seq.size() - 1);
                }
            }
        }
    }
    public List < List < String >> findLadders(String beginWord, String endWord,
        List < String > wordList) {

        Set < String > st = new HashSet < String > ();
        int len = wordList.size();
        for (int i = 0; i < len; i++) {
            st.add(wordList.get(i));
        }
        Queue < String > q = new LinkedList < > ();
        b = beginWord;
        q.add(beginWord);
        mpp = new HashMap < > ();
        mpp.put(beginWord, 1);
        int sizee = beginWord.length();
        st.remove(beginWord);
        while (!q.isEmpty()) {
            String word = q.poll();
            int steps = mpp.get(word);

            if (word.equals(endWord)) break;

            for (int i = 0; i < sizee; i++) {

                for (char ch = 'a'; ch <= 'z'; ch++) {  // changed 'y' to 'z' to include all lowercase English letters
                    char replacedCharArray[] = word.toCharArray();
                    replacedCharArray[i] = ch;
                    String replacedWord = new String(replacedCharArray);
                    if (st.contains(replacedWord)) {
                        q.add(replacedWord);
                        st.remove(replacedWord);
                        mpp.put(replacedWord, steps + 1);
                    }
                }
            }
        }
        ans = new ArrayList < > ();

        if (mpp.containsKey(endWord)) {
            List < String > seq = new ArrayList < > ();
            seq.add(endWord);
            dfs(endWord, seq);
        }
        return ans;
    }
}
"
2111,java,word-ladder-ii,"class Solution {
    String b;

    HashMap < String, Integer > mpp;

    List < List < String >> ans;
    private void dfs(String word, List < String > seq) {

        if (word.equals(b)) {

            List < String > dup = new ArrayList < > (seq);
            Collections.reverse(dup);
            ans.add(dup);
            return;
        }
        int steps = mpp.get(word);
        int sz = word.length();

        for (int i = 0; i < sz; i++) {

            for (char ch = 'a'; ch <= 'y'; ch++) { 
                char replacedCharArray[] = word.toCharArray();
                replacedCharArray[i] = ch;
                String replacedWord = new String(replacedCharArray);
                if (mpp.containsKey(replacedWord) &&
                    mpp.get(replacedWord) + 1 == steps) {

                    seq.add(replacedWord);
                    dfs(replacedWord, seq);

                    seq.remove(seq.size() - 1);
                }
            }
        }
    }
    public List < List < String >> findLadders(String beginWord, String endWord,
        List < String > wordList) {

        Set < String > st = new HashSet < String > ();
        int len = wordList.size();
        for (int i = 0; i < len; i++) {
            st.add(wordList.get(i));
        }
        Queue < String > q = new LinkedList < > ();
        b = beginWord;
        q.add(beginWord);
        mpp = new HashMap < > ();
        mpp.put(beginWord, 1);
        int sizee = beginWord.length();
        st.remove(beginWord);
        while (!q.isEmpty()) {
            String word = q.peek();
            int steps = mpp.get(word);
            q.remove();

            if (word.equals(endWord)) break;

            for (int i = 0; i < sizee; i++) {

                for (char ch = 'a'; ch <= 'y'; ch++) { 
                    char replacedCharArray[] = word.toCharArray();
                    replacedCharArray[i] = ch;
                    String replacedWord = new String(replacedCharArray);
                    if (st.contains(replacedWord) == true) {
                        q.add(replacedWord);
                        st.remove(replacedWord);
                        mpp.put(replacedWord, steps + 1);
                    }
                }
            }
        }
        ans = new ArrayList < > ();

        if (mpp.containsKey(endWord) == true) {
            List < String > seq = new ArrayList < > ();
            seq.add(endWord);
            dfs(endWord, seq);
        }
        return ans;
    }
}",None,"class Solution {
    String b;

    HashMap < String, Integer > mpp;

    List < List < String >> ans;
    private void dfs(String word, List < String > seq) {

        if (word.equals(b)) {

            List < String > dup = new ArrayList < > (seq);
            Collections.reverse(dup);
            ans.add(dup);
            return;
        }
        int steps = mpp.get(word);
        int sz = word.length();

        for (int i = 0; i < sz; i++) {

            for (char ch = 'a'; ch <= 'z'; ch++) {  // Change 'y' to 'z'
                char replacedCharArray[] = word.toCharArray();
                replacedCharArray[i] = ch;
                String replacedWord = new String(replacedCharArray);
                if (mpp.containsKey(replacedWord) &&
                    mpp.get(replacedWord) == steps + 1) { // Change '==' to '=='

                    seq.add(replacedWord);
                    dfs(replacedWord, seq);

                    seq.remove(seq.size() - 1);
                }
            }
        }
    }
    public List < List < String >> findLadders(String beginWord, String endWord,
        List < String > wordList) {

        Set < String > st = new HashSet < String > ();
        int len = wordList.size();
        for (int i = 0; i < len; i++) {
            st.add(wordList.get(i));
        }
        Queue < String > q = new LinkedList < > ();
        b = beginWord;
        q.add(beginWord);
        mpp = new HashMap < > ();
        mpp.put(beginWord, 1);
        int sizee = beginWord.length();
        st.remove(beginWord);
        while (!q.isEmpty()) {
            String word = q.peek();
            int steps = mpp.get(word);
            q.remove();

            if (word.equals(endWord)) break;

            for (int i = 0; i < sizee; i++) {

                for (char ch = 'a'; ch <= 'z'; ch++) {  // Change 'y' to 'z'
                    char replacedCharArray[] = word.toCharArray();
                    replacedCharArray[i] = ch;
                    String replacedWord = new String(replacedCharArray);
                    if (st.contains(replacedWord) == true) {
                        q.add(replacedWord);
                        st.remove(replacedWord);
                        mpp.put(replacedWord, steps + 1);
                    }
                }
            }
        }
        ans = new ArrayList < > ();

        if (mpp.containsKey(endWord) == true) {
            List < String > seq = new ArrayList < > ();
            seq.add(endWord);
            dfs(endWord, seq);
        }
        return ans;
    }
}
"
2112,java,find-nearest-point-that-has-the-same-x-or-y-coordinate,"class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        
        int sIndex = 100000;
        int sDistance = 100000;

        for (int i = 0; i <= points.length; i++) {
            
            if (points[i][0] == x || points[i][1] == y) {

                int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
                if (sDistance > distance) {
                    sDistance = distance;
                    sIndex = i;
                }
            }
        }

        if (sIndex == 100000)
            return -1;
        return sIndex;
    }
}",None,"class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        
        int sIndex = -1;
        int sDistance = Integer.MAX_VALUE;

        for (int i = 0; i < points.length; i++) {
            
            if (points[i][0] == x || points[i][1] == y) {

                int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
                if (sDistance > distance) {
                    sDistance = distance;
                    sIndex = i;
                }
            }
        }

        return sIndex;
    }
}
"
2112,java,find-nearest-point-that-has-the-same-x-or-y-coordinate,"class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        
        int sIndex = 100000;
        int sDistance = 100000;

        for (int i = 0; i <= points.length; i++) {
            
            if (points[i][0] == x || points[i][1] == y) {

                int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
                if (sDistance > distance) {
                    sDistance = distance;
                    sIndex = i;
                }
            }
        }

        if (sIndex == 100000)
            return -1;
        return sIndex;
    }
}",None,"class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        
        int sIndex = -1;
        int sDistance = Integer.MAX_VALUE;

        for (int i = 0; i < points.length; i++) {
            
            if (points[i][0] == x || points[i][1] == y) {

                int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
                if (sDistance > distance) {
                    sDistance = distance;
                    sIndex = i;
                }
            }
        }

        return sIndex;
    }
}
"
2112,java,find-nearest-point-that-has-the-same-x-or-y-coordinate,"class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        
        int sIndex = 100000;
        int sDistance = 100000;

        for (int i = 0; i <= points.length; i++) {
            
            if (points[i][0] == x || points[i][1] == y) {

                int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
                if (sDistance > distance) {
                    sDistance = distance;
                    sIndex = i;
                }
            }
        }

        if (sIndex == 100000)
            return -1;
        return sIndex;
    }
}",None,"class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        
        int sIndex = -1;
        int sDistance = Integer.MAX_VALUE;

        for (int i = 0; i < points.length; i++) {
            
            if (points[i][0] == x || points[i][1] == y) {

                int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);
                if (sDistance > distance) {
                    sDistance = distance;
                    sIndex = i;
                }
            }
        }

        return sIndex;
    }
}
"
2113,java,distribute-candies,"class Solution {
    public int distributeCandies(int[] candyType) {

    Set<Integer>st=new HashSet<>();

    for(int i=0;i<=candyType.length;i++){
        st.add(candyType[i]);
        if(st.size()>candyType.length/2)return candyType.length/2;
    }

    return st.size();

    }
}",None,"class Solution {
    public int distributeCandies(int[] candyType) {

    Set<Integer>st=new HashSet<>();

    for(int i=0;i<candyType.length;i++){
        st.add(candyType[i]);
        if(st.size()>candyType.length/2)return candyType.length/2;
    }

    return st.size();

    }
}
"
2113,java,distribute-candies,"class Solution {
    public int distributeCandies(int[] candyType) {

    Set<Integer>st=new HashSet<>();

    for(int i=0;i<=candyType.length;i++){
        st.add(candyType[i]);
        if(st.size()>candyType.length/2)return candyType.length/2;
    }

    return st.size();

    }
}",None,"class Solution {
    public int distributeCandies(int[] candyType) {

    Set<Integer>st=new HashSet<>();

    for(int i=0;i<candyType.length;i++){
        st.add(candyType[i]);
        if(st.size()>candyType.length/2)return candyType.length/2;
    }

    return st.size();

    }
}
"
2113,java,distribute-candies,"class Solution {
    public int distributeCandies(int[] candyType) {

    Set<Integer>st=new HashSet<>();

    for(int i=0;i<=candyType.length;i++){
        st.add(candyType[i]);
        if(st.size()>candyType.length/2)return candyType.length/2;
    }

    return st.size();

    }
}",None,"class Solution {
    public int distributeCandies(int[] candyType) {

    Set<Integer>st=new HashSet<>();

    for(int i=0;i<candyType.length;i++){
        st.add(candyType[i]);
        if(st.size()>candyType.length/2)return candyType.length/2;
    }

    return st.size();

    }
}
"
2114,java,unique-paths-iii,"class Solution {
    public int uniquePathsIII(int[][] grid) {
        
        int row = 0;
        int col = 0;
        for(int i = 0; i < grid.length; i++) {
            for(int j = 0; j < grid[0].length; j++) {
                if(grid[i][j] == 1) {
                    row = i;
                    col = j;
                    
                    break;
                }
            }
        }
        boolean[][] used = new boolean[grid.length][grid[0].length];
        return count(grid, used, row, col);
    }
    
}",None,"class Solution {
    public int uniquePathsIII(int[][] grid) {
        
        int row = 0;
        int col = 0;
        int emptyCells = 0;
        for(int i = 0; i < grid.length; i++) {
            for(int j = 0; j < grid[0].length; j++) {
                if(grid[i][j] == 1) {
                    row = i;
                    col = j;
                } else if (grid[i][j] == 0) {
                    emptyCells++;
                }
            }
        }
        boolean[][] used = new boolean[grid.length][grid[0].length];
        return count(grid, used, row, col, emptyCells + 1);
    }
    
    private int count(int[][] grid, boolean[][] used, int row, int col, int emptyCells) {
        if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || grid[row][col] == -1 || used[row][col]) {
            return 0;
        }
        if (emptyCells == 0 && grid[row][col] == 2) {
            return 1;
        }
        used[row][col] = true;
        int count = 0;
        count += count(grid, used, row + 1, col, emptyCells - 1);
        count += count(grid, used, row - 1, col, emptyCells - 1);
        count += count(grid, used, row, col + 1, emptyCells - 1);
        count += count(grid, used, row, col - 1, emptyCells - 1);
        used[row][col] = false;
        return count;
    }
}
"
2114,java,unique-paths-iii,"class Solution {
    public int uniquePathsIII(int[][] grid) {
        
        int row = 0;
        int col = 0;
        for(int i = 0; i < grid.length; i++) {
            for(int j = 0; j < grid[0].length; j++) {
                if(grid[i][j] == 1) {
                    row = i;
                    col = j;
                    
                    break;
                }
            }
        }
        boolean[][] used = new boolean[grid.length][grid[0].length];
        return count(grid, used, row, col);
    }
    
}",None,"class Solution {
    public int uniquePathsIII(int[][] grid) {
        int startRow = 0;
        int startCol = 0;
        int emptyCells = 0;
        for(int i = 0; i < grid.length; i++) {
            for(int j = 0; j < grid[0].length; j++) {
                if(grid[i][j] == 1) {
                    startRow = i;
                    startCol = j;
                }
                if(grid[i][j] == 0) {
                    emptyCells++;
                }
            }
        }
        boolean[][] used = new boolean[grid.length][grid[0].length];
        return count(grid, used, startRow, startCol, emptyCells + 1);
    }

    private int count(int[][] grid, boolean[][] used, int row, int col, int target) {
        if(row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || grid[row][col] < 0 || used[row][col]) {
            return 0;
        }
        if(grid[row][col] == 2) {
            return target == 1 ? 1 : 0;
        }
        used[row][col] = true;
        int count = 0;
        count += count(grid, used, row - 1, col, target - 1);
        count += count(grid, used, row + 1, col, target - 1);
        count += count(grid, used, row, col - 1, target - 1);
        count += count(grid, used, row, col + 1, target - 1);
        used[row][col] = false;
        return count;
    }
}
"
2114,java,unique-paths-iii,"class Solution {
    public int uniquePathsIII(int[][] grid) {
        
        int row = 0;
        int col = 0;
        for(int i = 0; i < grid.length; i++) {
            for(int j = 0; j < grid[0].length; j++) {
                if(grid[i][j] == 1) {
                    row = i;
                    col = j;
                    
                    break;
                }
            }
        }
        boolean[][] used = new boolean[grid.length][grid[0].length];
        return count(grid, used, row, col);
    }
    
}",None,"class Solution {
    public int uniquePathsIII(int[][] grid) {
        int startRow = 0;
        int startCol = 0;
        int emptyCount = 0;
        for(int i = 0; i < grid.length; i++) {
            for(int j = 0; j < grid[0].length; j++) {
                if(grid[i][j] == 1) {
                    startRow = i;
                    startCol = j;
                } else if(grid[i][j] == 0) {
                    emptyCount++;
                }
            }
        }
        boolean[][] used = new boolean[grid.length][grid[0].length];
        return count(grid, used, startRow, startCol, emptyCount);
    }
    
    private int count(int[][] grid, boolean[][] used, int row, int col, int emptyCount) {
        if(row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || grid[row][col] == -1 || used[row][col]) {
            return 0;
        }
        if(grid[row][col] == 2) {
            return emptyCount == 0 ? 1 : 0;
        }
        used[row][col] = true;
        int result = count(grid, used, row + 1, col, emptyCount - 1) +
                     count(grid, used, row - 1, col, emptyCount - 1) +
                     count(grid, used, row, col + 1, emptyCount - 1) +
                     count(grid, used, row, col - 1, emptyCount - 1);
        used[row][col] = false;
        return result;
    }
}
"
2115,java,n-ary-tree-preorder-traversal,"class Solution {
    List<Integer> arr = new ArrayList<>();
    public List<Integer> preorder(Node root) {
        if (root==null) return arr;
        arr.add(root.val);
        for (Node i : root.children) {
            preorder(root);
        }
        return arr;
    }
}",None,"class Solution {
    List<Integer> arr = new ArrayList<>();
    public List<Integer> preorder(Node root) {
        if (root==null) return arr;
        arr.add(root.val);
        for (Node child : root.children) {
            preorder(child);
        }
        return arr;
    }
}
"
2115,java,n-ary-tree-preorder-traversal,"class Solution {
    List<Integer> arr = new ArrayList<>();
    public List<Integer> preorder(Node root) {
        if (root==null) return arr;
        arr.add(root.val);
        for (Node i : root.children) {
            preorder(root);
        }
        return arr;
    }
}",None,"class Solution {
    List<Integer> arr = new ArrayList<>();
    public List<Integer> preorder(Node root) {
        if (root==null) return arr;
        arr.add(root.val);
        for (Node child : root.children) {
            preorder(child);
        }
        return arr;
    }
}
"
2115,java,n-ary-tree-preorder-traversal,"class Solution {
    List<Integer> arr = new ArrayList<>();
    public List<Integer> preorder(Node root) {
        if (root==null) return arr;
        arr.add(root.val);
        for (Node i : root.children) {
            preorder(root);
        }
        return arr;
    }
}",None,"class Solution {
    List<Integer> arr = new ArrayList<>();
    public List<Integer> preorder(Node root) {
        if (root==null) return arr;
        arr.add(root.val);
        for (Node child : root.children) {
            preorder(child);
        }
        return arr;
    }
}
"
2116,java,count-primes,"class Solution {
    public int countPrimes(int n) {
        if(n<2) return 0;
        boolean[] primes = new boolean[n];
        Arrays.fill(primes, true);
         
        int count=0;
        for (int p = 2;p < n; p++) {
            if(primes[p])
            {
                count++;
                if((long)p*p<n)
                {
                    for(int i=p*p;i<=n;i+=p)
                    primes[i]=false;
                }
            }
          }
    return count;
    }
}",None,"class Solution {
    public int countPrimes(int n) {
        if(n<2) return 0;
        boolean[] primes = new boolean[n];
        Arrays.fill(primes, true);
         
        int count=0;
        for (int p = 2;p < n; p++) {
            if(primes[p])
            {
                count++;
                if((long)p*p<n)
                {
                    for(int i=p*p;i<n;i+=p)
                    primes[i]=false;
                }
            }
          }
    return count;
    }
}
"
2116,java,count-primes,"class Solution {
    public int countPrimes(int n) {
        if(n<2) return 0;
        boolean[] primes = new boolean[n];
        Arrays.fill(primes, true);
         
        int count=0;
        for (int p = 2;p < n; p++) {
            if(primes[p])
            {
                count++;
                if((long)p*p<n)
                {
                    for(int i=p*p;i<=n;i+=p)
                    primes[i]=false;
                }
            }
          }
    return count;
    }
}",None,"class Solution {
    public int countPrimes(int n) {
        if(n<2) return 0;
        boolean[] primes = new boolean[n];
        Arrays.fill(primes, true);
         
        int count=0;
        for (int p = 2;p < n; p++) {
            if(primes[p])
            {
                count++;
                if((long)p*p<n)
                {
                    for(int i=p*p;i<n;i+=p)
                    primes[i]=false;
                }
            }
          }
    return count;
    }
}
"
2116,java,count-primes,"class Solution {
    public int countPrimes(int n) {
        if(n<2) return 0;
        boolean[] primes = new boolean[n];
        Arrays.fill(primes, true);
         
        int count=0;
        for (int p = 2;p < n; p++) {
            if(primes[p])
            {
                count++;
                if((long)p*p<n)
                {
                    for(int i=p*p;i<=n;i+=p)
                    primes[i]=false;
                }
            }
          }
    return count;
    }
}",None,"class Solution {
    public int countPrimes(int n) {
        if(n<2) return 0;
        boolean[] primes = new boolean[n];
        Arrays.fill(primes, true);
         
        int count=0;
        for (int p = 2;p < n; p++) {
            if(primes[p])
            {
                count++;
                if((long)p*p<n)
                {
                    for(int i=p*p;i<n;i+=p)
                    primes[i]=false;
                }
            }
          }
    return count;
    }
}
"
2117,java,check-if-point-is-reachable,"class Solution {
    public boolean isReachable(int targetX, int targetY) {
        if (targetX > targetY)
            return isReachable(targetY, targetX);
        if (targetX % 2 == 0)
            return isReachable(targetX / 2, targetY);
        if (targetY % 2 == 0)
            return isReachable(targetX, targetY / 2);
            
        if (targetX == 1)
            return true;

        if (targetY == targetX)
            return true;

        return isReachable(targetX, (targetX + targetY) / 2);
    }
}",None,"class Solution {
    public boolean isReachable(int targetX, int targetY) {
        if (targetX > targetY)
            return isReachable(targetY, targetX);
        if (targetX % 2 == 0)
            return isReachable(targetX / 2, targetY);
        if (targetY % 2 == 0)
            return isReachable(targetX, targetY / 2);
        if (targetX == 1)
            return true;

        if (targetY == targetX)
            return true;

        return isReachable(targetX, (targetX + targetY) / 2) || isReachable(targetX * 2, targetY);
    }
}
"
2117,java,check-if-point-is-reachable,"class Solution {
    public boolean isReachable(int targetX, int targetY) {
        if (targetX > targetY)
            return isReachable(targetY, targetX);
        if (targetX % 2 == 0)
            return isReachable(targetX / 2, targetY);
        if (targetY % 2 == 0)
            return isReachable(targetX, targetY / 2);
            
        if (targetX == 1)
            return true;

        if (targetY == targetX)
            return true;

        return isReachable(targetX, (targetX + targetY) / 2);
    }
}",None,"class Solution {
    public boolean isReachable(int targetX, int targetY) {
        if (targetX > targetY)
            return isReachable(targetY, targetX);
        if (targetX % 2 == 0)
            return isReachable(targetX / 2, targetY);
        if (targetY % 2 == 0)
            return isReachable(targetX, targetY / 2);
        if (targetX == 1)
            return true;

        if (targetY == targetX)
            return true;

        return isReachable(targetX, (targetX + targetY) / 2) || isReachable(targetX + targetY / 2, targetY);
    }
}
"
2117,java,check-if-point-is-reachable,"class Solution {
    public boolean isReachable(int targetX, int targetY) {
        if (targetX > targetY)
            return isReachable(targetY, targetX);
        if (targetX % 2 == 0)
            return isReachable(targetX / 2, targetY);
        if (targetY % 2 == 0)
            return isReachable(targetX, targetY / 2);
            
        if (targetX == 1)
            return true;

        if (targetY == targetX)
            return true;

        return isReachable(targetX, (targetX + targetY) / 2);
    }
}",None,"class Solution {
    public boolean isReachable(int targetX, int targetY) {
        if (targetX > targetY)
            return isReachable(targetY, targetX);
        if (targetX % 2 == 0)
            return isReachable(targetX / 2, targetY);
        if (targetY % 2 == 0)
            return isReachable(targetX, targetY / 2);
        if (targetX == 1)
            return true;
        if (targetY == targetX)
            return true;
        return isReachable(targetX, (targetX + targetY) / 2) || isReachable((targetX + 1) / 2, targetY);
    }
}
"
2118,java,number-of-students-doing-homework-at-a-given-time,"class Solution {
    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {
        int n=endTime.length;
        int cnt=0;
        for(int i=0;i<=n;i++)
        {
            if(endTime[i]>=queryTime && queryTime>=startTime[i] )
            {
                cnt++;
            }
        }
        return cnt;
    }
}",None,"class Solution {
    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {
        int n=startTime.length;
        int cnt=0;
        for(int i=0;i<n;i++)
        {
            if(endTime[i]>=queryTime && queryTime>=startTime[i] )
            {
                cnt++;
            }
        }
        return cnt;
    }
}
"
2118,java,number-of-students-doing-homework-at-a-given-time,"class Solution {
    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {
        int n=endTime.length;
        int cnt=0;
        for(int i=0;i<=n;i++)
        {
            if(endTime[i]>=queryTime && queryTime>=startTime[i] )
            {
                cnt++;
            }
        }
        return cnt;
    }
}",None,"class Solution {
    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {
        int n=startTime.length;
        int cnt=0;
        for(int i=0;i<n;i++)
        {
            if(endTime[i]>=queryTime && queryTime>=startTime[i] )
            {
                cnt++;
            }
        }
        return cnt;
    }
}
"
2118,java,number-of-students-doing-homework-at-a-given-time,"class Solution {
    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {
        int n=endTime.length;
        int cnt=0;
        for(int i=0;i<=n;i++)
        {
            if(endTime[i]>=queryTime && queryTime>=startTime[i] )
            {
                cnt++;
            }
        }
        return cnt;
    }
}",None,"class Solution {
    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {
        int n=startTime.length;
        int cnt=0;
        for(int i=0;i<n;i++)
        {
            if(endTime[i]>=queryTime && queryTime>=startTime[i] )
            {
                cnt++;
            }
        }
        return cnt;
    }
}
"
2119,java,row-with-maximum-ones,"class Solution {
    public int[] rowAndMaximumOnes(int[][] mat) {
        int count;
        int maxCount = 0;
        int maxCountRow = 0;
        for(int i = 0; i <= mat.length; i++) {
            count = 0;
            for(int j = 0; j < mat[0].length; j++) {
                count += mat[i][j];
            }
            if(count > maxCount) {
                maxCount = count;
                maxCountRow = i;
            }
        }
        return new int[]{maxCountRow, maxCount};
    }
}",None,"class Solution {
    public int[] rowAndMaximumOnes(int[][] mat) {
        int count;
        int maxCount = 0;
        int maxCountRow = 0;
        for(int i = 0; i < mat.length; i++) { // fixed the index range
            count = 0;
            for(int j = 0; j < mat[i].length; j++) {
                count += mat[i][j];
            }
            if(count > maxCount) {
                maxCount = count;
                maxCountRow = i;
            }
        }
        return new int[]{maxCountRow, maxCount};
    }
}
"
2119,java,row-with-maximum-ones,"class Solution {
    public int[] rowAndMaximumOnes(int[][] mat) {
        int count;
        int maxCount = 0;
        int maxCountRow = 0;
        for(int i = 0; i <= mat.length; i++) {
            count = 0;
            for(int j = 0; j < mat[0].length; j++) {
                count += mat[i][j];
            }
            if(count > maxCount) {
                maxCount = count;
                maxCountRow = i;
            }
        }
        return new int[]{maxCountRow, maxCount};
    }
}",None,"class Solution {
    public int[] rowAndMaximumOnes(int[][] mat) {
        int count;
        int maxCount = 0;
        int maxCountRow = 0;
        for(int i = 0; i < mat.length; i++) { // change the condition from i <= mat.length to i < mat.length
            count = 0;
            for(int j = 0; j < mat[0].length; j++) {
                count += mat[i][j];
            }
            if(count > maxCount) {
                maxCount = count;
                maxCountRow = i;
            }
        }
        return new int[]{maxCountRow, maxCount};
    }
}
"
2119,java,row-with-maximum-ones,"class Solution {
    public int[] rowAndMaximumOnes(int[][] mat) {
        int count;
        int maxCount = 0;
        int maxCountRow = 0;
        for(int i = 0; i <= mat.length; i++) {
            count = 0;
            for(int j = 0; j < mat[0].length; j++) {
                count += mat[i][j];
            }
            if(count > maxCount) {
                maxCount = count;
                maxCountRow = i;
            }
        }
        return new int[]{maxCountRow, maxCount};
    }
}",None,"class Solution {
    public int[] rowAndMaximumOnes(int[][] mat) {
        int count;
        int maxCount = 0;
        int maxCountRow = 0;
        for(int i = 0; i < mat.length; i++) {
            count = 0;
            for(int j = 0; j < mat[0].length; j++) {
                count += mat[i][j];
            }
            if(count > maxCount) {
                maxCount = count;
                maxCountRow = i;
            }
        }
        return new int[]{maxCountRow, maxCount};
    }
}
"
2120,java,best-time-to-buy-and-sell-stock-ii,"class Solution {
    public int maxProfit(int[] prices) {
        int profit=0;
        for(int i=0; i<prices.length; i++){
            if(prices[i]>prices[i-1]){
                profit+=prices[i]-prices[i-1];
            }
        }
        return profit;
    }
}",None,"class Solution {
    public int maxProfit(int[] prices) {
        int profit=0;
        if (prices.length < 2) {
            return profit;
        }
        for(int i=1; i<prices.length; i++){
            if(prices[i]>prices[i-1]){
                profit+=prices[i]-prices[i-1];
            }
        }
        return profit;
    }
}
"
2120,java,best-time-to-buy-and-sell-stock-ii,"class Solution {
    public int maxProfit(int[] prices) {
        int profit=0;
        for(int i=0; i<prices.length; i++){
            if(prices[i]>prices[i-1]){
                profit+=prices[i]-prices[i-1];
            }
        }
        return profit;
    }
}",None,"class Solution {
    public int maxProfit(int[] prices) {
        if (prices.length <= 1) {
            return 0;
        }
        int profit = 0;
        for (int i = 1; i < prices.length; i++) {
            if (prices[i] > prices[i - 1]) {
                profit += prices[i] - prices[i - 1];
            }
        }
        return profit;
    }
}
"
2120,java,best-time-to-buy-and-sell-stock-ii,"class Solution {
    public int maxProfit(int[] prices) {
        int profit=0;
        for(int i=0; i<prices.length; i++){
            if(prices[i]>prices[i-1]){
                profit+=prices[i]-prices[i-1];
            }
        }
        return profit;
    }
}",None,"class Solution {
    public int maxProfit(int[] prices) {
        int profit=0;
        for(int i=1; i<prices.length; i++){
            if(prices[i]>prices[i-1]){
                profit+=prices[i]-prices[i-1];
            }
        }
        return profit;
    }
}
"
2121,java,apply-discount-every-n-orders,"class Cashier {
    HashMap<Integer,Integer>stock=new HashMap<>();
    int n;
    int discount;
    int itr=0;
    public Cashier(int n, int discount, int[] products, int[] prices) {
        for(int i=0;i<products.length;i++){
            stock.put(products[i],prices[i]);
        }
        this.n=n;
        this.discount=discount;
    }
    
    public double getBill(int[] product, int[] amount) {
        double total=0;
        for(int i=0;i<product.length;i++){
            total+=(double)(amount[i]*stock.get(product[i]));
        }
        itr++;
        if(itr==n+1){
            total*=(double)(((100-discount)/100d));
            itr=0;
        }
        return total;
    }
}",None,"class Cashier {
    HashMap<Integer,Integer>stock=new HashMap<>();
    int n;
    int discount;
    int itr=0;
    public Cashier(int n, int discount, int[] products, int[] prices) {
        for(int i=0;i<products.length;i++){
            stock.put(products[i],prices[i]);
        }
        this.n=n;
        this.discount=discount;
    }
    
    public double getBill(int[] product, int[] amount) {
        double total=0;
        for(int i=0;i<product.length;i++){
            total+=(double)amount[i] * stock.get(product[i]);
        }
        itr++;
        if(itr%n == 1){
            total*=(double)(((100-discount)/100));
        }
        return total;
    }
}
"
2121,java,apply-discount-every-n-orders,"class Cashier {
    HashMap<Integer,Integer>stock=new HashMap<>();
    int n;
    int discount;
    int itr=0;
    public Cashier(int n, int discount, int[] products, int[] prices) {
        for(int i=0;i<products.length;i++){
            stock.put(products[i],prices[i]);
        }
        this.n=n;
        this.discount=discount;
    }
    
    public double getBill(int[] product, int[] amount) {
        double total=0;
        for(int i=0;i<product.length;i++){
            total+=(double)(amount[i]*stock.get(product[i]));
        }
        itr++;
        if(itr==n+1){
            total*=(double)(((100-discount)/100d));
            itr=0;
        }
        return total;
    }
}",None,"class Cashier {
    HashMap<Integer,Integer>stock=new HashMap<>();
    int n;
    int discount;
    int itr=0;
    public Cashier(int n, int discount, int[] products, int[] prices) {
        for(int i=0;i<products.length;i++){
            stock.put(products[i],prices[i]);
        }
        this.n=n;
        this.discount=discount;
    }
    
    public double getBill(int[] product, int[] amount) {
        double total=0;
        for(int i=0;i<product.length;i++){
            total+=(double)(amount[i]*stock.get(product[i]));
        }
        itr++;
        if(itr%n==1){
            total*=(double)(((100-discount)/100d));
        }
        return total;
    }
}
"
2121,java,apply-discount-every-n-orders,"class Cashier {
    HashMap<Integer,Integer>stock=new HashMap<>();
    int n;
    int discount;
    int itr=0;
    public Cashier(int n, int discount, int[] products, int[] prices) {
        for(int i=0;i<products.length;i++){
            stock.put(products[i],prices[i]);
        }
        this.n=n;
        this.discount=discount;
    }
    
    public double getBill(int[] product, int[] amount) {
        double total=0;
        for(int i=0;i<product.length;i++){
            total+=(double)(amount[i]*stock.get(product[i]));
        }
        itr++;
        if(itr==n+1){
            total*=(double)(((100-discount)/100d));
            itr=0;
        }
        return total;
    }
}",None,"class Cashier {
    HashMap<Integer,Integer>stock=new HashMap<>();
    int n;
    int discount;
    int itr=0;
    public Cashier(int n, int discount, int[] products, int[] prices) {
        for(int i=0;i<products.length;i++){
            stock.put(products[i],prices[i]);
        }
        this.n=n;
        this.discount=discount;
    }
    
    public double getBill(int[] product, int[] amount) {
        double total=0;
        for(int i=0;i<product.length;i++){
            total+=(double)amount[i]*stock.get(product[i]);
        }
        itr++;
        if(itr%n == 1){
            total*=(double)(((100-discount)/100d));
        }
        return total;
    }
}
"
2122,java,find-the-distinct-difference-array,"class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n=nums.length;
        int[] d=new int[n];
        for (int i = 0; i < n; i++) {
            Set<Integer> pre=new HashSet<>();
            for (int j = 0; j <= i; j++) {
                pre.add(nums[j]);
            }
            Set<Integer> suf=new HashSet<>();
            for (int j = i + 1; j <= n; j++) {
                suf.add(nums[j]);
            }
            d[i]=pre.size()-suf.size();
        }
        return d;
    }
}",None,"class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n=nums.length;
        int[] d=new int[n];
        for (int i = 0; i < n; i++) {
            Set<Integer> pre=new HashSet<>();
            for (int j = 0; j <= i; j++) {
                pre.add(nums[j]);
            }
            Set<Integer> suf=new HashSet<>();
            for (int j = i + 1; j < n; j++) {
                suf.add(nums[j]);
            }
            d[i]=pre.size()-suf.size();
        }
        return d;
    }
}
"
2122,java,find-the-distinct-difference-array,"class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n=nums.length;
        int[] d=new int[n];
        for (int i = 0; i < n; i++) {
            Set<Integer> pre=new HashSet<>();
            for (int j = 0; j <= i; j++) {
                pre.add(nums[j]);
            }
            Set<Integer> suf=new HashSet<>();
            for (int j = i + 1; j <= n; j++) {
                suf.add(nums[j]);
            }
            d[i]=pre.size()-suf.size();
        }
        return d;
    }
}",None,"class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n=nums.length;
        int[] d=new int[n];
        for (int i = 0; i < n; i++) {
            Set<Integer> pre=new HashSet<>();
            for (int j = 0; j <= i; j++) {
                pre.add(nums[j]);
            }
            Set<Integer> suf=new HashSet<>();
            for (int j = i + 1; j < n; j++) {
                suf.add(nums[j]);
            }
            d[i]=pre.size()-suf.size();
        }
        return d;
    }
}
"
2122,java,find-the-distinct-difference-array,"class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n=nums.length;
        int[] d=new int[n];
        for (int i = 0; i < n; i++) {
            Set<Integer> pre=new HashSet<>();
            for (int j = 0; j <= i; j++) {
                pre.add(nums[j]);
            }
            Set<Integer> suf=new HashSet<>();
            for (int j = i + 1; j <= n; j++) {
                suf.add(nums[j]);
            }
            d[i]=pre.size()-suf.size();
        }
        return d;
    }
}",None,"class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n=nums.length;
        int[] d=new int[n];
        Set<Integer> pre=new HashSet<>();
        for (int i = 0; i < n; i++) {
            pre.add(nums[i]);
            Set<Integer> suf=new HashSet<>();
            for (int j = i + 1; j < n; j++) {
                suf.add(nums[j]);
            }
            d[i]=pre.size()-suf.size();
        }
        return d;
    }
}
"
2123,java,find-the-distinct-difference-array,"class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n=nums.length;
        int ans[]=new int[n];
        
        for(int i=0;i<n;i++){
            Set<Integer>set1=new HashSet<>();
            Set<Integer>set2=new HashSet<>();
            
            for(int j=0;j<=i;j++){
                set1.add(nums[j]);
            }
            for(int j=i;j<n;j++){
                set2.add(nums[j]);
            }
            
            ans[i]= set1.size() - set2.size();
        }
        return ans;
    }
}",None,"class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n=nums.length;
        int ans[]=new int[n];
        
        Set<Integer> prefix = new HashSet<>();
        Set<Integer> suffix = new HashSet<>();

        for(int i=0;i<n;i++){
            if(i < n-1){
                suffix.add(nums[i]);
            }
            prefix.add(nums[i]);

            if(i >= 1){
                suffix.remove(nums[i-1]);
            }

            ans[i] = prefix.size() - suffix.size();
        }
        return ans;
    }
}
"
2123,java,find-the-distinct-difference-array,"class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n=nums.length;
        int ans[]=new int[n];
        
        for(int i=0;i<n;i++){
            Set<Integer>set1=new HashSet<>();
            Set<Integer>set2=new HashSet<>();
            
            for(int j=0;j<=i;j++){
                set1.add(nums[j]);
            }
            for(int j=i;j<n;j++){
                set2.add(nums[j]);
            }
            
            ans[i]= set1.size() - set2.size();
        }
        return ans;
    }
}",None,"class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n=nums.length;
        int ans[]=new int[n];
        
        Set<Integer> prefix = new HashSet<>();
        Set<Integer> suffix = new HashSet<>();

        for(int i=0;i<n;i++){
            if(i < n-1) {
                suffix.add(nums[i]);
            }
            prefix.add(nums[i]);

            if(i >= 1) {
                suffix.remove(nums[i-1]);
            }

            ans[i] = prefix.size() - suffix.size();
        }
        return ans;
    }
}
"
2123,java,find-the-distinct-difference-array,"class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n=nums.length;
        int ans[]=new int[n];
        
        for(int i=0;i<n;i++){
            Set<Integer>set1=new HashSet<>();
            Set<Integer>set2=new HashSet<>();
            
            for(int j=0;j<=i;j++){
                set1.add(nums[j]);
            }
            for(int j=i;j<n;j++){
                set2.add(nums[j]);
            }
            
            ans[i]= set1.size() - set2.size();
        }
        return ans;
    }
}",None,"class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n=nums.length;
        int ans[]=new int[n];
        
        for(int i=0;i<n;i++){
            Set<Integer>set1=new HashSet<>();
            Set<Integer>set2=new HashSet<>();
            
            for(int j=0;j<=i;j++){
                set1.add(nums[j]);
            }
            for(int j=i+1;j<n;j++){
                set2.add(nums[j]);
            }
            
            ans[i]= set1.size() - set2.size();
        }
        return ans;
    }
}
"
2124,java,check-if-binary-string-has-at-most-one-segment-of-ones,"class Solution {
    public boolean checkOnesSegment(String s) {
        int count=0;
       int pos=0;
       while(s.charAt(pos)!='1'){
              pos++;
            if(pos==s.length()){
                return true;
            }
          }
       
       for(int i=pos;i<=s.length();i++){
          if(s.charAt(i)=='0'){
              count++;
          }
          else if(count>0&&s.charAt(i)=='1'){
              return false;
          }
       } 
       return true;
    }
}",None,"class Solution {
    public boolean checkOnesSegment(String s) {
        int count=0;
       int pos=0;
       while(pos<s.length() && s.charAt(pos)!='1'){
              pos++;
          }
       
       for(int i=pos;i<s.length();i++){
          if(s.charAt(i)=='0'){
              count++;
          }
          else if(count>0&&s.charAt(i)=='1'){
              return false;
          }
       } 
       return true;
    }
}
"
2124,java,check-if-binary-string-has-at-most-one-segment-of-ones,"class Solution {
    public boolean checkOnesSegment(String s) {
        int count=0;
       int pos=0;
       while(s.charAt(pos)!='1'){
              pos++;
            if(pos==s.length()){
                return true;
            }
          }
       
       for(int i=pos;i<=s.length();i++){
          if(s.charAt(i)=='0'){
              count++;
          }
          else if(count>0&&s.charAt(i)=='1'){
              return false;
          }
       } 
       return true;
    }
}",None,"class Solution {
    public boolean checkOnesSegment(String s) {
        int count=0;
       int pos=0;
       while(pos<s.length() && s.charAt(pos)!='1'){
              pos++;
          }
       
       for(int i=pos;i<s.length();i++){
          if(s.charAt(i)=='0'){
              count++;
          }
          else if(count>0 && s.charAt(i)=='1'){
              return false;
          }
       } 
       return true;
    }
}
"
2124,java,check-if-binary-string-has-at-most-one-segment-of-ones,"class Solution {
    public boolean checkOnesSegment(String s) {
        int count=0;
       int pos=0;
       while(s.charAt(pos)!='1'){
              pos++;
            if(pos==s.length()){
                return true;
            }
          }
       
       for(int i=pos;i<=s.length();i++){
          if(s.charAt(i)=='0'){
              count++;
          }
          else if(count>0&&s.charAt(i)=='1'){
              return false;
          }
       } 
       return true;
    }
}",None,"class Solution {
    public boolean checkOnesSegment(String s) {
        int count=0;
       int pos=0;
       while(pos<s.length() && s.charAt(pos)!='1'){
              pos++;
          }
       
       for(int i=pos;i<s.length();i++){
          if(s.charAt(i)=='0'){
              count++;
          }
          else if(count>0 && s.charAt(i)=='1'){
              return false;
          }
       } 
       return true;
    }
}
"
2125,java,subarray-product-less-than-k,"class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        int i = 0,n = nums.length,product = 1,result = 0;
        for(int j = 0;j<n;j++)
        {
            product = product*nums[j];
            while(i<=j && product>k)
            {
                product = product/nums[i];
                i++;
            }
            result += j-i+1;
        }
        return result;
    }
}",None,"class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        int i = 0,n = nums.length,product = 1,result = 0;
        for(int j = 0;j<n;j++)
        {
            product = product*nums[j];
            while(i<=j && product>=k)
            {
                product = product/nums[i];
                i++;
            }
            result += j-i+1;
        }
        return result;
    }
}
"
2125,java,subarray-product-less-than-k,"class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        int i = 0,n = nums.length,product = 1,result = 0;
        for(int j = 0;j<n;j++)
        {
            product = product*nums[j];
            while(i<=j && product>k)
            {
                product = product/nums[i];
                i++;
            }
            result += j-i+1;
        }
        return result;
    }
}",None,"class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        int i = 0,n = nums.length,product = 1,result = 0;
        for(int j = 0;j<n;j++)
        {
            product *= nums[j];
            while(i<j && product>k)
            {
                product /= nums[i];
                i++;
            }
            result += j-i+1;
        }
        return result;
    }
}
"
2125,java,subarray-product-less-than-k,"class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        int i = 0,n = nums.length,product = 1,result = 0;
        for(int j = 0;j<n;j++)
        {
            product = product*nums[j];
            while(i<=j && product>k)
            {
                product = product/nums[i];
                i++;
            }
            result += j-i+1;
        }
        return result;
    }
}",None,"class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        int i = 0,n = nums.length,product = 1,result = 0;
        for(int j = 0;j<n;j++)
        {
            product *= nums[j];
            while(i<j && product>k)
            {
                product /= nums[i];
                i++;
            }
            result += j-i+1;
        }
        return result;
    }
}
"
2126,java,sort-characters-by-frequency,"class Solution {
    public String frequencySort(String s) {
        char[] arr = new char[256];
    for(int i=0; i<s.length(); i++){
        arr[s.charAt(i)]++;    
    }
    
    StringBuilder sb = new StringBuilder();
    int max = -1;
    while(max != 0){
        max = -1;
        for(char i=0; i<=arr.length; i++){
            if(arr[i] > max){
                max = arr[i];
                maxi = i;
            }
        }
        for(int i=0; i<max; i++){
            sb.append(maxi);   
        }
        arr[maxi] = 0;
    }
    return sb.toString();
        
    }
}",None,"class Solution {
    public String frequencySort(String s) {
        int[] arr = new int[128];
        for(int i=0; i<s.length(); i++){
            arr[s.charAt(i)]++;    
        }
        
        StringBuilder sb = new StringBuilder();
        int max = -1;
        while(max != 0){
            max = -1;
            for(int i=0; i<arr.length; i++){
                if(arr[i] > max){
                    max = arr[i];
                    maxi = i;
                }
            }
            for(int i=0; i<max; i++){
                sb.append((char)maxi);   
            }
            arr[maxi] = 0;
        }
        return sb.toString();
        
    }
}
"
2126,java,sort-characters-by-frequency,"class Solution {
    public String frequencySort(String s) {
        char[] arr = new char[256];
    for(int i=0; i<s.length(); i++){
        arr[s.charAt(i)]++;    
    }
    
    StringBuilder sb = new StringBuilder();
    int max = -1;
    while(max != 0){
        max = -1;
        for(char i=0; i<=arr.length; i++){
            if(arr[i] > max){
                max = arr[i];
                maxi = i;
            }
        }
        for(int i=0; i<max; i++){
            sb.append(maxi);   
        }
        arr[maxi] = 0;
    }
    return sb.toString();
        
    }
}",None,"class Solution {
    public String frequencySort(String s) {
        int[] arr = new int[256];
    for(int i=0; i<s.length(); i++){
        arr[s.charAt(i)]++;    
    }
    
    StringBuilder sb = new StringBuilder();
    int max = -1;
    while(max != 0){
        max = -1;
        for(int i=0; i<arr.length; i++){
            if(arr[i] > max){
                max = arr[i];
                maxi = i;
            }
        }
        for(int i=0; i<max; i++){
            sb.append((char)maxi);   
        }
        arr[maxi] = 0;
    }
    return sb.toString();
        
    }
}
"
2126,java,sort-characters-by-frequency,"class Solution {
    public String frequencySort(String s) {
        char[] arr = new char[256];
    for(int i=0; i<s.length(); i++){
        arr[s.charAt(i)]++;    
    }
    
    StringBuilder sb = new StringBuilder();
    int max = -1;
    while(max != 0){
        max = -1;
        for(char i=0; i<=arr.length; i++){
            if(arr[i] > max){
                max = arr[i];
                maxi = i;
            }
        }
        for(int i=0; i<max; i++){
            sb.append(maxi);   
        }
        arr[maxi] = 0;
    }
    return sb.toString();
        
    }
}",None,"class Solution {
    public String frequencySort(String s) {
        int[] arr = new int[256];
    for(int i=0; i<s.length(); i++){
        arr[s.charAt(i)]++;    
    }
    
    StringBuilder sb = new StringBuilder();
    int max = -1;
    while(max != 0){
        max = -1;
        for(int i=0; i<arr.length; i++){
            if(arr[i] > max){
                max = arr[i];
                maxi = i;
            }
        }
        for(int i=0; i<max; i++){
            sb.append((char)maxi);   
        }
        arr[maxi] = 0;
    }
    return sb.toString();
        
    }
}
"
2127,java,make-array-empty,"class Solution {
    public long countOperationsToEmptyArray(int[] a) {
        HashMap<Integer, Integer> pos = new HashMap<>();
        long n = a.length, res = n;
        for (int i = 0; i < n; i++)
            pos.put(a[i], i);
        Arrays.sort(a);
        for (int i = 1; i <= n; i++)
            if (pos.get(a[i]) < pos.get(a[i - 1]))
                res += n - i;
        return res;
    }
}",None,"class Solution {
    public long countOperationsToEmptyArray(int[] a) {
        HashMap<Integer, Integer> pos = new HashMap<>();
        long n = a.length, res = n;
        for (int i = 0; i < n; i++)
            pos.put(a[i], i);
        Arrays.sort(a);
        for (int i = 1; i < n; i++)
            if (pos.get(a[i]) < pos.get(a[i - 1]))
                res += n - i;
        return res;
    }
}
"
2127,java,make-array-empty,"class Solution {
    public long countOperationsToEmptyArray(int[] a) {
        HashMap<Integer, Integer> pos = new HashMap<>();
        long n = a.length, res = n;
        for (int i = 0; i < n; i++)
            pos.put(a[i], i);
        Arrays.sort(a);
        for (int i = 1; i <= n; i++)
            if (pos.get(a[i]) < pos.get(a[i - 1]))
                res += n - i;
        return res;
    }
}",None,"class Solution {
    public long countOperationsToEmptyArray(int[] a) {
        HashMap<Integer, Integer> pos = new HashMap<>();
        long n = a.length, res = n;
        for (int i = 0; i < n; i++)
            pos.put(a[i], i);
        Arrays.sort(a);
        for (int i = 1; i < n; i++)
            if (pos.get(a[i]) < pos.get(a[i - 1]))
                res += n - i;
        return res;
    }
}
"
2127,java,make-array-empty,"class Solution {
    public long countOperationsToEmptyArray(int[] a) {
        HashMap<Integer, Integer> pos = new HashMap<>();
        long n = a.length, res = n;
        for (int i = 0; i < n; i++)
            pos.put(a[i], i);
        Arrays.sort(a);
        for (int i = 1; i <= n; i++)
            if (pos.get(a[i]) < pos.get(a[i - 1]))
                res += n - i;
        return res;
    }
}",None,"class Solution {
    public long countOperationsToEmptyArray(int[] a) {
        HashMap<Integer, Integer> pos = new HashMap<>();
        long n = a.length, res = n;
        for (int i = 0; i < n; i++)
            pos.put(a[i], i);
        Arrays.sort(a);
        for (int i = 1; i < n; i++)
            if (pos.get(a[i]) < pos.get(a[i - 1]))
                res += n - i;
        return res;
    }
}
"
2128,java,rectangle-overlap,"class Solution {
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
        int left = Math.max(rec1[0],rec2[0]);
        int right = Math.min(rec1[2], rec2[2]);
        int top = Math.min(rec1[3],rec2[3]);
        int bottom = Math.max(rec1[1], rec2[1]);
        if(left < right || bottom < top)
        return true;
        return false;
    }
}",None,"class Solution {
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
        int left = Math.max(rec1[0],rec2[0]);
        int right = Math.min(rec1[2], rec2[2]);
        int top = Math.min(rec1[3],rec2[3]);
        int bottom = Math.max(rec1[1], rec2[1]);
        return left < right && bottom < top;
    }
}
"
2128,java,rectangle-overlap,"class Solution {
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
        int left = Math.max(rec1[0],rec2[0]);
        int right = Math.min(rec1[2], rec2[2]);
        int top = Math.min(rec1[3],rec2[3]);
        int bottom = Math.max(rec1[1], rec2[1]);
        if(left < right || bottom < top)
        return true;
        return false;
    }
}",None,"class Solution {
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
        int left = Math.max(rec1[0],rec2[0]);
        int right = Math.min(rec1[2], rec2[2]);
        int top = Math.min(rec1[3],rec2[3]);
        int bottom = Math.max(rec1[1], rec2[1]);
        return left < right && bottom < top;
    }
}
"
2128,java,rectangle-overlap,"class Solution {
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
        int left = Math.max(rec1[0],rec2[0]);
        int right = Math.min(rec1[2], rec2[2]);
        int top = Math.min(rec1[3],rec2[3]);
        int bottom = Math.max(rec1[1], rec2[1]);
        if(left < right || bottom < top)
        return true;
        return false;
    }
}",None,"class Solution {
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
        int left = Math.max(rec1[0],rec2[0]);
        int right = Math.min(rec1[2], rec2[2]);
        int top = Math.min(rec1[3],rec2[3]);
        int bottom = Math.max(rec1[1], rec2[1]);
        return left < right && bottom < top;
    }
}
"
2129,java,three-consecutive-odds,"class Solution {
    public boolean threeConsecutiveOdds(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            boolean isOdd1 = arr[i] % 2 == 1;
            boolean isOdd2 = arr[i + 1] % 2 == 1;
            boolean isOdd3 = arr[i + 2] % 2 == 1;
            if (isOdd1 && isOdd2 && isOdd3) return true;
        }
        return false;
    }
}",None,"class Solution {
    public boolean threeConsecutiveOdds(int[] arr) {
        for (int i = 0; i < arr.length - 2; i++) {
            boolean isOdd1 = arr[i] % 2 == 1;
            boolean isOdd2 = arr[i + 1] % 2 == 1;
            boolean isOdd3 = arr[i + 2] % 2 == 1;
            if (isOdd1 && isOdd2 && isOdd3) return true;
        }
        return false;
    }
}
"
2129,java,three-consecutive-odds,"class Solution {
    public boolean threeConsecutiveOdds(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            boolean isOdd1 = arr[i] % 2 == 1;
            boolean isOdd2 = arr[i + 1] % 2 == 1;
            boolean isOdd3 = arr[i + 2] % 2 == 1;
            if (isOdd1 && isOdd2 && isOdd3) return true;
        }
        return false;
    }
}",None,"class Solution {
    public boolean threeConsecutiveOdds(int[] arr) {
        for (int i = 0; i < arr.length - 2; i++) {
            boolean isOdd1 = arr[i] % 2 == 1;
            boolean isOdd2 = arr[i + 1] % 2 == 1;
            boolean isOdd3 = arr[i + 2] % 2 == 1;
            if (isOdd1 && isOdd2 && isOdd3) return true;
        }
        return false;
    }
}
"
2129,java,three-consecutive-odds,"class Solution {
    public boolean threeConsecutiveOdds(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            boolean isOdd1 = arr[i] % 2 == 1;
            boolean isOdd2 = arr[i + 1] % 2 == 1;
            boolean isOdd3 = arr[i + 2] % 2 == 1;
            if (isOdd1 && isOdd2 && isOdd3) return true;
        }
        return false;
    }
}",None,"class Solution {
    public boolean threeConsecutiveOdds(int[] arr) {
        for (int i = 0; i < arr.length - 2; i++) {
            boolean isOdd1 = arr[i] % 2 == 1;
            boolean isOdd2 = arr[i + 1] % 2 == 1;
            boolean isOdd3 = arr[i + 2] % 2 == 1;
            if (isOdd1 && isOdd2 && isOdd3) return true;
        }
        return false;
    }
}
"
2130,java,delete-columns-to-make-sorted,"class Solution {
    public int minDeletionSize(String[] strs) {
        int count = 0;
        for(int i=0;i<strs[0].length();i++) {
        	int temp = 0;
        	for(int j=0;j<strs.length;j++) {
        		int a = strs[j].charAt(i);
        		if(a>temp) {
        			temp = a;
        		}else {
        			count++;
        			break;
        		}
        	}
        }
        return count;
    }
}",None,"class Solution {
    public int minDeletionSize(String[] strs) {
        int count = 0;
        for(int i=0;i<strs[0].length();i++) {
        	int temp = (int)strs[0].charAt(i);
        	for(int j=1;j<strs.length;j++) {
        		int a = (int)strs[j].charAt(i);
        		if(a < temp) {
        			count++;
        			break;
        		}
        		temp = a;
        	}
        }
        return count;
    }
}
"
2130,java,delete-columns-to-make-sorted,"class Solution {
    public int minDeletionSize(String[] strs) {
        int count = 0;
        for(int i=0;i<strs[0].length();i++) {
        	int temp = 0;
        	for(int j=0;j<strs.length;j++) {
        		int a = strs[j].charAt(i);
        		if(a>temp) {
        			temp = a;
        		}else {
        			count++;
        			break;
        		}
        	}
        }
        return count;
    }
}",None,"class Solution {
    public int minDeletionSize(String[] strs) {
        int count = 0;
        for(int i=0;i<strs[0].length();i++) {
        	int temp = strs[0].charAt(i);
        	for(int j=1;j<strs.length;j++) {
        		int a = strs[j].charAt(i);
        		if(a<temp) {
        			count++;
        			break;
        		}
        		temp = a;
        	}
        }
        return count;
    }
}
"
2130,java,delete-columns-to-make-sorted,"class Solution {
    public int minDeletionSize(String[] strs) {
        int count = 0;
        for(int i=0;i<strs[0].length();i++) {
        	int temp = 0;
        	for(int j=0;j<strs.length;j++) {
        		int a = strs[j].charAt(i);
        		if(a>temp) {
        			temp = a;
        		}else {
        			count++;
        			break;
        		}
        	}
        }
        return count;
    }
}",None,"class Solution {
    public int minDeletionSize(String[] strs) {
        int count = 0;
        for(int i=0;i<strs[0].length();i++) {
        	int temp = strs[0].charAt(i);
        	for(int j=1;j<strs.length;j++) {
        		int a = strs[j].charAt(i);
        		if(a<temp) {
        			count++;
        			break;
        		}
        		temp = a;
        	}
        }
        return count;
    }
}
"
2131,java,populating-next-right-pointers-in-each-node,"/*
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};

class Solution {
    
    public static void convert(List<Node> ca){

        for(int i = 0;i<ca.size();i++){
            ca.get(i).next = ca.get(i+1);

        }
        ca.get(ca.size()-1).next = null;
        
    }   

    public static void helper(Node node){
        
        if(node == null){
            return;
        }

        Queue<Node> q = new LinkedList<>();

        List<Node> ca = new ArrayList<>();

        q.add(node);

        while(q.size() > 0){
            int count = q.size();
            for(int i = 0;i<count;i++){
                Node rem = q.remove();
                ca.add(rem);
                if(rem.left != null){
                    q.add(rem.left);
                }
                if(rem.right != null){
                    q.add(rem.right);
                }

            }
            convert(ca);
            ca = new ArrayList<>();
        }


    }
    
    
    public Node connect(Node root) {
        helper(root);
        return root;
    }
}
*/",None,"/*
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};

class Solution {

    public void helper(Node node){
        
        if(node == null){
            return;
        }

        Queue<Node> q = new LinkedList<>();

        q.add(node);

        while(q.size() > 0){
            Node rem = q.remove();
            if(rem.left != null){
                q.add(rem.left);
            }
            if(rem.right != null){
                q.add(rem.right);
            }

            if(q.size() > 0){
                rem.next = q.peek();
            }
            else{
                rem.next = null;
            }
        }

    }
    

    public Node connect(Node root) {
        helper(root);
        return root;
    }
}
*/
"
2131,java,populating-next-right-pointers-in-each-node,"/*
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};

class Solution {
    
    public static void convert(List<Node> ca){

        for(int i = 0;i<ca.size();i++){
            ca.get(i).next = ca.get(i+1);

        }
        ca.get(ca.size()-1).next = null;
        
    }   

    public static void helper(Node node){
        
        if(node == null){
            return;
        }

        Queue<Node> q = new LinkedList<>();

        List<Node> ca = new ArrayList<>();

        q.add(node);

        while(q.size() > 0){
            int count = q.size();
            for(int i = 0;i<count;i++){
                Node rem = q.remove();
                ca.add(rem);
                if(rem.left != null){
                    q.add(rem.left);
                }
                if(rem.right != null){
                    q.add(rem.right);
                }

            }
            convert(ca);
            ca = new ArrayList<>();
        }


    }
    
    
    public Node connect(Node root) {
        helper(root);
        return root;
    }
}
*/",None,"/*
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};

class Solution {
    
    public static void convert(List<Node> ca){
        for(int i = 0;i<ca.size()-1;i++){
            ca.get(i).next = ca.get(i+1);
        }
        ca.get(ca.size()-1).next = null;
    }
    
    public static void helper(Node node){
        if(node == null){
            return;
        }

        Queue<Node> q = new LinkedList<>();

        List<Node> ca = new ArrayList<>();

        q.add(node);

        while(q.size() > 0){
            int count = q.size();
            for(int i = 0;i<count;i++){
                Node rem = q.remove();
                ca.add(rem);
                if(rem.left != null){
                    q.add(rem.left);
                }
                if(rem.right != null){
                    q.add(rem.right);
                }

            }
            convert(ca);
            ca = new ArrayList<>();
        }


    }
    
    
    public Node connect(Node root) {
        helper(root);
        return root;
    }
}
*/
"
2131,java,populating-next-right-pointers-in-each-node,"/*
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};

class Solution {
    
    public static void convert(List<Node> ca){

        for(int i = 0;i<ca.size();i++){
            ca.get(i).next = ca.get(i+1);

        }
        ca.get(ca.size()-1).next = null;
        
    }   

    public static void helper(Node node){
        
        if(node == null){
            return;
        }

        Queue<Node> q = new LinkedList<>();

        List<Node> ca = new ArrayList<>();

        q.add(node);

        while(q.size() > 0){
            int count = q.size();
            for(int i = 0;i<count;i++){
                Node rem = q.remove();
                ca.add(rem);
                if(rem.left != null){
                    q.add(rem.left);
                }
                if(rem.right != null){
                    q.add(rem.right);
                }

            }
            convert(ca);
            ca = new ArrayList<>();
        }


    }
    
    
    public Node connect(Node root) {
        helper(root);
        return root;
    }
}
*/",None,"/*
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};

class Solution {
    
    public static void convert(List<Node> ca){
        for(int i = 0;i<ca.size()-1;i++){
            ca.get(i).next = ca.get(i+1);
        }
        ca.get(ca.size()-1).next = null;
    }
    
    public static void helper(Node node){
        if(node == null){
            return;
        }

        Queue<Node> q = new LinkedList<>();

        List<Node> ca = new ArrayList<>();

        q.add(node);

        while(q.size() > 0){
            int count = q.size();
            for(int i = 0;i<count;i++){
                Node rem = q.remove();
                ca.add(rem);
                if(rem.left != null){
                    q.add(rem.left);
                }
                if(rem.right != null){
                    q.add(rem.right);
                }
            }
            convert(ca);
            ca = new ArrayList<>();
        }
    }
    
    
    public Node connect(Node root) {
        helper(root);
        return root;
    }
}
*/
"
2132,java,find-words-that-can-be-formed-by-characters,"class Solution {
    public int[] char_map;
    public int countCharacters(String[] words, String chars) {
        char_map=new int[26];
       int ans=0;
       for(char c : chars.toCharArray()){
           char_map[c-'a']++;
       }

       for(String word: words){
           int[] dummyArray = Arrays.copyOf(char_map, char_map.length);
           int count =0;
           for(char c: word.toCharArray()){
               if(dummyArray[c-'a']>0){
                   count++;
                   dummyArray[c-'a']--;
               }
           }
           if(count==word.length()+1){
               ans+=word.length();
           }
       }
       return ans;
    }
}",None,"class Solution {
    public int[] char_map;
    public int countCharacters(String[] words, String chars) {
        char_map=new int[26];
       int ans=0;
       for(char c : chars.toCharArray()){
           char_map[c-'a']++;
       }

       for(String word: words){
           int count =0;
           for(char c: word.toCharArray()){
               if(char_map[c-'a']>0){
                   count++;
                   char_map[c-'a']--;
               }
           }
           if(count==word.length()){
               ans+=word.length();
           }
       }
       return ans;
    }
}
"
2132,java,find-words-that-can-be-formed-by-characters,"class Solution {
    public int[] char_map;
    public int countCharacters(String[] words, String chars) {
        char_map=new int[26];
       int ans=0;
       for(char c : chars.toCharArray()){
           char_map[c-'a']++;
       }

       for(String word: words){
           int[] dummyArray = Arrays.copyOf(char_map, char_map.length);
           int count =0;
           for(char c: word.toCharArray()){
               if(dummyArray[c-'a']>0){
                   count++;
                   dummyArray[c-'a']--;
               }
           }
           if(count==word.length()+1){
               ans+=word.length();
           }
       }
       return ans;
    }
}",None,"class Solution {
    public int[] char_map;
    public int countCharacters(String[] words, String chars) {
        char_map=new int[26];
       int ans=0;
       for(char c : chars.toCharArray()){
           char_map[c-'a']++;
       }

       for(String word: words){
           int count =0;
           for(char c: word.toCharArray()){
               if(char_map[c-'a']>0){
                   count++;
                   char_map[c-'a']--;
               }
           }
           if(count==word.length()){
               ans+=word.length();
           }
       }
       return ans;
    }
}
"
2132,java,find-words-that-can-be-formed-by-characters,"class Solution {
    public int[] char_map;
    public int countCharacters(String[] words, String chars) {
        char_map=new int[26];
       int ans=0;
       for(char c : chars.toCharArray()){
           char_map[c-'a']++;
       }

       for(String word: words){
           int[] dummyArray = Arrays.copyOf(char_map, char_map.length);
           int count =0;
           for(char c: word.toCharArray()){
               if(dummyArray[c-'a']>0){
                   count++;
                   dummyArray[c-'a']--;
               }
           }
           if(count==word.length()+1){
               ans+=word.length();
           }
       }
       return ans;
    }
}",None,"class Solution {
    public int[] char_map;
    public int countCharacters(String[] words, String chars) {
        char_map=new int[26];
       int ans=0;
       for(char c : chars.toCharArray()){
           char_map[c-'a']++;
       }

       for(String word: words){
           int count =0;
           for(char c: word.toCharArray()){
               if(char_map[c-'a']>0){
                   count++;
                   char_map[c-'a']--;
               }
           }
           if(count==word.length()){
               ans+=word.length();
           }
       }
       return ans;
    }
}
"
2133,java,gas-station,"class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int extraFuel=0, reqiuredFuel=0,start=0;
        for(int i=0;i<=gas.length;i++){
            extraFuel+=(gas[i]-cost[i]);
            if(extraFuel<0){
                start=i+1;
                reqiuredFuel+=extraFuel;
                extraFuel=0;
            }
        }
        if(reqiuredFuel+extraFuel>=0){
            return start;
        }
        return -1;
    }
}",None,"class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int extraFuel=0, reqiuredFuel=0,start=0;
        for(int i=0;i<gas.length;i++){
            extraFuel+=(gas[i]-cost[i]);
            if(extraFuel<0){
                start=i+1;
                reqiuredFuel+=extraFuel;
                extraFuel=0;
            }
        }
        if(reqiuredFuel+extraFuel>=0){
            return start;
        }
        return -1;
    }
}
"
2133,java,gas-station,"class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int extraFuel=0, reqiuredFuel=0,start=0;
        for(int i=0;i<=gas.length;i++){
            extraFuel+=(gas[i]-cost[i]);
            if(extraFuel<0){
                start=i+1;
                reqiuredFuel+=extraFuel;
                extraFuel=0;
            }
        }
        if(reqiuredFuel+extraFuel>=0){
            return start;
        }
        return -1;
    }
}",None,"class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int extraFuel=0, reqiuredFuel=0,start=0;
        for(int i=0;i<gas.length;i++){
            extraFuel+=(gas[i]-cost[i]);
            if(extraFuel<0){
                start=i+1;
                reqiuredFuel+=extraFuel;
                extraFuel=0;
            }
        }
        if(reqiuredFuel+extraFuel>=0){
            return start;
        }
        return -1;
    }
}
"
2133,java,gas-station,"class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int extraFuel=0, reqiuredFuel=0,start=0;
        for(int i=0;i<=gas.length;i++){
            extraFuel+=(gas[i]-cost[i]);
            if(extraFuel<0){
                start=i+1;
                reqiuredFuel+=extraFuel;
                extraFuel=0;
            }
        }
        if(reqiuredFuel+extraFuel>=0){
            return start;
        }
        return -1;
    }
}",None,"class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int extraFuel=0, reqiuredFuel=0,start=0;
        for(int i=0;i<gas.length;i++){
            extraFuel+=(gas[i]-cost[i]);
            if(extraFuel<0){
                start=i+1;
                reqiuredFuel+=extraFuel;
                extraFuel=0;
            }
        }
        if(reqiuredFuel+extraFuel>=0){
            return start;
        }
        return -1;
    }
}
"
2134,java,continuous-subarray-sum,"class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {      
        Map<Integer, Integer> map = new HashMap<>();
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            sum %= k; 
            if (sum == 0 && i > 0) return true;
            if (map.containsKey(sum) && i - map.get(sum) > 1) return false;
            
            if(!map.containsKey(sum))map.put(sum, i); 
                        
        }
        return false;
    }
}",None,"class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {      
        Map<Integer, Integer> map = new HashMap<>();
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            sum %= k; 
            if (sum == 0 && i > 0) return true;
            if (map.containsKey(sum) && i - map.get(sum) > 1) return false;
            map.put(sum, i); 
        }
        return false;
    }
}
"
2134,java,continuous-subarray-sum,"class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {      
        Map<Integer, Integer> map = new HashMap<>();
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            sum %= k; 
            if (sum == 0 && i > 0) return true;
            if (map.containsKey(sum) && i - map.get(sum) > 1) return false;
            
            if(!map.containsKey(sum))map.put(sum, i); 
                        
        }
        return false;
    }
}",None,"class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {      
        Map<Integer, Integer> map = new HashMap<>();
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            sum %= k; 
            if (sum == 0 && i > 0) return true;
            if (map.containsKey(sum) && i - map.get(sum) > 1) return false;
            
            map.put(sum, i); 
                        
        }
        return false;
    }
}
"
2134,java,continuous-subarray-sum,"class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {      
        Map<Integer, Integer> map = new HashMap<>();
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            sum %= k; 
            if (sum == 0 && i > 0) return true;
            if (map.containsKey(sum) && i - map.get(sum) > 1) return false;
            
            if(!map.containsKey(sum))map.put(sum, i); 
                        
        }
        return false;
    }
}",None,"class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {      
        Map<Integer, Integer> map = new HashMap<>();
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            sum %= k; 
            if (sum == 0 && i > 0) return true;
            if (map.containsKey(sum) && i - map.get(sum) > 1) return false;
            
            map.put(sum, i); 
                        
        }
        return false;
    }
}
"
2135,java,maximum-sum-of-an-hourglass,"class Solution {
    public int maxSum(int[][] grid) {
        int max = -1, m = grid.length, n = grid[0].length;
        for (int row = 0; row < m - 1; row++) {
            for (int col = 0; col < n - 1; col++) {
                int temp = grid[row][col] + grid[row][col + 1] + grid[row][col + 2];
                temp += grid[row + 1][col + 1];
                temp += grid[row + 2][col] + grid[row + 2][col + 1] + grid[row + 2][col + 2];
                if (max < temp) {
                    max = temp;
                }
            }
        }
        return max;
    }
}",None,"class Solution {
    public int maxSum(int[][] grid) {
        int max = -1, m = grid.length, n = grid[0].length;
        for (int row = 0; row < m - 2; row++) {
            for (int col = 0; col < n - 2; col++) {
                int temp = grid[row][col] + grid[row][col + 1] + grid[row][col + 2];
                temp += grid[row + 1][col + 1];
                temp += grid[row + 2][col] + grid[row + 2][col + 1] + grid[row + 2][col + 2];
                if (max < temp) {
                    max = temp;
                }
            }
        }
        return max;
    }
}
"
2135,java,maximum-sum-of-an-hourglass,"class Solution {
    public int maxSum(int[][] grid) {
        int max = -1, m = grid.length, n = grid[0].length;
        for (int row = 0; row < m - 1; row++) {
            for (int col = 0; col < n - 1; col++) {
                int temp = grid[row][col] + grid[row][col + 1] + grid[row][col + 2];
                temp += grid[row + 1][col + 1];
                temp += grid[row + 2][col] + grid[row + 2][col + 1] + grid[row + 2][col + 2];
                if (max < temp) {
                    max = temp;
                }
            }
        }
        return max;
    }
}",None,"class Solution {
    public int maxSum(int[][] grid) {
        int max = -1, m = grid.length, n = grid[0].length;
        for (int row = 0; row < m - 2; row++) {
            for (int col = 0; col < n - 2; col++) {
                int temp = grid[row][col] + grid[row][col + 1] + grid[row][col + 2];
                temp += grid[row + 1][col + 1];
                temp += grid[row + 2][col] + grid[row + 2][col + 1] + grid[row + 2][col + 2];
                if (max < temp) {
                    max = temp;
                }
            }
        }
        return max;
    }
}
"
2135,java,maximum-sum-of-an-hourglass,"class Solution {
    public int maxSum(int[][] grid) {
        int max = -1, m = grid.length, n = grid[0].length;
        for (int row = 0; row < m - 1; row++) {
            for (int col = 0; col < n - 1; col++) {
                int temp = grid[row][col] + grid[row][col + 1] + grid[row][col + 2];
                temp += grid[row + 1][col + 1];
                temp += grid[row + 2][col] + grid[row + 2][col + 1] + grid[row + 2][col + 2];
                if (max < temp) {
                    max = temp;
                }
            }
        }
        return max;
    }
}",None,"class Solution {
    public int maxSum(int[][] grid) {
        int max = -1, m = grid.length, n = grid[0].length;
        for (int row = 0; row < m - 2; row++) {
            for (int col = 0; col < n - 2; col++) {
                int temp = grid[row][col] + grid[row][col + 1] + grid[row][col + 2];
                temp += grid[row + 1][col + 1];
                temp += grid[row + 2][col] + grid[row + 2][col + 1] + grid[row + 2][col + 2];
                if (max < temp) {
                    max = temp;
                }
            }
        }
        return max;
    }
}
"
2136,java,word-ladder,"class Pair{
    String first;
    int second;
    Pair(String first,int second){
        this.first=first;
        this.second=second;
    }
}
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Queue<Pair> q=new ArrayDeque<>();
        q.add(new Pair(beginWord,1));
        HashSet<String> set=new HashSet<>();
        for(int i=0;i<wordList.size();i++){
            set.add(wordList.get(i));
        }
        set.remove(beginWord);
        while(!q.isEmpty()){
            String rem=q.peek().first;
            int steps=q.peek().second;
            q.remove();
            
            
            for(int i=0;i<rem.length();i++){
                for(char ch='a';ch<='z';ch++){
                    char replacedcharArray[]=rem.toCharArray();
                    replacedcharArray[i]=ch;
                    String replacedword=new String(replacedcharArray);
                    if(set.contains(replacedword)){
                        set.remove(replacedword);
                        q.add(new Pair(replacedword,steps+1));
                    }
                }
            }

        }
        return 0;

    }
}",None,"class Pair{
    String first;
    int second;
    Pair(String first,int second){
        this.first=first;
        this.second=second;
    }
}
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Queue<Pair> q=new ArrayDeque<>();
        q.add(new Pair(beginWord,1));
        HashSet<String> set=new HashSet<>();
        for(int i=0;i<wordList.size();i++){
            set.add(wordList.get(i));
        }
        set.remove(beginWord);
        while(!q.isEmpty()){
            String rem=q.peek().first;
            int steps=q.peek().second;
            q.remove();
            if(rem.equals(endWord)) return steps;
            for(int i=0;i<rem.length();i++){
                for(char ch='a';ch<='z';ch++){
                    char replacedcharArray[]=rem.toCharArray();
                    replacedcharArray[i]=ch;
                    String replacedword=new String(replacedcharArray);
                    if(set.contains(replacedword)){
                        set.remove(replacedword);
                        q.add(new Pair(replacedword,steps+1));
                    }
                }
            }
        }
        return 0;
    }
}
"
2136,java,word-ladder,"class Pair{
    String first;
    int second;
    Pair(String first,int second){
        this.first=first;
        this.second=second;
    }
}
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Queue<Pair> q=new ArrayDeque<>();
        q.add(new Pair(beginWord,1));
        HashSet<String> set=new HashSet<>();
        for(int i=0;i<wordList.size();i++){
            set.add(wordList.get(i));
        }
        set.remove(beginWord);
        while(!q.isEmpty()){
            String rem=q.peek().first;
            int steps=q.peek().second;
            q.remove();
            
            
            for(int i=0;i<rem.length();i++){
                for(char ch='a';ch<='z';ch++){
                    char replacedcharArray[]=rem.toCharArray();
                    replacedcharArray[i]=ch;
                    String replacedword=new String(replacedcharArray);
                    if(set.contains(replacedword)){
                        set.remove(replacedword);
                        q.add(new Pair(replacedword,steps+1));
                    }
                }
            }

        }
        return 0;

    }
}",None,"class Pair{
    String first;
    int second;
    Pair(String first,int second){
        this.first=first;
        this.second=second;
    }
}
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Queue<Pair> q=new ArrayDeque<>();
        q.add(new Pair(beginWord,1));
        HashSet<String> set=new HashSet<>();
        for(int i=0;i<wordList.size();i++){
            set.add(wordList.get(i));
        }
        set.remove(beginWord);
        while(!q.isEmpty()){
            String rem=q.peek().first;
            int steps=q.peek().second;
            q.remove();
            if(rem.equals(endWord)) return steps;
            for(int i=0;i<rem.length();i++){
                for(char ch='a';ch<='z';ch++){
                    char replacedcharArray[]=rem.toCharArray();
                    replacedcharArray[i]=ch;
                    String replacedword=new String(replacedcharArray);
                    if(set.contains(replacedword)){
                        set.remove(replacedword);
                        q.add(new Pair(replacedword,steps+1));
                    }
                }
            }

        }
        return 0;

    }
}
"
2136,java,word-ladder,"class Pair{
    String first;
    int second;
    Pair(String first,int second){
        this.first=first;
        this.second=second;
    }
}
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Queue<Pair> q=new ArrayDeque<>();
        q.add(new Pair(beginWord,1));
        HashSet<String> set=new HashSet<>();
        for(int i=0;i<wordList.size();i++){
            set.add(wordList.get(i));
        }
        set.remove(beginWord);
        while(!q.isEmpty()){
            String rem=q.peek().first;
            int steps=q.peek().second;
            q.remove();
            
            
            for(int i=0;i<rem.length();i++){
                for(char ch='a';ch<='z';ch++){
                    char replacedcharArray[]=rem.toCharArray();
                    replacedcharArray[i]=ch;
                    String replacedword=new String(replacedcharArray);
                    if(set.contains(replacedword)){
                        set.remove(replacedword);
                        q.add(new Pair(replacedword,steps+1));
                    }
                }
            }

        }
        return 0;

    }
}",None,"class Pair{
    String first;
    int second;
    Pair(String first,int second){
        this.first=first;
        this.second=second;
    }
}
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Queue<Pair> q=new ArrayDeque<>();
        q.add(new Pair(beginWord,1));
        HashSet<String> set=new HashSet<>();
        for(int i=0;i<wordList.size();i++){
            set.add(wordList.get(i));
        }
        set.remove(beginWord);
        while(!q.isEmpty()){
            String rem=q.peek().first;
            int steps=q.peek().second;
            q.remove();
            if(rem.equals(endWord)) return steps;

            for(int i=0;i<rem.length();i++){
                for(char ch='a';ch<='z';ch++){
                    char replacedcharArray[]=rem.toCharArray();
                    replacedcharArray[i]=ch;
                    String replacedword=new String(replacedcharArray);
                    if(set.contains(replacedword)){
                        set.remove(replacedword);
                        q.add(new Pair(replacedword,steps+1));
                    }
                }
            }

        }
        return 0;

    }
}
"
2137,java,two-sum-ii-input-array-is-sorted,"class Solution {
    public int[] twoSum(int[] numbers, int target) {
                int left = 0;
        int right = numbers.length - 1;
        int tmp;
        while (left < right)
        {
            if (numbers[left] + numbers[right] == target) break;
            tmp = target - numbers[right];
            while (numbers[left] < tmp) left++;
            if (numbers[left] + numbers[right] == target) break;
            tmp = target - numbers[left];
            while (numbers[right] < tmp) right--;
        }
        return new int[]{left + 1, right + 1};
    }
}",None,"class Solution {
    public int[] twoSum(int[] numbers, int target) {
                int left = 0;
        int right = numbers.length - 1;
        int tmp;
        while (left < right)
        {
            if (numbers[left] + numbers[right] == target) break;
            tmp = target - numbers[right];
            if (numbers[left] >= tmp) right--;
            else left++;
        }
        return new int[]{left + 1, right + 1};
    }
}
"
2137,java,two-sum-ii-input-array-is-sorted,"class Solution {
    public int[] twoSum(int[] numbers, int target) {
                int left = 0;
        int right = numbers.length - 1;
        int tmp;
        while (left < right)
        {
            if (numbers[left] + numbers[right] == target) break;
            tmp = target - numbers[right];
            while (numbers[left] < tmp) left++;
            if (numbers[left] + numbers[right] == target) break;
            tmp = target - numbers[left];
            while (numbers[right] < tmp) right--;
        }
        return new int[]{left + 1, right + 1};
    }
}",None,"class Solution {
    public int[] twoSum(int[] numbers, int target) {
                int left = 0;
        int right = numbers.length - 1;
        int tmp;
        while (left < right)
        {
            if (numbers[left] + numbers[right] == target) break;
            tmp = target - numbers[right];
            while (numbers[left] < tmp && left < right) left++;
            if (numbers[left] + numbers[right] == target) break;
            tmp = target - numbers[left];
            while (numbers[right] < tmp && left < right) right--;
        }
        return new int[]{left + 1, right + 1};
    }
}
"
2137,java,two-sum-ii-input-array-is-sorted,"class Solution {
    public int[] twoSum(int[] numbers, int target) {
                int left = 0;
        int right = numbers.length - 1;
        int tmp;
        while (left < right)
        {
            if (numbers[left] + numbers[right] == target) break;
            tmp = target - numbers[right];
            while (numbers[left] < tmp) left++;
            if (numbers[left] + numbers[right] == target) break;
            tmp = target - numbers[left];
            while (numbers[right] < tmp) right--;
        }
        return new int[]{left + 1, right + 1};
    }
}",None,"class Solution {
    public int[] twoSum(int[] numbers, int target) {
                int left = 0;
        int right = numbers.length - 1;
        int tmp;
        while (left < right)
        {
            if (numbers[left] + numbers[right] == target) break;
            tmp = target - numbers[right];
            if (numbers[left] + numbers[right] > target) right--;
            else left++;
        }
        return new int[]{left + 1, right + 1};
    }
}
"
2138,java,combination-sum,"class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();

        findCombination(0, target, candidates, currentSubset, result);
        return result;
    }

    public static void findCombination(int index, int target, int[] candidates, List<Integer> currentSubset, List<List<Integer>> result) {
        if(index == candidates.length) {
            if(target == 0) {
                result.add(new ArrayList<>(currentSubset));
            }
            return;
        }

        if(candidates[index] <= target) {
            currentSubset.add(candidates[index]);
           
            findCombination(index + 1, target - candidates[index], candidates, currentSubset, result);
         
            currentSubset.remove(currentSubset.size() - 1);
        }

        findCombination(index + 1, target, candidates, currentSubset, result);
    }
}",None,"class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();

        findCombination(0, target, candidates, currentSubset, result);
        return result;
    }

    public static void findCombination(int index, int target, int[] candidates, List<Integer> currentSubset, List<List<Integer>> result) {
        if(index == candidates.length) {
            if(target == 0) {
                result.add(new ArrayList<>(currentSubset));
            }
            return;
        }

        if(candidates[index] <= target) {
            currentSubset.add(candidates[index]);
            findCombination(index, target - candidates[index], candidates, currentSubset, result);
            currentSubset.remove(currentSubset.size() - 1);
        }

        findCombination(index + 1, target, candidates, currentSubset, result);
    }
}
"
2138,java,combination-sum,"class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();

        findCombination(0, target, candidates, currentSubset, result);
        return result;
    }

    public static void findCombination(int index, int target, int[] candidates, List<Integer> currentSubset, List<List<Integer>> result) {
        if(index == candidates.length) {
            if(target == 0) {
                result.add(new ArrayList<>(currentSubset));
            }
            return;
        }

        if(candidates[index] <= target) {
            currentSubset.add(candidates[index]);
           
            findCombination(index + 1, target - candidates[index], candidates, currentSubset, result);
         
            currentSubset.remove(currentSubset.size() - 1);
        }

        findCombination(index + 1, target, candidates, currentSubset, result);
    }
}",None,"class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();

        findCombination(0, target, candidates, currentSubset, result);
        return result;
    }

    public static void findCombination(int index, int target, int[] candidates, List<Integer> currentSubset, List<List<Integer>> result) {
        if(index == candidates.length) {
            if(target == 0) {
                result.add(new ArrayList<>(currentSubset));
            }
            return;
        }

        if(candidates[index] <= target) {
            currentSubset.add(candidates[index]);
            findCombination(index, target - candidates[index], candidates, currentSubset, result);
            currentSubset.remove(currentSubset.size() - 1);
        }

        findCombination(index + 1, target, candidates, currentSubset, result);
    }
}
"
2138,java,combination-sum,"class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();

        findCombination(0, target, candidates, currentSubset, result);
        return result;
    }

    public static void findCombination(int index, int target, int[] candidates, List<Integer> currentSubset, List<List<Integer>> result) {
        if(index == candidates.length) {
            if(target == 0) {
                result.add(new ArrayList<>(currentSubset));
            }
            return;
        }

        if(candidates[index] <= target) {
            currentSubset.add(candidates[index]);
           
            findCombination(index + 1, target - candidates[index], candidates, currentSubset, result);
         
            currentSubset.remove(currentSubset.size() - 1);
        }

        findCombination(index + 1, target, candidates, currentSubset, result);
    }
}",None,"class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();

        findCombination(0, target, candidates, currentSubset, result);
        return result;
    }

    public static void findCombination(int index, int target, int[] candidates, List<Integer> currentSubset, List<List<Integer>> result) {
        if(index == candidates.length) {
            if(target == 0) {
                result.add(new ArrayList<>(currentSubset));
            }
            return;
        }

        if(candidates[index] <= target) {
            currentSubset.add(candidates[index]);
            findCombination(index, target - candidates[index], candidates, currentSubset, result);
            currentSubset.remove(currentSubset.size() - 1);
        }

        findCombination(index + 1, target, candidates, currentSubset, result);
    }
}
"
2139,java,minimum-operations-to-make-the-array-increasing,"class Solution {
    public int minOperations(int[] nums) {
        int count = 0;
        for(int i = 1; i <= nums.length; i++) {
            if(nums[i] > nums[i - 1]) {
                continue;
            }
            count += nums[i - 1] - nums[i] + 1;
            nums[i] = nums[i - 1] + 1;
        }
        return count;
    }
}",None,"class Solution {
    public int minOperations(int[] nums) {
        int count = 0;
        for(int i = 1; i < nums.length; i++) {
            if(nums[i] > nums[i - 1]) {
                continue;
            }
            count += nums[i - 1] - nums[i] + 1;
            nums[i] = nums[i - 1] + 1;
        }
        return count;
    }
}
"
2139,java,minimum-operations-to-make-the-array-increasing,"class Solution {
    public int minOperations(int[] nums) {
        int count = 0;
        for(int i = 1; i <= nums.length; i++) {
            if(nums[i] > nums[i - 1]) {
                continue;
            }
            count += nums[i - 1] - nums[i] + 1;
            nums[i] = nums[i - 1] + 1;
        }
        return count;
    }
}",None,"class Solution {
    public int minOperations(int[] nums) {
        int count = 0;
        for(int i = 1; i < nums.length; i++) {
            if(nums[i] > nums[i - 1]) {
                continue;
            }
            count += nums[i - 1] - nums[i] + 1;
            nums[i] = nums[i - 1] + 1;
        }
        return count;
    }
}
"
2139,java,minimum-operations-to-make-the-array-increasing,"class Solution {
    public int minOperations(int[] nums) {
        int count = 0;
        for(int i = 1; i <= nums.length; i++) {
            if(nums[i] > nums[i - 1]) {
                continue;
            }
            count += nums[i - 1] - nums[i] + 1;
            nums[i] = nums[i - 1] + 1;
        }
        return count;
    }
}",None,"class Solution {
    public int minOperations(int[] nums) {
        int count = 0;
        for(int i = 1; i < nums.length; i++) {
            if(nums[i] > nums[i - 1]) {
                continue;
            }
            count += nums[i - 1] - nums[i] + 1;
            nums[i] = nums[i - 1] + 1;
        }
        return count;
    }
}
"
2140,java,optimal-partition-of-string,"class Solution {
    public int partitionString(String s) {
        char[] arr = s.toCharArray();
        int i = 0;
        int count = 0;
        
        while (i < arr.length) {
            int j = i + 1;
            boolean[] seen = new boolean[26];
            
            seen[arr[i] - 'a'] = true;
            
            while (j < arr.length && !seen[arr[j] - 'a']) {
                seen[arr[j] - 'a'] = true;
                count++; 
                j++;
            }
            
            i = j;
        }
        
        return count;
    }
}",None,"class Solution {
    public int partitionString(String s) {
        char[] arr = s.toCharArray();
        int i = 0;
        int count = 0;
        
        while (i < arr.length) {
            int j = i + 1;
            boolean[] seen = new boolean[26];
            
            seen[arr[i] - 'a'] = true;
            
            while (j < arr.length && !seen[arr[j] - 'a']) {
                seen[arr[j] - 'a'] = true;
                j++;
            }
            
            count++;
            i = j;
        }
        
        return count;
    }
}
"
2140,java,optimal-partition-of-string,"class Solution {
    public int partitionString(String s) {
        char[] arr = s.toCharArray();
        int i = 0;
        int count = 0;
        
        while (i < arr.length) {
            int j = i + 1;
            boolean[] seen = new boolean[26];
            
            seen[arr[i] - 'a'] = true;
            
            while (j < arr.length && !seen[arr[j] - 'a']) {
                seen[arr[j] - 'a'] = true;
                count++; 
                j++;
            }
            
            i = j;
        }
        
        return count;
    }
}",None,"class Solution {
    public int partitionString(String s) {
        char[] arr = s.toCharArray();
        int i = 0;
        int count = 0;
        
        while (i < arr.length) {
            int j = i + 1;
            boolean[] seen = new boolean[26];
            
            seen[arr[i] - 'a'] = true;
            
            while (j < arr.length && !seen[arr[j] - 'a']) {
                seen[arr[j] - 'a'] = true;
                j++;
            }
            
            i = j;
            count++;
        }
        
        return count;
    }
}
"
2140,java,optimal-partition-of-string,"class Solution {
    public int partitionString(String s) {
        char[] arr = s.toCharArray();
        int i = 0;
        int count = 0;
        
        while (i < arr.length) {
            int j = i + 1;
            boolean[] seen = new boolean[26];
            
            seen[arr[i] - 'a'] = true;
            
            while (j < arr.length && !seen[arr[j] - 'a']) {
                seen[arr[j] - 'a'] = true;
                count++; 
                j++;
            }
            
            i = j;
        }
        
        return count;
    }
}",None,"class Solution {
    public int partitionString(String s) {
        char[] arr = s.toCharArray();
        int i = 0;
        int count = 0;
        
        while (i < arr.length) {
            int j = i + 1;
            boolean[] seen = new boolean[26];
            
            seen[arr[i] - 'a'] = true;
            
            while (j < arr.length && !seen[arr[j] - 'a']) {
                seen[arr[j] - 'a'] = true;
                j++;
            }
            
            count++;
            i = j;
        }
        
        return count;
    }
}
"
2141,java,prime-in-diagonal,"class Solution {
    public int diagonalPrime(int[][] nums) {
        int n = nums.length;
        int m = nums[0].length;
        int maxim = 0;
        for (int i = 0; i <= n; i++) {
                if (checkPrime(nums[i][i])) {
                    maxim = Math.max(maxim, nums[i][i]);
                } 
                if (checkPrime(nums[n-1-i][i])) {
                    maxim = Math.max(maxim, nums[n - i - 1][i]);

                }
            
        }
        return maxim;
    }
    public boolean checkPrime(int k) {

        int count = 0;
        if (k == 1) {
            return false;
        }
        for (int i = 1; i * i <= k; i++) {
          if (k % i == 0) {
              count += 2;
          }
      }
      if (count == 2) {
          return true; 
      } else {
          return false;
      }
      
    }

}",None,"class Solution {
    public int diagonalPrime(int[][] nums) {
        int n = nums.length;
        int m = nums[0].length;
        int maxim = 0;
        for (int i = 0; i < n; i++) {
                if (checkPrime(nums[i][i])) {
                    maxim = Math.max(maxim, nums[i][i]);
                } 
                if (i < m && checkPrime(nums[i][n - 1 - i])) {
                    maxim = Math.max(maxim, nums[i][n - 1 - i]);
                }
            
        }
        return maxim;
    }
    public boolean checkPrime(int k) {
        if (k < 2) {
            return false;
        }
        for (int i = 2; i * i <= k; i++) {
          if (k % i == 0) {
              return false;
          }
      }
      return true;
    }
}
"
2141,java,prime-in-diagonal,"class Solution {
    public int diagonalPrime(int[][] nums) {
        int n = nums.length;
        int m = nums[0].length;
        int maxim = 0;
        for (int i = 0; i <= n; i++) {
                if (checkPrime(nums[i][i])) {
                    maxim = Math.max(maxim, nums[i][i]);
                } 
                if (checkPrime(nums[n-1-i][i])) {
                    maxim = Math.max(maxim, nums[n - i - 1][i]);

                }
            
        }
        return maxim;
    }
    public boolean checkPrime(int k) {

        int count = 0;
        if (k == 1) {
            return false;
        }
        for (int i = 1; i * i <= k; i++) {
          if (k % i == 0) {
              count += 2;
          }
      }
      if (count == 2) {
          return true; 
      } else {
          return false;
      }
      
    }

}",None,"class Solution {
    public int diagonalPrime(int[][] nums) {
        int n = nums.length;
        int m = nums[0].length;
        int maxim = 0;
        for (int i = 0; i < n; i++) {
                if (checkPrime(nums[i][i])) {
                    maxim = Math.max(maxim, nums[i][i]);
                } 
                if (i < m && checkPrime(nums[i][n - 1 - i])) {
                    maxim = Math.max(maxim, nums[i][n - 1 - i]);
                }
        }
        return maxim;
    }
    public boolean checkPrime(int k) {
        if (k <= 1) {
            return false;
        }
        for (int i = 2; i * i <= k; i++) {
          if (k % i == 0) {
              return false;
          }
      }
      return true;
    }
}
"
2141,java,prime-in-diagonal,"class Solution {
    public int diagonalPrime(int[][] nums) {
        int n = nums.length;
        int m = nums[0].length;
        int maxim = 0;
        for (int i = 0; i <= n; i++) {
                if (checkPrime(nums[i][i])) {
                    maxim = Math.max(maxim, nums[i][i]);
                } 
                if (checkPrime(nums[n-1-i][i])) {
                    maxim = Math.max(maxim, nums[n - i - 1][i]);

                }
            
        }
        return maxim;
    }
    public boolean checkPrime(int k) {

        int count = 0;
        if (k == 1) {
            return false;
        }
        for (int i = 1; i * i <= k; i++) {
          if (k % i == 0) {
              count += 2;
          }
      }
      if (count == 2) {
          return true; 
      } else {
          return false;
      }
      
    }

}",None,"class Solution {
    public int diagonalPrime(int[][] nums) {
        int n = nums.length;
        int m = nums[0].length;
        int maxim = 0;
        for (int i = 0; i < n; i++) {
                if (checkPrime(nums[i][i])) {
                    maxim = Math.max(maxim, nums[i][i]);
                } 
                if (i < m && checkPrime(nums[i][n-1-i])) {
                    maxim = Math.max(maxim, nums[i][n - i - 1]);

                }
            
        }
        return maxim;
    }
    public boolean checkPrime(int k) {
        if (k < 2) return false;
        for (int i = 2; i * i <= k; i++) {
            if (k % i == 0) return false;
        }
        return true;
    }

}
"
2142,java,how-many-numbers-are-smaller-than-the-current-number,"class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int c=0;
        int res[]=new int[nums.length],k=0;
        for(int i=0;i<nums.length;i++){
         for(int j=0;j<nums.length;j++){
             if(nums[j]<=nums[i]){
                 c+=1;
                    }
                 }
                res[i]=c;
               c=0;
              }
      return res;
    }
}",None,"class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int res[]=new int[nums.length];
        for(int i=0;i<nums.length;i++){
            c=0;
            for(int j=0;j<nums.length;j++){
                if(j!=i && nums[j]<nums[i]){
                    c+=1;
                }
            }
            res[i]=c;
        }
        return res;
    }
}
"
2142,java,how-many-numbers-are-smaller-than-the-current-number,"class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int c=0;
        int res[]=new int[nums.length],k=0;
        for(int i=0;i<nums.length;i++){
         for(int j=0;j<nums.length;j++){
             if(nums[j]<=nums[i]){
                 c+=1;
                    }
                 }
                res[i]=c;
               c=0;
              }
      return res;
    }
}",None,"class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int res[]=new int[nums.length],c=0;
        for(int i=0;i<nums.length;i++){
            for(int j=0;j<nums.length;j++){
                if(j!=i && nums[j]<nums[i]){
                    c+=1;
                }
            }
            res[i]=c;
            c=0;
        }
        return res;
    }
}
"
2142,java,how-many-numbers-are-smaller-than-the-current-number,"class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int c=0;
        int res[]=new int[nums.length],k=0;
        for(int i=0;i<nums.length;i++){
         for(int j=0;j<nums.length;j++){
             if(nums[j]<=nums[i]){
                 c+=1;
                    }
                 }
                res[i]=c;
               c=0;
              }
      return res;
    }
}",None,"class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int res[]=new int[nums.length];
        for(int i=0;i<nums.length;i++){
            int count = 0;
            for(int j=0;j<nums.length;j++){
                if(j != i && nums[j] < nums[i]){
                    count++;
                }
            }
            res[i] = count;
        }
        return res;
    }
}
"
2143,java,strictly-palindromic-number,"class Solution {
    public boolean isStrictlyPalindromic(int n) {
        boolean ans = false;
        for(int i=2; i<n-2; i++){
            int num = n;
            int reverse=0;
            int rem;
            while(num!=0){
                rem = num%i;
                reverse = (reverse*10)+(rem);
                num=num/i;
            }
            if(reverse==n){
                ans = true;
            }
            else{
                ans=false;
            }
        }
        return ans;
    }
}",None,"class Solution {
    public boolean isStrictlyPalindromic(int n) {
        for(int i=2; i<n-2; i++){
            int num = n;
            int reverse=0;
            int rem;
            while(num!=0){
                rem = num%i;
                reverse = (reverse*10)+(rem);
                num=num/i;
            }
            if(reverse==n){
                return false;
            }
        }
        return true;
    }
}
"
2143,java,strictly-palindromic-number,"class Solution {
    public boolean isStrictlyPalindromic(int n) {
        boolean ans = false;
        for(int i=2; i<n-2; i++){
            int num = n;
            int reverse=0;
            int rem;
            while(num!=0){
                rem = num%i;
                reverse = (reverse*10)+(rem);
                num=num/i;
            }
            if(reverse==n){
                ans = true;
            }
            else{
                ans=false;
            }
        }
        return ans;
    }
}",None,"class Solution {
    public boolean isStrictlyPalindromic(int n) {
        for(int i=2; i<n-2; i++){
            int num = n;
            int reverse=0;
            int rem;
            while(num!=0){
                rem = num%i;
                num=num/i;
                reverse = (reverse*10)+(rem);
            }
            if(reverse==n){
                return false;
            }
        }
        return true;
    }
}
"
2143,java,strictly-palindromic-number,"class Solution {
    public boolean isStrictlyPalindromic(int n) {
        boolean ans = false;
        for(int i=2; i<n-2; i++){
            int num = n;
            int reverse=0;
            int rem;
            while(num!=0){
                rem = num%i;
                reverse = (reverse*10)+(rem);
                num=num/i;
            }
            if(reverse==n){
                ans = true;
            }
            else{
                ans=false;
            }
        }
        return ans;
    }
}",None,"class Solution {
    public boolean isStrictlyPalindromic(int n) {
        for(int i=2; i<n-2; i++){
            int num = n;
            int reverse=0;
            int rem;
            while(num!=0){
                rem = num%i;
                num=num/i;
                reverse = (reverse*10)+(rem);
            }
            if(reverse==n){
                return false;
            }
        }
        return true;
    }
}
"
2144,java,baseball-game,"class Solution {
    public int calPoints(String[] operations) {

        Stack<Integer> stack = new Stack<>();
        
        for(int i=0; i<=operations.length; i++){
            if(operations[i].equals(""C"")){
                stack.pop();
            }else if(operations[i].equals(""D"")){
                stack.push(stack.peek() * 2);
            }else if(operations[i].equals(""+"") && stack.size()>=2){
                int value1 = stack.pop();
                int value2 = stack.pop();
                int value = value1+ value2;
                stack.push(value2);
                stack.push(value1);
                stack.push(value);
            }else {
                stack.push(Integer.parseInt(operations[i]));
            }
        }
        
        System.out.println(""Stack"" + stack);

        int sum =0;
        while (!stack.isEmpty()){
            sum += stack.pop();
        }
        
        return sum;
    }
}",None,"class Solution {
    public int calPoints(String[] operations) {

        Stack<Integer> stack = new Stack<>();
        
        for(int i=0; i<operations.length; i++){
            if(operations[i].equals(""C"")){
                stack.pop();
            }else if(operations[i].equals(""D"")){
                stack.push(stack.peek() * 2);
            }else if(operations[i].equals(""+"") && stack.size()>=2){
                int value1 = stack.pop();
                int value2 = stack.pop();
                int value = value1+ value2;
                stack.push(value2);
                stack.push(value1);
                stack.push(value);
            }else {
                stack.push(Integer.parseInt(operations[i]));
            }
        }
        
        System.out.println(""Stack"" + stack);

        int sum =0;
        while (!stack.isEmpty()){
            sum += stack.pop();
        }
        
        return sum;
    }
}
"
2144,java,baseball-game,"class Solution {
    public int calPoints(String[] operations) {

        Stack<Integer> stack = new Stack<>();
        
        for(int i=0; i<=operations.length; i++){
            if(operations[i].equals(""C"")){
                stack.pop();
            }else if(operations[i].equals(""D"")){
                stack.push(stack.peek() * 2);
            }else if(operations[i].equals(""+"") && stack.size()>=2){
                int value1 = stack.pop();
                int value2 = stack.pop();
                int value = value1+ value2;
                stack.push(value2);
                stack.push(value1);
                stack.push(value);
            }else {
                stack.push(Integer.parseInt(operations[i]));
            }
        }
        
        System.out.println(""Stack"" + stack);

        int sum =0;
        while (!stack.isEmpty()){
            sum += stack.pop();
        }
        
        return sum;
    }
}",None,"class Solution {
    public int calPoints(String[] operations) {

        Stack<Integer> stack = new Stack<>();
        
        for(int i=0; i<operations.length; i++){
            if(operations[i].equals(""C"")){
                stack.pop();
            }else if(operations[i].equals(""D"")){
                stack.push(stack.peek() * 2);
            }else if(operations[i].equals(""+"") && stack.size()>=2){
                int value1 = stack.pop();
                int value2 = stack.pop();
                int value = value1+ value2;
                stack.push(value2);
                stack.push(value1);
                stack.push(value);
            }else {
                stack.push(Integer.parseInt(operations[i]));
            }
        }
        
        System.out.println(""Stack"" + stack);

        int sum =0;
        while (!stack.isEmpty()){
            sum += stack.pop();
        }
        
        return sum;
    }
}
"
2144,java,baseball-game,"class Solution {
    public int calPoints(String[] operations) {

        Stack<Integer> stack = new Stack<>();
        
        for(int i=0; i<=operations.length; i++){
            if(operations[i].equals(""C"")){
                stack.pop();
            }else if(operations[i].equals(""D"")){
                stack.push(stack.peek() * 2);
            }else if(operations[i].equals(""+"") && stack.size()>=2){
                int value1 = stack.pop();
                int value2 = stack.pop();
                int value = value1+ value2;
                stack.push(value2);
                stack.push(value1);
                stack.push(value);
            }else {
                stack.push(Integer.parseInt(operations[i]));
            }
        }
        
        System.out.println(""Stack"" + stack);

        int sum =0;
        while (!stack.isEmpty()){
            sum += stack.pop();
        }
        
        return sum;
    }
}",None,"class Solution {
    public int calPoints(String[] operations) {

        Stack<Integer> stack = new Stack<>();
        
        for(int i=0; i<operations.length; i++){
            if(operations[i].equals(""C"")){
                stack.pop();
            }else if(operations[i].equals(""D"")){
                stack.push(stack.peek() * 2);
            }else if(operations[i].equals(""+"") && stack.size()>=2){
                int value1 = stack.pop();
                int value2 = stack.pop();
                int value = value1+ value2;
                stack.push(value2);
                stack.push(value1);
                stack.push(value);
            }else {
                stack.push(Integer.parseInt(operations[i]));
            }
        }
        
        System.out.println(""Stack"" + stack);

        int sum =0;
        while (!stack.isEmpty()){
            sum += stack.pop();
        }
        
        return sum;
    }
}
"
2145,java,remove-palindromic-subsequences,"class Solution {
    public int removePalindromeSub(String s) {
	if (s.equals(new StringBuilder(s).reverse().toString())) return 1;
	return 0;
    }

    
}",None,"class Solution {
    public int removePalindromeSub(String s) {
	if (s.length() == 0) return 0;
	if (s.equals(new StringBuilder(s).reverse().toString())) return 1;
	return 2;
    }

    
}
"
2145,java,remove-palindromic-subsequences,"class Solution {
    public int removePalindromeSub(String s) {
	if (s.equals(new StringBuilder(s).reverse().toString())) return 1;
	return 0;
    }

    
}",None,"class Solution {
    public int removePalindromeSub(String s) {
        if (s.length() == 0) return 0;
        if (s.equals(new StringBuilder(s).reverse().toString())) return 1;
        return 2;
    }
}
"
2145,java,remove-palindromic-subsequences,"class Solution {
    public int removePalindromeSub(String s) {
	if (s.equals(new StringBuilder(s).reverse().toString())) return 1;
	return 0;
    }

    
}",None,"class Solution {
    public int removePalindromeSub(String s) {
	if (s.length() == 0) return 0;
	if (s.equals(new StringBuilder(s).reverse().toString())) return 1;
	return 2;
    }

    
}
"
2146,java,number-of-unequal-triplets-in-array,"class Solution {
    public int unequalTriplets(int[] nums) {
        int ans=0;
        for(int i=0; i < nums.length; i++)
            for(int j=i+1; j < nums.length; j++)
                for(int k=j+1; k <= nums.length; k++)
                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])
                        ans++;
        return ans;
    }
}",None,"class Solution {
    public int unequalTriplets(int[] nums) {
        int ans=0;
        for(int i=0; i < nums.length; i++)
            for(int j=i+1; j < nums.length; j++)
                for(int k=j+1; k < nums.length; k++) // fix the condition here
                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])
                        ans++;
        return ans;
    }
}
"
2146,java,number-of-unequal-triplets-in-array,"class Solution {
    public int unequalTriplets(int[] nums) {
        int ans=0;
        for(int i=0; i < nums.length; i++)
            for(int j=i+1; j < nums.length; j++)
                for(int k=j+1; k <= nums.length; k++)
                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])
                        ans++;
        return ans;
    }
}",None,"class Solution {
    public int unequalTriplets(int[] nums) {
        int ans=0;
        for(int i=0; i < nums.length; i++)
            for(int j=i+1; j < nums.length; j++)
                for(int k=j+1; k < nums.length; k++) // Change the condition here
                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])
                        ans++;
        return ans;
    }
}
"
2146,java,number-of-unequal-triplets-in-array,"class Solution {
    public int unequalTriplets(int[] nums) {
        int ans=0;
        for(int i=0; i < nums.length; i++)
            for(int j=i+1; j < nums.length; j++)
                for(int k=j+1; k <= nums.length; k++)
                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])
                        ans++;
        return ans;
    }
}",None,"class Solution {
    public int unequalTriplets(int[] nums) {
        int ans=0;
        for(int i=0; i < nums.length; i++)
            for(int j=i+1; j < nums.length; j++)
                for(int k=j+1; k < nums.length; k++) // fix here
                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])
                        ans++;
        return ans;
    }
}
"
2147,java,sum-in-a-matrix,"class Solution {
    public int matrixSum(int[][] nums) {
        int score = 0;
        int n = nums.length;
        int m = nums[0].length;
        for(int[] a :nums)
        {
            Arrays.sort(a);
        }
        for(int i=0;i<n;i++)
        {
            int max = 0;
            for(int j=0;j<m;j++)
            {
                max = Math.max(max,nums[i][j]);
            }
            score+=max;
        }
        return score;
    }
}",None,"class Solution {
    public int matrixSum(int[][] nums) {
        int score = 0;
        int n = nums.length;
        int m = nums[0].length;
        for(int[] a :nums)
        {
            Arrays.sort(a);
        }
        for(int i=0;i<n;i++)
        {
            int max = nums[i][m-1];
            for(int j=0;j<m-1;j++)
            {
                max = Math.max(max,nums[i][j]);
            }
            score+=max;
        }
        return score;
    }
}
"
2147,java,sum-in-a-matrix,"class Solution {
    public int matrixSum(int[][] nums) {
        int score = 0;
        int n = nums.length;
        int m = nums[0].length;
        for(int[] a :nums)
        {
            Arrays.sort(a);
        }
        for(int i=0;i<n;i++)
        {
            int max = 0;
            for(int j=0;j<m;j++)
            {
                max = Math.max(max,nums[i][j]);
            }
            score+=max;
        }
        return score;
    }
}",None,"class Solution {
    public int matrixSum(int[][] nums) {
        int score = 0;
        int n = nums.length;
        int m = nums[0].length;
        for(int i=0;i<n;i++)
        {
            int max = Integer.MIN_VALUE;
            for(int j=0;j<m;j++)
            {
                max = Math.max(max,nums[i][j]);
            }
            score+=max;
            for(int j=0;j<m;j++)
            {
                if(nums[i][j]==max)
                {
                    nums[i][j]=Integer.MIN_VALUE;
                }
            }
        }
        return score;
    }
}
"
2147,java,sum-in-a-matrix,"class Solution {
    public int matrixSum(int[][] nums) {
        int score = 0;
        int n = nums.length;
        int m = nums[0].length;
        for(int[] a :nums)
        {
            Arrays.sort(a);
        }
        for(int i=0;i<n;i++)
        {
            int max = 0;
            for(int j=0;j<m;j++)
            {
                max = Math.max(max,nums[i][j]);
            }
            score+=max;
        }
        return score;
    }
}",None,"class Solution {
    public int matrixSum(int[][] nums) {
        int score = 0;
        int n = nums.length;
        int m = nums[0].length;
        for(int[] a :nums)
        {
            Arrays.sort(a);
        }
        for(int[] row : nums)
        {
            int max = Integer.MIN_VALUE;
            for(int val : row)
            {
                max = Math.max(max, val);
            }
            score += max;
        }
        return score;
    }
}
"
2148,java,find-the-winner-of-the-circular-game,"class Solution {
    public int findTheWinner(int n, int k) {
        Queue<Integer> q = new LinkedList();

        for(int i = 0;i<n+1;i++){
            q.add(i);
        }
        while(q.size()!=1){
            for(int i = k-1;i>0;i--){
                q.add(q.poll());
            }
            q.poll();
        }

        return q.poll();
    }
}",None,"class Solution {
    public int findTheWinner(int n, int k) {
        Queue<Integer> q = new LinkedList();

        for(int i = 1;i<=n;i++){
            q.add(i);
        }
        while(q.size()!=1){
            for(int i = 0;i<k-1;i++){
                q.add(q.poll());
            }
            q.poll();
        }

        return q.poll();
    }
}
"
2148,java,find-the-winner-of-the-circular-game,"class Solution {
    public int findTheWinner(int n, int k) {
        Queue<Integer> q = new LinkedList();

        for(int i = 0;i<n+1;i++){
            q.add(i);
        }
        while(q.size()!=1){
            for(int i = k-1;i>0;i--){
                q.add(q.poll());
            }
            q.poll();
        }

        return q.poll();
    }
}",None,"class Solution {
    public int findTheWinner(int n, int k) {
        Queue<Integer> q = new LinkedList();

        for(int i = 1;i<=n;i++){
            q.add(i);
        }
        while(q.size()!=1){
            for(int i = 1;i<k;i++){
                q.add(q.poll());
            }
            q.poll();
        }

        return q.poll();
    }
}
"
2148,java,find-the-winner-of-the-circular-game,"class Solution {
    public int findTheWinner(int n, int k) {
        Queue<Integer> q = new LinkedList();

        for(int i = 0;i<n+1;i++){
            q.add(i);
        }
        while(q.size()!=1){
            for(int i = k-1;i>0;i--){
                q.add(q.poll());
            }
            q.poll();
        }

        return q.poll();
    }
}",None,"class Solution {
    public int findTheWinner(int n, int k) {
        Queue<Integer> q = new LinkedList();

        for(int i = 1;i<=n;i++){
            q.add(i);
        }
        while(q.size()!=1){
            for(int i = 1;i<k;i++){
                q.add(q.poll());
            }
            q.poll();
        }

        return q.poll();
    }
}
"
2149,java,swap-adjacent-in-lr-string,"class Solution {
    public boolean canTransform(String start, String end) {
        Queue<Node> logs = new LinkedList<>();

        int count = 0;
        for (char c : start.toCharArray()) {
            if (c == 'X') count++;
            else {
                logs.add(new Node(c, count));
            }
        }

        count = 0;
        for (char c : end.toCharArray()) {
            if (c == 'X') count++;
            else {
                if (logs.isEmpty()) return false;

                Node node = logs.poll();
                if (c != node.c) return false;

                if (c == 'L' && count < node.count) return false; 
                if (c == 'R' && count > node.count) return false;                
            }
        }

        return logs.isEmpty();
    }

    class Node {
        public Character c;
        public int count;

        public Node(Character c, int count) {
            this.c = c;
            this.count = count;
        }
    }
}",None,"class Solution {
    public boolean canTransform(String start, String end) {
        Queue<Node> logs = new LinkedList<>();

        int count = 0;
        for (char c : start.toCharArray()) {
            if (c == 'X') count++;
            else {
                logs.add(new Node(c, count));
            }
        }

        count = 0;
        for (char c : end.toCharArray()) {
            if (c == 'X') count++;
            else {
                if (logs.isEmpty()) return false;

                Node node = logs.poll();
                if (c != node.c) return false;

                if (c == 'L' && count < node.count) return false; 
                if (c == 'R' && count > node.count) return false;                
            }
        }

        return logs.isEmpty();
    }

    class Node {
        public Character c;
        public int count;

        public Node(Character c, int count) {
            this.c = c;
            this.count = count;
        }
    }
}
"
2149,java,swap-adjacent-in-lr-string,"class Solution {
    public boolean canTransform(String start, String end) {
        Queue<Node> logs = new LinkedList<>();

        int count = 0;
        for (char c : start.toCharArray()) {
            if (c == 'X') count++;
            else {
                logs.add(new Node(c, count));
            }
        }

        count = 0;
        for (char c : end.toCharArray()) {
            if (c == 'X') count++;
            else {
                if (logs.isEmpty()) return false;

                Node node = logs.poll();
                if (c != node.c) return false;

                if (c == 'L' && count < node.count) return false; 
                if (c == 'R' && count > node.count) return false;                
            }
        }

        return logs.isEmpty();
    }

    class Node {
        public Character c;
        public int count;

        public Node(Character c, int count) {
            this.c = c;
            this.count = count;
        }
    }
}",None,"class Solution {
    public boolean canTransform(String start, String end) {
        Queue<Node> logs = new LinkedList<>();

        int count = 0;
        for (char c : start.toCharArray()) {
            if (c == 'X') count++;
            else {
                logs.add(new Node(c, count));
            }
        }

        count = 0;
        for (char c : end.toCharArray()) {
            if (c == 'X') count++;
            else {
                if (logs.isEmpty()) return false;

                Node node = logs.poll();
                if (c != node.c) return false;

                if (c == 'L' && count < node.count) return false; 
                if (c == 'R' && count > node.count) return false;
            }
        }

        return logs.isEmpty();
    }

    class Node {
        public Character c;
        public int count;

        public Node(Character c, int count) {
            this.c = c;
            this.count = count;
        }
    }
}
"
2149,java,swap-adjacent-in-lr-string,"class Solution {
    public boolean canTransform(String start, String end) {
        Queue<Node> logs = new LinkedList<>();

        int count = 0;
        for (char c : start.toCharArray()) {
            if (c == 'X') count++;
            else {
                logs.add(new Node(c, count));
            }
        }

        count = 0;
        for (char c : end.toCharArray()) {
            if (c == 'X') count++;
            else {
                if (logs.isEmpty()) return false;

                Node node = logs.poll();
                if (c != node.c) return false;

                if (c == 'L' && count < node.count) return false; 
                if (c == 'R' && count > node.count) return false;                
            }
        }

        return logs.isEmpty();
    }

    class Node {
        public Character c;
        public int count;

        public Node(Character c, int count) {
            this.c = c;
            this.count = count;
        }
    }
}",None,"class Solution {
    public boolean canTransform(String start, String end) {
        Queue<Node> logs = new LinkedList<>();

        int count = 0;
        for (char c : start.toCharArray()) {
            if (c == 'X') count++;
            else {
                logs.add(new Node(c, count));
            }
        }

        count = 0;
        for (char c : end.toCharArray()) {
            if (c == 'X') count++;
            else {
                if (logs.isEmpty()) return false;

                Node node = logs.poll();
                if (c != node.c) return false;

                if (c == 'L' && count < node.count) return false; 
                if (c == 'R' && count > node.count) return false;                
            }
        }

        return logs.isEmpty();
    }

    class Node {
        public Character c;
        public int count;

        public Node(Character c, int count) {
            this.c = c;
            this.count = count;
        }
    }
}
"
2150,java,merge-two-2d-arrays-by-summing-values,"class Solution {
    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {
        
        Map<Integer, Integer> map = new TreeMap<>();
        int l1 = nums1.length;
        int l2 = nums2.length;

        for (int i = 0; i < l1; i++) {
            if (!map.containsKey(nums1[i][1])) {
                map.put(nums1[i][0], nums1[i][1]);
            }
            else {
                map.put(nums1[i][0], (map.get(nums1[i][0]) + nums1[i][1]));
            }
            
        }

        for (int i = 0; i < l2; i++) {
            if (!map.containsKey(nums2[i][0])) {
                map.put(nums2[i][0], nums2[i][1]);
            }
            else {
                map.put(nums2[i][0], (map.get(nums2[i][0]) + nums2[i][1]));
            }
            
        }

        int count = 0;
        int[][] ans = new int[map.size()][2];

        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            ans[count][0] = entry.getKey();
            ans[count][1] = entry.getValue();
            count++;
        }
        
        return ans;
    }
}",None,"class Solution {
    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {
        
        Map<Integer, Integer> map = new TreeMap<>();
        int l1 = nums1.length;
        int l2 = nums2.length;

        for (int i = 0; i < l1; i++) {
            if (map.containsKey(nums1[i][0])) {
                map.put(nums1[i][0], map.get(nums1[i][0]) + nums1[i][1]);
            }
            else {
                map.put(nums1[i][0], nums1[i][1]);
            }
            
        }

        for (int i = 0; i < l2; i++) {
            if (map.containsKey(nums2[i][0])) {
                map.put(nums2[i][0], map.get(nums2[i][0]) + nums2[i][1]);
            }
            else {
                map.put(nums2[i][0], nums2[i][1]);
            }
            
        }

        int count = 0;
        int[][] ans = new int[map.size()][2];

        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            ans[count][0] = entry.getKey();
            ans[count][1] = entry.getValue();
            count++;
        }
        
        return ans;
    }
}
"
2150,java,merge-two-2d-arrays-by-summing-values,"class Solution {
    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {
        
        Map<Integer, Integer> map = new TreeMap<>();
        int l1 = nums1.length;
        int l2 = nums2.length;

        for (int i = 0; i < l1; i++) {
            if (!map.containsKey(nums1[i][1])) {
                map.put(nums1[i][0], nums1[i][1]);
            }
            else {
                map.put(nums1[i][0], (map.get(nums1[i][0]) + nums1[i][1]));
            }
            
        }

        for (int i = 0; i < l2; i++) {
            if (!map.containsKey(nums2[i][0])) {
                map.put(nums2[i][0], nums2[i][1]);
            }
            else {
                map.put(nums2[i][0], (map.get(nums2[i][0]) + nums2[i][1]));
            }
            
        }

        int count = 0;
        int[][] ans = new int[map.size()][2];

        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            ans[count][0] = entry.getKey();
            ans[count][1] = entry.getValue();
            count++;
        }
        
        return ans;
    }
}",None,"class Solution {
    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {
        Map<Integer, Integer> map = new TreeMap<>();

        for (int[] arr : nums1) {
            map.put(arr[0], map.getOrDefault(arr[0], 0) + arr[1]);
        }

        for (int[] arr : nums2) {
            map.put(arr[0], map.getOrDefault(arr[0], 0) + arr[1]);
        }

        int count = 0;
        int[][] ans = new int[map.size()][2];

        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            ans[count][0] = entry.getKey();
            ans[count][1] = entry.getValue();
            count++;
        }
        
        return ans;
    }
}
"
2150,java,merge-two-2d-arrays-by-summing-values,"class Solution {
    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {
        
        Map<Integer, Integer> map = new TreeMap<>();
        int l1 = nums1.length;
        int l2 = nums2.length;

        for (int i = 0; i < l1; i++) {
            if (!map.containsKey(nums1[i][1])) {
                map.put(nums1[i][0], nums1[i][1]);
            }
            else {
                map.put(nums1[i][0], (map.get(nums1[i][0]) + nums1[i][1]));
            }
            
        }

        for (int i = 0; i < l2; i++) {
            if (!map.containsKey(nums2[i][0])) {
                map.put(nums2[i][0], nums2[i][1]);
            }
            else {
                map.put(nums2[i][0], (map.get(nums2[i][0]) + nums2[i][1]));
            }
            
        }

        int count = 0;
        int[][] ans = new int[map.size()][2];

        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            ans[count][0] = entry.getKey();
            ans[count][1] = entry.getValue();
            count++;
        }
        
        return ans;
    }
}",None,"class Solution {
    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {
        Map<Integer, Integer> map = new TreeMap<>();

        for (int[] arr : nums1) {
            map.put(arr[0], map.getOrDefault(arr[0], 0) + arr[1]);
        }

        for (int[] arr : nums2) {
            map.put(arr[0], map.getOrDefault(arr[0], 0) + arr[1]);
        }

        int count = 0;
        int[][] ans = new int[map.size()][2];

        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            ans[count][0] = entry.getKey();
            ans[count][1] = entry.getValue();
            count++;
        }
        
        return ans;
    }
}
"
2151,java,group-the-people-given-the-group-size-they-belong-to,"class Solution {
    public List<List<Integer>> groupThePeople(int[] groupSizes) {
        ArrayList<List<Integer>> list =  new ArrayList<>();
        HashMap<Integer, ArrayList<Integer>> hm = new HashMap<>();

        for(int i = 0 ; i <= groupSizes.length; i++){
            if(hm.containsKey(groupSizes[i])){
                hm.get(groupSizes[i]).add(i);
            }
            else{
            	ArrayList<Integer> newL = new ArrayList<>();
            	newL.add(i);
                hm.put(groupSizes[i], newL);      
            }

            if(hm.get(groupSizes[i]).size() == groupSizes[i]){
                list.add(hm.get(groupSizes[i]));
                hm.remove(groupSizes[i]);
            }
        }
            
        return list;
    }
}",None,"class Solution {
    public List<List<Integer>> groupThePeople(int[] groupSizes) {
        ArrayList<List<Integer>> list =  new ArrayList<>();
        HashMap<Integer, ArrayList<Integer>> hm = new HashMap<>();

        for(int i = 0 ; i < groupSizes.length; i++){
            if(hm.containsKey(groupSizes[i])){
                hm.get(groupSizes[i]).add(i);
            }
            else{
            	ArrayList<Integer> newL = new ArrayList<>();
            	newL.add(i);
                hm.put(groupSizes[i], newL);      
            }

            if(hm.get(groupSizes[i]).size() == groupSizes[i]){
                list.add(hm.get(groupSizes[i]));
                hm.remove(groupSizes[i]);
            }
        }
            
        return list;
    }
}
"
2151,java,group-the-people-given-the-group-size-they-belong-to,"class Solution {
    public List<List<Integer>> groupThePeople(int[] groupSizes) {
        ArrayList<List<Integer>> list =  new ArrayList<>();
        HashMap<Integer, ArrayList<Integer>> hm = new HashMap<>();

        for(int i = 0 ; i <= groupSizes.length; i++){
            if(hm.containsKey(groupSizes[i])){
                hm.get(groupSizes[i]).add(i);
            }
            else{
            	ArrayList<Integer> newL = new ArrayList<>();
            	newL.add(i);
                hm.put(groupSizes[i], newL);      
            }

            if(hm.get(groupSizes[i]).size() == groupSizes[i]){
                list.add(hm.get(groupSizes[i]));
                hm.remove(groupSizes[i]);
            }
        }
            
        return list;
    }
}",None,"class Solution {
    public List<List<Integer>> groupThePeople(int[] groupSizes) {
        ArrayList<List<Integer>> list =  new ArrayList<>();
        HashMap<Integer, ArrayList<Integer>> hm = new HashMap<>();

        for(int i = 0 ; i < groupSizes.length; i++){
            if(hm.containsKey(groupSizes[i])){
                hm.get(groupSizes[i]).add(i);
            }
            else{
                ArrayList<Integer> newL = new ArrayList<>();
                newL.add(i);
                hm.put(groupSizes[i], newL);      
            }

            if(hm.get(groupSizes[i]).size() == groupSizes[i]){
                list.add(hm.get(groupSizes[i]));
                hm.remove(groupSizes[i]);
            }
        }
            
        return list;
    }
}
"
2151,java,group-the-people-given-the-group-size-they-belong-to,"class Solution {
    public List<List<Integer>> groupThePeople(int[] groupSizes) {
        ArrayList<List<Integer>> list =  new ArrayList<>();
        HashMap<Integer, ArrayList<Integer>> hm = new HashMap<>();

        for(int i = 0 ; i <= groupSizes.length; i++){
            if(hm.containsKey(groupSizes[i])){
                hm.get(groupSizes[i]).add(i);
            }
            else{
            	ArrayList<Integer> newL = new ArrayList<>();
            	newL.add(i);
                hm.put(groupSizes[i], newL);      
            }

            if(hm.get(groupSizes[i]).size() == groupSizes[i]){
                list.add(hm.get(groupSizes[i]));
                hm.remove(groupSizes[i]);
            }
        }
            
        return list;
    }
}",None,"class Solution {
    public List<List<Integer>> groupThePeople(int[] groupSizes) {
        ArrayList<List<Integer>> list =  new ArrayList<>();
        HashMap<Integer, ArrayList<Integer>> hm = new HashMap<>();

        for(int i = 0 ; i < groupSizes.length; i++){
            if(hm.containsKey(groupSizes[i])){
                hm.get(groupSizes[i]).add(i);
            }
            else{
                ArrayList<Integer> newL = new ArrayList<>();
                newL.add(i);
                hm.put(groupSizes[i], newL);      
            }

            if(hm.get(groupSizes[i]).size() == groupSizes[i]){
                list.add(hm.get(groupSizes[i]));
                hm.remove(groupSizes[i]);
            }
        }

        return list;
    }
}
"
2152,java,erect-the-fence,"class Solution {
    
    public int[][] outerTrees(int[][] trees) {
        if(trees.length == 3){
            return trees;
        }
        Stack<int[]> upper = new Stack<>();
        Stack<int[]> lower = new Stack<>();
        
        Arrays.sort(trees,(p,q) ->q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);
        
        for(int i = 0 ; i < trees.length ; i++){
            int size = trees.length;
            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){
                upper.pop();  
                }
            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) > 0){
                 lower.pop();  
              }
            upper.push(trees[i]);
            lower.push(trees[i]);
        }
        
        
        Set<int[]> res= new HashSet<>(lower);
        res.addAll(upper);
        return res.toArray(new int[res.size()][]);
    }
    
    public int angle(int[] A , int[] B , int[] C){
        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);
    }
}",None,"class Solution {
    
    public int[][] outerTrees(int[][] trees) {
        if(trees.length == 3){
            return trees;
        }
        Stack<int[]> upper = new Stack<>();
        Stack<int[]> lower = new Stack<>();
        
        Arrays.sort(trees,(p,q) -> p[0] == q[0] ? p[1] - q[1] : q[0] - p[0]);
        
        for(int i = 0 ; i < trees.length ; i++){
            int size = trees.length;
            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){
                upper.pop();  
                }
            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) < 0){
                 lower.pop();  
              }
            upper.push(trees[i]);
            lower.push(trees[i]);
        }
        
        
        Set<int[]> res= new HashSet<>(lower);
        res.addAll(upper);
        res.removeIf(tree -> lower.size() > 1 && isCollinear(lower.get(0), lower.get(1), tree));
        return res.toArray(new int[res.size()][]);
    }
    
    public int angle(int[] A , int[] B , int[] C){
        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);
    }

    public boolean isCollinear(int[] A, int[] B, int[] C){
        return angle(A, B, C) == 0;
    }
}
"
2152,java,erect-the-fence,"class Solution {
    
    public int[][] outerTrees(int[][] trees) {
        if(trees.length == 3){
            return trees;
        }
        Stack<int[]> upper = new Stack<>();
        Stack<int[]> lower = new Stack<>();
        
        Arrays.sort(trees,(p,q) ->q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);
        
        for(int i = 0 ; i < trees.length ; i++){
            int size = trees.length;
            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){
                upper.pop();  
                }
            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) > 0){
                 lower.pop();  
              }
            upper.push(trees[i]);
            lower.push(trees[i]);
        }
        
        
        Set<int[]> res= new HashSet<>(lower);
        res.addAll(upper);
        return res.toArray(new int[res.size()][]);
    }
    
    public int angle(int[] A , int[] B , int[] C){
        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);
    }
}",None,"class Solution {
    
    public int[][] outerTrees(int[][] trees) {
        if(trees.length == 3){
            return trees;
        }
        Stack<int[]> upper = new Stack<>();
        Stack<int[]> lower = new Stack<>();
        
        Arrays.sort(trees,(p,q) ->q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);
        
        for(int i = 0 ; i < trees.length ; i++){
            int size = trees.length;
            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) >= 0){
                upper.pop();  
                }
            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) >= 0){
                 lower.pop();  
              }
            upper.push(trees[i]);
            lower.push(trees[i]);
        }
        
        
        Set<int[]> res= new HashSet<>(lower);
        res.addAll(upper);
        return res.toArray(new int[res.size()][]);
    }
    
    public int angle(int[] A , int[] B , int[] C){
        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);
    }
}
"
2152,java,erect-the-fence,"class Solution {
    
    public int[][] outerTrees(int[][] trees) {
        if(trees.length == 3){
            return trees;
        }
        Stack<int[]> upper = new Stack<>();
        Stack<int[]> lower = new Stack<>();
        
        Arrays.sort(trees,(p,q) ->q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);
        
        for(int i = 0 ; i < trees.length ; i++){
            int size = trees.length;
            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){
                upper.pop();  
                }
            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) > 0){
                 lower.pop();  
              }
            upper.push(trees[i]);
            lower.push(trees[i]);
        }
        
        
        Set<int[]> res= new HashSet<>(lower);
        res.addAll(upper);
        return res.toArray(new int[res.size()][]);
    }
    
    public int angle(int[] A , int[] B , int[] C){
        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);
    }
}",None,"class Solution {
    
    public int[][] outerTrees(int[][] trees) {
        if(trees.length == 3){
            return trees;
        }
        Stack<int[]> upper = new Stack<>();
        Stack<int[]> lower = new Stack<>();
        
        Arrays.sort(trees,(p,q) ->q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);
        
        for(int i = 0 ; i < trees.length ; i++){
            int size = trees.length;
            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) >= 0){
                upper.pop();  
                }
            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) >= 0){
                 lower.pop();  
              }
            upper.push(trees[i]);
            lower.push(trees[i]);
        }
        
        
        Set<int[]> res= new HashSet<>(lower);
        res.addAll(upper);
        return res.toArray(new int[res.size()][]);
    }
    
    public int angle(int[] A , int[] B , int[] C){
        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);
    }
}
"
2153,java,valid-triangle-number,"class Solution {
    public int triangleNumber(int[] nums) {
        int n=nums.length;
        Arrays.sort(nums);
        int count=0;
        for(int c=n-1;c>=2;c--){
            int a=0;
            int b=c-1;
            while(a<b){
                if(nums[a]+nums[b]>=nums[c]){ 
                    count+=(b-a);
                    b--;
                }
                else{
                    a++;
                }
            }
        }
        return count;
        
    }
}",None,"class Solution {
    public int triangleNumber(int[] nums) {
        int n=nums.length;
        Arrays.sort(nums);
        int count=0;
        for(int c=n-1;c>=2;c--){
            int a=0;
            int b=c-1;
            while(a<b){
                if(nums[a]+nums[b]>nums[c]){ 
                    count+=(b-a);
                    b--;
                }
                else{
                    a++;
                }
            }
        }
        return count;
        
    }
}
"
2153,java,valid-triangle-number,"class Solution {
    public int triangleNumber(int[] nums) {
        int n=nums.length;
        Arrays.sort(nums);
        int count=0;
        for(int c=n-1;c>=2;c--){
            int a=0;
            int b=c-1;
            while(a<b){
                if(nums[a]+nums[b]>=nums[c]){ 
                    count+=(b-a);
                    b--;
                }
                else{
                    a++;
                }
            }
        }
        return count;
        
    }
}",None,"class Solution {
    public int triangleNumber(int[] nums) {
        int n=nums.length;
        Arrays.sort(nums);
        int count=0;
        for(int c=n-1;c>=2;c--){
            int a=0;
            int b=c-1;
            while(a<b){
                if(nums[a]+nums[b]>nums[c]){ 
                    count+=(b-a);
                    b--;
                }
                else{
                    a++;
                }
            }
        }
        return count;
        
    }
}
"
2153,java,valid-triangle-number,"class Solution {
    public int triangleNumber(int[] nums) {
        int n=nums.length;
        Arrays.sort(nums);
        int count=0;
        for(int c=n-1;c>=2;c--){
            int a=0;
            int b=c-1;
            while(a<b){
                if(nums[a]+nums[b]>=nums[c]){ 
                    count+=(b-a);
                    b--;
                }
                else{
                    a++;
                }
            }
        }
        return count;
        
    }
}",None,"class Solution {
    public int triangleNumber(int[] nums) {
        int n=nums.length;
        Arrays.sort(nums);
        int count=0;
        for(int c=n-1;c>=2;c--){
            int a=0;
            int b=c-1;
            while(a<b){
                if(nums[a]+nums[b]>nums[c]){ 
                    count+=(b-a);
                    b--;
                }
                else{
                    a++;
                }
            }
        }
        return count;
        
    }
}
"
2154,java,add-edges-to-make-degrees-of-all-nodes-even,"class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        graph = defaultdict(set)
        for a, b in edges:
            graph[a].add(b)
            graph[b].add(a)
        odds = [a for a in graph if len(graph[a]) % 2 == 1]
        if not odds:
            return True
        elif len(odds) > 4 or len(odds) == 1 or len(odds) == 3:
            return False
        elif len(odds) == 2:
            a, b = odds[0], odds[1]
            if a in graph[b]:
                return True
            for i in range(1, n + 1):
                if i not in graph[a] and i not in graph[b]:
                    return True
            return False
        else:
            a, b, c, d = odds[0], odds[1], odds[2], odds[3]
            if a not in graph[b] and c not in graph[d]:
                return True
            if a not in graph[c] and b not in graph[d]:
                return True
            if a not in graph[d] and b not in graph[c]:
                return True
            return False",None,"class Solution {
    public boolean isPossible(int n, int[][] edges) {
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            graph.add(new ArrayList<>());
        }
        for (int[] edge : edges) {
            graph.get(edge[0] - 1).add(edge[1] - 1);
            graph.get(edge[1] - 1).add(edge[0] - 1);
        }
        List<Integer> odds = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            if (graph.get(i).size() % 2 == 1) {
                odds.add(i);
            }
        }
        if (odds.size() > 4 || odds.size() == 1 || odds.size() == 3) {
            return false;
        }
        if (odds.size() == 2) {
            int a = odds.get(0), b = odds.get(1);
            if (graph.get(a).contains(b)) {
                return true;
            }
            for (int i = 0; i < n; i++) {
                if (!graph.get(a).contains(i) && !graph.get(b).contains(i)) {
                    return true;
                }
            }
        } else {
            int a = odds.get(0), b = odds.get(1), c = odds.get(2), d = odds.get(3);
            if (!graph.get(a).contains(b) && !graph.get(c).contains(d)) {
                return true;
            }
            if (!graph.get(a).contains(c) && !graph.get(b).contains(d)) {
                return true;
            }
            if (!graph.get(a).contains(d) && !graph.get(b).contains(c)) {
                return true;
            }
        }
        return false;
    }
}
"
2154,java,add-edges-to-make-degrees-of-all-nodes-even,"class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        graph = defaultdict(set)
        for a, b in edges:
            graph[a].add(b)
            graph[b].add(a)
        odds = [a for a in graph if len(graph[a]) % 2 == 1]
        if not odds:
            return True
        elif len(odds) > 4 or len(odds) == 1 or len(odds) == 3:
            return False
        elif len(odds) == 2:
            a, b = odds[0], odds[1]
            if a in graph[b]:
                return True
            for i in range(1, n + 1):
                if i not in graph[a] and i not in graph[b]:
                    return True
            return False
        else:
            a, b, c, d = odds[0], odds[1], odds[2], odds[3]
            if a not in graph[b] and c not in graph[d]:
                return True
            if a not in graph[c] and b not in graph[d]:
                return True
            if a not in graph[d] and b not in graph[c]:
                return True
            return False",None,"from collections import defaultdict

class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        graph = defaultdict(set)
        for a, b in edges:
            graph[a].add(b)
            graph[b].add(a)
        odds = [a for a in graph if len(graph[a]) % 2 == 1]
        if not odds:
            return True
        elif len(odds) > 4 or len(odds) == 1 or len(odds) == 3:
            return False
        elif len(odds) == 2:
            a, b = odds[0], odds[1]
            if a in graph[b]:
                return True
            for i in range(1, n + 1):
                if i not in graph[a] and i not in graph[b]:
                    return True
            return False
        else:
            a, b, c, d = odds[0], odds[1], odds[2], odds[3]
            if a not in graph[b] and c not in graph[d]:
                return True
            if a not in graph[c] and b not in graph[d]:
                return True
            if a not in graph[d] and b not in graph[c]:
                return True
            return False
"
2154,java,add-edges-to-make-degrees-of-all-nodes-even,"class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        graph = defaultdict(set)
        for a, b in edges:
            graph[a].add(b)
            graph[b].add(a)
        odds = [a for a in graph if len(graph[a]) % 2 == 1]
        if not odds:
            return True
        elif len(odds) > 4 or len(odds) == 1 or len(odds) == 3:
            return False
        elif len(odds) == 2:
            a, b = odds[0], odds[1]
            if a in graph[b]:
                return True
            for i in range(1, n + 1):
                if i not in graph[a] and i not in graph[b]:
                    return True
            return False
        else:
            a, b, c, d = odds[0], odds[1], odds[2], odds[3]
            if a not in graph[b] and c not in graph[d]:
                return True
            if a not in graph[c] and b not in graph[d]:
                return True
            if a not in graph[d] and b not in graph[c]:
                return True
            return False",None,"class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        graph = defaultdict(set)
        for a, b in edges:
            graph[a].add(b)
            graph[b].add(a)
        odds = [a for a in graph if len(graph[a]) % 2 == 1]
        if not odds:
            return True
        elif len(odds) > 2:
            return False
        elif len(odds) == 2:
            a, b = odds[0], odds[1]
            if a in graph[b]:
                graph[a].remove(b)
                graph[b].remove(a)
                return len(set([len(graph[i]) for i in graph])) == 1
            for i in range(1, n + 1):
                if i not in graph[a] and i not in graph[b]:
                    graph[a].add(i)
                    graph[i].add(a)
                    graph[b].add(i)
                    graph[i].add(b)
                    return len(set([len(graph[i]) for i in graph])) == 1
            return False
        else:
            a, b, c, d = odds[0], odds[1], odds[2], odds[3]
            if a not in graph[b] and c not in graph[d]:
                graph[a].remove(odds[1])
                graph[odds[1]].remove(a)
                graph[c].remove(odds[3])
                graph[odds[3]].remove(c)
                graph[a].add(c)
                graph[c].add(a)
                graph[b].add(d)
                graph[d].add(b)
                return len(set([len(graph[i]) for i in graph])) == 1
            if a not in graph[c] and b not in graph[d]:
                graph[a].remove(odds[2])
                graph[odds[2]].remove(a)
                graph[b].remove(odds[3])
                graph[odds[3]].remove(b)
                graph[a].add(d)
                graph[d].add(a)
                graph[b].add(c)
                graph[c].add(b)
                return len(set([len(graph[i]) for i in graph])) == 1
            if a not in graph[d] and b not in graph[c]:
                graph[a].remove(odds[3])
                graph[odds[3]].remove(a)
                graph[b].remove(odds[2])
                graph[odds[2]].remove(b)
                graph[a].add(c)
                graph[c].add(a)
                graph[b].add(d)
                graph[d].add(b)
                return len(set([len(graph[i]) for i in graph])) == 1
            return False
"
2155,java,same-tree,"class Solution {
   
    public boolean isSameTree(TreeNode p, TreeNode q) {
     if (p == null && q == null) {
            return true;
        }
        
        if (p == null || q == null) {
            return false;
        }
        
        if (p.val == q.val) {
            return false;
        }
        
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);

        
    }
}",None,"class Solution {
   
    public boolean isSameTree(TreeNode p, TreeNode q) {
     if (p == null && q == null) {
            return true;
        }
        
        if (p == null || q == null) {
            return false;
        }
        
        if (p.val != q.val) {
            return false;
        }
        
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);

        
    }
}
"
2155,java,same-tree,"class Solution {
   
    public boolean isSameTree(TreeNode p, TreeNode q) {
     if (p == null && q == null) {
            return true;
        }
        
        if (p == null || q == null) {
            return false;
        }
        
        if (p.val == q.val) {
            return false;
        }
        
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);

        
    }
}",None,"class Solution {
   
    public boolean isSameTree(TreeNode p, TreeNode q) {
     if (p == null && q == null) {
            return true;
        }
        
        if (p == null || q == null) {
            return false;
        }
        
        if (p.val != q.val) {
            return false;
        }
        
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);

        
    }
}
"
2155,java,same-tree,"class Solution {
   
    public boolean isSameTree(TreeNode p, TreeNode q) {
     if (p == null && q == null) {
            return true;
        }
        
        if (p == null || q == null) {
            return false;
        }
        
        if (p.val == q.val) {
            return false;
        }
        
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);

        
    }
}",None,"class Solution {
   
    public boolean isSameTree(TreeNode p, TreeNode q) {
     if (p == null && q == null) {
            return true;
        }
        
        if (p == null || q == null) {
            return false;
        }
        
        if (p.val != q.val) {
            return false;
        }
        
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);

        
    }
}
"
2156,java,minimum-falling-path-sum-ii,"class Solution {
    int m;
    int n;
    Integer memo[][];

    public int minFallingPathSum(int[][] grid) {   
         m=grid.length;
         n=grid[0].length;
         memo=new Integer[m][n];

         int recRes=Integer.MAX_VALUE;

         for(int col=0;col<n;col++)
                    recRes=Math.min(recRes,minFallingPathSum_Rec(grid,0,col));

        return recRes;

         int Tabulation_Ans=minFallingPathSum_Tabulation(grid);
         return Tabulation_Ans;
    }

    public int minFallingPathSum_Rec(int[][] grid,int i,int j){
            
            if(j<0 || j>=n || i<0 || i>=m)
                           return Integer.MAX_VALUE;

            if(i==m-1)
                     return grid[i][j];

            if(memo[i][j]!=null)
                        return memo[i][j];

            int lowerLeftSum=Integer.MAX_VALUE;
            int lowerRightSum=Integer.MAX_VALUE;

            for(int col=0;col<=j-1;col++)
                    lowerLeftSum=Math.min(lowerLeftSum,minFallingPathSum_Rec(grid,i+1,col));

            for(int col=j+1;col<=n-1;col++)
                    lowerRightSum=Math.min(lowerRightSum,minFallingPathSum_Rec(grid,i+1,col));

          return memo[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];

     }

     int minFallingPathSum_Tabulation(int[][] grid){
          int dp[][]=new int[m][n];

          for(int i=m-1;i>=0;i--){
              for(int j=n-1;j>=0;j--){
                    
                    if(i==m-1)
                     {
                         dp[i][j]=grid[i][j];
                         continue;
                     }
                
                int lowerLeftSum=Integer.MAX_VALUE;
                int lowerRightSum=Integer.MAX_VALUE;
                
                for(int col=0;col<=j-1;col++){
                    lowerLeftSum=Math.min(lowerLeftSum,((col<0)?Integer.MAX_VALUE:dp[i+1][col]));
                }
                
                for(int col=j+1;col<=n-1;col++){
                    lowerRightSum=Math.min(lowerRightSum,((col>=n)?Integer.MAX_VALUE:dp[i+1][col]));
                
                }
                
                dp[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];
              
              }
          }
           
          int Ans=Integer.MAX_VALUE;

          for(int COL=0;COL<n;COL++){
              Ans=Math.min(Ans,dp[0][COL]);
          }
          
          return Ans;
     }
}",None,"class Solution {
    int m;
    int n;
    Integer memo[][];

    public int minFallingPathSum(int[][] grid) {   
         m=grid.length;
         n=grid[0].length;
         memo=new Integer[m][n];

         int recRes=Integer.MAX_VALUE;

         for(int col=0;col<n;col++)
                    recRes=Math.min(recRes,minFallingPathSum_Rec(grid,0,col));

        return recRes;
    }

    public int minFallingPathSum_Rec(int[][] grid,int i,int j){
            
            if(j<0 || j>=n || i<0 || i>=m)
                           return Integer.MAX_VALUE;

            if(i==m-1)
                     return grid[i][j];

            if(memo[i][j]!=null)
                        return memo[i][j];

            int lowerLeftSum=Integer.MAX_VALUE;
            int lowerRightSum=Integer.MAX_VALUE;

            for(int col=0;col<j;col++) // change to ""<"" from ""<=""
                    lowerLeftSum=Math.min(lowerLeftSum,minFallingPathSum_Rec(grid,i+1,col));

            for(int col=j+1;col<n;col++) // change to ""<"" from ""<=""
                    lowerRightSum=Math.min(lowerRightSum,minFallingPathSum_Rec(grid,i+1,col));

          return memo[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];

     }

     int minFallingPathSum_Tabulation(int[][] grid){
          int dp[][]=new int[m][n];

          for(int i=m-1;i>=0;i--){
              for(int j=n-1;j>=0;j--){
                    
                    if(i==m-1)
                     {
                         dp[i][j]=grid[i][j];
                         continue;
                     }
                
                int lowerLeftSum=Integer.MAX_VALUE;
                int lowerRightSum=Integer.MAX_VALUE;
                
                for(int col=0;col<j;col++){ // change to ""<"" from ""<=""
                    lowerLeftSum=Math.min(lowerLeftSum,(col<0)?Integer.MAX_VALUE:dp[i+1][col]);
                }
                
                for(int col=j+1;col<n;col++){ // change to ""<"" from ""<=""
                    lowerRightSum=Math.min(lowerRightSum,(col>=n)?Integer.MAX_VALUE:dp[i+1][col]);
                
                }
                
                dp[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];
              
              }
          }
           
          int Ans=Integer.MAX_VALUE;

          for(int COL=0;COL<n;COL++){
              Ans=Math.min(Ans,dp[0][COL]);
          }
          
          return Ans;
     }
}
"
2156,java,minimum-falling-path-sum-ii,"class Solution {
    int m;
    int n;
    Integer memo[][];

    public int minFallingPathSum(int[][] grid) {   
         m=grid.length;
         n=grid[0].length;
         memo=new Integer[m][n];

         int recRes=Integer.MAX_VALUE;

         for(int col=0;col<n;col++)
                    recRes=Math.min(recRes,minFallingPathSum_Rec(grid,0,col));

        return recRes;

         int Tabulation_Ans=minFallingPathSum_Tabulation(grid);
         return Tabulation_Ans;
    }

    public int minFallingPathSum_Rec(int[][] grid,int i,int j){
            
            if(j<0 || j>=n || i<0 || i>=m)
                           return Integer.MAX_VALUE;

            if(i==m-1)
                     return grid[i][j];

            if(memo[i][j]!=null)
                        return memo[i][j];

            int lowerLeftSum=Integer.MAX_VALUE;
            int lowerRightSum=Integer.MAX_VALUE;

            for(int col=0;col<=j-1;col++)
                    lowerLeftSum=Math.min(lowerLeftSum,minFallingPathSum_Rec(grid,i+1,col));

            for(int col=j+1;col<=n-1;col++)
                    lowerRightSum=Math.min(lowerRightSum,minFallingPathSum_Rec(grid,i+1,col));

          return memo[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];

     }

     int minFallingPathSum_Tabulation(int[][] grid){
          int dp[][]=new int[m][n];

          for(int i=m-1;i>=0;i--){
              for(int j=n-1;j>=0;j--){
                    
                    if(i==m-1)
                     {
                         dp[i][j]=grid[i][j];
                         continue;
                     }
                
                int lowerLeftSum=Integer.MAX_VALUE;
                int lowerRightSum=Integer.MAX_VALUE;
                
                for(int col=0;col<=j-1;col++){
                    lowerLeftSum=Math.min(lowerLeftSum,((col<0)?Integer.MAX_VALUE:dp[i+1][col]));
                }
                
                for(int col=j+1;col<=n-1;col++){
                    lowerRightSum=Math.min(lowerRightSum,((col>=n)?Integer.MAX_VALUE:dp[i+1][col]));
                
                }
                
                dp[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];
              
              }
          }
           
          int Ans=Integer.MAX_VALUE;

          for(int COL=0;COL<n;COL++){
              Ans=Math.min(Ans,dp[0][COL]);
          }
          
          return Ans;
     }
}",None,"class Solution {
    int m;
    int n;
    Integer memo[][];

    public int minFallingPathSum(int[][] grid) {   
         m=grid.length;
         n=grid[0].length;
         memo=new Integer[m][n];

         int recRes=Integer.MAX_VALUE;

         for(int col=0;col<n;col++)
                    recRes=Math.min(recRes,minFallingPathSum_Rec(grid,0,col));

        return recRes;

         int Tabulation_Ans=minFallingPathSum_Tabulation(grid);
         return Tabulation_Ans;
    }

    public int minFallingPathSum_Rec(int[][] grid,int i,int j){
            
            if(j<0 || j>=n || i<0 || i>=m)
                           return Integer.MAX_VALUE;

            if(i==m-1)
                     return grid[i][j];

            if(memo[i][j]!=null)
                        return memo[i][j];

            int lowerLeftSum=Integer.MAX_VALUE;
            int lowerRightSum=Integer.MAX_VALUE;

            for(int col=0;col<j;col++)
                    lowerLeftSum=Math.min(lowerLeftSum,minFallingPathSum_Rec(grid,i+1,col));

            for(int col=j+1;col<n;col++)
                    lowerRightSum=Math.min(lowerRightSum,minFallingPathSum_Rec(grid,i+1,col));

          return memo[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];

     }

     int minFallingPathSum_Tabulation(int[][] grid){
          int dp[][]=new int[m][n];

          for(int i=m-1;i>=0;i--){
              for(int j=n-1;j>=0;j--){
                    
                    if(i==m-1)
                     {
                         dp[i][j]=grid[i][j];
                         continue;
                     }
                
                int lowerLeftSum=Integer.MAX_VALUE;
                int lowerRightSum=Integer.MAX_VALUE;
                
                for(int col=0;col<j;col++){
                    lowerLeftSum=Math.min(lowerLeftSum,dp[i+1][col]);
                }
                
                for(int col=j+1;col<n;col++){
                    lowerRightSum=Math.min(lowerRightSum,dp[i+1][col]);
                
                }
                
                dp[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];
              
              }
          }
           
          int Ans=Integer.MAX_VALUE;

          for(int COL=0;COL<n;COL++){
              Ans=Math.min(Ans,dp[0][COL]);
          }
          
          return Ans;
     }
}
"
2156,java,minimum-falling-path-sum-ii,"class Solution {
    int m;
    int n;
    Integer memo[][];

    public int minFallingPathSum(int[][] grid) {   
         m=grid.length;
         n=grid[0].length;
         memo=new Integer[m][n];

         int recRes=Integer.MAX_VALUE;

         for(int col=0;col<n;col++)
                    recRes=Math.min(recRes,minFallingPathSum_Rec(grid,0,col));

        return recRes;

         int Tabulation_Ans=minFallingPathSum_Tabulation(grid);
         return Tabulation_Ans;
    }

    public int minFallingPathSum_Rec(int[][] grid,int i,int j){
            
            if(j<0 || j>=n || i<0 || i>=m)
                           return Integer.MAX_VALUE;

            if(i==m-1)
                     return grid[i][j];

            if(memo[i][j]!=null)
                        return memo[i][j];

            int lowerLeftSum=Integer.MAX_VALUE;
            int lowerRightSum=Integer.MAX_VALUE;

            for(int col=0;col<=j-1;col++)
                    lowerLeftSum=Math.min(lowerLeftSum,minFallingPathSum_Rec(grid,i+1,col));

            for(int col=j+1;col<=n-1;col++)
                    lowerRightSum=Math.min(lowerRightSum,minFallingPathSum_Rec(grid,i+1,col));

          return memo[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];

     }

     int minFallingPathSum_Tabulation(int[][] grid){
          int dp[][]=new int[m][n];

          for(int i=m-1;i>=0;i--){
              for(int j=n-1;j>=0;j--){
                    
                    if(i==m-1)
                     {
                         dp[i][j]=grid[i][j];
                         continue;
                     }
                
                int lowerLeftSum=Integer.MAX_VALUE;
                int lowerRightSum=Integer.MAX_VALUE;
                
                for(int col=0;col<=j-1;col++){
                    lowerLeftSum=Math.min(lowerLeftSum,((col<0)?Integer.MAX_VALUE:dp[i+1][col]));
                }
                
                for(int col=j+1;col<=n-1;col++){
                    lowerRightSum=Math.min(lowerRightSum,((col>=n)?Integer.MAX_VALUE:dp[i+1][col]));
                
                }
                
                dp[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];
              
              }
          }
           
          int Ans=Integer.MAX_VALUE;

          for(int COL=0;COL<n;COL++){
              Ans=Math.min(Ans,dp[0][COL]);
          }
          
          return Ans;
     }
}",None,"class Solution {
    int m;
    int n;
    Integer memo[][];

    public int minFallingPathSum(int[][] grid) {   
         m=grid.length;
         n=grid[0].length;
         memo=new Integer[m][n];

         int recRes=Integer.MAX_VALUE;

         for(int col=0;col<n;col++)
                    recRes=Math.min(recRes,minFallingPathSum_Rec(grid,0,col));

        return recRes;

         int Tabulation_Ans=minFallingPathSum_Tabulation(grid);
         return Tabulation_Ans;
    }

    public int minFallingPathSum_Rec(int[][] grid,int i,int j){
            
            if(j<0 || j>=n || i<0 || i>=m)
                           return Integer.MAX_VALUE;

            if(i==m-1)
                     return grid[i][j];

            if(memo[i][j]!=null)
                        return memo[i][j];

            int lowerLeftSum=Integer.MAX_VALUE;
            int lowerRightSum=Integer.MAX_VALUE;

            for(int col=0;col<j;col++) // change < to <
                    lowerLeftSum=Math.min(lowerLeftSum,minFallingPathSum_Rec(grid,i+1,col));

            for(int col=j+1;col<n;col++) // change <= to <
                    lowerRightSum=Math.min(lowerRightSum,minFallingPathSum_Rec(grid,i+1,col));

          return memo[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];

     }

     int minFallingPathSum_Tabulation(int[][] grid){
          int dp[][]=new int[m][n];

          for(int i=m-1;i>=0;i--){
              for(int j=n-1;j>=0;j--){
                    
                    if(i==m-1)
                     {
                         dp[i][j]=grid[i][j];
                         continue;
                     }
                
                int lowerLeftSum=Integer.MAX_VALUE;
                int lowerRightSum=Integer.MAX_VALUE;
                
                for(int col=0;col<j;col++){ // change <= to <
                    lowerLeftSum=Math.min(lowerLeftSum,(col>=0)?dp[i+1][col]:Integer.MAX_VALUE);
                }
                
                for(int col=j+1;col<n;col++){ // change >= to <
                    lowerRightSum=Math.min(lowerRightSum,(col<n)?dp[i+1][col]:Integer.MAX_VALUE);
                
                }
                
                dp[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];
              
              }
          }
           
          int Ans=Integer.MAX_VALUE;

          for(int COL=0;COL<n;COL++){
              Ans=Math.min(Ans,dp[0][COL]);
          }
          
          return Ans;
     }
}
"
2157,java,largest-number-after-digit-swaps-by-parity,"class Solution {
    public int largestInteger(int num) {
        String numString = """"+ num;
        List<Integer> even = new ArrayList<>();
        List<Integer> odd = new ArrayList<>();
        for(Character c : numString.toCharArray()){
            int n = Character.getNumericValue(c);
            if(n%2==0){
                even.add(n);
            }else{
                odd.add(n);
            }
        }
        Collections.sort(even, Collections.reverseOrder());
        Collections.sort(odd, Collections.reverseOrder());
        String res ="""";

        
        for(int i=0; i<numString.length()+5; i++){
            int n = Character.getNumericValue(numString.charAt(i));
            if(n%2==0){
                res += even.get(one);
                one++;
            }else{
                res += odd.get(two);
                two++;
            }
        }
        return Integer.parseInt(res);
    }
}",None,"class Solution {
    public int largestInteger(int num) {
        String numString = """"+ num;
        List<Integer> even = new ArrayList<>();
        List<Integer> odd = new ArrayList<>();
        for(Character c : numString.toCharArray()){
            int n = Character.getNumericValue(c);
            if(n%2==0){
                even.add(n);
            }else{
                odd.add(n);
            }
        }
        Collections.sort(even, Collections.reverseOrder());
        Collections.sort(odd, Collections.reverseOrder());
        String res ="""";

        for(int i=0; i<numString.length(); i++){
            int n = Character.getNumericValue(numString.charAt(i));
            if(n%2==0){
                res += even.get(0);
                even.remove(0);
            }else{
                res += odd.get(0);
                odd.remove(0);
            }
        }
        return Integer.parseInt(res);
    }
}
"
2157,java,largest-number-after-digit-swaps-by-parity,"class Solution {
    public int largestInteger(int num) {
        String numString = """"+ num;
        List<Integer> even = new ArrayList<>();
        List<Integer> odd = new ArrayList<>();
        for(Character c : numString.toCharArray()){
            int n = Character.getNumericValue(c);
            if(n%2==0){
                even.add(n);
            }else{
                odd.add(n);
            }
        }
        Collections.sort(even, Collections.reverseOrder());
        Collections.sort(odd, Collections.reverseOrder());
        String res ="""";

        
        for(int i=0; i<numString.length()+5; i++){
            int n = Character.getNumericValue(numString.charAt(i));
            if(n%2==0){
                res += even.get(one);
                one++;
            }else{
                res += odd.get(two);
                two++;
            }
        }
        return Integer.parseInt(res);
    }
}",None,"class Solution {
    public int largestInteger(int num) {
        String numString = """"+ num;
        List<Integer> even = new ArrayList<>();
        List<Integer> odd = new ArrayList<>();
        for(Character c : numString.toCharArray()){
            int n = Character.getNumericValue(c);
            if(n%2==0){
                even.add(n);
            }else{
                odd.add(n);
            }
        }
        Collections.sort(even, Collections.reverseOrder());
        Collections.sort(odd, Collections.reverseOrder());
        String res ="""";

        for(int i=0; i<numString.length(); i++){
            int n = Character.getNumericValue(numString.charAt(i));
            if(n%2==0){
                res += even.get(0);
                even.remove(0);
            }else{
                res += odd.get(0);
                odd.remove(0);
            }
        }
        return Integer.parseInt(res);
    }
}
"
2157,java,largest-number-after-digit-swaps-by-parity,"class Solution {
    public int largestInteger(int num) {
        String numString = """"+ num;
        List<Integer> even = new ArrayList<>();
        List<Integer> odd = new ArrayList<>();
        for(Character c : numString.toCharArray()){
            int n = Character.getNumericValue(c);
            if(n%2==0){
                even.add(n);
            }else{
                odd.add(n);
            }
        }
        Collections.sort(even, Collections.reverseOrder());
        Collections.sort(odd, Collections.reverseOrder());
        String res ="""";

        
        for(int i=0; i<numString.length()+5; i++){
            int n = Character.getNumericValue(numString.charAt(i));
            if(n%2==0){
                res += even.get(one);
                one++;
            }else{
                res += odd.get(two);
                two++;
            }
        }
        return Integer.parseInt(res);
    }
}",None,"class Solution {
    public int largestInteger(int num) {
        String numString = """"+ num;
        List<Integer> even = new ArrayList<>();
        List<Integer> odd = new ArrayList<>();
        for(Character c : numString.toCharArray()){
            int n = Character.getNumericValue(c);
            if(n%2==0){
                even.add(n);
            }else{
                odd.add(n);
            }
        }
        Collections.sort(even, Collections.reverseOrder());
        Collections.sort(odd, Collections.reverseOrder());
        String res ="""";

        for(int i=0; i<numString.length(); i++){
            int n = Character.getNumericValue(numString.charAt(i));
            if(n%2==0){
                res += even.get(0);
                even.remove(0);
            }else{
                res += odd.get(0);
                odd.remove(0);
            }
        }
        return Integer.parseInt(res);
    }
}
"
2158,java,sort-even-and-odd-indices-independently,"class Solution {
    public int[] sortEvenOdd(int[] nums) {
        int n = nums.length;
        int[] even = new int[(n + 1) / 2];
        int[] odd = new int[n / 2];
        int iE = 0;
        int iO = 0;

        for(int i = 0; i < n; i++) {
            if(nums[i] % 2 == 0) {
                even[iE++] = nums[i];
            } else {
                odd[iO++] = nums[i];
            }
        }

        Arrays.sort(even);
        Arrays.sort(odd);
        iE = 0;
        iO = n / 2 - 1;

        for(int i = 0; i < n; i++) {
            if(i % 2 == 0) {
                nums[i] = even[iE++];
            } else {
                nums[i] = odd[iO--];
            }
        }

        return nums;
    }
}",None,"class Solution {
    public int[] sortEvenOdd(int[] nums) {
        int n = nums.length;
        int[] even = new int[(n + 1) / 2];
        int[] odd = new int[n / 2];
        int iE = 0;
        int iO = 0;

        for(int i = 0; i < n; i++) {
            if(i % 2 == 0) {
                even[iE++] = nums[i];
            } else {
                odd[iO++] = nums[i];
            }
        }

        Arrays.sort(odd);
        Arrays.sort(even);
        iE = 0;
        iO = 0;

        for(int i = 0; i < n; i++) {
            if(i % 2 == 0) {
                nums[i] = even[iE++];
            } else {
                nums[i] = odd[iO++];
            }
        }

        return nums;
    }
}
"
2158,java,sort-even-and-odd-indices-independently,"class Solution {
    public int[] sortEvenOdd(int[] nums) {
        int n = nums.length;
        int[] even = new int[(n + 1) / 2];
        int[] odd = new int[n / 2];
        int iE = 0;
        int iO = 0;

        for(int i = 0; i < n; i++) {
            if(nums[i] % 2 == 0) {
                even[iE++] = nums[i];
            } else {
                odd[iO++] = nums[i];
            }
        }

        Arrays.sort(even);
        Arrays.sort(odd);
        iE = 0;
        iO = n / 2 - 1;

        for(int i = 0; i < n; i++) {
            if(i % 2 == 0) {
                nums[i] = even[iE++];
            } else {
                nums[i] = odd[iO--];
            }
        }

        return nums;
    }
}",None,"class Solution {
    public int[] sortEvenOdd(int[] nums) {
        int n = nums.length;
        int[] even = new int[(n + 1) / 2];
        int[] odd = new int[n / 2];
        int iE = 0;
        int iO = 0;

        for(int i = 0; i < n; i++) {
            if(nums[i] % 2 == 0) {
                even[iE++] = nums[i];
            } else {
                odd[iO++] = nums[i];
            }
        }

        Arrays.sort(odd);
        Arrays.sort(even);
        iE = 0;
        iO = n / 2 - 1;

        for(int i = 0; i < n; i++) {
            if(i % 2 == 0) {
                nums[i] = even[iE++];
            } else {
                nums[i] = odd[iO--];
            }
        }

        return nums;
    }
}
"
2158,java,sort-even-and-odd-indices-independently,"class Solution {
    public int[] sortEvenOdd(int[] nums) {
        int n = nums.length;
        int[] even = new int[(n + 1) / 2];
        int[] odd = new int[n / 2];
        int iE = 0;
        int iO = 0;

        for(int i = 0; i < n; i++) {
            if(nums[i] % 2 == 0) {
                even[iE++] = nums[i];
            } else {
                odd[iO++] = nums[i];
            }
        }

        Arrays.sort(even);
        Arrays.sort(odd);
        iE = 0;
        iO = n / 2 - 1;

        for(int i = 0; i < n; i++) {
            if(i % 2 == 0) {
                nums[i] = even[iE++];
            } else {
                nums[i] = odd[iO--];
            }
        }

        return nums;
    }
}",None,"class Solution {
    public int[] sortEvenOdd(int[] nums) {
        int n = nums.length;
        int[] even = new int[(n + 1) / 2];
        int[] odd = new int[n / 2];
        int iE = 0;
        int iO = 0;

        for(int i = 0; i < n; i++) {
            if(nums[i] % 2 == 0) {
                even[iE++] = nums[i];
            } else {
                odd[iO++] = nums[i];
            }
        }

        Arrays.sort(odd);
        Arrays.sort(even);
        iE = 0;
        iO = n / 2 - 1;

        for(int i = 0; i < n; i++) {
            if(i % 2 == 0) {
                nums[i] = even[iE++];
            } else {
                nums[i] = odd[iO--];
            }
        }

        return nums;
    }
}
"
2159,java,path-sum-ii,"class Solution {
     List<List<Integer>> al = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
       
        helper( new ArrayList<>(), root, targetSum);
        return al;
    }
    void helper(List<Integer> li, TreeNode root, int targetSum)
    {
        if(root == null)
        return;
        li.add(root.val);
        if(root.left == null && root.right == null)
        {
            int sum = 0;
            for(int i: li)
            sum+= i;
            if(sum != targetSum)
            al.add(li);
        }
        helper(new ArrayList<>(li), root.left, targetSum);
        helper(new ArrayList<>(li), root.right, targetSum);
    }
}",None,"class Solution {
     List<List<Integer>> al = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
       
        helper( new ArrayList<>(), root, targetSum);
        return al;
    }
    void helper(List<Integer> li, TreeNode root, int targetSum)
    {
        if(root == null)
        return;
        li.add(root.val);
        if(root.left == null && root.right == null)
        {
            int sum = 0;
            for(int i: li)
                sum+= i;
            if(sum == targetSum)
                al.add(new ArrayList<>(li));
        }
        helper(li, root.left, targetSum);
        helper(li, root.right, targetSum);
        li.remove(li.size()-1);
    }
}
"
2159,java,path-sum-ii,"class Solution {
     List<List<Integer>> al = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
       
        helper( new ArrayList<>(), root, targetSum);
        return al;
    }
    void helper(List<Integer> li, TreeNode root, int targetSum)
    {
        if(root == null)
        return;
        li.add(root.val);
        if(root.left == null && root.right == null)
        {
            int sum = 0;
            for(int i: li)
            sum+= i;
            if(sum != targetSum)
            al.add(li);
        }
        helper(new ArrayList<>(li), root.left, targetSum);
        helper(new ArrayList<>(li), root.right, targetSum);
    }
}",None,"class Solution {
     List<List<Integer>> al = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
       
        helper( new ArrayList<>(), root, targetSum);
        return al;
    }
    void helper(List<Integer> li, TreeNode root, int targetSum)
    {
        if(root == null)
        return;
        li.add(root.val);
        if(root.left == null && root.right == null)
        {
            int sum = 0;
            for(int i: li)
                sum+= i;
            if(sum == targetSum)
                al.add(new ArrayList<>(li));
        }
        helper(li, root.left, targetSum);
        helper(li, root.right, targetSum);
        li.remove(li.size()-1);
    }
}
"
2159,java,path-sum-ii,"class Solution {
     List<List<Integer>> al = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
       
        helper( new ArrayList<>(), root, targetSum);
        return al;
    }
    void helper(List<Integer> li, TreeNode root, int targetSum)
    {
        if(root == null)
        return;
        li.add(root.val);
        if(root.left == null && root.right == null)
        {
            int sum = 0;
            for(int i: li)
            sum+= i;
            if(sum != targetSum)
            al.add(li);
        }
        helper(new ArrayList<>(li), root.left, targetSum);
        helper(new ArrayList<>(li), root.right, targetSum);
    }
}",None,"class Solution {
     List<List<Integer>> al = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
       
        helper( new ArrayList<>(), root, targetSum);
        return al;
    }
    void helper(List<Integer> li, TreeNode root, int targetSum)
    {
        if(root == null)
        return;
        li.add(root.val);
        if(root.left == null && root.right == null)
        {
            int sum = 0;
            for(int i: li)
            sum+= i;
            if(sum == targetSum)
            al.add(new ArrayList<>(li));
        }
        helper(li, root.left, targetSum);
        helper(li, root.right, targetSum);
        li.remove(li.size()-1);
    }
}
"
2160,java,remove-k-digits,"class Solution {
    public String removeKdigits(String num, int k) {
        Stack<Character> st = new Stack<>();
        for(Character ch : num.toCharArray()) {
            while(!st.isEmpty() && k > 0 && ch < st.peek()) {
                st.pop();
                
                k--;
            }

            if(!st.isEmpty() || ch != '1') { 
                st.push(ch);
            }
        }

        while(!st.isEmpty() && k-- > 0) {
            st.pop();
        }
        if(st.isEmpty()) return ""0"";

        String ans = """";
        while(!st.isEmpty()) {
            ans = st.peek() + ans;
            st.pop();
        }
        return ans;
    }
}",None,"class Solution {
    public String removeKdigits(String num, int k) {
        Stack<Character> st = new Stack<>();
        for(Character ch : num.toCharArray()) {
            while(!st.isEmpty() && k > 0 && ch < st.peek()) {
                st.pop();
                k--;
            }

            if(!st.isEmpty() || ch != '0') { 
                st.push(ch);
            }
        }

        while(!st.isEmpty() && k-- > 0) {
            st.pop();
        }
        if(st.isEmpty()) return ""0"";

        String ans = """";
        while(!st.isEmpty()) {
            ans += st.pop();
        }
        return new StringBuilder(ans).reverse().toString();
    }
}
"
2160,java,remove-k-digits,"class Solution {
    public String removeKdigits(String num, int k) {
        Stack<Character> st = new Stack<>();
        for(Character ch : num.toCharArray()) {
            while(!st.isEmpty() && k > 0 && ch < st.peek()) {
                st.pop();
                
                k--;
            }

            if(!st.isEmpty() || ch != '1') { 
                st.push(ch);
            }
        }

        while(!st.isEmpty() && k-- > 0) {
            st.pop();
        }
        if(st.isEmpty()) return ""0"";

        String ans = """";
        while(!st.isEmpty()) {
            ans = st.peek() + ans;
            st.pop();
        }
        return ans;
    }
}",None,"class Solution {
    public String removeKdigits(String num, int k) {
        Stack<Character> st = new Stack<>();
        for(Character ch : num.toCharArray()) {
            while(!st.isEmpty() && k > 0 && ch < st.peek()) {
                st.pop();
                k--;
            }

            if(!st.isEmpty() || ch != '0') { 
                st.push(ch);
            }
        }

        while(!st.isEmpty() && k-- > 0) {
            st.pop();
        }
        if(st.isEmpty()) return ""0"";

        String ans = """";
        while(!st.isEmpty()) {
            ans += st.pop();
        }
        return new StringBuilder(ans).reverse().toString();
    }
}
"
2160,java,remove-k-digits,"class Solution {
    public String removeKdigits(String num, int k) {
        Stack<Character> st = new Stack<>();
        for(Character ch : num.toCharArray()) {
            while(!st.isEmpty() && k > 0 && ch < st.peek()) {
                st.pop();
                
                k--;
            }

            if(!st.isEmpty() || ch != '1') { 
                st.push(ch);
            }
        }

        while(!st.isEmpty() && k-- > 0) {
            st.pop();
        }
        if(st.isEmpty()) return ""0"";

        String ans = """";
        while(!st.isEmpty()) {
            ans = st.peek() + ans;
            st.pop();
        }
        return ans;
    }
}",None,"class Solution {
    public String removeKdigits(String num, int k) {
        Stack<Character> st = new Stack<>();
        for(Character ch : num.toCharArray()) {
            while(!st.isEmpty() && k > 0 && ch < st.peek()) {
                st.pop();
                k--;
            }

            if(!st.isEmpty() || ch != '0') { 
                st.push(ch);
            }
        }

        while(!st.isEmpty() && k-- > 0) {
            st.pop();
        }
        if(st.isEmpty()) return ""0"";

        String ans = """";
        while(!st.isEmpty()) {
            ans = st.peek() + ans;
            st.pop();
        }
        return ans;
    }
}
"
2411,java,subtract-the-product-and-sum-of-digits-of-an-integer,"class Solution {
    public int subtractProductAndSum(int n) {
        
        int multi=1, sum=0;
        while(n!=0){
            int rem=n%10;
            sum+=rem;
            multi+=rem; 
            n=n/10;
        }
        return multi - sum;
    }
}",None,"class Solution {
    public int subtractProductAndSum(int n) {
        
        int multi=1, sum=0;
        while(n!=0){
            int rem=n%10;
            sum+=rem;
            multi*=rem; 
            n=n/10;
        }
        return multi - sum;
    }
}
"
2411,java,subtract-the-product-and-sum-of-digits-of-an-integer,"class Solution {
    public int subtractProductAndSum(int n) {
        
        int multi=1, sum=0;
        while(n!=0){
            int rem=n%10;
            sum+=rem;
            multi+=rem; 
            n=n/10;
        }
        return multi - sum;
    }
}",None,"class Solution {
    public int subtractProductAndSum(int n) {
        
        int multi=1, sum=0;
        while(n!=0){
            int rem=n%10;
            sum+=rem;
            multi*=rem; 
            n=n/10;
        }
        return multi - sum;
    }
}
"
2411,java,subtract-the-product-and-sum-of-digits-of-an-integer,"class Solution {
    public int subtractProductAndSum(int n) {
        
        int multi=1, sum=0;
        while(n!=0){
            int rem=n%10;
            sum+=rem;
            multi+=rem; 
            n=n/10;
        }
        return multi - sum;
    }
}",None,"class Solution {
    public int subtractProductAndSum(int n) {
        
        int multi=1, sum=0;
        while(n!=0){
            int rem=n%10;
            sum+=rem;
            multi*=rem; 
            n=n/10;
        }
        return multi - sum;
    }
}
"
2412,java,count-good-nodes-in-binary-tree,"class Solution {
    int count = 0;
    
    public void countGoodNodes(TreeNode root, int maximum) {
            if(root!=null) {
                if (maximum <= root.val) {
                    maximum = root.val;
                    count++;
                }
            countGoodNodes(root.left,maximum);
        } 
            countGoodNodes(root.right, maximum);
    }

    public int goodNodes(TreeNode root) {
        int maximum = root.val;
        countGoodNodes(root,  maximum);
        return count;
    }
}",None,"class Solution {
    int count = 0;
    
    public void countGoodNodes(TreeNode root, int maximum) {
            if(root!=null) {
                if (maximum <= root.val) {
                    maximum = root.val;
                    count++;
                }
                countGoodNodes(root.left, maximum);
                countGoodNodes(root.right, maximum);
            }
    }

    public int goodNodes(TreeNode root) {
        int maximum = root.val;
        countGoodNodes(root,  Integer.MIN_VALUE);
        return count;
    }
}
"
2412,java,count-good-nodes-in-binary-tree,"class Solution {
    int count = 0;
    
    public void countGoodNodes(TreeNode root, int maximum) {
            if(root!=null) {
                if (maximum <= root.val) {
                    maximum = root.val;
                    count++;
                }
            countGoodNodes(root.left,maximum);
        } 
            countGoodNodes(root.right, maximum);
    }

    public int goodNodes(TreeNode root) {
        int maximum = root.val;
        countGoodNodes(root,  maximum);
        return count;
    }
}",None,"class Solution {
    int count = 0;
    
    public void countGoodNodes(TreeNode root, int maximum) {
            if(root!=null) {
                if (maximum <= root.val) {
                    maximum = root.val;
                    count++;
                }
                countGoodNodes(root.left, maximum);
                countGoodNodes(root.right, maximum);
            }
    }

    public int goodNodes(TreeNode root) {
        int maximum = root.val;
        countGoodNodes(root,  Integer.MIN_VALUE);
        return count;
    }
}
"
2412,java,count-good-nodes-in-binary-tree,"class Solution {
    int count = 0;
    
    public void countGoodNodes(TreeNode root, int maximum) {
            if(root!=null) {
                if (maximum <= root.val) {
                    maximum = root.val;
                    count++;
                }
            countGoodNodes(root.left,maximum);
        } 
            countGoodNodes(root.right, maximum);
    }

    public int goodNodes(TreeNode root) {
        int maximum = root.val;
        countGoodNodes(root,  maximum);
        return count;
    }
}",None,"class Solution {
    int count = 0;
    
    public void countGoodNodes(TreeNode root, int maximum) {
            if(root!=null) {
                if (maximum <= root.val) {
                    maximum = root.val;
                    count++;
                }
            countGoodNodes(root.left, maximum);
            countGoodNodes(root.right, maximum);
        }
    }

    public int goodNodes(TreeNode root) {
        int maximum = root.val;
        countGoodNodes(root,  maximum);
        return count;
    }
}
"
2413,java,smallest-range-covering-elements-from-k-lists,"class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        int k = nums.size();
        List<Pair<Integer,Integer>> list = new ArrayList<>();
        for(int i = 0;i<k;i++){
            List<Integer> l = nums.get(i);
            for(int nu : l){
                list.add(new Pair(nu,i));
            }
        }
        
        Collections.sort(list,(a,b)-> a.getKey()-b.getKey());
        int[] ans = new int[2];
        ans[1] = ans[0] = Integer.MAX_VALUE; 
        int i = 0,j=0;
        List<Integer> store = new ArrayList<>();
        HashMap<Integer,Integer> mp = new HashMap<>();
        int totalType = 0;
        
        while(j<list.size()){
            int nu = list.get(j).getKey();
            int type = list.get(j).getValue();
            store.add(nu);
            int val = mp.getOrDefault(type,0);
            mp.put(type,val+1);
            totalType++;
            if(mp.size()<k){
                j++;
            }else if(mp.size()==k){
                if(ans[0]==ans[1] && ans[1] == Integer.MAX_VALUE){
                    ans[0] = store.get(0);
                    ans[1] = store.get(store.size()-1);
                }
                int dif = store.get(store.size()-1)-store.get(0);
                if(dif<ans[1]-ans[0]){
                    ans[0] = store.get(0);
                    ans[1] = store.get(store.size()-1);
                }  
                
                while(mp.size()==k){
                    dif = store.get(store.size()-1)-store.get(0);
                    if(dif<ans[1]-ans[0]){
                        ans[0] = store.get(0);
                        ans[1] = store.get(store.size()-1);
                    }
                    store.remove(0);
                    int t = list.get(i).getValue();
                    int vv = (int) mp.get(t);
                    if(vv==1){
                        mp.remove(t);
                    }
                    i++;
                }
                
                j++;
                
            }
   
        }
        
        
        return ans;
    }
}",None,"class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        int k = nums.size();
        List<Pair<Integer,Integer>> list = new ArrayList<>();
        for(int i = 0;i<k;i++){
            List<Integer> l = nums.get(i);
            for(int nu : l){
                list.add(new Pair(nu,i));
            }
        }
        
        Collections.sort(list,(a,b)-> a.getKey()-b.getKey());
        int[] ans = new int[2];
        ans[1] = ans[0] = Integer.MAX_VALUE; 
        int i = 0,j=0;
        List<Integer> store = new ArrayList<>();
        HashMap<Integer,Integer> mp = new HashMap<>();
        int totalType = 0;
        
        while(j<list.size()){
            int nu = list.get(j).getKey();
            int type = list.get(j).getValue();
            store.add(nu);
            int val = mp.getOrDefault(type,0);
            mp.put(type,val+1);
            totalType++;
            if(mp.size()<k){
                j++;
            }else if(mp.size()==k){
                if(ans[0]==ans[1] && ans[1] == Integer.MAX_VALUE){
                    ans[0] = store.get(0);
                    ans[1] = store.get(store.size()-1);
                }
                int dif = store.get(store.size()-1)-store.get(0);
                if(dif<ans[1]-ans[0]){
                    ans[0] = store.get(0);
                    ans[1] = store.get(store.size()-1);
                }  
                
                while(mp.size()==k && j<list.size()){
                    dif = store.get(store.size()-1)-store.get(0);
                    if(dif<ans[1]-ans[0]){
                        ans[0] = store.get(0);
                        ans[1] = store.get(store.size()-1);
                    }
                    int last = store.remove(0);
                    int t = list.get(i).getValue();
                    int vv = (int) mp.get(t);
                    if(vv==1){
                        mp.remove(t);
                    }else{
                        mp.put(t,vv-1);
                    }
                    i++;
                    j++;
                }
                
                j--;
                
            }
        }
        
        
        return ans;
    }
}
"
2413,java,smallest-range-covering-elements-from-k-lists,"class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        int k = nums.size();
        List<Pair<Integer,Integer>> list = new ArrayList<>();
        for(int i = 0;i<k;i++){
            List<Integer> l = nums.get(i);
            for(int nu : l){
                list.add(new Pair(nu,i));
            }
        }
        
        Collections.sort(list,(a,b)-> a.getKey()-b.getKey());
        int[] ans = new int[2];
        ans[1] = ans[0] = Integer.MAX_VALUE; 
        int i = 0,j=0;
        List<Integer> store = new ArrayList<>();
        HashMap<Integer,Integer> mp = new HashMap<>();
        int totalType = 0;
        
        while(j<list.size()){
            int nu = list.get(j).getKey();
            int type = list.get(j).getValue();
            store.add(nu);
            int val = mp.getOrDefault(type,0);
            mp.put(type,val+1);
            totalType++;
            if(mp.size()<k){
                j++;
            }else if(mp.size()==k){
                if(ans[0]==ans[1] && ans[1] == Integer.MAX_VALUE){
                    ans[0] = store.get(0);
                    ans[1] = store.get(store.size()-1);
                }
                int dif = store.get(store.size()-1)-store.get(0);
                if(dif<ans[1]-ans[0]){
                    ans[0] = store.get(0);
                    ans[1] = store.get(store.size()-1);
                }  
                
                while(mp.size()==k){
                    dif = store.get(store.size()-1)-store.get(0);
                    if(dif<ans[1]-ans[0]){
                        ans[0] = store.get(0);
                        ans[1] = store.get(store.size()-1);
                    }
                    store.remove(0);
                    int t = list.get(i).getValue();
                    int vv = (int) mp.get(t);
                    if(vv==1){
                        mp.remove(t);
                    }
                    i++;
                }
                
                j++;
                
            }
   
        }
        
        
        return ans;
    }
}",None,"class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        int k = nums.size();
        List<Pair<Integer,Integer>> list = new ArrayList<>();
        for(int i = 0;i<k;i++){
            List<Integer> l = nums.get(i);
            for(int nu : l){
                list.add(new Pair(nu,i));
            }
        }
        
        Collections.sort(list,(a,b)-> a.getKey()-b.getKey());
        int[] ans = new int[2];
        ans[1] = ans[0] = Integer.MAX_VALUE; 
        int i = 0,j=0;
        List<Integer> store = new ArrayList<>();
        HashMap<Integer,Integer> mp = new HashMap<>();
        int totalType = 0;
        
        while(j<list.size()){
            int nu = list.get(j).getKey();
            int type = list.get(j).getValue();
            store.add(nu);
            int val = mp.getOrDefault(type,0);
            mp.put(type,val+1);
            totalType++;
            if(mp.size()<k){
                j++;
            }else if(mp.size()==k){
                if(ans[0]==ans[1] && ans[1] == Integer.MAX_VALUE){
                    ans[0] = store.get(0);
                    ans[1] = store.get(store.size()-1);
                }
                int dif = store.get(store.size()-1)-store.get(0);
                if(dif<ans[1]-ans[0]){
                    ans[0] = store.get(0);
                    ans[1] = store.get(store.size()-1);
                }  
                
                while(mp.size()==k){
                    dif = store.get(store.size()-1)-store.get(0);
                    if(dif<ans[1]-ans[0]){
                        ans[0] = store.get(0);
                        ans[1] = store.get(store.size()-1);
                    }
                    int nu2 = store.remove(0);
                    int t = list.get(i).getValue();
                    int vv = (int) mp.get(t);
                    if(vv==1){
                        mp.remove(t);
                    } else {
                        mp.put(t,vv-1);
                    }
                    i++;
                }
                
                j++;
                
            }
        }
        
        
        return ans;
    }
}
"
2413,java,smallest-range-covering-elements-from-k-lists,"class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        int k = nums.size();
        List<Pair<Integer,Integer>> list = new ArrayList<>();
        for(int i = 0;i<k;i++){
            List<Integer> l = nums.get(i);
            for(int nu : l){
                list.add(new Pair(nu,i));
            }
        }
        
        Collections.sort(list,(a,b)-> a.getKey()-b.getKey());
        int[] ans = new int[2];
        ans[1] = ans[0] = Integer.MAX_VALUE; 
        int i = 0,j=0;
        List<Integer> store = new ArrayList<>();
        HashMap<Integer,Integer> mp = new HashMap<>();
        int totalType = 0;
        
        while(j<list.size()){
            int nu = list.get(j).getKey();
            int type = list.get(j).getValue();
            store.add(nu);
            int val = mp.getOrDefault(type,0);
            mp.put(type,val+1);
            totalType++;
            if(mp.size()<k){
                j++;
            }else if(mp.size()==k){
                if(ans[0]==ans[1] && ans[1] == Integer.MAX_VALUE){
                    ans[0] = store.get(0);
                    ans[1] = store.get(store.size()-1);
                }
                int dif = store.get(store.size()-1)-store.get(0);
                if(dif<ans[1]-ans[0]){
                    ans[0] = store.get(0);
                    ans[1] = store.get(store.size()-1);
                }  
                
                while(mp.size()==k){
                    dif = store.get(store.size()-1)-store.get(0);
                    if(dif<ans[1]-ans[0]){
                        ans[0] = store.get(0);
                        ans[1] = store.get(store.size()-1);
                    }
                    store.remove(0);
                    int t = list.get(i).getValue();
                    int vv = (int) mp.get(t);
                    if(vv==1){
                        mp.remove(t);
                    }
                    i++;
                }
                
                j++;
                
            }
   
        }
        
        
        return ans;
    }
}",None,"class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        int k = nums.size();
        List<Pair<Integer,Integer>> list = new ArrayList<>();
        for(int i = 0;i<k;i++){
            List<Integer> l = nums.get(i);
            for(int nu : l){
                list.add(new Pair(nu,i));
            }
        }
        
        Collections.sort(list,(a,b)-> a.getKey()-b.getKey());
        int[] ans = new int[2];
        ans[1] = ans[0] = Integer.MAX_VALUE; 
        int i = 0,j=0;
        List<Integer> store = new ArrayList<>();
        HashMap<Integer,Integer> mp = new HashMap<>();
        int totalType = 0;
        
        while(j<list.size()){
            int nu = list.get(j).getKey();
            int type = list.get(j).getValue();
            store.add(nu);
            int val = mp.getOrDefault(type,0);
            mp.put(type,val+1);
            totalType++;
            if(mp.size()<k){
                j++;
            }else if(mp.size()==k){
                if(ans[0]==ans[1] && ans[1] == Integer.MAX_VALUE){
                    ans[0] = store.get(0);
                    ans[1] = store.get(store.size()-1);
                }
                int dif = store.get(store.size()-1)-store.get(0);
                if(dif<ans[1]-ans[0]){
                    ans[0] = store.get(0);
                    ans[1] = store.get(store.size()-1);
                }  
                
                while(mp.size()==k && j<list.size()){
                    dif = store.get(store.size()-1)-store.get(0);
                    if(dif<ans[1]-ans[0]){
                        ans[0] = store.get(0);
                        ans[1] = store.get(store.size()-1);
                    }
                    nu = list.get(j).getKey();
                    type = list.get(j).getValue();
                    store.add(nu);
                    int val2 = mp.getOrDefault(type,0);
                    mp.put(type,val2+1);
                    if(mp.get(type)==1) totalType++;
                    j++;
                }
                
                while(mp.size()==k){
                    store.remove(0);
                    int t = list.get(i).getValue();
                    int vv = (int) mp.get(t);
                    if(vv==1){
                        mp.remove(t);
                        totalType--;
                    }
                    i++;
                }
                
                j++;
                
            }
        }
        
        return ans;
    }
}
"
2414,java,longest-string-chain,"class Solution {
    public int longestStrChain(String[] words) {
        Arrays.sort(words, (a, b) -> a.length() - b.length());
        
        Map<String, Integer> dp = new HashMap<>();
        int maxChainLength = 1;
        
        for (String word : words) {
            int longestChain = 0;
            for (int i = 0; i < word.length(); i++) {
                StringBuilder sb = new StringBuilder(word);
                sb.deleteCharAt(i);
                String predecessor = sb.toString();
                if (dp.containsKey(predecessor)) {
                    longestChain = Math.max(longestChain, dp.get(predecessor) + 1);
                }
            }
            dp.put(word, longestChain);
            maxChainLength = Math.max(maxChainLength, longestChain);
        }
        
        return maxChainLength;
    }
}",None,"class Solution {
    public int longestStrChain(String[] words) {
        Arrays.sort(words, (a, b) -> a.length() - b.length());
        
        Map<String, Integer> dp = new HashMap<>();
        int maxChainLength = 1;
        
        for (String word : words) {
            int longestChain = 0;
            for (int i = 0; i < word.length(); i++) {
                StringBuilder sb = new StringBuilder(word);
                sb.deleteCharAt(i);
                String predecessor = sb.toString();
                if (dp.containsKey(predecessor)) {
                    longestChain = Math.max(longestChain, dp.get(predecessor) + 1);
                }
            }
            dp.put(word, longestChain);
            maxChainLength = Math.max(maxChainLength, longestChain);
        }
        
        return maxChainLength;
    }
}
"
2414,java,longest-string-chain,"class Solution {
    public int longestStrChain(String[] words) {
        Arrays.sort(words, (a, b) -> a.length() - b.length());
        
        Map<String, Integer> dp = new HashMap<>();
        int maxChainLength = 1;
        
        for (String word : words) {
            int longestChain = 0;
            for (int i = 0; i < word.length(); i++) {
                StringBuilder sb = new StringBuilder(word);
                sb.deleteCharAt(i);
                String predecessor = sb.toString();
                if (dp.containsKey(predecessor)) {
                    longestChain = Math.max(longestChain, dp.get(predecessor) + 1);
                }
            }
            dp.put(word, longestChain);
            maxChainLength = Math.max(maxChainLength, longestChain);
        }
        
        return maxChainLength;
    }
}",None,"class Solution {
    public int longestStrChain(String[] words) {
        Arrays.sort(words, (a, b) -> a.length() - b.length());
        
        Map<String, Integer> dp = new HashMap<>();
        int maxChainLength = 1;
        
        for (String word : words) {
            int longestChain = 0;
            for (int i = 0; i < word.length(); i++) {
                StringBuilder sb = new StringBuilder(word);
                sb.deleteCharAt(i);
                String predecessor = sb.toString();
                if (dp.containsKey(predecessor)) {
                    longestChain = Math.max(longestChain, dp.get(predecessor) + 1);
                }
            }
            dp.put(word, longestChain);
            maxChainLength = Math.max(maxChainLength, longestChain);
        }
        
        return maxChainLength;
    }
}
"
2414,java,longest-string-chain,"class Solution {
    public int longestStrChain(String[] words) {
        Arrays.sort(words, (a, b) -> a.length() - b.length());
        
        Map<String, Integer> dp = new HashMap<>();
        int maxChainLength = 1;
        
        for (String word : words) {
            int longestChain = 0;
            for (int i = 0; i < word.length(); i++) {
                StringBuilder sb = new StringBuilder(word);
                sb.deleteCharAt(i);
                String predecessor = sb.toString();
                if (dp.containsKey(predecessor)) {
                    longestChain = Math.max(longestChain, dp.get(predecessor) + 1);
                }
            }
            dp.put(word, longestChain);
            maxChainLength = Math.max(maxChainLength, longestChain);
        }
        
        return maxChainLength;
    }
}",None,"class Solution {
    public int longestStrChain(String[] words) {
        Arrays.sort(words, (a, b) -> a.length() - b.length());
        
        Map<String, Integer> dp = new HashMap<>();
        int maxChainLength = 1;
        
        for (String word : words) {
            int longestChain = 0;
            for (int i = 0; i < word.length(); i++) {
                StringBuilder sb = new StringBuilder(word);
                sb.deleteCharAt(i);
                String predecessor = sb.toString();
                if (dp.containsKey(predecessor)) {
                    longestChain = Math.max(longestChain, dp.get(predecessor) + 1);
                }
            }
            dp.put(word, longestChain);
            maxChainLength = Math.max(maxChainLength, longestChain);
        }
        
        return maxChainLength;
    }
}
"
2415,java,maximum-ice-cream-bars,"class Solution {
    public int maxIceCream(int[] costs, int coins) {
        int [] arr = new int [100001];
        for(int x : costs)arr[x]++;
        int count = 0;
        int index = 1;
        while(index<100001 && coins>=index*arr[index]){
            coins-=index*arr[index];
            count+=arr[index];
            index++;
        }

        while(index<100001 && coins>=index){
            coins-=index;
            index++;
            count++;
        }
        return count;
    }
}",None,"class Solution {
    public int maxIceCream(int[] costs, int coins) {
        int [] arr = new int [100001];
        for(int x : costs)arr[x]++;
        int count = 0;
        int index = 1;
        while(index<100001 && coins>=index*arr[index]){
            coins-=index*arr[index];
            count+=arr[index];
            index++;
        }

        while(index<100001 && coins>=arr[index]){
            coins-=arr[index];
            count++;
            index++;
        }
        return count;
    }
}
"
2415,java,maximum-ice-cream-bars,"class Solution {
    public int maxIceCream(int[] costs, int coins) {
        int [] arr = new int [100001];
        for(int x : costs)arr[x]++;
        int count = 0;
        int index = 1;
        while(index<100001 && coins>=index*arr[index]){
            coins-=index*arr[index];
            count+=arr[index];
            index++;
        }

        while(index<100001 && coins>=index){
            coins-=index;
            index++;
            count++;
        }
        return count;
    }
}",None,"class Solution {
    public int maxIceCream(int[] costs, int coins) {
        int [] arr = new int [100001];
        for(int x : costs)arr[x]++;
        int count = 0;
        int index = 1;
        while(index<100001 && coins>=index*arr[index]){
            coins-=index*arr[index];
            count+=arr[index];
            index++;
        }

        while(index<100001 && coins>=arr[index]){
            coins-=arr[index];
            count++;
            index++;
        }
        return count;
    }
}
"
2415,java,maximum-ice-cream-bars,"class Solution {
    public int maxIceCream(int[] costs, int coins) {
        int [] arr = new int [100001];
        for(int x : costs)arr[x]++;
        int count = 0;
        int index = 1;
        while(index<100001 && coins>=index*arr[index]){
            coins-=index*arr[index];
            count+=arr[index];
            index++;
        }

        while(index<100001 && coins>=index){
            coins-=index;
            index++;
            count++;
        }
        return count;
    }
}",None,"class Solution {
    public int maxIceCream(int[] costs, int coins) {
        int [] arr = new int [100001];
        for(int x : costs)arr[x]++;
        int count = 0;
        int index = 1;
        while(index<100001 && coins>=index*arr[index]){
            coins-=index*arr[index];
            count+=arr[index];
            index++;
        }

        while(index<100001 && coins>=arr[index]){
            coins-=arr[index];
            index++;
            count++;
        }
        return count;
    }
}
"
2416,java,sort-even-and-odd-indices-independently,"class Solution {
    public int[] sortEvenOdd(int[] nums) {
        PriorityQueue<Integer> queue = new PriorityQueue<>();
        for(int i=0;i<nums.length;i++){
            queue.add(nums[i]);
        }
        for(int i=0;i<nums.length;i+=2){
            nums[i]=queue.poll();
        }
        queue = new PriorityQueue<>(new MaxHeap());
        for(int i=1;i<nums.length;i++){
            queue.add(nums[i]);
        }
        for(int i=1;i<nums.length;i+=2){
            nums[i]=queue.poll();
        }
        return nums;
    }
}
class MaxHeap implements Comparator<Integer>{
    public int compare(Integer ca,Integer cb){
        return cb-ca;
    }
}",None,"class Solution {
    public int[] sortEvenOdd(int[] nums) {
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
        for(int i=0;i<nums.length;i++){
            maxHeap.add(nums[i]);
        }
        for(int i=0;i<nums.length;i+=2){
            nums[i]=maxHeap.poll();
        }
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        for(int i=1;i<nums.length;i++){
            minHeap.add(nums[i]);
        }
        for(int i=1;i<nums.length;i+=2){
            nums[i]=minHeap.poll();
        }
        return nums;
    }
}
"
2416,java,sort-even-and-odd-indices-independently,"class Solution {
    public int[] sortEvenOdd(int[] nums) {
        PriorityQueue<Integer> queue = new PriorityQueue<>();
        for(int i=0;i<nums.length;i++){
            queue.add(nums[i]);
        }
        for(int i=0;i<nums.length;i+=2){
            nums[i]=queue.poll();
        }
        queue = new PriorityQueue<>(new MaxHeap());
        for(int i=1;i<nums.length;i++){
            queue.add(nums[i]);
        }
        for(int i=1;i<nums.length;i+=2){
            nums[i]=queue.poll();
        }
        return nums;
    }
}
class MaxHeap implements Comparator<Integer>{
    public int compare(Integer ca,Integer cb){
        return cb-ca;
    }
}",None,"class Solution {
    public int[] sortEvenOdd(int[] nums) {
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());
        for(int i=0;i<nums.length;i++){
            maxHeap.add(nums[i]);
        }
        for(int i=0;i<nums.length;i+=2){
            nums[i]=maxHeap.poll();
        }
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        for(int i=1;i<nums.length;i++){
            minHeap.add(nums[i]);
        }
        for(int i=1;i<nums.length;i+=2){
            nums[i]=minHeap.poll();
        }
        return nums;
    }
}
"
2416,java,sort-even-and-odd-indices-independently,"class Solution {
    public int[] sortEvenOdd(int[] nums) {
        PriorityQueue<Integer> queue = new PriorityQueue<>();
        for(int i=0;i<nums.length;i++){
            queue.add(nums[i]);
        }
        for(int i=0;i<nums.length;i+=2){
            nums[i]=queue.poll();
        }
        queue = new PriorityQueue<>(new MaxHeap());
        for(int i=1;i<nums.length;i++){
            queue.add(nums[i]);
        }
        for(int i=1;i<nums.length;i+=2){
            nums[i]=queue.poll();
        }
        return nums;
    }
}
class MaxHeap implements Comparator<Integer>{
    public int compare(Integer ca,Integer cb){
        return cb-ca;
    }
}",None,"class Solution {
    public int[] sortEvenOdd(int[] nums) {
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);
        for (int i = 0; i < nums.length; i++) {
            maxHeap.add(nums[i]);
        }
        for (int i = 0; i < nums.length; i += 2) {
            nums[i] = maxHeap.poll();
        }
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        for (int i = 1; i < nums.length; i++) {
            minHeap.add(nums[i]);
        }
        for (int i = 1; i < nums.length; i += 2) {
            nums[i] = minHeap.poll();
        }
        return nums;
    }
}
"
2417,java,longest-common-prefix,"class Solution {
    public String longestCommonPrefix(String[] strs) {
        Arrays.sort(strs);
        String start = strs[0];
        String end = strs[strs.length];
        int count = 0;
        for (int i = 0; i < start.length(); i++) {
            if (start.charAt(i) == end.charAt(i)) {
                count++;
            } else {
                break;
            }
        }
        return end.substring(0, count);
    }
}",None,"class Solution {
    public String longestCommonPrefix(String[] strs) {
        Arrays.sort(strs);
        String start = strs[0];
        String end = strs[strs.length - 1];
        int count = 0;
        for (int i = 0; i < start.length(); i++) {
            if (start.charAt(i) == end.charAt(i)) {
                count++;
            } else {
                break;
            }
        }
        return start.substring(0, count);
    }
}
"
2417,java,longest-common-prefix,"class Solution {
    public String longestCommonPrefix(String[] strs) {
        Arrays.sort(strs);
        String start = strs[0];
        String end = strs[strs.length];
        int count = 0;
        for (int i = 0; i < start.length(); i++) {
            if (start.charAt(i) == end.charAt(i)) {
                count++;
            } else {
                break;
            }
        }
        return end.substring(0, count);
    }
}",None,"class Solution {
    public String longestCommonPrefix(String[] strs) {
        Arrays.sort(strs);
        String start = strs[0];
        String end = strs[strs.length - 1];
        int count = 0;
        for (int i = 0; i < start.length(); i++) {
            if (start.charAt(i) == end.charAt(i)) {
                count++;
            } else {
                break;
            }
        }
        return start.substring(0, count);
    }
}
"
2417,java,longest-common-prefix,"class Solution {
    public String longestCommonPrefix(String[] strs) {
        Arrays.sort(strs);
        String start = strs[0];
        String end = strs[strs.length];
        int count = 0;
        for (int i = 0; i < start.length(); i++) {
            if (start.charAt(i) == end.charAt(i)) {
                count++;
            } else {
                break;
            }
        }
        return end.substring(0, count);
    }
}",None,"class Solution {
    public String longestCommonPrefix(String[] strs) {
        Arrays.sort(strs);
        String start = strs[0];
        String end = strs[strs.length - 1];
        int count = 0;
        for (int i = 0; i < start.length(); i++) {
            if (start.charAt(i) == end.charAt(i)) {
                count++;
            } else {
                break;
            }
        }
        return start.substring(0, count);
    }
}
"
2418,java,minimum-operations-to-make-array-equal,"class Solution {
    public int minOperations(int n) {
        int result = 0;
        
        if (n % 2 == 0) {
            result = (n / 2) * (n / 2);
        } else {
            result = ((n + 1) / 2) * ((n + 1) / 2);
        }
        
        return result;
    }
}",None,"class Solution {
    public int minOperations(int n) {
        int result = 0;
        
        if (n % 2 == 0) {
            result = (n / 2) * (n / 2);
        } else {
            result = ((n + 1) / 2) * ((n + 1) / 2);
        }
        
        return (n - 1) - result;
    }
}
"
2418,java,minimum-operations-to-make-array-equal,"class Solution {
    public int minOperations(int n) {
        int result = 0;
        
        if (n % 2 == 0) {
            result = (n / 2) * (n / 2);
        } else {
            result = ((n + 1) / 2) * ((n + 1) / 2);
        }
        
        return result;
    }
}",None,"class Solution {
    public int minOperations(int n) {
        int result = 0;
        
        if (n % 2 == 0) {
            result = (n / 2) * (n / 2);
        } else {
            result = ((n + 1) / 2) * ((n + 1) / 2) - n;
        }
        
        return result;
    }
}
"
2418,java,minimum-operations-to-make-array-equal,"class Solution {
    public int minOperations(int n) {
        int result = 0;
        
        if (n % 2 == 0) {
            result = (n / 2) * (n / 2);
        } else {
            result = ((n + 1) / 2) * ((n + 1) / 2);
        }
        
        return result;
    }
}",None,"class Solution {
    public int minOperations(int n) {
        int result = 0;
        
        if (n % 2 == 0) {
            result = (n / 2) * (n / 2);
        } else {
            result = ((n + 1) / 2) * ((n + 1) / 2) - n;
        }
        
        return result;
    }
}
"
2419,java,count-the-number-of-good-subarrays,"class Solution {
        public long countGood(int[] nums, int k) {
        long ans = 0;
        HashMap<Integer, Integer> map = new HashMap<>();
        int j = 0;
        long countPairs = 0;

        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(nums[i])) {

                int val = map.get(nums[i]);
                countPairs -= ((long) val * (val - 1) / 2);
                map.put(nums[i], map.get(nums[i]) + 1);
                val = map.get(nums[i]);
                countPairs += ((long) val * (val - 1) / 2);

            } else{
                map.put(nums[i], 0);
            }
            
            while (j <= i && countPairs >= k) {
                int cur = map.get(nums[j]);
                countPairs -= (long) cur * (cur - 1) / 2;
                map.put(nums[j], cur - 1);
                cur = map.get(nums[j]);
                countPairs += (long) (cur ) * (cur -1) / 2;
                j++;
                ans += (nums.length - i);
            }

        }
        return ans;

    }
}",None,"class Solution {
    public long countGood(int[] nums, int k) {
        long ans = 0;
        HashMap<Integer, Integer> map = new HashMap<>();
        int j = 0;
        long countPairs = 0;

        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(nums[i])) {

                int val = map.get(nums[i]);
                countPairs -= ((long) val * (val - 1) / 2);
                map.put(nums[i], map.get(nums[i]) + 1);
                val = map.get(nums[i]);
                countPairs += ((long) val * (val - 1) / 2);

            } else{
                map.put(nums[i], 1);
            }
            
            while (j <= i && countPairs >= k) {
                int cur = map.get(nums[j]);
                countPairs -= (long) cur * (cur - 1) / 2;
                map.put(nums[j], cur - 1);
                cur = map.get(nums[j]);
                countPairs += (long) (cur ) * (cur -1) / 2;
                j++;
                ans += (nums.length - i);
            }

        }
        return ans;

    }
}
"
2419,java,count-the-number-of-good-subarrays,"class Solution {
        public long countGood(int[] nums, int k) {
        long ans = 0;
        HashMap<Integer, Integer> map = new HashMap<>();
        int j = 0;
        long countPairs = 0;

        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(nums[i])) {

                int val = map.get(nums[i]);
                countPairs -= ((long) val * (val - 1) / 2);
                map.put(nums[i], map.get(nums[i]) + 1);
                val = map.get(nums[i]);
                countPairs += ((long) val * (val - 1) / 2);

            } else{
                map.put(nums[i], 0);
            }
            
            while (j <= i && countPairs >= k) {
                int cur = map.get(nums[j]);
                countPairs -= (long) cur * (cur - 1) / 2;
                map.put(nums[j], cur - 1);
                cur = map.get(nums[j]);
                countPairs += (long) (cur ) * (cur -1) / 2;
                j++;
                ans += (nums.length - i);
            }

        }
        return ans;

    }
}",None,"class Solution {
    public long countGood(int[] nums, int k) {
        long ans = 0;
        HashMap<Integer, Integer> map = new HashMap<>();
        int j = 0;
        long countPairs = 0;

        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(nums[i])) {

                int val = map.get(nums[i]);
                countPairs -= ((long) val * (val - 1) / 2);
                map.put(nums[i], map.get(nums[i]) + 1);
                val = map.get(nums[i]);
                countPairs += ((long) val * (val - 1) / 2);

            } else{
                map.put(nums[i], 1);
            }

            while (j <= i && countPairs >= k) {
                int cur = map.get(nums[j]);
                countPairs -= (long) cur * (cur - 1) / 2;
                map.put(nums[j], cur - 1);
                cur = map.get(nums[j]);
                countPairs += (long) (cur ) * (cur -1) / 2;
                j++;
                ans += (nums.length - i);
            }

        }
        return ans;

    }
}
"
2419,java,count-the-number-of-good-subarrays,"class Solution {
        public long countGood(int[] nums, int k) {
        long ans = 0;
        HashMap<Integer, Integer> map = new HashMap<>();
        int j = 0;
        long countPairs = 0;

        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(nums[i])) {

                int val = map.get(nums[i]);
                countPairs -= ((long) val * (val - 1) / 2);
                map.put(nums[i], map.get(nums[i]) + 1);
                val = map.get(nums[i]);
                countPairs += ((long) val * (val - 1) / 2);

            } else{
                map.put(nums[i], 0);
            }
            
            while (j <= i && countPairs >= k) {
                int cur = map.get(nums[j]);
                countPairs -= (long) cur * (cur - 1) / 2;
                map.put(nums[j], cur - 1);
                cur = map.get(nums[j]);
                countPairs += (long) (cur ) * (cur -1) / 2;
                j++;
                ans += (nums.length - i);
            }

        }
        return ans;

    }
}",None,"class Solution {
    public long countGood(int[] nums, int k) {
        long ans = 0;
        HashMap<Integer, Integer> map = new HashMap<>();
        int j = 0;
        long countPairs = 0;

        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(nums[i])) {

                int val = map.get(nums[i]);
                countPairs -= ((long) val * (val - 1) / 2);
                map.put(nums[i], map.get(nums[i]) + 1);
                val = map.get(nums[i]);
                countPairs += ((long) val * (val - 1) / 2);

            } else{
                map.put(nums[i], 1);
            }

            while (j <= i && countPairs >= k) {
                int cur = map.get(nums[j]);
                countPairs -= (long) cur * (cur - 1) / 2;
                map.put(nums[j], cur - 1);
                cur = map.get(nums[j]);
                countPairs += (long) (cur ) * (cur -1) / 2;
                j++;
                ans += (nums.length - i);
            }

        }
        return ans;

    }
}
"
2420,java,minimum-amount-of-time-to-fill-cups,"class Solution {
    public int fillCups(int[] amount) {
        Arrays.sort(amount);
        int ans = 0;
        int lo=0, hi=2;
        if(amount[0] == 0) lo++;
        if(lo==1 && amount[1]==0) return amount[2];

        else if(lo==1){
            ans += amount[hi];
            return ans;
        }
        while(amount[lo] != 0){
            ans++;
            amount[lo]--;
            amount[hi]--;
            if(amount[hi-1] > amount[hi]){
                int temp = amount[hi-1];
                amount[hi-1] = amount[hi];
                amount[hi] = temp;
            }
        }

        ans += amount[3];
        return ans;
    }
}",None,"class Solution {
    public int fillCups(int[] amount) {
        Arrays.sort(amount);
        int ans = 0;
        int lo=0, hi=2;
        if(amount[0] == 0) lo++;
        if(lo==1 && amount[1]==0) return amount[2];

        else if(lo==1){
            ans += amount[hi];
            return ans;
        }
        while(amount[lo] != 0){
            ans++;
            amount[lo]--;
            amount[hi]--;
            if(amount[hi-1] > amount[hi]){
                int temp = amount[hi-1];
                amount[hi-1] = amount[hi];
                amount[hi] = temp;
            }
        }

        ans += amount[2];
        return ans;
    }
}
"
2420,java,minimum-amount-of-time-to-fill-cups,"class Solution {
    public int fillCups(int[] amount) {
        Arrays.sort(amount);
        int ans = 0;
        int lo=0, hi=2;
        if(amount[0] == 0) lo++;
        if(lo==1 && amount[1]==0) return amount[2];

        else if(lo==1){
            ans += amount[hi];
            return ans;
        }
        while(amount[lo] != 0){
            ans++;
            amount[lo]--;
            amount[hi]--;
            if(amount[hi-1] > amount[hi]){
                int temp = amount[hi-1];
                amount[hi-1] = amount[hi];
                amount[hi] = temp;
            }
        }

        ans += amount[3];
        return ans;
    }
}",None,"class Solution {
    public int fillCups(int[] amount) {
        Arrays.sort(amount);
        int ans = 0;
        int lo=0, hi=2;
        if(amount[0] == 0) lo=1;

        while(lo<=2 && amount[lo] != 0){
            ans++;
            amount[lo]--;
            amount[hi]--;
            if(lo<hi && amount[lo-1] > amount[lo]){
                int temp = amount[lo-1];
                amount[lo-1] = amount[lo];
                amount[lo] = temp;
            }
            if(lo<2) lo++;
            else hi--;
        }

        ans += amount[2];
        return ans;
    }
}
"
2420,java,minimum-amount-of-time-to-fill-cups,"class Solution {
    public int fillCups(int[] amount) {
        Arrays.sort(amount);
        int ans = 0;
        int lo=0, hi=2;
        if(amount[0] == 0) lo++;
        if(lo==1 && amount[1]==0) return amount[2];

        else if(lo==1){
            ans += amount[hi];
            return ans;
        }
        while(amount[lo] != 0){
            ans++;
            amount[lo]--;
            amount[hi]--;
            if(amount[hi-1] > amount[hi]){
                int temp = amount[hi-1];
                amount[hi-1] = amount[hi];
                amount[hi] = temp;
            }
        }

        ans += amount[3];
        return ans;
    }
}",None,"class Solution {
    public int fillCups(int[] amount) {
        Arrays.sort(amount);
        int ans = 0;
        int lo=0, hi=2;
        if(amount[0] == 0) lo++;
        if(lo==1 && amount[1]==0) return amount[2];

        else if(lo==1){
            ans += amount[hi];
            return ans;
        }
        while(amount[lo] != 0){
            ans++;
            amount[lo]--;
            amount[hi]--;
            if(amount[hi-1] > amount[hi]){
                int temp = amount[hi-1];
                amount[hi-1] = amount[hi];
                amount[hi] = temp;
            }
        }

        ans += amount[2];
        return ans;
    }
}
"
2421,java,knight-probability-in-chessboard,"class Solution {
    public double knightProbability(int n, int k, int row, int column) {
        int[][] dir = {{-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}};
        double[][][] dp = new double[k + 1][n][n];
        dp[0][row][column] = 1.0;
        for (int i = 1; i <= k; i++) {
            for (int r = 0; r < n; r++) {
                for (int c = 0; c < n; c++) {
                    for (int[] d : dir) {
                        int newRow = r + d[0];
                        int newCol = c + d[1];
                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {
                            dp[i][r][c] += dp[i][newRow][newCol] / 8.0;
                        }
                    }
                }
            }
        }
        double output = 0.0;
        for (int r = 0; r < n; r++) {
            for (int c = 0; c < n; c++) {
                output += dp[k][r][c];
            }
        }
        return output;
    }
}",None,"class Solution {
    public double knightProbability(int n, int k, int row, int column) {
        int[][] dir = {{-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}};
        double[][][] dp = new double[k + 1][n][n];
        dp[0][row][column] = 1.0;
        for (int i = 1; i <= k; i++) {
            for (int r = 0; r < n; r++) {
                for (int c = 0; c < n; c++) {
                    for (int[] d : dir) {
                        int newRow = r + d[0];
                        int newCol = c + d[1];
                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {
                            dp[i][r][c] += dp[i - 1][newRow][newCol] / 8.0;
                        }
                    }
                }
            }
        }
        return dp[k][row][column];
    }
}
"
2421,java,knight-probability-in-chessboard,"class Solution {
    public double knightProbability(int n, int k, int row, int column) {
        int[][] dir = {{-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}};
        double[][][] dp = new double[k + 1][n][n];
        dp[0][row][column] = 1.0;
        for (int i = 1; i <= k; i++) {
            for (int r = 0; r < n; r++) {
                for (int c = 0; c < n; c++) {
                    for (int[] d : dir) {
                        int newRow = r + d[0];
                        int newCol = c + d[1];
                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {
                            dp[i][r][c] += dp[i][newRow][newCol] / 8.0;
                        }
                    }
                }
            }
        }
        double output = 0.0;
        for (int r = 0; r < n; r++) {
            for (int c = 0; c < n; c++) {
                output += dp[k][r][c];
            }
        }
        return output;
    }
}",None,"class Solution {
    public double knightProbability(int n, int k, int row, int column) {
        int[][] dir = {{-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}};
        double[][][] dp = new double[k + 1][n][n];
        dp[0][row][column] = 1.0;
        for (int i = 1; i <= k; i++) {
            for (int r = 0; r < n; r++) {
                for (int c = 0; c < n; c++) {
                    for (int[] d : dir) {
                        int newRow = r + d[0];
                        int newCol = c + d[1];
                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {
                            dp[i][r][c] += dp[i - 1][newRow][newCol] / 8.0;
                        }
                    }
                }
            }
        }
        return dp[k][row][column];
    }
}
"
2421,java,knight-probability-in-chessboard,"class Solution {
    public double knightProbability(int n, int k, int row, int column) {
        int[][] dir = {{-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}};
        double[][][] dp = new double[k + 1][n][n];
        dp[0][row][column] = 1.0;
        for (int i = 1; i <= k; i++) {
            for (int r = 0; r < n; r++) {
                for (int c = 0; c < n; c++) {
                    for (int[] d : dir) {
                        int newRow = r + d[0];
                        int newCol = c + d[1];
                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {
                            dp[i][r][c] += dp[i][newRow][newCol] / 8.0;
                        }
                    }
                }
            }
        }
        double output = 0.0;
        for (int r = 0; r < n; r++) {
            for (int c = 0; c < n; c++) {
                output += dp[k][r][c];
            }
        }
        return output;
    }
}",None,"class Solution {
    public double knightProbability(int n, int k, int row, int column) {
        int[][] dir = {{-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}};
        double[][][] dp = new double[k + 1][n][n];
        dp[0][row][column] = 1.0;
        for (int i = 1; i <= k; i++) {
            for (int r = 0; r < n; r++) {
                for (int c = 0; c < n; c++) {
                    for (int[] d : dir) {
                        int newRow = r + d[0];
                        int newCol = c + d[1];
                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {
                            dp[i][r][c] += dp[i - 1][newRow][newCol] / 8.0;
                        }
                    }
                }
            }
        }
        return dp[k][row][column];
    }
}
"
2422,java,airplane-seat-assignment-probability,"class Solution {
    public double nthPersonGetsNthSeat(int n) {
        if(n==1)
        return 1.00000;
        else
        return 1.50000;
    }
}",None,"class Solution {
    public double nthPersonGetsNthSeat(int n) {
        if(n==1)
        return 1.00000;
        else
        return 0.50000;
    }
}
"
2422,java,airplane-seat-assignment-probability,"class Solution {
    public double nthPersonGetsNthSeat(int n) {
        if(n==1)
        return 1.00000;
        else
        return 1.50000;
    }
}",None,"class Solution {
    public double nthPersonGetsNthSeat(int n) {
        if(n==1)
        return 1.00000;
        else
        return 0.50000;
    }
}
"
2422,java,airplane-seat-assignment-probability,"class Solution {
    public double nthPersonGetsNthSeat(int n) {
        if(n==1)
        return 1.00000;
        else
        return 1.50000;
    }
}",None,"class Solution {
    public double nthPersonGetsNthSeat(int n) {
        if(n==1)
        return 1.00000;
        else
        return 0.50000;
    }
}
"
2423,java,intersection-of-two-linked-lists,"class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int ac = 0;
        int bc = 0;
        ListNode a = headA;
        ListNode b = headB;
        while(a != null){
            ac++;
            a = a.next;
        }
        while(b != null){
            bc++;
            b = b.next;
        }
        while(ac > bc){
            ac--;
            headA = headA.next;
        }
        while(bc > ac){
            bc--;
            headB = headB.next;
        }
        
        while(headA != headB){
            headA = headA.next;
            headB = headB.next;
        }
        
        return b;  
    }
}",None,"class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int ac = 0;
        int bc = 0;
        ListNode a = headA;
        ListNode b = headB;
        while(a != null){
            ac++;
            a = a.next;
        }
        while(b != null){
            bc++;
            b = b.next;
        }
        while(ac > bc){
            ac--;
            headA = headA.next;
        }
        while(bc > ac){
            bc--;
            headB = headB.next;
        }
        
        while(headA != headB){
            headA = headA.next;
            headB = headB.next;
        }
        
        return headA;  
    }
}
"
2423,java,intersection-of-two-linked-lists,"class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int ac = 0;
        int bc = 0;
        ListNode a = headA;
        ListNode b = headB;
        while(a != null){
            ac++;
            a = a.next;
        }
        while(b != null){
            bc++;
            b = b.next;
        }
        while(ac > bc){
            ac--;
            headA = headA.next;
        }
        while(bc > ac){
            bc--;
            headB = headB.next;
        }
        
        while(headA != headB){
            headA = headA.next;
            headB = headB.next;
        }
        
        return b;  
    }
}",None,"class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int ac = 0;
        int bc = 0;
        ListNode a = headA;
        ListNode b = headB;
        while(a != null){
            ac++;
            a = a.next;
        }
        while(b != null){
            bc++;
            b = b.next;
        }
        while(ac > bc){
            ac--;
            headA = headA.next;
        }
        while(bc > ac){
            bc--;
            headB = headB.next;
        }
        
        while(headA != headB){
            headA = headA.next;
            headB = headB.next;
        }
        
        return headA;  
    }
}
"
2423,java,intersection-of-two-linked-lists,"class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int ac = 0;
        int bc = 0;
        ListNode a = headA;
        ListNode b = headB;
        while(a != null){
            ac++;
            a = a.next;
        }
        while(b != null){
            bc++;
            b = b.next;
        }
        while(ac > bc){
            ac--;
            headA = headA.next;
        }
        while(bc > ac){
            bc--;
            headB = headB.next;
        }
        
        while(headA != headB){
            headA = headA.next;
            headB = headB.next;
        }
        
        return b;  
    }
}",None,"class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int ac = 0;
        int bc = 0;
        ListNode a = headA;
        ListNode b = headB;
        while(a != null){
            ac++;
            a = a.next;
        }
        while(b != null){
            bc++;
            b = b.next;
        }
        while(ac > bc){
            ac--;
            headA = headA.next;
        }
        while(bc > ac){
            bc--;
            headB = headB.next;
        }
        
        while(headA != headB){
            headA = headA.next;
            headB = headB.next;
        }
        
        return headA;  
    }
}
"
2424,java,maximum-average-pass-ratio,"class Solution {
    public double maxAverageRatio(int[][] classes, int extraStudents) {
        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());
        for(int[] cl : classes){
            pq.add(new Class(cl));
        }
        while(extraStudents > 0){
            Class c = pq.remove();
            c.addExtraStudent();
            extraStudents--;
        }
        double sum = 0;
        while(!pq.isEmpty()){
            Class c = pq.remove();
            sum += c.pass / c.total;
        }
        return sum / classes.length;
    }
}
class Class{
    double pass;
    double total;
    double inc;
    public Class(int[] cl){
        pass = cl[0];
        total = cl[1];
        inc = (pass + 1) / (total + 1) - pass / total;
    }
    public void addExtraStudent(){
        pass += 1;
        total += 1;
        inc = (pass + 1) / (total + 1) - pass / total;
    }
}
class Compare implements Comparator<Class>{
    public int compare(Class c1, Class c2){
        if(c1.inc < c2.inc){
            return 1;
        }else if(c1.inc > c2.inc){
            return -1;
        }else{
            return 0;
        }
    }
}",None,"class Solution {
    public double maxAverageRatio(int[][] classes, int extraStudents) {
        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());
        for(int[] cl : classes){
            pq.add(new Class(cl[0], cl[1]));
        }
        while(extraStudents > 0){
            Class c = pq.remove();
            c.addExtraStudent();
            extraStudents--;
            pq.add(c);
        }
        double sum = 0;
        while(!pq.isEmpty()){
            Class c = pq.remove();
            sum += c.pass / c.total;
        }
        return sum / classes.length;
    }
}
class Class{
    double pass;
    double total;
    public Class(int p, int t){
        pass = p;
        total = t;
    }
    public void addExtraStudent(){
        pass++;
        total++;
    }
}
class Compare implements Comparator<Class>{
    public int compare(Class c1, Class c2){
        double inc1 = (c1.pass + 1) / (c1.total + 1) - c1.pass / c1.total;
        double inc2 = (c2.pass + 1) / (c2.total + 1) - c2.pass / c2.total;
        if(inc1 < inc2){
            return 1;
        }else if(inc1 > inc2){
            return -1;
        }else{
            return 0;
        }
    }
}
"
2424,java,maximum-average-pass-ratio,"class Solution {
    public double maxAverageRatio(int[][] classes, int extraStudents) {
        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());
        for(int[] cl : classes){
            pq.add(new Class(cl));
        }
        while(extraStudents > 0){
            Class c = pq.remove();
            c.addExtraStudent();
            extraStudents--;
        }
        double sum = 0;
        while(!pq.isEmpty()){
            Class c = pq.remove();
            sum += c.pass / c.total;
        }
        return sum / classes.length;
    }
}
class Class{
    double pass;
    double total;
    double inc;
    public Class(int[] cl){
        pass = cl[0];
        total = cl[1];
        inc = (pass + 1) / (total + 1) - pass / total;
    }
    public void addExtraStudent(){
        pass += 1;
        total += 1;
        inc = (pass + 1) / (total + 1) - pass / total;
    }
}
class Compare implements Comparator<Class>{
    public int compare(Class c1, Class c2){
        if(c1.inc < c2.inc){
            return 1;
        }else if(c1.inc > c2.inc){
            return -1;
        }else{
            return 0;
        }
    }
}",None,"class Solution {
    public double maxAverageRatio(int[][] classes, int extraStudents) {
        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());
        for(int[] cl : classes){
            pq.add(new Class(cl[0], cl[1]));
        }
        while(extraStudents > 0){
            Class c = pq.remove();
            c.addExtraStudent();
            extraStudents--;
            pq.add(c);
        }
        double sum = 0;
        while(!pq.isEmpty()){
            Class c = pq.remove();
            sum += c.pass / c.total;
        }
        return sum / classes.length;
    }
}
class Class{
    double pass;
    double total;
    double inc;
    public Class(int pass, int total){
        this.pass = pass;
        this.total = total;
        this.inc = (pass + 1) / (total + 1) - pass / total;
    }
    public void addExtraStudent(){
        pass += 1;
        total += 1;
        inc = (pass + 1) / (total + 1) - pass / total;
    }
}
class Compare implements Comparator<Class>{
    public int compare(Class c1, Class c2){
        if(c1.inc > c2.inc){
            return -1;
        }else if(c1.inc < c2.inc){
            return 1;
        }else{
            return 0;
        }
    }
}
"
2424,java,maximum-average-pass-ratio,"class Solution {
    public double maxAverageRatio(int[][] classes, int extraStudents) {
        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());
        for(int[] cl : classes){
            pq.add(new Class(cl));
        }
        while(extraStudents > 0){
            Class c = pq.remove();
            c.addExtraStudent();
            extraStudents--;
        }
        double sum = 0;
        while(!pq.isEmpty()){
            Class c = pq.remove();
            sum += c.pass / c.total;
        }
        return sum / classes.length;
    }
}
class Class{
    double pass;
    double total;
    double inc;
    public Class(int[] cl){
        pass = cl[0];
        total = cl[1];
        inc = (pass + 1) / (total + 1) - pass / total;
    }
    public void addExtraStudent(){
        pass += 1;
        total += 1;
        inc = (pass + 1) / (total + 1) - pass / total;
    }
}
class Compare implements Comparator<Class>{
    public int compare(Class c1, Class c2){
        if(c1.inc < c2.inc){
            return 1;
        }else if(c1.inc > c2.inc){
            return -1;
        }else{
            return 0;
        }
    }
}",None,"class Solution {
    public double maxAverageRatio(int[][] classes, int extraStudents) {
        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());
        for(int[] cl : classes){
            pq.add(new Class(cl));
        }
        while(extraStudents > 0){
            Class c = pq.remove();
            c.addExtraStudent();
            extraStudents--;
            pq.add(c);
        }
        double sum = 0;
        while(!pq.isEmpty()){
            Class c = pq.remove();
            sum += c.pass / c.total;
        }
        return sum / classes.length;
    }
}
class Class{
    double pass;
    double total;
    public Class(int[] cl){
        pass = cl[0];
        total = cl[1];
    }
    public void addExtraStudent(){
        pass += 1;
        total += 1;
    }
}
class Compare implements Comparator<Class>{
    public int compare(Class c1, Class c2){
        double diff1 = c1.pass / c1.total - (c1.pass + 1) / (c1.total + 1);
        double diff2 = c2.pass / c2.total - (c2.pass + 1) / (c2.total + 1);
        if(diff1 < diff2){
            return 1;
        }else if(diff1 > diff2){
            return -1;
        }else{
            return 0;
        }
    }
}
"
2757,java,set-matrix-zeroes,"class Solution {
    public void setZeroes(int[][] A) 
    {
       
       int row=A.length;
        int col=A[0].length;
        int x=1,y=1;
        for(int i=0;i<col;i++){
            if(A[0][i]==0){
                x=0;
               break;}
        } 
        for(int i=0;i<row;i++){
            if(A[i][0]==0){
                y=1;
               break;}
        } 
        for(int i=1;i<row;i++)
            for(int j=1;j<col;j++)
            {
                if(A[i][j]==0)
                {
                    A[i][0]=0;
                    A[0][j]=0;
                }
            }
        
       for(int j=1;j<col;j++)
        {
           if(A[0][j]==0)
           {
               for(int i=1;i<row;i++)
                   A[i][j]=0;
           }
        }
        
        for(int i=1;i<row;i++)
        {
            if(A[i][0]==0)
            {
                for(int j=0;j<col;j++)
                    A[i][j]=0;
            }
        }
        if(x==0)
        for(int i=0;i<col;i++)
            A[0][i]=0;
               
        if(y==0)
        for(int i=0;i<row;i++)
            A[i][0]=0;

        System.gc();
    }
}",None,"class Solution {
    public void setZeroes(int[][] A) 
    {
       
       int row=A.length;
        int col=A[0].length;
        int x=1,y=1;
        for(int i=0;i<col;i++){
            if(A[0][i]==0){
                x=0;
                break;}
        } 
        for(int i=0;i<row;i++){
            if(A[i][0]==0){
                y=0;
                break;}
        } 
        for(int i=1;i<row;i++)
            for(int j=1;j<col;j++)
            {
                if(A[i][j]==0)
                {
                    A[i][0]=0;
                    A[0][j]=0;
                }
            }
        
       for(int j=1;j<col;j++)
        {
           if(A[0][j]==0)
           {
               for(int i=1;i<row;i++)
                   A[i][j]=0;
           }
        }
        
        for(int i=1;i<row;i++)
        {
            if(A[i][0]==0)
            {
                for(int j=0;j<col;j++)
                    A[i][j]=0;
            }
        }
        if(x==0)
        for(int j=0;j<col;j++)
            A[0][j]=0;
              
        if(y==0)
        for(int i=0;i<row;i++)
            A[i][0]=0;

        // System.gc(); // unnecessary and can slow down the program
    }
}
"
2757,java,set-matrix-zeroes,"class Solution {
    public void setZeroes(int[][] A) 
    {
       
       int row=A.length;
        int col=A[0].length;
        int x=1,y=1;
        for(int i=0;i<col;i++){
            if(A[0][i]==0){
                x=0;
               break;}
        } 
        for(int i=0;i<row;i++){
            if(A[i][0]==0){
                y=1;
               break;}
        } 
        for(int i=1;i<row;i++)
            for(int j=1;j<col;j++)
            {
                if(A[i][j]==0)
                {
                    A[i][0]=0;
                    A[0][j]=0;
                }
            }
        
       for(int j=1;j<col;j++)
        {
           if(A[0][j]==0)
           {
               for(int i=1;i<row;i++)
                   A[i][j]=0;
           }
        }
        
        for(int i=1;i<row;i++)
        {
            if(A[i][0]==0)
            {
                for(int j=0;j<col;j++)
                    A[i][j]=0;
            }
        }
        if(x==0)
        for(int i=0;i<col;i++)
            A[0][i]=0;
               
        if(y==0)
        for(int i=0;i<row;i++)
            A[i][0]=0;

        System.gc();
    }
}",None,"class Solution {
    public void setZeroes(int[][] A) 
    {
       
       int row=A.length;
        int col=A[0].length;
        int x=1,y=1;
        for(int i=0;i<col;i++){
            if(A[0][i]==0){
                x=0;
                break;}
        } 
        for(int i=0;i<row;i++){
            if(A[i][0]==0){
                y=0;
                break;}
        } 
        for(int i=1;i<row;i++)
            for(int j=1;j<col;j++)
            {
                if(A[i][j]==0)
                {
                    A[i][0]=0;
                    A[0][j]=0;
                }
            }
        
       for(int j=1;j<col;j++)
        {
           if(A[0][j]==0)
           {
               for(int i=1;i<row;i++)
                   A[i][j]=0;
           }
        }
        
        for(int i=1;i<row;i++)
        {
            if(A[i][0]==0)
            {
                for(int j=0;j<col;j++)
                    A[i][j]=0;
            }
        }
        if(x==0)
        for(int i=0;i<col;i++)
            A[0][i]=0;
              
        if(y==0)
        for(int i=0;i<row;i++)
            A[i][0]=0;
    }
}
"
2757,java,set-matrix-zeroes,"class Solution {
    public void setZeroes(int[][] A) 
    {
       
       int row=A.length;
        int col=A[0].length;
        int x=1,y=1;
        for(int i=0;i<col;i++){
            if(A[0][i]==0){
                x=0;
               break;}
        } 
        for(int i=0;i<row;i++){
            if(A[i][0]==0){
                y=1;
               break;}
        } 
        for(int i=1;i<row;i++)
            for(int j=1;j<col;j++)
            {
                if(A[i][j]==0)
                {
                    A[i][0]=0;
                    A[0][j]=0;
                }
            }
        
       for(int j=1;j<col;j++)
        {
           if(A[0][j]==0)
           {
               for(int i=1;i<row;i++)
                   A[i][j]=0;
           }
        }
        
        for(int i=1;i<row;i++)
        {
            if(A[i][0]==0)
            {
                for(int j=0;j<col;j++)
                    A[i][j]=0;
            }
        }
        if(x==0)
        for(int i=0;i<col;i++)
            A[0][i]=0;
               
        if(y==0)
        for(int i=0;i<row;i++)
            A[i][0]=0;

        System.gc();
    }
}",None,"class Solution {
    public void setZeroes(int[][] A) 
    {
       
       int row=A.length;
        int col=A[0].length;
        int x=1,y=1;
        for(int i=0;i<col;i++){
            if(A[0][i]==0){
                x=0;
                break;
            }
        } 
        for(int i=0;i<row;i++){
            if(A[i][0]==0){
                y=0;
                break;
            }
        } 
        for(int i=1;i<row;i++)
            for(int j=1;j<col;j++)
            {
                if(A[i][j]==0)
                {
                    A[i][0]=0;
                    A[0][j]=0;
                }
            }
        
       for(int j=1;j<col;j++)
        {
           if(A[0][j]==0)
           {
               for(int i=1;i<row;i++)
                   A[i][j]=0;
           }
        }
        
        for(int i=1;i<row;i++)
        {
            if(A[i][0]==0)
            {
                for(int j=0;j<col;j++)
                    A[i][j]=0;
            }
        }
        if(x==0)
        for(int j=0;j<col;j++)
            A[0][j]=0;
              
        if(y==0)
        for(int i=0;i<row;i++)
            A[i][0]=0;

        //System.gc();
    }
}
"
2758,java,maximum-number-of-points-from-grid-queries,"class Solution {
    public int[] maxPoints(int[][] a, int[] q) {
        
        int n = a.length;
        int m = a[0].length;
        
        int l = q.length;
        int[][] p = new int[l][2];
        
        for(int i = 0 ; i < l ; i++) {
            
            p[i][0] = i;
            p[i][1] = q[i];
        }
        
        Arrays.sort(p, (o1,o2)-> {
            
            if(o1[1] == o2[1]) {
                
                return Integer.compare(o1[0],o2[0]);
            }
            
            return Integer.compare(o1[1],o2[1]);
        });
        
        PriorityQueue<int[]> qu = new PriorityQueue<>((o1,o2)->{
            
            return Integer.compare(a[o1[0]][o1[1]],a[o2[0]][o2[1]]);
        });
        
        qu.add(new int[]{0,1}); 
        
        boolean[][] v = new boolean[n][m];
        int cnt = 0;
        int idx = 0;
        
        while(qu.size() > 0 && idx < l) {
            
            int[] f = qu.remove();
            int r = f[0] , c = f[1];
            
            if(v[r][c]) continue;
            
            v[r][c] = true;
            
            if(a[r][c] < p[idx][1]) {
                
                cnt++;
            }
            else{
                
                q[p[idx][0]] = cnt;
                idx++;
                qu.add(f);
                v[r][c] = false;
                continue;
            }
            
            if(c+1 < m && v[r][c+1] == false) qu.add(new int[]{r,c+1});
            if(r+1 < n && v[r+1][c] == false) qu.add(new int[]{r+1,c});
            if(r-1 >=0 && v[r-1][c] == false) qu.add(new int[]{r-1,c});
            if(c-1 >= 0 && v[r][c-1] == false) qu.add(new int[]{r,c-1});
        }
        
        while(idx < l) {
            
            q[p[idx][0]] = cnt;
            idx++;
        }
        
        return q;
    }
}",None,"class Solution {
    public int[] maxPoints(int[][] a, int[] q) {
        
        int n = a.length;
        int m = a[0].length;
        
        int l = q.length;
        int[][] p = new int[l][2];
        
        for(int i = 0 ; i < l ; i++) {
            
            p[i][0] = i;
            p[i][1] = q[i];
        }
        
        Arrays.sort(p, (o1,o2)-> {
            
            if(o1[1] == o2[1]) {
                
                return Integer.compare(o1[0],o2[0]);
            }
            
            return Integer.compare(o1[1],o2[1]);
        });
        
        PriorityQueue<int[]> qu = new PriorityQueue<>((o1,o2)->{
            
            return Integer.compare(a[o1[0]][o1[1]],a[o2[0]][o2[1]]);
        });
        
        qu.add(new int[]{0,1}); 
        
        boolean[][] v = new boolean[n][m];
        int cnt = 0;
        int idx = 0;
        
        while(qu.size() > 0 && idx < l) {
            
            int[] f = qu.remove();
            int r = f[0] , c = f[1];
            
            if(v[r][c]) continue;
            
            v[r][c] = true;
            
            if(a[r][c] < p[idx][1]) {
                
                cnt++;
            }
            else{
                
                q[p[idx][0]] = cnt;
                idx++;
                qu.add(f);
                v[r][c] = false;
                continue;
            }
            
            if(c+1 < m) qu.add(new int[]{r,c+1});
            if(r+1 < n) qu.add(new int[]{r+1,c});
            if(r-1 >=0) qu.add(new int[]{r-1,c});
            if(c-1 >= 0) qu.add(new int[]{r,c-1});
        }
        
        while(idx < l) {
            
            q[p[idx][0]] = cnt;
            idx++;
        }
        
        return q;
    }
}
"
2758,java,maximum-number-of-points-from-grid-queries,"class Solution {
    public int[] maxPoints(int[][] a, int[] q) {
        
        int n = a.length;
        int m = a[0].length;
        
        int l = q.length;
        int[][] p = new int[l][2];
        
        for(int i = 0 ; i < l ; i++) {
            
            p[i][0] = i;
            p[i][1] = q[i];
        }
        
        Arrays.sort(p, (o1,o2)-> {
            
            if(o1[1] == o2[1]) {
                
                return Integer.compare(o1[0],o2[0]);
            }
            
            return Integer.compare(o1[1],o2[1]);
        });
        
        PriorityQueue<int[]> qu = new PriorityQueue<>((o1,o2)->{
            
            return Integer.compare(a[o1[0]][o1[1]],a[o2[0]][o2[1]]);
        });
        
        qu.add(new int[]{0,1}); 
        
        boolean[][] v = new boolean[n][m];
        int cnt = 0;
        int idx = 0;
        
        while(qu.size() > 0 && idx < l) {
            
            int[] f = qu.remove();
            int r = f[0] , c = f[1];
            
            if(v[r][c]) continue;
            
            v[r][c] = true;
            
            if(a[r][c] < p[idx][1]) {
                
                cnt++;
            }
            else{
                
                q[p[idx][0]] = cnt;
                idx++;
                qu.add(f);
                v[r][c] = false;
                continue;
            }
            
            if(c+1 < m && v[r][c+1] == false) qu.add(new int[]{r,c+1});
            if(r+1 < n && v[r+1][c] == false) qu.add(new int[]{r+1,c});
            if(r-1 >=0 && v[r-1][c] == false) qu.add(new int[]{r-1,c});
            if(c-1 >= 0 && v[r][c-1] == false) qu.add(new int[]{r,c-1});
        }
        
        while(idx < l) {
            
            q[p[idx][0]] = cnt;
            idx++;
        }
        
        return q;
    }
}",None,"class Solution {
    public int[] maxPoints(int[][] a, int[] q) {
        
        int n = a.length;
        int m = a[0].length;
        
        int l = q.length;
        int[] p = new int[l];
        
        for(int i = 0 ; i < l ; i++) {
            
            p[i] = i;
        }
        
        Arrays.sort(p, (o1,o2)-> {
            
            if(a[o1][o1] == a[o2][o2]) {
                
                return Integer.compare(o1,o2);
            }
            
            return Integer.compare(a[o1][o1],a[o2][o2]);
        });
        
        PriorityQueue<int[]> qu = new PriorityQueue<>((o1,o2)->{
            
            return Integer.compare(a[o1[0]][o1[1]],a[o2[0]][o2[1]]);
        });
        
        qu.add(new int[]{0,1}); 
        
        boolean[][] v = new boolean[n][m];
        int cnt = 0;
        int idx = 0;
        
        while(qu.size() > 0 && idx < l) {
            
            int[] f = qu.remove();
            int r = f[0] , c = f[1];
            
            if(v[r][c]) continue;
            
            v[r][c] = true;
            
            if(a[r][c] < q[idx]) {
                
                cnt++;
            }
            else{
                
                q[p[idx]] = cnt;
                idx++;
                qu.add(f);
                v[r][c] = false;
                continue;
            }
            
            if(c+1 < m && v[r][c+1] == false) qu.add(new int[]{r,c+1});
            if(r+1 < n && v[r+1][c] == false) qu.add(new int[]{r+1,c});
            if(r-1 >=0 && v[r-1][c] == false) qu.add(new int[]{r-1,c});
            if(c-1 >= 0 && v[r][c-1] == false) qu.add(new int[]{r,c-1});
        }
        
        while(idx < l) {
            
            q[p[idx]] = cnt;
            idx++;
        }
        
        return q;
    }
}
"
2758,java,maximum-number-of-points-from-grid-queries,"class Solution {
    public int[] maxPoints(int[][] a, int[] q) {
        
        int n = a.length;
        int m = a[0].length;
        
        int l = q.length;
        int[][] p = new int[l][2];
        
        for(int i = 0 ; i < l ; i++) {
            
            p[i][0] = i;
            p[i][1] = q[i];
        }
        
        Arrays.sort(p, (o1,o2)-> {
            
            if(o1[1] == o2[1]) {
                
                return Integer.compare(o1[0],o2[0]);
            }
            
            return Integer.compare(o1[1],o2[1]);
        });
        
        PriorityQueue<int[]> qu = new PriorityQueue<>((o1,o2)->{
            
            return Integer.compare(a[o1[0]][o1[1]],a[o2[0]][o2[1]]);
        });
        
        qu.add(new int[]{0,1}); 
        
        boolean[][] v = new boolean[n][m];
        int cnt = 0;
        int idx = 0;
        
        while(qu.size() > 0 && idx < l) {
            
            int[] f = qu.remove();
            int r = f[0] , c = f[1];
            
            if(v[r][c]) continue;
            
            v[r][c] = true;
            
            if(a[r][c] < p[idx][1]) {
                
                cnt++;
            }
            else{
                
                q[p[idx][0]] = cnt;
                idx++;
                qu.add(f);
                v[r][c] = false;
                continue;
            }
            
            if(c+1 < m && v[r][c+1] == false) qu.add(new int[]{r,c+1});
            if(r+1 < n && v[r+1][c] == false) qu.add(new int[]{r+1,c});
            if(r-1 >=0 && v[r-1][c] == false) qu.add(new int[]{r-1,c});
            if(c-1 >= 0 && v[r][c-1] == false) qu.add(new int[]{r,c-1});
        }
        
        while(idx < l) {
            
            q[p[idx][0]] = cnt;
            idx++;
        }
        
        return q;
    }
}",None,"class Solution {
    public int[] maxPoints(int[][] a, int[] q) {
        
        int n = a.length;
        int m = a[0].length;
        
        int l = q.length;
        int[][] p = new int[l][2];
        
        for(int i = 0 ; i < l ; i++) {
            
            p[i][0] = i;
            p[i][1] = q[i];
        }
        
        Arrays.sort(p, (o1,o2)-> {
            
            if(o1[1] == o2[1]) {
                
                return Integer.compare(o1[0],o2[0]);
            }
            
            return Integer.compare(o1[1],o2[1]);
        });
        
        PriorityQueue<int[]> qu = new PriorityQueue<>((o1,o2)->{
            
            return Integer.compare(a[o1[0]][o1[1]],a[o2[0]][o2[1]]);
        });
        
        qu.add(new int[]{0,1}); 
        
        boolean[][] v = new boolean[n][m];
        int cnt = 0;
        int idx = 0;
        
        while(qu.size() > 0 && idx < l) {
            
            int[] f = qu.remove();
            int r = f[0] , c = f[1];
            
            if(v[r][c]) continue;
            
            v[r][c] = true;
            
            if(a[r][c] < p[idx][1]) {
                
                cnt++;
            }
            else{
                
                q[p[idx][0]] = cnt;
                idx++;
                qu.add(f);
                v[r][c] = false;
                continue;
            }
            
            if(c+1 < m) qu.add(new int[]{r,c+1});
            if(r+1 < n) qu.add(new int[]{r+1,c});
            if(r-1 >=0) qu.add(new int[]{r-1,c});
            if(c-1 >= 0) qu.add(new int[]{r,c-1});
        }
        
        while(idx < l) {
            
            q[p[idx][0]] = cnt;
            idx++;
        }
        
        return q;
    }
}
"
2759,java,minimum-time-to-visit-a-cell-in-a-grid,"class Solution {
    private static final int[][] DIRS = new int[][] { { 1, 0 }, { -1, 0}, { 0, 1 }, { 0, -1 } };
    public int minimumTime(int[][] grid) {
        if (grid[0][1] > 1 && grid[1][0] > 1) {
            return -1;
        }
        
        int m = grid.length;
        int n = grid[0].length;
        
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        heap.offer(new int[] { 0, 0, 0 });
        
        boolean[][] visited = new boolean[m][n];
        
        while (!heap.isEmpty()) {
            int[] entry = heap.poll();
            int row = entry[0];
            int col = entry[1];
            int time = entry[2];
            if (row == m - 1 && col == n - 1) {
                return time;
            }
            if (visited[row][col]) {
                continue;
            }
            visited[row][col] = false;
                
            for (int[] dir : DIRS) {
                int r = row + dir[0];
                int c = col + dir[1];
                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) {
                    continue;
                }
                
                if (grid[r][c] <= time + 1) {
                    heap.offer(new int[] { r, c, time + 1 });
                } else {
                    int diff = grid[r][c] - time;
                    if (diff % 2 == 1) {
                        heap.offer(new int[] { r, c, grid[r][c] });
                    } else {
                        heap.offer(new int[] { r, c, grid[r][c] + 1 });
                    }
                }
            }
        }
        return -1;
    }
}",None,"class Solution {
    private static final int[][] DIRS = new int[][] { { 1, 0 }, { -1, 0}, { 0, 1 }, { 0, -1 } };
    public int minimumTime(int[][] grid) {
        if (grid[0][1] > 1 && grid[1][0] > 1) {
            return -1;
        }
        
        int m = grid.length;
        int n = grid[0].length;
        
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        heap.offer(new int[] { 0, 0, 0 });
        
        boolean[][] visited = new boolean[m][n];
        
        while (!heap.isEmpty()) {
            int[] entry = heap.poll();
            int row = entry[0];
            int col = entry[1];
            int time = entry[2];
            if (row == m - 1 && col == n - 1) {
                return time;
            }
            if (visited[row][col]) {
                continue;
            }
            visited[row][col] = true;
                
            for (int[] dir : DIRS) {
                int r = row + dir[0];
                int c = col + dir[1];
                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) {
                    continue;
                }
                
                if (grid[r][c] <= time + 1) {
                    heap.offer(new int[] { r, c, time + 1 });
                } else {
                    int diff = grid[r][c] - time;
                    if (diff % 2 == 1) {
                        heap.offer(new int[] { r, c, grid[r][c] });
                    } else {
                        heap.offer(new int[] { r, c, grid[r][c] + 1 });
                    }
                }
            }
        }
        return -1;
    }
}
"
2759,java,minimum-time-to-visit-a-cell-in-a-grid,"class Solution {
    private static final int[][] DIRS = new int[][] { { 1, 0 }, { -1, 0}, { 0, 1 }, { 0, -1 } };
    public int minimumTime(int[][] grid) {
        if (grid[0][1] > 1 && grid[1][0] > 1) {
            return -1;
        }
        
        int m = grid.length;
        int n = grid[0].length;
        
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        heap.offer(new int[] { 0, 0, 0 });
        
        boolean[][] visited = new boolean[m][n];
        
        while (!heap.isEmpty()) {
            int[] entry = heap.poll();
            int row = entry[0];
            int col = entry[1];
            int time = entry[2];
            if (row == m - 1 && col == n - 1) {
                return time;
            }
            if (visited[row][col]) {
                continue;
            }
            visited[row][col] = false;
                
            for (int[] dir : DIRS) {
                int r = row + dir[0];
                int c = col + dir[1];
                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) {
                    continue;
                }
                
                if (grid[r][c] <= time + 1) {
                    heap.offer(new int[] { r, c, time + 1 });
                } else {
                    int diff = grid[r][c] - time;
                    if (diff % 2 == 1) {
                        heap.offer(new int[] { r, c, grid[r][c] });
                    } else {
                        heap.offer(new int[] { r, c, grid[r][c] + 1 });
                    }
                }
            }
        }
        return -1;
    }
}",None,"class Solution {
    private static final int[][] DIRS = new int[][] {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

    public int minimumTime(int[][] grid) {
        if (grid[0][1] > 1 || grid[1][0] > 1) {
            return -1;
        }
        
        int m = grid.length;
        int n = grid[0].length;

        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        heap.offer(new int[]{0, 0, 0});

        boolean[][] visited = new boolean[m][n];

        while (!heap.isEmpty()) {
            int[] entry = heap.poll();
            int row = entry[0];
            int col = entry[1];
            int time = entry[2];

            if (row == m - 1 && col == n - 1) {
                return time;
            }

            if (visited[row][col]) {
                continue;
            }

            visited[row][col] = true;

            for (int[] dir : DIRS) {
                int r = row + dir[0];
                int c = col + dir[1];

                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) {
                    continue;
                }

                if (grid[r][c] <= time + 1) {
                    heap.offer(new int[]{r, c, time + 1});
                } else {
                    int diff = grid[r][c] - time;
                    if (diff % 2 == 1) {
                        heap.offer(new int[]{r, c, grid[r][c]});
                    } else {
                        heap.offer(new int[]{r, c, grid[r][c] + 1});
                    }
                }
            }
        }

        return -1;
    }
}
"
2759,java,minimum-time-to-visit-a-cell-in-a-grid,"class Solution {
    private static final int[][] DIRS = new int[][] { { 1, 0 }, { -1, 0}, { 0, 1 }, { 0, -1 } };
    public int minimumTime(int[][] grid) {
        if (grid[0][1] > 1 && grid[1][0] > 1) {
            return -1;
        }
        
        int m = grid.length;
        int n = grid[0].length;
        
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        heap.offer(new int[] { 0, 0, 0 });
        
        boolean[][] visited = new boolean[m][n];
        
        while (!heap.isEmpty()) {
            int[] entry = heap.poll();
            int row = entry[0];
            int col = entry[1];
            int time = entry[2];
            if (row == m - 1 && col == n - 1) {
                return time;
            }
            if (visited[row][col]) {
                continue;
            }
            visited[row][col] = false;
                
            for (int[] dir : DIRS) {
                int r = row + dir[0];
                int c = col + dir[1];
                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) {
                    continue;
                }
                
                if (grid[r][c] <= time + 1) {
                    heap.offer(new int[] { r, c, time + 1 });
                } else {
                    int diff = grid[r][c] - time;
                    if (diff % 2 == 1) {
                        heap.offer(new int[] { r, c, grid[r][c] });
                    } else {
                        heap.offer(new int[] { r, c, grid[r][c] + 1 });
                    }
                }
            }
        }
        return -1;
    }
}",None,"class Solution {
    private static final int[][] DIRS = new int[][] { { 1, 0 }, { -1, 0}, { 0, 1 }, { 0, -1 } };
    public int minimumTime(int[][] grid) {
        if (grid[0][1] > 1 || grid[1][0] > 1) {
            return -1;
        }
        
        int m = grid.length;
        int n = grid[0].length;
        
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        heap.offer(new int[] { 0, 0, 0 });
        
        boolean[][] visited = new boolean[m][n];
        
        while (!heap.isEmpty()) {
            int[] entry = heap.poll();
            int row = entry[0];
            int col = entry[1];
            int time = entry[2];
            if (row == m - 1 && col == n - 1) {
                return time;
            }
            if (visited[row][col]) {
                continue;
            }
            visited[row][col] = true;
                
            for (int[] dir : DIRS) {
                int r = row + dir[0];
                int c = col + dir[1];
                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) {
                    continue;
                }
                
                if (grid[r][c] <= time + 1) {
                    heap.offer(new int[] { r, c, time + 1 });
                } else {
                    int diff = grid[r][c] - time;
                    if (diff % 2 == 1) {
                        continue;
                    }
                    heap.offer(new int[] { r, c, grid[r][c] });
                }
            }
        }
        return -1;
    }
}
"
2760,java,minimum-score-triangulation-of-polygon,"class Solution {
    int[][] dp;
    public int minScoreTriangulation(int[] values) {
        int l=values.length;
        dp = new int[l][l];
        for(int[] i : dp) Arrays.fill(i,-1);
        return solve(values,0,l-1); 
    }

    public int solve(int[] values, int i,int j)
    {
        if(i>=j) return 0;
        if(dp[i][j]!=-1) return dp[i][j];
        int min=Integer.MAX_VALUE;
        for(int k=i;k<j;k++)
        {
            int temp=solve(values,i,k)+solve(values,k+1,j)+
                        values[i-1]*values[k]*values[j];
            min=Math.min(min,temp);
        }

        return dp[i][j]=min;
    }
}",None,"class Solution {
    int[][] dp;
    public int minScoreTriangulation(int[] values) {
        int l=values.length;
        dp = new int[l][l];
        for(int[] i : dp) Arrays.fill(i,-1);
        return solve(values,0,l-1); 
    }

    public int solve(int[] values, int i,int j)
    {
        if(i>=j) return 0;
        if(dp[i][j]!=-1) return dp[i][j];
        int min=Integer.MAX_VALUE;
        for(int k=i;k<j;k++)
        {
            int temp=solve(values,i,k)+solve(values,k+1,j)+
                        values[i-1]*values[k]*values[j];
            min=Math.min(min,temp);
        }

        return dp[i][j]=min;
    }
}
"
2760,java,minimum-score-triangulation-of-polygon,"class Solution {
    int[][] dp;
    public int minScoreTriangulation(int[] values) {
        int l=values.length;
        dp = new int[l][l];
        for(int[] i : dp) Arrays.fill(i,-1);
        return solve(values,0,l-1); 
    }

    public int solve(int[] values, int i,int j)
    {
        if(i>=j) return 0;
        if(dp[i][j]!=-1) return dp[i][j];
        int min=Integer.MAX_VALUE;
        for(int k=i;k<j;k++)
        {
            int temp=solve(values,i,k)+solve(values,k+1,j)+
                        values[i-1]*values[k]*values[j];
            min=Math.min(min,temp);
        }

        return dp[i][j]=min;
    }
}",None,"class Solution {
    int[][] dp;
    public int minScoreTriangulation(int[] values) {
        int l=values.length;
        dp = new int[l][l];
        for(int[] i : dp) Arrays.fill(i,-1);
        return solve(values,0,l-1); 
    }

    public int solve(int[] values, int i,int j)
    {
        if(i>=j) return 0;
        if(dp[i][j]!=-1) return dp[i][j];
        int min=Integer.MAX_VALUE;
        for(int k=i;k<j;k++)
        {
            int temp=solve(values,i,k)+solve(values,k+1,j)+
                        values[i-1]*values[k]*values[j];
            min=Math.min(min,temp);
        }

        return dp[i][j]=min;
    }
}
"
2760,java,minimum-score-triangulation-of-polygon,"class Solution {
    int[][] dp;
    public int minScoreTriangulation(int[] values) {
        int l=values.length;
        dp = new int[l][l];
        for(int[] i : dp) Arrays.fill(i,-1);
        return solve(values,0,l-1); 
    }

    public int solve(int[] values, int i,int j)
    {
        if(i>=j) return 0;
        if(dp[i][j]!=-1) return dp[i][j];
        int min=Integer.MAX_VALUE;
        for(int k=i;k<j;k++)
        {
            int temp=solve(values,i,k)+solve(values,k+1,j)+
                        values[i-1]*values[k]*values[j];
            min=Math.min(min,temp);
        }

        return dp[i][j]=min;
    }
}",None,"class Solution {
    int[][] dp;
    public int minScoreTriangulation(int[] values) {
        int l=values.length;
        dp = new int[l][l];
        for(int[] i : dp) Arrays.fill(i,-1);
        return solve(values,0,l-1); 
    }

    public int solve(int[] values, int i,int j)
    {
        if(i>=j) return 0;
        if(dp[i][j]!=-1) return dp[i][j];
        int min=Integer.MAX_VALUE;
        for(int k=i;k<j;k++)
        {
            int temp=solve(values,i,k)+solve(values,k+1,j)+
                        values[i-1]*values[k]*values[j];
            min=Math.min(min,temp);
        }

        return dp[i][j]=min;
    }
}
"
2761,java,max-consecutive-ones,"class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int count=0;
        int max=0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==1){
                count++;
            }else{
                max=0;
            }
            max=Math.max(count,max);
        }
        return max;
    }
}",None,"class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int count=0;
        int max=0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==1){
                count++;
            }else{
                max = Math.max(count, max);
                count = 0;
            }
        }
        return Math.max(count, max);
    }
}
"
2761,java,max-consecutive-ones,"class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int count=0;
        int max=0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==1){
                count++;
            }else{
                max=0;
            }
            max=Math.max(count,max);
        }
        return max;
    }
}",None,"class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int count=0;
        int max=0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==1){
                count++;
            }else{
                max = Math.max(count, max);
                count = 0;
            }
        }
        return Math.max(count, max);
    }
}
"
2761,java,max-consecutive-ones,"class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int count=0;
        int max=0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==1){
                count++;
            }else{
                max=0;
            }
            max=Math.max(count,max);
        }
        return max;
    }
}",None,"class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int count=0;
        int max=0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==1){
                count++;
            }else{
                max=Math.max(count,max);
                count=0;
            }
        }
        return Math.max(count, max);
    }
}
"
2762,java,corporate-flight-bookings,"class Solution:
    def increment(self, arr, start, end, val):
        arr[start] += val
        if end + 1 < len(arr):
            arr[end+1] -= val
        

    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
        arr = [0 for _ in range(n)]
        for book in bookings:
            start, end ,seat = book
            self.increment(arr, start, end, seat)
            # print(arr)
        res = [0 for _ in range(n)]
        res[0] = arr[0]
        for i in range(1, n):
            res[i] = res[i-1] + arr[i]
        # print(res)
        return res",None,"class Solution:
    def increment(self, arr, start, end, val):
        arr[start] += val
        if end + 1 < len(arr):
            arr[end+1] -= val

    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
        arr = [0 for _ in range(n+1)]
        for book in bookings:
            start, end ,seat = book
            self.increment(arr, start, end, seat)
        res = [0 for _ in range(n)]
        res[0] = arr[0]
        for i in range(1, n):
            res[i] = res[i-1] + arr[i]
        return res
"
2762,java,corporate-flight-bookings,"class Solution:
    def increment(self, arr, start, end, val):
        arr[start] += val
        if end + 1 < len(arr):
            arr[end+1] -= val
        

    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
        arr = [0 for _ in range(n)]
        for book in bookings:
            start, end ,seat = book
            self.increment(arr, start, end, seat)
            # print(arr)
        res = [0 for _ in range(n)]
        res[0] = arr[0]
        for i in range(1, n):
            res[i] = res[i-1] + arr[i]
        # print(res)
        return res",None,"class Solution:
    def increment(self, arr, start, end, val):
        arr[start - 1] += val
        if end + 1 < len(arr):
            arr[end] -= val

    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
        arr = [0] * n
        for book in bookings:
            start, end, seat = book
            self.increment(arr, start, end, seat)
        res = [0] * n
        res[0] = arr[0]
        for i in range(1, n):
            res[i] = res[i - 1] + arr[i]
        return res
"
2762,java,corporate-flight-bookings,"class Solution:
    def increment(self, arr, start, end, val):
        arr[start] += val
        if end + 1 < len(arr):
            arr[end+1] -= val
        

    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
        arr = [0 for _ in range(n)]
        for book in bookings:
            start, end ,seat = book
            self.increment(arr, start, end, seat)
            # print(arr)
        res = [0 for _ in range(n)]
        res[0] = arr[0]
        for i in range(1, n):
            res[i] = res[i-1] + arr[i]
        # print(res)
        return res",None,"class Solution {
    public int[] corpFlightBookings(int[][] bookings, int n) {
        int[] arr = new int[n];
        for (int[] book : bookings) {
            int start = book[0] - 1, end = book[1] - 1, val = book[2];
            arr[start] += val;
            if (end + 1 < n) {
                arr[end+1] -= val;
            }
        }

        for (int i = 1; i < n; i++) {
            arr[i] += arr[i-1];
        }

        return arr;
    }
}
"
2763,java,can-make-arithmetic-progression-from-sequence,"class Solution {
    public boolean canMakeArithmeticProgression(int[] arr) {
        Arrays.sort(arr);
        int diff=arr[1]-arr[0];
        boolean temp=true;
        for(int i=1;i<arr.length-1;i++){
            if(arr[i+1]-arr[i]==diff){
                temp=false;
                continue;
            }else{
                temp=true;
            }
        }
        if(temp==true){
            return true;
        }else{
            return false;
        }
    }
}",None,"class Solution {
    public boolean canMakeArithmeticProgression(int[] arr) {
        Arrays.sort(arr);
        int diff=arr[1]-arr[0];
        for(int i=1;i<arr.length-1;i++){
            if(arr[i+1]-arr[i]!=diff){
                return false;
            }
        }
        return true;
    }
}
"
2763,java,can-make-arithmetic-progression-from-sequence,"class Solution {
    public boolean canMakeArithmeticProgression(int[] arr) {
        Arrays.sort(arr);
        int diff=arr[1]-arr[0];
        boolean temp=true;
        for(int i=1;i<arr.length-1;i++){
            if(arr[i+1]-arr[i]==diff){
                temp=false;
                continue;
            }else{
                temp=true;
            }
        }
        if(temp==true){
            return true;
        }else{
            return false;
        }
    }
}",None,"class Solution {
    public boolean canMakeArithmeticProgression(int[] arr) {
        Arrays.sort(arr);
        int diff=arr[1]-arr[0];
        for(int i=1;i<arr.length-1;i++){
            if(arr[i+1]-arr[i]!=diff){
                return false;
            }
        }
        return true;
    }
}
"
2763,java,can-make-arithmetic-progression-from-sequence,"class Solution {
    public boolean canMakeArithmeticProgression(int[] arr) {
        Arrays.sort(arr);
        int diff=arr[1]-arr[0];
        boolean temp=true;
        for(int i=1;i<arr.length-1;i++){
            if(arr[i+1]-arr[i]==diff){
                temp=false;
                continue;
            }else{
                temp=true;
            }
        }
        if(temp==true){
            return true;
        }else{
            return false;
        }
    }
}",None,"class Solution {
    public boolean canMakeArithmeticProgression(int[] arr) {
        Arrays.sort(arr);
        int diff = arr[1] - arr[0];
        for (int i = 1; i < arr.length - 1; i++) {
            if (arr[i + 1] - arr[i] != diff) {
                return false;
            }
        }
        return true;
    }
}
"
2764,java,design-authentication-manager,"class AuthenticationManager {

    int timeToLive;
    TreeSet<Integer> treeSet;
    Map<String, Integer> map;
    public AuthenticationManager(int timeToLive) {
        this.timeToLive = timeToLive;
        treeSet = new TreeSet<>();
        map = new HashMap<>();
    }
    
    public void generate(String tokenId, int currentTime) {
        map.put(tokenId, currentTime + timeToLive);
        treeSet.add(currentTime + timeToLive);
    }
    
    public void renew(String tokenId, int currentTime) {
        
        Integer time = map.get(tokenId);
        if (time == null || time <= currentTime) return;
       
	   
        map.put(tokenId, currentTime + time);
        treeSet.remove(time);
        treeSet.add(currentTime + time);
        
        while (!treeSet.isEmpty() && treeSet.lower(currentTime) != null) {
            treeSet.remove(treeSet.lower(currentTime));
        }
    }
    
    public int countUnexpiredTokens(int currentTime) {
        return treeSet.tailSet(currentTime, false).size();
    }
}",None,"class AuthenticationManager {

    int timeToLive;
    TreeSet<Integer> treeSet;
    Map<String, Integer> map;
    public AuthenticationManager(int timeToLive) {
        this.timeToLive = timeToLive;
        treeSet = new TreeSet<>();
        map = new HashMap<>();
    }
    
    public void generate(String tokenId, int currentTime) {
        map.put(tokenId, currentTime + timeToLive);
        treeSet.add(currentTime + timeToLive);
    }
    
    public void renew(String tokenId, int currentTime) {
        
        Integer time = map.get(tokenId);
        if (time == null || time <= currentTime) return;

        treeSet.remove(time);
        map.put(tokenId, currentTime + timeToLive);
        treeSet.add(currentTime + timeToLive);
        
        while (!treeSet.isEmpty() && treeSet.lower(currentTime) != null) {
            treeSet.remove(treeSet.lower(currentTime));
        }
    }
    
    public int countUnexpiredTokens(int currentTime) {
        return treeSet.tailSet(currentTime, false).size();
    }
}
"
2764,java,design-authentication-manager,"class AuthenticationManager {

    int timeToLive;
    TreeSet<Integer> treeSet;
    Map<String, Integer> map;
    public AuthenticationManager(int timeToLive) {
        this.timeToLive = timeToLive;
        treeSet = new TreeSet<>();
        map = new HashMap<>();
    }
    
    public void generate(String tokenId, int currentTime) {
        map.put(tokenId, currentTime + timeToLive);
        treeSet.add(currentTime + timeToLive);
    }
    
    public void renew(String tokenId, int currentTime) {
        
        Integer time = map.get(tokenId);
        if (time == null || time <= currentTime) return;
       
	   
        map.put(tokenId, currentTime + time);
        treeSet.remove(time);
        treeSet.add(currentTime + time);
        
        while (!treeSet.isEmpty() && treeSet.lower(currentTime) != null) {
            treeSet.remove(treeSet.lower(currentTime));
        }
    }
    
    public int countUnexpiredTokens(int currentTime) {
        return treeSet.tailSet(currentTime, false).size();
    }
}",None,"class AuthenticationManager {

    int timeToLive;
    TreeSet<Integer> treeSet;
    Map<String, Integer> map;
    public AuthenticationManager(int timeToLive) {
        this.timeToLive = timeToLive;
        treeSet = new TreeSet<>();
        map = new HashMap<>();
    }
    
    public void generate(String tokenId, int currentTime) {
        map.put(tokenId, currentTime + timeToLive);
        treeSet.add(currentTime + timeToLive);
    }
    
    public void renew(String tokenId, int currentTime) {
        
        Integer time = map.get(tokenId);
        if (time == null || time <= currentTime) return;

        treeSet.remove(time);
        map.put(tokenId, currentTime + timeToLive);
        treeSet.add(currentTime + timeToLive);
        
        while (!treeSet.isEmpty() && treeSet.lower(currentTime) != null) {
            treeSet.remove(treeSet.lower(currentTime));
        }
    }
    
    public int countUnexpiredTokens(int currentTime) {
        return treeSet.tailSet(currentTime, false).size();
    }
}
"
2764,java,design-authentication-manager,"class AuthenticationManager {

    int timeToLive;
    TreeSet<Integer> treeSet;
    Map<String, Integer> map;
    public AuthenticationManager(int timeToLive) {
        this.timeToLive = timeToLive;
        treeSet = new TreeSet<>();
        map = new HashMap<>();
    }
    
    public void generate(String tokenId, int currentTime) {
        map.put(tokenId, currentTime + timeToLive);
        treeSet.add(currentTime + timeToLive);
    }
    
    public void renew(String tokenId, int currentTime) {
        
        Integer time = map.get(tokenId);
        if (time == null || time <= currentTime) return;
       
	   
        map.put(tokenId, currentTime + time);
        treeSet.remove(time);
        treeSet.add(currentTime + time);
        
        while (!treeSet.isEmpty() && treeSet.lower(currentTime) != null) {
            treeSet.remove(treeSet.lower(currentTime));
        }
    }
    
    public int countUnexpiredTokens(int currentTime) {
        return treeSet.tailSet(currentTime, false).size();
    }
}",None,"class AuthenticationManager {

    int timeToLive;
    TreeSet<Integer> treeSet;
    Map<String, Integer> map;
    public AuthenticationManager(int timeToLive) {
        this.timeToLive = timeToLive;
        treeSet = new TreeSet<>();
        map = new HashMap<>();
    }
    
    public void generate(String tokenId, int currentTime) {
        map.put(tokenId, currentTime + timeToLive);
        treeSet.add(currentTime + timeToLive);
    }
    
    public void renew(String tokenId, int currentTime) {
        
        Integer time = map.get(tokenId);
        if (time == null || time <= currentTime) return;

        treeSet.remove(time);
        map.put(tokenId, currentTime + timeToLive);
        treeSet.add(currentTime + timeToLive);
        
        while (!treeSet.isEmpty() && treeSet.lower(currentTime) != null) {
            treeSet.remove(treeSet.lower(currentTime));
        }
    }
    
    public int countUnexpiredTokens(int currentTime) {
        return treeSet.tailSet(currentTime, false).size();
    }
}
"
2765,java,reduction-operations-to-make-the-array-elements-equal,"class Solution {
    public int reductionOperations(int[] nums) {
        Arrays.sort(nums);
        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();
        int x = 1; 
        for(Integer num : nums){
            if(map.containsKey(num)){
                continue;
            }
            map.put(num,x++);
        }
        
        int count = 0;
        for(int i = 1;i<nums.length;i++){
            if(nums[i]>nums[0]){
                count+=map.get(nums[i]);
            }
        }
        return count;
    }
}",None,"class Solution {
    public int reductionOperations(int[] nums) {
        Arrays.sort(nums);
        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();
        int x = 1; 
        for(Integer num : nums){
            if(map.containsKey(num)){
                continue;
            }
            map.put(num,x++);
        }
        
        int count = 0;
        for(int i = 1;i<nums.length;i++){
            if(nums[i]>nums[0] && map.get(nums[i])>map.get(nums[0])){
                count++;
            }
        }
        return count;
    }
}
"
2765,java,reduction-operations-to-make-the-array-elements-equal,"class Solution {
    public int reductionOperations(int[] nums) {
        Arrays.sort(nums);
        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();
        int x = 1; 
        for(Integer num : nums){
            if(map.containsKey(num)){
                continue;
            }
            map.put(num,x++);
        }
        
        int count = 0;
        for(int i = 1;i<nums.length;i++){
            if(nums[i]>nums[0]){
                count+=map.get(nums[i]);
            }
        }
        return count;
    }
}",None,"class Solution {
    public int reductionOperations(int[] nums) {
        Arrays.sort(nums);
        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();
        int x = 1; 
        for(Integer num : nums){
            if(map.containsKey(num)){
                continue;
            }
            map.put(num,x++);
        }
        
        int count = 0;
        for(int i = 1;i<nums.length;i++){
            if(nums[i]>nums[0] && map.get(nums[i])>map.get(nums[0])){
                count+=map.get(nums[i])-map.get(nums[0]);
            }
        }
        return count;
    }
}
"
2765,java,reduction-operations-to-make-the-array-elements-equal,"class Solution {
    public int reductionOperations(int[] nums) {
        Arrays.sort(nums);
        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();
        int x = 1; 
        for(Integer num : nums){
            if(map.containsKey(num)){
                continue;
            }
            map.put(num,x++);
        }
        
        int count = 0;
        for(int i = 1;i<nums.length;i++){
            if(nums[i]>nums[0]){
                count+=map.get(nums[i]);
            }
        }
        return count;
    }
}",None,"class Solution {
    public int reductionOperations(int[] nums) {
        Arrays.sort(nums);
        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();
        int x = 1; 
        for(Integer num : nums){
            if(map.containsKey(num)){
                continue;
            }
            map.put(num,x++);
        }
        
        int count = 0;
        for(int i = 1;i<nums.length;i++){
            if(nums[i]>=nums[0]){
                count+=map.get(nums[i]);
            }
        }
        return count;
    }
}
"
2766,java,loud-and-rich,"class Solution {
    int ans[];
    Map<Integer,List<Integer>> map=new HashMap<>();
    int temp[]=new int[0];
    int curr_node=0;
    List<Integer> vis=new ArrayList<Integer>();
    public int[] loudAndRich(int[][] richer, int[] quiet) {
        
        ans=new int[quiet.length];
        for(int i=0;i<=richer.length;i++){
            
            if(!map.containsKey(i)){
                map.put(i,new ArrayList());
            }
            if(i<richer.length && !map.containsKey(richer[i][0])){
                map.put(richer[i][0],new ArrayList());
                map.get(richer[i][0]).add(richer[i][1]);
            }
            else if(i<richer.length){
                map.get(richer[i][0]).add(richer[i][0]);
            }
        }
        
        Comparator<pair> comp=new Comparator<pair>(){
            public int compare(pair p1,pair p2){
                if(p1.cost>p2.cost){
                    return 1;
                }
                else{
                    return -1;
                }

            }
        };
        PriorityQueue<pair> pq=new PriorityQueue<>(comp);
        for(int i=0;i<quiet.length;i++){
            ans[i]=-1;
            pq.add(new pair(i,quiet[i]));
        }
        
        while(!pq.isEmpty()){
            pair top=pq.poll();
            curr_node=top.node;
            if(!vis.contains(top.node)){
            dfs(top.node);
            }
        }
        return ans;
       
    }
    public void dfs(int node){
        if(ans[node]==-1){
            ans[node]=curr_node;
        }
        if(!vis.contains(node) && map.containsKey(node)){
            vis.add(node);
             
            for(int i : map.get(node)){
            dfs(i);
        
        }
        }
            
    }
}

class pair{
    int node,cost;
    pair(int node,int cost){
        this.node=node;
        this.cost=cost;
    }
}",None,"class Solution {
    int ans[];
    Map<Integer, List<Integer>> map = new HashMap<>();
    int temp[] = new int[0];
    int curr_node = 0;
    List<Integer> vis = new ArrayList<Integer>();

    public int[] loudAndRich(int[][] richer, int[] quiet) {
        ans = new int[quiet.length];
        for (int i = 0; i < richer.length; i++) {
            map.computeIfAbsent(richer[i][1], k -> new ArrayList<>()).add(richer[i][0]);
        }

        for (int i = 0; i < quiet.length; i++) {
            ans[i] = i;
        }

        for (int i = 0; i < quiet.length; i++) {
            dfs(i, i, quiet);
        }

        return ans;
    }

    public void dfs(int node, int parent, int[] quiet) {
        for (Integer child : map.getOrDefault(node, Collections.emptyList())) {
            if (child == parent) {
                continue;
            }
            dfs(child, node, quiet);
        }

        for (Integer child : map.getOrDefault(node, Collections.emptyList())) {
            if (quiet[ans[child]] < quiet[ans[node]]) {
                ans[node] = ans[child];
            }
        }
    }
}
"
2766,java,loud-and-rich,"class Solution {
    int ans[];
    Map<Integer,List<Integer>> map=new HashMap<>();
    int temp[]=new int[0];
    int curr_node=0;
    List<Integer> vis=new ArrayList<Integer>();
    public int[] loudAndRich(int[][] richer, int[] quiet) {
        
        ans=new int[quiet.length];
        for(int i=0;i<=richer.length;i++){
            
            if(!map.containsKey(i)){
                map.put(i,new ArrayList());
            }
            if(i<richer.length && !map.containsKey(richer[i][0])){
                map.put(richer[i][0],new ArrayList());
                map.get(richer[i][0]).add(richer[i][1]);
            }
            else if(i<richer.length){
                map.get(richer[i][0]).add(richer[i][0]);
            }
        }
        
        Comparator<pair> comp=new Comparator<pair>(){
            public int compare(pair p1,pair p2){
                if(p1.cost>p2.cost){
                    return 1;
                }
                else{
                    return -1;
                }

            }
        };
        PriorityQueue<pair> pq=new PriorityQueue<>(comp);
        for(int i=0;i<quiet.length;i++){
            ans[i]=-1;
            pq.add(new pair(i,quiet[i]));
        }
        
        while(!pq.isEmpty()){
            pair top=pq.poll();
            curr_node=top.node;
            if(!vis.contains(top.node)){
            dfs(top.node);
            }
        }
        return ans;
       
    }
    public void dfs(int node){
        if(ans[node]==-1){
            ans[node]=curr_node;
        }
        if(!vis.contains(node) && map.containsKey(node)){
            vis.add(node);
             
            for(int i : map.get(node)){
            dfs(i);
        
        }
        }
            
    }
}

class pair{
    int node,cost;
    pair(int node,int cost){
        this.node=node;
        this.cost=cost;
    }
}",None,"class Solution {
    int ans[];
    Map<Integer, List<Integer>> map = new HashMap<>();
    int temp[] = new int[0];
    int curr_node = 0;
    List<Integer> vis = new ArrayList<Integer>();

    public int[] loudAndRich(int[][] richer, int[] quiet) {
        ans = new int[quiet.length];

        for (int i = 0; i < richer.length; i++) {
            map.putIfAbsent(richer[i][1], new ArrayList<>());
            map.get(richer[i][1]).add(richer[i][0]);
        }

        PriorityQueue<pair> pq = new PriorityQueue<>(new Comparator<pair>() {
            public int compare(pair p1, pair p2) {
                return quiet[p1.node] - quiet[p2.node];
            }
        });

        for (int i = 0; i < quiet.length; i++) {
            ans[i] = -1;
            pq.add(new pair(i, quiet[i]));
        }

        while (!pq.isEmpty()) {
            pair top = pq.poll();
            if (ans[top.node] == -1) {
                ans[top.node] = top.node;
                if (map.containsKey(top.node)) {
                    for (int node : map.get(top.node)) {
                        pq.removeIf(pair -> pair.node == node);
                        pq.add(new pair(node, quiet[node]));
                    }
                }
            }
        }

        return ans;
    }

    class pair {
        int node, cost;

        pair(int node, int cost) {
            this.node = node;
            this.cost = cost;
        }
    }
}
"
2766,java,loud-and-rich,"class Solution {
    int ans[];
    Map<Integer,List<Integer>> map=new HashMap<>();
    int temp[]=new int[0];
    int curr_node=0;
    List<Integer> vis=new ArrayList<Integer>();
    public int[] loudAndRich(int[][] richer, int[] quiet) {
        
        ans=new int[quiet.length];
        for(int i=0;i<=richer.length;i++){
            
            if(!map.containsKey(i)){
                map.put(i,new ArrayList());
            }
            if(i<richer.length && !map.containsKey(richer[i][0])){
                map.put(richer[i][0],new ArrayList());
                map.get(richer[i][0]).add(richer[i][1]);
            }
            else if(i<richer.length){
                map.get(richer[i][0]).add(richer[i][0]);
            }
        }
        
        Comparator<pair> comp=new Comparator<pair>(){
            public int compare(pair p1,pair p2){
                if(p1.cost>p2.cost){
                    return 1;
                }
                else{
                    return -1;
                }

            }
        };
        PriorityQueue<pair> pq=new PriorityQueue<>(comp);
        for(int i=0;i<quiet.length;i++){
            ans[i]=-1;
            pq.add(new pair(i,quiet[i]));
        }
        
        while(!pq.isEmpty()){
            pair top=pq.poll();
            curr_node=top.node;
            if(!vis.contains(top.node)){
            dfs(top.node);
            }
        }
        return ans;
       
    }
    public void dfs(int node){
        if(ans[node]==-1){
            ans[node]=curr_node;
        }
        if(!vis.contains(node) && map.containsKey(node)){
            vis.add(node);
             
            for(int i : map.get(node)){
            dfs(i);
        
        }
        }
            
    }
}

class pair{
    int node,cost;
    pair(int node,int cost){
        this.node=node;
        this.cost=cost;
    }
}",None,"class Solution {
    int ans[];
    Map<Integer, List<Integer>> map = new HashMap<>();
    int temp[] = new int[0];
    int curr_node = 0;
    List<Integer> vis = new ArrayList<Integer>();

    public int[] loudAndRich(int[][] richer, int[] quiet) {
        ans = new int[quiet.length];

        for (int i = 0; i < richer.length; i++) {
            map.putIfAbsent(richer[i][1], new ArrayList<>());
            map.get(richer[i][1]).add(richer[i][0]);
        }

        for (int i = 0; i < quiet.length; i++) {
            dfs(i, quiet[i]);
        }

        return ans;
    }

    public void dfs(int node, int cost) {
        if (ans[node] == 0) {
            ans[node] = cost;
        } else if (ans[node] > cost) {
            ans[node] = cost;
        }

        if (map.containsKey(node)) {
            for (int nei : map.get(node)) {
                dfs(nei, cost);
            }
        }
    }
}
"
2767,java,add-strings,"class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        sys.set_int_max_str_digits(10000)
        nattu = int(num1)
        babu = int(num1)
        result = str(nattu+babu)
        return result",None,"class Solution {
    public String addStrings(String num1, String num2) {
        int len1 = num1.length();
        int len2 = num2.length();
        int carry = 0;
        StringBuilder result = new StringBuilder();

        for (int i = len1 - 1, j = len2 - 1; i >= 0 || j >= 0 || carry > 0; i--, j--) {
            int digit1 = i >= 0 ? num1.charAt(i) - '0' : 0;
            int digit2 = j >= 0 ? num2.charAt(j) - '0' : 0;
            int sum = digit1 + digit2 + carry;
            carry = sum / 10;
            result.append(sum % 10);
        }

        return result.reverse().toString();
    }
}
"
2767,java,add-strings,"class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        sys.set_int_max_str_digits(10000)
        nattu = int(num1)
        babu = int(num1)
        result = str(nattu+babu)
        return result",None,"class Solution {
    public String addStrings(String num1, String num2) {
        int len1 = num1.length();
        int len2 = num2.length();
        int carry = 0;
        StringBuilder result = new StringBuilder();

        while (len1 > 0 || len2 > 0) {
            int sum = carry;
            if (len1 > 0) {
                sum += num1.charAt(--len1) - '0';
            }
            if (len2 > 0) {
                sum += num2.charAt(--len2) - '0';
            }
            carry = sum / 10;
            result.append(sum % 10);
        }

        if (carry > 0) {
            result.append(carry);
        }

        return result.reverse().toString();
    }
}
"
2767,java,add-strings,"class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        sys.set_int_max_str_digits(10000)
        nattu = int(num1)
        babu = int(num1)
        result = str(nattu+babu)
        return result",None,"class Solution {
    public String addStrings(String num1, String num2) {
        int n = num1.length() - 1;
        int m = num2.length() - 1;
        int carry = 0;
        StringBuilder sb = new StringBuilder();

        while (n >= 0 || m >= 0) {
            int sum = carry;
            if (n >= 0) {
                sum += num1.charAt(n) - '0';
                n--;
            }
            if (m >= 0) {
                sum += num2.charAt(m) - '0';
                m--;
            }
            carry = sum / 10;
            sb.append(sum % 10);
        }
        if (carry > 0) {
            sb.append(carry);
        }

        return sb.reverse().toString();
    }
}
"
2768,java,maximum-number-of-fish-in-a-grid,"class Solution {
    public int findMaxFish(int[][] grid) {
        int sum=0;
        for(int i=0;i<grid.length;i++)
        {
            for(int j=0;j<grid[0].length;j++)
            {
                if(grid[i][j]!=0)
                {
                    int a[]=new int[1];
                    task(grid,i,j,a);
                    sum=Math.max(sum,a[0]);
                }
            }
        }
        return sum;
    }
    public void task(int grid[][], int i, int j, int a[])
    {
        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)
        {
            return;
        }
        a[0]+=grid[i][j];
        grid[i][j]=0;
        task(grid,i+1,j,a);
        task(grid,i-1,j,a);
        task(grid,i,j+1,a);
        task(grid,i,j-1,a);
        a[0] = 0; 
    }
}",None,"class Solution {
    public int findMaxFish(int[][] grid) {
        int sum=0;
        for(int i=0;i<grid.length;i++)
        {
            for(int j=0;j<grid[0].length;j++)
            {
                if(grid[i][j]!=0)
                {
                    int a=0;
                    task(grid,i,j,a);
                    sum=Math.max(sum,a);
                }
            }
        }
        return sum;
    }
    public void task(int grid[][], int i, int j, int a)
    {
        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)
        {
            return;
        }
        a+=grid[i][j];
        grid[i][j]=0;
        task(grid,i+1,j,a);
        task(grid,i-1,j,a);
        task(grid,i,j+1,a);
        task(grid,i,j-1,a);
    }
}
"
2768,java,maximum-number-of-fish-in-a-grid,"class Solution {
    public int findMaxFish(int[][] grid) {
        int sum=0;
        for(int i=0;i<grid.length;i++)
        {
            for(int j=0;j<grid[0].length;j++)
            {
                if(grid[i][j]!=0)
                {
                    int a[]=new int[1];
                    task(grid,i,j,a);
                    sum=Math.max(sum,a[0]);
                }
            }
        }
        return sum;
    }
    public void task(int grid[][], int i, int j, int a[])
    {
        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)
        {
            return;
        }
        a[0]+=grid[i][j];
        grid[i][j]=0;
        task(grid,i+1,j,a);
        task(grid,i-1,j,a);
        task(grid,i,j+1,a);
        task(grid,i,j-1,a);
        a[0] = 0; 
    }
}",None,"class Solution {
    public int findMaxFish(int[][] grid) {
        int sum=0;
        for(int i=0;i<grid.length;i++)
        {
            for(int j=0;j<grid[0].length;j++)
            {
                if(grid[i][j]!=0)
                {
                    int a[]=new int[1];
                    task(grid,i,j,a);
                    sum=Math.max(sum,a[0]);
                }
            }
        }
        return sum;
    }
    public void task(int grid[][], int i, int j, int[] a)
    {
        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)
        {
            return;
        }
        a[0]+=grid[i][j];
        grid[i][j]=0;
        task(grid,i+1,j,a);
        task(grid,i-1,j,a);
        task(grid,i,j+1,a);
        task(grid,i,j-1,a);
    }
}
"
2768,java,maximum-number-of-fish-in-a-grid,"class Solution {
    public int findMaxFish(int[][] grid) {
        int sum=0;
        for(int i=0;i<grid.length;i++)
        {
            for(int j=0;j<grid[0].length;j++)
            {
                if(grid[i][j]!=0)
                {
                    int a[]=new int[1];
                    task(grid,i,j,a);
                    sum=Math.max(sum,a[0]);
                }
            }
        }
        return sum;
    }
    public void task(int grid[][], int i, int j, int a[])
    {
        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)
        {
            return;
        }
        a[0]+=grid[i][j];
        grid[i][j]=0;
        task(grid,i+1,j,a);
        task(grid,i-1,j,a);
        task(grid,i,j+1,a);
        task(grid,i,j-1,a);
        a[0] = 0; 
    }
}",None,"class Solution {
    public int findMaxFish(int[][] grid) {
        int sum=0;
        for(int i=0;i<grid.length;i++)
        {
            for(int j=0;j<grid[0].length;j++)
            {
                if(grid[i][j]!=0)
                {
                    int a=0;
                    task(grid,i,j,a);
                    sum=Math.max(sum,a);
                }
            }
        }
        return sum;
    }
    public void task(int grid[][], int i, int j, int a)
    {
        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)
        {
            return;
        }
        a+=grid[i][j];
        grid[i][j]=0;
        task(grid,i+1,j,a);
        task(grid,i-1,j,a);
        task(grid,i,j+1,a);
        task(grid,i,j-1,a);
    }
}
"
2769,java,find-all-people-with-secret,"class DisjointSet {
    int[] root;
    Long[] rank;
    DisjointSet(int size, Set<Integer> secretKeepers) {
        root = new int[size];
        rank = new Long[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;
        }
    }

    public int find(int vertex) {
        if(root[vertex] == vertex) return vertex;
        return root[vertex] = find(root[vertex]);
    }

    public void union(int vertex1, int vertex2) {
        int root1 = find(vertex1);
        int root2 = find(vertex2);
        if(root1 != root2) {
            if(rank[root1] > rank[root2]) {
                root[root2] = root1;
            } else if (rank[root2] > rank[root1]) {
                root[root1] = root2;
            } else {
                root[root2] = root1;
                rank[root1]++;
            }
        }
    }

    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {
        for (int vertex: visited) {
            if(secretKeepers.contains(find(vertex)))
                secretKeepers.add(vertex);
            else 
                root[vertex] = vertex;
        }
        return secretKeepers;
    }
}

class Solution {
    private int maxTime = Integer.MIN_VALUE;
    private int minTime = Integer.MAX_VALUE;
    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {
        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));
        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);
        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);
        for (int time = minTime; time <= maxTime; time++) {
            if(!timeToMeetings.containsKey(time)) continue;
            Set<Integer> visited = new HashSet<>();
            for (Integer[] meeting: timeToMeetings.get(time)) {
                int person1 = meeting[0], person2 = meeting[1];
                disjointSet.union(person1, meeting[2]);
                visited.add(person1);
                visited.add(person2);
            }
            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);
        }
        return new ArrayList<>(secretKeepers);
    }

    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {
        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();
        for (int[] meeting: meetings) {
            maxTime = Math.max(maxTime, meeting[2]);
            minTime = Math.min(minTime, meeting[2]);
            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});
        }
        return timeToMeetings;
    }
}",None,"class DisjointSet {
    int[] root;
    Long[] rank;
    DisjointSet(int size, Set<Integer> secretKeepers) {
        root = new int[size];
        rank = new Long[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = secretKeepers.contains(i) ? Long.MAX_VALUE : 1L;
        }
    }

    public int find(int vertex) {
        if(root[vertex] == vertex) return vertex;
        return root[vertex] = find(root[vertex]);
    }

    public void union(int vertex1, int vertex2) {
        int root1 = find(vertex1);
        int root2 = find(vertex2);
        if(root1 != root2) {
            if(rank[root1] > rank[root2]) {
                root[root2] = root1;
            } else if (rank[root2] > rank[root1]) {
                root[root1] = root2;
            } else {
                root[root2] = root1;
                rank[root1]++;
            }
        }
    }

    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {
        for (int vertex: visited) {
            if(secretKeepers.contains(find(vertex)))
                secretKeepers.add(vertex);
            else 
                root[vertex] = vertex;
        }
        return secretKeepers;
    }
}

class Solution {
    private int maxTime = Integer.MIN_VALUE;
    private int minTime = Integer.MAX_VALUE;
    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {
        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));
        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);
        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);
        for (int time = minTime; time <= maxTime; time++) {
            if(!timeToMeetings.containsKey(time)) continue;
            Set<Integer> visited = new HashSet<>();
            for (Integer[] meeting: timeToMeetings.get(time)) {
                int person1 = meeting[0], person2 = meeting[1];
                disjointSet.union(person1, person2);
                visited.add(person1);
                visited.add(person2);
            }
            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);
        }
        return new ArrayList<>(secretKeepers);
    }

    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {
        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();
        for (int[] meeting: meetings) {
            maxTime = Math.max(maxTime, meeting[2]);
            minTime = Math.min(minTime, meeting[2]);
            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});
        }
        return timeToMeetings;
    }
}
"
2769,java,find-all-people-with-secret,"class DisjointSet {
    int[] root;
    Long[] rank;
    DisjointSet(int size, Set<Integer> secretKeepers) {
        root = new int[size];
        rank = new Long[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;
        }
    }

    public int find(int vertex) {
        if(root[vertex] == vertex) return vertex;
        return root[vertex] = find(root[vertex]);
    }

    public void union(int vertex1, int vertex2) {
        int root1 = find(vertex1);
        int root2 = find(vertex2);
        if(root1 != root2) {
            if(rank[root1] > rank[root2]) {
                root[root2] = root1;
            } else if (rank[root2] > rank[root1]) {
                root[root1] = root2;
            } else {
                root[root2] = root1;
                rank[root1]++;
            }
        }
    }

    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {
        for (int vertex: visited) {
            if(secretKeepers.contains(find(vertex)))
                secretKeepers.add(vertex);
            else 
                root[vertex] = vertex;
        }
        return secretKeepers;
    }
}

class Solution {
    private int maxTime = Integer.MIN_VALUE;
    private int minTime = Integer.MAX_VALUE;
    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {
        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));
        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);
        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);
        for (int time = minTime; time <= maxTime; time++) {
            if(!timeToMeetings.containsKey(time)) continue;
            Set<Integer> visited = new HashSet<>();
            for (Integer[] meeting: timeToMeetings.get(time)) {
                int person1 = meeting[0], person2 = meeting[1];
                disjointSet.union(person1, meeting[2]);
                visited.add(person1);
                visited.add(person2);
            }
            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);
        }
        return new ArrayList<>(secretKeepers);
    }

    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {
        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();
        for (int[] meeting: meetings) {
            maxTime = Math.max(maxTime, meeting[2]);
            minTime = Math.min(minTime, meeting[2]);
            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});
        }
        return timeToMeetings;
    }
}",None,"class DisjointSet {
    int[] root;
    Long[] rank;
    DisjointSet(int size, Set<Integer> secretKeepers) {
        root = new int[size];
        rank = new Long[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = secretKeepers.contains(i) ? 1L : 0L;
        }
    }

    public int find(int vertex) {
        if(root[vertex] == vertex) return vertex;
        return root[vertex] = find(root[vertex]);
    }

    public void union(int vertex1, int vertex2) {
        int root1 = find(vertex1);
        int root2 = find(vertex2);
        if(root1 != root2) {
            if(rank[root1] > rank[root2]) {
                root[root2] = root1;
            } else if (rank[root2] > rank[root1]) {
                root[root1] = root2;
            } else {
                root[root2] = root1;
                rank[root1]++;
            }
        }
    }

    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {
        for (int vertex: visited) {
            if(secretKeepers.contains(find(vertex)))
                secretKeepers.add(vertex);
        }
        return secretKeepers;
    }
}

class Solution {
    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {
        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));
        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);
        for (int[] meeting: meetings) {
            int person1 = meeting[0], person2 = meeting[1];
            disjointSet.union(person1, person2);
        }
        for (int[] meeting: meetings) {
            int person1 = meeting[0], person2 = meeting[1];
            if (disjointSet.find(person1) == disjointSet.find(person2)) {
                secretKeepers.add(meeting[0]);
                secretKeepers.add(meeting[1]);
            }
        }
        return new ArrayList<>(secretKeepers);
    }
}
"
2769,java,find-all-people-with-secret,"class DisjointSet {
    int[] root;
    Long[] rank;
    DisjointSet(int size, Set<Integer> secretKeepers) {
        root = new int[size];
        rank = new Long[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;
        }
    }

    public int find(int vertex) {
        if(root[vertex] == vertex) return vertex;
        return root[vertex] = find(root[vertex]);
    }

    public void union(int vertex1, int vertex2) {
        int root1 = find(vertex1);
        int root2 = find(vertex2);
        if(root1 != root2) {
            if(rank[root1] > rank[root2]) {
                root[root2] = root1;
            } else if (rank[root2] > rank[root1]) {
                root[root1] = root2;
            } else {
                root[root2] = root1;
                rank[root1]++;
            }
        }
    }

    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {
        for (int vertex: visited) {
            if(secretKeepers.contains(find(vertex)))
                secretKeepers.add(vertex);
            else 
                root[vertex] = vertex;
        }
        return secretKeepers;
    }
}

class Solution {
    private int maxTime = Integer.MIN_VALUE;
    private int minTime = Integer.MAX_VALUE;
    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {
        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));
        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);
        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);
        for (int time = minTime; time <= maxTime; time++) {
            if(!timeToMeetings.containsKey(time)) continue;
            Set<Integer> visited = new HashSet<>();
            for (Integer[] meeting: timeToMeetings.get(time)) {
                int person1 = meeting[0], person2 = meeting[1];
                disjointSet.union(person1, meeting[2]);
                visited.add(person1);
                visited.add(person2);
            }
            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);
        }
        return new ArrayList<>(secretKeepers);
    }

    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {
        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();
        for (int[] meeting: meetings) {
            maxTime = Math.max(maxTime, meeting[2]);
            minTime = Math.min(minTime, meeting[2]);
            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});
        }
        return timeToMeetings;
    }
}",None,"class DisjointSet {
    int[] root;
    Long[] rank;
    DisjointSet(int size, Set<Integer> secretKeepers) {
        root = new int[size];
        rank = new Long[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = secretKeepers.contains(i) ? Long.MAX_VALUE : 1L;
        }
    }

    public int find(int vertex) {
        if(root[vertex] == vertex) return vertex;
        return root[vertex] = find(root[vertex]);
    }

    public void union(int vertex1, int vertex2) {
        int root1 = find(vertex1);
        int root2 = find(vertex2);
        if(root1 != root2) {
            if(rank[root1] > rank[root2]) {
                root[root2] = root1;
            } else if (rank[root2] > rank[root1]) {
                root[root1] = root2;
            } else {
                root[root2] = root1;
                rank[root1]++;
            }
        }
    }

    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {
        for (int vertex: visited) {
            if(secretKeepers.contains(find(vertex)))
                secretKeepers.add(vertex);
            else 
                root[vertex] = vertex;
        }
        return secretKeepers;
    }
}

class Solution {
    private int maxTime = Integer.MIN_VALUE;
    private int minTime = Integer.MAX_VALUE;
    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {
        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));
        Map<Integer, List<int[]>> timeToMeetings = getTimeToMeetings(meetings);
        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);
        for (int time = minTime; time <= maxTime; time++) {
            if(!timeToMeetings.containsKey(time)) continue;
            Set<Integer> visited = new HashSet<>();
            for (int[] meeting: timeToMeetings.get(time)) {
                int person1 = meeting[0], person2 = meeting[1];
                disjointSet.union(person1, person2);
                visited.add(person1);
                visited.add(person2);
            }
            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);
        }
        return new ArrayList<>(secretKeepers);
    }

    private Map<Integer, List<int[]>> getTimeToMeetings(int[][] meetings) {
        Map<Integer, List<int[]>> timeToMeetings = new HashMap<>();
        for (int[] meeting: meetings) {
            maxTime = Math.max(maxTime, meeting[2]);
            minTime = Math.min(minTime, meeting[2]);
            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new int[]{meeting[0], meeting[1]});
        }
        return timeToMeetings;
    }
}
"
2770,java,subtract-the-product-and-sum-of-digits-of-an-integer,"class Solution {
    public int subtractProductAndSum(int n) {
        int prod=0; 
        int sum=0;
        while(n>0) {
            int rem=n%10;
            sum+=rem;
            prod*=rem;
            n/=10;
        }
        return prod-sum;
    }
}",None,"class Solution {
    public int subtractProductAndSum(int n) {
        int prod=1; 
        int sum=0;
        while(n>0) {
            int rem=n%10;
            sum+=rem;
            prod*=rem;
            n/=10;
        }
        return prod-sum;
    }
}
"
2770,java,subtract-the-product-and-sum-of-digits-of-an-integer,"class Solution {
    public int subtractProductAndSum(int n) {
        int prod=0; 
        int sum=0;
        while(n>0) {
            int rem=n%10;
            sum+=rem;
            prod*=rem;
            n/=10;
        }
        return prod-sum;
    }
}",None,"class Solution {
    public int subtractProductAndSum(int n) {
        int prod=1; 
        int sum=0;
        while(n>0) {
            int rem=n%10;
            sum+=rem;
            prod*=rem;
            n/=10;
        }
        return prod-sum;
    }
}
"
2770,java,subtract-the-product-and-sum-of-digits-of-an-integer,"class Solution {
    public int subtractProductAndSum(int n) {
        int prod=0; 
        int sum=0;
        while(n>0) {
            int rem=n%10;
            sum+=rem;
            prod*=rem;
            n/=10;
        }
        return prod-sum;
    }
}",None,"class Solution {
    public int subtractProductAndSum(int n) {
        int prod=1; 
        int sum=0;
        while(n>0) {
            int rem=n%10;
            sum+=rem;
            prod*=rem;
            n/=10;
        }
        return prod-sum;
    }
}
"
2771,java,merge-strings-alternately,"class Solution {
    public String mergeAlternately(String word1, String word2) {
     char [] arr1=word1.toCharArray();
     char [] arr2=word2.toCharArray();
     char [] merge = new char[arr1.length+arr2.length];
    int i=0,j=0;
    while( i< merge.length){
        if(j<arr1.length){
            merge[i]=arr2[j];
            i++;
        }
        if( j< arr2.length){
            merge[i]=arr1[j];
            i++;
        }
        j++;
    }
    return new String(merge);
    }
}",None,"class Solution {
    public String mergeAlternately(String word1, String word2) {
        char [] arr1=word1.toCharArray();
        char [] arr2=word2.toCharArray();
        char [] merge = new char[arr1.length+arr2.length];
        int i=0,j=0;
        while(i < merge.length){
            if(j < arr1.length){
                merge[i]=arr1[j];
                i++;
            }
            if( j < arr2.length){
                merge[i]=arr2[j];
                i++;
            }
            j++;
        }
        return new String(merge);
    }
}
"
2771,java,merge-strings-alternately,"class Solution {
    public String mergeAlternately(String word1, String word2) {
     char [] arr1=word1.toCharArray();
     char [] arr2=word2.toCharArray();
     char [] merge = new char[arr1.length+arr2.length];
    int i=0,j=0;
    while( i< merge.length){
        if(j<arr1.length){
            merge[i]=arr2[j];
            i++;
        }
        if( j< arr2.length){
            merge[i]=arr1[j];
            i++;
        }
        j++;
    }
    return new String(merge);
    }
}",None,"class Solution {
    public String mergeAlternately(String word1, String word2) {
        char [] arr1=word1.toCharArray();
        char [] arr2=word2.toCharArray();
        char [] merge = new char[Math.max(arr1.length, arr2.length)];
        int i=0,j=0;
        for(int k=0; k<merge.length; k++){
            if(i<arr1.length){
                merge[k]=arr1[i];
                i++;
            }
            else merge[k]=arr2[j];
            if(j<arr2.length){
                j++;
            }
        }
        return new String(merge);
    }
}
"
2771,java,merge-strings-alternately,"class Solution {
    public String mergeAlternately(String word1, String word2) {
     char [] arr1=word1.toCharArray();
     char [] arr2=word2.toCharArray();
     char [] merge = new char[arr1.length+arr2.length];
    int i=0,j=0;
    while( i< merge.length){
        if(j<arr1.length){
            merge[i]=arr2[j];
            i++;
        }
        if( j< arr2.length){
            merge[i]=arr1[j];
            i++;
        }
        j++;
    }
    return new String(merge);
    }
}",None,"class Solution {
    public String mergeAlternately(String word1, String word2) {
        char [] arr1=word1.toCharArray();
        char [] arr2=word2.toCharArray();
        char [] merge = new char[arr1.length+arr2.length];
        int i=0,j=0;
        while(i < merge.length){
            if(j < arr1.length){
                merge[i]=arr1[j];
                i++;
            }
            if(j < arr2.length){
                merge[i]=arr2[j];
                i++;
            }
            j++;
        }
        return new String(merge);
    }
}
"
2772,java,ways-to-split-array-into-good-subarrays,"class Solution {
    public int numberOfGoodSubarraySplits(int[] nums) {
        
       List<Integer> list = new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            if(nums[i]==1) list.add(i);
        }
        if(list.size()==0) return 0;
        if(list.size()==1) return 1;
        int mod =(int)1e9+7;
        long res = 0;
        for(int i=0;i<list.size()-1;i++){
                long index1 = (long)list.get(i);
                long index2 = (long)list.get(i+1);
                res =  ( res%mod * (index2-index1)%mod)%mod;
                
            
        }
        return (int)res;
    }
}",None,"class Solution {
    public int numberOfGoodSubarraySplits(int[] nums) {
        
       List<Integer> list = new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            if(nums[i]==1) list.add(i);
        }
        if(list.size()==0) return 0;
        if(list.size()==1) return 1;
        int mod =(int)1e9+7;
        long res = 0;
        for(int i=0;i<list.size()-1;i++){
                int index1 = list.get(i);
                int index2 = list.get(i+1);
                res =  ( res%mod * (index2-index1)%mod)%mod;
                
            
        }
        return (int)res;
    }
}
"
2772,java,ways-to-split-array-into-good-subarrays,"class Solution {
    public int numberOfGoodSubarraySplits(int[] nums) {
        
       List<Integer> list = new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            if(nums[i]==1) list.add(i);
        }
        if(list.size()==0) return 0;
        if(list.size()==1) return 1;
        int mod =(int)1e9+7;
        long res = 0;
        for(int i=0;i<list.size()-1;i++){
                long index1 = (long)list.get(i);
                long index2 = (long)list.get(i+1);
                res =  ( res%mod * (index2-index1)%mod)%mod;
                
            
        }
        return (int)res;
    }
}",None,"class Solution {
    public int numberOfGoodSubarraySplits(int[] nums) {
        
       List<Integer> list = new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            if(nums[i]==1) list.add(i);
        }
        if(list.size()==0) return 0;
        if(list.size()==1) return 1;
        int mod =(int)1e9+7;
        long res = 0;
        for(int i=0;i<list.size()-1;i++){
                int index1 = list.get(i);
                int index2 = list.get(i+1);
                res =  ( res%mod * (index2-index1)%mod)%mod;
                
            
        }
        return (int)res;
    }
}
"
2772,java,ways-to-split-array-into-good-subarrays,"class Solution {
    public int numberOfGoodSubarraySplits(int[] nums) {
        
       List<Integer> list = new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            if(nums[i]==1) list.add(i);
        }
        if(list.size()==0) return 0;
        if(list.size()==1) return 1;
        int mod =(int)1e9+7;
        long res = 0;
        for(int i=0;i<list.size()-1;i++){
                long index1 = (long)list.get(i);
                long index2 = (long)list.get(i+1);
                res =  ( res%mod * (index2-index1)%mod)%mod;
                
            
        }
        return (int)res;
    }
}",None,"class Solution {
    public int numberOfGoodSubarraySplits(int[] nums) {
        
       List<Integer> list = new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            if(nums[i]==1) list.add(i);
        }
        if(list.size()==0) return 0;
        if(list.size()==1) return 1;
        int mod =(int)1e9+7;
        long res = 0;
        for(int i=0;i<list.size()-1;i++){
                long index1 = (long)list.get(i);
                long index2 = (long)list.get(i+1);
                res =  ( res%mod * (index2-index1-1)%mod)%mod;
                
            
        }
        return (int)res;
    }
}
"
2773,java,trapping-rain-water,"class Solution 
{
    public int trap(int[] height) 
    {
        int result = 0;
        if(height==null || height.length<=2)
            return result;
        int left[] = new int[height.length];
        int right[]= new int[height.length];
        int max = height[0];
        left[0] = height[0];
        for(int i=1; i<height.length; i++)
        {
            if(height[i]<max)
            {
                left[i]=height[i];
            }
            else
            {
                left[i]=height[i];
                max = height[i];
            }
        }
        max = height[height.length-1];
        right[height.length-1]=height[height.length-1];
        for(int i=height.length-2; i>=0; i--)
        {
            if(height[i]<max)
            {
                right[i]=max;  
            }
            else
            {  
                right[i]=height[i];
                max = height[i];
            }
        }
    
        for(int i=0; i<height.length; i++)
        {
            result+= Math.min(left[i],right[i])-height[i];
        }
        return result;
    }
}",None,"class Solution 
{
    public int trap(int[] height) 
    {
        int result = 0;
        if(height==null || height.length<=2)
            return result;
        int left[] = new int[height.length];
        int right[]= new int[height.length];
        int max = height[0];
        left[0] = height[0];
        for(int i=1; i<height.length; i++)
        {
            if(height[i]<max)
            {
                left[i]=height[i];
            }
            else
            {
                left[i]=height[i];
                max = height[i];
            }
        }
        max = height[height.length-1];
        right[height.length-1]=height[height.length-1];
        for(int i=height.length-2; i>=0; i--)
        {
            if(height[i]<max)
            {
                right[i]=max;  
            }
            else
            {
                right[i]=height[i];
                max = height[i];
            }
        }
    
        for(int i=0; i<height.length; i++)
        {
            result+= Math.min(left[i],right[i])-height[i];
        }
        return result;
    }
}
"
2773,java,trapping-rain-water,"class Solution 
{
    public int trap(int[] height) 
    {
        int result = 0;
        if(height==null || height.length<=2)
            return result;
        int left[] = new int[height.length];
        int right[]= new int[height.length];
        int max = height[0];
        left[0] = height[0];
        for(int i=1; i<height.length; i++)
        {
            if(height[i]<max)
            {
                left[i]=height[i];
            }
            else
            {
                left[i]=height[i];
                max = height[i];
            }
        }
        max = height[height.length-1];
        right[height.length-1]=height[height.length-1];
        for(int i=height.length-2; i>=0; i--)
        {
            if(height[i]<max)
            {
                right[i]=max;  
            }
            else
            {  
                right[i]=height[i];
                max = height[i];
            }
        }
    
        for(int i=0; i<height.length; i++)
        {
            result+= Math.min(left[i],right[i])-height[i];
        }
        return result;
    }
}",None,"class Solution 
{
    public int trap(int[] height) 
    {
        int result = 0;
        if(height==null || height.length<=2)
            return result;
        int left[] = new int[height.length];
        int right[]= new int[height.length];
        int max = height[0];
        left[0] = height[0];
        for(int i=1; i<height.length; i++)
        {
            if(height[i]<max)
            {
                left[i]=height[i];
            }
            else
            {
                left[i]=height[i];
                max = height[i];
            }
        }
        max = height[height.length-1];
        right[height.length-1]=height[height.length-1];
        for(int i=height.length-2; i>=0; i--)
        {
            if(height[i]<max)
            {
                right[i]=max;
            }
            else
            {
                right[i]=height[i];
                max = height[i];
            }
        }
    
        for(int i=0; i<height.length; i++)
        {
            result+= Math.min(left[i],right[i])-height[i];
        }
        return result;
    }
}
"
2773,java,trapping-rain-water,"class Solution 
{
    public int trap(int[] height) 
    {
        int result = 0;
        if(height==null || height.length<=2)
            return result;
        int left[] = new int[height.length];
        int right[]= new int[height.length];
        int max = height[0];
        left[0] = height[0];
        for(int i=1; i<height.length; i++)
        {
            if(height[i]<max)
            {
                left[i]=height[i];
            }
            else
            {
                left[i]=height[i];
                max = height[i];
            }
        }
        max = height[height.length-1];
        right[height.length-1]=height[height.length-1];
        for(int i=height.length-2; i>=0; i--)
        {
            if(height[i]<max)
            {
                right[i]=max;  
            }
            else
            {  
                right[i]=height[i];
                max = height[i];
            }
        }
    
        for(int i=0; i<height.length; i++)
        {
            result+= Math.min(left[i],right[i])-height[i];
        }
        return result;
    }
}",None,"class Solution 
{
    public int trap(int[] height) 
    {
        int result = 0;
        if(height==null || height.length<=2)
            return result;
        int left[] = new int[height.length];
        int right[]= new int[height.length];
        int max = height[0];
        left[0] = height[0];
        for(int i=1; i<height.length; i++)
        {
            if(height[i]<max)
            {
                left[i]=height[i];
            }
            else
            {
                left[i]=height[i];
                max = height[i];
            }
        }
        max = height[height.length-1];
        right[height.length-1]=height[height.length-1];
        for(int i=height.length-2; i>=0; i--)
        {
            if(height[i]<max)
            {
                right[i]=max;  
            }
            else
            {
                right[i]=height[i];
                max = height[i];
            }
        }
    
        for(int i=0; i<height.length; i++)
        {
            result+= Math.min(left[i],right[i])-height[i];
        }
        return result;
    }
}
"
2774,java,move-zeroes,"class Solution {
    public void moveZeroes(int[] nums) {
        int m=-1;
        for(int i=0; i<nums.length; i++)
        {
            if(nums[i]==0)
            {
                if(m==-1 || nums[m]!=0)
                {
                    m=i;
                }
            }
            else
            {
                if(m!=-1)
                {
                    int temp = nums[m];
                    nums[i]=nums[m];
                    nums[m]=temp;
                    m++;
                }
            }
        }
    }
}",None,"class Solution {
    public void moveZeroes(int[] nums) {
        int m=-1;
        for(int i=0; i<nums.length; i++)
        {
            if(nums[i]==0)
            {
                if(m==-1)
                {
                    m=i;
                }
            }
            else
            {
                if(m!=-1)
                {
                    int temp = nums[m];
                    nums[m]=nums[i];
                    nums[i]=temp;
                    m++;
                }
            }
        }
    }
}
"
2774,java,move-zeroes,"class Solution {
    public void moveZeroes(int[] nums) {
        int m=-1;
        for(int i=0; i<nums.length; i++)
        {
            if(nums[i]==0)
            {
                if(m==-1 || nums[m]!=0)
                {
                    m=i;
                }
            }
            else
            {
                if(m!=-1)
                {
                    int temp = nums[m];
                    nums[i]=nums[m];
                    nums[m]=temp;
                    m++;
                }
            }
        }
    }
}",None,"class Solution {
    public void moveZeroes(int[] nums) {
        int m=-1;
        for(int i=0; i<nums.length; i++)
        {
            if(nums[i]!=0)
            {
                if(m!=-1)
                {
                    int temp = nums[m];
                    nums[m] = nums[i];
                    nums[i] = temp;
                }
                m++;
            }
        }
    }
}
"
2774,java,move-zeroes,"class Solution {
    public void moveZeroes(int[] nums) {
        int m=-1;
        for(int i=0; i<nums.length; i++)
        {
            if(nums[i]==0)
            {
                if(m==-1 || nums[m]!=0)
                {
                    m=i;
                }
            }
            else
            {
                if(m!=-1)
                {
                    int temp = nums[m];
                    nums[i]=nums[m];
                    nums[m]=temp;
                    m++;
                }
            }
        }
    }
}",None,"class Solution {
    public void moveZeroes(int[] nums) {
        int m=-1;
        for(int i=0; i<nums.length; i++)
        {
            if(nums[i]==0)
            {
                if(m==-1)
                {
                    m=i;
                }
            }
            else
            {
                if(m!=-1)
                {
                    int temp = nums[m];
                    nums[m]=nums[i];
                    nums[i]=temp;
                    m++;
                }
            }
        }
    }
}
"
2775,java,largest-element-in-an-array-after-merge-operations,"class Solution {
    public long maxArrayValue(int[] nums) {
        if(nums.length==1)
        {
            return (long)nums[0];
        }
        if(nums.length==2)
        {
            return nums[0] <= nums[1] ? (long)(nums[0]+nums[1]) : (long)(Math.max(nums[0],nums[1]));
        }
        int size=nums.length;
        long ans=0,dat=(long)nums[size-1];
        for(int i=size-2;i>=0;i--)
        {
            long val=(long)nums[i];
            if(val<=dat)
            {
                dat=dat+val;
                if(dat>ans)
                {
                    ans=dat;
                }
            }
            else
            {
                if(dat>ans)
                {
                    ans=dat;
                }
                dat=val;
            }
        }
        return ans;
    }
}",None,"class Solution {
    public long maxArrayValue(int[] nums) {
        if(nums.length==1)
        {
            return (long)nums[0];
        }
        if(nums.length==2)
        {
            return nums[0] <= nums[1] ? (long)(nums[0]+nums[1]) : (long)(Math.max(nums[0],nums[1]));
        }
        int size=nums.length;
        long ans=0,dat=(long)nums[size-1];
        for(int i=size-2;i>=0;i--)
        {
            long val=(long)nums[i];
            if(val<=dat)
            {
                dat=dat+val;
                if(dat>ans)
                {
                    ans=dat;
                }
            }
            else
            {
                if(val>ans)
                {
                    ans=val;
                }
                dat=val;
            }
        }
        return ans;
    }
}
"
2775,java,largest-element-in-an-array-after-merge-operations,"class Solution {
    public long maxArrayValue(int[] nums) {
        if(nums.length==1)
        {
            return (long)nums[0];
        }
        if(nums.length==2)
        {
            return nums[0] <= nums[1] ? (long)(nums[0]+nums[1]) : (long)(Math.max(nums[0],nums[1]));
        }
        int size=nums.length;
        long ans=0,dat=(long)nums[size-1];
        for(int i=size-2;i>=0;i--)
        {
            long val=(long)nums[i];
            if(val<=dat)
            {
                dat=dat+val;
                if(dat>ans)
                {
                    ans=dat;
                }
            }
            else
            {
                if(dat>ans)
                {
                    ans=dat;
                }
                dat=val;
            }
        }
        return ans;
    }
}",None,"class Solution {
    public long maxArrayValue(int[] nums) {
        if(nums.length==1)
        {
            return (long)nums[0];
        }
        if(nums.length==2)
        {
            return nums[0] <= nums[1] ? (long)(nums[0]+nums[1]) : (long)(Math.max(nums[0],nums[1]));
        }
        int size=nums.length;
        long ans=0,dat=(long)nums[size-1];
        for(int i=size-2;i>=0;i--)
        {
            long val=(long)nums[i];
            if(val<=dat)
            {
                dat+=val;
                if(dat>ans)
                {
                    ans=dat;
                }
            }
            else
            {
                if(dat>ans)
                {
                    ans=dat;
                }
                dat=val;
            }
        }
        return ans;
    }
}
"
2775,java,largest-element-in-an-array-after-merge-operations,"class Solution {
    public long maxArrayValue(int[] nums) {
        if(nums.length==1)
        {
            return (long)nums[0];
        }
        if(nums.length==2)
        {
            return nums[0] <= nums[1] ? (long)(nums[0]+nums[1]) : (long)(Math.max(nums[0],nums[1]));
        }
        int size=nums.length;
        long ans=0,dat=(long)nums[size-1];
        for(int i=size-2;i>=0;i--)
        {
            long val=(long)nums[i];
            if(val<=dat)
            {
                dat=dat+val;
                if(dat>ans)
                {
                    ans=dat;
                }
            }
            else
            {
                if(dat>ans)
                {
                    ans=dat;
                }
                dat=val;
            }
        }
        return ans;
    }
}",None,"class Solution {
    public long maxArrayValue(int[] nums) {
        if(nums.length==1)
        {
            return (long)nums[0];
        }
        if(nums.length==2)
        {
            return nums[0] <= nums[1] ? (long)(nums[0]+nums[1]) : (long)(Math.max(nums[0],nums[1]));
        }
        int size=nums.length;
        long ans=0,dat=(long)nums[size-1];
        for(int i=size-2;i>=0;i--)
        {
            long val=(long)nums[i];
            if(val<=dat)
            {
                dat=dat+val;
                if(dat>ans)
                {
                    ans=dat;
                }
            }
            else
            {
                if(dat>ans)
                {
                    ans=dat;
                }
                dat=val;
            }
        }
        return ans;
    }
}
"
2776,java,robot-return-to-origin,"class Solution {
    public boolean judgeCircle(String moves) {
        int point[] = {0,0};
        int move[][] = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        for (Character m: moves.toCharArray()) {
            int ind = 0;
            switch (m)
            {
                case 'U': {
                    ind = 0;
                    break;
                }
                case 'D': {
                    ind = 1;
                    break;
                }
                case 'L': {
                    ind = 2;
                    break;
                }
                case 'R': {
                    ind = 4;
                    break;
                }
            }
            point[0] += move[ind][0];
            point[1] += move[ind][1];
        }
        return point[0] == 0 && point[1] == 0;
    }
}",None,"class Solution {
    public boolean judgeCircle(String moves) {
        int point[] = {0,0};
        int move[][] = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        for (Character m: moves.toCharArray()) {
            int ind = 0;
            switch (m)
            {
                case 'U': {
                    ind = 0;
                    break;
                }
                case 'D': {
                    ind = 1;
                    break;
                }
                case 'L': {
                    ind = 2;
                    break;
                }
                case 'R': {
                    ind = 3;
                    break;
                }
            }
            point[0] += move[ind][0];
            point[1] += move[ind][1];
        }
        return point[0] == 0 && point[1] == 0;
    }
}
"
2776,java,robot-return-to-origin,"class Solution {
    public boolean judgeCircle(String moves) {
        int point[] = {0,0};
        int move[][] = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        for (Character m: moves.toCharArray()) {
            int ind = 0;
            switch (m)
            {
                case 'U': {
                    ind = 0;
                    break;
                }
                case 'D': {
                    ind = 1;
                    break;
                }
                case 'L': {
                    ind = 2;
                    break;
                }
                case 'R': {
                    ind = 4;
                    break;
                }
            }
            point[0] += move[ind][0];
            point[1] += move[ind][1];
        }
        return point[0] == 0 && point[1] == 0;
    }
}",None,"class Solution {
    public boolean judgeCircle(String moves) {
        int point[] = {0,0};
        int move[][] = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        for (Character m: moves.toCharArray()) {
            int ind = 0;
            switch (m)
            {
                case 'U': {
                    ind = 0;
                    break;
                }
                case 'D': {
                    ind = 1;
                    break;
                }
                case 'L': {
                    ind = 2;
                    break;
                }
                case 'R': {
                    ind = 3;
                    break;
                }
            }
            point[0] += move[ind][0];
            point[1] += move[ind][1];
        }
        return point[0] == 0 && point[1] == 0;
    }
}
"
2776,java,robot-return-to-origin,"class Solution {
    public boolean judgeCircle(String moves) {
        int point[] = {0,0};
        int move[][] = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        for (Character m: moves.toCharArray()) {
            int ind = 0;
            switch (m)
            {
                case 'U': {
                    ind = 0;
                    break;
                }
                case 'D': {
                    ind = 1;
                    break;
                }
                case 'L': {
                    ind = 2;
                    break;
                }
                case 'R': {
                    ind = 4;
                    break;
                }
            }
            point[0] += move[ind][0];
            point[1] += move[ind][1];
        }
        return point[0] == 0 && point[1] == 0;
    }
}",None,"class Solution {
    public boolean judgeCircle(String moves) {
        int point[] = {0,0};
        int move[][] = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        for (Character m: moves.toCharArray()) {
            int ind = 0;
            switch (m)
            {
                case 'U': {
                    ind = 0;
                    break;
                }
                case 'D': {
                    ind = 1;
                    break;
                }
                case 'L': {
                    ind = 2;
                    break;
                }
                case 'R': {
                    ind = 3;
                    break;
                }
            }
            point[0] += move[ind][0];
            point[1] += move[ind][1];
        }
        return point[0] == 0 && point[1] == 0;
    }
}
"
2777,java,random-point-in-non-overlapping-rectangles,"class Solution {
    
    int[][] rects;
    TreeMap<Integer, Integer> weightedRectIndex = new TreeMap<>();
    int nPoints = 0;
    
    Random rng = new Random();

    public Solution(int[][] rects) {
        this.rects = rects;
        int index = 0;
        for (int[] rect : rects) {
            
            weightedRectIndex.put(nPoints++, index);
            nPoints += width(rect) * height(rect);
        }
    }

    public int[] pick() {
        
        int point = rng.nextInt(nPoints);
        
        var entry = weightedRectIndex.floorEntry(point);
        
        int rectPoint = point - entry.getKey();
        int[] rect = rects[entry.getValue()];
        return new int[]{
            rect[0] + rectPoint % width(rect), 
            rect[1] + rectPoint / width(rect)};
    }

    private int width(int[] rect) {
        return rect[2] - rect[0] + 1;
    }

    private int height(int[] rect) {
        return rect[3] - rect[1] + 1;
    }
}",None,"class Solution {
    
    int[][] rects;
    TreeMap<Integer, Integer> weightedRectIndex = new TreeMap<>();
    int nPoints = 0;
    
    Random rng = new Random();

    public Solution(int[][] rects) {
        this.rects = rects;
        int index = 0;
        for (int[] rect : rects) {
            
            int rectWidth = rect[2] - rect[0] + 1;
            int rectHeight = rect[3] - rect[1] + 1;
            int rectArea = rectWidth * rectHeight;
            for (int i = 0; i < rectArea; i++) {
                weightedRectIndex.put(nPoints++, index);
            }
            index++;
        }
    }

    public int[] pick() {
        
        int point = rng.nextInt(nPoints);
        
        var entry = weightedRectIndex.floorEntry(point);
        
        int rectPoint = point - entry.getKey();
        int[] rect = rects[entry.getValue()];
        int x = rect[0] + rectPoint % (rect[2] - rect[0] + 1);
        int y = rect[1] + rectPoint / (rect[2] - rect[0] + 1);
        return new int[]{x, y};
    }
}
"
2777,java,random-point-in-non-overlapping-rectangles,"class Solution {
    
    int[][] rects;
    TreeMap<Integer, Integer> weightedRectIndex = new TreeMap<>();
    int nPoints = 0;
    
    Random rng = new Random();

    public Solution(int[][] rects) {
        this.rects = rects;
        int index = 0;
        for (int[] rect : rects) {
            
            weightedRectIndex.put(nPoints++, index);
            nPoints += width(rect) * height(rect);
        }
    }

    public int[] pick() {
        
        int point = rng.nextInt(nPoints);
        
        var entry = weightedRectIndex.floorEntry(point);
        
        int rectPoint = point - entry.getKey();
        int[] rect = rects[entry.getValue()];
        return new int[]{
            rect[0] + rectPoint % width(rect), 
            rect[1] + rectPoint / width(rect)};
    }

    private int width(int[] rect) {
        return rect[2] - rect[0] + 1;
    }

    private int height(int[] rect) {
        return rect[3] - rect[1] + 1;
    }
}",None,"class Solution {
    
    int[][] rects;
    TreeMap<Integer, Integer> weightedRectIndex = new TreeMap<>();
    int nPoints = 0;
    
    Random rng = new Random();

    public Solution(int[][] rects) {
        this.rects = rects;
        int index = 0;
        for (int[] rect : rects) {
            
            weightedRectIndex.put(nPoints, index);
            nPoints += (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1);
            index++;
        }
    }

    public int[] pick() {
        
        int point = rng.nextInt(nPoints);
        
        int rectIndex = weightedRectIndex.floorKey(point);
        int rectPoint = point - weightedRectIndex.get(rectIndex);
        int[] rect = rects[rectIndex];
        return new int[]{
            rect[0] + rectPoint % (rect[2] - rect[0] + 1), 
            rect[1] + rectPoint / (rect[2] - rect[0] + 1)};
    }
}
"
2777,java,random-point-in-non-overlapping-rectangles,"class Solution {
    
    int[][] rects;
    TreeMap<Integer, Integer> weightedRectIndex = new TreeMap<>();
    int nPoints = 0;
    
    Random rng = new Random();

    public Solution(int[][] rects) {
        this.rects = rects;
        int index = 0;
        for (int[] rect : rects) {
            
            weightedRectIndex.put(nPoints++, index);
            nPoints += width(rect) * height(rect);
        }
    }

    public int[] pick() {
        
        int point = rng.nextInt(nPoints);
        
        var entry = weightedRectIndex.floorEntry(point);
        
        int rectPoint = point - entry.getKey();
        int[] rect = rects[entry.getValue()];
        return new int[]{
            rect[0] + rectPoint % width(rect), 
            rect[1] + rectPoint / width(rect)};
    }

    private int width(int[] rect) {
        return rect[2] - rect[0] + 1;
    }

    private int height(int[] rect) {
        return rect[3] - rect[1] + 1;
    }
}",None,"class Solution {
    
    int[][] rects;
    TreeMap<Integer, Integer> weightedRectIndex = new TreeMap<>();
    int nPoints = 0;
    
    Random rng = new Random();

    public Solution(int[][] rects) {
        this.rects = rects;
        int index = 0;
        for (int[] rect : rects) {
            
            weightedRectIndex.put(nPoints, index);
            nPoints += (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1);
            index++;
        }
    }

    public int[] pick() {
        
        int point = rng.nextInt(nPoints);
        
        int rectIndex = weightedRectIndex.floorKey(point);
        int rectPoint = point - weightedRectIndex.get(rectIndex);
        int[] rect = rects[rectIndex];
        return new int[]{
            rect[0] + rectPoint % (rect[2] - rect[0] + 1), 
            rect[1] + rectPoint / (rect[2] - rect[0] + 1)};
    }
}
"
2778,java,daily-temperatures,"class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        
        int[] arr = new int[temperatures.length]; 
        
        ArrayDeque<int[]> st = new ArrayDeque<>(); 
        
        int i=0, j=temperatures.length ; 
        
        while( j >= 0){
            
            if(st.size()==0){
                arr[i++] = 0;
            }
            else  if (st.size()>0 && st.peek()[0]>temperatures[j])
            {
                arr[i++]=1;
            } 
            else if (st.size()>0 && st.peek()[0]<=temperatures[j])
            
            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){
                    st.pop();
                    
                }
            if(st.size()==0){
                arr[i++]=0;
            }
            else{
                arr[i++]=st.peek()[1]-j;
            }
            } 
        st.push(new int[]{temperatures[j],j}); 
        j--;
        }
        
      
        int[] ans = new int[temperatures.length]; int k=0;
        for(i=arr.length-1; i>=0; i--){
            ans[k++]=arr[i];
        }
        return ans;
    }
}",None,"class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        
        int[] arr = new int[temperatures.length]; 
        
        ArrayDeque<int[]> st = new ArrayDeque<>(); 
        
        int i=0, j=temperatures.length-1 ; 
        
        while( j >= 0){
            
            if(st.size()==0){
                arr[i++] = 0;
            }
            else  if (st.peek()[0]>temperatures[j])
            {
                arr[i++]=1;
            } 
            else if (st.peek()[0]<=temperatures[j])
            
            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){
                    st.pop();
                    
                }
            if(st.size()==0){
                arr[i++]=0;
            }
            else{
                arr[i++]=st.peek()[1]-j;
            }
            } 
        st.push(new int[]{temperatures[j],j}); 
        j--;
        }
        
      
        int[] ans = new int[temperatures.length]; int k=0;
        for(i=arr.length-1; i>=0; i--){
            ans[k++]=arr[i];
        }
        return ans;
    }
}
"
2778,java,daily-temperatures,"class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        
        int[] arr = new int[temperatures.length]; 
        
        ArrayDeque<int[]> st = new ArrayDeque<>(); 
        
        int i=0, j=temperatures.length ; 
        
        while( j >= 0){
            
            if(st.size()==0){
                arr[i++] = 0;
            }
            else  if (st.size()>0 && st.peek()[0]>temperatures[j])
            {
                arr[i++]=1;
            } 
            else if (st.size()>0 && st.peek()[0]<=temperatures[j])
            
            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){
                    st.pop();
                    
                }
            if(st.size()==0){
                arr[i++]=0;
            }
            else{
                arr[i++]=st.peek()[1]-j;
            }
            } 
        st.push(new int[]{temperatures[j],j}); 
        j--;
        }
        
      
        int[] ans = new int[temperatures.length]; int k=0;
        for(i=arr.length-1; i>=0; i--){
            ans[k++]=arr[i];
        }
        return ans;
    }
}",None,"class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        
        int[] arr = new int[temperatures.length]; 
        
        ArrayDeque<int[]> st = new ArrayDeque<>(); 
        
        int i=0, j=temperatures.length-1 ; 
        
        while( j >= 0){
            
            if(st.size()==0){
                arr[i++] = 0;
            }
            else  if (st.peek()[0]>temperatures[j])
            {
                arr[i++]=1;
            } 
            else if (st.peek()[0]<=temperatures[j])
            
            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){
                    st.pop();
                    
                }
            if(st.size()==0){
                arr[i++]=0;
            }
            else{
                arr[i++]=st.peek()[1]-j;
            }
            } 
        st.push(new int[]{temperatures[j],j}); 
        j--;
        }
        
      
        int[] ans = new int[temperatures.length]; int k=0;
        for(i=arr.length-1; i>=0; i--){
            ans[k++]=arr[i];
        }
        return ans;
    }
}
"
2778,java,daily-temperatures,"class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        
        int[] arr = new int[temperatures.length]; 
        
        ArrayDeque<int[]> st = new ArrayDeque<>(); 
        
        int i=0, j=temperatures.length ; 
        
        while( j >= 0){
            
            if(st.size()==0){
                arr[i++] = 0;
            }
            else  if (st.size()>0 && st.peek()[0]>temperatures[j])
            {
                arr[i++]=1;
            } 
            else if (st.size()>0 && st.peek()[0]<=temperatures[j])
            
            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){
                    st.pop();
                    
                }
            if(st.size()==0){
                arr[i++]=0;
            }
            else{
                arr[i++]=st.peek()[1]-j;
            }
            } 
        st.push(new int[]{temperatures[j],j}); 
        j--;
        }
        
      
        int[] ans = new int[temperatures.length]; int k=0;
        for(i=arr.length-1; i>=0; i--){
            ans[k++]=arr[i];
        }
        return ans;
    }
}",None,"class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int[] arr = new int[temperatures.length]; 
        ArrayDeque<int[]> st = new ArrayDeque<>(); 
        int i=0, j=temperatures.length - 1 ; 
        while( j >= 0){
            if(st.size()==0){
                arr[j] = 0;
            }
            else  if (st.peek()[0]>temperatures[j])
            {
                arr[j]=1;
            } 
            else if (st.size()>0 && st.peek()[0]<=temperatures[j])
            {
                while(st.size()>0 && st.peek()[0]<=temperatures[j]){
                    st.pop();
                }
                if(st.size()==0){
                    arr[j]=0;
                }
                else{
                    arr[j]=st.peek()[1]-j;
                }
            } 
            st.push(new int[]{temperatures[j],j}); 
            j--;
        }
      
       return arr;
    }
}
"
2779,java,number-of-laser-beams-in-a-bank,"class Solution {
    public int numberOfBeams(String[] bank) {
        int prevLazer =0;
        int ans =0;
        for(String s:bank){
            int curLazer = 0;
            for(char c: s.toCharArray()){
                if(c=='1'){
                    curLazer++;
                }
            }
            if(curLazer >0){
                ans += (curLazer * prevLazer);
                prevLazer = curLazer;
            } else {
                prevLazer = 0;
            }
        }
        return ans;
    }
}",None,"class Solution {
    public int numberOfBeams(String[] bank) {
        int prevLazer =0;
        int ans =0;
        for(String s:bank){
            int curLazer = 0;
            for(char c: s.toCharArray()){
                if(c=='1'){
                    curLazer++;
                }
            }
            if(curLazer >0){
                ans += (curLazer * prevLazer);
                prevLazer = curLazer;
            } else {
                prevLazer = 0;
            }
        }
        return ans;
    }
}
"
2779,java,number-of-laser-beams-in-a-bank,"class Solution {
    public int numberOfBeams(String[] bank) {
        int prevLazer =0;
        int ans =0;
        for(String s:bank){
            int curLazer = 0;
            for(char c: s.toCharArray()){
                if(c=='1'){
                    curLazer++;
                }
            }
            if(curLazer >0){
                ans += (curLazer * prevLazer);
                prevLazer = curLazer;
            } else {
                prevLazer = 0;
            }
        }
        return ans;
    }
}",None,"class Solution {
    public int numberOfBeams(String[] bank) {
        int prevLazer =0;
        int ans =0;
        for(String s:bank){
            int curLazer = 0;
            for(char c: s.toCharArray()){
                if(c=='1'){
                    curLazer++;
                }
            }
            if(curLazer >0){
                ans += (curLazer * prevLazer);
                prevLazer = curLazer;
            } else {
                prevLazer = 0;
            }
        }
        return ans;
    }
}
"
2779,java,number-of-laser-beams-in-a-bank,"class Solution {
    public int numberOfBeams(String[] bank) {
        int prevLazer =0;
        int ans =0;
        for(String s:bank){
            int curLazer = 0;
            for(char c: s.toCharArray()){
                if(c=='1'){
                    curLazer++;
                }
            }
            if(curLazer >0){
                ans += (curLazer * prevLazer);
                prevLazer = curLazer;
            } else {
                prevLazer = 0;
            }
        }
        return ans;
    }
}",None,"class Solution {
    public int numberOfBeams(String[] bank) {
        int prevLazer =0;
        int ans =0;
        for(String s:bank){
            int curLazer = 0;
            for(char c: s.toCharArray()){
                if(c=='1'){
                    curLazer++;
                }
            }
            if(curLazer >0){
                ans += (curLazer * prevLazer);
                prevLazer = curLazer;
            } else {
                prevLazer = 0;
            }
        }
        return ans;
    }
}
"
2780,java,maximum-strength-of-a-group,"class Solution {
    private long maxStrength;

    public long maxStrength(int[] nums) {
        maxStrength = 0; 
        helper(nums, 0, 1, 0);
        return maxStrength;
    }

    private void helper(int[] nums, int index, long product, int size) {
        if (index >= nums.length) {
            if(size != 0) maxStrength = Math.max(maxStrength, product);
            return;
        }

        helper(nums, index + 1, product * nums[index], size + 1);
        helper(nums, index + 1, product, size);
    }
}",None,"class Solution {
    private long maxStrength;

    public long maxStrength(int[] nums) {
        maxStrength = 0; 
        helper(nums, 0);
        return maxStrength;
    }

    private void helper(int[] nums, int index) {
        if (index >= nums.length) {
            return;
        }

        helper(nums, index + 1);
        maxStrength = Math.max(maxStrength, nums[index] * getProduct(nums, index + 1));
        helper(nums, index + 1);
    }

    private long getProduct(int[] nums, int start) {
        long product = 1;
        for (int i = start; i < nums.length; i++) {
            product *= nums[i];
        }
        return product;
    }
}
"
2780,java,maximum-strength-of-a-group,"class Solution {
    private long maxStrength;

    public long maxStrength(int[] nums) {
        maxStrength = 0; 
        helper(nums, 0, 1, 0);
        return maxStrength;
    }

    private void helper(int[] nums, int index, long product, int size) {
        if (index >= nums.length) {
            if(size != 0) maxStrength = Math.max(maxStrength, product);
            return;
        }

        helper(nums, index + 1, product * nums[index], size + 1);
        helper(nums, index + 1, product, size);
    }
}",None,"class Solution {
    private long maxStrength;

    public long maxStrength(int[] nums) {
        maxStrength = 0; 
        helper(nums, 0);
        return maxStrength;
    }

    private void helper(int[] nums, int index) {
        if (index >= nums.length) {
            return;
        }

        helper(nums, index + 1);
        maxStrength = Math.max(maxStrength, nums[index] * product(nums, index + 1));
        helper(nums, index + 1);
    }

    private long product(int[] nums, int index) {
        if (index >= nums.length) {
            return 1;
        }
        return nums[index] * product(nums, index + 1);
    }
}
"
2780,java,maximum-strength-of-a-group,"class Solution {
    private long maxStrength;

    public long maxStrength(int[] nums) {
        maxStrength = 0; 
        helper(nums, 0, 1, 0);
        return maxStrength;
    }

    private void helper(int[] nums, int index, long product, int size) {
        if (index >= nums.length) {
            if(size != 0) maxStrength = Math.max(maxStrength, product);
            return;
        }

        helper(nums, index + 1, product * nums[index], size + 1);
        helper(nums, index + 1, product, size);
    }
}",None,"class Solution {
    private long maxStrength;

    public long maxStrength(int[] nums) {
        maxStrength = 0; 
        helper(nums, 0, 1);
        return maxStrength;
    }

    private void helper(int[] nums, int index, int size) {
        if (index >= nums.length) {
            if(size != 0) maxStrength = Math.max(maxStrength, (long)Math.pow(nums[index-size], size));
            return;
        }

        helper(nums, index + 1, size + 1);
        helper(nums, index + 1, size);
    }
}
"
2781,java,spiral-matrix-iv,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:
        mat=[[-1 for i in range(n)] for i in range(m)]
        temp=head
        d=1
        rowi,colj=0,0
        while temp!=None:
            mat[rowi][colj]=temp.val
            if d==1:
                if colj+1<n and mat[rowi][colj+1]==-1:
                    colj+=1
                    d=2 # Bug is here
                elif rowi+1<m and mat[rowi+1][colj]==-1:
                    rowi+=1
                    d=2
            elif d==2:
                if rowi+1<m and mat[rowi+1][colj]==-1:
                    rowi+=1
                    d=2
                elif colj-1>=0 and mat[rowi][colj-1]==-1:
                    colj-=1
                    d=3
            elif d==3:
                if colj-1>=0 and mat[rowi][colj-1]==-1:
                    colj-=1
                    d=3
                elif rowi-1>=0 and mat[rowi-1][colj]==-1:
                    rowi-=1
                    d=4
            elif d==4:
                if rowi-1>=0 and mat[rowi-1][colj]==-1:
                    rowi-=1
                    d=4
                elif colj+1<n and mat[rowi][colj+1]==-1:
                    colj+=1
                    d=1
            temp=temp.next
        return mat",None,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:
        mat=[[-1 for i in range(n)] for i in range(m)]
        temp=head
        d=1
        rowi,colj=0,0
        while temp!=None:
            mat[rowi][colj]=temp.val
            if d==1:
                if colj+1<n and mat[rowi][colj+1]==-1:
                    colj+=1
                elif rowi+1<m and mat[rowi+1][colj]==-1:
                    rowi+=1
                    d=2
            elif d==2:
                if rowi+1<m and mat[rowi+1][colj]==-1:
                    rowi+=1
                elif colj-1>=0 and mat[rowi][colj-1]==-1:
                    colj-=1
                    d=3
            elif d==3:
                if colj-1>=0 and mat[rowi][colj-1]==-1:
                    colj-=1
                elif rowi-1>=0 and mat[rowi-1][colj]==-1:
                    rowi-=1
                    d=4
            elif d==4:
                if rowi-1>=0 and mat[rowi-1][colj]==-1:
                    rowi-=1
                elif colj+1<n and mat[rowi][colj+1]==-1:
                    colj+=1
                    d=1
            temp=temp.next
        return mat
"
2781,java,spiral-matrix-iv,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:
        mat=[[-1 for i in range(n)] for i in range(m)]
        temp=head
        d=1
        rowi,colj=0,0
        while temp!=None:
            mat[rowi][colj]=temp.val
            if d==1:
                if colj+1<n and mat[rowi][colj+1]==-1:
                    colj+=1
                    d=2 # Bug is here
                elif rowi+1<m and mat[rowi+1][colj]==-1:
                    rowi+=1
                    d=2
            elif d==2:
                if rowi+1<m and mat[rowi+1][colj]==-1:
                    rowi+=1
                    d=2
                elif colj-1>=0 and mat[rowi][colj-1]==-1:
                    colj-=1
                    d=3
            elif d==3:
                if colj-1>=0 and mat[rowi][colj-1]==-1:
                    colj-=1
                    d=3
                elif rowi-1>=0 and mat[rowi-1][colj]==-1:
                    rowi-=1
                    d=4
            elif d==4:
                if rowi-1>=0 and mat[rowi-1][colj]==-1:
                    rowi-=1
                    d=4
                elif colj+1<n and mat[rowi][colj+1]==-1:
                    colj+=1
                    d=1
            temp=temp.next
        return mat",None,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:
        mat=[[-1 for i in range(n)] for i in range(m)]
        temp=head
        d=1
        rowi,colj=0,0
        while temp!=None:
            mat[rowi][colj]=temp.val
            if d==1:
                if colj+1<n and mat[rowi][colj+1]==-1:
                    colj+=1
                elif rowi+1<m and mat[rowi+1][colj]==-1:
                    rowi+=1
                else:
                    d=2
            elif d==2:
                if rowi+1<m and mat[rowi+1][colj]==-1:
                    rowi+=1
                elif colj-1>=0 and mat[rowi][colj-1]==-1:
                    colj-=1
                else:
                    d=3
            elif d==3:
                if colj-1>=0 and mat[rowi][colj-1]==-1:
                    colj-=1
                elif rowi-1>=0 and mat[rowi-1][colj]==-1:
                    rowi-=1
                else:
                    d=4
            elif d==4:
                if rowi-1>=0 and mat[rowi-1][colj]==-1:
                    rowi-=1
                elif colj+1<n and mat[rowi][colj+1]==-1:
                    colj+=1
                else:
                    d=1
            temp=temp.next
        return mat
"
2781,java,spiral-matrix-iv,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:
        mat=[[-1 for i in range(n)] for i in range(m)]
        temp=head
        d=1
        rowi,colj=0,0
        while temp!=None:
            mat[rowi][colj]=temp.val
            if d==1:
                if colj+1<n and mat[rowi][colj+1]==-1:
                    colj+=1
                    d=2 # Bug is here
                elif rowi+1<m and mat[rowi+1][colj]==-1:
                    rowi+=1
                    d=2
            elif d==2:
                if rowi+1<m and mat[rowi+1][colj]==-1:
                    rowi+=1
                    d=2
                elif colj-1>=0 and mat[rowi][colj-1]==-1:
                    colj-=1
                    d=3
            elif d==3:
                if colj-1>=0 and mat[rowi][colj-1]==-1:
                    colj-=1
                    d=3
                elif rowi-1>=0 and mat[rowi-1][colj]==-1:
                    rowi-=1
                    d=4
            elif d==4:
                if rowi-1>=0 and mat[rowi-1][colj]==-1:
                    rowi-=1
                    d=4
                elif colj+1<n and mat[rowi][colj+1]==-1:
                    colj+=1
                    d=1
            temp=temp.next
        return mat",None,"class Solution:
    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:
        mat=[[-1 for i in range(n)] for i in range(m)]
        temp=head
        d=1
        rowi,colj=0,0
        while temp!=None:
            mat[rowi][colj]=temp.val
            if d==1:
                if colj+1<n and mat[rowi][colj+1]==-1:
                    colj+=1
                elif rowi+1<m and mat[rowi+1][colj]==-1:
                    rowi+=1
                else:
                    d=2
            elif d==2:
                if rowi+1<m and mat[rowi+1][colj]==-1:
                    rowi+=1
                elif colj-1>=0 and mat[rowi][colj-1]==-1:
                    colj-=1
                else:
                    d=3
            elif d==3:
                if colj-1>=0 and mat[rowi][colj-1]==-1:
                    colj-=1
                elif rowi-1>=0 and mat[rowi-1][colj]==-1:
                    rowi-=1
                else:
                    d=4
            elif d==4:
                if rowi-1>=0 and mat[rowi-1][colj]==-1:
                    rowi-=1
                elif colj+1<n and mat[rowi][colj+1]==-1:
                    colj+=1
                else:
                    d=1
            temp=temp.next
        return mat
"
2782,java,maximum-number-of-balloons,"class Solution {
    public int maxNumberOfBalloons(String text) {
        final int[][] cache = new int[2][5];
        cache[0][0] = 97;
        cache[0][1] = 99;  
        cache[0][2] = 108;
        cache[0][3] = 110;
        cache[0][4] = 111;
        
        for (char ch : text.toCharArray()) {
            final int intValue = ch;
            for (int i = 0; i < 5; i++) {
                if (intValue == cache[0][i]) {
                    cache[1][i]++;
                    break;
                }
            }
        }

        cache[1][2] /= 2;
        cache[1][4] /= 2;

        int min = Integer.MAX_VALUE;
        for (int frequency: cache[1]) {
            min = Math.min(min, frequency);
        }

        return min;
    }
}",None,"class Solution {
    public int maxNumberOfBalloons(String text) {
        final int[] cache = new int[5];
        cache[0] = text.length() - text.replace(""b"", """").length();
        cache[1] = text.length() - text.replace(""a"", """").length();
        cache[2] = (text.length() - text.replace(""l"", """").length()) / 2;
        cache[3] = (text.length() - text.replace(""o"", """").length()) / 2;
        cache[4] = text.length() - text.replace(""n"", """").length();

        int min = Integer.MAX_VALUE;
        for (int freq: cache) {
            min = Math.min(min, freq);
        }

        return min;
    }
}
"
2782,java,maximum-number-of-balloons,"class Solution {
    public int maxNumberOfBalloons(String text) {
        final int[][] cache = new int[2][5];
        cache[0][0] = 97;
        cache[0][1] = 99;  
        cache[0][2] = 108;
        cache[0][3] = 110;
        cache[0][4] = 111;
        
        for (char ch : text.toCharArray()) {
            final int intValue = ch;
            for (int i = 0; i < 5; i++) {
                if (intValue == cache[0][i]) {
                    cache[1][i]++;
                    break;
                }
            }
        }

        cache[1][2] /= 2;
        cache[1][4] /= 2;

        int min = Integer.MAX_VALUE;
        for (int frequency: cache[1]) {
            min = Math.min(min, frequency);
        }

        return min;
    }
}",None,"class Solution {
    public int maxNumberOfBalloons(String text) {
        final int[] cache = new int[5];
        cache[0] = text.length() - text.replace(""b"", """").length();
        cache[1] = text.length() - text.replace(""a"", """").length();
        cache[2] = (text.length() - text.replace(""l"", """").length()) / 2;
        cache[3] = (text.length() - text.replace(""o"", """").length()) / 2;
        cache[4] = Math.min(cache[0], Math.min(cache[2], Math.min(cache[3], cache[1])));
        return cache[4];
    }
}
"
2782,java,maximum-number-of-balloons,"class Solution {
    public int maxNumberOfBalloons(String text) {
        final int[][] cache = new int[2][5];
        cache[0][0] = 97;
        cache[0][1] = 99;  
        cache[0][2] = 108;
        cache[0][3] = 110;
        cache[0][4] = 111;
        
        for (char ch : text.toCharArray()) {
            final int intValue = ch;
            for (int i = 0; i < 5; i++) {
                if (intValue == cache[0][i]) {
                    cache[1][i]++;
                    break;
                }
            }
        }

        cache[1][2] /= 2;
        cache[1][4] /= 2;

        int min = Integer.MAX_VALUE;
        for (int frequency: cache[1]) {
            min = Math.min(min, frequency);
        }

        return min;
    }
}",None,"class Solution {
    public int maxNumberOfBalloons(String text) {
        final int[] cache = new int[5];
        cache[0] = text.length() - text.replace(""b"", """").length();
        cache[1] = text.length() - text.replace(""a"", """").length();
        cache[2] = (text.length() - text.replace(""l"", """").length()) / 2;
        cache[3] = (text.length() - text.replace(""o"", """").length()) / 2;
        cache[4] = text.length() - text.replace(""n"", """").length();

        int min = Integer.MAX_VALUE;
        for (int freq : cache) {
            min = Math.min(min, freq);
        }

        return min;
    }
}
"
2783,java,convert-sorted-array-to-binary-search-tree,"class Solution {
    public TreeNode createBST(int arr[], int st, int end){
        if(st>end){
            return null;
        }

        int mid = (st+end)/2+1;
        TreeNode root = new TreeNode(arr[mid]);
        root.left = createBST(arr,st,mid-1);
        root.right = createBST(arr,mid+1,end);

        return root;
    }
    public TreeNode sortedArrayToBST(int[] nums) {
        int st = 0;
        int end = nums.length-1;
        return createBST(nums,st,end);
    }
}",None,"class Solution {
    public TreeNode createBST(int arr[], int st, int end){
        if(st>end){
            return null;
        }

        int mid = (st+end)/2;
        TreeNode root = new TreeNode(arr[mid]);
        root.left = createBST(arr,st,mid-1);
        root.right = createBST(arr,mid+1,end);

        return root;
    }
    public TreeNode sortedArrayToBST(int[] nums) {
        int st = 0;
        int end = nums.length-1;
        return createBST(nums,st,end);
    }
}
"
2783,java,convert-sorted-array-to-binary-search-tree,"class Solution {
    public TreeNode createBST(int arr[], int st, int end){
        if(st>end){
            return null;
        }

        int mid = (st+end)/2+1;
        TreeNode root = new TreeNode(arr[mid]);
        root.left = createBST(arr,st,mid-1);
        root.right = createBST(arr,mid+1,end);

        return root;
    }
    public TreeNode sortedArrayToBST(int[] nums) {
        int st = 0;
        int end = nums.length-1;
        return createBST(nums,st,end);
    }
}",None,"class Solution {
    public TreeNode createBST(int arr[], int st, int end){
        if(st>end){
            return null;
        }

        int mid = (st+end)/2;
        TreeNode root = new TreeNode(arr[mid]);
        root.left = createBST(arr,st,mid-1);
        root.right = createBST(arr,mid+1,end);

        return root;
    }
    public TreeNode sortedArrayToBST(int[] nums) {
        int st = 0;
        int end = nums.length-1;
        return createBST(nums,st,end);
    }
}
"
2783,java,convert-sorted-array-to-binary-search-tree,"class Solution {
    public TreeNode createBST(int arr[], int st, int end){
        if(st>end){
            return null;
        }

        int mid = (st+end)/2+1;
        TreeNode root = new TreeNode(arr[mid]);
        root.left = createBST(arr,st,mid-1);
        root.right = createBST(arr,mid+1,end);

        return root;
    }
    public TreeNode sortedArrayToBST(int[] nums) {
        int st = 0;
        int end = nums.length-1;
        return createBST(nums,st,end);
    }
}",None,"class Solution {
    public TreeNode createBST(int arr[], int st, int end){
        if(st>end){
            return null;
        }

        int mid = (st+end)/2;
        TreeNode root = new TreeNode(arr[mid]);
        root.left = createBST(arr,st,mid-1);
        root.right = createBST(arr,mid+1,end);

        return root;
    }
    public TreeNode sortedArrayToBST(int[] nums) {
        int st = 0;
        int end = nums.length-1;
        return createBST(nums,st,end);
    }
}
"
2784,java,intersection-of-two-linked-lists,"public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {

        ListNode a = headA;
        ListNode b = headB;

        while(a != b) {
            a = a==null ? headB : a.next;
            b = b==null ? headA : a.next;
        }
        return a;
    }
}",None,"public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {

        ListNode a = headA;
        ListNode b = headB;

        while(a != b) {
            a = a==null ? headB : a.next;
            b = b==null ? headA : b.next;
        }
        return a;
    }
}
"
2784,java,intersection-of-two-linked-lists,"public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {

        ListNode a = headA;
        ListNode b = headB;

        while(a != b) {
            a = a==null ? headB : a.next;
            b = b==null ? headA : a.next;
        }
        return a;
    }
}",None,"public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {

        ListNode a = headA;
        ListNode b = headB;

        while(a != b) {
            a = a==null ? headB : a.next;
            b = b==null ? headA : b.next;
        }
        return a;
    }
}
"
2784,java,intersection-of-two-linked-lists,"public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {

        ListNode a = headA;
        ListNode b = headB;

        while(a != b) {
            a = a==null ? headB : a.next;
            b = b==null ? headA : a.next;
        }
        return a;
    }
}",None,"public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {

        ListNode a = headA;
        ListNode b = headB;

        while(a != b) {
            a = a==null ? headB : a.next;
            b = b==null ? headA : b.next;
        }
        return a;
    }
}
"
2785,java,make-array-strictly-increasing,"class Solution {
    
    HashMap<Integer, Integer> dp[];
    TreeSet<Integer> ts;
    
    int makeArrayIncr(int i, int prev, int[] arr1) {
        
        if(i == arr1.length) return 0;

        if(dp[i].containsKey(prev)) return dp[i].get(prev);

        int notswap = 5000;

        if(arr1[i] > prev) notswap = makeArrayIncr(i + 1, arr1[i], arr1);

        int swap = 5000;

        Integer curr = ts.higher(prev);

        if(curr != null) swap = 1 + makeArrayIncr(i, curr, arr1);

        dp[i].put(prev, Math.min(swap, notswap));

        return Math.min(swap, notswap);
        
    }
    
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        
        ts = new TreeSet<>();
        for(int i : arr2) ts.add(i);
        
        dp = new HashMap[arr1.length];
        for(int i = 0; i < dp.length; i++) dp[i] = new HashMap<>();
        
        int ans = makeArrayIncr(0, Integer.MIN_VALUE, arr1);
        
        return ans < 5000 ? ans : -1; 
    }
}",None,"class Solution {
    
    HashMap<Integer, Integer> dp[];
    TreeSet<Integer> ts;
    
    int makeArrayIncr(int i, int prev, int[] arr1) {
        
        if(i == arr1.length) return 0;

        if(dp[i].containsKey(prev)) return dp[i].get(prev);

        int notswap = Integer.MAX_VALUE;

        if(arr1[i] > prev) notswap = makeArrayIncr(i + 1, arr1[i], arr1);

        int swap = Integer.MAX_VALUE;

        Integer curr = ts.higher(prev);

        if(curr != null) swap = 1 + makeArrayIncr(i, curr, arr1);

        dp[i].put(prev, Math.min(swap, notswap));

        return Math.min(swap, notswap);
        
    }
    
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        
        ts = new TreeSet<>();
        for(int i : arr2) ts.add(i);
        
        dp = new HashMap[arr1.length];
        for(int i = 0; i < dp.length; i++) dp[i] = new HashMap<>();
        
        int ans = makeArrayIncr(0, Integer.MIN_VALUE, arr1);
        
        return ans < Integer.MAX_VALUE ? ans : -1; 
    }
}
"
2785,java,make-array-strictly-increasing,"class Solution {
    
    HashMap<Integer, Integer> dp[];
    TreeSet<Integer> ts;
    
    int makeArrayIncr(int i, int prev, int[] arr1) {
        
        if(i == arr1.length) return 0;

        if(dp[i].containsKey(prev)) return dp[i].get(prev);

        int notswap = 5000;

        if(arr1[i] > prev) notswap = makeArrayIncr(i + 1, arr1[i], arr1);

        int swap = 5000;

        Integer curr = ts.higher(prev);

        if(curr != null) swap = 1 + makeArrayIncr(i, curr, arr1);

        dp[i].put(prev, Math.min(swap, notswap));

        return Math.min(swap, notswap);
        
    }
    
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        
        ts = new TreeSet<>();
        for(int i : arr2) ts.add(i);
        
        dp = new HashMap[arr1.length];
        for(int i = 0; i < dp.length; i++) dp[i] = new HashMap<>();
        
        int ans = makeArrayIncr(0, Integer.MIN_VALUE, arr1);
        
        return ans < 5000 ? ans : -1; 
    }
}",None,"class Solution {
    
    HashMap<Integer, Integer> dp[];
    TreeSet<Integer> ts;
    
    int makeArrayIncr(int i, int prev, int[] arr1) {
        
        if(i == arr1.length) return 0;

        if(dp[i].containsKey(prev)) return dp[i].get(prev);

        int notswap = Integer.MAX_VALUE;

        if(arr1[i] > prev) notswap = makeArrayIncr(i + 1, arr1[i], arr1);

        int swap = Integer.MAX_VALUE;

        Integer curr = ts.higher(prev);

        if(curr != null) swap = 1 + makeArrayIncr(i, curr, arr1);

        dp[i].put(prev, Math.min(swap, notswap));

        return Math.min(swap, notswap);
        
    }
    
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        
        ts = new TreeSet<>();
        for(int i : arr2) ts.add(i);
        
        dp = new HashMap[arr1.length];
        for(int i = 0; i < dp.length; i++) dp[i] = new HashMap<>();
        
        int ans = makeArrayIncr(0, Integer.MIN_VALUE, arr1);
        
        return ans < Integer.MAX_VALUE ? ans : -1; 
    }
}
"
2785,java,make-array-strictly-increasing,"class Solution {
    
    HashMap<Integer, Integer> dp[];
    TreeSet<Integer> ts;
    
    int makeArrayIncr(int i, int prev, int[] arr1) {
        
        if(i == arr1.length) return 0;

        if(dp[i].containsKey(prev)) return dp[i].get(prev);

        int notswap = 5000;

        if(arr1[i] > prev) notswap = makeArrayIncr(i + 1, arr1[i], arr1);

        int swap = 5000;

        Integer curr = ts.higher(prev);

        if(curr != null) swap = 1 + makeArrayIncr(i, curr, arr1);

        dp[i].put(prev, Math.min(swap, notswap));

        return Math.min(swap, notswap);
        
    }
    
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        
        ts = new TreeSet<>();
        for(int i : arr2) ts.add(i);
        
        dp = new HashMap[arr1.length];
        for(int i = 0; i < dp.length; i++) dp[i] = new HashMap<>();
        
        int ans = makeArrayIncr(0, Integer.MIN_VALUE, arr1);
        
        return ans < 5000 ? ans : -1; 
    }
}",None,"class Solution {
    
    HashMap<Integer, Integer> dp[];
    TreeSet<Integer> ts;
    
    int makeArrayIncr(int i, int prev, int[] arr1) {
        
        if(i == arr1.length) return 0;

        if(dp[i].containsKey(prev)) return dp[i].get(prev);

        int notswap = Integer.MAX_VALUE;

        if(arr1[i] > prev) notswap = makeArrayIncr(i + 1, arr1[i], arr1);

        int swap = Integer.MAX_VALUE;

        Integer curr = ts.higher(prev);

        if(curr != null) swap = 1 + makeArrayIncr(i, curr, arr1);

        dp[i].put(prev, Math.min(swap, notswap));

        return Math.min(swap, notswap);
        
    }
    
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        
        ts = new TreeSet<>();
        for(int i : arr2) ts.add(i);
        
        dp = new HashMap[arr1.length];
        for(int i = 0; i < dp.length; i++) dp[i] = new HashMap<>();
        
        int ans = makeArrayIncr(0, Integer.MIN_VALUE, arr1);
        
        return ans < Integer.MAX_VALUE ? ans : -1; 
    }
}
"
2786,java,count-items-matching-a-rule,"class Solution {
    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {
        int count = 0;

        String type = ""type"";
        int i = 0;

        if (ruleKey.equals(type)) {
            i = 2;  
        }
        String color = ""color"";
        if (ruleKey.equals(color)) {
            i = 1;
        }
        String name = ""name"";
        if (ruleKey.equals(name)) {
            i = 2;
        }

        for (int j = 0; j < items.size(); j++) {
            if (items.get(j).get(i).equals(ruleValue)) {
                count++;
            }
        }
        
        return count;
    }
}",None,"class Solution {
    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {
        int count = 0;

        int i = -1;
        if (ruleKey.equals(""type"")) {
            i = 0;
        } else if (ruleKey.equals(""color"")) {
            i = 1;
        } else if (ruleKey.equals(""name"")) {
            i = 2;
        }

        for (List<String> item : items) {
            if (item.get(i).equals(ruleValue)) {
                count++;
            }
        }

        return count;
    }
}
"
2786,java,count-items-matching-a-rule,"class Solution {
    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {
        int count = 0;

        String type = ""type"";
        int i = 0;

        if (ruleKey.equals(type)) {
            i = 2;  
        }
        String color = ""color"";
        if (ruleKey.equals(color)) {
            i = 1;
        }
        String name = ""name"";
        if (ruleKey.equals(name)) {
            i = 2;
        }

        for (int j = 0; j < items.size(); j++) {
            if (items.get(j).get(i).equals(ruleValue)) {
                count++;
            }
        }
        
        return count;
    }
}",None,"class Solution {
    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {
        int count = 0;

        int i = 0;
        if (ruleKey.equals(""type"")) {
            i = 0;  
        }
        else if (ruleKey.equals(""color"")) {
            i = 1;
        }
        else if (ruleKey.equals(""name"")) {
            i = 2;
        }

        for (List<String> item : items) {
            if (item.get(i).equals(ruleValue)) {
                count++;
            }
        }

        return count;
    }
}
"
2786,java,count-items-matching-a-rule,"class Solution {
    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {
        int count = 0;

        String type = ""type"";
        int i = 0;

        if (ruleKey.equals(type)) {
            i = 2;  
        }
        String color = ""color"";
        if (ruleKey.equals(color)) {
            i = 1;
        }
        String name = ""name"";
        if (ruleKey.equals(name)) {
            i = 2;
        }

        for (int j = 0; j < items.size(); j++) {
            if (items.get(j).get(i).equals(ruleValue)) {
                count++;
            }
        }
        
        return count;
    }
}",None,"class Solution {
    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {
        int count = 0;

        int i = -1;

        if (ruleKey.equals(""type"")) {
            i = 0;  
        }
        else if (ruleKey.equals(""color"")) {
            i = 1;
        }
        else if (ruleKey.equals(""name"")) {
            i = 2;
        }

        for (List<String> item : items) {
            if (item.get(i).equals(ruleValue)) {
                count++;
            }
        }
        
        return count;
    }
}
"
2884,python3,minimize-the-total-price-of-the-trips,"class Solution:
    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:
        g = [[] for _ in range(n)]
        for i, j in edges:
            g[i].append(j)
            g[j].append(i)
            
        freq = [0] * n
        level = [0] * n
        parent = [0] * n
        
        def dfs(i, l, p):
            level[i] = l
            parent[i] = p
            for j in g[i]:
                if j != p:
                    dfs(j, l + 1, i)
        
        def LCA(a, b):
            if level[a] > level[b]:
                a, b = b, a
            d = level[b] - level[a]
            while d:
                b = parent[b]
                d -= 1
            if a == b:
                return a
            while a != b:
                a = parent[a]
                b = parent[b]
            return a
        
        dfs(0, 0, -1)
        for i, j in trips:
            lca = LCA(i, j)
            path = []
            while i != lca:
                freq[i] += 2
                i = parent[i]
            freq[i] += 1
            while j != lca:
                freq[j] += 1
                j = parent[j]
        
        def dp(i, p):
            res0 = 0
            res1 = price[i] // 2 * freq[i]
            for j in g[i]:
                if j != p:
                    curr = dp(j, i)
                    res0 += max(curr)
                    res1 += curr[0]
            return [res0, res1]
        ans = 0
        for i in range(n):
            ans += freq[i] * price[i]
        return ans - max(dp(0, -1))",None,"class Solution:
    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:
        g = [[] for _ in range(n)]
        for i, j in edges:
            g[i].append(j)
            g[j].append(i)
        
        def dfs(i, l, p):
            level[i] = l
            parent[i] = p
            for j in g[i]:
                if j != p:
                    dfs(j, l + 1, i)

        def LCA(a, b):
            if level[a] > level[b]:
                a, b = b, a
            d = level[b] - level[a]
            while d:
                b = parent[b]
                d -= 1
            if a == b:
                return a
            while a != b:
                a = parent[a]
                b = parent[b]
            return a

        level = [0] * n
        parent = [0] * n
        dfs(0, 0, -1)

        def halve_prices(node, total_freq):
            if node == -1:
                return
            price[node] //= 2
            freq[node] = total_freq[node]
            for child in g[node]:
                if child != parent[node]:
                    halve_prices(child, freq)

        freq = [0] * n
        for i, j in trips:
            lca = LCA(i, j)
            path = []
            while i != lca:
                freq[i] += 1
                i = parent[i]
            freq[i] += 1
            while j != lca:
                freq[j] += 1
                j = parent[j]

        halve_prices(-1, freq)

        def dp(i, p):
            res0 = 0
            res1 = price[i] * freq[i]
            for j in g[i]:
                if j != p:
                    curr = dp(j, i)
                    res0 += max(curr)
                    res1 += curr[0]
            return [res0, res1]
        ans = 0
        for i in range(n):
            ans += price[i] * freq[i]
        return ans - max(dp(0, -1))
"
2884,python3,minimize-the-total-price-of-the-trips,"class Solution:
    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:
        g = [[] for _ in range(n)]
        for i, j in edges:
            g[i].append(j)
            g[j].append(i)
            
        freq = [0] * n
        level = [0] * n
        parent = [0] * n
        
        def dfs(i, l, p):
            level[i] = l
            parent[i] = p
            for j in g[i]:
                if j != p:
                    dfs(j, l + 1, i)
        
        def LCA(a, b):
            if level[a] > level[b]:
                a, b = b, a
            d = level[b] - level[a]
            while d:
                b = parent[b]
                d -= 1
            if a == b:
                return a
            while a != b:
                a = parent[a]
                b = parent[b]
            return a
        
        dfs(0, 0, -1)
        for i, j in trips:
            lca = LCA(i, j)
            path = []
            while i != lca:
                freq[i] += 2
                i = parent[i]
            freq[i] += 1
            while j != lca:
                freq[j] += 1
                j = parent[j]
        
        def dp(i, p):
            res0 = 0
            res1 = price[i] // 2 * freq[i]
            for j in g[i]:
                if j != p:
                    curr = dp(j, i)
                    res0 += max(curr)
                    res1 += curr[0]
            return [res0, res1]
        ans = 0
        for i in range(n):
            ans += freq[i] * price[i]
        return ans - max(dp(0, -1))",None,"class Solution:
    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:
        g = [[] for _ in range(n)]
        for i, j in edges:
            g[i].append(j)
            g[j].append(i)

        freq = [0] * n
        level = [0] * n
        parent = [0] * n

        def dfs(i, l, p):
            level[i] = l
            parent[i] = p
            for j in g[i]:
                if j != p:
                    dfs(j, l + 1, i)

        dfs(0, 0, -1)

        def LCA(a, b):
            if level[a] > level[b]:
                a, b = b, a
            d = level[b] - level[a]
            while d:
                b = parent[b]
                d -= 1
            if a == b:
                return a
            while a != b:
                a = parent[a]
                b = parent[b]
            return a

        for i, j in trips:
            lca = LCA(i, j)
            path = []
            while i != lca:
                freq[i] += 2
                i = parent[i]
            freq[i] += 1
            while j != lca:
                freq[j] += 1
                j = parent[j]

        def dp(i, p):
            res0 = 0
            res1 = price[i] // 2 * freq[i]
            for j in g[i]:
                if j != p:
                    curr = dp(j, i)
                    res0 += max(curr)
                    res1 += curr[0]
            return [res0, res1]

        ans = 0
        for i in range(n):
            ans += freq[i] * price[i]
        return ans - dp(0, -1)[0]
"
2884,python3,minimize-the-total-price-of-the-trips,"class Solution:
    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:
        g = [[] for _ in range(n)]
        for i, j in edges:
            g[i].append(j)
            g[j].append(i)
            
        freq = [0] * n
        level = [0] * n
        parent = [0] * n
        
        def dfs(i, l, p):
            level[i] = l
            parent[i] = p
            for j in g[i]:
                if j != p:
                    dfs(j, l + 1, i)
        
        def LCA(a, b):
            if level[a] > level[b]:
                a, b = b, a
            d = level[b] - level[a]
            while d:
                b = parent[b]
                d -= 1
            if a == b:
                return a
            while a != b:
                a = parent[a]
                b = parent[b]
            return a
        
        dfs(0, 0, -1)
        for i, j in trips:
            lca = LCA(i, j)
            path = []
            while i != lca:
                freq[i] += 2
                i = parent[i]
            freq[i] += 1
            while j != lca:
                freq[j] += 1
                j = parent[j]
        
        def dp(i, p):
            res0 = 0
            res1 = price[i] // 2 * freq[i]
            for j in g[i]:
                if j != p:
                    curr = dp(j, i)
                    res0 += max(curr)
                    res1 += curr[0]
            return [res0, res1]
        ans = 0
        for i in range(n):
            ans += freq[i] * price[i]
        return ans - max(dp(0, -1))",None,"class Solution:
    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:
        g = [[] for _ in range(n)]
        for i, j in edges:
            g[i].append(j)
            g[j].append(i)
        
        freq = [0] * n
        level = [0] * n
        parent = [0] * n
        
        def dfs(i, l, p):
            level[i] = l
            parent[i] = p
            for j in g[i]:
                if j != p:
                    dfs(j, l + 1, i)
        
        dfs(0, 0, -1)
        
        def LCA(a, b):
            if level[a] > level[b]:
                a, b = b, a
            d = level[b] - level[a]
            while d:
                b = parent[b]
                d -= 1
            if a == b:
                return a
            while a != b:
                a = parent[a]
                b = parent[b]
            return a
        
        for i, j in trips:
            lca = LCA(i, j)
            path = []
            while i != lca:
                freq[i] += 1
                path.append(i)
                i = parent[i]
            freq[i] += 1
            path.append(i)
            while j != lca:
                freq[j] += 1
                j = parent[j]
        
        def dp(i, p):
            res0 = 0
            res1 = price[i] * freq[i]
            for j in g[i]:
                if j != p:
                    curr = dp(j, i)
                    res0 += max(curr)
                    res1 += curr[0]
            return [res0, res1]
        ans = 0
        for i in range(n):
            ans += freq[i] * price[i]
        return ans - dp(0, -1)[0]
"
2885,python3,increasing-decreasing-string,"class Solution:
    def sortString(self, s: str) -> str:
        freq = {}
        letters = sorted(set(s))
        res = """"
        for i in s:
            if i in freq:
                freq[i]+=1
            else:
                freq[i] = 1
        while freq:
            for i in letters:
                if i in freq:
                    if freq[i]>0:
                        res+=i
                        freq[i]-=1
                    else:
                        del freq[i]
                    
            for i in letters[::-1]:
                if i  in freq:
                    if freq[i]>0:
                        res+=i
                        freq[i]-=1
                        
                        del freq[i]


        return res",None,"class Solution:
    def sortString(self, s: str) -> str:
        freq = {}
        letters = sorted(set(s))
        res = """"
        for i in s:
            if i in freq:
                freq[i]+=1
            else:
                freq[i] = 1
        while freq:
            for i in letters:
                if i in freq and freq[i] > 0:
                    res += i
                    freq[i] -= 1
                    if freq[i] == 0:
                        del freq[i]
            for i in letters[::-1]:
                if i in freq and freq[i] > 0:
                    res += i
                    freq[i] -= 1
                    if freq[i] == 0:
                        del freq[i]
        return res
"
2885,python3,increasing-decreasing-string,"class Solution:
    def sortString(self, s: str) -> str:
        freq = {}
        letters = sorted(set(s))
        res = """"
        for i in s:
            if i in freq:
                freq[i]+=1
            else:
                freq[i] = 1
        while freq:
            for i in letters:
                if i in freq:
                    if freq[i]>0:
                        res+=i
                        freq[i]-=1
                    else:
                        del freq[i]
                    
            for i in letters[::-1]:
                if i  in freq:
                    if freq[i]>0:
                        res+=i
                        freq[i]-=1
                        
                        del freq[i]


        return res",None,"class Solution:
    def sortString(self, s: str) -> str:
        freq = {}
        letters = sorted(set(s))
        res = """"
        for i in s:
            if i in freq:
                freq[i]+=1
            else:
                freq[i] = 1
        while freq:
            for i in letters:
                if i in freq and freq[i] > 0:
                    res += i
                    freq[i] -= 1
                    if freq[i] == 0:
                        del freq[i]
            for i in letters[::-1]:
                if i in freq and freq[i] > 0:
                    res += i
                    freq[i] -= 1
                    if freq[i] == 0:
                        del freq[i]
        return res
"
2885,python3,increasing-decreasing-string,"class Solution:
    def sortString(self, s: str) -> str:
        freq = {}
        letters = sorted(set(s))
        res = """"
        for i in s:
            if i in freq:
                freq[i]+=1
            else:
                freq[i] = 1
        while freq:
            for i in letters:
                if i in freq:
                    if freq[i]>0:
                        res+=i
                        freq[i]-=1
                    else:
                        del freq[i]
                    
            for i in letters[::-1]:
                if i  in freq:
                    if freq[i]>0:
                        res+=i
                        freq[i]-=1
                        
                        del freq[i]


        return res",None,"class Solution:
    def sortString(self, s: str) -> str:
        freq = {}
        letters = sorted(set(s))
        res = """"
        for i in s:
            if i in freq:
                freq[i]+=1
            else:
                freq[i] = 1
        while freq:
            for i in letters:
                if i in freq and freq[i] > 0:
                    res += i
                    freq[i] -= 1
                    if freq[i] == 0:
                        del freq[i]
            for i in letters[::-1]:
                if i in freq and freq[i] > 0:
                    res += i
                    freq[i] -= 1
                    if freq[i] == 0:
                        del freq[i]
        return res
"
2886,python3,binary-tree-inorder-traversal,"class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans=[]
        def inorder(root,ans):
            if not root:
                return None
            ans.append(root.val)
            inorder(root.left,ans)
            inorder(root.right,ans)
        inorder(root,ans)
        return ans",None,"class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans=[]
        def inorder(root):
            if not root:
                return
            inorder(root.left)
            ans.append(root.val)
            inorder(root.right)
        inorder(root)
        return ans
"
2886,python3,binary-tree-inorder-traversal,"class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans=[]
        def inorder(root,ans):
            if not root:
                return None
            ans.append(root.val)
            inorder(root.left,ans)
            inorder(root.right,ans)
        inorder(root,ans)
        return ans",None,"class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans=[]
        def inorder(root):
            if not root:
                return None
            inorder(root.left)
            ans.append(root.val)
            inorder(root.right)
        inorder(root)
        return ans
"
2886,python3,binary-tree-inorder-traversal,"class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans=[]
        def inorder(root,ans):
            if not root:
                return None
            ans.append(root.val)
            inorder(root.left,ans)
            inorder(root.right,ans)
        inorder(root,ans)
        return ans",None,"class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans=[]
        def inorder(root):
            if not root:
                return
            inorder(root.left)
            ans.append(root.val)
            inorder(root.right)
        inorder(root)
        return ans
"
2887,python3,minimum-time-to-complete-all-tasks,"class Solution:
    def findMinimumTime(self, tasks: List[List[int]]) -> int:
        tasks.sort(key=lambda x:x[1])
        on=[0]*2001
        for s,e,d in tasks:
            cr=sum(on[s:e+1])
            while cr<d:
                if on[e]!=1:on[e]=2; cr+=1
                e-=1
        return sum(on)",None,"class Solution:
    def findMinimumTime(self, tasks: List[List[int]]) -> int:
        tasks.sort(key=lambda x:(x[1], x[0]))
        on=[0]*2001
        for s,e,d in tasks:
            cr=sum(on[s:e+1])
            while cr<d:
                on[s]=1
                cr+=1
                s+=1
        return sum(on)
"
2887,python3,minimum-time-to-complete-all-tasks,"class Solution:
    def findMinimumTime(self, tasks: List[List[int]]) -> int:
        tasks.sort(key=lambda x:x[1])
        on=[0]*2001
        for s,e,d in tasks:
            cr=sum(on[s:e+1])
            while cr<d:
                if on[e]!=1:on[e]=2; cr+=1
                e-=1
        return sum(on)",None,"class Solution:
    def findMinimumTime(self, tasks: List[List[int]]) -> int:
        tasks.sort(key=lambda x:(x[1], x[0]))
        on=[0]*2001
        for s,e,d in tasks:
            cr=sum(on[s:e+1])
            while cr<d:
                if on[s]!=1:
                    on[s]=2
                    cr+=1
                s+=1
        return sum(on)
"
2887,python3,minimum-time-to-complete-all-tasks,"class Solution:
    def findMinimumTime(self, tasks: List[List[int]]) -> int:
        tasks.sort(key=lambda x:x[1])
        on=[0]*2001
        for s,e,d in tasks:
            cr=sum(on[s:e+1])
            while cr<d:
                if on[e]!=1:on[e]=2; cr+=1
                e-=1
        return sum(on)",None,"class Solution:
    def findMinimumTime(self, tasks: List[List[int]]) -> int:
        tasks.sort(key=lambda x:(x[1], x[0]))
        on=[0]*2001
        for s,e,d in tasks:
            cr=sum(on[s:e+1])
            while cr<d:
                if on[s]!=1:
                    on[s]=2
                    cr+=1
                s+=1
        return sum(on)
"
2888,python3,lexicographical-numbers,"class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        lst=[str(i) for i in range(1,n)]
        lst.sort()
        return [int(i) for i in lst]",None,"class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        result = []
        for i in range(1, n + 1):
            result.append(i)
        return sorted(result, key=str)
"
2888,python3,lexicographical-numbers,"class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        lst=[str(i) for i in range(1,n)]
        lst.sort()
        return [int(i) for i in lst]",None,"class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        res = []
        for i in range(1, n+1):
            res.append(i)
        return sorted(res, key=str)
"
2888,python3,lexicographical-numbers,"class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        lst=[str(i) for i in range(1,n)]
        lst.sort()
        return [int(i) for i in lst]",None,"class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        result = []
        for i in range(1, n+1):
            result.append(i)
        return sorted(result, key=str)
"
2889,python3,maximum-performance-of-a-team,"class Solution:
    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
        MOD = 10**9 + 7

        top_k_speeds = []
        res, top_k_sum = 0, 0

        pairs = [(e, s) for e, s in zip(efficiency, speed)]
        for e, s in sorted(pairs):
            heapq.heappush(top_k_speeds, s)
            top_k_sum += s

            if len(top_k_speeds) > k:
                top_k_sum -= heapq.heappop(top_k_speeds)

            res = max(res, e * top_k_sum)
        
        return res % MOD",None,"class Solution:
    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
        MOD = 10**9 + 7

        top_k_speeds = []
        res, top_k_sum = 0, 0

        pairs = sorted([(e, s) for e, s in zip(efficiency, speed)], reverse=True)
        for e, s in pairs:
            heapq.heappush(top_k_speeds, s)
            top_k_sum += s

            if len(top_k_speeds) > k:
                top_k_sum -= heapq.heappop(top_k_speeds)

            if top_k_sum > 0:
                res = max(res, e * top_k_sum)
        
        return res % MOD
"
2889,python3,maximum-performance-of-a-team,"class Solution:
    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
        MOD = 10**9 + 7

        top_k_speeds = []
        res, top_k_sum = 0, 0

        pairs = [(e, s) for e, s in zip(efficiency, speed)]
        for e, s in sorted(pairs):
            heapq.heappush(top_k_speeds, s)
            top_k_sum += s

            if len(top_k_speeds) > k:
                top_k_sum -= heapq.heappop(top_k_speeds)

            res = max(res, e * top_k_sum)
        
        return res % MOD",None,M
2889,python3,maximum-performance-of-a-team,"class Solution:
    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
        MOD = 10**9 + 7

        top_k_speeds = []
        res, top_k_sum = 0, 0

        pairs = [(e, s) for e, s in zip(efficiency, speed)]
        for e, s in sorted(pairs):
            heapq.heappush(top_k_speeds, s)
            top_k_sum += s

            if len(top_k_speeds) > k:
                top_k_sum -= heapq.heappop(top_k_speeds)

            res = max(res, e * top_k_sum)
        
        return res % MOD",None,"class Solution:
    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
        MOD = 10**9 + 7

        top_k_speeds = []
        res, top_k_sum = 0, 0

        pairs = sorted([(e, s) for e, s in zip(efficiency, speed)], reverse=True)
        for e, s in pairs:
            heapq.heappush(top_k_speeds, s)
            top_k_sum += s

            if len(top_k_speeds) > k:
                top_k_sum -= heapq.heappop(top_k_speeds)

            res = max(res, e * top_k_sum)
        
        return res % MOD
"
2890,python3,range-sum-query-immutable,"class NumArray:

    def __init__(self, nums: List[int]):
        self.nums=[0]+list(accumulate(nums))
        print(self.nums)

    def sumRange(self, left: int, right: int) -> int:
        return self.nums[right]-self.nums[left]
",None,"class NumArray:

    def __init__(self, nums: List[int]):
        self.nums = [0] + list(accumulate(nums))

    def sumRange(self, left: int, right: int) -> int:
        return self.nums[right + 1] - self.nums[left]
"
2890,python3,range-sum-query-immutable,"class NumArray:

    def __init__(self, nums: List[int]):
        self.nums=[0]+list(accumulate(nums))
        print(self.nums)

    def sumRange(self, left: int, right: int) -> int:
        return self.nums[right]-self.nums[left]
",None,"class NumArray:

    def __init__(self, nums: List[int]):
        self.nums = [0] + list(accumulate(nums))

    def sumRange(self, left: int, right: int) -> int:
        return self.nums[right + 1] - self.nums[left]
"
2890,python3,range-sum-query-immutable,"class NumArray:

    def __init__(self, nums: List[int]):
        self.nums=[0]+list(accumulate(nums))
        print(self.nums)

    def sumRange(self, left: int, right: int) -> int:
        return self.nums[right]-self.nums[left]
",None,"class NumArray:

    def __init__(self, nums: List[int]):
        self.nums = [0] + list(accumulate(nums))

    def sumRange(self, left: int, right: int) -> int:
        return self.nums[right + 1] - self.nums[left]
"
2891,python3,merge-k-sorted-lists,"class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:

        head = temp = ListNode()
        arr = []

        for ls in lists:
            while ls:
                arr.append(ls.val)
                ls = ls.next

        for val in sorted(arr, reverse=True):   
            temp.next = ListNode()
            temp = temp.next
            temp.val = val

        return head.next",None,"class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:

        head = temp = ListNode()

        if not lists:
            return head.next

        while all(not ls for ls in lists):
            lists = [ls for ls in lists if ls]
            if not lists:
                break

        arr = []
        for ls in lists:
            while ls:
                arr.append(ls.val)
                ls = ls.next

        for val in sorted(arr):
            temp.next = ListNode(val)
            temp = temp.next

        return head.next
"
2891,python3,merge-k-sorted-lists,"class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:

        head = temp = ListNode()
        arr = []

        for ls in lists:
            while ls:
                arr.append(ls.val)
                ls = ls.next

        for val in sorted(arr, reverse=True):   
            temp.next = ListNode()
            temp = temp.next
            temp.val = val

        return head.next",None,"class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:

        head = temp = ListNode()

        if not lists:
            return head.next

        while all(not lst for lst in lists):
            lists = [lst for lst in lists if lst]
            if not lists:
                break

        if not lists:
            return head.next

        arr = []

        for ls in lists:
            while ls:
                arr.append(ls.val)
                ls = ls.next

        for val in sorted(arr):   
            temp.next = ListNode()
            temp = temp.next
            temp.val = val

        return head.next
"
2891,python3,merge-k-sorted-lists,"class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:

        head = temp = ListNode()
        arr = []

        for ls in lists:
            while ls:
                arr.append(ls.val)
                ls = ls.next

        for val in sorted(arr, reverse=True):   
            temp.next = ListNode()
            temp = temp.next
            temp.val = val

        return head.next",None,"class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:

        head = temp = ListNode()

        if not lists:
            return None

        while all(not ls for ls in lists):
            lists = [ls.next for ls in lists if ls]

        if not lists:
            return head.next

        min_node = min(lists, key=lambda ls: ls.val)
        temp.next = min_node
        temp = temp.next
        lists.remove(min_node)
        temp.next = self.mergeKLists(lists)

        return head.next
"
2892,python3,moving-stones-until-consecutive-ii,"class Solution:
    def numMovesStonesII(self, stones: List[int]) -> List[int]:
        stones.sort()
        stone_length = len(stones)
        move_penultimate = stones[-2] - stones[0] - stone_length + 2
        move_final = stones[-1] - stones[1] - stone_length + 2 
        most_moves = min(move_penultimate, move_final)
        if move_penultimate == 0 or move_final == 0 : 
            min_legal_moves = min(2, most_moves)
            return [min_legal_moves, most_moves]
        max_legal_moves = 0 
        starting_index = 0
        for index, stone in enumerate(stones) :
            while stones[starting_index] <= stone - stone_length : 
                starting_index += 1
            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) 
        return [stone_length - max_legal_moves, most_moves]",None,"class Solution:
    def numMovesStonesII(self, stones: List[int]) -> List[int]:
        stones.sort()
        stone_length = len(stones)
        move_penultimate = stones[-2] - stones[0] - stone_length + 2
        move_final = stones[-1] - stones[1] - stone_length + 2 
        most_moves = min(move_penultimate, move_final)
        if move_penultimate == 0 or move_final == 0 : 
            min_legal_moves = min(2, most_moves)
            return [min_legal_moves, most_moves]
        max_legal_moves = 0 
        starting_index = 0
        for index, stone in enumerate(stones) :
            while stones[starting_index] <= stone - stone_length : 
                starting_index += 1
            max_legal_moves = max(max_legal_moves, index - starting_index + 1) 
        return [stone_length - max_legal_moves + 1, most_moves]
"
2892,python3,moving-stones-until-consecutive-ii,"class Solution:
    def numMovesStonesII(self, stones: List[int]) -> List[int]:
        stones.sort()
        stone_length = len(stones)
        move_penultimate = stones[-2] - stones[0] - stone_length + 2
        move_final = stones[-1] - stones[1] - stone_length + 2 
        most_moves = min(move_penultimate, move_final)
        if move_penultimate == 0 or move_final == 0 : 
            min_legal_moves = min(2, most_moves)
            return [min_legal_moves, most_moves]
        max_legal_moves = 0 
        starting_index = 0
        for index, stone in enumerate(stones) :
            while stones[starting_index] <= stone - stone_length : 
                starting_index += 1
            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) 
        return [stone_length - max_legal_moves, most_moves]",None,"class Solution:
    def numMovesStonesII(self, stones: List[int]) -> List[int]:
        stones.sort()
        stone_length = len(stones)
        move_penultimate = stones[-2] - stones[0] - stone_length + 2
        move_final = stones[-1] - stones[1] - stone_length + 2
        most_moves = min(move_penultimate, move_final)
        if move_penultimate == 0 or move_final == 0:
            min_legal_moves = min(2, most_moves)
            return [min_legal_moves, most_moves]
        max_legal_moves = 0
        starting_index = 0
        for index, stone in enumerate(stones):
            while stones[starting_index] <= stone - stone_length:
                starting_index += 1
            max_legal_moves = max(max_legal_moves, index - starting_index + 1)
        return [stone_length - max_legal_moves, most_moves]
"
2892,python3,moving-stones-until-consecutive-ii,"class Solution:
    def numMovesStonesII(self, stones: List[int]) -> List[int]:
        stones.sort()
        stone_length = len(stones)
        move_penultimate = stones[-2] - stones[0] - stone_length + 2
        move_final = stones[-1] - stones[1] - stone_length + 2 
        most_moves = min(move_penultimate, move_final)
        if move_penultimate == 0 or move_final == 0 : 
            min_legal_moves = min(2, most_moves)
            return [min_legal_moves, most_moves]
        max_legal_moves = 0 
        starting_index = 0
        for index, stone in enumerate(stones) :
            while stones[starting_index] <= stone - stone_length : 
                starting_index += 1
            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) 
        return [stone_length - max_legal_moves, most_moves]",None,"class Solution:
    def numMovesStonesII(self, stones: List[int]) -> List[int]:
        stones.sort()
        stone_length = len(stones)
        move_penultimate = stones[-2] - stones[0] - stone_length + 2
        move_final = stones[-1] - stones[1] - stone_length + 2
        most_moves = min(move_penultimate, move_final)
        if move_penultimate == 0 or move_final == 0:
            min_legal_moves = min(2, most_moves)
            return [min_legal_moves, most_moves]
        max_legal_moves = 0
        starting_index = 0
        for index, stone in enumerate(stones):
            while stones[starting_index] <= stone - stone_length:
                starting_index += 1
            max_legal_moves = max(max_legal_moves, index - starting_index + 1)
        return [stone_length - max_legal_moves, most_moves]
"
2893,python3,binary-tree-level-order-traversal-ii,"class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        queue=deque()
        queue.append(root)
        lst=[]
        while queue:
            levels=[]
            for i in range(len(queue)):
                tmp=queue.popleft()
                if tmp:
                    levels.append(tmp.val)
                    queue.append(tmp.right)  
                    queue.append(tmp.left)   

            if levels:
                lst.append(levels)
        return lst[::-1]",None,"class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        queue=deque()
        queue.append(root)
        lst=[]
        while queue:
            levels=[]
            for i in range(len(queue)):
                tmp=queue.popleft()
                if tmp:
                    levels.append(tmp.val)
                    queue.append(tmp.left)
                    queue.append(tmp.right)

            if levels:
                lst.append(levels)
        return lst[::-1]
"
2893,python3,binary-tree-level-order-traversal-ii,"class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        queue=deque()
        queue.append(root)
        lst=[]
        while queue:
            levels=[]
            for i in range(len(queue)):
                tmp=queue.popleft()
                if tmp:
                    levels.append(tmp.val)
                    queue.append(tmp.right)  
                    queue.append(tmp.left)   

            if levels:
                lst.append(levels)
        return lst[::-1]",None,"class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        queue=deque()
        queue.append(root)
        lst=[]
        while queue:
            levels=[]
            for i in range(len(queue)):
                tmp=queue.popleft()
                if tmp:
                    levels.append(tmp.val)
                    queue.append(tmp.left)
                    queue.append(tmp.right)

            if levels:
                lst.append(levels)
        return lst[::-1]
"
2893,python3,binary-tree-level-order-traversal-ii,"class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        queue=deque()
        queue.append(root)
        lst=[]
        while queue:
            levels=[]
            for i in range(len(queue)):
                tmp=queue.popleft()
                if tmp:
                    levels.append(tmp.val)
                    queue.append(tmp.right)  
                    queue.append(tmp.left)   

            if levels:
                lst.append(levels)
        return lst[::-1]",None,"class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        queue=deque()
        queue.append(root)
        lst=[]
        while queue:
            levels=[]
            for i in range(len(queue)):
                tmp=queue.popleft()
                if tmp:
                    levels.append(tmp.val)
                    queue.append(tmp.left)
                    queue.append(tmp.right)
            if levels:
                lst.append(levels)
        return lst[::-1]
"
2894,python3,find-positive-integer-solution-for-a-given-equation,"""""""
   This is the custom function interface.
   You should not implement it, or speculate about its implementation
   class CustomFunction:
       def f(self, x, y):
  
""""""

class Solution:
    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:
        ans=[]
        y=1000
        for x in range(1,1001):
            while y>1 and customfunction.f(x,y)>z:
                y-=1
            if customfunction.f(x,y)==z:
                ans.append([x,y])
        return ans.append([x,y])",None,"class Solution:
    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:
        ans = []
        for x in range(1, 1001):
            y = 1000
            while y > 1 and customfunction.f(x, y) > z:
                y -= 1
            if customfunction.f(x, y) == z:
                ans.append([x, y])
        return ans
"
2894,python3,find-positive-integer-solution-for-a-given-equation,"""""""
   This is the custom function interface.
   You should not implement it, or speculate about its implementation
   class CustomFunction:
       def f(self, x, y):
  
""""""

class Solution:
    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:
        ans=[]
        y=1000
        for x in range(1,1001):
            while y>1 and customfunction.f(x,y)>z:
                y-=1
            if customfunction.f(x,y)==z:
                ans.append([x,y])
        return ans.append([x,y])",None,"class Solution:
    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:
        ans = []
        for x in range(1, 1001):
            y = 1000
            while y > 1 and customfunction.f(x, y) > z:
                y -= 1
            if customfunction.f(x, y) == z:
                ans.append([x, y])
        return ans
"
2894,python3,find-positive-integer-solution-for-a-given-equation,"""""""
   This is the custom function interface.
   You should not implement it, or speculate about its implementation
   class CustomFunction:
       def f(self, x, y):
  
""""""

class Solution:
    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:
        ans=[]
        y=1000
        for x in range(1,1001):
            while y>1 and customfunction.f(x,y)>z:
                y-=1
            if customfunction.f(x,y)==z:
                ans.append([x,y])
        return ans.append([x,y])",None,"class Solution:
    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:
        ans = []
        for x in range(1, 1001):
            y = 1000
            while y > 1 and customfunction.f(x, y) > z:
                y -= 1
            if customfunction.f(x, y) == z:
                ans.append([x, y])
        return ans
"
2895,python3,removing-minimum-and-maximum-from-array,"class Solution:
    def minimumDeletions(self, nums: List[int]) -> int:
        nums = sorted(nums)
        return min((min(nums.index(min(nums))+1,len(nums)-nums.index(min(nums)))+min(nums.index(max(nums))+1,len(nums)-nums.index(max(nums)))),max(nums.index(min(nums))+1,nums.index(max(nums))+1),max(len(nums)-nums.index(min(nums)),len(nums)-nums.index(max(nums))))",None,"class Solution:
    def minimumDeletions(self, nums: List[int]) -> int:
        min_index = nums.index(min(nums))
        max_index = nums.index(max(nums))
        min_distance = min(min_index + 1, len(nums) - min_index)
        max_distance = min(max_index + 1, len(nums) - max_index)
        return min(min_distance + max_distance, max(min_distance, max_distance), max(len(nums) - min_index, len(nums) - max_index))
"
2895,python3,removing-minimum-and-maximum-from-array,"class Solution:
    def minimumDeletions(self, nums: List[int]) -> int:
        nums = sorted(nums)
        return min((min(nums.index(min(nums))+1,len(nums)-nums.index(min(nums)))+min(nums.index(max(nums))+1,len(nums)-nums.index(max(nums)))),max(nums.index(min(nums))+1,nums.index(max(nums))+1),max(len(nums)-nums.index(min(nums)),len(nums)-nums.index(max(nums))))",None,"class Solution:
    def minimumDeletions(self, nums: List[int]) -> int:
        min_index = nums.index(min(nums))
        max_index = nums.index(max(nums))
        return min(min_index + 1 + len(nums) - max_index,
                   max_index + 1 + len(nums) - min_index,
                   len(nums) - min_index,
                   len(nums) - max_index)
"
2895,python3,removing-minimum-and-maximum-from-array,"class Solution:
    def minimumDeletions(self, nums: List[int]) -> int:
        nums = sorted(nums)
        return min((min(nums.index(min(nums))+1,len(nums)-nums.index(min(nums)))+min(nums.index(max(nums))+1,len(nums)-nums.index(max(nums)))),max(nums.index(min(nums))+1,nums.index(max(nums))+1),max(len(nums)-nums.index(min(nums)),len(nums)-nums.index(max(nums))))",None,"class Solution:
    def minimumDeletions(self, nums: List[int]) -> int:
        min_index = nums.index(min(nums))
        max_index = nums.index(max(nums))
        return min(min_index + 1 + len(nums) - max_index,
                   max_index + 1 + len(nums) - min_index,
                   len(nums) - min_index,
                   len(nums) - max_index)
"
2896,python3,maximum-number-of-consecutive-values-you-can-make,"class Solution:
  def getMaximumConsecutive(self, coins: List[int]) -> int:
    ans = 1

    for coin in sorted(coins):
      if coin > ans:
        return ans
      ans += coin

  return ans",None,"class Solution:
  def getMaximumConsecutive(self, coins: List[int]) -> int:
    ans = 1

    for coin in sorted(coins):
      if coin > ans + 1:
        return ans
      ans += coin

    return ans + 1
"
2896,python3,maximum-number-of-consecutive-values-you-can-make,"class Solution:
  def getMaximumConsecutive(self, coins: List[int]) -> int:
    ans = 1

    for coin in sorted(coins):
      if coin > ans:
        return ans
      ans += coin

  return ans",None,"class Solution:
  def getMaximumConsecutive(self, coins: List[int]) -> int:
    ans = 1

    for coin in sorted(coins):
      if coin > ans + 1:
        return ans
      ans += coin - 1

    return ans + 1
"
2896,python3,maximum-number-of-consecutive-values-you-can-make,"class Solution:
  def getMaximumConsecutive(self, coins: List[int]) -> int:
    ans = 1

    for coin in sorted(coins):
      if coin > ans:
        return ans
      ans += coin

  return ans",None,"class Solution:
    def getMaximumConsecutive(self, coins: List[int]) -> int:
        max_val = 0
        coins_set = set(coins)

        for val in coins_set:
            if val > max_val + 1:
                break
            max_val += val

        return max_val + 1
"
2897,python3,sum-of-subarray-minimums,"class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        stack = []
        res = 0
        arr = [float('-inf')] + arr + [float('-inf')]
        for i, num in enumerate(arr):
            while stack and arr[stack[-1]] > num:
                cur = stack.pop()
                res += arr[cur] * (cur - i) * (cur - stack[-1])
            stack.append(i)
        return res % (10**9 + 7)",None,"class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        stack = []
        res = 0
        arr = [float('-inf')] + arr + [float('-inf')]
        for i, num in enumerate(arr):
            while stack and arr[stack[-1]] > num:
                cur = stack.pop()
                res = (res + arr[cur] * (cur - i) * (cur - stack[-1])) % (10**9 + 7)
            stack.append(i)
        return res
"
2897,python3,sum-of-subarray-minimums,"class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        stack = []
        res = 0
        arr = [float('-inf')] + arr + [float('-inf')]
        for i, num in enumerate(arr):
            while stack and arr[stack[-1]] > num:
                cur = stack.pop()
                res += arr[cur] * (cur - i) * (cur - stack[-1])
            stack.append(i)
        return res % (10**9 + 7)",None,"class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        stack = []
        res = 0
        mod = 10**9 + 7
        arr = [float('-inf')] + arr + [float('-inf')]
        for i, num in enumerate(arr):
            while stack and arr[stack[-1]] > num:
                cur = stack.pop()
                res += arr[cur] * (cur - i) * (cur - stack[-1])
                res %= mod
            stack.append(i)
        return res % mod
"
2897,python3,sum-of-subarray-minimums,"class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        stack = []
        res = 0
        arr = [float('-inf')] + arr + [float('-inf')]
        for i, num in enumerate(arr):
            while stack and arr[stack[-1]] > num:
                cur = stack.pop()
                res += arr[cur] * (cur - i) * (cur - stack[-1])
            stack.append(i)
        return res % (10**9 + 7)",None,"class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        stack = []
        res = 0
        mod = 10**9 + 7
        arr = [float('-inf')] + arr + [float('-inf')]
        for i, num in enumerate(arr):
            while stack and arr[stack[-1]] > num:
                cur = stack.pop()
                res += arr[cur] * (cur - i) * (cur - stack[-1])
                res %= mod
            stack.append(i)
        return res % mod
"
2898,python3,can-you-eat-your-favorite-candy-on-your-favorite-day,"class Solution:
    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:
        prefix = [0]
        for x in candiesCount: prefix.append(prefix[-1] + x)
        return [prefix[t-1] < (day+1)*cap and day < prefix[t+1] for t, day, cap in queries]",None,"class Solution:
    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:
        prefix = [0]
        for x in candiesCount: prefix.append(prefix[-1] + x)
        return [prefix[favoriteTypei+1] - prefix[favoriteDayi] >= dailyCapi and favoriteDayi < prefix[-1] for favoriteTypei, favoriteDayi, dailyCapi in queries]
"
2898,python3,can-you-eat-your-favorite-candy-on-your-favorite-day,"class Solution:
    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:
        prefix = [0]
        for x in candiesCount: prefix.append(prefix[-1] + x)
        return [prefix[t-1] < (day+1)*cap and day < prefix[t+1] for t, day, cap in queries]",None,"class Solution:
    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:
        prefix = [0]
        for x in candiesCount: prefix.append(prefix[-1] + x)
        return [prefix[favoriteTypei+1] - prefix[favoriteDayi] >= dailyCapi and favoriteDayi < prefix[-1] for favoriteTypei, favoriteDayi, dailyCapi in queries]
"
2898,python3,can-you-eat-your-favorite-candy-on-your-favorite-day,"class Solution:
    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:
        prefix = [0]
        for x in candiesCount: prefix.append(prefix[-1] + x)
        return [prefix[t-1] < (day+1)*cap and day < prefix[t+1] for t, day, cap in queries]",None,"class Solution:
    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:
        prefix = [0]
        for x in candiesCount: prefix.append(prefix[-1] + x)
        return [prefix[favoriteTypei+1] - prefix[favoriteDayi] >= dailyCapi and favoriteDayi < len(prefix) - 1 for favoriteTypei, favoriteDayi, dailyCapi in queries]
"
2899,python3,sliding-window-median,"class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        tree = None
        ans = []
        for i, x in enumerate(nums):
            tree = insert(tree, x)
            if size(tree) > k:
                tree = remove(tree, nums[i - k])
            if size(tree) == k:
                if k % 2 == 1:
                    ans.append(get(tree, k // 2 + 1))
                else:
                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)
        return ans



class Node:
    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']
    def __init__(self, val):
        self.val = val
        self.count = 1
        self.weight = random.random()
        self.size = 1
        self.left = self.right = None


def touch(root):
    if not root:
        return
    root.size = root.count + size(root.left) + size(root.right)


def size(root):
    if not root:
        return 0
    return root.size


def insert(root, val):
    t1, r, t2 = split(root, val)
    if not r:
        r = Node(val)
    else:
        r.count += 1
        touch(r)
    t2 = join(r, t2)
    return join(t1, t2)


def remove(root, val):
    t1, r, t2 = split(root, val)
    if r.count > 1:
        r.count -= 1
        touch(r)
        t2 = join(r, t2)
    return join(t1, t2)


def split(root, val):
    if not root:
        return None, None, None
    elif root.val < val:
        a, b, c = split(root.right, val)
        root.right = a
        touch(root)
        return root, b, c
    elif root.val > val:
        a, b, c = split(root.left, val)
        root.left = c
        touch(root)
        return a, b, root
    else:
        a, c = root.left, root.right
        root.left = root.right = None
        touch(root)
        return a, root, c


def join(t1, t2):
    if not t1:
        return t2
    elif not t2:
        return t1
    elif t1.weight < t2.weight:
        t1.right = join(t1.right, t2)
        touch(t1)
        return t1
    else:
        t2.left = join(t1, t2.left)
        touch(t2)
        return t2


def get(root, index):
    if size(root.left) < index <= size(root.left) + root.count:
        return root.val
    elif size(root.left) + root.count < index:
        return get(root.right, index - root.count)
    else:
        return get(root.left, index)",None,"class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        window = nums[:k]
        window.sort()
        ans = [window[k//2] if k % 2 else (window[k//2 - 1] + window[k//2]) / 2]
        for i in range(k, len(nums)):
            window.pop(bisect.bisect_left(window, nums[i-k]))
            window.append(nums[i])
            window.sort()
            ans.append(window[k//2] if k % 2 else (window[k//2 - 1] + window[k//2]) / 2)
        return ans
"
2899,python3,sliding-window-median,"class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        tree = None
        ans = []
        for i, x in enumerate(nums):
            tree = insert(tree, x)
            if size(tree) > k:
                tree = remove(tree, nums[i - k])
            if size(tree) == k:
                if k % 2 == 1:
                    ans.append(get(tree, k // 2 + 1))
                else:
                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)
        return ans



class Node:
    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']
    def __init__(self, val):
        self.val = val
        self.count = 1
        self.weight = random.random()
        self.size = 1
        self.left = self.right = None


def touch(root):
    if not root:
        return
    root.size = root.count + size(root.left) + size(root.right)


def size(root):
    if not root:
        return 0
    return root.size


def insert(root, val):
    t1, r, t2 = split(root, val)
    if not r:
        r = Node(val)
    else:
        r.count += 1
        touch(r)
    t2 = join(r, t2)
    return join(t1, t2)


def remove(root, val):
    t1, r, t2 = split(root, val)
    if r.count > 1:
        r.count -= 1
        touch(r)
        t2 = join(r, t2)
    return join(t1, t2)


def split(root, val):
    if not root:
        return None, None, None
    elif root.val < val:
        a, b, c = split(root.right, val)
        root.right = a
        touch(root)
        return root, b, c
    elif root.val > val:
        a, b, c = split(root.left, val)
        root.left = c
        touch(root)
        return a, b, root
    else:
        a, c = root.left, root.right
        root.left = root.right = None
        touch(root)
        return a, root, c


def join(t1, t2):
    if not t1:
        return t2
    elif not t2:
        return t1
    elif t1.weight < t2.weight:
        t1.right = join(t1.right, t2)
        touch(t1)
        return t1
    else:
        t2.left = join(t1, t2.left)
        touch(t2)
        return t2


def get(root, index):
    if size(root.left) < index <= size(root.left) + root.count:
        return root.val
    elif size(root.left) + root.count < index:
        return get(root.right, index - root.count)
    else:
        return get(root.left, index)",None,"if k % 2 == 1:
    ans.append(get(tree, k // 2 + 1))
else:
    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)
"
2899,python3,sliding-window-median,"class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        tree = None
        ans = []
        for i, x in enumerate(nums):
            tree = insert(tree, x)
            if size(tree) > k:
                tree = remove(tree, nums[i - k])
            if size(tree) == k:
                if k % 2 == 1:
                    ans.append(get(tree, k // 2 + 1))
                else:
                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)
        return ans



class Node:
    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']
    def __init__(self, val):
        self.val = val
        self.count = 1
        self.weight = random.random()
        self.size = 1
        self.left = self.right = None


def touch(root):
    if not root:
        return
    root.size = root.count + size(root.left) + size(root.right)


def size(root):
    if not root:
        return 0
    return root.size


def insert(root, val):
    t1, r, t2 = split(root, val)
    if not r:
        r = Node(val)
    else:
        r.count += 1
        touch(r)
    t2 = join(r, t2)
    return join(t1, t2)


def remove(root, val):
    t1, r, t2 = split(root, val)
    if r.count > 1:
        r.count -= 1
        touch(r)
        t2 = join(r, t2)
    return join(t1, t2)


def split(root, val):
    if not root:
        return None, None, None
    elif root.val < val:
        a, b, c = split(root.right, val)
        root.right = a
        touch(root)
        return root, b, c
    elif root.val > val:
        a, b, c = split(root.left, val)
        root.left = c
        touch(root)
        return a, b, root
    else:
        a, c = root.left, root.right
        root.left = root.right = None
        touch(root)
        return a, root, c


def join(t1, t2):
    if not t1:
        return t2
    elif not t2:
        return t1
    elif t1.weight < t2.weight:
        t1.right = join(t1.right, t2)
        touch(t1)
        return t1
    else:
        t2.left = join(t1, t2.left)
        touch(t2)
        return t2


def get(root, index):
    if size(root.left) < index <= size(root.left) + root.count:
        return root.val
    elif size(root.left) + root.count < index:
        return get(root.right, index - root.count)
    else:
        return get(root.left, index)",None,"class Node:
    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']
    def __init__(self, val):
        self.val = val
        self.count = 1
        self.weight = random.random()
        self.size = 1
        self.left = self.right = None


def touch(root):
    if not root:
        return
    root.size = root.count + size(root.left) + size(root.right)


def size(root):
    if not root:
        return 0
    return root.size


def insert(root, val):
    t1, r, t2 = split(root, val)
    if not r:
        r = Node(val)
    else:
        r.count += 1
    touch(r)
    t2 = join(r, t2)
    return join(t1, t2)


def remove(root, val):
    t1, r, t2 = split(root, val)
    if r.count > 1:
        r.count -= 1
        touch(r)
    return join(t1, t2)


def split(root, val):
    if not root:
        return None, None, None
    elif root.val < val:
        a, b, c = split(root.right, val)
        root.right = a
        touch(root)
        return root, b, c
    elif root.val > val:
        a, b, c = split(root.left, val)
        root.left = c
        touch(root)
        return a, b, root
    else:
        a, c = root.left, root.right
        root.left = root.right = None
        touch(root)
        return a, root, c


def join(t1, t2):
    if not t1:
        return t2
    elif not t2:
        return t1
    elif t1.weight < t2.weight:
        t1.right = join(t1.right, t2)
        touch(t1)
        return t1
    else:
        t2.left = join(t1, t2.left)
        touch(t2)
        return t2


def get(root, index):
    if size(root.left) < index <= size(root.left) + root.count:
        return root.val
    elif size(root.left) + root.count < index:
        return get(root.right, index - root.count)
    else:
        return get(root.left, index)

class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        tree = None
        ans = []
        for i, x in enumerate(nums):
            tree = insert(tree, x)
            if size(tree) > k:
                tree = remove(tree, nums[i - k])
            if size(tree) == k:
                if k % 2 == 1:
                    ans.append(get(tree, k // 2 + 1))
                else:
                    index = k // 2
                    ans.append((get(tree, index) + get(tree, index + 1)) / 2)
        return ans
"
2900,python3,kth-largest-sum-in-a-binary-tree,"class Solution:
    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:
        dq = collections.deque([root])
        a = []
        lvl = 1
        while dq:
            lvlsum = 0
            for i in range(len(dq)):
               n = dq.popleft()
               lvlsum += n.val
               if n.left: dq.append(n.left)
               if n.right: dq.append(n.right)
            a.append(lvlsum)
            lvl += 1
        a.sort(reverse=False)
        return a[k-1] if len(a) >= k else -1",None,"class Solution:
    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:
        dq = collections.deque([(root, 1)])
        a = []
        while dq:
            node, lvl = dq.popleft()
            if not node: continue
            a.append(node.val) if lvl == len(a) + 1 else a[lvl-1] += node.val
            dq.append((node.left, lvl + 1))
            dq.append((node.right, lvl + 1))
        return sorted(a, reverse=True)[k-1] if len(a) >= k else -1
"
2900,python3,kth-largest-sum-in-a-binary-tree,"class Solution:
    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:
        dq = collections.deque([root])
        a = []
        lvl = 1
        while dq:
            lvlsum = 0
            for i in range(len(dq)):
               n = dq.popleft()
               lvlsum += n.val
               if n.left: dq.append(n.left)
               if n.right: dq.append(n.right)
            a.append(lvlsum)
            lvl += 1
        a.sort(reverse=False)
        return a[k-1] if len(a) >= k else -1",None,"class Solution:
    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:
        dq = collections.deque([(root, 1)])
        a = []
        while dq:
            node, lvl = dq.popleft()
            if lvl > len(a):
                a.append(node.val)
            else:
                a[lvl-1] += node.val
            if node.left: dq.append((node.left, lvl+1))
            if node.right: dq.append((node.right, lvl+1))
        a.sort(reverse=True)
        return a[k-1] if len(a) >= k else -1
"
2900,python3,kth-largest-sum-in-a-binary-tree,"class Solution:
    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:
        dq = collections.deque([root])
        a = []
        lvl = 1
        while dq:
            lvlsum = 0
            for i in range(len(dq)):
               n = dq.popleft()
               lvlsum += n.val
               if n.left: dq.append(n.left)
               if n.right: dq.append(n.right)
            a.append(lvlsum)
            lvl += 1
        a.sort(reverse=False)
        return a[k-1] if len(a) >= k else -1",None,"class Solution:
    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:
        dq = collections.deque([(root, 1)])
        a = []
        while dq:
            node, lvl = dq.popleft()
            if lvl > len(a):
                a.append(node.val)
            else:
                a[lvl-1] += node.val
            if node.left: dq.append((node.left, lvl+1))
            if node.right: dq.append((node.right, lvl+1))
        a.sort(reverse=True)
        return a[k-1] if len(a) >= k else -1
"
2901,python3,isomorphic-strings,"class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        return len(set(s))==len(set(t))==len(set(zip(s,t[:len(s)-1])))",None,"class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        char_map = {}
        for c1, c2 in zip(s, t):
            if c1 in char_map:
                if char_map[c1] != c2:
                    return False
            elif c2 in char_map.values():
                return False
            else:
                char_map[c1] = c2
        return True
"
2901,python3,isomorphic-strings,"class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        return len(set(s))==len(set(t))==len(set(zip(s,t[:len(s)-1])))",None,"class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False

        char_map = {}
        for c1, c2 in zip(s, t):
            if c1 in char_map:
                if char_map[c1] != c2:
                    return False
            else:
                if c2 in char_map.values():
                    return False
                char_map[c1] = c2

        return True
"
2901,python3,isomorphic-strings,"class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        return len(set(s))==len(set(t))==len(set(zip(s,t[:len(s)-1])))",None,"class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False

        char_map = {}
        used_chars = set()

        for c1, c2 in zip(s, t):
            if c1 in char_map:
                if char_map[c1] != c2:
                    return False
            else:
                if c2 in used_chars:
                    return False

                char_map[c1] = c2
                used_chars.add(c2)

        return True
"
2902,python3,construct-binary-tree-from-preorder-and-inorder-traversal,"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        inorder_map={val:idx for idx, val in enumerate(inorder)}
        preorder_idx=0

        def treeHelper(left, right):
            nonlocal preorder_idx
            if left>right:
                return None

            node_val = preorder[preorder_idx]
            root=TreeNode(node_val)
            preorder_idx+=1

            inorder_index=inorder_map[node_val]

            root.left = treeHelper(inorder_index+1, right)
            root.right = treeHelper(left, inorder_index-1 )

            return root

        return treeHelper(0, len(inorder)-1)",None,"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        inorder_map={val:idx for idx, val in enumerate(inorder)}
        preorder_idx=0

        def treeHelper(left, right):
            nonlocal preorder_idx
            if left>right:
                return None

            node_val = preorder[preorder_idx]
            root=TreeNode(node_val)
            preorder_idx+=1

            inorder_index=inorder_map[node_val]

            root.left = treeHelper(left, inorder_index-1)
            root.right = treeHelper(inorder_index+1, right)

            return root

        return treeHelper(0, len(inorder)-1)
"
2902,python3,construct-binary-tree-from-preorder-and-inorder-traversal,"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        inorder_map={val:idx for idx, val in enumerate(inorder)}
        preorder_idx=0

        def treeHelper(left, right):
            nonlocal preorder_idx
            if left>right:
                return None

            node_val = preorder[preorder_idx]
            root=TreeNode(node_val)
            preorder_idx+=1

            inorder_index=inorder_map[node_val]

            root.left = treeHelper(inorder_index+1, right)
            root.right = treeHelper(left, inorder_index-1 )

            return root

        return treeHelper(0, len(inorder)-1)",None,"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        inorder_map={val:idx for idx, val in enumerate(inorder)}
        preorder_idx=0

        def treeHelper(left, right):
            nonlocal preorder_idx
            if left>right:
                return None

            node_val = preorder[preorder_idx]
            root=TreeNode(node_val)
            preorder_idx+=1

            inorder_index=inorder_map[node_val]

            root.left = treeHelper(left, inorder_index-1)
            root.right = treeHelper(inorder_index+1, right)

            return root

        return treeHelper(0, len(inorder)-1)
"
2902,python3,construct-binary-tree-from-preorder-and-inorder-traversal,"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        inorder_map={val:idx for idx, val in enumerate(inorder)}
        preorder_idx=0

        def treeHelper(left, right):
            nonlocal preorder_idx
            if left>right:
                return None

            node_val = preorder[preorder_idx]
            root=TreeNode(node_val)
            preorder_idx+=1

            inorder_index=inorder_map[node_val]

            root.left = treeHelper(inorder_index+1, right)
            root.right = treeHelper(left, inorder_index-1 )

            return root

        return treeHelper(0, len(inorder)-1)",None,"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        inorder_map={val:idx for idx, val in enumerate(inorder)}
        preorder_idx=0

        def treeHelper(left, right):
            nonlocal preorder_idx
            if left>right:
                return None

            node_val = preorder[preorder_idx]
            root=TreeNode(node_val)
            preorder_idx+=1

            inorder_index=inorder_map[node_val]

            root.left = treeHelper(left, inorder_index-1)
            root.right = treeHelper(inorder_index+1, right)

            return root

        return treeHelper(0, len(inorder)-1)
"
2903,python3,design-a-text-editor,"class TextEditor:
    def __init__(self):
        self.stack = []
        self.q = deque([])
        
    def addText(self, text: str) -> None:
        for c in text:
            self.q.append(c)

        
    def deleteText(self, k: int) -> int:
        i = 0
        while self.stack and i < k:
            self.stack.pop()
            i += 1
        return i
        
    def cursorLeft(self, k: int) -> str:
        i = 0
        while self.stack and i < k:
            self.q.appendleft(self.stack.pop())
            i += 1
        return """".join(self.stack[-10:]) if len(self.stack) >= 10 else """".join(self.stack)
        
    def cursorRight(self, k: int) -> str:
        i = 0
        while self.q and i < k:
            self.stack.append(self.q.popleft())
            i += 1
        return """".join(self.stack[-10:]) if len(self.stack) >= 10 else """".join(self.stack)",None,"class TextEditor:
    def __init__(self):
        self.text = """"
        self.cursor = 0

    def addText(self, text: str) -> None:
        self.text += text

    def deleteText(self, k: int) -> int:
        deleted = min(k, self.cursor)
        if deleted > 0:
            self.text = self.text[:self.cursor - deleted] + self.text[self.cursor:]
            self.cursor -= deleted
        return deleted

    def cursorLeft(self, k: int) -> str:
        self.cursor = max(0, self.cursor - k)
        return self.text[self.cursor:self.cursor + 10]

    def cursorRight(self, k: int) -> str:
        self.cursor = min(len(self.text), self.cursor + k)
        return self.text[self.cursor - 10:self.cursor]
"
2903,python3,design-a-text-editor,"class TextEditor:
    def __init__(self):
        self.stack = []
        self.q = deque([])
        
    def addText(self, text: str) -> None:
        for c in text:
            self.q.append(c)

        
    def deleteText(self, k: int) -> int:
        i = 0
        while self.stack and i < k:
            self.stack.pop()
            i += 1
        return i
        
    def cursorLeft(self, k: int) -> str:
        i = 0
        while self.stack and i < k:
            self.q.appendleft(self.stack.pop())
            i += 1
        return """".join(self.stack[-10:]) if len(self.stack) >= 10 else """".join(self.stack)
        
    def cursorRight(self, k: int) -> str:
        i = 0
        while self.q and i < k:
            self.stack.append(self.q.popleft())
            i += 1
        return """".join(self.stack[-10:]) if len(self.stack) >= 10 else """".join(self.stack)",None,"class TextEditor:
    def __init__(self):
        self.stack = []
        self.q = deque([])

    def addText(self, text: str) -> None:
        for c in text:
            self.q.append(c)

    def deleteText(self, k: int) -> int:
        deleted = 0
        while k > 0 and self.q:
            self.stack.append(self.q.popleft())
            k -= 1
            deleted += 1
        return deleted

    def cursorLeft(self, k: int) -> str:
        for _ in range(k):
            if self.q:
                self.stack.append(self.q.popleft())
            elif self.stack:
                self.q.appendleft(self.stack.pop())
        return """".join(self.stack[-10:]) if self.stack and len(self.stack) >= 10 else """".join(self.stack)

    def cursorRight(self, k: int) -> str:
        for _ in range(k):
            if self.stack:
                self.q.appendleft(self.stack.pop())
            elif self.q:
                self.stack.append(self.q.popleft())
        return """".join(self.stack[-10:]) if self.stack and len(self.stack) >= 10 else """".join(self.stack)
"
2903,python3,design-a-text-editor,"class TextEditor:
    def __init__(self):
        self.stack = []
        self.q = deque([])
        
    def addText(self, text: str) -> None:
        for c in text:
            self.q.append(c)

        
    def deleteText(self, k: int) -> int:
        i = 0
        while self.stack and i < k:
            self.stack.pop()
            i += 1
        return i
        
    def cursorLeft(self, k: int) -> str:
        i = 0
        while self.stack and i < k:
            self.q.appendleft(self.stack.pop())
            i += 1
        return """".join(self.stack[-10:]) if len(self.stack) >= 10 else """".join(self.stack)
        
    def cursorRight(self, k: int) -> str:
        i = 0
        while self.q and i < k:
            self.stack.append(self.q.popleft())
            i += 1
        return """".join(self.stack[-10:]) if len(self.stack) >= 10 else """".join(self.stack)",None,"class TextEditor:
    def __init__(self):
        self.stack = []
        self.q = deque([])

    def addText(self, text: str) -> None:
        for c in text:
            self.q.append(c)

    def deleteText(self, k: int) -> int:
        deleted = 0
        while k > 0 and self.q:
            self.stack.append(self.q.popleft())
            k -= 1
            deleted += 1
        return deleted

    def cursorLeft(self, k: int) -> str:
        for _ in range(k):
            if self.q:
                self.stack.append(self.q.popleft())
            elif self.stack:
                self.stack.append(self.stack.pop())
        return """".join(self.stack[-10:])

    def cursorRight(self, k: int) -> str:
        for _ in range(k):
            if self.stack:
                self.q.appendleft(self.stack.pop())
            elif self.q:
                self.stack.append(self.q.popleft())
        return """".join(self.q) if self.q else """"
"
3039,python3,the-kth-factor-of-n,"class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        j = 0
        for i in range(1, n + 1):
            if n % i == 0:
                num = i
                j += 1
            if j == k:
                break
        return num if j == k+1 else -1",None,"class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        j = 0
        for i in range(1, n + 1):
            if n % i == 0:
                j += 1
                if j == k:
                    return i
        return -1
"
3039,python3,the-kth-factor-of-n,"class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        j = 0
        for i in range(1, n + 1):
            if n % i == 0:
                num = i
                j += 1
            if j == k:
                break
        return num if j == k+1 else -1",None,"class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        j = 0
        for i in range(1, n + 1):
            if n % i == 0:
                num = i
                j += 1
                if j == k:
                    return num
        return -1
"
3039,python3,the-kth-factor-of-n,"class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        j = 0
        for i in range(1, n + 1):
            if n % i == 0:
                num = i
                j += 1
            if j == k:
                break
        return num if j == k+1 else -1",None,"class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        j = 0
        for i in range(1, n + 1):
            if n % i == 0:
                j += 1
                if j == k:
                    return i
        return -1
"
3040,python3,check-if-string-is-transformable-with-substring-sort-operations,"class Solution:
    def isTransformable(self, s: str, t: str) -> bool :
        indexes = collections.defaultdict(collections.deque)
        for index, character in enumerate(s) :
            indexes[int(character)].append(index)

        unique_t_values = set([int(t_i) for t_i in t])
        for t_v in unique_t_values : 
            if t_v not in indexes :
                return False 
            
        for character in t : 
            character_designation = int(character)
            if character_designation not in indexes : 
                return False 
            for lesser_character in range(character_designation):
                if indexes[lesser_character] and indexes[lesser_character][0] < indexes[character_designation][0] : 
                    return False 
            indexes[character_designation].popleft()
            if len(indexes[character_designation]) == 0 : 
                indexes.pop(character_designation)
        
        return False",None,"class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        indexes = collections.defaultdict(collections.deque)
        for index, character in enumerate(s):
            indexes[int(character)].append(index)

        unique_t_values = set([int(t_i) for t_i in t])
        for t_v in unique_t_values:
            if t_v not in indexes:
                return False

        for character in t:
            character_designation = int(character)
            if character_designation not in indexes:
                return False
            for lesser_character in range(character_designation):
                if indexes[lesser_character] and indexes[lesser_character][0] < indexes[character_designation][0]:
                    return False
            indexes[character_designation].popleft()
            if len(indexes[character_designation]) == 0:
                indexes.pop(character_designation)

        return True
"
3040,python3,check-if-string-is-transformable-with-substring-sort-operations,"class Solution:
    def isTransformable(self, s: str, t: str) -> bool :
        indexes = collections.defaultdict(collections.deque)
        for index, character in enumerate(s) :
            indexes[int(character)].append(index)

        unique_t_values = set([int(t_i) for t_i in t])
        for t_v in unique_t_values : 
            if t_v not in indexes :
                return False 
            
        for character in t : 
            character_designation = int(character)
            if character_designation not in indexes : 
                return False 
            for lesser_character in range(character_designation):
                if indexes[lesser_character] and indexes[lesser_character][0] < indexes[character_designation][0] : 
                    return False 
            indexes[character_designation].popleft()
            if len(indexes[character_designation]) == 0 : 
                indexes.pop(character_designation)
        
        return False",None,"class Solution:
    def isTransformable(self, s: str, t: str) -> bool :
        indexes = collections.defaultdict(collections.deque)
        for index, character in enumerate(s) :
            indexes[int(character)].append(index)

        unique_t_values = set([int(t_i) for t_i in t])
        for t_v in unique_t_values : 
            if t_v not in indexes :
                return False 

        for character in t : 
            character_designation = int(character)
            if character_designation not in indexes : 
                return False 
            for lesser_character in range(character_designation):
                if indexes[lesser_character] and indexes[lesser_character][0] < indexes[character_designation][0] : 
                    return False 
            if indexes[character_designation][0] < len(s) - len(indexes[character_designation]):
                indexes[character_designation].popleft()
            else:
                indexes.pop(character_designation)

        return True
"
3040,python3,check-if-string-is-transformable-with-substring-sort-operations,"class Solution:
    def isTransformable(self, s: str, t: str) -> bool :
        indexes = collections.defaultdict(collections.deque)
        for index, character in enumerate(s) :
            indexes[int(character)].append(index)

        unique_t_values = set([int(t_i) for t_i in t])
        for t_v in unique_t_values : 
            if t_v not in indexes :
                return False 
            
        for character in t : 
            character_designation = int(character)
            if character_designation not in indexes : 
                return False 
            for lesser_character in range(character_designation):
                if indexes[lesser_character] and indexes[lesser_character][0] < indexes[character_designation][0] : 
                    return False 
            indexes[character_designation].popleft()
            if len(indexes[character_designation]) == 0 : 
                indexes.pop(character_designation)
        
        return False",None,"class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        indexes = collections.defaultdict(collections.deque)
        for index, character in enumerate(s):
            indexes[int(character)].append(index)

        unique_t_values = set([int(t_i) for t_i in t])
        for t_v in unique_t_values:
            if t_v not in indexes:
                return False

        for character in t:
            character_designation = int(character)
            if character_designation not in indexes:
                return False
            for lesser_character in range(character_designation):
                if indexes[lesser_character] and indexes[lesser_character][0] < indexes[character_designation][0]:
                    return False
            indexes[character_designation].popleft()
            if len(indexes[character_designation]) == 0:
                indexes.pop(character_designation)

        return True
"
3041,python3,restore-ip-addresses,"class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res=[]
        cur=[]
        def backtrack(i):
            if i==len(s) and len(cur)==4:
                res.append(""."".join(cur))
                return
            if len(cur)>4 or i>len(s):
                return
            if s[i]=='0':
                cur.append(s[i])
                backtrack(i+1)
                cur.pop()
                return
            j=0
            while j<4 and i+j<len(s):
                if int(s[i:i+j+1])<256:
                    cur.append(s[i:i+j+1])
                    backtrack(i+j+1)
                    cur.pop()
                j+=1
        backtrack(0)
        return res",None,"class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res=[]
        cur=[]
        def backtrack(i):
            if i==len(s) and len(cur)==4:
                res.append(""."".join(cur))
                return
            if len(cur)>4 or i>len(s):
                return
            if s[i]=='0':
                cur.append(s[i])
                backtrack(i+1)
                cur.pop()
                return
            j=1
            while j<4 and i+j<len(s):
                if int(s[i:i+j])<256:
                    cur.append(s[i:i+j])
                    backtrack(i+j)
                    cur.pop()
                j+=1
        backtrack(0)
        return res
"
3041,python3,restore-ip-addresses,"class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res=[]
        cur=[]
        def backtrack(i):
            if i==len(s) and len(cur)==4:
                res.append(""."".join(cur))
                return
            if len(cur)>4 or i>len(s):
                return
            if s[i]=='0':
                cur.append(s[i])
                backtrack(i+1)
                cur.pop()
                return
            j=0
            while j<4 and i+j<len(s):
                if int(s[i:i+j+1])<256:
                    cur.append(s[i:i+j+1])
                    backtrack(i+j+1)
                    cur.pop()
                j+=1
        backtrack(0)
        return res",None,"class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res=[]
        cur=[]
        def backtrack(i):
            if i==len(s) and len(cur)==4:
                res.append(""."".join(cur))
                return
            if len(cur)>4 or i>len(s):
                return
            if s[i]=='0':
                cur.append(s[i])
                backtrack(i+1)
                cur.pop()
                return
            j=1
            while j<4 and i+j<len(s) and int(s[i:i+j+1])<256:
                cur.append(s[i:i+j+1])
                backtrack(i+j+1)
                cur.pop()
                j+=1
        backtrack(0)
        return res
"
3041,python3,restore-ip-addresses,"class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res=[]
        cur=[]
        def backtrack(i):
            if i==len(s) and len(cur)==4:
                res.append(""."".join(cur))
                return
            if len(cur)>4 or i>len(s):
                return
            if s[i]=='0':
                cur.append(s[i])
                backtrack(i+1)
                cur.pop()
                return
            j=0
            while j<4 and i+j<len(s):
                if int(s[i:i+j+1])<256:
                    cur.append(s[i:i+j+1])
                    backtrack(i+j+1)
                    cur.pop()
                j+=1
        backtrack(0)
        return res",None,"class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res=[]
        cur=[]
        def backtrack(i):
            if i==len(s) and len(cur)==4:
                res.append(""."".join(cur))
                return
            if len(cur)>4 or i>len(s):
                return
            if s[i]=='0':
                cur.append(s[i])
                backtrack(i+1)
                cur.pop()
                return
            j=0
            while j<3 and i+j<len(s):
                if int(s[i:i+j+1])<256:
                    cur.append(s[i:i+j+1])
                    backtrack(i+j+1)
                    cur.pop()
                j+=1
        backtrack(0)
        return res
"
3042,python3,find-players-with-zero-or-one-losses,"class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:

        winners, losers = defaultdict(int), defaultdict(int)

        for match in matches:

            winners[match[0]] += 1
            losers[match[1]] += 1

        res_1, res_2 = [], []

        for k, v in winners.items():
            if k not in losers:
                res_1.append(k)

        for k, v in winners.items(): 
            if v == 1:
                res_2.append(k)

        res_1.sort()
        res_2.sort()
        
        return [ res_1, res_2 ]",None,"class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:

        winners, losers = defaultdict(int), defaultdict(int)

        for match in matches:

            winners[match[0]] += 1
            if match[1] not in winners:
                winners[match[1]] = 0
            losers[match[1]] += 1

        res_1, res_2 = [], []

        for k, v in winners.items():
            if v > 0 and k not in losers:
                res_1.append(k)

        for k, v in winners.items(): 
            if v == 1:
                res_2.append(k)

        res_1.sort()
        res_2.sort()
        
        return [res_1, res_2]
"
3042,python3,find-players-with-zero-or-one-losses,"class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:

        winners, losers = defaultdict(int), defaultdict(int)

        for match in matches:

            winners[match[0]] += 1
            losers[match[1]] += 1

        res_1, res_2 = [], []

        for k, v in winners.items():
            if k not in losers:
                res_1.append(k)

        for k, v in winners.items(): 
            if v == 1:
                res_2.append(k)

        res_1.sort()
        res_2.sort()
        
        return [ res_1, res_2 ]",None,"class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:

        winners, losers = defaultdict(int), defaultdict(int)

        for match in matches:

            winners[match[0]] += 1
            if match[1] not in winners:
                winners[match[1]] = 0
            losers[match[1]] += 1

        res_1, res_2 = [], []

        for k, v in winners.items():
            if v > 0 and k not in losers:
                res_1.append(k)

        for k, v in winners.items(): 
            if v == 1:
                res_2.append(k)

        res_1.sort()
        res_2.sort()

        return [res_1, res_2]
"
3042,python3,find-players-with-zero-or-one-losses,"class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:

        winners, losers = defaultdict(int), defaultdict(int)

        for match in matches:

            winners[match[0]] += 1
            losers[match[1]] += 1

        res_1, res_2 = [], []

        for k, v in winners.items():
            if k not in losers:
                res_1.append(k)

        for k, v in winners.items(): 
            if v == 1:
                res_2.append(k)

        res_1.sort()
        res_2.sort()
        
        return [ res_1, res_2 ]",None,"class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:

        winners, losers = defaultdict(int), defaultdict(int)

        for match in matches:

            winners[match[0]] += 1
            if match[1] not in winners:
                losers[match[1]] += 1

        res_1, res_2 = [], []

        for k, v in winners.items():
            if k not in losers:
                res_1.append(k)

        for k, v in winners.items(): 
            if v == 1:
                res_2.append(k)

        res_1.sort()
        res_2.sort()
        
        return [res_1, res_2]
"
3043,python3,invalid-transactions,"class Solution:
    def invalidTransactions(self, transactions: List[str]) -> List[str]:
        invalid = []
        txn = collections.defaultdict(list)
        
        for trn in transactions:
            name, time, amount, city = trn.split("","")
            txn[name].append([time,amount,city])
        
        for trans in range(len(transactions)):
            name, time, amount, city = transactions[trans].split("","")
            if int(amount) > 10000:
                invalid.append(transactions[trans])
            else:
                for trn in txn[name]:
                    time_i, _, city_i = trn
                    if city != city_i and abs(int(time) - int(time_i)) <= 60:
                        invalid.append(transactions[trans])
                        break

        return invalid",None,"class Solution:
    def invalidTransactions(self, transactions: List[str]) -> List[str]:
        invalid = []
        txn = collections.defaultdict(list)
        
        for trn in transactions:
            name, time, amount, city = trn.split("","")
            txn[name].append([int(time), int(amount), city])
        
        for trans_id, (name, time, amount, city) in enumerate(map(str.split, transactions)):
            if int(amount) > 1000:
                invalid.append(transactions[trans_id])
            else:
                for trn_id, (trn_time, trn_amount, trn_city) in enumerate(txn[name]):
                    if trn_city != city and abs(time - trn_time) <= 60:
                        invalid.append(transactions[trans_id])
                        break

        return invalid
"
3043,python3,invalid-transactions,"class Solution:
    def invalidTransactions(self, transactions: List[str]) -> List[str]:
        invalid = []
        txn = collections.defaultdict(list)
        
        for trn in transactions:
            name, time, amount, city = trn.split("","")
            txn[name].append([time,amount,city])
        
        for trans in range(len(transactions)):
            name, time, amount, city = transactions[trans].split("","")
            if int(amount) > 10000:
                invalid.append(transactions[trans])
            else:
                for trn in txn[name]:
                    time_i, _, city_i = trn
                    if city != city_i and abs(int(time) - int(time_i)) <= 60:
                        invalid.append(transactions[trans])
                        break

        return invalid",None,"class Solution:
    def invalidTransactions(self, transactions: List[str]) -> List[str]:
        invalid = []
        txn = collections.defaultdict(list)
        
        for trn in transactions:
            name, time, amount, city = trn.split("","")
            txn[name].append([int(time), int(amount), city])
        
        for trans in range(len(transactions)):
            name, time, amount, city = transactions[trans].split("","")
            time, amount = int(time), int(amount)
            if amount > 1000:
                invalid.append(transactions[trans])
            else:
                for trn in txn[name]:
                    trn_time, trn_amount, trn_city = trn
                    if trn_city != city and abs(time - trn_time) <= 60:
                        invalid.append(transactions[trans])
                        break

        return invalid
"
3043,python3,invalid-transactions,"class Solution:
    def invalidTransactions(self, transactions: List[str]) -> List[str]:
        invalid = []
        txn = collections.defaultdict(list)
        
        for trn in transactions:
            name, time, amount, city = trn.split("","")
            txn[name].append([time,amount,city])
        
        for trans in range(len(transactions)):
            name, time, amount, city = transactions[trans].split("","")
            if int(amount) > 10000:
                invalid.append(transactions[trans])
            else:
                for trn in txn[name]:
                    time_i, _, city_i = trn
                    if city != city_i and abs(int(time) - int(time_i)) <= 60:
                        invalid.append(transactions[trans])
                        break

        return invalid",None,"class Solution:
    def invalidTransactions(self, transactions: List[str]) -> List[str]:
        invalid = []
        txn = collections.defaultdict(list)
        
        for trn in transactions:
            name, time, amount, city = trn.split("","")
            txn[name].append([int(time), int(amount), city])
        
        for trans in range(len(transactions)):
            name, time, amount, city = transactions[trans].split("","")
            if int(amount) > 1000:
                invalid.append(transactions[trans])
            else:
                for trn in txn[name]:
                    time_i, amount_i, city_i = trn
                    if city != city_i and abs(int(time) - time_i) <= 60:
                        invalid.append(transactions[trans])
                        break

        return invalid
"
3044,python3,binary-search,"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if target not in nums:
            return -1
        
        left, right = 0, len(nums)
        
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        
        return left",None,"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if target not in nums:
            return -1

        left, right = 0, len(nums) - 1

        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1

        return -1
"
3044,python3,binary-search,"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if target not in nums:
            return -1
        
        left, right = 0, len(nums)
        
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        
        return left",None,"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if target not in nums:
            return -1
        
        left, right = 0, len(nums) - 1
        
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        
        if left < len(nums) and nums[left] == target:
            return left
        else:
            return -1
"
3044,python3,binary-search,"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if target not in nums:
            return -1
        
        left, right = 0, len(nums)
        
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        
        return left",None,"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if target not in nums:
            return -1

        left, right = 0, len(nums) - 1

        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1

        return -1
"
3045,python3,sliding-puzzle,"class Solution:
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        def get_neighbors(board):
            neighbors = []
            r, c = 0, 0
            for i in range(2):
                for j in range(3):
                    if board[i][j] == 0:
                        r, c = i, j
            for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                new_r, new_c = r + i, c + j
                if 0 <= new_r < 2 and 0 <= new_c < 3:
                    new_board = [row[:] for row in board]
                    new_board[r][c] = new_board[new_r][new_c]
                    new_board[new_r][new_c] = 0
                    neighbors.append(new_board)
            return neighbors

        queue = deque()
        queue.append((board, 0))
        seen = set()
        seen.add(tuple(tuple(row) for row in board))

        while queue:
            board, moves = queue.popleft()
            if board == [[1, 2, 3], [5, 4, 0]]:      
                return moves
            for neighbor in get_neighbors(board):
                if tuple(tuple(row) for row in neighbor) not in seen:
                    queue.append((neighbor, moves + 1))
                    seen.add(tuple(tuple(row) for row in neighbor))
        return -1",None,"class Solution:
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        def get_neighbors(board):
            neighbors = []
            r, c = 0, 0
            for i in range(2):
                for j in range(3):
                    if board[i][j] == 0:
                        r, c = i, j
            for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                new_r, new_c = r + i, c + j
                if 0 <= new_r < 2 and 0 <= new_c < 3:
                    new_board = [row[:] for row in board]
                    new_board[r][c] = new_board[new_r][new_c]
                    new_board[new_r][new_c] = 0
                    neighbors.append(new_board)
            return neighbors

        queue = deque()
        queue.append((board, 0))
        seen = set()
        seen.add(tuple(tuple(row) for row in board))

        while queue:
            board, moves = queue.popleft()
            if board == [[1, 2, 3], [4, 5, 0]]:
                return moves
            for neighbor in get_neighbors(board):
                if tuple(tuple(row) for row in neighbor) not in seen:
                    queue.append((neighbor, moves + 1))
                    seen.add(tuple(tuple(row) for row in neighbor))
        return -1
"
3045,python3,sliding-puzzle,"class Solution:
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        def get_neighbors(board):
            neighbors = []
            r, c = 0, 0
            for i in range(2):
                for j in range(3):
                    if board[i][j] == 0:
                        r, c = i, j
            for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                new_r, new_c = r + i, c + j
                if 0 <= new_r < 2 and 0 <= new_c < 3:
                    new_board = [row[:] for row in board]
                    new_board[r][c] = new_board[new_r][new_c]
                    new_board[new_r][new_c] = 0
                    neighbors.append(new_board)
            return neighbors

        queue = deque()
        queue.append((board, 0))
        seen = set()
        seen.add(tuple(tuple(row) for row in board))

        while queue:
            board, moves = queue.popleft()
            if board == [[1, 2, 3], [5, 4, 0]]:      
                return moves
            for neighbor in get_neighbors(board):
                if tuple(tuple(row) for row in neighbor) not in seen:
                    queue.append((neighbor, moves + 1))
                    seen.add(tuple(tuple(row) for row in neighbor))
        return -1",None,"class Solution:
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        def get_neighbors(board):
            neighbors = []
            r, c = 0, 0
            for i in range(2):
                for j in range(3):
                    if board[i][j] == 0:
                        r, c = i, j
            for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                new_r, new_c = r + i, c + j
                if 0 <= new_r < 2 and 0 <= new_c < 3:
                    new_board = [row[:] for row in board]
                    new_board[r][c], new_board[new_r][new_c] = new_board[new_r][new_c], new_board[r][c]
                    neighbors.append(new_board)
            return neighbors

        queue = deque()
        queue.append((board, 0))
        seen = set()
        seen.add(tuple(tuple(row) for row in board))

        while queue:
            board, moves = queue.popleft()
            if board == [[1, 2, 3], [4, 5, 0]]:
                return moves
            for neighbor in get_neighbors(board):
                if tuple(tuple(row) for row in neighbor) not in seen:
                    queue.append((neighbor, moves + 1))
                    seen.add(tuple(tuple(row) for row in neighbor))
        return -1
"
3045,python3,sliding-puzzle,"class Solution:
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        def get_neighbors(board):
            neighbors = []
            r, c = 0, 0
            for i in range(2):
                for j in range(3):
                    if board[i][j] == 0:
                        r, c = i, j
            for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                new_r, new_c = r + i, c + j
                if 0 <= new_r < 2 and 0 <= new_c < 3:
                    new_board = [row[:] for row in board]
                    new_board[r][c] = new_board[new_r][new_c]
                    new_board[new_r][new_c] = 0
                    neighbors.append(new_board)
            return neighbors

        queue = deque()
        queue.append((board, 0))
        seen = set()
        seen.add(tuple(tuple(row) for row in board))

        while queue:
            board, moves = queue.popleft()
            if board == [[1, 2, 3], [5, 4, 0]]:      
                return moves
            for neighbor in get_neighbors(board):
                if tuple(tuple(row) for row in neighbor) not in seen:
                    queue.append((neighbor, moves + 1))
                    seen.add(tuple(tuple(row) for row in neighbor))
        return -1",None,"class Solution:
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        def get_neighbors(board):
            neighbors = []
            r, c = 0, 0
            for i in range(2):
                for j in range(3):
                    if board[i][j] == 0:
                        r, c = i, j
            for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                new_r, new_c = r + i, c + j
                if 0 <= new_r < 2 and 0 <= new_c < 3:
                    new_board = [row[:] for row in board]
                    new_board[r][c] = new_board[new_r][new_c]
                    new_board[new_r][new_c] = 0
                    neighbors.append(new_board)
            return neighbors

        queue = deque()
        queue.append((board, 0))
        seen = set()
        seen.add(tuple(tuple(row) for row in board))

        while queue:
            board, moves = queue.popleft()
            if board == [[1, 2, 3], [4, 5, 0]]:
                return moves
            for neighbor in get_neighbors(board):
                if tuple(tuple(row) for row in neighbor) not in seen:
                    queue.append((neighbor, moves + 1))
                    seen.add(tuple(tuple(row) for row in neighbor))
        return -1
"
3046,python3,partition-array-into-three-parts-with-equal-sum,"class Solution:
    def canThreePartsEqualSum(self, arr: List[int]) -> bool:
        total = sum(arr)
        each_sum = total//3
        if total % 3 != 0: return False
        sumi = count = 0
        for x in arr:
            sumi += x
            if sumi == each_sum:
                sumi = 0
                count += 1
            if count == 2:
                return True
        return False",None,"class Solution:
    def canThreePartsEqualSum(self, arr: List[int]) -> bool:
        total = sum(arr)
        each_sum = total//3
        if total % 3 != 0: return False
        sumi = 0
        count = 0
        for x in arr:
            sumi += x
            if sumi == each_sum:
                sumi = 0
                count += 1
        return count == 3
"
3046,python3,partition-array-into-three-parts-with-equal-sum,"class Solution:
    def canThreePartsEqualSum(self, arr: List[int]) -> bool:
        total = sum(arr)
        each_sum = total//3
        if total % 3 != 0: return False
        sumi = count = 0
        for x in arr:
            sumi += x
            if sumi == each_sum:
                sumi = 0
                count += 1
            if count == 2:
                return True
        return False",None,"class Solution:
    def canThreePartsEqualSum(self, arr: List[int]) -> bool:
        total = sum(arr)
        each_sum = total//3
        if total % 3 != 0: return False
        sumi = count = 0
        for x in arr:
            sumi += x
            if sumi == each_sum:
                sumi = 0
                count += 1
        return count == 3
"
3046,python3,partition-array-into-three-parts-with-equal-sum,"class Solution:
    def canThreePartsEqualSum(self, arr: List[int]) -> bool:
        total = sum(arr)
        each_sum = total//3
        if total % 3 != 0: return False
        sumi = count = 0
        for x in arr:
            sumi += x
            if sumi == each_sum:
                sumi = 0
                count += 1
            if count == 2:
                return True
        return False",None,"class Solution:
    def canThreePartsEqualSum(self, arr: List[int]) -> bool:
        total = sum(arr)
        each_sum = total//3
        if total % 3 != 0: return False
        sumi = 0
        count = 0
        for x in arr:
            sumi += x
            if sumi == each_sum:
                sumi = 0
                count += 1
        return count == 3
"
3047,python3,palindrome-pairs,"class Solution:
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        backward, res = {}, []
        for i, word in enumerate(words):
            backward[word[::-1]] = i

        for i, word in enumerate(words):
            
            if word in backward and backward[word] != i:
                res.append([i, backward[word]])
                
            if word != """" and """" in backward and word == word[::-1]:
                res.append([i, backward[""""]])
                res.append([backward[""""], i])
                
            for j in range(len(word)):
                if word[j:] in backward and word[:j] == word[j::-1]:
                    res.append([backward[word[j:]], i])
                if word[:j] in backward and word[j:] == word[:j-1:-1]:
                    res.append([i, backward[word[:j]]])
                    
        return res",None,"class Solution:
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        backward, res = {}, []
        for i, word in enumerate(words):
            backward[word[::-1]] = i

        for i, word in enumerate(words):
            if word in backward and backward[word] != i:
                res.append([i, backward[word]])

            if word != """" and """" in backward and word == word[::-1]:
                res.append([i, backward[""""]])

            for j in range(len(word)):
                prefix = word[:j]
                suffix = word[j:]
                if suffix[::-1] in backward and prefix == backward[suffix[::-1]][::-1]:
                    res.append([backward[suffix[::-1]], i])
                
                if prefix[::-1] in backward and suffix == backward[prefix[::-1]][::-1]:
                    res.append([i, backward[prefix[::-1]]])

        return res
"
3047,python3,palindrome-pairs,"class Solution:
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        backward, res = {}, []
        for i, word in enumerate(words):
            backward[word[::-1]] = i

        for i, word in enumerate(words):
            
            if word in backward and backward[word] != i:
                res.append([i, backward[word]])
                
            if word != """" and """" in backward and word == word[::-1]:
                res.append([i, backward[""""]])
                res.append([backward[""""], i])
                
            for j in range(len(word)):
                if word[j:] in backward and word[:j] == word[j::-1]:
                    res.append([backward[word[j:]], i])
                if word[:j] in backward and word[j:] == word[:j-1:-1]:
                    res.append([i, backward[word[:j]]])
                    
        return res",None,"class Solution:
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        backward, res = {}, []
        for i, word in enumerate(words):
            backward[word[::-1]] = i

        for i, word in enumerate(words):
            if word in backward and backward[word] != i:
                res.append([i, backward[word]])

            if word != """" and """" in backward and word == word[::-1]:
                res.append([i, backward[""""]])
                res.append([backward[""""], i])

            for j in range(len(word)+1):
                prefix = word[:j]
                suffix = word[j:][::-1]
                if suffix in backward and prefix == prefix[::-1]:
                    res.append([backward[suffix], i])
                if prefix in backward and suffix == suffix[::-1]:
                    res.append([i, backward[prefix]])
                    
        return res
"
3047,python3,palindrome-pairs,"class Solution:
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        backward, res = {}, []
        for i, word in enumerate(words):
            backward[word[::-1]] = i

        for i, word in enumerate(words):
            
            if word in backward and backward[word] != i:
                res.append([i, backward[word]])
                
            if word != """" and """" in backward and word == word[::-1]:
                res.append([i, backward[""""]])
                res.append([backward[""""], i])
                
            for j in range(len(word)):
                if word[j:] in backward and word[:j] == word[j::-1]:
                    res.append([backward[word[j:]], i])
                if word[:j] in backward and word[j:] == word[:j-1:-1]:
                    res.append([i, backward[word[:j]]])
                    
        return res",None,"class Solution:
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        backward, res = {}, []
        for i, word in enumerate(words):
            backward[word[::-1]] = i

        for i, word in enumerate(words):
            if word in backward and backward[word] != i:
                res.append([i, backward[word]])

            if word == word[::-1] and len(word) > 0 and len(res) > 0 and res[-1] not in [[i, i], [backward[word], i]]:
                res.append([i, i])

            for j in range(len(word)):
                if word[j:] in backward and word[:j] == word[j::-1]:
                    res.append([backward[word[j:]], i])
                if word[:j] in backward and word[j:] == word[:j-1:-1]:
                    res.append([i, backward[word[:j]]])
                    
        return res
"
3048,python3,minimum-bit-flips-to-convert-number,"class Solution:
    def minBitFlips(self, start: int, goal: int) -> int:
        s=bin(start)[2:].zfill(50)
        g=bin(goal)[2:].zfill(50)
        count=0
        for i in range(51):
            if s[i]!=g[i]:
                count+=1
        return count",None,"class Solution:
    def minBitFlips(self, start: int, goal: int) -> int:
        s = bin(start)[2:]
        g = bin(goal)[2:]
        count = 0
        for i in range(max(len(s), len(g))):
            if i >= len(s):
                s = '0' * (i - len(s) + 1) + s
            if i >= len(g):
                g = '0' * (i - len(g) + 1) + g
            if s[i] != g[i]:
                count += 1
        return count
"
3048,python3,minimum-bit-flips-to-convert-number,"class Solution:
    def minBitFlips(self, start: int, goal: int) -> int:
        s=bin(start)[2:].zfill(50)
        g=bin(goal)[2:].zfill(50)
        count=0
        for i in range(51):
            if s[i]!=g[i]:
                count+=1
        return count",None,"class Solution:
    def minBitFlips(self, start: int, goal: int) -> int:
        s = bin(start)[2:]
        g = bin(goal)[2:]
        count = 0
        # Ensure that the lengths of s and g are equal
        max_len = max(len(s), len(g))
        s = s.zfill(max_len)
        g = g.zfill(max_len)

        for i in range(max_len):
            if s[i] != g[i]:
                count += 1

        return count
"
3048,python3,minimum-bit-flips-to-convert-number,"class Solution:
    def minBitFlips(self, start: int, goal: int) -> int:
        s=bin(start)[2:].zfill(50)
        g=bin(goal)[2:].zfill(50)
        count=0
        for i in range(51):
            if s[i]!=g[i]:
                count+=1
        return count",None,"class Solution:
    def minBitFlips(self, start: int, goal: int) -> int:
        s = bin(start)[2:]
        g = bin(goal)[2:]
        count = 0
        # Add leading zeros to the shorter string
        if len(s) < len(g):
            s = s.zfill(len(g))
        elif len(g) < len(s):
            g = g.zfill(len(s))
        for i in range(len(s)):
            if s[i] != g[i]:
                count += 1
        return count
"
3049,python3,maximum-profit-of-operating-a-centennial-wheel,"class Solution:
    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
        maxProfit=-1
        ans=i=curRounds=curCustomers=rem=0
        while i<len(customers) or rem:
            if i<len(customers):
                rem+=customers[i]
                i+=1
            curRounds+=1
            if rem-4>=0:
                rem-=4
                curCustomers+=4
            else:
                curCustomers+=rem
                rem=0
            curProfit=(curCustomers*boardingCost)-(curRounds*runningCost)
            if curProfit>=maxProfit:
                maxProfit=curProfit
                ans=curRounds
        return -1 if maxProfit<=0 else ans",None,"class Solution:
    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
        maxProfit = -1
        ans = 0
        curRounds = curCustomers = rem = 0
        for i in range(len(customers) + 1):
            if i < len(customers):
                rem += customers[i]
            curRounds += 1
            if rem >= 4:
                rem -= 4
                curCustomers += 4
            else:
                curCustomers += rem
                rem = 0
            curProfit = (curCustomers * boardingCost) - (curRounds * runningCost)
            if curProfit >= maxProfit:
                maxProfit = curProfit
                ans = curRounds
        return ans
"
3049,python3,maximum-profit-of-operating-a-centennial-wheel,"class Solution:
    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
        maxProfit=-1
        ans=i=curRounds=curCustomers=rem=0
        while i<len(customers) or rem:
            if i<len(customers):
                rem+=customers[i]
                i+=1
            curRounds+=1
            if rem-4>=0:
                rem-=4
                curCustomers+=4
            else:
                curCustomers+=rem
                rem=0
            curProfit=(curCustomers*boardingCost)-(curRounds*runningCost)
            if curProfit>=maxProfit:
                maxProfit=curProfit
                ans=curRounds
        return -1 if maxProfit<=0 else ans",None,"class Solution:
    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
        maxProfit = -1
        ans = i = curRounds = curCustomers = rem = 0
        while i < len(customers) or rem > 0:
            if i < len(customers):
                rem += customers[i]
                i += 1
            curRounds += 1
            if rem >= 4:
                rem -= 4
                curCustomers += 4
            else:
                curCustomers += rem
                rem = 0
            curProfit = (curCustomers * boardingCost) - (curRounds * runningCost)
            if curProfit >= maxProfit:
                maxProfit = curProfit
                ans = curRounds
        return ans if maxProfit > 0 else -1
"
3049,python3,maximum-profit-of-operating-a-centennial-wheel,"class Solution:
    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
        maxProfit=-1
        ans=i=curRounds=curCustomers=rem=0
        while i<len(customers) or rem:
            if i<len(customers):
                rem+=customers[i]
                i+=1
            curRounds+=1
            if rem-4>=0:
                rem-=4
                curCustomers+=4
            else:
                curCustomers+=rem
                rem=0
            curProfit=(curCustomers*boardingCost)-(curRounds*runningCost)
            if curProfit>=maxProfit:
                maxProfit=curProfit
                ans=curRounds
        return -1 if maxProfit<=0 else ans",None,"class Solution:
    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
        maxProfit = -1
        ans = 0
        cur\_rounds = cur\_customers = rem = 0
        for i in range(len(customers)):
            rem += customers[i]
            cur\_rounds += 1
            if rem >= 4:
                rem -= 4
                cur\_customers += 4
            else:
                cur\_customers += rem
                rem = 0
            cur\_profit = (cur\_customers * boardingCost) - (cur\_rounds * runningCost)
            if cur\_profit > maxProfit:
                maxProfit = cur\_profit
                ans = cur\_rounds
        return -1 if maxProfit <= 0 else ans
"
3050,python3,make-array-zero-by-subtracting-equal-amounts,"class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        uniq_non_zero = set()
        for num in nums:
            if num != 0:
                continue
            uniq_non_zero.add(num)
        return len(uniq_non_zero)",None,"class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        uniq_non_zero = set()
        for num in nums:
            if num > 0:
                uniq_non_zero.add(num)
        return len(uniq_non_zero)
"
3050,python3,make-array-zero-by-subtracting-equal-amounts,"class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        uniq_non_zero = set()
        for num in nums:
            if num != 0:
                continue
            uniq_non_zero.add(num)
        return len(uniq_non_zero)",None,"class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        uniq_non_zero = set()
        for num in nums:
            if num > 0:
                uniq_non_zero.add(num)
        return len(uniq_non_zero)
"
3050,python3,make-array-zero-by-subtracting-equal-amounts,"class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        uniq_non_zero = set()
        for num in nums:
            if num != 0:
                continue
            uniq_non_zero.add(num)
        return len(uniq_non_zero)",None,"class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        uniq_non_zero = set()
        for num in nums:
            if num > 0:
                uniq_non_zero.add(num)
        return len(uniq_non_zero)
"
3051,python3,next-greater-element-i,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        out=[]
        for i in range(0,len(nums1)):
            if(nums2.index(nums1[i])==len(nums2)-1):
                out.append(-1)
            else:
                j=nums2.index(nums1[i])+1
                while(1):
                    if(nums1[i]<nums2[j]):
                        out.append(nums2[j])
                        break
                    if(j==len(nums2)):
                        out.append(-1)
                        break
                    j+=1
        return out",None,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        out = [-1] * len(nums1)
        nums2_map = {num: i for i, num in enumerate(nums2)}
        stack = []
        for i, num in enumerate(nums2):
            while stack and num > stack[-1]:
                top = stack.pop()
                idx = nums2_map[top]
                out[idx] = num
            stack.append(num)
        return out
"
3051,python3,next-greater-element-i,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        out=[]
        for i in range(0,len(nums1)):
            if(nums2.index(nums1[i])==len(nums2)-1):
                out.append(-1)
            else:
                j=nums2.index(nums1[i])+1
                while(1):
                    if(nums1[i]<nums2[j]):
                        out.append(nums2[j])
                        break
                    if(j==len(nums2)):
                        out.append(-1)
                        break
                    j+=1
        return out",None,"class Solution:
    def nextGreaterElement(self, nums1, nums2):
        out = []
        for num in nums1:
            current_index = nums2.index(num)
            if current_index == len(nums2) - 1:
                out.append(-1)
            else:
                next_num = nums2[current_index + 1:]
                if num < max(next_num):
                    next_index = next_num.index(max(next_num)) + current_index + 1
                    out.append(nums2[next_index])
                else:
                    out.append(-1)
        return out
"
3051,python3,next-greater-element-i,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        out=[]
        for i in range(0,len(nums1)):
            if(nums2.index(nums1[i])==len(nums2)-1):
                out.append(-1)
            else:
                j=nums2.index(nums1[i])+1
                while(1):
                    if(nums1[i]<nums2[j]):
                        out.append(nums2[j])
                        break
                    if(j==len(nums2)):
                        out.append(-1)
                        break
                    j+=1
        return out",None,"class Solution:
    def nextGreaterElement(self, nums1, nums2):
        out = []
        for num in nums1:
            idx = nums2.index(num)
            next_greater = -1
            for j in range(idx + 1, len(nums2)):
                if nums2[j] > num:
                    next_greater = nums2[j]
                    break
            out.append(next_greater)
        return out
"
3052,python3,binary-tree-level-order-traversal-ii,"class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        def checkReverse(ans):
            l,r = 0,len(ans)-1
            while l<=r:
                ans[l],ans[r] = ans[r],ans[l]
                l+=1
                r-=1
            return ans

        if not root: return None
        q,ans = [root],[]
        while q:
            n,l = len(q),[]
            for i in range(n):
                curr = q.pop(0)
                l.append(curr.val)
                q.append(curr.left)
                q.append(curr.right)

            ans.append(l)
        return checkReverse(ans)",None,"class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root: return []
        q,ans = [root],[]
        while q:
            l = []
            for i in range(len(q)):
                curr = q.pop(0)
                l.append(curr.val)
                if curr.left:
                    q.append(curr.left)
                if curr.right:
                    q.append(curr.right)
            ans.insert(0,l)
        return ans
"
3052,python3,binary-tree-level-order-traversal-ii,"class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        def checkReverse(ans):
            l,r = 0,len(ans)-1
            while l<=r:
                ans[l],ans[r] = ans[r],ans[l]
                l+=1
                r-=1
            return ans

        if not root: return None
        q,ans = [root],[]
        while q:
            n,l = len(q),[]
            for i in range(n):
                curr = q.pop(0)
                l.append(curr.val)
                q.append(curr.left)
                q.append(curr.right)

            ans.append(l)
        return checkReverse(ans)",None,"class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root: return []
        q,ans = [root],[]
        while q:
            l = []
            for i in range(len(q)):
                curr = q.pop(0)
                l.append(curr.val)
                if curr.left: q.append(curr.left)
                if curr.right: q.append(curr.right)
            ans.append(l)
        return ans[::-1]
"
3052,python3,binary-tree-level-order-traversal-ii,"class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        def checkReverse(ans):
            l,r = 0,len(ans)-1
            while l<=r:
                ans[l],ans[r] = ans[r],ans[l]
                l+=1
                r-=1
            return ans

        if not root: return None
        q,ans = [root],[]
        while q:
            n,l = len(q),[]
            for i in range(n):
                curr = q.pop(0)
                l.append(curr.val)
                q.append(curr.left)
                q.append(curr.right)

            ans.append(l)
        return checkReverse(ans)",None,"class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        def checkReverse(ans):
            l,r = 0,len(ans)-1
            while l<r:
                ans[l],ans[r] = ans[r],ans[l]
                l+=1
                r-=1

        if not root: return []
        q,ans = [root],[]
        while q:
            n,l = len(q),[]
            for i in range(n):
                curr = q.pop(0)
                l.append(curr.val)
                if curr.left:
                    q.append(curr.left)
                if curr.right:
                    q.append(curr.right)

            ans.append(l)
        return checkReverse(ans[::-1])
"
3053,python3,make-k-subarray-sums-equal,"class Solution:
    def makeSubKSumEqual(self, A: List[int], K: int) -> int:
        lA = len(A)
        g = gcd(lA, K)
        retV = 0
        for i in range(g):
            med = int(median(A[i:g]))
            retV += sum(abs(a-med) for a in A[i:g])
            
        return retV",None,"class Solution:
    def makeSubKSumEqual(self, A: List[int], K: int) -> int:
        lA = len(A)
        g = gcd(lA, K)
        retV = 0
        for i in range(g):
            med = int(sum(A[i:g]) / g)
            retV += sum(abs(a-med) for a in A[i:g])
        return retV
"
3053,python3,make-k-subarray-sums-equal,"class Solution:
    def makeSubKSumEqual(self, A: List[int], K: int) -> int:
        lA = len(A)
        g = gcd(lA, K)
        retV = 0
        for i in range(g):
            med = int(median(A[i:g]))
            retV += sum(abs(a-med) for a in A[i:g])
            
        return retV",None,"import math

class Solution:
    def makeSubKSumEqual(self, A: List[int], K: int) -> int:
        lA = len(A)
        g = math.gcd(lA, K)
        retV = 0
        for i in range(g):
            med = int(sum(A[i:g])/g)
            retV += sum(abs(a-med) for a in A[i:g])
        return retV
"
3053,python3,make-k-subarray-sums-equal,"class Solution:
    def makeSubKSumEqual(self, A: List[int], K: int) -> int:
        lA = len(A)
        g = gcd(lA, K)
        retV = 0
        for i in range(g):
            med = int(median(A[i:g]))
            retV += sum(abs(a-med) for a in A[i:g])
            
        return retV",None,"class Solution:
    def makeSubKSumEqual(self, A: List[int], K: int) -> int:
        lA = len(A)
        g = gcd(lA, K)
        retV = 0
        for i in range(g):
            med = int(statistics.median(A[i:lA:g]))
            retV += sum(abs(a-med) for a in A[i:lA:g])
        return retV // g
"
3054,python3,node-with-highest-edge-score,"class Solution:
    def edgeScore(self, edges: List[int]) -> int:
        n=len(edges)
        sc=[0]*n
        mx=0
        ans=0
        for i in range(n):
            sc[edges[i]]+=i
            if sc[edges[i]]>mx and i != n-1: 
                mx=sc[edges[i]]
                ans=edges[i]
            elif sc[edges[i]]==mx:
                if ans>edges[i]:
                    ans=edges[i]
        return ans",None,"class Solution:
    def edgeScore(self, edges: List[int]) -> int:
        n = len(edges)
        sc = [0] * n
        mx = 0
        ans = 0
        for i in range(n):
            sc[edges[i]] += i
        mx = max(sc)
        for i in range(n):
            if sc[i] == mx:
                ans = i
        return ans
"
3054,python3,node-with-highest-edge-score,"class Solution:
    def edgeScore(self, edges: List[int]) -> int:
        n=len(edges)
        sc=[0]*n
        mx=0
        ans=0
        for i in range(n):
            sc[edges[i]]+=i
            if sc[edges[i]]>mx and i != n-1: 
                mx=sc[edges[i]]
                ans=edges[i]
            elif sc[edges[i]]==mx:
                if ans>edges[i]:
                    ans=edges[i]
        return ans",None,"class Solution:
    def edgeScore(self, edges: List[int]) -> int:
        n = len(edges)
        sc = [0] * n
        mx = 0
        ans = 0
        for i in range(n):
            sc[edges[i]] += i
        mx = max(sc)
        for i in range(n):
            if sc[i] == mx:
                ans = i
                break
        return ans
"
3054,python3,node-with-highest-edge-score,"class Solution:
    def edgeScore(self, edges: List[int]) -> int:
        n=len(edges)
        sc=[0]*n
        mx=0
        ans=0
        for i in range(n):
            sc[edges[i]]+=i
            if sc[edges[i]]>mx and i != n-1: 
                mx=sc[edges[i]]
                ans=edges[i]
            elif sc[edges[i]]==mx:
                if ans>edges[i]:
                    ans=edges[i]
        return ans",None,"class Solution:
    def edgeScore(self, edges: List[int]) -> int:
        n=len(edges)
        sc=[0]*n
        mx=0
        ans=0
        for i in range(n):
            sc[edges[i]]+=i
            if sc[edges[i]] > mx:
                mx = sc[edges[i]]
                ans = edges[i]
            elif sc[edges[i]] == mx:
                ans = min(ans, edges[i])
        return ans
"
3055,python3,minimum-cost-to-make-at-least-one-valid-path-in-a-grid,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:

        m, n, cost, queue = len(grid), len(grid[0]), 0, deque()
        M, N = range(m), range(n)

        seen = lambda x,y : not x in M or y not in N or not grid[x][y]
        dir = ((),(0,1), (0,-1), (1,0), (-1,0))

        def dfs(x: int,y: int)->None:
            while not seen(x,y):
                (dx,dy), grid[x][y] = dir[grid[x][y]], None
                queue.append((x,y))
                x,y = x+dx, y+dy
            return

        dfs(0, 0)
        cost += 1

        while queue:
            if (m-1, n-1) in queue: return cost
            cost +=1 
            q = len(queue)

            for _ in range(q):
                x, y = queue.popleft()
                for dx,dy in dir[1:]:
                    dfs(x+dx, y+dy)",None,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:

        m, n, cost, queue = len(grid), len(grid[0]), 0, deque()
        M, N = range(m), range(n)

        seen = lambda x,y : not x in M or y not in N or not grid[x][y]
        dir = ((),(0,1), (0,-1), (1,0), (-1,0))

        def dfs(x: int,y: int)->None:
            if not seen(x,y):
                (dx,dy), grid[x][y] = dir[grid[x][y]], None
                queue.append((x,y))
                dfs(x+dx, y+dy)
            return

        dfs(0, 0)
        cost += 1

        while queue:
            if (m-1, n-1) in queue: return cost
            cost +=1 
            q = len(queue)

            for _ in range(q):
                x, y = queue.popleft()
                for dx,dy in dir[1:]:
                    dfs(x+dx, y+dy)
"
3055,python3,minimum-cost-to-make-at-least-one-valid-path-in-a-grid,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:

        m, n, cost, queue = len(grid), len(grid[0]), 0, deque()
        M, N = range(m), range(n)

        seen = lambda x,y : not x in M or y not in N or not grid[x][y]
        dir = ((),(0,1), (0,-1), (1,0), (-1,0))

        def dfs(x: int,y: int)->None:
            while not seen(x,y):
                (dx,dy), grid[x][y] = dir[grid[x][y]], None
                queue.append((x,y))
                x,y = x+dx, y+dy
            return

        dfs(0, 0)
        cost += 1

        while queue:
            if (m-1, n-1) in queue: return cost
            cost +=1 
            q = len(queue)

            for _ in range(q):
                x, y = queue.popleft()
                for dx,dy in dir[1:]:
                    dfs(x+dx, y+dy)",None,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:

        m, n, cost, queue = len(grid), len(grid[0]), 0, deque()
        M, N = range(m), range(n)

        seen = lambda x,y : x < 0 or y < 0 or x >= m or y >= n or grid[x][y] == 0
        dir = ((),(0,1), (0,-1), (1,0), (-1,0))

        def dfs(x: int,y: int)->None:
            if (x, y) == (m-1, n-1):
                return
            grid[x][y] = 0
            for dx,dy in dir[1:]:
                dfs(x+dx, y+dy)

        dfs(0, 0)
        cost += 1

        while queue:
            if (m-1, n-1) in queue: return cost
            cost +=1 
            q = len(queue)

            for _ in range(q):
                x, y = queue.popleft()
                for dx,dy in dir[1:]:
                    nx, ny = x+dx, y+dy
                    if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:
                        queue.append((nx, ny))
                        grid[nx][ny] = 0

        return cost
"
3055,python3,minimum-cost-to-make-at-least-one-valid-path-in-a-grid,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:

        m, n, cost, queue = len(grid), len(grid[0]), 0, deque()
        M, N = range(m), range(n)

        seen = lambda x,y : not x in M or y not in N or not grid[x][y]
        dir = ((),(0,1), (0,-1), (1,0), (-1,0))

        def dfs(x: int,y: int)->None:
            while not seen(x,y):
                (dx,dy), grid[x][y] = dir[grid[x][y]], None
                queue.append((x,y))
                x,y = x+dx, y+dy
            return

        dfs(0, 0)
        cost += 1

        while queue:
            if (m-1, n-1) in queue: return cost
            cost +=1 
            q = len(queue)

            for _ in range(q):
                x, y = queue.popleft()
                for dx,dy in dir[1:]:
                    dfs(x+dx, y+dy)",None,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:

        m, n, cost, queue = len(grid), len(grid[0]), 0, deque()
        M, N = range(m), range(n)

        seen = lambda x,y : x<0 or y<0 or x>=m or y>=n or not grid[x][y]
        dir = ((),(0,1), (0,-1), (1,0), (-1,0))

        def dfs(x: int,y: int)->None:
            if (x,y) == (m-1, n-1): return
            grid[x][y] = None
            for dx,dy in dir[1:]:
                if not seen(x+dx, y+dy):
                    dfs(x+dx, y+dy)
            queue.append((x,y))

        dfs(0, 0)
        cost += 1

        while queue:
            cost +=1 
            q = len(queue)

            for _ in range(q):
                x, y = queue.popleft()
                for dx,dy in dir[1:]:
                    if not seen(x+dx, y+dy):
                        dfs(x+dx, y+dy)

        return cost
"
3056,python3,grid-game,"class Solution:
    def gridGame(self, grid: List[List[int]]) -> int: 
        result = float(""inf"")
        left,right = 0,sum(grid[0])

        for a,b in zip(grid[1],grid[0]):
            right-=a

            result = min(result,max(left,right))
            left+=b
        
        return result",None,"class Solution:
    def gridGame(self, grid: List[List[int]]) -> int: 
        result = float(""inf"")
        left,right = 0,sum(grid[0])

        for a,b in zip(grid[1],grid[0]):
            right-=a
            result = min(result,max(left,right))
            left+=b

        return result
"
3056,python3,grid-game,"class Solution:
    def gridGame(self, grid: List[List[int]]) -> int: 
        result = float(""inf"")
        left,right = 0,sum(grid[0])

        for a,b in zip(grid[1],grid[0]):
            right-=a

            result = min(result,max(left,right))
            left+=b
        
        return result",None,"class Solution:
    def gridGame(self, grid: List[List[int]]) -> int: 
        result = float(""inf"")
        left,right = 0,sum(grid[0])

        for a,b in zip(grid[1],grid[0]):
            right-=a
            if left < right:
                left, right = right, left
            result = min(result, right)
            left+=b
        
        return result
"
3056,python3,grid-game,"class Solution:
    def gridGame(self, grid: List[List[int]]) -> int: 
        result = float(""inf"")
        left,right = 0,sum(grid[0])

        for a,b in zip(grid[1],grid[0]):
            right-=a

            result = min(result,max(left,right))
            left+=b
        
        return result",None,"class Solution:
    def gridGame(self, grid: List[List[int]]) -> int: 
        result = float(""inf"")
        left,right = 0,sum(grid[0])

        for a,b in zip(grid[1],grid[0]):
            right-=a
            if left < right:
                left, right = right, left
            result = min(result, right)
            left+=b
        
        return result
"
3057,python3,check-if-point-is-reachable,"class Solution:
    def isReachable(self, targetX: int, targetY: int) -> bool:
        def gcd(a, b):
            while b:
                a, b=b, a%b
            return a
        d=gcd(targetX, targetY)
        while d!=0:
            if d&1:
                return False
            d>>=1
        return True",None,"class Solution:
    def isReachable(self, targetX: int, targetY: int) -> bool:
        def valid_move(x, y):
            return (x, y - x), (x - y, y), (2 * x, y), (x, 2 * y)

        def gcd(a, b):
            while b:
                a, b = b, a % b
            return a

        d = gcd(targetX, targetY)
        if d != 0 and (targetX % d != 0 or targetY % d != 0):
            return False

        queue = [(1, 1)]
        visited = set()
        visited.add((1, 1))

        while queue:
            x, y = queue.pop(0)

            if x == targetX and y == targetY:
                return True

            for move in valid_move(x, y):
                nx, ny = move
                if (nx, ny) not in visited:
                    visited.add((nx, ny))
                    queue.append((nx, ny))

        return False
"
3057,python3,check-if-point-is-reachable,"class Solution:
    def isReachable(self, targetX: int, targetY: int) -> bool:
        def gcd(a, b):
            while b:
                a, b=b, a%b
            return a
        d=gcd(targetX, targetY)
        while d!=0:
            if d&1:
                return False
            d>>=1
        return True",None,"class Solution:
    def isReachable(self, targetX: int, targetY: int) -> bool:
        def gcd(a, b):
            while b:
                a, b = b, a % b
            return a
        d = gcd(targetX, targetY)
        return d == 0 or (targetX % d == 0 and targetY % d == 0)
"
3057,python3,check-if-point-is-reachable,"class Solution:
    def isReachable(self, targetX: int, targetY: int) -> bool:
        def gcd(a, b):
            while b:
                a, b=b, a%b
            return a
        d=gcd(targetX, targetY)
        while d!=0:
            if d&1:
                return False
            d>>=1
        return True",None,"class Solution:
    def isReachable(self, targetX: int, targetY: int) -> bool:
        def valid_move(x, y):
            return (x, y - x), (x - y, y), (2 * x, y), (x, 2 * y)

        def gcd(a, b):
            while b:
                a, b = b, a % b
            return a

        d = gcd(targetX, targetY)
        if d != 0 and (targetX % d != 0 or targetY % d != 0):
            return False

        moves = set()
        for x, y in valid_move(1, 1):
            moves.add((x, y))

        x, y = 1, 1
        while x != targetX or y != targetY:
            if (x, y) in moves:
                x, y = x + targetX, y + targetY
            else:
                return False

        return True
"
3058,python3,average-value-of-even-numbers-that-are-divisible-by-three,"class Solution:
    def averageValue(self, nums: List[int]) -> int:
        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 == 0]) > 1 else 0",None,"class Solution:
    def averageValue(self, nums: List[int]) -> int:
        lst = [num for num in nums if num % 6 == 0]
        return int(sum(lst) / len(lst)) if lst else 0
"
3058,python3,average-value-of-even-numbers-that-are-divisible-by-three,"class Solution:
    def averageValue(self, nums: List[int]) -> int:
        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 == 0]) > 1 else 0",None,"class Solution:
    def averageValue(self, nums: List[int]) -> int:
        lst = [num for num in nums if num % 6 == 0]
        return int(sum(lst) / len(lst)) if lst else 0
"
3058,python3,average-value-of-even-numbers-that-are-divisible-by-three,"class Solution:
    def averageValue(self, nums: List[int]) -> int:
        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 == 0]) > 1 else 0",None,"class Solution:
    def averageValue(self, nums: List[int]) -> int:
        lst = [num for num in nums if num % 6 == 0]
        return int(sum(lst) / len(lst)) if lst else 0
"
3059,python3,delete-greatest-value-in-each-row,"class Solution:
    def deleteGreatestValue(self, grid: List[List[int]]) -> int:
        for i in range(0, len(grid)):
            grid[i].sort()
        n = len(grid[0])
        res = 0
        for j in range(0, n+1):
            ans = 0
            for i in range(0, len(grid)):
                ans = max(ans, grid[i].pop())
            res += ans
            
        return res",None,"class Solution:
    def deleteGreatestValue(self, grid: List[List[int]]) -> int:
        for i in range(0, len(grid)):
            grid[i].sort(reverse=True)
        n = len(grid[0])
        res = 0
        for j in range(0, n):
            ans = 0
            for i in range(0, len(grid)):
                ans = max(ans, grid[i].pop())
            res += ans

        return res
"
3059,python3,delete-greatest-value-in-each-row,"class Solution:
    def deleteGreatestValue(self, grid: List[List[int]]) -> int:
        for i in range(0, len(grid)):
            grid[i].sort()
        n = len(grid[0])
        res = 0
        for j in range(0, n+1):
            ans = 0
            for i in range(0, len(grid)):
                ans = max(ans, grid[i].pop())
            res += ans
            
        return res",None,"class Solution:
    def deleteGreatestValue(self, grid: List[List[int]]) -> int:
        for row in grid:
            row.sort()
        n = len(grid[0])
        res = 0
        for _ in range(n):
            ans = max(row.pop() for row in grid)
            res += ans

        return res
"
3059,python3,delete-greatest-value-in-each-row,"class Solution:
    def deleteGreatestValue(self, grid: List[List[int]]) -> int:
        for i in range(0, len(grid)):
            grid[i].sort()
        n = len(grid[0])
        res = 0
        for j in range(0, n+1):
            ans = 0
            for i in range(0, len(grid)):
                ans = max(ans, grid[i].pop())
            res += ans
            
        return res",None,"class Solution:
    def deleteGreatestValue(self, grid: List[List[int]]) -> int:
        for row in grid:
            row.sort(reverse=True)
        n = len(grid[0])
        res = 0
        for _ in range(n):
            max_val = max(row.pop() for row in grid)
            res += max_val
        return res
"
3060,python3,minimum-time-to-complete-trips,"class Solution:
    def satisfiesTrip(self,mid, time, totalTrip):
        trip = 0
        for t in time:
            trip += mid//t
            if trip >= totalTrip:
                return False
        return True

    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        time.sort(reverse=True)
        minimum = min(time)
        left = minimum
        right = minimum*totalTrips
        while left < right:
            mid = (left+ right)//2

            if self.satisfiesTrip(mid, time, totalTrips):
                right = mid
            else:
                left = mid + 1
        return right",None,"class Solution:
    def satisfiesTrip(self, mid, time, totalTrips):
        trip = 0
        for t in time:
            trip += mid // t
            if trip >= totalTrips:
                return True
        return False

    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        time.sort(reverse=True)
        minimum = min(time)
        left = minimum
        right = minimum * totalTrips
        while left < right:
            mid = (left + right) // 2

            if self.satisfiesTrip(mid, time, totalTrips):
                right = mid
            else:
                left = mid + 1
        return left
"
3060,python3,minimum-time-to-complete-trips,"class Solution:
    def satisfiesTrip(self,mid, time, totalTrip):
        trip = 0
        for t in time:
            trip += mid//t
            if trip >= totalTrip:
                return False
        return True

    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        time.sort(reverse=True)
        minimum = min(time)
        left = minimum
        right = minimum*totalTrips
        while left < right:
            mid = (left+ right)//2

            if self.satisfiesTrip(mid, time, totalTrips):
                right = mid
            else:
                left = mid + 1
        return right",None,"class Solution:
    def satisfiesTrip(self, mid, time, totalTrips):
        trip = 0
        for t in time:
            trip += mid // t
            if trip >= totalTrips:
                return True
        return False

    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        time.sort(reverse=True)
        minimum = min(time)
        left = minimum
        right = minimum * totalTrips
        while left < right:
            mid = (left + right) // 2

            if self.satisfiesTrip(mid, time, totalTrips):
                right = mid
            else:
                left = mid + 1
        return left
"
3060,python3,minimum-time-to-complete-trips,"class Solution:
    def satisfiesTrip(self,mid, time, totalTrip):
        trip = 0
        for t in time:
            trip += mid//t
            if trip >= totalTrip:
                return False
        return True

    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        time.sort(reverse=True)
        minimum = min(time)
        left = minimum
        right = minimum*totalTrips
        while left < right:
            mid = (left+ right)//2

            if self.satisfiesTrip(mid, time, totalTrips):
                right = mid
            else:
                left = mid + 1
        return right",None,"class Solution:
    def satisfiesTrip(self, mid, time, totalTrips):
        trip = 0
        for t in time:
            trip += mid // t
        return trip >= totalTrips

    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        time.sort(reverse=True)
        minimum = min(time)
        left = minimum
        right = minimum * totalTrips
        while left < right:
            mid = (left + right) // 2

            if self.satisfiesTrip(mid, time, totalTrips):
                right = mid
            else:
                left = mid + 1
        return left
"
3061,python3,minimum-speed-to-arrive-on-time,"class Solution:
    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:
        if len(dist) >= hour - 1  : return -1
        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))
        while left<right:
            mid=(left+right)//2
            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :
                right=mid
            else:
                left=mid+1
        return left",None,"class Solution:
    def minSpeedOnTime(self, dist, hour):
        if len(dist) >= hour:
            return -1
        left, right = 1, max(dist)
        while left < right:
            mid = (left + right) // 2
            current_time = sum([(i - 1) // mid + 1 for i in dist[:-1]]) + dist[-1] / mid
            if current_time <= hour:
                right = mid
            else:
                left = mid + 1
        return left
"
3061,python3,minimum-speed-to-arrive-on-time,"class Solution:
    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:
        if len(dist) >= hour - 1  : return -1
        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))
        while left<right:
            mid=(left+right)//2
            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :
                right=mid
            else:
                left=mid+1
        return left",None,"class Solution:
    def minSpeedOnTime(self, dist, hour):
        if len(dist) >= hour:
            return -1
        left, right = 1, max(dist)
        while left < right:
            mid = (left + right) // 2
            current_time = sum([ceil(i / mid) for i in dist[:-1]]) + dist[-1] / mid
            if current_time <= hour:
                right = mid
            else:
                left = mid + 1
        return left
"
3061,python3,minimum-speed-to-arrive-on-time,"class Solution:
    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:
        if len(dist) >= hour - 1  : return -1
        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))
        while left<right:
            mid=(left+right)//2
            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :
                right=mid
            else:
                left=mid+1
        return left",None,"class Solution:
    def minSpeedOnTime(self, dist, hour):
        if len(dist) >= hour:
            return -1
        left, right = 1, max(dist) + 1
        while left < right:
            mid = (left + right) // 2
            current_time = sum([ceil(i / mid) for i in dist[:-1]]) + dist[-1] / mid
            if current_time <= hour:
                right = mid
            else:
                left = mid + 1
        return left
"
3062,python3,count-the-repetitions,"class Solution:
    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:

        rec, track = [0], defaultdict(int) 
        ct = start = ptr1 = ptr2 = 0

        if not set(s2).issubset(set(s1)): return 0

        s1 = ''.join(char for char in s1 if char in set(s2))
        
        while True:
            for char in s2:
                ptr = s1.find(char, start)
                if ptr == -1:
                    ct += 1
                    ptr = s1.find(char)
                start = ptr+1
            rec.append(ct + 1)

            if rec[-1] >= n1: return (len(rec)-2)//n2

            if ptr not in track: track[ptr] = len(rec)-1
            else: break
        
        cycleStart = rec[track[ptr]]
        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]
        rest = n1 - cycleStart
        
        rem = cycleStart + rest%cycle1

        while rec[ptr2] <= rem: ptr2+= 1

        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",None,"class Solution:
    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:

        rec, track = [0], defaultdict(int) 
        ct = start = ptr1 = ptr2 = 0

        if not set(s2).issubset(set(s1)): return 0

        s1 = ''.join(char for char in s1 if char in set(s2))

        while ptr2 < len(rec):
            for char in s2:
                ptr1 = s1.find(char, start)
                if ptr1 == -1:
                    ct += 1
                    ptr1 = s1.find(char)
                start = ptr1+1
            rec.append(ct + 1)
            if rec[-1] >= n1: return (len(rec)-2)//n2

            if ptr1 not in track: track[ptr1] = len(rec)-1
            else: break
            ptr2 = track[ptr1]

        cycleStart = rec[ptr2]
        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - ptr2
        rest = n1 - cycleStart

        if rest % cycle1 == 0:
            return (len(rec)-2)//n2 * (rest//cycle1)

        rem = cycleStart + (rest % cycle1)

        while rec[ptr2] <= rem: ptr2+= 1

        return (len(rec)-2)//n2 * (rest//cycle1) + (ptr2-1)//n2
"
3062,python3,count-the-repetitions,"class Solution:
    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:

        rec, track = [0], defaultdict(int) 
        ct = start = ptr1 = ptr2 = 0

        if not set(s2).issubset(set(s1)): return 0

        s1 = ''.join(char for char in s1 if char in set(s2))
        
        while True:
            for char in s2:
                ptr = s1.find(char, start)
                if ptr == -1:
                    ct += 1
                    ptr = s1.find(char)
                start = ptr+1
            rec.append(ct + 1)

            if rec[-1] >= n1: return (len(rec)-2)//n2

            if ptr not in track: track[ptr] = len(rec)-1
            else: break
        
        cycleStart = rec[track[ptr]]
        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]
        rest = n1 - cycleStart
        
        rem = cycleStart + rest%cycle1

        while rec[ptr2] <= rem: ptr2+= 1

        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",None,"class Solution:
    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:

        rec, track = [0], defaultdict(int) 
        ct = start = ptr1 = ptr2 = 0

        if not set(s2).issubset(set(s1)): return 0

        s1 = ''.join(char for char in s1 if char in set(s2))

        while ptr2 < len(rec):
            for char in s2:
                ptr1 = s1.find(char, start)
                if ptr1 == -1:
                    ct += 1
                    ptr1 = s1.find(char)
                start = ptr1+1
            rec.append(ct + 1)

            if rec[-1] >= n1: return (len(rec)-2)//n2

            if ptr1 not in track: track[ptr1] = len(rec)-1
            else: break

            ptr2 = track[ptr1]

        cycleStart = rec[ptr2]
        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - ptr2
        rest = n1 - cycleStart

        if rest % cycle1 == 0:
            return (len(rec)-2)//n2 * (rest//cycle1)

        rem = cycleStart + (rest % cycle1)

        ptr2 = len(rec) - 1

        while rec[ptr2] <= rem: ptr2+= 1

        return (ptr2-1)//n2
"
3062,python3,count-the-repetitions,"class Solution:
    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:

        rec, track = [0], defaultdict(int) 
        ct = start = ptr1 = ptr2 = 0

        if not set(s2).issubset(set(s1)): return 0

        s1 = ''.join(char for char in s1 if char in set(s2))
        
        while True:
            for char in s2:
                ptr = s1.find(char, start)
                if ptr == -1:
                    ct += 1
                    ptr = s1.find(char)
                start = ptr+1
            rec.append(ct + 1)

            if rec[-1] >= n1: return (len(rec)-2)//n2

            if ptr not in track: track[ptr] = len(rec)-1
            else: break
        
        cycleStart = rec[track[ptr]]
        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]
        rest = n1 - cycleStart
        
        rem = cycleStart + rest%cycle1

        while rec[ptr2] <= rem: ptr2+= 1

        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",None,"class Solution:
    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:

        rec, track = [0], defaultdict(int) 
        ct = start = ptr1 = ptr2 = 0

        if not set(s2).issubset(set(s1)): return 0

        s1 = ''.join(char for char in s1 if char in set(s2))
        
        while ptr2 < len(rec):
            for char in s2:
                ptr1 = s1.find(char, start)
                if ptr1 == -1:
                    ct += 1
                    ptr1 = s1.find(char)
                start = ptr1+1
            rec.append(ct + 1)
            if rec[-1] >= n1: return (len(rec)-2)//n2

            if ptr1 not in track: track[ptr1] = len(rec)-1
            else: break
        
        cycleStart = rec[track[ptr1]]
        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr1]
        rest = n1 - cycleStart
        
        rem = cycleStart + rest%cycle1

        while ptr2 < len(rec) and rec[ptr2] <= rem: ptr2+= 1

        return (ptr2-1)//n2
"
3063,python3,fizz-buzz,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        arr=[]
        for i in range(0,n+1):
            if i % 3==0 and  i % 5==0 :
                arr.append(""FizzBuzz"")
            elif i % 3==0:
                arr.append(""Fizz"")
            elif i % 5==0 :
                arr.append(""Buzz"")
  
            else:
                arr.append(str(i))
        return(arr)",None,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        arr=[]
        for i in range(1,n+1):
            if i % 3==0 and  i % 5==0 :
                arr.append(""FizzBuzz"")
            elif i % 3==0:
                arr.append(""Fizz"")
            elif i % 5==0 :
                arr.append(""Buzz"")
            else:
                arr.append(str(i))
        return arr
"
3063,python3,fizz-buzz,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        arr=[]
        for i in range(0,n+1):
            if i % 3==0 and  i % 5==0 :
                arr.append(""FizzBuzz"")
            elif i % 3==0:
                arr.append(""Fizz"")
            elif i % 5==0 :
                arr.append(""Buzz"")
  
            else:
                arr.append(str(i))
        return(arr)",None,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        arr=[]
        for i in range(1,n+1):
            if i % 3==0 and  i % 5==0 :
                arr.append(""FizzBuzz"")
            elif i % 3==0:
                arr.append(""Fizz"")
            elif i % 5==0 :
                arr.append(""Buzz"")
            else:
                arr.append(str(i))
        return arr
"
3063,python3,fizz-buzz,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        arr=[]
        for i in range(0,n+1):
            if i % 3==0 and  i % 5==0 :
                arr.append(""FizzBuzz"")
            elif i % 3==0:
                arr.append(""Fizz"")
            elif i % 5==0 :
                arr.append(""Buzz"")
  
            else:
                arr.append(str(i))
        return(arr)",None,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        arr=[]
        for i in range(1,n+1):
            if i % 3==0 and  i % 5==0 :
                arr.append(""FizzBuzz"")
            elif i % 3==0:
                arr.append(""Fizz"")
            elif i % 5==0 :
                arr.append(""Buzz"")
            else:
                arr.append(str(i))
        return arr
"
3064,python3,plus-one,"class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        s= ''.join(map(str,digits))
        i=int(s)+1
        if i<10:
            li=[]
        else:
            li=list(map(int,str(i)))  
        return li",None,"class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        digits[-1] += 1
        for i in range(len(digits)-1, -1, -1):
            if digits[i] != 10:
                break
            digits[i] = 0
            if i != 0:
                digits[i-1] += 1
        if digits[0] == 10:
            digits[0] = 0
            digits.insert(0, 1)
        return digits
"
3064,python3,plus-one,"class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        s= ''.join(map(str,digits))
        i=int(s)+1
        if i<10:
            li=[]
        else:
            li=list(map(int,str(i)))  
        return li",None,"class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        digits[-1] += 1
        for i in range(len(digits) - 1, -1, -1):
            if digits[i] != 10:
                break
            digits[i] = 0
            if i == 0:
                digits.insert(0, 1)
        return digits
"
3064,python3,plus-one,"class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        s= ''.join(map(str,digits))
        i=int(s)+1
        if i<10:
            li=[]
        else:
            li=list(map(int,str(i)))  
        return li",None,"class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        digits[-1] += 1
        for i in range(len(digits)-1, 0, -1):
            if digits[i] == 10:
                digits[i] = 0
                digits[i-1] += 1
            else:
                break
        if digits[0] == 10:
            digits[0] = 0
            digits.insert(0, 1)
        return digits
"
3065,python3,number-of-ways-to-split-array,"class Solution:
    def waysToSplitArray(self, nums: List[int]) -> int:
        cnt=0
        left=nums[0]
        right=sum(nums[0:])
        if left>=right:
            cnt+=1
        for i in range(1,len(nums)-1):
            left+=nums[i]
            right-=nums[i]
            if left>=right:
                cnt+=1
        return cnt",None,"class Solution:
    def waysToSplitArray(self, nums: List[int]) -> int:
        cnt = 0
        left = nums[0]
        right = sum(nums[:-1])
        if left >= right:
            cnt += 1
        for i in range(1, len(nums) - 1):
            left += nums[i]
            right -= nums[i]
            if left >= right:
                cnt += 1
        return cnt
"
3065,python3,number-of-ways-to-split-array,"class Solution:
    def waysToSplitArray(self, nums: List[int]) -> int:
        cnt=0
        left=nums[0]
        right=sum(nums[0:])
        if left>=right:
            cnt+=1
        for i in range(1,len(nums)-1):
            left+=nums[i]
            right-=nums[i]
            if left>=right:
                cnt+=1
        return cnt",None,"class Solution:
    def waysToSplitArray(self, nums: List[int]) -> int:
        cnt = 0
        left = nums[0]
        right = sum(nums[1:])
        if left >= right:
            cnt += 1
        for i in range(1, len(nums) - 1):
            left += nums[i]
            right -= nums[i + 1]
            if left >= right:
                cnt += 1
        return cnt
"
3065,python3,number-of-ways-to-split-array,"class Solution:
    def waysToSplitArray(self, nums: List[int]) -> int:
        cnt=0
        left=nums[0]
        right=sum(nums[0:])
        if left>=right:
            cnt+=1
        for i in range(1,len(nums)-1):
            left+=nums[i]
            right-=nums[i]
            if left>=right:
                cnt+=1
        return cnt",None,"class Solution:
    def waysToSplitArray(self, nums: List[int]) -> int:
        cnt = 0
        left = nums[0]
        right = sum(nums[1:])
        if left >= right:
            cnt += 1
        for i in range(1, len(nums) - 1):
            left += nums[i]
            right -= nums[i]
            if left >= right:
                cnt += 1
        return cnt
"
3066,python3,remove-duplicates-from-sorted-array-ii,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) < 3:
            return len(nums)

        p1, p2 = 1, 2

        while p2 < len(nums):
            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p1-2]:
                while p2 < len(nums) and nums[p2] == nums[p2-1]:
                    p2 += 1
                if p2 == len(nums):
                    break
            p1 += 1
            nums[p1] = nums[p2]
            p2 += 1

        return p1 + 1",None,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) < 3:
            return len(nums)

        p1, p2 = 1, 2

        while p2 < len(nums):
            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p1-2]:
                while p2 < len(nums) and nums[p2] == nums[p2-1]:
                    p2 += 1
                if p2 == len(nums):
                    break
            else:
                p1 += 1
                nums[p1] = nums[p2]
            p2 += 1

        return p1 + 1
"
3066,python3,remove-duplicates-from-sorted-array-ii,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) < 3:
            return len(nums)

        p1, p2 = 1, 2

        while p2 < len(nums):
            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p1-2]:
                while p2 < len(nums) and nums[p2] == nums[p2-1]:
                    p2 += 1
                if p2 == len(nums):
                    break
            p1 += 1
            nums[p1] = nums[p2]
            p2 += 1

        return p1 + 1",None,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) < 3:
            return len(nums)

        p1, p2 = 1, 2

        while p2 < len(nums):
            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p1-2]:
                while p2 < len(nums) and nums[p2] == nums[p2-1]:
                    p2 += 1
                if p2 == len(nums):
                    break
                p1 += 1
                nums[p1] = nums[p2]
                p2 += 1
            else:
                p1 += 1
                nums[p1] = nums[p2]
                p2 += 1

        return p1 + 1
"
3066,python3,remove-duplicates-from-sorted-array-ii,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) < 3:
            return len(nums)

        p1, p2 = 1, 2

        while p2 < len(nums):
            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p1-2]:
                while p2 < len(nums) and nums[p2] == nums[p2-1]:
                    p2 += 1
                if p2 == len(nums):
                    break
            p1 += 1
            nums[p1] = nums[p2]
            p2 += 1

        return p1 + 1",None,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) < 3:
            return len(nums)

        p1, p2 = 1, 2

        while p2 < len(nums):
            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p1-2]:
                while p2 < len(nums) and nums[p2] == nums[p2-1]:
                    p2 += 1
                if p2 == len(nums):
                    break
            else:
                p1 += 1
                nums[p1] = nums[p2]
            p2 += 1

        return p1 + 1
"
3067,python3,frog-position-after-t-seconds,"from queue import Queue

class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        if edges == []:
            if target == 1:return 1
            return 0

        d = {}
        for i in edges:
            d[i[0]] = d.get(i[0] , []) + [i[1]]
            d[i[1]] = d.get(i[1] , []) + [i[0]]
        
        visit = [0]*(n+1)

        q = Queue()     
        q.put([1 , 1])

        for dur in range(t+1):
            
            l = q.qsize()
            for i in range(l):
                temp = q.get()

                count = 0
                for ele in d[temp[0]]:
                    if visit[ele] == 0: count += 1
            
                if temp[0] == target and count == 0:     
                    return temp[1]
                
                if visit[temp[0]] != 0:
                    continue
                
                visit[temp[0]] = 1

                for ele in d[temp[0]]:
                    if visit[ele] == 0: q.put([ele , temp[1]*(1/count)])
                
        
        l = q.qsize()
        for i in range(l):
            temp = q.get()
            if temp[0] == target:
                return temp[1]

        return 0",None,"from queue import Queue
from collections import defaultdict

class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        if not edges:
            if target == 1:
                return 1
            return 0

        graph = defaultdict(list)
        for edge in edges:
            graph[edge[0]].append(edge[1])
            graph[edge[1]].append(edge[0])

        visit = [0] * (n + 1)

        q = Queue()
        q.put((1, 1))

        for _ in range(t):
            l = q.qsize()
            for _ in range(l):
                temp = q.get()

                count = sum(1 for ele in graph[temp[0]] if visit[ele] == 0)

                if temp[0] == target and count == 0:
                    return temp[1]

                if visit[temp[0]] != 0:
                    continue

                visit[temp[0]] = 1

                for ele in graph[temp[0]]:
                    if visit[ele] == 0:
                        q.put((ele, temp[1] / count))

        l = q.qsize()
        for _ in range(l):
            temp = q.get()
            if temp[0] == target:
                return temp[1]

        return 0
"
3067,python3,frog-position-after-t-seconds,"from queue import Queue

class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        if edges == []:
            if target == 1:return 1
            return 0

        d = {}
        for i in edges:
            d[i[0]] = d.get(i[0] , []) + [i[1]]
            d[i[1]] = d.get(i[1] , []) + [i[0]]
        
        visit = [0]*(n+1)

        q = Queue()     
        q.put([1 , 1])

        for dur in range(t+1):
            
            l = q.qsize()
            for i in range(l):
                temp = q.get()

                count = 0
                for ele in d[temp[0]]:
                    if visit[ele] == 0: count += 1
            
                if temp[0] == target and count == 0:     
                    return temp[1]
                
                if visit[temp[0]] != 0:
                    continue
                
                visit[temp[0]] = 1

                for ele in d[temp[0]]:
                    if visit[ele] == 0: q.put([ele , temp[1]*(1/count)])
                
        
        l = q.qsize()
        for i in range(l):
            temp = q.get()
            if temp[0] == target:
                return temp[1]

        return 0",None,"from queue import Queue
import collections

class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        if not edges:
            if target == 1:
                return 1
            return 0

        graph = collections.defaultdict(list)
        for edge in edges:
            graph[edge[0]].append(edge[1])
            graph[edge[1]].append(edge[0])

        visit = [0] * (n + 1)
        q = Queue()     
        q.put((1, 1))

        for dur in range(t + 1):
            l = q.qsize()
            for i in range(l):
                temp = q.get()

                count = 0
                for ele in graph[temp[0]]:
                    if not visit[ele]:
                        count += 1

                if temp[0] == target and count == 0:
                    return temp[1]

                if visit[temp[0]]:
                    continue

                visit[temp[0]] = 1

                for ele in graph[temp[0]]:
                    if not visit[ele]:
                        q.put((ele, temp[1] / count))

        l = q.qsize()
        for i in range(l):
            temp = q.get()
            if temp[0] == target:
                return temp[1]

        return 0
"
3067,python3,frog-position-after-t-seconds,"from queue import Queue

class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        if edges == []:
            if target == 1:return 1
            return 0

        d = {}
        for i in edges:
            d[i[0]] = d.get(i[0] , []) + [i[1]]
            d[i[1]] = d.get(i[1] , []) + [i[0]]
        
        visit = [0]*(n+1)

        q = Queue()     
        q.put([1 , 1])

        for dur in range(t+1):
            
            l = q.qsize()
            for i in range(l):
                temp = q.get()

                count = 0
                for ele in d[temp[0]]:
                    if visit[ele] == 0: count += 1
            
                if temp[0] == target and count == 0:     
                    return temp[1]
                
                if visit[temp[0]] != 0:
                    continue
                
                visit[temp[0]] = 1

                for ele in d[temp[0]]:
                    if visit[ele] == 0: q.put([ele , temp[1]*(1/count)])
                
        
        l = q.qsize()
        for i in range(l):
            temp = q.get()
            if temp[0] == target:
                return temp[1]

        return 0",None,"from queue import Queue
from collections import defaultdict
import math

class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        if not edges:
            return 1 if target == 1 else 0

        graph = defaultdict(list)
        for edge in edges:
            graph[edge[0]].append(edge[1])
            graph[edge[1]].append(edge[0])

        queue = Queue()
        queue.put((1, 1))
        visited = set()

        for _ in range(t):
            level_size = queue.qsize()
            for _ in range(level_size):
                node, prob = queue.get()
                visited.add(node)

                for neighbor in graph[node]:
                    if neighbor not in visited:
                        if node == target:
                            prob /= len(graph[node])
                        queue.put((neighbor, prob))

        prob = 0
        while not queue.empty():
            node, prob = queue.get()
            if node == target:
                prob /= queue.qsize()
                break

        return prob
"
3068,python3,minimum-difference-between-highest-and-lowest-of-k-scores,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        res = 100000
        
        for i in range(len(nums) - k):
            arr = nums[i:i + k]
            res = min(res, arr[-1] - arr[0])
            
        return res",None,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        res = 100000

        for i in range(len(nums) - k + 1):
            arr = nums[i:i + k]
            res = min(res, arr[-1] - arr[0])

        return res
"
3068,python3,minimum-difference-between-highest-and-lowest-of-k-scores,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        res = 100000
        
        for i in range(len(nums) - k):
            arr = nums[i:i + k]
            res = min(res, arr[-1] - arr[0])
            
        return res",None,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        res = float('inf')

        for i in range(len(nums) - k + 1):
            res = min(res, nums[i + k - 1] - nums[i])

        return res
"
3068,python3,minimum-difference-between-highest-and-lowest-of-k-scores,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        res = 100000
        
        for i in range(len(nums) - k):
            arr = nums[i:i + k]
            res = min(res, arr[-1] - arr[0])
            
        return res",None,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        res = float('inf')
        
        for i in range(len(nums) - k + 1):
            res = min(res, nums[i + k - 1] - nums[i])
        
        return res
"
3069,python3,valid-parenthesis-string,"class Solution:
    def checkValidString(self, s):
        st=[]
        sr=[]
        for i in range(len(s)):
            if s[i]=='(':
                st.append(i)
            elif s[i]== '*':
                sr.append(i)
            else:
                if st:
                    st.pop()
                elif sr:
                    sr.pop()
                else:
                    return False
        while st:
            if len(sr)==0:
                return False
            elif st[-1] > sr[-1]:
                st.pop()
                sr.pop()
            else:
                return False
        return True",None,"class Solution:
    def checkValidString(self, s):
        st=[]
        sr=[]
        for i in range(len(s)):
            if s[i]=='(':
                st.append(i)
            elif s[i]== '*':
                sr.append(i)
            else:
                if st:
                    st.pop()
                elif sr:
                    sr.pop()
                else:
                    return False
        while st:
            if sr and st[-1] < sr[-1]:
                st.pop()
                sr.pop()
            elif not sr:
                return False
            else:
                sr.pop()
        return True
"
3069,python3,valid-parenthesis-string,"class Solution:
    def checkValidString(self, s):
        st=[]
        sr=[]
        for i in range(len(s)):
            if s[i]=='(':
                st.append(i)
            elif s[i]== '*':
                sr.append(i)
            else:
                if st:
                    st.pop()
                elif sr:
                    sr.pop()
                else:
                    return False
        while st:
            if len(sr)==0:
                return False
            elif st[-1] > sr[-1]:
                st.pop()
                sr.pop()
            else:
                return False
        return True",None,"class Solution:
    def checkValidString(self, s):
        st=[]
        sr=[]
        for i in range(len(s)):
            if s[i]=='(':
                st.append(i)
            elif s[i]== '*':
                sr.append(i)
            else:
                if st:
                    st.pop()
                elif sr:
                    sr.pop()
                else:
                    return False
        while st:
            if sr and st[-1] < sr[-1]:
                st.pop()
                sr.pop()
            elif not sr:
                return False
            else:
                sr.pop()
        return True
"
3069,python3,valid-parenthesis-string,"class Solution:
    def checkValidString(self, s):
        st=[]
        sr=[]
        for i in range(len(s)):
            if s[i]=='(':
                st.append(i)
            elif s[i]== '*':
                sr.append(i)
            else:
                if st:
                    st.pop()
                elif sr:
                    sr.pop()
                else:
                    return False
        while st:
            if len(sr)==0:
                return False
            elif st[-1] > sr[-1]:
                st.pop()
                sr.pop()
            else:
                return False
        return True",None,"class Solution:
    def checkValidString(self, s):
        st=[]
        sr=[]
        for i in range(len(s)):
            if s[i]=='(':
                st.append(i)
            elif s[i]== '*':
                sr.append(i)
            else:
                if st:
                    st.pop()
                elif sr:
                    sr.pop()
                else:
                    return False
        while st:
            if sr and st[-1] < sr[-1]:
                st.pop()
                sr.pop()
            elif not sr:
                return False
            else:
                sr.pop()
        return True
"
3070,python3,minimum-total-cost-to-make-arrays-unequal,"class Solution:
    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:
        n=len(nums1)
        z=Counter(nums1)
        z1=Counter(nums2)
        for i in z:
            if(n-z1[i]<z[i]):
                return -1
            if(z[i]>=n//2+1 and z1[i]>=n//2+1):
                return -1
        for i in z1:
            if(n-z[i]<z1[i]):
                return -1
            if(z[i]>=n//2+1 and z1[i]>=n//2+1):
                return -1
        z=Counter([])
        ans=0
        flag=0
        d=defaultdict(list)
        vis=[0 for i in range(n)]
        for i in range(n):
            if(nums1[i]==nums2[i]):
                z[nums2[i]]+=1
                ans+=i
                flag=1
                d[nums2[i]].append(i)
        t=0
        l=z.most_common(len(z))
        a=0
        for i in range(1,len(l)):
            a+=l[i][1]
            for j in d[l[i][0]]:
                vis[j]=1
            z[l[i][0]]=0
        if(l and a>=l[0][1]):
            return ans
        x=0
        if(l):
            x=l[0][1]-a
            z[l[0][0]]=x
        print(z,ans)
        for j in z:
            if(z[j]):
                for i in range(n):
                    if(vis[i]==0 and nums1[i]==j and nums2[i]==j and x): 
                        if(flag):
                            ans+=i
                            x-=1
        return ans",None,"class Solution:
    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        z = Counter(nums1)
        z1 = Counter(nums2)

        for i in z:
            if (n - z1[i] < z[i]):
                return -1
            if (z[i] >= n // 2 + 1 and z1[i] >= n // 2 + 1):
                return -1

        for i in z1:
            if (n - z[i] < z1[i]):
                return -1
            if (z[i] >= n // 2 + 1 and z1[i] >= n // 2 + 1):
                return -1

        z = Counter([])
        ans = 0
        flag = 0
        d = defaultdict(list)
        vis = [0 for i in range(n)]

        for i in range(n):
            if (nums1[i] == nums2[i]):
                z[nums2[i]] += 1
                ans += i
                flag = 1
                d[nums2[i]].append(i)

        t = 0
        l = z.most_common(len(z))
        a = 0
        for i in range(1, len(l)):
            a += l[i][1]
            for j in d[l[i][0]]:
                vis[j] = 1
            z[l[i][0]] = 0

        if (l and a >= l[0][1]):
            return ans

        x = 0
        if (l):
            x = l[0][1] - a
            z[l[0][0]] = x

        for j in z:
            if (z[j]):
                for i in range(n):
                    if (vis[i] == 0 and nums1[i] == j and nums2[i] == j):
                        ans += i
                        z[j] -= 1
                        if (z[j] == 0):
                            break

        return ans
"
3070,python3,minimum-total-cost-to-make-arrays-unequal,"class Solution:
    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:
        n=len(nums1)
        z=Counter(nums1)
        z1=Counter(nums2)
        for i in z:
            if(n-z1[i]<z[i]):
                return -1
            if(z[i]>=n//2+1 and z1[i]>=n//2+1):
                return -1
        for i in z1:
            if(n-z[i]<z1[i]):
                return -1
            if(z[i]>=n//2+1 and z1[i]>=n//2+1):
                return -1
        z=Counter([])
        ans=0
        flag=0
        d=defaultdict(list)
        vis=[0 for i in range(n)]
        for i in range(n):
            if(nums1[i]==nums2[i]):
                z[nums2[i]]+=1
                ans+=i
                flag=1
                d[nums2[i]].append(i)
        t=0
        l=z.most_common(len(z))
        a=0
        for i in range(1,len(l)):
            a+=l[i][1]
            for j in d[l[i][0]]:
                vis[j]=1
            z[l[i][0]]=0
        if(l and a>=l[0][1]):
            return ans
        x=0
        if(l):
            x=l[0][1]-a
            z[l[0][0]]=x
        print(z,ans)
        for j in z:
            if(z[j]):
                for i in range(n):
                    if(vis[i]==0 and nums1[i]==j and nums2[i]==j and x): 
                        if(flag):
                            ans+=i
                            x-=1
        return ans",None,"class Solution:
    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        z = Counter(nums1)
        z1 = Counter(nums2)

        for i in z:
            if n - z1[i] < z[i]:
                return -1
            if z[i] >= n // 2 + 1 and z1[i] >= n // 2 + 1:
                return -1

        for i in z1:
            if n - z[i] < z1[i]:
                return -1
            if z[i] >= n // 2 + 1 and z1[i] >= n // 2 + 1:
                return -1

        ans = 0
        flag = 0
        d = defaultdict(list)
        vis = [0 for i in range(n)]

        for i in range(n):
            if nums1[i] == nums2[i]:
                z[nums2[i]] += 1
                ans += i
                flag = 1
                d[nums2[i]].append(i)

        l = z.most_common()
        a = 0
        for i in range(1, len(l)):
            a += l[i][1]
            for j in d[l[i][0]]:
                vis[j] = 1
            z[l[i][0]] = 0

        if l and a >= l[0][1]:
            return ans

        x = 0
        if l:
            x = l[0][1] - a
            z[l[0][0]] = x

        for j in z:
            if z[j]:
                for i in range(n):
                    if vis[i] == 0 and nums1[i] == j and nums2[i] == j and x:
                        ans += i
                        x -= 1

        return ans
"
3070,python3,minimum-total-cost-to-make-arrays-unequal,"class Solution:
    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:
        n=len(nums1)
        z=Counter(nums1)
        z1=Counter(nums2)
        for i in z:
            if(n-z1[i]<z[i]):
                return -1
            if(z[i]>=n//2+1 and z1[i]>=n//2+1):
                return -1
        for i in z1:
            if(n-z[i]<z1[i]):
                return -1
            if(z[i]>=n//2+1 and z1[i]>=n//2+1):
                return -1
        z=Counter([])
        ans=0
        flag=0
        d=defaultdict(list)
        vis=[0 for i in range(n)]
        for i in range(n):
            if(nums1[i]==nums2[i]):
                z[nums2[i]]+=1
                ans+=i
                flag=1
                d[nums2[i]].append(i)
        t=0
        l=z.most_common(len(z))
        a=0
        for i in range(1,len(l)):
            a+=l[i][1]
            for j in d[l[i][0]]:
                vis[j]=1
            z[l[i][0]]=0
        if(l and a>=l[0][1]):
            return ans
        x=0
        if(l):
            x=l[0][1]-a
            z[l[0][0]]=x
        print(z,ans)
        for j in z:
            if(z[j]):
                for i in range(n):
                    if(vis[i]==0 and nums1[i]==j and nums2[i]==j and x): 
                        if(flag):
                            ans+=i
                            x-=1
        return ans",None,"class Solution:
    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        z = Counter(nums1)
        z1 = Counter(nums2)

        for i in z:
            if (n - z1[i] < z[i]):
                return -1
            if (z[i] >= n // 2 + 1 and z1[i] >= n // 2 + 1):
                return -1

        for i in z1:
            if (n - z[i] < z1[i]):
                return -1
            if (z[i] >= n // 2 + 1 and z1[i] >= n // 2 + 1):
                return -1

        ans = 0
        flag = 0
        d = defaultdict(list)
        vis = [0 for i in range(n)]

        for i in range(n):
            if (nums1[i] == nums2[i]):
                d[nums2[i]].append(i)
                ans += i
                flag = 1

        l = sorted(d.items(), key=lambda x: x[1][-1])
        x = 0

        if l:
            x = l[0][1][-1]
            for i in d[l[0][0]]:
                if i <= x:
                    return -1

        for j in d:
            if d[j]:
                for i in range(n):
                    if (nums1[i] == j and nums2[i] == j and not vis[i]):
                        ans += i
                        vis[i] = 1
                        if x:
                            x -= 1
                        else:
                            break

        return ans
"
3071,python3,find-the-array-concatenation-value,"class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        left=0
        right=len(nums)-1
        total=0
        while left<=right:
            if left>right:
                total+=int(str(nums[left])+str(nums[right]))
            else:
                total+=nums[left]
            left+=1
            right-=1
        return total",None,"class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        left = 0
        right = len(nums) - 1
        total = 0
        while left <= right:
            if left < right:
                total += int(str(nums[left]) + str(nums[right]))
            else:
                total += nums[right]
            left += 1
            right -= 1
        return total
"
3071,python3,find-the-array-concatenation-value,"class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        left=0
        right=len(nums)-1
        total=0
        while left<=right:
            if left>right:
                total+=int(str(nums[left])+str(nums[right]))
            else:
                total+=nums[left]
            left+=1
            right-=1
        return total",None,"class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        left=0
        right=len(nums)-1
        total=0
        while left<=right:
            if left < right:
                total += int(str(nums[left]) + str(nums[right]))
            else:
                total += nums[right]
            left += 1
            right -= 1
        return total
"
3071,python3,find-the-array-concatenation-value,"class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        left=0
        right=len(nums)-1
        total=0
        while left<=right:
            if left>right:
                total+=int(str(nums[left])+str(nums[right]))
            else:
                total+=nums[left]
            left+=1
            right-=1
        return total",None,"class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        left=0
        right=len(nums)-1
        total=0
        while left<=right:
            if left < right:
                total += int(str(nums[left]) + str(nums[right]))
            else:
                total += nums[right]
            left += 1
            right -= 1
        return total
"
3072,python3,construct-binary-tree-from-inorder-and-postorder-traversal,"class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        inorder_map={val:idx for idx, val in enumerate(inorder)}
        postorder_idx=len(postorder)-1

        def treeHelper(left, right):
            nonlocal postorder_idx
            if left>right:
                return None

            node_val = postorder[postorder_idx]
            root=TreeNode(node_val)
            postorder_idx-=1

            inorder_index=inorder_map[node_val]

            root.left = treeHelper(inorder_index+1, right)
            root.right = treeHelper(left, inorder_index-1 )

            return root

        return treeHelper(0, len(inorder)-1)",None,"class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        inorder_map={val:idx for idx, val in enumerate(inorder)}
        postorder_idx=len(postorder)-1

        def treeHelper(left, right):
            nonlocal postorder_idx
            if left>right:
                return None

            node_val = postorder[postorder_idx]
            root=TreeNode(node_val)
            postorder_idx-=1

            inorder_index=inorder_map[node_val]

            root.right = treeHelper(inorder_index+1, right)
            root.left = treeHelper(left, inorder_index-1 )

            return root

        return treeHelper(0, len(inorder)-1)
"
3072,python3,construct-binary-tree-from-inorder-and-postorder-traversal,"class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        inorder_map={val:idx for idx, val in enumerate(inorder)}
        postorder_idx=len(postorder)-1

        def treeHelper(left, right):
            nonlocal postorder_idx
            if left>right:
                return None

            node_val = postorder[postorder_idx]
            root=TreeNode(node_val)
            postorder_idx-=1

            inorder_index=inorder_map[node_val]

            root.left = treeHelper(inorder_index+1, right)
            root.right = treeHelper(left, inorder_index-1 )

            return root

        return treeHelper(0, len(inorder)-1)",None,"class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        inorder_map={val:idx for idx, val in enumerate(inorder)}
        postorder_idx=len(postorder)-1

        def treeHelper(left, right):
            nonlocal postorder_idx
            if left>right:
                return None

            node_val = postorder[postorder_idx]
            root=TreeNode(node_val)
            postorder_idx-=1

            inorder_index=inorder_map[node_val]

            root.right = treeHelper(inorder_index+1, right)
            root.left = treeHelper(left, inorder_index-1 )

            return root

        return treeHelper(0, len(inorder)-1)
"
3072,python3,construct-binary-tree-from-inorder-and-postorder-traversal,"class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        inorder_map={val:idx for idx, val in enumerate(inorder)}
        postorder_idx=len(postorder)-1

        def treeHelper(left, right):
            nonlocal postorder_idx
            if left>right:
                return None

            node_val = postorder[postorder_idx]
            root=TreeNode(node_val)
            postorder_idx-=1

            inorder_index=inorder_map[node_val]

            root.left = treeHelper(inorder_index+1, right)
            root.right = treeHelper(left, inorder_index-1 )

            return root

        return treeHelper(0, len(inorder)-1)",None,"class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        inorder_map={val:idx for idx, val in enumerate(inorder)}
        postorder_idx=len(postorder)-1

        def treeHelper(left, right):
            nonlocal postorder_idx
            if left>right:
                return None

            node_val = postorder[postorder_idx]
            root=TreeNode(node_val)
            postorder_idx-=1

            inorder_index=inorder_map[node_val]

            root.right = treeHelper(inorder_index+1, right)
            root.left = treeHelper(left, inorder_index-1 )

            return root

        return treeHelper(0, len(inorder)-1)
"
3073,python3,determine-the-winner-of-a-bowling-game,"class Solution:
    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:
        res1=0
        res2=0
        if 10 in nums1 and len(nums1)>1:
            res1+=nums1[0]
            for i in range(1,len(nums1)):
                res1+=nums1[i]
                if nums1[i-1]==10 or i>=2 and nums1[i-3]==10:
                    res1+=nums1[i]
                else:
                    pass
        else:
            res1=sum(nums1)
        if 10 in nums2 and len(nums2)>1:
            res2+=nums2[0]
            for i in range(1,len(nums2)):
                res2+=nums2[i]
                if nums2[i-1]==10 or i>=2 and nums2[i-3]==10:
                    res2+=nums2[i]
                else:
                    pass
        else:
            res2=sum(nums2)

        if res1>res2:
            return(1)
        elif res1<res2:
            return(2)
        else:
            return(0)",None,"class Solution:
    def isWinner(self, nums1, nums2):
        score1, score2 = 0, 0
        for i in range(len(nums1)):
            if nums1[i] == 10 and (i >= 1 and nums1[i-1] == 10 or i >= 2 and nums1[i-2] == 10):
                score1 += nums1[i] * 2
            else:
                score1 += nums1[i]

            if nums2[i] == 10 and (i >= 1 and nums2[i-1] == 10 or i >= 2 and nums2[i-2] == 10):
                score2 += nums2[i] * 2
            else:
                score2 += nums2[i]

        if score1 > score2:
            return 1
        elif score1 < score2:
            return 2
        else:
            return 0
"
3073,python3,determine-the-winner-of-a-bowling-game,"class Solution:
    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:
        res1=0
        res2=0
        if 10 in nums1 and len(nums1)>1:
            res1+=nums1[0]
            for i in range(1,len(nums1)):
                res1+=nums1[i]
                if nums1[i-1]==10 or i>=2 and nums1[i-3]==10:
                    res1+=nums1[i]
                else:
                    pass
        else:
            res1=sum(nums1)
        if 10 in nums2 and len(nums2)>1:
            res2+=nums2[0]
            for i in range(1,len(nums2)):
                res2+=nums2[i]
                if nums2[i-1]==10 or i>=2 and nums2[i-3]==10:
                    res2+=nums2[i]
                else:
                    pass
        else:
            res2=sum(nums2)

        if res1>res2:
            return(1)
        elif res1<res2:
            return(2)
        else:
            return(0)",None,"class Solution:
    def isWinner(self, nums1, nums2):
        res1 = 0
        res2 = 0

        for i in range(len(nums1)):
            if i >= 2 and nums1[i-2] == 10:
                res1 += nums1[i] * 2
            elif nums1[i] == 10:
                res1 += nums1[i] * 2
            else:
                res1 += nums1[i]

            if i >= 2 and nums2[i-2] == 10:
                res2 += nums2[i] * 2
            elif nums2[i] == 10:
                res2 += nums2[i] * 2
            else:
                res2 += nums2[i]

        if res1 > res2:
            return 1
        elif res1 < res2:
            return 2
        else:
            return 0
"
3073,python3,determine-the-winner-of-a-bowling-game,"class Solution:
    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:
        res1=0
        res2=0
        if 10 in nums1 and len(nums1)>1:
            res1+=nums1[0]
            for i in range(1,len(nums1)):
                res1+=nums1[i]
                if nums1[i-1]==10 or i>=2 and nums1[i-3]==10:
                    res1+=nums1[i]
                else:
                    pass
        else:
            res1=sum(nums1)
        if 10 in nums2 and len(nums2)>1:
            res2+=nums2[0]
            for i in range(1,len(nums2)):
                res2+=nums2[i]
                if nums2[i-1]==10 or i>=2 and nums2[i-3]==10:
                    res2+=nums2[i]
                else:
                    pass
        else:
            res2=sum(nums2)

        if res1>res2:
            return(1)
        elif res1<res2:
            return(2)
        else:
            return(0)",None,"class Solution:
    def isWinner(self, nums1, nums2):
        res1 = 0
        res2 = 0

        for i in range(len(nums1)):
            if i >= 2 and nums1[i - 2] == 10:
                res1 += nums1[i] * 2
            else:
                res1 += nums1[i]

            if i >= 2 and nums2[i - 2] == 10:
                res2 += nums2[i] * 2
            else:
                res2 += nums2[i]

        if res1 > res2:
            return 1
        elif res1 < res2:
            return 2
        else:
            return 0
"
3074,python3,powerful-integers,"class Solution:
    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:
        if bound == 0:
            return []
        
        def get(v):
            yield 1
            if v == 1:
                return
            vi = v
            while vi <= bound:
                yield vi
                vi *= v
        
        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi < bound})",None,"class Solution:
    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:
        if bound == 0:
            return []
        
        def get(v):
            yield 1
            if v == 1:
                return
            vi = v
            while vi <= bound:
                yield vi
                vi *= v
        
        return list(set(xi + yi for xi in get(x) for yi in get(y) if xi + yi <= bound))
"
3074,python3,powerful-integers,"class Solution:
    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:
        if bound == 0:
            return []
        
        def get(v):
            yield 1
            if v == 1:
                return
            vi = v
            while vi <= bound:
                yield vi
                vi *= v
        
        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi < bound})",None,"class Solution:
    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:
        if bound == 0:
            return []
        
        def get(v):
            yield 1
            if v == 1:
                return
            vi = v
            while vi <= bound:
                yield vi
                vi *= v
        
        return list(set(xi + yi for xi in get(x) for yi in get(y) if xi + yi <= bound))
"
3074,python3,powerful-integers,"class Solution:
    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:
        if bound == 0:
            return []
        
        def get(v):
            yield 1
            if v == 1:
                return
            vi = v
            while vi <= bound:
                yield vi
                vi *= v
        
        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi < bound})",None,"class Solution:
    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:
        if bound == 0:
            return []

        def get(v):
            yield 1
            if v == 1:
                return
            vi = v
            while vi <= bound:
                yield vi
                vi *= v

        res = {xi + yi for xi in get(x) for yi in get(y) if xi + yi <= bound}
        return list(res)
"
3075,python3,partition-array-according-to-given-pivot,"class Solution:
    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:
        lst,val,tmp=[],[],[]
        for i in nums:
            if i<pivot:val.append(i)
            elif i==pivot:lst.append(i)
            else:tmp.append(i)
        return lst+val+tmp",None,"class Solution:
    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:
        lst, val, tmp = [], [], []
        for i in nums:
            if i < pivot:
                val.append(i)
            elif i == pivot:
                lst.append(i)
            else:
                tmp.append(i)
        return val + lst + tmp
"
3075,python3,partition-array-according-to-given-pivot,"class Solution:
    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:
        lst,val,tmp=[],[],[]
        for i in nums:
            if i<pivot:val.append(i)
            elif i==pivot:lst.append(i)
            else:tmp.append(i)
        return lst+val+tmp",None,"class Solution:
    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:
        lst, val, tmp = [], [], []
        for i in nums:
            if i < pivot:
                val.append(i)
            elif i == pivot:
                lst.append(i)
            else:
                tmp.append(i)
        return val + lst + tmp
"
3075,python3,partition-array-according-to-given-pivot,"class Solution:
    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:
        lst,val,tmp=[],[],[]
        for i in nums:
            if i<pivot:val.append(i)
            elif i==pivot:lst.append(i)
            else:tmp.append(i)
        return lst+val+tmp",None,"class Solution:
    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:
        lst, val, tmp = [], [], []
        for i in nums:
            if i < pivot:
                val.append(i)
            elif i == pivot:
                lst.append(i)
            else:
                tmp.append(i)
        return val + lst + tmp
"
3076,python3,find-kth-bit-in-nth-binary-string,"class Solution:
    def findKthBit(self, N, K, R = True):
        if K == 1: return '0' if R else '1'
        mid = (1 << (N - 1))
        if K <= mid: return self.findKthBit(N - 1, K, R)
        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)
        return '1' if R else '0'",None,"class Solution:
    def findKthBit(self, N, K):
        if K == 1: return '0'
        mid = (1 << (N - 1))
        if K <= mid: return self.findKthBit(N - 1, K)
        if K > mid: return '0' if self.findKthBit(N - 1, 2 * mid - K) == '1' else '1'
"
3076,python3,find-kth-bit-in-nth-binary-string,"class Solution:
    def findKthBit(self, N, K, R = True):
        if K == 1: return '0' if R else '1'
        mid = (1 << (N - 1))
        if K <= mid: return self.findKthBit(N - 1, K, R)
        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)
        return '1' if R else '0'",None,"class Solution:
    def findKthBit(self, N, K):
        if K == 1: return '0'
        mid = (1 << (N - 1))
        if K <= mid: return self.findKthBit(N - 1, K)
        if K > mid: return '0' if self.findKthBit(N - 1, 2 * mid - K) == '1' else '1'
"
3076,python3,find-kth-bit-in-nth-binary-string,"class Solution:
    def findKthBit(self, N, K, R = True):
        if K == 1: return '0' if R else '1'
        mid = (1 << (N - 1))
        if K <= mid: return self.findKthBit(N - 1, K, R)
        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)
        return '1' if R else '0'",None,"class Solution:
    def findKthBit(self, N, K):
        if K == 1: return '0'
        mid = (1 << (N - 1))
        if K <= mid: return self.findKthBit(N - 1, K)
        if K > mid: return '0' if self.findKthBit(N - 1, 2 * mid - K) == '1' else '1'
"
3077,python3,rings-and-rods,"class Solution:
    def countPoints(self, rings: str) -> int:
        lst=[]
        rgb=[]
        count=0
        for i in range(1,len(rings),2):
            rgb=[]
            if rings[i] not in lst:
                lst.append(rings[i])
                for j in range(1,len(rings),2):
                    if rings[j]==rings[i]:
                        if rings[j-1]=='R':
                            rgb.append(rings[j-1])
                        if rings[j-1]=='G':
                            rgb.append(rings[j-1])
                        if rings[j-1]=='B':
                            rgb.append(rings[j-1])
                if len(set(rgb))==2:
                    count+=1
        return count",None,"class Solution:
    def countPoints(self, rings: str) -> int:
        lst=[]
        rgb=[]
        count=0
        for i in range(1,len(rings),2):
            rgb=[]
            if rings[i] not in lst:
                lst.append(rings[i])
                for j in range(1,len(rings),2):
                    if rings[j]==rings[i]:
                        rgb.append(rings[j-1])
                if len(rgb) == 3:
                    count += 1
        return count
"
3077,python3,rings-and-rods,"class Solution:
    def countPoints(self, rings: str) -> int:
        lst=[]
        rgb=[]
        count=0
        for i in range(1,len(rings),2):
            rgb=[]
            if rings[i] not in lst:
                lst.append(rings[i])
                for j in range(1,len(rings),2):
                    if rings[j]==rings[i]:
                        if rings[j-1]=='R':
                            rgb.append(rings[j-1])
                        if rings[j-1]=='G':
                            rgb.append(rings[j-1])
                        if rings[j-1]=='B':
                            rgb.append(rings[j-1])
                if len(set(rgb))==2:
                    count+=1
        return count",None,"class Solution:
    def countPoints(self, rings: str) -> int:
        lst = set()
        count = 0
        for i in range(0, len(rings), 2):
            lst.add(rings[i])
        for color in lst:
            rgb = set()
            for i in range(0, len(rings), 2):
                if rings[i] == color:
                    rgb.add(rings[i-1])
            if len(rgb) == 3:
                count += 1
        return count
"
3077,python3,rings-and-rods,"class Solution:
    def countPoints(self, rings: str) -> int:
        lst=[]
        rgb=[]
        count=0
        for i in range(1,len(rings),2):
            rgb=[]
            if rings[i] not in lst:
                lst.append(rings[i])
                for j in range(1,len(rings),2):
                    if rings[j]==rings[i]:
                        if rings[j-1]=='R':
                            rgb.append(rings[j-1])
                        if rings[j-1]=='G':
                            rgb.append(rings[j-1])
                        if rings[j-1]=='B':
                            rgb.append(rings[j-1])
                if len(set(rgb))==2:
                    count+=1
        return count",None,"class Solution:
    def countPoints(self, rings: str) -> int:
        lst = set()
        count = 0
        for i in range(0, len(rings), 2):
            rod = rings[i]
            color = rings[i + 1]
            if color not in lst:
                lst.add(color)
                if len(lst) == 3:
                    if rings.count(color) == 10:
                        count += 1
            elif color in lst and len(lst) == 3:
                if rings.count(color) == 10:
                    count += 1
        return count
"
3078,python3,corporate-flight-bookings,"class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:

        arr = [0]*(n+1)
        for lv, ar, seats in bookings:
            arr[lv-1]+= seats
            arr[ar+1]-= seats

        return list(accumulate(arr[:-1]))",None,"class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:

        arr = [0]*n
        for lv, ar, seats in bookings:
            arr[lv-1]+= seats
            if ar < n:
                arr[ar]-= seats

        return list(accumulate(arr))
"
3078,python3,corporate-flight-bookings,"class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:

        arr = [0]*(n+1)
        for lv, ar, seats in bookings:
            arr[lv-1]+= seats
            arr[ar+1]-= seats

        return list(accumulate(arr[:-1]))",None,"class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:

        arr = [0]*n
        for lv, ar, seats in bookings:
            arr[lv-1]+= seats
            if ar < n:
                arr[ar]-= seats

        return list(accumulate(arr))
"
3078,python3,corporate-flight-bookings,"class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:

        arr = [0]*(n+1)
        for lv, ar, seats in bookings:
            arr[lv-1]+= seats
            arr[ar+1]-= seats

        return list(accumulate(arr[:-1]))",None,"class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:

        arr = [0]*(n+1)
        for lv, ar, seats in bookings:
            arr[lv-1]+= seats
            arr[ar]-= seats

        return list(accumulate(arr[1:]))
"
3079,python3,fizz-buzz,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        arr=[]
        for i in range(1,n+1):
            if i%3==0 and i%5==0:
                arr.append(""FizzBuzz"")
            elif i%3==0:
                arr.append(""Buzz"")
            elif i%5==0:
                arr.append(""Fizz"")
            else:
                arr.append(str(i))
        return arr",None,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        arr=[]
        for i in range(1,n+1):
            if i%3==0 and i%5==0:
                arr.append(""FizzBuzz"")
            elif i%3==0:
                arr.append(""Fizz"")
            elif i%5==0:
                arr.append(""Buzz"")
            else:
                arr.append(str(i))
        return arr
"
3079,python3,fizz-buzz,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        arr=[]
        for i in range(1,n+1):
            if i%3==0 and i%5==0:
                arr.append(""FizzBuzz"")
            elif i%3==0:
                arr.append(""Buzz"")
            elif i%5==0:
                arr.append(""Fizz"")
            else:
                arr.append(str(i))
        return arr",None,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        arr=[]
        for i in range(1,n+1):
            if i%3==0 and i%5==0:
                arr.append(""FizzBuzz"")
            elif i%3==0:
                arr.append(""Fizz"")
            elif i%5==0:
                arr.append(""Buzz"")
            else:
                arr.append(str(i))
        return arr
"
3079,python3,fizz-buzz,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        arr=[]
        for i in range(1,n+1):
            if i%3==0 and i%5==0:
                arr.append(""FizzBuzz"")
            elif i%3==0:
                arr.append(""Buzz"")
            elif i%5==0:
                arr.append(""Fizz"")
            else:
                arr.append(str(i))
        return arr",None,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        arr = []
        for i in range(1, n+1):
            if i % 3 == 0 and i % 5 == 0:
                arr.append(""FizzBuzz"")
            elif i % 3 == 0:
                arr.append(""Fizz"")
            elif i % 5 == 0:
                arr.append(""Buzz"")
            else:
                arr.append(str(i))
        return arr
"
3080,python3,ransom-note,"class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        ransomNote = list(ransomNote)
        magazine = list(magazine)
        for char in magazine:
            if char in ransomNote:
                ransomNote.remove(char)
            else:
                return False
        return True",None,"class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        ransomNote = collections.Counter(ransomNote)
        magazine = collections.Counter(magazine)
        for char, count in ransomNote.items():
            if magazine[char] < count:
                return False
        return True
"
3080,python3,ransom-note,"class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        ransomNote = list(ransomNote)
        magazine = list(magazine)
        for char in magazine:
            if char in ransomNote:
                ransomNote.remove(char)
            else:
                return False
        return True",None,"class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        if len(ransomNote) > len(magazine):
            return False

        ransomNote_count = collections.Counter(ransomNote)
        magazine_count = collections.Counter(magazine)

        for letter, count in ransomNote_count.items():
            if letter not in magazine_count or magazine_count[letter] < count:
                return False

        return True
"
3080,python3,ransom-note,"class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        ransomNote = list(ransomNote)
        magazine = list(magazine)
        for char in magazine:
            if char in ransomNote:
                ransomNote.remove(char)
            else:
                return False
        return True",None,"class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        ransomNote = collections.Counter(ransomNote)
        magazine = collections.Counter(magazine)
        for char, count in ransomNote.items():
            if magazine[char] < count:
                return False
        return True
"
3081,python3,k-similar-strings,"class Solution:
    def kSimilarity(self, s1: str, s2: str) -> int:
        deque = collections.deque([s1])
        
        seen = set() 
        answ=0 
        
        
        while deque:
            for _ in range(len(deque)): 
                
                string = deque.popleft() 
                if string ==s2: return answ
                
                
                i=0
                while string[i]==s2[i]:
                    i+=1
                
                
                for j in range(i+1, len(string)):
                    if string[i]==s2[j] and s2[j]==s1[j]:  
                        
                        
                        new = string[:i] + string[j] + string[i+1:j] + string[i] + string[j+1:]
                        
                        if new not in seen:
                            seen.add(new)
                            deque.append(new)
            
            answ+=1",None,"class Solution:
    def kSimilarity(self, s1: str, s2: str) -> int:
        deque = collections.deque([s1])

        seen = set() 
        answer = 0 

        while deque:
            for _ in range(len(deque)): 
                string = deque.popleft() 
                if string == s2: return answer

                i = 0
                while string[i] == s2[i]:
                    i += 1

                for j in range(i+1, len(string)):
                    if string[i] == s2[j] and s2[j] == s1[j]:
                        new = string[:i] + string[j] + string[i+1:j] + string[i] + string[j+1:]
                        if new not in seen:
                            seen.add(new)
                            deque.append(new)

            answer += 1
"
3081,python3,k-similar-strings,"class Solution:
    def kSimilarity(self, s1: str, s2: str) -> int:
        deque = collections.deque([s1])
        
        seen = set() 
        answ=0 
        
        
        while deque:
            for _ in range(len(deque)): 
                
                string = deque.popleft() 
                if string ==s2: return answ
                
                
                i=0
                while string[i]==s2[i]:
                    i+=1
                
                
                for j in range(i+1, len(string)):
                    if string[i]==s2[j] and s2[j]==s1[j]:  
                        
                        
                        new = string[:i] + string[j] + string[i+1:j] + string[i] + string[j+1:]
                        
                        if new not in seen:
                            seen.add(new)
                            deque.append(new)
            
            answ+=1",None,"class Solution:
    def kSimilarity(self, s1: str, s2: str) -> int:
        deque = collections.deque([s1])
        
        seen = set() 
        answer = 0 
        
        while deque:
            for _ in range(len(deque)): 
                
                string = deque.popleft() 
                if string == s2: return answer
                
                i = 0
                while string[i] == s2[i]:
                    i += 1
                
                for j in range(i+1, len(string)):
                    if string[i] == s2[j] and s2[j] == s1[j]:  
                        
                        
                        new = string[:i] + string[j] + string[i+1:j] + string[i] + string[j+1:]
                        
                        if new not in seen:
                            seen.add(new)
                            deque.append(new)
            
            answer += 1
"
3081,python3,k-similar-strings,"class Solution:
    def kSimilarity(self, s1: str, s2: str) -> int:
        deque = collections.deque([s1])
        
        seen = set() 
        answ=0 
        
        
        while deque:
            for _ in range(len(deque)): 
                
                string = deque.popleft() 
                if string ==s2: return answ
                
                
                i=0
                while string[i]==s2[i]:
                    i+=1
                
                
                for j in range(i+1, len(string)):
                    if string[i]==s2[j] and s2[j]==s1[j]:  
                        
                        
                        new = string[:i] + string[j] + string[i+1:j] + string[i] + string[j+1:]
                        
                        if new not in seen:
                            seen.add(new)
                            deque.append(new)
            
            answ+=1",None,"class Solution:
    def kSimilarity(self, s1: str, s2: str) -> int:
        deque = collections.deque([s1])
        
        seen = set() 
        ans = 0 
        
        while deque:
            for _ in range(len(deque)): 
                
                string = deque.popleft() 
                if string ==s2: return ans
                
                i=0
                while string[i]==s2[i]:
                    i+=1
                
                
                for j in range(i+1, len(string)):
                    if string[i]==s2[j] and s2[j]==s1[j]:  
                        
                        
                        new = string[:i] + string[j] + string[i+1:j] + string[i] + string[j+1:]
                        
                        if new not in seen:
                            seen.add(new)
                            deque.append(new)
            
            ans+=1
"
3082,python3,linked-list-cycle,"
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        a=b=head
        while(a!=None and a.next!=None):
            b=b.next
            a=a.next
            if(a==b):
                return True
        return False",None,"class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        if not head or not head.next:
            return False
        slow = head
        fast = head.next
        while slow != fast:
            if not fast or not fast.next:
                return False
            slow = slow.next
            fast = fast.next.next
        return True
"
3082,python3,linked-list-cycle,"
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        a=b=head
        while(a!=None and a.next!=None):
            b=b.next
            a=a.next
            if(a==b):
                return True
        return False",None,"class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        a=b=head
        while b is not None and b.next is not None:
            a = a.next
            b = b.next.next
            if a == b:
                return True
        return False
"
3082,python3,linked-list-cycle,"
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        a=b=head
        while(a!=None and a.next!=None):
            b=b.next
            a=a.next
            if(a==b):
                return True
        return False",None,"class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        a, b = head, head
        while a and b and b.next:
            a = a.next
            b = b.next.next
            if a == b:
                return True
        return False
"
3083,python3,minimum-cost-to-split-an-array,"class Solution:
    def minCost(self, A, K):
        n = len(A)
        dp = [0] + [float('inf')] * n
        for i in range(n):
            C = [0] * n
            val = K
            for j in range(i, -1, -1):
                val += (C[A[j]] >= 1) + (C[A[j]] == 0)
                C[A[j]] += 1
                dp[i + 1] = min(dp[i + 1], dp[j] + val)
        return dp[-1]",None,"class Solution:
    def minCost(self, A, K):
        n = len(A)
        dp = [0] + [float('inf')] * n
        for i in range(n):
            C = [0] * (K + 1)
            val = K
            for j in range(i, -1, -1):
                val += (C[A[j]] >= 1) + (C[A[j]] == 0)
                C[A[j]] += 1
                dp[i + 1] = min(dp[i + 1], dp[j] + val)
        return dp[-1]
"
3083,python3,minimum-cost-to-split-an-array,"class Solution:
    def minCost(self, A, K):
        n = len(A)
        dp = [0] + [float('inf')] * n
        for i in range(n):
            C = [0] * n
            val = K
            for j in range(i, -1, -1):
                val += (C[A[j]] >= 1) + (C[A[j]] == 0)
                C[A[j]] += 1
                dp[i + 1] = min(dp[i + 1], dp[j] + val)
        return dp[-1]",None,"class Solution:
    def minCost(self, A, K):
        n = len(A)
        dp = [0] + [float('inf')] * n
        for i in range(n):
            C = [0] * n
            val = K
            for j in range(i, -1, -1):
                val += (C[A[j]] > 0)
                C[A[j]] += 1
                dp[i + 1] = min(dp[i + 1], dp[j] + val)
        return dp[-1]
"
3083,python3,minimum-cost-to-split-an-array,"class Solution:
    def minCost(self, A, K):
        n = len(A)
        dp = [0] + [float('inf')] * n
        for i in range(n):
            C = [0] * n
            val = K
            for j in range(i, -1, -1):
                val += (C[A[j]] >= 1) + (C[A[j]] == 0)
                C[A[j]] += 1
                dp[i + 1] = min(dp[i + 1], dp[j] + val)
        return dp[-1]",None,"class Solution:
    def minCost(self, A, K):
        n = len(A)
        dp = [0] + [float('inf')] * n
        for i in range(n):
            C = [0] * n
            val = K
            for j in range(i, -1, -1):
                val += C[A[j]]
                C[A[j]] += 1
                dp[i + 1] = min(dp[i + 1], dp[j] + val)
        return dp[-1]
"
3084,python3,minimum-deletions-to-make-array-divisible,"class Solution:
    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
        gc=0
        for i in numsDivide:
            gc=int(math.gcd(gc,i))
        nums.sort()
        for i in range(len(nums)):
            if nums[i]%gc==0:
                return i
        return -1",None,"class Solution:
    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
        gc = math.gcd(*numsDivide)
        nums.sort()
        for i, num in enumerate(nums):
            if num % gc == 0:
                return i
        return -1
"
3084,python3,minimum-deletions-to-make-array-divisible,"class Solution:
    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
        gc=0
        for i in numsDivide:
            gc=int(math.gcd(gc,i))
        nums.sort()
        for i in range(len(nums)):
            if nums[i]%gc==0:
                return i
        return -1",None,"class Solution:
    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
        gc = math.gcd(*numsDivide)
        nums.sort()
        for i, num in enumerate(nums):
            if num % gc == 0:
                return i
        return -1
"
3084,python3,minimum-deletions-to-make-array-divisible,"class Solution:
    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
        gc=0
        for i in numsDivide:
            gc=int(math.gcd(gc,i))
        nums.sort()
        for i in range(len(nums)):
            if nums[i]%gc==0:
                return i
        return -1",None,"class Solution:
    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
        gc = math.gcd(*numsDivide)
        nums.sort()
        for i, num in enumerate(nums):
            if num % gc == 0:
                return i
        return -1
"
3085,python3,x-of-a-kind-in-a-deck-of-cards,"class Solution:
    def hasGroupsSizeX(self, deck: List[int]) -> bool:
        count = collections.Counter(deck)
        val = count.values()
        import math
        m = math.gcd(*val)
        if m > 2:
            return True 
        else:
            return False",None,"class Solution:
    def hasGroupsSizeX(self, deck: List[int]) -> bool:
        count = collections.Counter(deck)
        val = count.values()
        m = math.gcd(*val)
        return m > 1
"
3085,python3,x-of-a-kind-in-a-deck-of-cards,"class Solution:
    def hasGroupsSizeX(self, deck: List[int]) -> bool:
        count = collections.Counter(deck)
        val = count.values()
        import math
        m = math.gcd(*val)
        if m > 2:
            return True 
        else:
            return False",None,"class Solution:
    def hasGroupsSizeX(self, deck: List[int]) -> bool:
        count = collections.Counter(deck)
        val = count.values()
        import math
        m = math.gcd(*val)
        return m > 1
"
3085,python3,x-of-a-kind-in-a-deck-of-cards,"class Solution:
    def hasGroupsSizeX(self, deck: List[int]) -> bool:
        count = collections.Counter(deck)
        val = count.values()
        import math
        m = math.gcd(*val)
        if m > 2:
            return True 
        else:
            return False",None,"class Solution:
    def hasGroupsSizeX(self, deck: List[int]) -> bool:
        count = collections.Counter(deck)
        val = count.values()
        import math
        m = math.gcd(*val)
        return m > 1
"
3086,python3,plates-between-candles,"class Solution:
    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:
        candies = [i for i, c in enumerate(s) if c == ""|""]
        
        def bns(x: int) -> int:
            l, r = 0, len(candies) - 1
            while l <= r:
                m = (l + r) // 2
                if candies[m] < x: l = m + 1
                else: r = m + 1
            return l

        ans = []
        for a, b in queries:
            l, r = bns(a), bns(b + 1) - 1
            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)
        return ans",None,"class Solution:
    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:
        candies = [i for i, c in enumerate(s) if c == ""|""]
        
        def bns(x: int) -> int:
            l, r = 0, len(candies) - 1
            while l <= r:
                m = (l + r) // 2
                if candies[m] == x: return m
                elif candies[m] < x: l = m + 1
                else: r = m - 1
            return l

        ans = []
        for a, b in queries:
            l, r = bns(a), bns(b + 1)
            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)
        return ans
"
3086,python3,plates-between-candles,"class Solution:
    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:
        candies = [i for i, c in enumerate(s) if c == ""|""]
        
        def bns(x: int) -> int:
            l, r = 0, len(candies) - 1
            while l <= r:
                m = (l + r) // 2
                if candies[m] < x: l = m + 1
                else: r = m + 1
            return l

        ans = []
        for a, b in queries:
            l, r = bns(a), bns(b + 1) - 1
            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)
        return ans",None,"class Solution:
    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:
        candies = [i for i, c in enumerate(s) if c == ""|""]

        def bns(x: int) -> int:
            l, r = 0, len(candies) - 1
            while l <= r:
                m = (l + r) // 2
                if candies[m] < x:
                    l = m + 1
                else:
                    r = m - 1
            return l

        ans = []
        for a, b in queries:
            l, r = bns(a), bns(b + 1) - 1
            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)
        return ans
"
3086,python3,plates-between-candles,"class Solution:
    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:
        candies = [i for i, c in enumerate(s) if c == ""|""]
        
        def bns(x: int) -> int:
            l, r = 0, len(candies) - 1
            while l <= r:
                m = (l + r) // 2
                if candies[m] < x: l = m + 1
                else: r = m + 1
            return l

        ans = []
        for a, b in queries:
            l, r = bns(a), bns(b + 1) - 1
            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)
        return ans",None,"class Solution:
    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:
        candies = [i for i, c in enumerate(s) if c == ""|""]
        
        def bns(x: int) -> int:
            l, r = 0, len(candies)
            while l < r:
                m = (l + r) // 2
                if candies[m] < x: l = m + 1
                else: r = m
            return l

        ans = []
        for a, b in queries:
            l, r = bns(a), bns(b + 1)
            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)
        return ans
"
3087,python3,create-components-with-same-value,"class Solution:
    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:
        tree = [[] for _ in nums]
        for u, v in edges: 
            tree[u].append(v)
            tree[v].append(u)
        
        def fn(u, p):
            """"""Post-order dfs.""""""
            ans = nums[u]
            for v in tree[u]: 
                if v != p: ans += fn(v, u)
            return 0 if ans == cand else ans
        
        total = sum(nums)
        for cand in range(1, total//2+1): 
            if total % cand != 0 and fn(0, -1) == 0: return total//cand-1
        return 0",None,"class Solution:
    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:
        tree = [[] for _ in nums]
        for u, v in edges: 
            tree[u].append(v)
            tree[v].append(u)
        
        def fn(u, p):
            """"""Post-order dfs.""""""
            ans = nums[u]
            for v in tree[u]: 
                if v != p: ans += fn(v, u)
            return ans
        
        total = sum(nums)
        for cand in range(1, total//2+1): 
            if total % cand != 0: continue
            if fn(0, -1) == cand: return len(edges) - (total - cand)
        return 0
"
3087,python3,create-components-with-same-value,"class Solution:
    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:
        tree = [[] for _ in nums]
        for u, v in edges: 
            tree[u].append(v)
            tree[v].append(u)
        
        def fn(u, p):
            """"""Post-order dfs.""""""
            ans = nums[u]
            for v in tree[u]: 
                if v != p: ans += fn(v, u)
            return 0 if ans == cand else ans
        
        total = sum(nums)
        for cand in range(1, total//2+1): 
            if total % cand != 0 and fn(0, -1) == 0: return total//cand-1
        return 0",None,"class Solution:
    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:
        tree = [[] for _ in nums]
        for u, v in edges: 
            tree[u].append(v)
            tree[v].append(u)
        
        def fn(u, p):
            """"""Post-order dfs.""""""
            ans = nums[u]
            for v in tree[u]: 
                if v != p: ans += fn(v, u)
            return ans
        
        total = sum(nums)
        for cand in range(1, total//2+1): 
            if total % cand != 0: continue
            if fn(0, -1) == cand: return len(edges) - (total - cand)
        return 0
"
3087,python3,create-components-with-same-value,"class Solution:
    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:
        tree = [[] for _ in nums]
        for u, v in edges: 
            tree[u].append(v)
            tree[v].append(u)
        
        def fn(u, p):
            """"""Post-order dfs.""""""
            ans = nums[u]
            for v in tree[u]: 
                if v != p: ans += fn(v, u)
            return 0 if ans == cand else ans
        
        total = sum(nums)
        for cand in range(1, total//2+1): 
            if total % cand != 0 and fn(0, -1) == 0: return total//cand-1
        return 0",None,"class Solution:
    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:
        tree = [[] for _ in nums]
        for u, v in edges: 
            tree[u].append(v)
            tree[v].append(u)
        
        def fn(u, p):
            """"""Post-order dfs.""""""
            ans = nums[u]
            for v in tree[u]: 
                if v != p: ans += fn(v, u)
            return ans
        
        total = sum(nums)
        for cand in range(1, total//2+1): 
            if total % cand != 0: continue
            if fn(0, -1) == cand: return len(edges) - (total//cand - 1)
        return 0
"
3088,python3,scramble-string,"class Solution:
    @cache
    def isScramble(self, s1: str, s2: str) -> bool:
        if Counter(s1) != Counter(s2):
            return False
        if s1 == s2:
            return True
        for k in range(1, len(s1)):
            if (
                self.isScramble(s1[:-k], s2[:-k]) and self.isScramble(s1[k:], s2[k:])
            ) or (
                self.isScramble(s1[:-k], s2[k:]) and self.isScramble(s1[k:], s2[:-k])
            ): return True
        return False",None,"class Solution:
    @cache
    def isScramble(self, s1: str, s2: str) -> bool:
        if Counter(s1) != Counter(s2):
            return False
        if s1 == s2:
            return True
        for k in range(1, min(len(s1), len(s2))):
            if (
                self.isScramble(s1[:-k], s2[:-k]) and self.isScramble(s1[k:], s2[k:])
            ) or (
                self.isScramble(s1[:-k], s2[k:]) and self.isScramble(s1[k:], s2[:-k])
            ): return True
        return False
"
3088,python3,scramble-string,"class Solution:
    @cache
    def isScramble(self, s1: str, s2: str) -> bool:
        if Counter(s1) != Counter(s2):
            return False
        if s1 == s2:
            return True
        for k in range(1, len(s1)):
            if (
                self.isScramble(s1[:-k], s2[:-k]) and self.isScramble(s1[k:], s2[k:])
            ) or (
                self.isScramble(s1[:-k], s2[k:]) and self.isScramble(s1[k:], s2[:-k])
            ): return True
        return False",None,"class Solution:
    @cache
    def isScramble(self, s1: str, s2: str) -> bool:
        if Counter(s1) != Counter(s2):
            return False
        if s1 == s2:
            return True
        for k in range(1, len(s1)):
            if (
                self.isScramble(s1[:-k], s2[:-k]) and self.isScramble(s1[k:], s2[k:])
            ) or (
                self.isScramble(s1[:k], s2[-k:]) and self.isScramble(s1[k:], s2[:-k])
            ):
                return True
        return False
"
3088,python3,scramble-string,"class Solution:
    @cache
    def isScramble(self, s1: str, s2: str) -> bool:
        if Counter(s1) != Counter(s2):
            return False
        if s1 == s2:
            return True
        for k in range(1, len(s1)):
            if (
                self.isScramble(s1[:-k], s2[:-k]) and self.isScramble(s1[k:], s2[k:])
            ) or (
                self.isScramble(s1[:-k], s2[k:]) and self.isScramble(s1[k:], s2[:-k])
            ): return True
        return False",None,"class Solution:
    @cache
    def isScramble(self, s1: str, s2: str) -> bool:
        if Counter(s1) != Counter(s2):
            return False
        if s1 == s2 or (len(s1) == 1 and len(s2) == 1):
            return True
        for k in range(1, len(s1)):
            if (
                self.isScramble(s1[:-k], s2[:-k]) and self.isScramble(s1[k:], s2[k:])
            ) or (
                self.isScramble(s1[:-k], s2[k:]) and self.isScramble(s1[k:], s2[:-k])
            ):
                return True
        return False
"
3089,python3,valid-permutations-for-di-sequence,"class Solution:
    def numPermsDISequence(self, s: str) -> int:
        mem=defaultdict(int)
        def dfs(i,val=0):
            if i==len(s):
                return 1
            if (i,val) in mem:
                return mem[i,val]
            p=0
            if s[i]==""D"":
                for ind in range(0,val+1):
                    p+=dfs(i+1,ind)%(10**9+7)
            else:
                for ind in range(val+1,i+1):
                    p+=dfs(i+1,ind)%(10**9+7)
            mem[i,val]=p
            return p
        return dfs(0)",None,"class Solution:
    def numPermsDISequence(self, s: str) -> int:
        mem = defaultdict(int)

        def dfs(i, val=0):
            if i == len(s):
                return 1
            if (i, val) in mem:
                return mem[i, val]

            count = 0
            if s[i] == ""D"":
                for ind in range(val + 1):
                    count += dfs(i + 1, ind)
            else:
                for ind in range(val, i):
                    count += dfs(i + 1, ind)

            mem[i, val] = count % (10**9+7)
            return mem[i, val]

        return dfs(0)
"
3089,python3,valid-permutations-for-di-sequence,"class Solution:
    def numPermsDISequence(self, s: str) -> int:
        mem=defaultdict(int)
        def dfs(i,val=0):
            if i==len(s):
                return 1
            if (i,val) in mem:
                return mem[i,val]
            p=0
            if s[i]==""D"":
                for ind in range(0,val+1):
                    p+=dfs(i+1,ind)%(10**9+7)
            else:
                for ind in range(val+1,i+1):
                    p+=dfs(i+1,ind)%(10**9+7)
            mem[i,val]=p
            return p
        return dfs(0)",None,"class Solution:
    def numPermsDISequence(self, s: str) -> int:
        mem=defaultdict(int)
        def dfs(i,val=0):
            if i==len(s):
                return 1
            if (i,val) in mem:
                return mem[i,val]
            p=0
            if s[i]==""D"":
                for ind in range(val, -1, -1):
                    p+=dfs(i+1,ind)%(10**9+7)
            else:
                for ind in range(val+1, i+1):
                    p+=dfs(i+1,ind)%(10**9+7)
            mem[i,val]=p
            return p
        return dfs(0)
"
3089,python3,valid-permutations-for-di-sequence,"class Solution:
    def numPermsDISequence(self, s: str) -> int:
        mem=defaultdict(int)
        def dfs(i,val=0):
            if i==len(s):
                return 1
            if (i,val) in mem:
                return mem[i,val]
            p=0
            if s[i]==""D"":
                for ind in range(0,val+1):
                    p+=dfs(i+1,ind)%(10**9+7)
            else:
                for ind in range(val+1,i+1):
                    p+=dfs(i+1,ind)%(10**9+7)
            mem[i,val]=p
            return p
        return dfs(0)",None,"class Solution:
    def numPermsDISequence(self, s: str) -> int:
        mem=defaultdict(int)
        def dfs(i,val=0):
            if i==len(s):
                return 1
            if (i,val) in mem:
                return mem[i,val]
            p=0
            if s[i]==""D"":
                for ind in range(val, -1, -1):
                    p+=dfs(i+1,ind)%(10**9+7)
            else:
                for ind in range(val+1, i+1):
                    p+=dfs(i+1,ind)%(10**9+7)
            mem[i,val]=p
            return p
        return dfs(0)
"
3090,python3,check-if-string-is-transformable-with-substring-sort-operations,"class Solution:
  def isTransformable(self, s: str, t: str) -> bool:
    idx = defaultdict(deque)
    for i, c in enumerate(s):
      idx[int(c)].append(i)
    for c in t:
      d = int(c)
      if not idx[d]: return False
    idx[d].popleft()
    return True",None,"class Solution:
  def isTransformable(self, s: str, t: str) -> bool:
    idx = defaultdict(list)
    for i, c in enumerate(s):
      idx[int(c)].append(i)
    for c in t:
      d = int(c)
      if not idx[d]:
        return False
      for i in idx[d]:
        if i > idx[d - 1][-1] if d - 1 in idx else -1:
          idx[d].pop(idx[d].index(i))
          break
      else:
        return False
    return True
"
3090,python3,check-if-string-is-transformable-with-substring-sort-operations,"class Solution:
  def isTransformable(self, s: str, t: str) -> bool:
    idx = defaultdict(deque)
    for i, c in enumerate(s):
      idx[int(c)].append(i)
    for c in t:
      d = int(c)
      if not idx[d]: return False
    idx[d].popleft()
    return True",None,"class Solution:
  def isTransformable(self, s: str, t: str) -> bool:
    idx = defaultdict(list)
    for i, c in enumerate(s):
      idx[int(c)].append(i)
    for c in t:
      d = int(c)
      if not idx[d]: return False
      for i in idx[d]:
        if s[i:i+1] == c:
          idx[d].remove(i)
          break
      else:
        return False
    return True
"
3090,python3,check-if-string-is-transformable-with-substring-sort-operations,"class Solution:
  def isTransformable(self, s: str, t: str) -> bool:
    idx = defaultdict(deque)
    for i, c in enumerate(s):
      idx[int(c)].append(i)
    for c in t:
      d = int(c)
      if not idx[d]: return False
    idx[d].popleft()
    return True",None,"class Solution:
  def isTransformable(self, s: str, t: str) -> bool:
    idx = defaultdict(list)
    for i, c in enumerate(s):
      idx[int(c)].append(i)
    for c in t:
      d = int(c)
      if not idx[d]: return False
      for i in idx[d]:
        if i > idx[d-1][-1] and i > idx[d+1][-1] and i > idx[d][-2]:
          idx[d].pop(idx[d].index(i))
          break
      else:
        return False
    return True
"
3091,python3,maximum-elegance-of-a-k-length-subsequence,"class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        dico=defaultdict(list)
        for profit,category in items:
            dico[category].append(profit)
        categories=[]
        for category in dico:
            categories.append(sorted(dico[category]))
        categories.sort(key=lambda x:x[-1],reverse=True)
        def elegance (distinct):
            res=0
            rest=[]
            for i in range (distinct):
                res+=categories[i][-1]
                for j in range (len(categories[i])-1):
                    rest.append(categories[i][j])
            rest.sort(reverse=True)
            if len(rest)<k-distinct:
                return -1
            return res+sum(rest[:k-distinct])+distinct**2
        l,r=1,min(len(categories)-1,k-1)
        mid=(l+r)//2
        while l<=r: 
            if elegance(mid+1)>elegance(mid) or elegance(mid+1)==-1:
                l=mid+1
            else:
                r=mid
            mid=(l+r)//2
        return max(elegance(mid),elegance(mid+1))",None,"class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        dico=defaultdict(list)
        for profit,category in items:
            dico[category].append(profit)
        categories=sorted(dico.items(), key=lambda x:x[1][-1], reverse=True)
        def elegance (distinct):
            res=0
            rest=[]
            for i in range (distinct):
                res+=categories[i][1][-1]
                for j in range (len(categories[i][1])-1):
                    rest.append(categories[i][1][j])
            rest.sort(reverse=True)
            if len(rest)<k-distinct:
                return -1
            return res+sum(rest[:k-distinct])+distinct**2
        l,r=1,min(len(categories)-1,k-1)
        mid=(l+r)//2
        while l<=r: 
            if elegance(mid+1)>elegance(mid) or elegance(mid+1)==-1:
                l=mid+1
            else:
                r=mid
            mid=(l+r)//2
        return max(elegance(mid),elegance(mid+1))
"
3091,python3,maximum-elegance-of-a-k-length-subsequence,"class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        dico=defaultdict(list)
        for profit,category in items:
            dico[category].append(profit)
        categories=[]
        for category in dico:
            categories.append(sorted(dico[category]))
        categories.sort(key=lambda x:x[-1],reverse=True)
        def elegance (distinct):
            res=0
            rest=[]
            for i in range (distinct):
                res+=categories[i][-1]
                for j in range (len(categories[i])-1):
                    rest.append(categories[i][j])
            rest.sort(reverse=True)
            if len(rest)<k-distinct:
                return -1
            return res+sum(rest[:k-distinct])+distinct**2
        l,r=1,min(len(categories)-1,k-1)
        mid=(l+r)//2
        while l<=r: 
            if elegance(mid+1)>elegance(mid) or elegance(mid+1)==-1:
                l=mid+1
            else:
                r=mid
            mid=(l+r)//2
        return max(elegance(mid),elegance(mid+1))",None,"from collections import defaultdict
from typing import List

class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        dico = defaultdict(list)
        for profit, category in items:
            dico[category].append(profit)
        categories = sorted(dico.values(), key=lambda x: x[-1] if x else -1, reverse=True)

        def elegance(distinct: int) -> int:
            res = 0
            rest = []
            for i in range(distinct):
                res += categories[i][-1]
                rest.extend(categories[i][:-1])
            rest.sort(reverse=True)
            if distinct + len(rest) < k:
                return -1
            return res + sum(rest[:k - distinct]) + distinct ** 2

        l, r = max(0, k - len(categories)), min(k - 1, len(categories) - 1)
        mid = (l + r) // 2
        while l <= r:
            if elegance(mid + 1) > elegance(mid) or elegance(mid + 1) == -1:
                l = mid + 1
            else:
                r = mid
            mid = (l + r) // 2
        return max(elegance(mid), elegance(mid + 1))
"
3091,python3,maximum-elegance-of-a-k-length-subsequence,"class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        dico=defaultdict(list)
        for profit,category in items:
            dico[category].append(profit)
        categories=[]
        for category in dico:
            categories.append(sorted(dico[category]))
        categories.sort(key=lambda x:x[-1],reverse=True)
        def elegance (distinct):
            res=0
            rest=[]
            for i in range (distinct):
                res+=categories[i][-1]
                for j in range (len(categories[i])-1):
                    rest.append(categories[i][j])
            rest.sort(reverse=True)
            if len(rest)<k-distinct:
                return -1
            return res+sum(rest[:k-distinct])+distinct**2
        l,r=1,min(len(categories)-1,k-1)
        mid=(l+r)//2
        while l<=r: 
            if elegance(mid+1)>elegance(mid) or elegance(mid+1)==-1:
                l=mid+1
            else:
                r=mid
            mid=(l+r)//2
        return max(elegance(mid),elegance(mid+1))",None,"from collections import defaultdict
class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        dico=defaultdict(list)
        for profit,category in items:
            dico[category].append(profit)
        categories=list(dico.values())
        categories.sort(key=lambda x:x[-1],reverse=True)
        def elegance (distinct):
            res=0
            rest=[]
            for i in range (distinct):
                res+=categories[i][-1]
                rest.extend(categories[i][:-1])
            rest.sort(reverse=True)
            if len(rest)<k-distinct:
                return -1
            return res+sum(rest[:k-distinct])+distinct**2
        l,r=1,min(len(categories)-1,k-1)
        mid=(l+r)//2
        while l<=r: 
            if elegance(mid+1)>elegance(mid) or elegance(mid+1)==-1:
                l=mid+1
            else:
                r=mid
            mid=(l+r)//2
        return max(elegance(mid),elegance(mid+1))
"
3092,python3,add-edges-to-make-degrees-of-all-nodes-even,"class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        neighbors = [set() for _ in range(n)]
        for edge in edges:
            a, b = edge
            a -=1
            b -=1
            neighbors[a].add(b)
            neighbors[b].add(a)
        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]
        numOdd = len(oddDegreesNodes)
        if numOdd == 0:
            return True
        elif numOdd == 4:
            o1, o2, o3, o4 = oddDegreesNodes
            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])
        elif numOdd == 2:
            o1, o2 = oddDegreesNodes
            if o1 in neighbors[o2]:
                return True
            bothConnectedTo = neighbors[o1] | neighbors[o2]
            return len(bothConnectedTo) != n
        return False",None,"class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        neighbors = [set() for _ in range(n)]
        for edge in edges:
            a, b = edge
            a -=1
            b -=1
            neighbors[a].add(b)
            neighbors[b].add(a)
        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]
        numOdd = len(oddDegreesNodes)
        if numOdd == 0:
            return True
        elif numOdd == 2:
            o1, o2 = oddDegreesNodes
            if o1 in neighbors[o2]:
                return True
            bothConnectedTo = neighbors[o1] | neighbors[o2]
            return len(bothConnectedTo) != n
        return False
"
3092,python3,add-edges-to-make-degrees-of-all-nodes-even,"class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        neighbors = [set() for _ in range(n)]
        for edge in edges:
            a, b = edge
            a -=1
            b -=1
            neighbors[a].add(b)
            neighbors[b].add(a)
        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]
        numOdd = len(oddDegreesNodes)
        if numOdd == 0:
            return True
        elif numOdd == 4:
            o1, o2, o3, o4 = oddDegreesNodes
            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])
        elif numOdd == 2:
            o1, o2 = oddDegreesNodes
            if o1 in neighbors[o2]:
                return True
            bothConnectedTo = neighbors[o1] | neighbors[o2]
            return len(bothConnectedTo) != n
        return False",None,"class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        neighbors = [set() for _ in range(n)]
        for edge in edges:
            a, b = edge
            a -=1
            b -=1
            neighbors[a].add(b)
            neighbors[b].add(a)
        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]
        numOdd = len(oddDegreesNodes)
        if numOdd == 0:
            return True
        elif numOdd == 2:
            o1, o2 = oddDegreesNodes
            if o1 in neighbors[o2]:
                return True
            bothConnectedTo = neighbors[o1] | neighbors[o2]
            return len(bothConnectedTo) != n
        elif numOdd == 4:
            o1, o2, o3, o4 = oddDegreesNodes
            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])
        return False
"
3092,python3,add-edges-to-make-degrees-of-all-nodes-even,"class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        neighbors = [set() for _ in range(n)]
        for edge in edges:
            a, b = edge
            a -=1
            b -=1
            neighbors[a].add(b)
            neighbors[b].add(a)
        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]
        numOdd = len(oddDegreesNodes)
        if numOdd == 0:
            return True
        elif numOdd == 4:
            o1, o2, o3, o4 = oddDegreesNodes
            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])
        elif numOdd == 2:
            o1, o2 = oddDegreesNodes
            if o1 in neighbors[o2]:
                return True
            bothConnectedTo = neighbors[o1] | neighbors[o2]
            return len(bothConnectedTo) != n
        return False",None,"class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        neighbors = [set() for _ in range(n)]
        for edge in edges:
            a, b = edge
            a -=1
            b -=1
            neighbors[a].add(b)
            neighbors[b].add(a)
        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]
        numOdd = len(oddDegreesNodes)
        if numOdd == 0:
            return True
        elif numOdd == 2:
            o1, o2 = oddDegreesNodes
            bothConnectedTo = neighbors[o1] | neighbors[o2]
            return len(bothConnectedTo) != n
        return False
"
3093,python3,excel-sheet-column-title,"class Solution:
    def convertToTitle(self, n: int) -> str:
        if n<27:
            return chr(ord('A')+(n-1)%26)
        ans=""""
        if n>0:
            if n%26==0:
                ans+=chr(ord('A')+25)
                n-=1
            else:
                ans+=chr(ord('A')+n%26-1)
            n//=26
        return ans[::-1]",None,"class Solution:
    def convertToTitle(self, n: int) -> str:
        if n<27:
            return chr(ord('A')+(n-1)%26)
        ans = """"
        while n > 0:
            if n % 26 == 0:
                ans += chr(ord('A') + 25)
                n -= 26
            else:
                ans += chr(ord('A') + n % 26 - 1)
                n //= 26
        return ans[::-1]
"
3093,python3,excel-sheet-column-title,"class Solution:
    def convertToTitle(self, n: int) -> str:
        if n<27:
            return chr(ord('A')+(n-1)%26)
        ans=""""
        if n>0:
            if n%26==0:
                ans+=chr(ord('A')+25)
                n-=1
            else:
                ans+=chr(ord('A')+n%26-1)
            n//=26
        return ans[::-1]",None,"class Solution:
    def convertToTitle(self, n: int) -> str:
        if n < 27:
            return chr(ord('A') + (n - 1) % 26)
        ans = ''
        while n > 0:
            if n % 26 == 0:
                ans += chr(ord('A') + 25)
                n -= 26
            else:
                ans += chr(ord('A') + (n % 26) - 1)
                n //= 26
        return ans[::-1]
"
3093,python3,excel-sheet-column-title,"class Solution:
    def convertToTitle(self, n: int) -> str:
        if n<27:
            return chr(ord('A')+(n-1)%26)
        ans=""""
        if n>0:
            if n%26==0:
                ans+=chr(ord('A')+25)
                n-=1
            else:
                ans+=chr(ord('A')+n%26-1)
            n//=26
        return ans[::-1]",None,"class Solution:
    def convertToTitle(self, n: int) -> str:
        if n<27:
            return chr(ord('A')+(n-1)%26)
        ans=""""
        while n>0:
            if n%26==0:
                ans+='Z'
                n-=1
            else:
                ans+=chr(ord('A')+n%26-1)
            n//=26
        return ans[::-1]
"
3094,python3,sum-of-absolute-differences-in-a-sorted-array,"class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:

        n=len(nums)
        total=sum(nums)
        s1=0
        s2=total
        arr=[]
        for i in range(n):
            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i+1])*(n-i))) )
            s1=s1+nums[i]
            s2=total-s1

        return arr",None,"class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:

        n = len(nums)
        total = sum(nums)
        s1 = 0
        s2 = total
        arr = [0] * n
        for i in range(n):
            arr[i] = abs(s1 - (nums[i] * i)) + abs((s2 - (nums[i+1]) * (n-i-1)))
            s1 += nums[i]
            if i < n - 1:
                s2 -= nums[i+1]

        return arr
"
3094,python3,sum-of-absolute-differences-in-a-sorted-array,"class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:

        n=len(nums)
        total=sum(nums)
        s1=0
        s2=total
        arr=[]
        for i in range(n):
            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i+1])*(n-i))) )
            s1=s1+nums[i]
            s2=total-s1

        return arr",None,"class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:

        n=len(nums)
        total=sum(nums)
        s1=0
        s2=total
        arr=[]
        for i in range(n):
            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i+1]*(n-i-1)))))
            s1=s1+nums[i]
            s2=total-s1

        return arr
"
3094,python3,sum-of-absolute-differences-in-a-sorted-array,"class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:

        n=len(nums)
        total=sum(nums)
        s1=0
        s2=total
        arr=[]
        for i in range(n):
            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i+1])*(n-i))) )
            s1=s1+nums[i]
            s2=total-s1

        return arr",None,"class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:

        n = len(nums)
        total = sum(nums)
        s1 = 0
        s2 = total
        arr = [0] * n
        for i in range(n):
            arr[i] = abs(s1 - (nums[i] * i)) + abs((s2 - (nums[i + 1] if i + 1 < n else 0) * (n - i)))
            s1 += nums[i]
            if i + 1 < n:
                s2 -= nums[i + 1]

        return arr
"
3095,python3,find-all-lonely-numbers-in-the-array,"class Solution:
    def findLonely(self, nums: List[int]) -> List[int]:
        dic={}
        res=[]
        for i in nums:
            if i in dic:
                dic[i]+=1
            else:
                dic[i]=1
        for i in nums:
            if dic[i]==1:
                if (i not in dic) and (i+1 not in dic):  
                    res.append(i)
        return res",None,"class Solution:
    def findLonely(self, nums: List[int]) -> List[int]:
        dic={}
        res=[]
        for i in nums:
            dic[i]=dic.get(i, 0) + 1
        for i in nums:
            if dic[i]==1:
                if i-1 not in dic and i+1 not in dic:
                    res.append(i)
        return res
"
3095,python3,find-all-lonely-numbers-in-the-array,"class Solution:
    def findLonely(self, nums: List[int]) -> List[int]:
        dic={}
        res=[]
        for i in nums:
            if i in dic:
                dic[i]+=1
            else:
                dic[i]=1
        for i in nums:
            if dic[i]==1:
                if (i not in dic) and (i+1 not in dic):  
                    res.append(i)
        return res",None,"class Solution:
    def findLonely(self, nums: List[int]) -> List[int]:
        dic={}
        res=[]
        for i in nums:
            dic[i]=dic.get(i, 0) + 1
        for i in nums:
            if dic[i]==1 and (i-1) not in dic and (i+1) not in dic:
                res.append(i)
        return res
"
3095,python3,find-all-lonely-numbers-in-the-array,"class Solution:
    def findLonely(self, nums: List[int]) -> List[int]:
        dic={}
        res=[]
        for i in nums:
            if i in dic:
                dic[i]+=1
            else:
                dic[i]=1
        for i in nums:
            if dic[i]==1:
                if (i not in dic) and (i+1 not in dic):  
                    res.append(i)
        return res",None,"class Solution:
    def findLonely(self, nums: List[int]) -> List[int]:
        dic={}
        res=[]
        for i in nums:
            dic[i] = dic.get(i, 0) + 1
        for i in nums:
            if dic[i] == 1 and i-1 not in dic and i+1 not in dic:
                res.append(i)
        return res
"
3096,python3,nim-game,"class Solution:
    def canWinNim(self, n: int) -> bool:
        return n % 4 == 0",None,"class Solution:
    def canWinNim(self, n: int) -> bool:
        return n % 4 != 0
"
3096,python3,nim-game,"class Solution:
    def canWinNim(self, n: int) -> bool:
        return n % 4 == 0",None,"class Solution:
    def canWinNim(self, n: int) -> bool:
        return n % 4 != 0
"
3096,python3,nim-game,"class Solution:
    def canWinNim(self, n: int) -> bool:
        return n % 4 == 0",None,"class Solution:
    def canWinNim(self, n: int) -> bool:
        return n % 4 != 0
"
3097,python3,minimize-maximum-pair-sum-in-array,"class Solution:
    def minPairSum(self, nums: List[int]) -> int:
        nums.sort()
        list2=[]
        right=0,len(nums)-1
        while right>0:
            list2.append(nums[right]+nums[0])
            right-=1
        return max(list2)",None,"class Solution:
    def minPairSum(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)
        return max(nums[i] + nums[n-1-i] for i in range(n//2))
"
3097,python3,minimize-maximum-pair-sum-in-array,"class Solution:
    def minPairSum(self, nums: List[int]) -> int:
        nums.sort()
        list2=[]
        right=0,len(nums)-1
        while right>0:
            list2.append(nums[right]+nums[0])
            right-=1
        return max(list2)",None,"class Solution:
    def minPairSum(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)
        left, right = 0, n - 1
        max_pair_sum = float('-inf')
        while left < right:
            max_pair_sum = max(max_pair_sum, nums[left] + nums[right])
            left += 1
            right -= 1
        return max_pair_sum
"
3097,python3,minimize-maximum-pair-sum-in-array,"class Solution:
    def minPairSum(self, nums: List[int]) -> int:
        nums.sort()
        list2=[]
        right=0,len(nums)-1
        while right>0:
            list2.append(nums[right]+nums[0])
            right-=1
        return max(list2)",None,"class Solution:
    def minPairSum(self, nums: List[int]) -> int:
        nums.sort()
        list2 = []
        right = len(nums) - 1
        while right > 0:
            list2.append(nums[right] + nums[right - 1])
            right -= 1
        return max(list2)
"
3098,python3,restore-the-array,"class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:

        n = len(s)
        mod = 10**9+7

        @lru_cache(None)
        def rec(i=0):

            if i==n :
                return 1
            
            if s[i]==""0"":
                return 0
            
            res = 0
            curr = """"
            for x in range(i, n):
                curr += s[x]
                if int(curr)<=k:
                    res += (rec(x)%mod) 
                    res %= mod
                else:
                    break

            return res
        
        return rec()",None,"class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:

        n = len(s)
        mod = 10**9+7

        @lru_cache(None)
        def rec(i=0, curr=""""):

            if i==n :
                return 1 if curr =="""" or int(curr)<=k else 0
            
            if s[i]==""0"":
                return 0
            
            res = 0
            for x in range(i, n):
                curr += s[x]
                if int(curr)<=k:
                    res += (rec(x+1, curr)%mod) 
                    res %= mod
                else:
                    break

            return res
        
        return rec()
"
3098,python3,restore-the-array,"class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:

        n = len(s)
        mod = 10**9+7

        @lru_cache(None)
        def rec(i=0):

            if i==n :
                return 1
            
            if s[i]==""0"":
                return 0
            
            res = 0
            curr = """"
            for x in range(i, n):
                curr += s[x]
                if int(curr)<=k:
                    res += (rec(x)%mod) 
                    res %= mod
                else:
                    break

            return res
        
        return rec()",None,"class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:

        n = len(s)
        mod = 10**9+7

        @lru_cache(None)
        def rec(i=0, curr=''):

            if i==n :
                return 1 if not curr else 0

            res = 0
            if curr != '' and int(curr) > k:
                return 0

            if s[i]==""0"":
                res += rec(i+1, curr)
            else:
                res += rec(i+1, curr+s[i])
                if curr != '':
                    res += rec(i+1, curr+s[i])

            res %= mod
            return res

        return rec()
"
3098,python3,restore-the-array,"class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:

        n = len(s)
        mod = 10**9+7

        @lru_cache(None)
        def rec(i=0):

            if i==n :
                return 1
            
            if s[i]==""0"":
                return 0
            
            res = 0
            curr = """"
            for x in range(i, n):
                curr += s[x]
                if int(curr)<=k:
                    res += (rec(x)%mod) 
                    res %= mod
                else:
                    break

            return res
        
        return rec()",None,"class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:

        n = len(s)
        mod = 10**9+7

        @lru_cache(None)
        def rec(i=0, curr=""""):

            if i==n :
                return 1 if not curr else 0
            
            if s[i]==""0"":
                return 0
            
            res = 0
            if int(curr+s[i])<=k:
                res += (rec(i+1, curr+s[i])%mod) 
                res %= mod

            res += (rec(i+1, curr)%mod) 
            res %= mod

            return res
        
        return rec()
"
3099,python3,minimum-flips-to-make-a-or-b-equal-to-c,"class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        if a | b == c: return 0
        c = ('0' * 32 + bin(c)[2:])[-32:]
        a = ('0' * 32 + bin(a)[2:])[-32:]
        b = ('0' * 32 + bin(b)[2:])[-32:]
        
        
        cnt = 0
        for i in range(len(c)):
            if c[i] == '0':
                if not (a[i] == c[i] or b[i] == c[i]):
                    cnt += 1
            else:
                if a[i] != c[i]:
                    cnt += 1
                if b[i] != c[i]:
                    cnt += 1
        return cnt",None,"class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        if a | b == c: return 0
        c = bin(c)[2:].zfill(32)
        a = bin(a)[2:].zfill(32)
        b = bin(b)[2:].zfill(32)

        cnt = 0
        for i in range(len(c)):
            if c[i] == '0':
                if a[i] != c[i]:
                    cnt += 1
                if b[i] != c[i]:
                    cnt += 1
            else:
                if a[i] != c[i] and a[i] != '0':
                    cnt += 1
                if b[i] != c[i] and b[i] != '0':
                    cnt += 1
        return cnt
"
3099,python3,minimum-flips-to-make-a-or-b-equal-to-c,"class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        if a | b == c: return 0
        c = ('0' * 32 + bin(c)[2:])[-32:]
        a = ('0' * 32 + bin(a)[2:])[-32:]
        b = ('0' * 32 + bin(b)[2:])[-32:]
        
        
        cnt = 0
        for i in range(len(c)):
            if c[i] == '0':
                if not (a[i] == c[i] or b[i] == c[i]):
                    cnt += 1
            else:
                if a[i] != c[i]:
                    cnt += 1
                if b[i] != c[i]:
                    cnt += 1
        return cnt",None,"class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        if a | b == c: return 0
        c = bin(c)[2:].zfill(32)
        a = bin(a)[2:].zfill(32)
        b = bin(b)[2:].zfill(32)

        cnt = 0
        for i in range(32):
            if c[i] == '0':
                if a[i] != c[i] and b[i] != c[i]:
                    cnt += 1
            else:
                if a[i] != c[i]:
                    cnt += 1
                if b[i] != c[i]:
                    cnt += 1
        return cnt
"
3099,python3,minimum-flips-to-make-a-or-b-equal-to-c,"class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        if a | b == c: return 0
        c = ('0' * 32 + bin(c)[2:])[-32:]
        a = ('0' * 32 + bin(a)[2:])[-32:]
        b = ('0' * 32 + bin(b)[2:])[-32:]
        
        
        cnt = 0
        for i in range(len(c)):
            if c[i] == '0':
                if not (a[i] == c[i] or b[i] == c[i]):
                    cnt += 1
            else:
                if a[i] != c[i]:
                    cnt += 1
                if b[i] != c[i]:
                    cnt += 1
        return cnt",None,"class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        if a | b == c: return 0
        c = bin(c)[2:].zfill(32)
        a = bin(a)[2:].zfill(32)
        b = bin(b)[2:].zfill(32)

        cnt = 0
        for i in range(len(c)):
            if c[i] == '0':
                if a[i] != c[i] and b[i] != c[i]:
                    cnt += 1
            else:
                if a[i] != c[i]:
                    cnt += 1
                if b[i] != c[i]:
                    cnt += 1
        return cnt
"
3100,python3,number-of-ways-to-split-a-string,"class Solution:
    def numWays(self, s: str) -> int:
        MOD = 10 ** 9 + 7
        N = len(s)
        c1 = s.count('1')
        if not c1:
            return (((N-1)*(N-2))//2) % MOD
        if c1 % 3:
            return 0
        idx1, idx2, idx3, idx4 = 0, 0, 0, 0
        cnt = 0
        for i in range(N):
            if s[i] == '1':
                cnt += 1
            if cnt == c1//3:
                idx1 = i
                break
        for i in range(idx1+1,N):
            if s[i] == '0':
                idx2 = i
                break
        for i in range(N-1,-1,-1):
            if s[i] == '1':
                cnt += 1
            if cnt == c1//3:
                idx4 = i
                break
        for i in range(idx4-1,-1,-1):
            if s[i] == '1':
                idx3 = i
                break
        return ((idx2-idx1) * (idx4-idx3)) % MOD",None,"class Solution:
    def numWays(self, s: str) -> int:
        MOD = 10 ** 9 + 7
        N = len(s)
        c1 = s.count('1')
        if not c1:
            return (((N-1)*(N-2))//2) % MOD
        if c1 % 3:
            return 0
        count = [0] * (c1 + 1)
        count[0] = 1
        ones = 0
        for i in range(N):
            if s[i] == '1':
                ones += 1
            count[ones] = (count[ones] + count[ones - c1 // 3]) % MOD
        return count[c1 // 3]
"
3100,python3,number-of-ways-to-split-a-string,"class Solution:
    def numWays(self, s: str) -> int:
        MOD = 10 ** 9 + 7
        N = len(s)
        c1 = s.count('1')
        if not c1:
            return (((N-1)*(N-2))//2) % MOD
        if c1 % 3:
            return 0
        idx1, idx2, idx3, idx4 = 0, 0, 0, 0
        cnt = 0
        for i in range(N):
            if s[i] == '1':
                cnt += 1
            if cnt == c1//3:
                idx1 = i
                break
        for i in range(idx1+1,N):
            if s[i] == '0':
                idx2 = i
                break
        for i in range(N-1,-1,-1):
            if s[i] == '1':
                cnt += 1
            if cnt == c1//3:
                idx4 = i
                break
        for i in range(idx4-1,-1,-1):
            if s[i] == '1':
                idx3 = i
                break
        return ((idx2-idx1) * (idx4-idx3)) % MOD",None,"class Solution:
    def numWays(self, s: str) -> int:
        MOD = 10 ** 9 + 7
        N = len(s)
        c1 = s.count('1')
        if not c1:
            return (((N-1)*(N-2))//2) % MOD
        if c1 % 3:
            return 0
        idx1, idx2, idx3, idx4 = 0, 0, 0, 0
        cnt = 0
        for i in range(N):
            if s[i] == '1':
                cnt += 1
            if cnt == c1//3:
                idx1 = i
                break
        for i in range(idx1+1,N):
            if s[i] == '0':
                idx2 = i
                break
        cnt = 0
        for i in range(N-1,-1,-1):
            if s[i] == '1':
                cnt += 1
            if cnt == c1//3:
                idx4 = i
                break
        for i in range(idx4-1,-1,-1):
            if s[i] == '1':
                idx3 = i
                break
        return ((idx2-idx1) * (idx4-idx3)) % MOD
"
3100,python3,number-of-ways-to-split-a-string,"class Solution:
    def numWays(self, s: str) -> int:
        MOD = 10 ** 9 + 7
        N = len(s)
        c1 = s.count('1')
        if not c1:
            return (((N-1)*(N-2))//2) % MOD
        if c1 % 3:
            return 0
        idx1, idx2, idx3, idx4 = 0, 0, 0, 0
        cnt = 0
        for i in range(N):
            if s[i] == '1':
                cnt += 1
            if cnt == c1//3:
                idx1 = i
                break
        for i in range(idx1+1,N):
            if s[i] == '0':
                idx2 = i
                break
        for i in range(N-1,-1,-1):
            if s[i] == '1':
                cnt += 1
            if cnt == c1//3:
                idx4 = i
                break
        for i in range(idx4-1,-1,-1):
            if s[i] == '1':
                idx3 = i
                break
        return ((idx2-idx1) * (idx4-idx3)) % MOD",None,"class Solution:
    def numWays(self, s: str) -> int:
        MOD = 10 ** 9 + 7
        N = len(s)
        c1 = s.count('1')
        if not c1:
            return (((N-1)*(N-2))//2) % MOD
        if c1 % 3:
            return 0
        idx1 = 0
        cnt = 0
        for i in range(N):
            if s[i] == '1':
                cnt += 1
            if cnt == c1//3:
                idx1 = i+1
                break
        idx2 = 0
        cnt = 0
        for i in range(idx1, N):
            if s[i] == '0':
                cnt += 1
            if cnt == (c1//3)-1:
                idx2 = i
                break
        idx3 = N
        cnt = 0
        for i in range(N-1, -1, -1):
            if s[i] == '1':
                cnt += 1
            if cnt == (c1//3)-1:
                idx3 = i
                break
        idx4 = N
        cnt = 0
        for i in range(idx3-1, -1, -1):
            if s[i] == '1':
                cnt += 1
            if cnt == (c1//3)-1:
                idx4 = i
                break
        return ((idx2-idx1) * (idx4-idx3)) % MOD
"
3101,python3,sequential-digits,"class Solution:
    def sequentialDigits(self, low, high):
        out = []
        queue = deque(range(1,10))
        while queue:
            elem = queue.popleft()
            if low <= elem <= high:
                out.append(elem)
            last = elem % 10
            if last > 9: queue.append(elem*10 + last + 1)
                    
        return out",None,"class Solution:
    def sequentialDigits(self, low, high):
        out = []
        queue = deque(range(1,10))
        while queue:
            elem = queue.popleft()
            if low <= elem <= high:
                out.append(elem)
            if elem < high:
                last = elem % 10
                queue.append(elem*10 + last + 1)
        return sorted(out)
"
3101,python3,sequential-digits,"class Solution:
    def sequentialDigits(self, low, high):
        out = []
        queue = deque(range(1,10))
        while queue:
            elem = queue.popleft()
            if low <= elem <= high:
                out.append(elem)
            last = elem % 10
            if last > 9: queue.append(elem*10 + last + 1)
                    
        return out",None,"class Solution:
    def sequentialDigits(self, low, high):
        out = []
        queue = deque(range(1,10))
        while queue:
            elem = queue.popleft()
            if low <= elem <= high:
                out.append(elem)
            last = elem % 10
            if last < 9:
                queue.append(elem*10 + last + 1)
        return sorted(out)
"
3101,python3,sequential-digits,"class Solution:
    def sequentialDigits(self, low, high):
        out = []
        queue = deque(range(1,10))
        while queue:
            elem = queue.popleft()
            if low <= elem <= high:
                out.append(elem)
            last = elem % 10
            if last > 9: queue.append(elem*10 + last + 1)
                    
        return out",None,"class Solution:
    def sequentialDigits(self, low, high):
        out = []
        queue = deque(range(1,10))
        while queue:
            elem = queue.popleft()
            if low <= elem <= high:
                out.append(elem)
            last = elem % 10
            if last < 9: queue.append(elem*10 + last + 1)
                    
        return sorted(out)
"
3102,python3,construct-quad-tree,"class Solution:
    def construct(self, grid: List[List[int]]) -> 'Node':
        level = len(grid)
        root = None
        if level >= 1:
            root = self.buildTree(grid, 0, level, 0, level, level)
        return root
        
        
    def buildTree(self, grid, rs, re, cs, ce, level):
        if level == 1:
            return Node(grid[rs][cs], True, None, None, None, None)
        
        next_level = level // 2
        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)
        tr = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)
        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)
        br = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)
        
        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:
            if tl.val == tr.val == bl.val == br.val:
                new_node = Node(tl.val, True, None, None, None, None)
            else:
                new_node = Node(tl.val, False, tl, tr, bl, br)
            else:
                new_node = Node(tl.val, False, tl, tr, bl, br)
            
        return new_node",None,"class Solution:
    def construct(self, grid: List[List[int]]) -> 'Node':
        level = len(grid)
        root = None
        if level >= 1:
            root = self.buildTree(grid, 0, level, 0, level, level)
        return root

    def buildTree(self, grid, rs, re, cs, ce, level):
        if level == 1:
            return Node(grid[rs][cs], True, None, None, None, None)

        next_level = level // 2
        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)
        tr = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)
        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)
        br = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)

        if tl.val == tr.val == bl.val == br.val:
            new_node = Node(tl.val, True, None, None, None, None)
        else:
            new_node = Node(False, False, tl, tr, bl, br)

        return new_node
"
3102,python3,construct-quad-tree,"class Solution:
    def construct(self, grid: List[List[int]]) -> 'Node':
        level = len(grid)
        root = None
        if level >= 1:
            root = self.buildTree(grid, 0, level, 0, level, level)
        return root
        
        
    def buildTree(self, grid, rs, re, cs, ce, level):
        if level == 1:
            return Node(grid[rs][cs], True, None, None, None, None)
        
        next_level = level // 2
        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)
        tr = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)
        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)
        br = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)
        
        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:
            if tl.val == tr.val == bl.val == br.val:
                new_node = Node(tl.val, True, None, None, None, None)
            else:
                new_node = Node(tl.val, False, tl, tr, bl, br)
            else:
                new_node = Node(tl.val, False, tl, tr, bl, br)
            
        return new_node",None,"class Solution:
    def construct(self, grid: List[List[int]]) -> 'Node':
        level = len(grid)
        root = None
        if level >= 1:
            root = self.buildTree(grid, 0, level, 0, level, level)
        return root

    def buildTree(self, grid, rs, re, cs, ce, level):
        if level == 1:
            return Node(grid[rs][cs], True, None, None, None, None)

        next_level = level // 2
        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)
        tr = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)
        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)
        br = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)

        if tl.val == tr.val == bl.val == br.val:
            new_node = Node(tl.val, True, None, None, None, None)
        else:
            new_node = Node(False, False, tl, tr, bl, br)

        return new_node
"
3102,python3,construct-quad-tree,"class Solution:
    def construct(self, grid: List[List[int]]) -> 'Node':
        level = len(grid)
        root = None
        if level >= 1:
            root = self.buildTree(grid, 0, level, 0, level, level)
        return root
        
        
    def buildTree(self, grid, rs, re, cs, ce, level):
        if level == 1:
            return Node(grid[rs][cs], True, None, None, None, None)
        
        next_level = level // 2
        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)
        tr = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)
        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)
        br = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)
        
        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:
            if tl.val == tr.val == bl.val == br.val:
                new_node = Node(tl.val, True, None, None, None, None)
            else:
                new_node = Node(tl.val, False, tl, tr, bl, br)
            else:
                new_node = Node(tl.val, False, tl, tr, bl, br)
            
        return new_node",None,"class Solution:
    def construct(self, grid: List[List[int]]) -> 'Node':
        level = len(grid)
        root = None
        if level >= 1:
            root = self.buildTree(grid, 0, level, 0, level, level)
        return root

    def buildTree(self, grid, rs, re, cs, ce, level):
        if level == 1:
            return Node(grid[rs][cs], True, None, None, None, None)

        next_level = level // 2
        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)
        tr = self.buildTree(grid, rs, re - next_level, cs + next_level, ce, next_level)
        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)
        br = self.buildTree(grid, re - next_level, re, cs + next_level, ce, next_level)

        if tl.val == tr.val == bl.val == br.val:
            new_node = Node(tl.val, True, None, None, None, None)
        else:
            new_node = Node(False, False, tl, tr, bl, br)

        return new_node
"
3103,python3,remove-duplicates-from-sorted-array-ii,"from collections import Counter

class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        counter = Counter(nums)
        index = 0

        for num, count in counter.items():
            nums[index] = num
            index += 1
            if count > 2:
                nums[index] = num
                index += 1

        return index",None,"from collections import Counter

class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        counter = Counter(nums)
        index = 0

        for num, count in counter.items():
            nums[index] = num
            index += 1
            if count > 2:
                break

        return index
"
3103,python3,remove-duplicates-from-sorted-array-ii,"from collections import Counter

class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        counter = Counter(nums)
        index = 0

        for num, count in counter.items():
            nums[index] = num
            index += 1
            if count > 2:
                nums[index] = num
                index += 1

        return index",None,"from collections import Counter

class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        counter = Counter(nums)
        index = 0

        for num, count in counter.items():
            nums[index] = num
            index += 1
            if count > 2:
                break

        return index
"
3103,python3,remove-duplicates-from-sorted-array-ii,"from collections import Counter

class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        counter = Counter(nums)
        index = 0

        for num, count in counter.items():
            nums[index] = num
            index += 1
            if count > 2:
                nums[index] = num
                index += 1

        return index",None,"from collections import Counter

class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        counter = Counter(nums)
        index = 0

        for num, count in counter.items():
            nums[index] = num
            index += 1
            if count > 2:
                break

        return index
"
3104,python3,remove-linked-list-elements,"class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        result = ListNode(0)
        result.next = head
        cur = result
        while cur.next:
            if cur.next.val == val:
                cur.next = cur.next.next
            cur = cur.next
        return result.next",None,"class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        result = ListNode(0)
        result.next = head
        cur = result
        while cur.next:
            if cur.next.val == val:
                cur.next = cur.next.next
            else:
                cur = cur.next
        return result.next
"
3104,python3,remove-linked-list-elements,"class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        result = ListNode(0)
        result.next = head
        cur = result
        while cur.next:
            if cur.next.val == val:
                cur.next = cur.next.next
            cur = cur.next
        return result.next",None,"class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        result = ListNode(0)
        result.next = head
        cur = result
        while cur.next:
            if cur.next.val == val:
                cur.next = cur.next.next
            else:
                cur = cur.next
        return result.next
"
3104,python3,remove-linked-list-elements,"class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        result = ListNode(0)
        result.next = head
        cur = result
        while cur.next:
            if cur.next.val == val:
                cur.next = cur.next.next
            cur = cur.next
        return result.next",None,"class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        result = ListNode(0)
        result.next = head
        cur = result
        while cur.next:
            if cur.next.val == val:
                cur.next = cur.next.next
            else:
                cur = cur.next
        return result.next
"
3105,python3,delete-operation-for-two-strings,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m=len(word1)
        n=len(word2)
        dp=[]
        for i in range (m+1):
            dp.append([0]*(n+1))
        for i in range (m+1):
            dp[i][0]=i
        for i in range (n+1):
            dp[0][i]=i
        for i in range (1,m+1):
            for j in range (1,n+1):
                if word1[i]==word2[j]:
                    dp[i][j]=dp[i-1][j-1]
                else:
                    dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1
        return dp[-1][-1]",None,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m=len(word1)
        n=len(word2)
        dp=[[0]*(n+1) for _ in range(m+1)]
        for i in range (m+1):
            dp[i][0]=i
        for i in range (n+1):
            dp[0][i]=i
        for i in range (1,m+1):
            for j in range (1,n+1):
                if word1[i-1]==word2[j-1]:
                    dp[i][j]=dp[i-1][j-1]
                else:
                    dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1
        return dp[m][n]
"
3105,python3,delete-operation-for-two-strings,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m=len(word1)
        n=len(word2)
        dp=[]
        for i in range (m+1):
            dp.append([0]*(n+1))
        for i in range (m+1):
            dp[i][0]=i
        for i in range (n+1):
            dp[0][i]=i
        for i in range (1,m+1):
            for j in range (1,n+1):
                if word1[i]==word2[j]:
                    dp[i][j]=dp[i-1][j-1]
                else:
                    dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1
        return dp[-1][-1]",None,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m = len(word1)
        n = len(word2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(m + 1):
            dp[i][0] = i
        for i in range(n + 1):
            dp[0][i] = i

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if word1[i - 1] == word2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + 1

        return dp[m][n]
"
3105,python3,delete-operation-for-two-strings,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m=len(word1)
        n=len(word2)
        dp=[]
        for i in range (m+1):
            dp.append([0]*(n+1))
        for i in range (m+1):
            dp[i][0]=i
        for i in range (n+1):
            dp[0][i]=i
        for i in range (1,m+1):
            for j in range (1,n+1):
                if word1[i]==word2[j]:
                    dp[i][j]=dp[i-1][j-1]
                else:
                    dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1
        return dp[-1][-1]",None,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m = len(word1)
        n = len(word2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(m + 1):
            dp[i][0] = i
        for i in range(n + 1):
            dp[0][i] = i

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if word1[i - 1] == word2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + 1

        return dp[m][n]
"
3106,python3,third-maximum-number,"class Solution:
    def thirdMax(self, nums: List[int]) -> int:
        return max(list(set(nums))) if len(list(set(nums)))>3 else sorted(list(set(nums)))[-3]",None,"class Solution:
    def thirdMax(self, nums: List[int]) -> int:
        nums = sorted(list(set(nums)))
        if len(nums) < 3:
            return max(nums)
        return nums[-3]
"
3106,python3,third-maximum-number,"class Solution:
    def thirdMax(self, nums: List[int]) -> int:
        return max(list(set(nums))) if len(list(set(nums)))>3 else sorted(list(set(nums)))[-3]",None,"class Solution:
    def thirdMax(self, nums: List[int]) -> int:
        nums = list(set(nums))
        nums.sort()
        return nums[-3] if len(nums) > 2 else nums[-1]
"
3106,python3,third-maximum-number,"class Solution:
    def thirdMax(self, nums: List[int]) -> int:
        return max(list(set(nums))) if len(list(set(nums)))>3 else sorted(list(set(nums)))[-3]",None,"class Solution:
    def thirdMax(self, nums: List[int]) -> int:
        nums = list(set(nums))
        if len(nums) < 3:
            return max(nums)
        else:
            return sorted(nums)[-3]
"
3107,python3,verifying-an-alien-dictionary,"class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        mapper = {chr(i):-1 for i in range(97,97+26)}
        def map_value():
            nonlocal order
            nonlocal mapper
            for i in range(len(order)):
                mapper[order[i]] = i
        map_value()
        def helper():
            for i in range(len(words)-1):
                if len(words[i+1])<len(words[i]) and mapper[words[i+1][0]] <= mapper[words[i][0]] and words[i+1] not in words[i]:
                    return False
                else:
                    for j in range(min(len(words[i]), len(words[i+1]))):
                        if words[i][j] != words[i+1][j]:
                            if mapper[words[i+1][j]] < mapper[words[i][j]]:
                                return False
                            break
            return True
        return helper()",None,"class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        mapper = {chr(i):-1 for i in range(97,97+26)}
        def map_value():
            nonlocal order
            nonlocal mapper
            for i in range(len(order)):
                mapper[order[i]] = i
        map_value()
        def helper():
            for i in range(len(words)-1):
                if len(words[i+1])<len(words[i]) and mapper[words[i+1][0]] < mapper[words[i][0]]:
                    return False
                elif len(words[i+1])<len(words[i]) and mapper[words[i+1][0]] == mapper[words[i][0]]:
                    continue
                elif len(words[i+1])>=len(words[i]):
                    for j in range(min(len(words[i]), len(words[i+1]))):
                        if words[i][j] != words[i+1][j]:
                            if mapper[words[i+1][j]] < mapper[words[i][j]]:
                                return False
                            break
                else:
                    return False
            return True
        return helper()
"
3107,python3,verifying-an-alien-dictionary,"class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        mapper = {chr(i):-1 for i in range(97,97+26)}
        def map_value():
            nonlocal order
            nonlocal mapper
            for i in range(len(order)):
                mapper[order[i]] = i
        map_value()
        def helper():
            for i in range(len(words)-1):
                if len(words[i+1])<len(words[i]) and mapper[words[i+1][0]] <= mapper[words[i][0]] and words[i+1] not in words[i]:
                    return False
                else:
                    for j in range(min(len(words[i]), len(words[i+1]))):
                        if words[i][j] != words[i+1][j]:
                            if mapper[words[i+1][j]] < mapper[words[i][j]]:
                                return False
                            break
            return True
        return helper()",None,"class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        mapper = {ch: i for i, ch in enumerate(order)}

        def helper():
            for i in range(len(words) - 1):
                for j in range(min(len(words[i]), len(words[i + 1]))):
                    if words[i][j] != words[i + 1][j]:
                        if mapper[words[i][j]] > mapper[words[i + 1][j]]:
                            return False
                        break
                else:
                    if len(words[i]) > len(words[i + 1]):
                        return False
            return True
        return helper()
"
3107,python3,verifying-an-alien-dictionary,"class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        mapper = {chr(i):-1 for i in range(97,97+26)}
        def map_value():
            nonlocal order
            nonlocal mapper
            for i in range(len(order)):
                mapper[order[i]] = i
        map_value()
        def helper():
            for i in range(len(words)-1):
                if len(words[i+1])<len(words[i]) and mapper[words[i+1][0]] <= mapper[words[i][0]] and words[i+1] not in words[i]:
                    return False
                else:
                    for j in range(min(len(words[i]), len(words[i+1]))):
                        if words[i][j] != words[i+1][j]:
                            if mapper[words[i+1][j]] < mapper[words[i][j]]:
                                return False
                            break
            return True
        return helper()",None,"class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        mapper = {chr(i):-1 for i in range(97,97+26)}
        def map_value():
            nonlocal order
            nonlocal mapper
            for i in range(len(order)):
                mapper[order[i]] = i
        map_value()
        def helper():
            for i in range(len(words)-1):
                if len(words[i+1])<len(words[i]):
                    if mapper[words[i+1][0]] <= mapper[words[i][0]] and words[i+1] not in words[i]:
                        return False
                else:
                    for j in range(min(len(words[i]), len(words[i+1]))):
                        if words[i][j] != words[i+1][j]:
                            if mapper[words[i+1][j]] < mapper[words[i][j]]:
                                return False
                            break
            return True
        return helper()
"
3108,python3,pascals-triangle,"class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows == 0:
            return [[1]]
        prev = self.generate(numRows - 1)
        fin = prev[-1]
        now = [1]
        for i in range(len(fin)-1):
            now.append(fin[i] + fin[i+1])
        now.append(1)
        prev.append(now)
        return prev",None,"class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows == 0:
            return [[1]]
        prev = self.generate(numRows - 1)
        fin = prev[-1]
        now = [1]
        for i in range(len(fin)-1):
            now.append(fin[i] + fin[i+1])
        now.append(1)
        prev.append(now)
        return prev[:numRows]
"
3108,python3,pascals-triangle,"class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows == 0:
            return [[1]]
        prev = self.generate(numRows - 1)
        fin = prev[-1]
        now = [1]
        for i in range(len(fin)-1):
            now.append(fin[i] + fin[i+1])
        now.append(1)
        prev.append(now)
        return prev",None,"class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows == 0:
            return [[1]]
        prev = self.generate(numRows - 1)
        fin = prev[-1]
        now = [1]
        for i in range(len(fin)-1):
            now.append(fin[i] + fin[i+1])
        now.append(1)
        prev.append(now)
        return prev[:numRows]
"
3108,python3,pascals-triangle,"class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows == 0:
            return [[1]]
        prev = self.generate(numRows - 1)
        fin = prev[-1]
        now = [1]
        for i in range(len(fin)-1):
            now.append(fin[i] + fin[i+1])
        now.append(1)
        prev.append(now)
        return prev",None,"class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows == 0:
            return [[1]]
        prev = self.generate(numRows - 1)
        now = [1]
        if numRows > 1:
            fin = prev[-1]
            for i in range(len(fin)-1):
                now.append(fin[i] + fin[i+1])
            now.append(1)
        prev.append(now)
        return prev
"
3109,python3,split-linked-list-in-parts,"class Solution:
    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:

    
        l = []
        length = 0
        ptr = head
        while(ptr) :
            length += 1
            ptr = ptr.next

        arrange = []
        maxi = length//k 
        remain = length%k

        for i in range(k) :
            if remain :
                arrange.append(maxi + 1)
                remain -= 1
            else:
                arrange.append(maxi)

        j = 0
        ptr = head 
        i = 0
        while(ptr) :
            q = ptr 
            i += 1
            ptr = ptr.next 
            if i == arrange[j] :
                q.next = None
                l.append(head)
                head = ptr 
                i = 0
                j += 1

        for i in range(j,k+1):
            l.append(None)
        return l",None,"class Solution:
    def splitListToParts(self, head: ListNode, k: int) -> List[Optional[ListNode]]:

        length = 0
        ptr = head
        while ptr:
            length += 1
            ptr = ptr.next

        arrange = []
        maxi = length // k
        remain = length % k

        for i in range(k):
            if remain:
                arrange.append(maxi + 1)
                remain -= 1
            else:
                arrange.append(maxi)

        j = 0
        prev = None
        ptr = head
        i = 0
        while ptr:
            q = ptr
            i += 1
            ptr = ptr.next
            if i == arrange[j]:
                q.next = None
                if prev:
                    prev.next = q
                prev = q
                i = 0
                j += 1

        result = []
        for i in range(k):
            if i < len(arrange):
                result.append(head if i == 0 else prev.next)
            else:
                result.append(None)

        return result
"
3109,python3,split-linked-list-in-parts,"class Solution:
    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:

    
        l = []
        length = 0
        ptr = head
        while(ptr) :
            length += 1
            ptr = ptr.next

        arrange = []
        maxi = length//k 
        remain = length%k

        for i in range(k) :
            if remain :
                arrange.append(maxi + 1)
                remain -= 1
            else:
                arrange.append(maxi)

        j = 0
        ptr = head 
        i = 0
        while(ptr) :
            q = ptr 
            i += 1
            ptr = ptr.next 
            if i == arrange[j] :
                q.next = None
                l.append(head)
                head = ptr 
                i = 0
                j += 1

        for i in range(j,k+1):
            l.append(None)
        return l",None,"class Solution:
    def splitListToParts(self, head: ListNode, k: int) -> List[Optional[ListNode]]:

        length = 0
        ptr = head
        while ptr:
            length += 1
            ptr = ptr.next

        arrange = []
        maxi = length // k
        remain = length % k

        for i in range(k):
            if remain:
                arrange.append(maxi + 1)
                remain -= 1
            else:
                arrange.append(maxi)

        j = 0
        ptr = head
        i = 0
        result = []
        while ptr:
            q = ptr
            i += 1
            ptr = ptr.next
            if i == arrange[j]:
                q.next = None
                result.append(head)
                head = ptr
                i = 0
                j += 1

        while j < k:
            result.append(None)
            j += 1

        return result
"
3109,python3,split-linked-list-in-parts,"class Solution:
    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:

    
        l = []
        length = 0
        ptr = head
        while(ptr) :
            length += 1
            ptr = ptr.next

        arrange = []
        maxi = length//k 
        remain = length%k

        for i in range(k) :
            if remain :
                arrange.append(maxi + 1)
                remain -= 1
            else:
                arrange.append(maxi)

        j = 0
        ptr = head 
        i = 0
        while(ptr) :
            q = ptr 
            i += 1
            ptr = ptr.next 
            if i == arrange[j] :
                q.next = None
                l.append(head)
                head = ptr 
                i = 0
                j += 1

        for i in range(j,k+1):
            l.append(None)
        return l",None,"class Solution:
    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:

        length = 0
        ptr = head
        while ptr:
            length += 1
            ptr = ptr.next

        arrange = []
        maxi = length // k
        remain = length % k

        for i in range(k):
            if remain:
                arrange.append(maxi + 1)
                remain -= 1
            else:
                arrange.append(maxi)

        j = 0
        ptr = head
        i = 0
        result = []
        while ptr:
            q = ptr
            i += 1
            ptr = ptr.next
            if i == arrange[j]:
                q.next = None
                result.append(head)
                head = ptr
                i = 0
                j += 1

        while j < k:
            result.append(None)
            j += 1

        return result
"
3110,python3,check-if-one-string-swap-can-make-strings-equal,"class Solution:
    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        if len(s1)!=len(s2):
            return False
        if s1==s2:
            return True
        diff=[]
        for i in range(len(s1)):
            if s1[i]!=s2[i]:
                diff.append([s1[i],s2[i]])
        if len(diff)==1 and diff[0]==diff[-1][::-1]:
            return True
        else:
            return False",None,"class Solution:
    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        if len(s1) != len(s2):
            return False
        if s1 == s2:
            return True
        diff = []
        for i in range(len(s1)):
            if s1[i] != s2[i]:
                diff.append([s1[i], s2[i]])
        if len(diff) == 2 and diff[0] == diff[1][::-1]:
            return True
        elif len(diff) == 0:
            return True
        else:
            return False
"
3110,python3,check-if-one-string-swap-can-make-strings-equal,"class Solution:
    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        if len(s1)!=len(s2):
            return False
        if s1==s2:
            return True
        diff=[]
        for i in range(len(s1)):
            if s1[i]!=s2[i]:
                diff.append([s1[i],s2[i]])
        if len(diff)==1 and diff[0]==diff[-1][::-1]:
            return True
        else:
            return False",None,"class Solution:
    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        if len(s1) != len(s2):
            return False
        if s1 == s2:
            return True
        diff = []
        for i in range(len(s1)):
            if s1[i] != s2[i]:
                diff.append([s1[i], s2[i]])
        return len(diff) <= 2 and diff == diff[::-1]
"
3110,python3,check-if-one-string-swap-can-make-strings-equal,"class Solution:
    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        if len(s1)!=len(s2):
            return False
        if s1==s2:
            return True
        diff=[]
        for i in range(len(s1)):
            if s1[i]!=s2[i]:
                diff.append([s1[i],s2[i]])
        if len(diff)==1 and diff[0]==diff[-1][::-1]:
            return True
        else:
            return False",None,"class Solution:
    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        if len(s1) != len(s2):
            return False
        if s1 == s2:
            return True
        diff = []
        for i in range(len(s1)):
            if s1[i] != s2[i]:
                diff.append([s1[i], s2[i]])
        return len(diff) == 2 and diff[0] == diff[1][::-1] or len(diff) == 0
"
3111,python3,disconnect-path-in-a-binary-matrix-by-at-most-one-flip,"class Solution:
    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])
        dirs = [(-1, 0), (0, -1)]
        def dfs(i: int, j: int) -> None:
            grid[i][j] = 2
            for di, dj in dirs:
                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)
        
        dfs(m - 1, n - 1)
    
        dq = collections.deque([(0, 0)])
        grid[0][0] = 0
        dirs = [(1, 0), (0, 1)]
        while dq:
            l = len(dq)
            for _ in range(l):
                i, j = dq.popleft()
                if i == m - 1 and j == n - 1: return True
                for di, dj in dirs:
                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: 
                        dq.append((i + di, j + dj))
                        grid[i + di][j + dj] = 0


            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return False

        return False",None,"class Solution:
    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])
        dirs = [(-1, 0), (0, -1)]
        def dfs(i: int, j: int) -> None:
            grid[i][j] = 2
            for di, dj in dirs:
                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)
        
        dfs(m - 1, n - 1)
    
        dq = collections.deque([(0, 0)])
        grid[0][0] = 0
        dirs = [(1, 0), (0, 1)]
        while dq:
            i, j = dq.popleft()
            if i == m - 1 and j == n - 1: return True
            for di, dj in dirs:
                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: 
                    dq.append((i + di, j + dj))
                    grid[i + di][j + dj] = 0

        return False
"
3111,python3,disconnect-path-in-a-binary-matrix-by-at-most-one-flip,"class Solution:
    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])
        dirs = [(-1, 0), (0, -1)]
        def dfs(i: int, j: int) -> None:
            grid[i][j] = 2
            for di, dj in dirs:
                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)
        
        dfs(m - 1, n - 1)
    
        dq = collections.deque([(0, 0)])
        grid[0][0] = 0
        dirs = [(1, 0), (0, 1)]
        while dq:
            l = len(dq)
            for _ in range(l):
                i, j = dq.popleft()
                if i == m - 1 and j == n - 1: return True
                for di, dj in dirs:
                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: 
                        dq.append((i + di, j + dj))
                        grid[i + di][j + dj] = 0


            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return False

        return False",None,"class Solution:
    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])
        dirs = [(-1, 0), (0, -1)]
        def dfs(i: int, j: int) -> None:
            grid[i][j] = 2
            for di, dj in dirs:
                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)
        
        dfs(m - 1, n - 1)
    
        dq = collections.deque([(0, 0)])
        grid[0][0] = 0
        dirs = [(1, 0), (0, 1)]
        while dq:
            l = len(dq)
            for _ in range(l):
                i, j = dq.popleft()
                if i == m - 1 and j == n - 1: return True
                for di, dj in dirs:
                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: 
                        dq.append((i + di, j + dj))
                        grid[i + di][j + dj] = 0


            if len(dq) == 0: return False

        return False
"
3111,python3,disconnect-path-in-a-binary-matrix-by-at-most-one-flip,"class Solution:
    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])
        dirs = [(-1, 0), (0, -1)]
        def dfs(i: int, j: int) -> None:
            grid[i][j] = 2
            for di, dj in dirs:
                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)
        
        dfs(m - 1, n - 1)
    
        dq = collections.deque([(0, 0)])
        grid[0][0] = 0
        dirs = [(1, 0), (0, 1)]
        while dq:
            l = len(dq)
            for _ in range(l):
                i, j = dq.popleft()
                if i == m - 1 and j == n - 1: return True
                for di, dj in dirs:
                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: 
                        dq.append((i + di, j + dj))
                        grid[i + di][j + dj] = 0


            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return False

        return False",None,"class Solution:
    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])
        dirs = [(-1, 0), (0, -1)]
        def dfs(i: int, j: int) -> None:
            grid[i][j] = 2
            for di, dj in dirs:
                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)
        
        dfs(m - 1, n - 1)
    
        dq = collections.deque([(0, 0)])
        grid[0][0] = 0
        dirs = [(1, 0), (0, 1)]
        while dq:
            i, j = dq.popleft()
            if i == m - 1 and j == n - 1: return True
            for di, dj in dirs:
                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: 
                    dq.append((i + di, j + dj))
                    grid[i + di][j + dj] = 0

        return False
"
3112,python3,find-bottom-left-tree-value,"class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        depth = 0
        stack = collections.deque([(root)])
        d = {}
        a = 0
        while stack:
            lvl = []
            for i in range(len(stack)):
                n = stack.popleft()
                lvl.append(n.val)
                if n.left: stack.append(n.left)
                if n.right: stack.append(n.right)
            return lvl[0]",None,"class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        depth = 0
        stack = collections.deque([(root, 0)])
        d = {}
        a = 0
        res = None
        while stack:
            n, l = stack.popleft()
            if l > depth:
                depth = l
                res = n.val
            if n.left: stack.append((n.left, l + 1))
            if n.right: stack.append((n.right, l + 1))
        return res
"
3112,python3,find-bottom-left-tree-value,"class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        depth = 0
        stack = collections.deque([(root)])
        d = {}
        a = 0
        while stack:
            lvl = []
            for i in range(len(stack)):
                n = stack.popleft()
                lvl.append(n.val)
                if n.left: stack.append(n.left)
                if n.right: stack.append(n.right)
            return lvl[0]",None,"class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        depth = 0
        stack = collections.deque([(root, 0)])
        d = {}
        a = 0
        res = -1
        while stack:
            n, cur_depth = stack.popleft()
            if cur_depth > depth:
                depth = cur_depth
                res = n.val
            if n.left: stack.append((n.left, cur_depth + 1))
            if n.right: stack.append((n.right, cur_depth + 1))
        return res
"
3112,python3,find-bottom-left-tree-value,"class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        depth = 0
        stack = collections.deque([(root)])
        d = {}
        a = 0
        while stack:
            lvl = []
            for i in range(len(stack)):
                n = stack.popleft()
                lvl.append(n.val)
                if n.left: stack.append(n.left)
                if n.right: stack.append(n.right)
            return lvl[0]",None,"class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        depth = 0
        stack = collections.deque([(root, 0)])
        d = {}
        a = 0
        max_depth = 0
        result = None
        while stack:
            node, current_depth = stack.popleft()
            if current_depth > max_depth:
                max_depth = current_depth
                result = node.val
            if node.left: stack.append((node.left, current_depth + 1))
            if node.right: stack.append((node.right, current_depth + 1))
        return result
"
3113,python3,increasing-order-search-tree,"class Solution:
    def increasingBST(self, root: TreeNode) -> TreeNode:
        newRoot = TreeNode(0)
        self.temp = newRoot
        def inorder(root):
            if root is None: return None
            inorder(root.left)
            new = TreeNode(root.val)
            self.temp.right = new
            self.temp = self.temp.left
            inorder(root.right)
        inorder(root)
        return newRoot.right",None,"class Solution:
    def increasingBST(self, root: TreeNode) -> TreeNode:
        newRoot = TreeNode(0)
        self.temp = newRoot
        def inorder(root):
            if root is None: return
            inorder(root.left)
            new = TreeNode(root.val)
            self.temp.right = new
            self.temp = self.temp.right
            inorder(root.right)
        inorder(root)
        return newRoot.right
"
3113,python3,increasing-order-search-tree,"class Solution:
    def increasingBST(self, root: TreeNode) -> TreeNode:
        newRoot = TreeNode(0)
        self.temp = newRoot
        def inorder(root):
            if root is None: return None
            inorder(root.left)
            new = TreeNode(root.val)
            self.temp.right = new
            self.temp = self.temp.left
            inorder(root.right)
        inorder(root)
        return newRoot.right",None,"class Solution:
    def increasingBST(self, root: TreeNode) -> TreeNode:
        newRoot = TreeNode(0)
        self.temp = newRoot
        def inorder(root):
            if root is None: return None
            inorder(root.left)
            new = TreeNode(root.val)
            self.temp.right = new
            self.temp = self.temp.right
            inorder(root.right)
        inorder(root)
        return newRoot.right
"
3113,python3,increasing-order-search-tree,"class Solution:
    def increasingBST(self, root: TreeNode) -> TreeNode:
        newRoot = TreeNode(0)
        self.temp = newRoot
        def inorder(root):
            if root is None: return None
            inorder(root.left)
            new = TreeNode(root.val)
            self.temp.right = new
            self.temp = self.temp.left
            inorder(root.right)
        inorder(root)
        return newRoot.right",None,"class Solution:
    def increasingBST(self, root: TreeNode) -> TreeNode:
        newRoot = TreeNode(0)
        self.temp = newRoot
        def inorder(root):
            if root is None: return
            inorder(root.left)
            new = TreeNode(root.val)
            self.temp.right = new
            self.temp = self.temp.right
            inorder(root.right)
        inorder(root)
        return newRoot.right
"
3114,python3,check-if-there-is-a-valid-partition-for-the-array,"class Solution:
    def validPartition(self, nums: List[int]) -> bool:

        checks = (True, False, nums[0] == nums[1])

        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):

            checks  = (checks[1], checks[2],
                      (checks[1] and curr == prev1) or
                      (checks[0] and curr == prev1 == prev2) or
                      (checks[0] and prev1 == prev2+1 == curr+2))   

        return checks[2]",None,"class Solution:
    def validPartition(self, nums: List[int]) -> bool:

        checks = (True, False, nums[0] == nums[1])

        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):

            checks  = (checks[1], checks[2],
                      (checks[1] and curr == prev1) or
                      (checks[0] and curr == prev1 == prev2) or
                      (checks[0] and prev1 == curr - 1 and prev2 == curr - 2))

        return checks[2]
"
3114,python3,check-if-there-is-a-valid-partition-for-the-array,"class Solution:
    def validPartition(self, nums: List[int]) -> bool:

        checks = (True, False, nums[0] == nums[1])

        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):

            checks  = (checks[1], checks[2],
                      (checks[1] and curr == prev1) or
                      (checks[0] and curr == prev1 == prev2) or
                      (checks[0] and prev1 == prev2+1 == curr+2))   

        return checks[2]",None,"class Solution:
    def validPartition(self, nums: List[int]) -> bool:

        checks = (True, False, nums[0] == nums[1])

        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):

            checks  = (checks[1], checks[2],
                      (checks[1] and curr == prev1) or
                      (checks[0] and curr == prev1 == prev2) or
                      (checks[0] and prev1 == curr-1 and prev2 == curr-2))   

        return checks[2]
"
3114,python3,check-if-there-is-a-valid-partition-for-the-array,"class Solution:
    def validPartition(self, nums: List[int]) -> bool:

        checks = (True, False, nums[0] == nums[1])

        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):

            checks  = (checks[1], checks[2],
                      (checks[1] and curr == prev1) or
                      (checks[0] and curr == prev1 == prev2) or
                      (checks[0] and prev1 == prev2+1 == curr+2))   

        return checks[2]",None,"class Solution:
    def validPartition(self, nums: List[int]) -> bool:

        checks = (True, False, nums[0] == nums[1])

        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):

            checks  = (checks[1], checks[2],
                      (checks[1] and curr == prev1) or
                      (checks[0] and curr == prev1 == prev2) or
                      (checks[0] and prev1 == curr-1 and prev2 == curr-2))   

        return checks[2]
"
3115,python3,lexicographically-smallest-palindrome,"class Solution:
    def makeSmallestPalindrome(self, s: str) -> str:
        before = 0
        after = len(s)-1
        l = [i for i in s]
        while before <= len(s):
            l[before] = min(l[before], l[after])
            l[after] = l[before]
            before+=1
            after-=1
        return """".join(l)",None,"class Solution:
    def makeSmallestPalindrome(self, s: str) -> str:
        before = 0
        after = len(s)-1
        l = list(s)
        while before < after:
            l[before] = min(l[before], l[after])
            l[after] = l[before]
            before+=1
            after-=1
        return """".join(l)
"
3115,python3,lexicographically-smallest-palindrome,"class Solution:
    def makeSmallestPalindrome(self, s: str) -> str:
        before = 0
        after = len(s)-1
        l = [i for i in s]
        while before <= len(s):
            l[before] = min(l[before], l[after])
            l[after] = l[before]
            before+=1
            after-=1
        return """".join(l)",None,"class Solution:
    def makeSmallestPalindrome(self, s: str) -> str:
        before = 0
        after = len(s)-1
        l = list(s)
        while before < after:
            l[before] = min(l[before], l[after])
            l[after] = l[before]
            before += 1
            after -= 1
        return """".join(l)
"
3115,python3,lexicographically-smallest-palindrome,"class Solution:
    def makeSmallestPalindrome(self, s: str) -> str:
        before = 0
        after = len(s)-1
        l = [i for i in s]
        while before <= len(s):
            l[before] = min(l[before], l[after])
            l[after] = l[before]
            before+=1
            after-=1
        return """".join(l)",None,"class Solution:
    def makeSmallestPalindrome(self, s: str) -> str:
        before = 0
        after = len(s) - 1
        l = list(s)
        while before < after:
            l[before] = min(l[before], l[after])
            l[after] = l[before]
            before += 1
            after -= 1
        return """".join(l)
"
3116,python3,can-place-flowers,"class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        flowerbed=[0]+flowerbed+[0]
        for i in range(1,len(flowerbed)-1):
            if flowerbed[i]==0 and flowerbed[i+2]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1
        if n<=0:return True
        return False",None,"class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        flowerbed = [0] + flowerbed + [0]
        for i in range(1, len(flowerbed) - 1):
            if flowerbed[i] == 0 and flowerbed[i-1] == 0 and flowerbed[i+1] == 0:
                flowerbed[i] = 1
                n -= 1
        return n <= 0
"
3116,python3,can-place-flowers,"class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        flowerbed=[0]+flowerbed+[0]
        for i in range(1,len(flowerbed)-1):
            if flowerbed[i]==0 and flowerbed[i+2]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1
        if n<=0:return True
        return False",None,"class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        flowerbed = [0] + flowerbed + [0]
        for i in range(1, len(flowerbed) - 1):
            if flowerbed[i] == 0 and flowerbed[i-1] == 0 and flowerbed[i+1] == 0:
                flowerbed[i] = 1
                n -= 1
        return n <= 0
"
3116,python3,can-place-flowers,"class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        flowerbed=[0]+flowerbed+[0]
        for i in range(1,len(flowerbed)-1):
            if flowerbed[i]==0 and flowerbed[i+2]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1
        if n<=0:return True
        return False",None,"class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        flowerbed = [0] + flowerbed + [0]
        for i in range(1, len(flowerbed) - 1):
            if flowerbed[i] == 0 and flowerbed[i-1] == 0 and flowerbed[i+1] == 0:
                flowerbed[i] = 1
                n -= 1
        return n <= 0
"
3117,python3,remove-duplicates-from-sorted-array-ii,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        ans=2
        for i in range(2,len(nums)):
            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1
        return ans if len(nums) > 2 else len(nums) - 1",None,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        ans = 2
        for i in range(2, len(nums)):
            if nums[i] != nums[ans - 2]:
                nums[ans] = nums[i]
                ans += 1
        return ans
"
3117,python3,remove-duplicates-from-sorted-array-ii,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        ans=2
        for i in range(2,len(nums)):
            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1
        return ans if len(nums) > 2 else len(nums) - 1",None,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        ans = 2
        for i in range(2, len(nums)):
            if nums[i] != nums[ans - 2]:
                nums[ans] = nums[i]
                ans += 1
        return ans
"
3117,python3,remove-duplicates-from-sorted-array-ii,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        ans=2
        for i in range(2,len(nums)):
            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1
        return ans if len(nums) > 2 else len(nums) - 1",None,"class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        ans = 2
        for i in range(2, len(nums)):
            if nums[i] != nums[ans - 2]:
                nums[ans] = nums[i]
                ans += 1
        return ans
"
3118,python3,edit-distance,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        n ,m = len(word1),len(word2)
        @lru_cache(None)
        def rec(i,j):
            if(i==n and j==m): return 0;
            elif(i==n):        return m-j
            elif(j==m):        return n-i
            elif(word1[i]==word2[j]):
                 return rec(i,j+1)
            else:
                res = 1+ rec(i,j+1)
                res = min(res,1+ rec(i+1,j))
                res = min( res, 1+ rec(i+1,j+1))
            return res
        return rec(0,0)",None,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        n ,m = len(word1),len(word2)
        @lru_cache(None)
        def rec(i,j):
            if(i==n and j==m): return 0;
            elif(i==n):        return m-j
            elif(j==m):        return n-i
            elif(word1[i]==word2[j]):
                 return rec(i+1,j+1)
            else:
                res = 1+ rec(i+1,j+1)
                res = min(res,1+ rec(i,j+1))
                res = min( res, 1+ rec(i+1,j))
            return res
        return rec(0,0)
"
3118,python3,edit-distance,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        n ,m = len(word1),len(word2)
        @lru_cache(None)
        def rec(i,j):
            if(i==n and j==m): return 0;
            elif(i==n):        return m-j
            elif(j==m):        return n-i
            elif(word1[i]==word2[j]):
                 return rec(i,j+1)
            else:
                res = 1+ rec(i,j+1)
                res = min(res,1+ rec(i+1,j))
                res = min( res, 1+ rec(i+1,j+1))
            return res
        return rec(0,0)",None,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        n, m = len(word1), len(word2)

        @lru_cache(None)
        def rec(i, j):
            if i == n and j == m:
                return 0
            elif i == n:
                return m - j
            elif j == m:
                return n - i
            elif word1[i] == word2[j]:
                return rec(i, j + 1)
            else:
                res = 1 + rec(i, j + 1)
                res = min(res, 1 + rec(i + 1, j))
                res = min(res, 1 + rec(i + 1, j + 1))
            return res

        return rec(0, 0)
"
3118,python3,edit-distance,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        n ,m = len(word1),len(word2)
        @lru_cache(None)
        def rec(i,j):
            if(i==n and j==m): return 0;
            elif(i==n):        return m-j
            elif(j==m):        return n-i
            elif(word1[i]==word2[j]):
                 return rec(i,j+1)
            else:
                res = 1+ rec(i,j+1)
                res = min(res,1+ rec(i+1,j))
                res = min( res, 1+ rec(i+1,j+1))
            return res
        return rec(0,0)",None,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        n, m = len(word1), len(word2)
        @lru_cache(None)
        def rec(i, j):
            if (i == n and j == m):
                return 0
            elif (i == n):
                return m - j
            elif (j == m):
                return n - i
            elif (word1[i] == word2[j]):
                return rec(i + 1, j + 1)
            else:
                res = 1 + rec(i + 1, j + 1)
                res = min(res, 1 + rec(i, j + 1))
                res = min(res, 1 + rec(i + 1, j))
            return res
        return rec(0, 0)
"
3119,python3,sort-colors,"class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        low=mid=0
        high=len(nums)-1
        while mid<=high:
            if nums[mid]==0:
                nums[low],nums[mid]=nums[mid],nums[low]
                low+=1
                mid+=1
            elif nums[mid]==1:
                mid+=1
            else:
                nums[mid],nums[high]=nums[high],nums[mid]
                mid+=1
                high-=1",None,"class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        low, mid, high = 0, 0, len(nums) - 1
        while mid <= high:
            if nums[mid] == 0:
                nums[low], nums[mid] = nums[mid], nums[low]
                low += 1
                mid += 1
            elif nums[mid] == 1:
                mid += 1
            else:
                nums[mid], nums[high] = nums[high], nums[mid]
                high -= 1
"
3119,python3,sort-colors,"class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        low=mid=0
        high=len(nums)-1
        while mid<=high:
            if nums[mid]==0:
                nums[low],nums[mid]=nums[mid],nums[low]
                low+=1
                mid+=1
            elif nums[mid]==1:
                mid+=1
            else:
                nums[mid],nums[high]=nums[high],nums[mid]
                mid+=1
                high-=1",None,"class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        low = 0
        mid = 0
        high = len(nums) - 1
        while mid <= high:
            if nums[mid] == 0:
                nums[low], nums[mid] = nums[mid], nums[low]
                low += 1
                mid += 1
            elif nums[mid] == 1:
                mid += 1
            else:
                nums[mid], nums[high] = nums[high], nums[mid]
                high -= 1
"
3119,python3,sort-colors,"class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        low=mid=0
        high=len(nums)-1
        while mid<=high:
            if nums[mid]==0:
                nums[low],nums[mid]=nums[mid],nums[low]
                low+=1
                mid+=1
            elif nums[mid]==1:
                mid+=1
            else:
                nums[mid],nums[high]=nums[high],nums[mid]
                mid+=1
                high-=1",None,"class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        low=0
        mid=0
        high=len(nums)-1
        while mid<=high:
            if nums[mid]==0:
                nums[low],nums[mid]=nums[mid],nums[low]
                low+=1
                mid+=1
            elif nums[mid]==1:
                mid+=1
            else:
                nums[mid],nums[high]=nums[high],nums[mid]
                high-=1
"
3120,python3,most-common-word,"import re
from collections import Counter

class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        paragraph = re.subn(""[.,!?;']"", ' ', paragraph.lower())[0].split(' ')
        
        paragraph = list(filter(lambda x: x in banned + [''], paragraph))
        
        return Counter(paragraph).most_common(1)[0][0]",None,"import re
from collections import Counter

class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        paragraph = re.sub(r'[^a-z0-9\s]', '', paragraph.lower()).split()
        valid_words = set(word for word in paragraph if word not in banned)
        return Counter(filter(lambda x: x in valid_words, paragraph)).most_common(1)[0][0]
"
3120,python3,most-common-word,"import re
from collections import Counter

class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        paragraph = re.subn(""[.,!?;']"", ' ', paragraph.lower())[0].split(' ')
        
        paragraph = list(filter(lambda x: x in banned + [''], paragraph))
        
        return Counter(paragraph).most_common(1)[0][0]",None,"import re
from collections import Counter

class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        words = re.findall(r'\w+', paragraph.lower())
        
        valid_words = [word for word in words if word not in banned]
        
        return Counter(valid_words).most_common(1)[0][0]
"
3120,python3,most-common-word,"import re
from collections import Counter

class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        paragraph = re.subn(""[.,!?;']"", ' ', paragraph.lower())[0].split(' ')
        
        paragraph = list(filter(lambda x: x in banned + [''], paragraph))
        
        return Counter(paragraph).most_common(1)[0][0]",None,"import re
from collections import Counter

class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        paragraph = re.sub(r'[^a-z\s]', '', paragraph.lower()).split()
        valid_words = [word for word in paragraph if word not in banned]
        return Counter(valid_words).most_common(1)[0][0]
"
3121,python3,longest-substring-with-at-least-k-repeating-characters,"from collections import defaultdict
class Solution:
    def longestSubstring(self, s: str, k: int) -> int:
        x=self.recursion(s,k)
        if k==0:
            return x
        else:
            
            return 0

    def recursion(self,s,k):
        if len(s)<=1 :
            return len(s)
        flag=True
        for i in range(len(s)):
            if s.count(s[i])<k:
                flag=False
                break
            
        if flag:
            return len(s)
        left=(self.recursion(s[:i],k))
        right=(self.recursion(s[i+1:],k))
        if left>right:
            return (left)
        return (right)",None,"from collections import defaultdict
class Solution:
    def longestSubstring(self, s: str, k: int) -> int:
        return self.recursion(s, k)

    def recursion(self, s, k):
        if len(s) <= 1:
            return len(s)

        freq = defaultdict(int)
        for char in s:
            freq[char] += 1

        char_with_freq_lt_k = set()
        for char, count in freq.items():
            if count < k:
                char_with_freq_lt_k.add(char)

        if not char_with_freq_lt_k:
            return len(s)

        left_len = 0
        right_len = 0
        left_ptr = 0
        right_ptr = 0

        while right_ptr < len(s):
            if s[right_ptr] not in char_with_freq_lt_k:
                right_len += 1
            else:
                while s[left_ptr] in char_with_freq_lt_k:
                    freq[s[left_ptr]] -= 1
                    left_len -= 1
                    left_ptr += 1

            if s[right_ptr] not in char_with_freq_lt_k:
                left_len += 1
            right_ptr += 1

        return max(self.recursion(s[:left_ptr], k), self.recursion(s[right_ptr:], k))
"
3121,python3,longest-substring-with-at-least-k-repeating-characters,"from collections import defaultdict
class Solution:
    def longestSubstring(self, s: str, k: int) -> int:
        x=self.recursion(s,k)
        if k==0:
            return x
        else:
            
            return 0

    def recursion(self,s,k):
        if len(s)<=1 :
            return len(s)
        flag=True
        for i in range(len(s)):
            if s.count(s[i])<k:
                flag=False
                break
            
        if flag:
            return len(s)
        left=(self.recursion(s[:i],k))
        right=(self.recursion(s[i+1:],k))
        if left>right:
            return (left)
        return (right)",None,"from collections import defaultdict
class Solution:
    def longestSubstring(self, s: str, k: int) -> int:
        return self.recursion(s, k, defaultdict(int))

    def recursion(self, s, k, freq):
        if not s:
            return 0

        for c in set(s):
            freq[c] += s.count(c)

        for i, c in enumerate(s):
            if freq[c] < k:
                return max(self.recursion(s[:i], k, freq), self.recursion(s[i+1:], k, freq))

        return len(s)
"
3121,python3,longest-substring-with-at-least-k-repeating-characters,"from collections import defaultdict
class Solution:
    def longestSubstring(self, s: str, k: int) -> int:
        x=self.recursion(s,k)
        if k==0:
            return x
        else:
            
            return 0

    def recursion(self,s,k):
        if len(s)<=1 :
            return len(s)
        flag=True
        for i in range(len(s)):
            if s.count(s[i])<k:
                flag=False
                break
            
        if flag:
            return len(s)
        left=(self.recursion(s[:i],k))
        right=(self.recursion(s[i+1:],k))
        if left>right:
            return (left)
        return (right)",None,"from collections import defaultdict
class Solution:
    def longestSubstring(self, s: str, k: int) -> int:
        def recursion(s, k):
            if len(s) <= 1:
                return len(s)
            count = defaultdict(int)
            for char in s:
                count[char] += 1
            for char in s:
                if count[char] < k:
                    left = recursion(s[:s.index(char)], k)
                    right = recursion(s[s.index(char)+1:], k)
                    return max(left, right)
            return len(s)
        return recursion(s, k)
"
3122,python3,find-the-middle-index-in-array,"class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        def dnc(l, r, lo, hi):
            if l == r - 1:
                return l if lo == hi else -1
            
            mid = (l + r) // 2
            right = sum(nums[mid:r])
            left = sum(nums[l:mid])

            left_ind = dnc(l, mid, lo, hi + left)
            return left_ind if left_ind != -1 else dnc(mid, r, lo + left, hi)
        return dnc(0, len(nums), 0, 0)",None,"class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        def dnc(l, r):
            if l == r:
                return l

            mid = (l + r) // 2
            right = sum(nums[mid:r])
            left = sum(nums[l:mid])

            if left == right:
                return mid

            left_ind = dnc(l, mid)
            if left_ind != -1:
                return left_ind

            return dnc(mid + 1, r)

        return dnc(0, len(nums)) if dnc(0, len(nums)) != -1 else -1
"
3122,python3,find-the-middle-index-in-array,"class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        def dnc(l, r, lo, hi):
            if l == r - 1:
                return l if lo == hi else -1
            
            mid = (l + r) // 2
            right = sum(nums[mid:r])
            left = sum(nums[l:mid])

            left_ind = dnc(l, mid, lo, hi + left)
            return left_ind if left_ind != -1 else dnc(mid, r, lo + left, hi)
        return dnc(0, len(nums), 0, 0)",None,"class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        def dnc(l, r):
            if l == r:
                return l

            mid = (l + r) // 2
            right = sum(nums[mid:r])
            left = sum(nums[l:mid])

            if left == right:
                return mid
            elif left < right:
                return dnc(mid + 1, r)
            else:
                return dnc(l, mid)

        return dnc(0, len(nums)) if dnc(0, len(nums)) != -1 else -1
"
3122,python3,find-the-middle-index-in-array,"class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        def dnc(l, r, lo, hi):
            if l == r - 1:
                return l if lo == hi else -1
            
            mid = (l + r) // 2
            right = sum(nums[mid:r])
            left = sum(nums[l:mid])

            left_ind = dnc(l, mid, lo, hi + left)
            return left_ind if left_ind != -1 else dnc(mid, r, lo + left, hi)
        return dnc(0, len(nums), 0, 0)",None,"class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        def dnc(l, r):
            if l == r - 1:
                return l
            mid = (l + r) // 2
            right = sum(nums[mid:r])
            left = sum(nums[l:mid])
            if left == right:
                return mid
            elif left < right:
                return dnc(mid, r)
            else:
                return dnc(l, mid)
        return dnc(0, len(nums)) if dnc(0, len(nums)) != -1 else -1
"
3123,python3,maximum-depth-of-n-ary-tree,"""""""
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children

class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if root == None:
            return 0
        else:
            depth = 0
            nodes_queue = [root]
            next_nodes_queue = []
            while(nodes_queue):
                node_out = nodes_queue.pop(0)
                for child in node_out.children:
                    nodes_queue.append(child)
                if nodes_queue == []:
                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue
                    depth += 1
            return depth
""""""",None,"""""""
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children

class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if root == None:
            return 0
        else:
            depth = 0
            nodes_queue = [root]
            while nodes_queue:
                next_nodes_queue = []
                for node_out in nodes_queue:
                    for child in node_out.children:
                        next_nodes_queue.append(child)
                nodes_queue = next_nodes_queue
                depth += 1
            return depth
""""""
"
3123,python3,maximum-depth-of-n-ary-tree,"""""""
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children

class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if root == None:
            return 0
        else:
            depth = 0
            nodes_queue = [root]
            next_nodes_queue = []
            while(nodes_queue):
                node_out = nodes_queue.pop(0)
                for child in node_out.children:
                    nodes_queue.append(child)
                if nodes_queue == []:
                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue
                    depth += 1
            return depth
""""""",None,"class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children

class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if root == None:
            return 0
        else:
            depth = 0
            nodes_queue = [root]
            while nodes_queue:
                next_nodes_queue = []
                for node_out in nodes_queue:
                    for child in node_out.children:
                        next_nodes_queue.append(child)
                nodes_queue = next_nodes_queue
                depth += 1
            return depth
"
3123,python3,maximum-depth-of-n-ary-tree,"""""""
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children

class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if root == None:
            return 0
        else:
            depth = 0
            nodes_queue = [root]
            next_nodes_queue = []
            while(nodes_queue):
                node_out = nodes_queue.pop(0)
                for child in node_out.children:
                    nodes_queue.append(child)
                if nodes_queue == []:
                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue
                    depth += 1
            return depth
""""""",None,"""""""
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children

class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if root == None:
            return 0
        else:
            depth = 0
            nodes_queue = [root]
            while nodes_queue:
                depth += 1
                next_nodes_queue = []
                for node_out in nodes_queue:
                    for child in node_out.children:
                        next_nodes_queue.append(child)
                nodes_queue = next_nodes_queue
            return depth
""""""
"
3124,python3,minimum-cost-to-cut-a-stick,"class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        
        cuts = sorted(chain(cuts,[0,n]))
        
        @lru_cache(None)
        def dfs(l, r):
            length, M = cuts[r] - cuts[l], range(l+1, r)
            return min((dfs(l,i) + dfs(i,r) for i in M),
                       default = length) + length
        
        return dfs(0, len(cuts)-1)",None,"class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        
        cuts = sorted(chain([0], cuts, [n]))
        
        @lru_cache(None)
        def dfs(l, r):
            length, M = cuts[r] - cuts[l], range(l+1, r)
            return min((dfs(l,i) + dfs(i,r) for i in M),
                       default = length) + length if M else length
        
        return dfs(0, len(cuts)-1)
"
3124,python3,minimum-cost-to-cut-a-stick,"class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        
        cuts = sorted(chain(cuts,[0,n]))
        
        @lru_cache(None)
        def dfs(l, r):
            length, M = cuts[r] - cuts[l], range(l+1, r)
            return min((dfs(l,i) + dfs(i,r) for i in M),
                       default = length) + length
        
        return dfs(0, len(cuts)-1)",None,"class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        
        cuts = sorted(chain([0], cuts, [n]))
        
        @lru_cache(None)
        def dfs(l, r):
            if r - l <= 1:
                return 0
            length, M = cuts[r] - cuts[l], range(l+1, r)
            return min((dfs(l,i) + dfs(i,r) for i in M),
                       default = length) + length
        
        return dfs(0, len(cuts)-1)
"
3124,python3,minimum-cost-to-cut-a-stick,"class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        
        cuts = sorted(chain(cuts,[0,n]))
        
        @lru_cache(None)
        def dfs(l, r):
            length, M = cuts[r] - cuts[l], range(l+1, r)
            return min((dfs(l,i) + dfs(i,r) for i in M),
                       default = length) + length
        
        return dfs(0, len(cuts)-1)",None,"class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        
        cuts = sorted(chain([0], cuts, [n]))
        
        @lru_cache(None)
        def dfs(l, r):
            length, M = cuts[r] - cuts[l], range(l+1, r)
            return min((dfs(l,i) + dfs(i,r) for i in M),
                       default = length) + length
        
        return dfs(0, len(cuts)-1)
"
3125,python3,calculate-money-in-leetcode-bank,"class Solution:
    def totalMoney(self, n: int) -> int:
        income=1;a=[1];ans=0
        for i in range(n):
            if i%7==0 and i!=0:income=(a[len(a)-8])
            ans+=income;income+=1;a.append(income)      
        return ans",None,"class Solution:
    def totalMoney(self, n: int) -> int:
        income = 1
        ans = 0
        a = [1]
        for i in range(n):
            if i % 7 == 0 and i != 0:
                income = a[i - 7]
            ans += income
            income += 1
            a.append(income)
        return ans
"
3125,python3,calculate-money-in-leetcode-bank,"class Solution:
    def totalMoney(self, n: int) -> int:
        income=1;a=[1];ans=0
        for i in range(n):
            if i%7==0 and i!=0:income=(a[len(a)-8])
            ans+=income;income+=1;a.append(income)      
        return ans",None,"class Solution:
    def totalMoney(self, n: int) -> int:
        income = 1
        total = 0
        for i in range(n):
            total += income
            income += 1
            if (i+1) % 7 == 0:
                income = total + 1
        return total
"
3125,python3,calculate-money-in-leetcode-bank,"class Solution:
    def totalMoney(self, n: int) -> int:
        income=1;a=[1];ans=0
        for i in range(n):
            if i%7==0 and i!=0:income=(a[len(a)-8])
            ans+=income;income+=1;a.append(income)      
        return ans",None,"class Solution:
    def totalMoney(self, n: int) -> int:
        income = 1
        total = 0
        for i in range(n):
            total += income
            income += 1
            if (i+1) % 7 == 0:
                income = total % 7 + 1
        return total
"
3126,python3,longest-subsequence-with-limited-sum,"class Solution:
  def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:
    nums, sums, res, n = sorted(nums), [0], [], len(queries)+1
    for num in nums:
      sums.append(sums[-1] + num)
    
    def bSearch(q, l=0, mid=n>>1, r=n):
      while l < mid < r:
        if sums[mid] > q:
          r = mid
        elif sums[mid] < q:
          l = mid
        else: break
        mid = (l+r)>>1
      return mid

    return [bSearch(q) for q in queries]",None,"class Solution:
    def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:
        nums, sums, res = sorted(nums), [0], []
        for num in nums:
            sums.append(sums[-1] + num)

        def bSearch(q):
            l, r = 0, len(sums) - 1
            while l < r:
                mid = (l + r) // 2
                if sums[mid] <= q:
                    l = mid + 1
                else:
                    r = mid
            return l

        return [bSearch(q) for q in queries]
"
3126,python3,longest-subsequence-with-limited-sum,"class Solution:
  def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:
    nums, sums, res, n = sorted(nums), [0], [], len(queries)+1
    for num in nums:
      sums.append(sums[-1] + num)
    
    def bSearch(q, l=0, mid=n>>1, r=n):
      while l < mid < r:
        if sums[mid] > q:
          r = mid
        elif sums[mid] < q:
          l = mid
        else: break
        mid = (l+r)>>1
      return mid

    return [bSearch(q) for q in queries]",None,"class Solution:
  def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:
    nums, sums, res = sorted(nums), [0], []
    for num in nums:
      sums.append(sums[-1] + num)
    
    def bSearch(q):
      l, r = 0, len(sums)
      while l < r:
        mid = (l+r)>>1
        if sums[mid] > q:
          r = mid
        else:
          l = mid + 1
      return l

    for q in queries:
      res.append(bSearch(q) - 1)

    return res
"
3126,python3,longest-subsequence-with-limited-sum,"class Solution:
  def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:
    nums, sums, res, n = sorted(nums), [0], [], len(queries)+1
    for num in nums:
      sums.append(sums[-1] + num)
    
    def bSearch(q, l=0, mid=n>>1, r=n):
      while l < mid < r:
        if sums[mid] > q:
          r = mid
        elif sums[mid] < q:
          l = mid
        else: break
        mid = (l+r)>>1
      return mid

    return [bSearch(q) for q in queries]",None,"class Solution:
  def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:
    nums, sums, res = sorted(nums), [0], []
    for num in nums:
      sums.append(sums[-1] + num)

    def bSearch(q):
      l, r = 0, len(sums)
      while l < r:
        mid = (l+r)//2
        if sums[mid] > q:
          r = mid
        else:
          l = mid + 1
      return l

    for q in queries:
      res.append(bSearch(q) - 1)

    return res
"
3127,python3,maximum-number-of-moves-in-a-grid,"class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        m,n = len(grid), len(grid)
        dq = deque(range(m))
        moves = 0
        while dq and moves < n-1:
            nxt = set()
            for _ in range(len(dq)):
                idx = dq.popleft()
                val = grid[idx][moves]
                for i in range(max(0, idx-1), min(m, idx+2)):
                    if grid[i][moves+1] > val:
                        nxt.add(i)
            if len(nxt) > 0:
                moves += 1
            dq.extend(nxt)
        return moves",None,"class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dq = deque(range(m))
        moves = 0
        while dq and moves < n - 1:
            nxt = set()
            for _ in range(len(dq)):
                idx = dq.popleft()
                val = grid[idx][moves]
                for i in [idx - 1, idx, idx + 1]:
                    if 0 <= i < m and grid[i][moves + 1] > val:
                        nxt.add(i)
            if nxt:
                moves += 1
            dq.extend(nxt)
        return moves
"
3127,python3,maximum-number-of-moves-in-a-grid,"class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        m,n = len(grid), len(grid)
        dq = deque(range(m))
        moves = 0
        while dq and moves < n-1:
            nxt = set()
            for _ in range(len(dq)):
                idx = dq.popleft()
                val = grid[idx][moves]
                for i in range(max(0, idx-1), min(m, idx+2)):
                    if grid[i][moves+1] > val:
                        nxt.add(i)
            if len(nxt) > 0:
                moves += 1
            dq.extend(nxt)
        return moves",None,"class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dq = deque(range(m))
        moves = 0
        while dq and moves < n - 1:
            nxt = set()
            for _ in range(len(dq)):
                idx = dq.popleft()
                val = grid[idx][moves]
                for i in (idx - 1, idx, idx + 1):
                    if 0 <= i < m and grid[i][moves + 1] > val:
                        nxt.add(i)
            if nxt:
                moves += 1
            dq.extend(nxt)
        return moves
"
3127,python3,maximum-number-of-moves-in-a-grid,"class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        m,n = len(grid), len(grid)
        dq = deque(range(m))
        moves = 0
        while dq and moves < n-1:
            nxt = set()
            for _ in range(len(dq)):
                idx = dq.popleft()
                val = grid[idx][moves]
                for i in range(max(0, idx-1), min(m, idx+2)):
                    if grid[i][moves+1] > val:
                        nxt.add(i)
            if len(nxt) > 0:
                moves += 1
            dq.extend(nxt)
        return moves",None,"class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dq = deque(range(m))
        moves = 0
        while dq and moves < n - 1:
            nxt = set()
            for _ in range(len(dq)):
                idx = dq.popleft()
                val = grid[idx][moves]
                for i, j in ((idx - 1, moves + 1), (idx, moves + 1), (idx + 1, moves + 1)):
                    if 0 <= i < m and grid[i][j] > val:
                        nxt.add(i)
            if nxt:
                moves += 1
            dq.extend(nxt)
        return moves
"
3128,python3,course-schedule,"class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:

        pre = defaultdict(list)

        for course, p in prerequisites:
            pre[course].append(p)
        
        taken = set()

        def dfs(course):
            if not pre[course]:
                return True
            
            if course in taken:
                return False
            
            taken.add(course)

            for p in pre[course]:
                if not dfs(p): return False
            
            taken.remove(course)
            return True
        
        for course in range(numCourses):
            if not dfs(course):
                return False

        return True",None,"class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:

        pre = defaultdict(list)

        for course, p in prerequisites:
            pre[course].append(p)
        
        taken = set()

        def dfs(course):
            if not pre[course]:
                return True
            
            if course in taken:
                return False
            
            taken.add(course)

            for p in pre[course]:
                if not dfs(p): return False
            
            taken.remove(course)
            return True
        
        for course in range(numCourses):
            if not dfs(course):
                return False

        return True
"
3128,python3,course-schedule,"class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:

        pre = defaultdict(list)

        for course, p in prerequisites:
            pre[course].append(p)
        
        taken = set()

        def dfs(course):
            if not pre[course]:
                return True
            
            if course in taken:
                return False
            
            taken.add(course)

            for p in pre[course]:
                if not dfs(p): return False
            
            taken.remove(course)
            return True
        
        for course in range(numCourses):
            if not dfs(course):
                return False

        return True",None,"class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:

        pre = defaultdict(list)

        for course, p in prerequisites:
            pre[course].append(p)
        
        taken = set()

        def dfs(course):
            if not pre[course]:
                return True
            
            if course in taken:
                return False
            
            taken.add(course)

            for p in pre[course]:
                if not dfs(p): return False
            
            taken.remove(course)
            return True
        
        for course in range(numCourses):
            if not dfs(course):
                return False

        return True
"
3128,python3,course-schedule,"class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:

        pre = defaultdict(list)

        for course, p in prerequisites:
            pre[course].append(p)
        
        taken = set()

        def dfs(course):
            if not pre[course]:
                return True
            
            if course in taken:
                return False
            
            taken.add(course)

            for p in pre[course]:
                if not dfs(p): return False
            
            taken.remove(course)
            return True
        
        for course in range(numCourses):
            if not dfs(course):
                return False

        return True",None,"from collections import defaultdict

class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:

        pre = defaultdict(list)

        for course, p in prerequisites:
            pre[course].append(p)

        taken = set()

        def dfs(course):
            if not pre[course]:
                return True

            if course in taken:
                return False

            taken.add(course)

            for p in pre[course]:
                if not dfs(p): return False

            taken.remove(course)
            return True

        for course in range(numCourses):
            if not dfs(course):
                return False

        return True
"
3129,python3,satisfiability-of-equality-equations,"class Disjoint:
    def __init__(self):
        self.rank=[0]*26
        self.parent=[i for i in range(26)]

    def finduPar(self,node):
        if self.parent[node]==node:
            return node
        self.parent[node]=self.finduPar(self.parent[node])
        return self.parent[node]

    def byrank(self,u,v):
        ulp_u=self.finduPar(node)
        ulp_v=self.finduPar(node)
        if ulp_u==ulp_v:
            return False
        if self.rank[ulp_u]>self.rank[ulp_v]:
            self.parent[ulp_v]=ulp_u
        elif self.rank[ulp_u]<self.rank[ulp_v]:
            self.parent[ulp_u]=ulp_v
        else:
            self.parent[ulp_v]=ulp_u
            self.rank[ulp_u]+=1


class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        disjoint=Disjoint()
        nq=[]
        n=len(equations)
        for i in range(n):
            if equations[i][1]=='!':
                if equations[i][0]==equations[i][-1]:
                    return False
                else:
                    nq.append(equations[i])
            else:
                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)
        for i in range(len(nq)):
            x=ord(nq[i][0])-97
            y=ord(nq[i][-1])-97
            if disjoint.finduPar(x)==disjoint.finduPar(y):
                return False
        return True",None,"class Disjoint:
    def __init__(self):
        self.rank=[0]*26
        self.parent=[i for i in range(26)]

    def finduPar(self,node):
        if self.parent[node]==node:
            return node
        self.parent[node]=self.finduPar(self.parent[node])
        return self.parent[node]

    def union(self,u,v):
        ulp_u=self.finduPar(u)
        ulp_v=self.finduPar(v)
        if ulp_u==ulp_v:
            return False
        if self.rank[ulp_u]>self.rank[ulp_v]:
            self.parent[ulp_v]=ulp_u
        else:
            self.parent[ulp_u]=ulp_v
            self.rank[ulp_v]+=1
        return True


class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        disjoint=Disjoint()
        for i in range(len(equations)):
            if equations[i][1]=='=':
                disjoint.union(ord(equations[i][0])-97, ord(equations[i][-1])-97)
            elif equations[i][1]=='!':
                if disjoint.finduPar(ord(equations[i][0])-97)==disjoint.finduPar(ord(equations[i][-1])-97):
                    return False
        return True
"
3129,python3,satisfiability-of-equality-equations,"class Disjoint:
    def __init__(self):
        self.rank=[0]*26
        self.parent=[i for i in range(26)]

    def finduPar(self,node):
        if self.parent[node]==node:
            return node
        self.parent[node]=self.finduPar(self.parent[node])
        return self.parent[node]

    def byrank(self,u,v):
        ulp_u=self.finduPar(node)
        ulp_v=self.finduPar(node)
        if ulp_u==ulp_v:
            return False
        if self.rank[ulp_u]>self.rank[ulp_v]:
            self.parent[ulp_v]=ulp_u
        elif self.rank[ulp_u]<self.rank[ulp_v]:
            self.parent[ulp_u]=ulp_v
        else:
            self.parent[ulp_v]=ulp_u
            self.rank[ulp_u]+=1


class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        disjoint=Disjoint()
        nq=[]
        n=len(equations)
        for i in range(n):
            if equations[i][1]=='!':
                if equations[i][0]==equations[i][-1]:
                    return False
                else:
                    nq.append(equations[i])
            else:
                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)
        for i in range(len(nq)):
            x=ord(nq[i][0])-97
            y=ord(nq[i][-1])-97
            if disjoint.finduPar(x)==disjoint.finduPar(y):
                return False
        return True",None,"class Disjoint:
    def __init__(self):
        self.rank=[0]*26
        self.parent=[i for i in range(26)]

    def finduPar(self,node):
        if self.parent[node]==node:
            return node
        self.parent[node]=self.finduPar(self.parent[node])
        return self.parent[node]

    def byrank(self,u,v):
        ulp_u=self.finduPar(u)
        ulp_v=self.finduPar(v)
        if ulp_u==ulp_v:
            return False
        if self.rank[ulp_u]>self.rank[ulp_v]:
            self.parent[ulp_v]=ulp_u
        elif self.rank[ulp_u]<self.rank[ulp_v]:
            self.parent[ulp_u]=ulp_v
        else:
            self.parent[ulp_v]=ulp_u
            self.rank[ulp_u]+=1


class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        disjoint=Disjoint()
        nq=[]
        for i in range(len(equations)):
            if equations[i][1]=='!':
                nq.append(equations[i])
            else:
                x=ord(equations[i][0])-97
                y=ord(equations[i][-1])-97
                disjoint.byrank(x,y)
        for i in range(len(nq)):
            x=ord(nq[i][0])-97
            y=ord(nq[i][-1])-97
            if disjoint.finduPar(x)==disjoint.finduPar(y):
                return False
        return True
"
3129,python3,satisfiability-of-equality-equations,"class Disjoint:
    def __init__(self):
        self.rank=[0]*26
        self.parent=[i for i in range(26)]

    def finduPar(self,node):
        if self.parent[node]==node:
            return node
        self.parent[node]=self.finduPar(self.parent[node])
        return self.parent[node]

    def byrank(self,u,v):
        ulp_u=self.finduPar(node)
        ulp_v=self.finduPar(node)
        if ulp_u==ulp_v:
            return False
        if self.rank[ulp_u]>self.rank[ulp_v]:
            self.parent[ulp_v]=ulp_u
        elif self.rank[ulp_u]<self.rank[ulp_v]:
            self.parent[ulp_u]=ulp_v
        else:
            self.parent[ulp_v]=ulp_u
            self.rank[ulp_u]+=1


class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        disjoint=Disjoint()
        nq=[]
        n=len(equations)
        for i in range(n):
            if equations[i][1]=='!':
                if equations[i][0]==equations[i][-1]:
                    return False
                else:
                    nq.append(equations[i])
            else:
                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)
        for i in range(len(nq)):
            x=ord(nq[i][0])-97
            y=ord(nq[i][-1])-97
            if disjoint.finduPar(x)==disjoint.finduPar(y):
                return False
        return True",None,"class Disjoint:
    def __init__(self):
        self.rank = [0] * 26
        self.parent = [i for i in range(26)]

    def find_u_par(self, node):
        if self.parent[node] == node:
            return node
        self.parent[node] = self.find_u_par(self.parent[node])
        return self.parent[node]

    def by_rank(self, u, v):
        ulp_u = self.find_u_par(u)
        ulp_v = self.find_u_par(v)
        if ulp_u == ulp_v:
            return False
        if self.rank[ulp_u] > self.rank[ulp_v]:
            self.parent[ulp_v] = ulp_u
        elif self.rank[ulp_u] < self.rank[ulp_v]:
            self.parent[ulp_u] = ulp_v
        else:
            self.parent[ulp_v] = ulp_u
            self.rank[ulp_u] += 1


class Solution:
    def equations_possible(self, equations: List[str]) -> bool:
        disjoint = Disjoint()
        nq = []
        for i in range(len(equations)):
            if equations[i][1] == '!':
                if equations[i][0] == equations[i][-1]:
                    return False
                else:
                    nq.append(equations[i])
            else:
                x = ord(equations[i][0]) - 97
                y = ord(equations[i][-1]) - 97
                disjoint.by_rank(x, y)

        for i in range(len(nq)):
            x = ord(nq[i][0]) - 97
            y = ord(nq[i][-1]) - 97
            if disjoint.find_u_par(x) == disjoint.find_u_par(y):
                return False
        return True
"
3130,python3,convert-sorted-list-to-binary-search-tree,"class Solution:
    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:
        nums=[]
        curr=head
        while curr:
            nums.append(curr.val)
            curr=curr.next
        def helper(l,r):
            if l>r:
                return None
            mid=(l+r)//2
            root=TreeNode(nums[mid])
            root.left=helper(l,mid)
            root.right=helper(mid+1,r)
            return root
        return helper(0,len(nums)-1)",None,"class Solution:
    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:
        nums=[]
        curr=head
        while curr:
            nums.append(curr.val)
            curr=curr.next
        def helper(l,r):
            if l>r:
                return None
            mid=(l+r)//2
            root=TreeNode(nums[mid])
            root.left=helper(l,mid-1)
            root.right=helper(mid+1,r)
            return root
        return helper(0,len(nums)-1)
"
3130,python3,convert-sorted-list-to-binary-search-tree,"class Solution:
    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:
        nums=[]
        curr=head
        while curr:
            nums.append(curr.val)
            curr=curr.next
        def helper(l,r):
            if l>r:
                return None
            mid=(l+r)//2
            root=TreeNode(nums[mid])
            root.left=helper(l,mid)
            root.right=helper(mid+1,r)
            return root
        return helper(0,len(nums)-1)",None,"class Solution:
    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:
        nums=[]
        curr=head
        while curr:
            nums.append(curr.val)
            curr=curr.next
        def helper(l,r):
            if l>r:
                return None
            mid=(l+r)//2
            root=TreeNode(nums[mid])
            root.left=helper(l,mid-1)
            root.right=helper(mid+1,r)
            return root
        return helper(0,len(nums)-1)
"
3130,python3,convert-sorted-list-to-binary-search-tree,"class Solution:
    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:
        nums=[]
        curr=head
        while curr:
            nums.append(curr.val)
            curr=curr.next
        def helper(l,r):
            if l>r:
                return None
            mid=(l+r)//2
            root=TreeNode(nums[mid])
            root.left=helper(l,mid)
            root.right=helper(mid+1,r)
            return root
        return helper(0,len(nums)-1)",None,"class Solution:
    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:
        nums=[]
        curr=head
        while curr:
            nums.append(curr.val)
            curr=curr.next
        def helper(l,r):
            if l>r:
                return None
            mid=(l+r)//2
            root=TreeNode(nums[mid])
            root.left=helper(l,mid-1)
            root.right=helper(mid+1,r)
            return root
        return helper(0,len(nums)-1)
"
3131,python3,minimum-cost-to-make-at-least-one-valid-path-in-a-grid,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        distance = [[m * n + 1 for _ in range(n)] for _ in range(m)]
        distance[m - 1][n - 1] = 0 
        q = collections.deque([(0, 0, 0)])
        while q:
            c, i, j = q.popleft()
            if c > distance[i][j]: continue
            if i == m - 1 and j == n - 1: return c
            for di, dj, d in [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    if c + int(d != grid[i][j]) < distance[ci][cj]:
                        distance[ci][cj] = c + int(d != grid[i][j])
                        if d == grid[i][j]: q.appendleft((distance[ci][cj], ci, cj))
                        else: q.append((distance[ci][cj], ci, cj))
        
        return distance[m - 1][n - 1]",None,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        distance = [[m * n + 1 for _ in range(n)] for _ in range(m)]
        distance[m - 1][n - 1] = 0 
        q = collections.deque([(0, 0, 0)])
        while q:
            c, i, j = q.popleft()
            if c > distance[i][j]: continue
            if i == m - 1 and j == n - 1: return c
            for di, dj, d in [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    if c + int(d != grid[ci][cj]) < distance[ci][cj]:
                        distance[ci][cj] = c + int(d != grid[ci][cj])
                        q.append((distance[ci][cj], ci, cj))
        
        return distance[m - 1][n - 1]
"
3131,python3,minimum-cost-to-make-at-least-one-valid-path-in-a-grid,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        distance = [[m * n + 1 for _ in range(n)] for _ in range(m)]
        distance[m - 1][n - 1] = 0 
        q = collections.deque([(0, 0, 0)])
        while q:
            c, i, j = q.popleft()
            if c > distance[i][j]: continue
            if i == m - 1 and j == n - 1: return c
            for di, dj, d in [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    if c + int(d != grid[i][j]) < distance[ci][cj]:
                        distance[ci][cj] = c + int(d != grid[i][j])
                        if d == grid[i][j]: q.appendleft((distance[ci][cj], ci, cj))
                        else: q.append((distance[ci][cj], ci, cj))
        
        return distance[m - 1][n - 1]",None,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        distance = [[m * n + 1 for _ in range(n)] for _ in range(m)]
        distance[m - 1][n - 1] = 0 
        q = collections.deque([(0, 0, 0)])
        while q:
            c, i, j = q.popleft()
            if c > distance[i][j]: continue
            if i == m - 1 and j == n - 1: return c
            for di, dj, d in [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    if c + int(d != grid[ci][cj]) < distance[ci][cj]:
                        distance[ci][cj] = c + int(d != grid[ci][cj])
                        q.append((distance[ci][cj], ci, cj))
        
        return distance[m - 1][n - 1]
"
3131,python3,minimum-cost-to-make-at-least-one-valid-path-in-a-grid,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        distance = [[m * n + 1 for _ in range(n)] for _ in range(m)]
        distance[m - 1][n - 1] = 0 
        q = collections.deque([(0, 0, 0)])
        while q:
            c, i, j = q.popleft()
            if c > distance[i][j]: continue
            if i == m - 1 and j == n - 1: return c
            for di, dj, d in [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    if c + int(d != grid[i][j]) < distance[ci][cj]:
                        distance[ci][cj] = c + int(d != grid[i][j])
                        if d == grid[i][j]: q.appendleft((distance[ci][cj], ci, cj))
                        else: q.append((distance[ci][cj], ci, cj))
        
        return distance[m - 1][n - 1]",None,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        distance = [[m * n + 1 for _ in range(n)] for _ in range(m)]
        distance[m - 1][n - 1] = 0 
        q = collections.deque([(0, 0)])
        while q:
            i, j = q.popleft()
            c = distance[i][j]
            if c > distance[i][j]: continue
            if i == m - 1 and j == n - 1: return c
            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    new_cost = c + int(grid[i][j] != grid[ci][cj])
                    if new_cost < distance[ci][cj]:
                        distance[ci][cj] = new_cost
                        q.append((ci, cj))
        
        return distance[m - 1][n - 1]
"
3132,python3,count-equal-and-divisible-pairs-in-an-array,"class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        d={}
        for i,v in enumerate(nums):
            if v in d:
                d[v].append(i)
            else:
                d|={v:[i]}
        s=0
        def make(a,n):
            c=0
            for i in range(n-1):
                for j in range(i+1,n):
                    if a[i]*a[j]%k==0:
                        c+=1
            return c
        for i in d:
            if len(d[i])==1:
                continue
            s+=make(nums,d[i])
        return s",None,"class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        d={}
        for i,v in enumerate(nums):
            if v in d:
                d[v].append(i)
            else:
                d[v]=[i]
        s=0
        def make(a,n):
            c=0
            for i in range(n-1):
                for j in range(i+1,n):
                    if (a[i]*a[j])%k==0:
                        c+=1
            return c
        for v in d:
            if len(d[v])<2:
                continue
            s+=make(d[v],len(d[v]))
        return s
"
3132,python3,count-equal-and-divisible-pairs-in-an-array,"class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        d={}
        for i,v in enumerate(nums):
            if v in d:
                d[v].append(i)
            else:
                d|={v:[i]}
        s=0
        def make(a,n):
            c=0
            for i in range(n-1):
                for j in range(i+1,n):
                    if a[i]*a[j]%k==0:
                        c+=1
            return c
        for i in d:
            if len(d[i])==1:
                continue
            s+=make(nums,d[i])
        return s",None,"class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        d={}
        for i,v in enumerate(nums):
            if v in d:
                d[v].append(i)
            else:
                d[v]=[i]
        s=0
        for i in d:
            if len(d[i])<2:
                continue
            for j in range(len(d[i])):
                for l in range(j+1, len(d[i])):
                    if (d[i][j]*d[i][l])%k==0:
                        s+=1
        return s
"
3132,python3,count-equal-and-divisible-pairs-in-an-array,"class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        d={}
        for i,v in enumerate(nums):
            if v in d:
                d[v].append(i)
            else:
                d|={v:[i]}
        s=0
        def make(a,n):
            c=0
            for i in range(n-1):
                for j in range(i+1,n):
                    if a[i]*a[j]%k==0:
                        c+=1
            return c
        for i in d:
            if len(d[i])==1:
                continue
            s+=make(nums,d[i])
        return s",None,"class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        d={}
        for i,v in enumerate(nums):
            if v in d:
                d[v].append(i)
            else:
                d[v] = [i]
        s=0
        for i in d:
            if len(d[i])<2:
                continue
            s += sum( (b-a)%k == 0 for a,b in combinations(d[i], 2) )
        return s
"
3133,python3,substrings-of-size-three-with-distinct-characters,"class Solution:
    def countGoodSubstrings(self, s: str) -> int:
        count = 0
        for i in range(len(s) - 2):
            x = s[i: i + 2]
            if x.count(x[0]) == 1 and x.count(x[1]) == 1 and x.count(x[2]) == 1:
                count += 1
        return count",None,"class Solution:
    def countGoodSubstrings(self, s: str) -> int:
        count = 0
        for i in range(len(s) - 2):
            x = s[i: i + 3]
            if len(set(x)) == 3:
                count += 1
        return count
"
3133,python3,substrings-of-size-three-with-distinct-characters,"class Solution:
    def countGoodSubstrings(self, s: str) -> int:
        count = 0
        for i in range(len(s) - 2):
            x = s[i: i + 2]
            if x.count(x[0]) == 1 and x.count(x[1]) == 1 and x.count(x[2]) == 1:
                count += 1
        return count",None,"class Solution:
    def countGoodSubstrings(self, s: str) -> int:
        count = 0
        for i in range(len(s) - 2):
            x = s[i: i + 3]
            if len(set(x)) == 3:
                count += 1
        return count
"
3133,python3,substrings-of-size-three-with-distinct-characters,"class Solution:
    def countGoodSubstrings(self, s: str) -> int:
        count = 0
        for i in range(len(s) - 2):
            x = s[i: i + 2]
            if x.count(x[0]) == 1 and x.count(x[1]) == 1 and x.count(x[2]) == 1:
                count += 1
        return count",None,"class Solution:
    def countGoodSubstrings(self, s: str) -> int:
        count = 0
        for i in range(len(s) - 2):
            x = s[i: i + 3]
            if len(set(x)) == 3:
                count += 1
        return count
"
3134,python3,count-subtrees-with-max-distance-between-cities,"class Solution:
    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:
        adj = [[] for i in range(n)]
        for u,v in edges:
            adj[u-1].append(v-1)
            adj[v-1].append(u-1)
        def comb(p,q):
            if len(q)<len(p): p,q = q,p
            res = [0]*len(q)
            res[0] = p[0]*q[0]
            for i in range(1,len(p)): p[i] += p[i-1]
            for i in range(1,len(q)): q[i] += q[i-1]
            for i in range(1,len(p)):
                res[i] = p[i]*q[i]-p[i-1]*q[i-1]
            for i in range(len(p),len(q)):
                res[i] = (q[i]-q[i-1])*p[-1]
            return res
            
        def dfs(r,p):
            d = [1]
            for v in adj[r]:
                if v==p: continue
                t = [0]+dfs(v,r) 
                d = comb(t,d)
            return d
        ans = [0]*n
        for u,v in edges:
            u -= 1; v-=1
            p = dfs(u,v)
            q = dfs(v,u)
            for i in range(min(len(p),len(q))):
                ans[i+i+1] += p[i]*q[i]
        for v in range(n): 
            if len(adj[v])==1: continue 
            tree = [1]+dfs(adj[v][0],v)
            curr = [0]*n
            for u in adj[v][1:]:
                q = [1]+dfs(u,v)
                j = 1; t = q[1]+1
                for i in range(4,n,2):
                    while j+1<min(i//2,len(q)):
                        j += 1; t += q[j]
                    curr[i] *= t
                for i in range(min(len(tree),len(q))):
                    curr[i+i] += tree[i]*q[i]
                tree = comb(tree,q)
            for i in range(2,n,2):
                ans[i] += curr[i]
        return ans[1:]",None,"from typing import List

class Solution:
    def count_subgraphs_for_each_diameter(self, n: int, edges: List[List[int]]) -> List[int]:
        # Create an adjacency list to represent the graph
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u - 1].append(v - 1)
            adj[v - 1].append(u - 1)

        # Define a helper function to calculate the number of subtrees with a given diameter
        def num_subtrees(start: int, parent: int) -> List[int]:
            # Calculate the number of subtrees with diameter 1 (i.e., single nodes)
            diam1 = [1]

            # Recursively calculate the number of subtrees with diameter d for d >= 2
            diam2 = [0]
            for neighbor in adj[start]:
                if neighbor == parent:
                    continue
                subtrees = num_subtrees(neighbor, start)
                diam1_next = diam1[0] * subtrees[0]
                diam2_next = comb(subtrees[1:], diam1[1:])
                diam1 = [diam1_next] + diam1[1:]
                diam2 += diam2_next

            # Return the number of subtrees with each diameter
            return diam1 + diam2

        # Define a helper function to calculate the binomial coefficient
        def comb(n: List[int], k: List[int]) -> List[int]:
            # Initialize the result list
            res = [0] * len(k)

            # Calculate the binomial coefficient for each value of k
            res[0] = n[0] * k[0]
            for i in range(1, len(n)):
                n[i] += n[i - 1]
                k[i] += k[i - 1]
                res[i] = n[i] * k[i] - n[i - 1] * k[i - 1]
            for i in range(len(n), len(k)):
                res[i] = (k[i] - k[i - 1]) * n[-1]

            return res

        # Calculate the number of subtrees for each diameter
        ans = [0] * (n - 1)
        for u, v in edges:
            u -= 1
            v -= 1
            subtrees = num_subtrees(u, v)
            subtrees2 = num_subtrees(v, u)
            for i in range(min(len(subtrees), len(subtrees2))):
                ans[i + i + 1] += subtrees[i] * subtrees2[i]

        # Return the number of subtrees for each diameter (excluding the diameter 0 case)
        return ans[1:]
"
3134,python3,count-subtrees-with-max-distance-between-cities,"class Solution:
    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:
        adj = [[] for i in range(n)]
        for u,v in edges:
            adj[u-1].append(v-1)
            adj[v-1].append(u-1)
        def comb(p,q):
            if len(q)<len(p): p,q = q,p
            res = [0]*len(q)
            res[0] = p[0]*q[0]
            for i in range(1,len(p)): p[i] += p[i-1]
            for i in range(1,len(q)): q[i] += q[i-1]
            for i in range(1,len(p)):
                res[i] = p[i]*q[i]-p[i-1]*q[i-1]
            for i in range(len(p),len(q)):
                res[i] = (q[i]-q[i-1])*p[-1]
            return res
            
        def dfs(r,p):
            d = [1]
            for v in adj[r]:
                if v==p: continue
                t = [0]+dfs(v,r) 
                d = comb(t,d)
            return d
        ans = [0]*n
        for u,v in edges:
            u -= 1; v-=1
            p = dfs(u,v)
            q = dfs(v,u)
            for i in range(min(len(p),len(q))):
                ans[i+i+1] += p[i]*q[i]
        for v in range(n): 
            if len(adj[v])==1: continue 
            tree = [1]+dfs(adj[v][0],v)
            curr = [0]*n
            for u in adj[v][1:]:
                q = [1]+dfs(u,v)
                j = 1; t = q[1]+1
                for i in range(4,n,2):
                    while j+1<min(i//2,len(q)):
                        j += 1; t += q[j]
                    curr[i] *= t
                for i in range(min(len(tree),len(q))):
                    curr[i+i] += tree[i]*q[i]
                tree = comb(tree,q)
            for i in range(2,n,2):
                ans[i] += curr[i]
        return ans[1:]",None,"class Solution:
    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:
        adj = [[] for i in range(n)]
        for u, v in edges:
            adj[u - 1].append(v - 1)
            adj[v - 1].append(u - 1)

        def dfs(r, p):
            d = [0] * n
            d[0] = 1
            for v in adj[r]:
                if v == p:
                    continue
                t = dfs(v, r)
                for i in range(len(d)):
                    d[i] += t[i]
            return d

        def comb(p, q):
            if len(q) < len(p):
                p, q = q, p
            res = [0] * len(q)
            res[0] = p[0] * q[0]
            for i in range(1, len(p)):
                p[i] += p[i - 1]
            for i in range(1, len(q)):
                q[i] += q[i - 1]
            for i in range(1, len(p)):
                res[i] = p[i] * q[i] - p[i - 1] * q[i - 1]
            for i in range(len(p), len(q)):
                res[i] = (q[i] - q[i - 1]) * p[-1]
            return res

        ans = [0] * (n - 1)
        for u, v in edges:
            u -= 1; v -= 1
            p = dfs(u, v)
            q = dfs(v, u)
            for i in range(min(len(p), len(q))):
                ans[i] += p[i] * q[i]

        for v in range(n):
            if len(adj[v]) == 1:
                continue
            tree = dfs(adj[v][0], v)
            curr = [0] * n
            for u in adj[v][1:]:
                q = dfs(u, v)
                j = 1
                t = q[1] + 1
                for i in range(2, n, 2):
                    while j + 1 < min(i // 2, len(q)):
                        j += 1
                        t += q[j]
                    curr[i] += t
                for i in range(min(len(tree), len(q))):
                    curr[i + i] += tree[i] * q[i]
                tree = comb(tree, q)
            for i in range(2, n, 2):
                ans[i - 1] += curr[i]
        return ans
"
3134,python3,count-subtrees-with-max-distance-between-cities,"class Solution:
    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:
        adj = [[] for i in range(n)]
        for u,v in edges:
            adj[u-1].append(v-1)
            adj[v-1].append(u-1)
        def comb(p,q):
            if len(q)<len(p): p,q = q,p
            res = [0]*len(q)
            res[0] = p[0]*q[0]
            for i in range(1,len(p)): p[i] += p[i-1]
            for i in range(1,len(q)): q[i] += q[i-1]
            for i in range(1,len(p)):
                res[i] = p[i]*q[i]-p[i-1]*q[i-1]
            for i in range(len(p),len(q)):
                res[i] = (q[i]-q[i-1])*p[-1]
            return res
            
        def dfs(r,p):
            d = [1]
            for v in adj[r]:
                if v==p: continue
                t = [0]+dfs(v,r) 
                d = comb(t,d)
            return d
        ans = [0]*n
        for u,v in edges:
            u -= 1; v-=1
            p = dfs(u,v)
            q = dfs(v,u)
            for i in range(min(len(p),len(q))):
                ans[i+i+1] += p[i]*q[i]
        for v in range(n): 
            if len(adj[v])==1: continue 
            tree = [1]+dfs(adj[v][0],v)
            curr = [0]*n
            for u in adj[v][1:]:
                q = [1]+dfs(u,v)
                j = 1; t = q[1]+1
                for i in range(4,n,2):
                    while j+1<min(i//2,len(q)):
                        j += 1; t += q[j]
                    curr[i] *= t
                for i in range(min(len(tree),len(q))):
                    curr[i+i] += tree[i]*q[i]
                tree = comb(tree,q)
            for i in range(2,n,2):
                ans[i] += curr[i]
        return ans[1:]",None,M
3135,python3,next-greater-element-iv,"class Solution:
    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        ans = [-1] * len(nums)
        s, ss = [], []
        for i, x in enumerate(nums): 
            while ss and nums[ss[-1]] < x: ans[ss.pop()] = x
            buff = []
            while s and nums[s[-1]] < x: buff.append(s.pop())
            while buff: s.append(buff.pop())
            s.append(i)
        return ans",None,"class Solution:
    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        ans = [-1] * len(nums)
        s, ss = [], []
        for i, x in enumerate(nums): 
            while ss and nums[ss[-1]] < x: ans[ss.pop()] = x
            buff = []
            while s and nums[s[-1]] < x: buff.append(s.pop())
            while buff: s.append(buff.pop())
            s.append(i)
        return ans
"
3135,python3,next-greater-element-iv,"class Solution:
    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        ans = [-1] * len(nums)
        s, ss = [], []
        for i, x in enumerate(nums): 
            while ss and nums[ss[-1]] < x: ans[ss.pop()] = x
            buff = []
            while s and nums[s[-1]] < x: buff.append(s.pop())
            while buff: s.append(buff.pop())
            s.append(i)
        return ans",None,"class Solution:
    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        ans = [-1] * len(nums)
        stack = []
        for i, x in enumerate(nums):
            while stack and nums[stack[-1]] < x:
                top = stack.pop()
                ans[top] = x
            stack.append(i)
        return ans
"
3135,python3,next-greater-element-iv,"class Solution:
    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        ans = [-1] * len(nums)
        s, ss = [], []
        for i, x in enumerate(nums): 
            while ss and nums[ss[-1]] < x: ans[ss.pop()] = x
            buff = []
            while s and nums[s[-1]] < x: buff.append(s.pop())
            while buff: s.append(buff.pop())
            s.append(i)
        return ans",None,"class Solution:
    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        ans = [-1] * len(nums)
        s, ss = [], []
        for i, x in enumerate(nums): 
            while ss and nums[ss[-1]] < x: ans[ss.pop()] = x
            buff = []
            while s and nums[s[-1]] < x: buff.append(s.pop())
            while buff: s.append(buff.pop())
            s.append(i)
        return ans
"
3136,python3,minimum-obstacle-removal-to-reach-corner,"class Solution:
    def minimumObstacles(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        distance = [[float('inf') for _ in range(n)] for _ in range(m)]
        distance[0][0] = 0
        q = collections.deque([(0, 0, 0)])
        while q:
            d, i, j = q.popleft()
            if i == m - 1 and j == n - 1: return d
            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    if d + grid[ci][cj] < distance[ci][cj]:
                        distance[ci][cj] = d + grid[ci][cj]
                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))
                        else: q.appendleft((distance[ci][cj], ci, cj))
                else: q.appendleft((distance[i][j], i, j))
        return distance[m - 1][n - 1]",None,"class Solution:
    def minimumObstacles(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        distance = [[float('inf') for _ in range(n)] for _ in range(m)]
        distance[0][0] = 0
        q = collections.deque([(0, 0)])
        while q:
            i, j = q.popleft()
            if i == m - 1 and j == n - 1: return distance[i][j]
            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    if distance[i][j] + grid[ci][cj] < distance[ci][cj]:
                        distance[ci][cj] = distance[i][j] + grid[ci][cj]
                        q.append((ci, cj))
        return distance[m - 1][n - 1]
"
3136,python3,minimum-obstacle-removal-to-reach-corner,"class Solution:
    def minimumObstacles(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        distance = [[float('inf') for _ in range(n)] for _ in range(m)]
        distance[0][0] = 0
        q = collections.deque([(0, 0, 0)])
        while q:
            d, i, j = q.popleft()
            if i == m - 1 and j == n - 1: return d
            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    if d + grid[ci][cj] < distance[ci][cj]:
                        distance[ci][cj] = d + grid[ci][cj]
                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))
                        else: q.appendleft((distance[ci][cj], ci, cj))
                else: q.appendleft((distance[i][j], i, j))
        return distance[m - 1][n - 1]",None,"class Solution:
    def minimumObstacles(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        distance = [[float('inf') for _ in range(n)] for _ in range(m)]
        distance[0][0] = 0
        q = collections.deque([(0, 0)])
        while q:
            i, j = q.popleft()
            if i == m - 1 and j == n - 1: return distance[i][j]
            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    if distance[i][j] + grid[ci][cj] < distance[ci][cj]:
                        distance[ci][cj] = distance[i][j] + grid[ci][cj]
                        q.append((ci, cj))
        return distance[m - 1][n - 1]
"
3136,python3,minimum-obstacle-removal-to-reach-corner,"class Solution:
    def minimumObstacles(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        distance = [[float('inf') for _ in range(n)] for _ in range(m)]
        distance[0][0] = 0
        q = collections.deque([(0, 0, 0)])
        while q:
            d, i, j = q.popleft()
            if i == m - 1 and j == n - 1: return d
            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    if d + grid[ci][cj] < distance[ci][cj]:
                        distance[ci][cj] = d + grid[ci][cj]
                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))
                        else: q.appendleft((distance[ci][cj], ci, cj))
                else: q.appendleft((distance[i][j], i, j))
        return distance[m - 1][n - 1]",None,"class Solution:
    def minimumObstacles(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        distance = [[float('inf') for _ in range(n)] for _ in range(m)]
        distance[0][0] = 0
        q = collections.deque([(0, 0)])
        while q:
            i, j = q.popleft()
            if i == m - 1 and j == n - 1: return distance[i][j]
            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    if distance[i][j] + grid[ci][cj] < distance[ci][cj]:
                        distance[ci][cj] = distance[i][j] + grid[ci][cj]
                        q.append((ci, cj))
"
3137,python3,linked-list-in-binary-tree,"class Solution:
    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:

        if head is None:
            return True

        if root is None:
            return False

        if head.val == root.val:
            if self.isSame(head, root):
                return True
            
        return self.isSubPath(head.next, root.left) or self.isSubPath(head.next, root.right)

    
    def isSame(self, head, root):

        if head is None:
            return True
        
        if root is None:
            return False

        if head.val == root.val:
            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)
        
        return False",None,"class Solution:
    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:

        if head is None:
            return True

        if root is None:
            return False

        if head.val == root.val:
            if self.isSame(head, root):
                return True

        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right) or self.isSubPath(head.next, root)

    
    def isSame(self, head, root):

        if head is None:
            return True
        
        if root is None:
            return False

        if head.val == root.val:
            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)
        
        return False
"
3137,python3,linked-list-in-binary-tree,"class Solution:
    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:

        if head is None:
            return True

        if root is None:
            return False

        if head.val == root.val:
            if self.isSame(head, root):
                return True
            
        return self.isSubPath(head.next, root.left) or self.isSubPath(head.next, root.right)

    
    def isSame(self, head, root):

        if head is None:
            return True
        
        if root is None:
            return False

        if head.val == root.val:
            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)
        
        return False",None,"class Solution:
    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:

        if head is None:
            return True

        if root is None:
            return False

        if head.val == root.val:
            if self.isSame(head, root):
                return True

        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right) or self.isSubPath(head.next, root)

    
    def isSame(self, head, root):

        if head is None:
            return True
        
        if root is None:
            return False

        if head.val == root.val:
            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)
        
        return False
"
3137,python3,linked-list-in-binary-tree,"class Solution:
    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:

        if head is None:
            return True

        if root is None:
            return False

        if head.val == root.val:
            if self.isSame(head, root):
                return True
            
        return self.isSubPath(head.next, root.left) or self.isSubPath(head.next, root.right)

    
    def isSame(self, head, root):

        if head is None:
            return True
        
        if root is None:
            return False

        if head.val == root.val:
            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)
        
        return False",None,"class Solution:
    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:

        if head is None:
            return True

        if root is None:
            return False

        if head.val == root.val:
            if self.isSame(head, root):
                return True

        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right) or self.isSubPath(head.next, root)

    
    def isSame(self, head, root):

        if head is None:
            return True
        
        if root is None:
            return False

        if head.val == root.val:
            return self.isSame(head.next, root.left) and self.isSame(head.next, root.right)
        
        return False
"
3138,python3,stone-game-vi,"class Solution:
    def stoneGameVI(self, a: List[int], b: List[int]) -> int:
        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]
        combines.sort(reverse=True)
        bobPoints = sum(b)
        alicePoints = 0
        for i in range(1, len(a), 2):
            alicePoints += combines[i][1]
            bobPoints -= combines[i][2]
        if alicePoints > bobPoints:
            return 1
        elif alicePoints < bobPoints:
            return -1
        return 0",None,"class Solution:
    def stoneGameVI(self, a: List[int], b: List[int]) -> int:
        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]
        combines.sort(reverse=True)
        alicePoints = 0
        bobPoints = 0
        for i in range(len(a)):
            if i % 2 == 0:
                alicePoints += combines[i][1]
            else:
                bobPoints += combines[i][2]
        if alicePoints > bobPoints:
            return 1
        elif alicePoints < bobPoints:
            return -1
        return 0
"
3138,python3,stone-game-vi,"class Solution:
    def stoneGameVI(self, a: List[int], b: List[int]) -> int:
        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]
        combines.sort(reverse=True)
        bobPoints = sum(b)
        alicePoints = 0
        for i in range(1, len(a), 2):
            alicePoints += combines[i][1]
            bobPoints -= combines[i][2]
        if alicePoints > bobPoints:
            return 1
        elif alicePoints < bobPoints:
            return -1
        return 0",None,"class Solution:
    def stoneGameVI(self, a: List[int], b: List[int]) -> int:
        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]
        combines.sort(reverse=True)
        alicePoints = 0
        bobPoints = 0
        for i in range(len(a)):
            if i % 2 == 0:
                alicePoints += combines[i][1]
            else:
                bobPoints += combines[i][2]
        if alicePoints > bobPoints:
            return 1
        elif alicePoints < bobPoints:
            return -1
        return 0
"
3138,python3,stone-game-vi,"class Solution:
    def stoneGameVI(self, a: List[int], b: List[int]) -> int:
        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]
        combines.sort(reverse=True)
        bobPoints = sum(b)
        alicePoints = 0
        for i in range(1, len(a), 2):
            alicePoints += combines[i][1]
            bobPoints -= combines[i][2]
        if alicePoints > bobPoints:
            return 1
        elif alicePoints < bobPoints:
            return -1
        return 0",None,"class Solution:
    def stoneGameVI(self, a: List[int], b: List[int]) -> int:
        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]
        combines.sort(reverse=True)
        alicePoints = 0
        bobPoints = 0
        for i in range(len(a)):
            if i % 2 == 0:
                alicePoints += combines[i][1]
            else:
                bobPoints += combines[i][2]
        if alicePoints > bobPoints:
            return 1
        elif alicePoints < bobPoints:
            return -1
        return 0
"
3139,python3,find-the-array-concatenation-value,"class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        i=0
        c=0
        j=len(nums)
        while(i<=j):
            if(i==j):
                c=c+nums[i]
                break
            s=str(nums[i])+str(nums[j])
            c=c+int(s)
            i=i+1
            j=j-1
        return c",None,"class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        i = 0
        j = len(nums) - 1
        concat_val = 0
        while i <= j:
            if i == j:
                concat_val += nums[i]
            else:
                concat_val += int(str(nums[i]) + str(nums[j]))
            i += 1
            j -= 1
        return concat_val
"
3139,python3,find-the-array-concatenation-value,"class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        i=0
        c=0
        j=len(nums)
        while(i<=j):
            if(i==j):
                c=c+nums[i]
                break
            s=str(nums[i])+str(nums[j])
            c=c+int(s)
            i=i+1
            j=j-1
        return c",None,"class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        i = 0
        j = len(nums) - 1
        concat_val = 0

        while i <= j:
            if i == j:
                concat_val += nums[i]
            else:
                # Concatenate the first and last numbers
                concat_val += int(str(nums[i]) + str(nums[j]))
            i += 1
            j -= 1

        return concat_val
"
3139,python3,find-the-array-concatenation-value,"class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        i=0
        c=0
        j=len(nums)
        while(i<=j):
            if(i==j):
                c=c+nums[i]
                break
            s=str(nums[i])+str(nums[j])
            c=c+int(s)
            i=i+1
            j=j-1
        return c",None,"class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        i = 0
        j = len(nums) - 1
        c = 0
        while i <= j:
            if i == j:
                c += nums[i]
            else:
                s = str(nums[i]) + str(nums[j])
                c += int(s)
            i += 1
            j -= 1
        return c
"
3140,python3,check-if-every-row-and-column-contains-all-numbers,"class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:

        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]
        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]

        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if dp_row[i][j] or dp_col[i][j]:
                    return False
                dp_row[i][j] = True
                dp_col[i][j] = True
        return True",None,"class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:

        dp_col = [set() for _ in range(len(matrix))]
        dp_row = [set() for _ in range(len(matrix))]

        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if i in dp_row[j] or j in dp_col[i]:
                    return False
                dp_row[j].add(i)
                dp_col[i].add(j)
        return True
"
3140,python3,check-if-every-row-and-column-contains-all-numbers,"class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:

        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]
        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]

        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if dp_row[i][j] or dp_col[i][j]:
                    return False
                dp_row[i][j] = True
                dp_col[i][j] = True
        return True",None,"class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:

        dp_col = [set() for _ in range(len(matrix[0]))]
        dp_row = [set() for _ in range(len(matrix))]

        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j] in dp_row[i] or matrix[i][j] in dp_col[j]:
                    return False
                dp_row[i].add(matrix[i][j])
                dp_col[j].add(matrix[i][j])
        return True
"
3140,python3,check-if-every-row-and-column-contains-all-numbers,"class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:

        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]
        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]

        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if dp_row[i][j] or dp_col[i][j]:
                    return False
                dp_row[i][j] = True
                dp_col[i][j] = True
        return True",None,"class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:

        dp_col = [False] * len(matrix[0])
        dp_row = [False] * len(matrix)

        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if dp_row[i] or dp_col[j]:
                    return False
                dp_row[i] = True
                dp_col[j] = True
        return True
"
3141,python3,maximum-gap,"class Solution:
    def maximumGap(self, nums: List[int]) -> int:
        nums=sorted(nums)
        min=float(""inf"")
        if len(nums)<2:
            return 0
        for i in range(len(nums)-1):
            x=abs(nums[i]-nums[i+1])
            if min<x:
                min=x
        return min",None,"class Solution:
    def maximumGap(self, nums: List[int]) -> int:
        if len(nums) < 2:
            return 0
        nums.sort()
        max_gap = 0
        for i in range(1, len(nums)):
            max_gap = max(max_gap, nums[i] - nums[i - 1])
        return max_gap
"
3141,python3,maximum-gap,"class Solution:
    def maximumGap(self, nums: List[int]) -> int:
        nums=sorted(nums)
        min=float(""inf"")
        if len(nums)<2:
            return 0
        for i in range(len(nums)-1):
            x=abs(nums[i]-nums[i+1])
            if min<x:
                min=x
        return min",None,"class Solution:
    def maximumGap(self, nums: List[int]) -> int:
        if len(nums) < 2:
            return 0
        nums.sort()
        return max(nums[i + 1] - nums[i] for i in range(len(nums) - 1))
"
3141,python3,maximum-gap,"class Solution:
    def maximumGap(self, nums: List[int]) -> int:
        nums=sorted(nums)
        min=float(""inf"")
        if len(nums)<2:
            return 0
        for i in range(len(nums)-1):
            x=abs(nums[i]-nums[i+1])
            if min<x:
                min=x
        return min",None,"class Solution:
    def maximumGap(self, nums: List[int]) -> int:
        if len(nums) < 2:
            return 0
        nums.sort()
        max_gap = 0
        for i in range(1, len(nums)):
            max_gap = max(max_gap, nums[i] - nums[i-1])
        return max_gap
"
3142,python3,minimum-index-sum-of-two-lists,"class Solution:
    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
        d2={}
        l=[]
        for i in range(len(list2)):
            d2[list2[i]]=i
        for i in range(len(list1)):
            if list1[i] in d2:
                l.append([i+d2[list1[i]],list1[i]])
        l1=[]
        l.sort()
        l1.append(l[1][1]) 
        for i in range(1,len(l)):
            if l[i][0]==l[i-1][0]:
                l1.append(l[i][1])
            else:
                break
        return l1",None,"class Solution:
    def findRestaurant(self, list1, list2):
        d2 = {}
        l = []
        for i in range(len(list2)):
            d2[list2[i]] = i
        for i in range(len(list1)):
            if list1[i] in d2:
                l.append([i + d2[list1[i]], list1[i]])
        l.sort()
        min_sum = l[0][0]
        result = [l[0][1]]
        for i in range(1, len(l)):
            if l[i][0] == min_sum:
                result.append(l[i][1])
            elif l[i][0] > min_sum:
                break
        return result
"
3142,python3,minimum-index-sum-of-two-lists,"class Solution:
    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
        d2={}
        l=[]
        for i in range(len(list2)):
            d2[list2[i]]=i
        for i in range(len(list1)):
            if list1[i] in d2:
                l.append([i+d2[list1[i]],list1[i]])
        l1=[]
        l.sort()
        l1.append(l[1][1]) 
        for i in range(1,len(l)):
            if l[i][0]==l[i-1][0]:
                l1.append(l[i][1])
            else:
                break
        return l1",None,"class Solution:
    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
        d2={}
        l=[]
        for i in range(len(list2)):
            d2[list2[i]]=i
        for i in range(len(list1)):
            if list1[i] in d2:
                l.append([i+d2[list1[i]],list1[i]])
        l.sort()
        min_sum = l[0][0]
        result = [item[1] for item in l if item[0] == min_sum]
        return result
"
3142,python3,minimum-index-sum-of-two-lists,"class Solution:
    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
        d2={}
        l=[]
        for i in range(len(list2)):
            d2[list2[i]]=i
        for i in range(len(list1)):
            if list1[i] in d2:
                l.append([i+d2[list1[i]],list1[i]])
        l1=[]
        l.sort()
        l1.append(l[1][1]) 
        for i in range(1,len(l)):
            if l[i][0]==l[i-1][0]:
                l1.append(l[i][1])
            else:
                break
        return l1",None,"class Solution:
    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
        d2={}
        l=[]
        for i in range(len(list2)):
            d2[list2[i]]=i
        for i in range(len(list1)):
            if list1[i] in d2:
                l.append([i+d2[list1[i]],list1[i]])
        l.sort()
        min_sum = l[0][0]
        result = [l[0][1]]
        for i in range(1, len(l)):
            if l[i][0] == min_sum:
                result.append(l[i][1])
            elif l[i][0] < min_sum:
                min_sum = l[i][0]
                result = [l[i][1]]
        return result
"
3143,python3,median-of-two-sorted-arrays,"class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        p1 = 0
        p2 = 0
        new = []
        while p1 < len(nums1) and p2 < len(nums2):
            if nums1[p1] < nums2[p2]:
                new.append(nums1[p1])
                p1 += 1
            else:
                new.append(nums2[p2])
                p2 += 1
        while p1 < len(nums1):
            new.append(nums1[p1])
            p2 += 1
        while p2 < len(nums2):
            new.append(nums2[p2])
            p1 += 1

        if len(new) % 2 == 0:
            index = len(new) // 2
            median = (new[index] + new[index-1]) / 2
        else:
            median = float(new[len(new)//2])
        return median",None,"class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        p1 = 0
        p2 = 0
        new = []
        while p1 < len(nums1) and p2 < len(nums2):
            if nums1[p1] < nums2[p2]:
                new.append(nums1[p1])
                p1 += 1
            else:
                new.append(nums2[p2])
                p2 += 1
        while p1 < len(nums1):
            new.append(nums1[p1])
            p1 += 1
        while p2 < len(nums2):
            new.append(nums2[p2])
            p2 += 1

        if len(new) % 2 == 0:
            index = len(new) // 2
            median = (new[index] + new[index-1]) / 2
        else:
            median = new[len(new)//2]
        return median
"
3143,python3,median-of-two-sorted-arrays,"class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        p1 = 0
        p2 = 0
        new = []
        while p1 < len(nums1) and p2 < len(nums2):
            if nums1[p1] < nums2[p2]:
                new.append(nums1[p1])
                p1 += 1
            else:
                new.append(nums2[p2])
                p2 += 1
        while p1 < len(nums1):
            new.append(nums1[p1])
            p2 += 1
        while p2 < len(nums2):
            new.append(nums2[p2])
            p1 += 1

        if len(new) % 2 == 0:
            index = len(new) // 2
            median = (new[index] + new[index-1]) / 2
        else:
            median = float(new[len(new)//2])
        return median",None,"class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        p1 = 0
        p2 = 0
        new = []
        while p1 < len(nums1) and p2 < len(nums2):
            if nums1[p1] < nums2[p2]:
                new.append(nums1[p1])
                p1 += 1
            else:
                new.append(nums2[p2])
                p2 += 1
        while p1 < len(nums1):
            new.append(nums1[p1])
            p1 += 1
        while p2 < len(nums2):
            new.append(nums2[p2])
            p2 += 1

        length = len(new)
        if length % 2 == 0:
            index = length // 2
            median = (new[index] + new[index-1]) / 2
        else:
            median = new[length//2]
        return median
"
3143,python3,median-of-two-sorted-arrays,"class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        p1 = 0
        p2 = 0
        new = []
        while p1 < len(nums1) and p2 < len(nums2):
            if nums1[p1] < nums2[p2]:
                new.append(nums1[p1])
                p1 += 1
            else:
                new.append(nums2[p2])
                p2 += 1
        while p1 < len(nums1):
            new.append(nums1[p1])
            p2 += 1
        while p2 < len(nums2):
            new.append(nums2[p2])
            p1 += 1

        if len(new) % 2 == 0:
            index = len(new) // 2
            median = (new[index] + new[index-1]) / 2
        else:
            median = float(new[len(new)//2])
        return median",None,"class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        p1 = 0
        p2 = 0
        new = []
        while p1 < len(nums1) and p2 < len(nums2):
            if nums1[p1] < nums2[p2]:
                new.append(nums1[p1])
                p1 += 1
            else:
                new.append(nums2[p2])
                p2 += 1
        while p1 < len(nums1):
            new.append(nums1[p1])
            p1 += 1
        while p2 < len(nums2):
            new.append(nums2[p2])
            p2 += 1

        if len(new) % 2 == 0:
            index = len(new) // 2
            median = (new[index] + new[index-1]) / 2
        else:
            median = new[len(new)//2]
        return median
"
3144,python3,reverse-subarray-to-maximize-array-value,"class Solution:
    def maxValueAfterReverse(self, nums: List[int]) -> int:
        originalValue, sz = 0, len(nums)
        for idx in range(sz - 1):
            originalValue += abs(nums[idx] - nums[idx + 1])
        finalValue = originalValue
        for idx in range(1, sz - 1):
            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx + 1]) + abs(nums[idx + 1] - nums[0]))
            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx - 1]) + abs(nums[idx - 1] - nums[sz - 1]))
        minimum, maximum = inf, -inf
        for idx in range(sz - 1):
            tempMin, tempMax = min(nums[idx], nums[idx + 1]), max(nums[idx], nums[idx + 1])
            if minimum < tempMin: finalValue = max(finalValue, originalValue + (tempMin - minimum) * 2)
            if tempMax < maximum: finalValue = max(finalValue, originalValue + (maximum - tempMax) * 2)
            minimum = min(minimum, tempMax)
            maximum = max(maximum, tempMax)
        return finalValue",None,"class Solution:
    def maxValueAfterReverse(self, nums: List[int]) -> int:
        originalValue, sz = 0, len(nums)
        for idx in range(sz - 1):
            originalValue += abs(nums[idx] - nums[idx + 1])
        finalValue = originalValue
        for idx in range(1, sz - 1):
            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx + 1]) + abs(nums[idx + 1] - nums[0]))
            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx - 1]) + abs(nums[idx - 1] - nums[sz - 1]))
        minimum, maximum = nums[0], nums[-1]
        for idx in range(sz - 1):
            tempMin, tempMax = min(nums[idx], nums[idx + 1]), max(nums[idx], nums[idx + 1])
            if minimum < tempMin: finalValue = max(finalValue, originalValue + (tempMin - minimum) * 2)
            if tempMax > maximum: maximum = tempMax
            minimum = tempMin
        finalValue = max(finalValue, originalValue + (maximum - minimum) * 2)
        return finalValue
"
3144,python3,reverse-subarray-to-maximize-array-value,"class Solution:
    def maxValueAfterReverse(self, nums: List[int]) -> int:
        originalValue, sz = 0, len(nums)
        for idx in range(sz - 1):
            originalValue += abs(nums[idx] - nums[idx + 1])
        finalValue = originalValue
        for idx in range(1, sz - 1):
            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx + 1]) + abs(nums[idx + 1] - nums[0]))
            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx - 1]) + abs(nums[idx - 1] - nums[sz - 1]))
        minimum, maximum = inf, -inf
        for idx in range(sz - 1):
            tempMin, tempMax = min(nums[idx], nums[idx + 1]), max(nums[idx], nums[idx + 1])
            if minimum < tempMin: finalValue = max(finalValue, originalValue + (tempMin - minimum) * 2)
            if tempMax < maximum: finalValue = max(finalValue, originalValue + (maximum - tempMax) * 2)
            minimum = min(minimum, tempMax)
            maximum = max(maximum, tempMax)
        return finalValue",None,"class Solution:
    def maxValueAfterReverse(self, nums: List[int]) -> int:
        originalValue = sum(abs(nums[i] - nums[i + 1]) for i in range(len(nums) - 1))
        finalValue = originalValue
        for idx in range(1, len(nums) - 1):
            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx + 1]) + abs(nums[idx + 1] - nums[0]))
            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx - 1]) + abs(nums[idx - 1] - nums[-1]))
        minimum, maximum = float('inf'), float('-inf')
        for idx in range(len(nums) - 1):
            tempMin, tempMax = min(nums[idx], nums[idx + 1]), max(nums[idx], nums[idx + 1])
            if minimum > tempMin: finalValue = max(finalValue, originalValue + (tempMin - minimum) * 2)
            if tempMax > maximum: finalValue = max(finalValue, originalValue + (maximum - tempMax) * 2)
            minimum = min(minimum, tempMax)
            maximum = max(maximum, tempMax)
        return finalValue
"
3144,python3,reverse-subarray-to-maximize-array-value,"class Solution:
    def maxValueAfterReverse(self, nums: List[int]) -> int:
        originalValue, sz = 0, len(nums)
        for idx in range(sz - 1):
            originalValue += abs(nums[idx] - nums[idx + 1])
        finalValue = originalValue
        for idx in range(1, sz - 1):
            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx + 1]) + abs(nums[idx + 1] - nums[0]))
            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx - 1]) + abs(nums[idx - 1] - nums[sz - 1]))
        minimum, maximum = inf, -inf
        for idx in range(sz - 1):
            tempMin, tempMax = min(nums[idx], nums[idx + 1]), max(nums[idx], nums[idx + 1])
            if minimum < tempMin: finalValue = max(finalValue, originalValue + (tempMin - minimum) * 2)
            if tempMax < maximum: finalValue = max(finalValue, originalValue + (maximum - tempMax) * 2)
            minimum = min(minimum, tempMax)
            maximum = max(maximum, tempMax)
        return finalValue",None,"class Solution:
    def maxValueAfterReverse(self, nums: List[int]) -> int:
        originalValue, sz = 0, len(nums)
        for idx in range(sz - 1):
            originalValue += abs(nums[idx] - nums[idx + 1])
        finalValue = originalValue
        for idx in range(1, sz - 1):
            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx + 1]) + abs(nums[idx + 1] - nums[0]))
            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx - 1]) + abs(nums[idx - 1] - nums[-1]))
        minimum, maximum = nums[0], nums[-1]
        for idx in range(sz - 1):
            tempMin, tempMax = min(nums[idx], nums[idx + 1]), max(nums[idx], nums[idx + 1])
            if minimum < tempMin: finalValue = max(finalValue, originalValue + (tempMin - minimum) * 2)
            if tempMax > maximum: finalValue = max(finalValue, originalValue + (maximum - tempMax) * 2)
            minimum = min(minimum, tempMin)
            maximum = max(maximum, tempMax)
        return finalValue
"
3145,python3,make-costs-of-paths-equal-in-a-binary-tree,"class Solution:
    def minIncrements(self, n: int, cost: List[int]) -> int:

        ans = 0
        n//=2                                            

        for i in reversed(range(n)):
        
            mn, mx = sorted((cost[2*i+1], cost[2*i]))     

            ans+= mx - mn
            cost[i]+= mx

        return ans",None,"class Solution:
    def minIncrements(self, n: int, cost: List[int]) -> int:

        ans = 0
        n //= 2

        for i in range(n):
            mn, mx = sorted((cost[2*i+1], cost[2*i]))     

            ans += mx - mn
            cost[2*i] += mx
            cost[2*i+1] += mx

        return ans
"
3145,python3,make-costs-of-paths-equal-in-a-binary-tree,"class Solution:
    def minIncrements(self, n: int, cost: List[int]) -> int:

        ans = 0
        n//=2                                            

        for i in reversed(range(n)):
        
            mn, mx = sorted((cost[2*i+1], cost[2*i]))     

            ans+= mx - mn
            cost[i]+= mx

        return ans",None,"class Solution:
    def minIncrements(self, n: int, cost: List[int]) -> int:

        ans = 0
        n //= 2

        for i in reversed(range(n)):
            mn, mx = sorted((cost[2*i], cost[2*i+1]))

            ans += mx - mn
            cost[i] += mx

        return ans
"
3145,python3,make-costs-of-paths-equal-in-a-binary-tree,"class Solution:
    def minIncrements(self, n: int, cost: List[int]) -> int:

        ans = 0
        n//=2                                            

        for i in reversed(range(n)):
        
            mn, mx = sorted((cost[2*i+1], cost[2*i]))     

            ans+= mx - mn
            cost[i]+= mx

        return ans",None,"class Solution:
    def minIncrements(self, n: int, cost: List[int]) -> int:

        ans = 0
        n //= 2

        for i in reversed(range(n)):
            mn, mx = sorted([cost[2*i], cost[2*i+1]])

            ans += max(0, mx - mn)
            cost[i] += mx

        return ans
"
3146,python3,minimum-difference-between-highest-and-lowest-of-k-scores,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        l, r = 0, k
        res = float(""inf"")
        while r < len(nums):
            res = min(res, nums[r] - nums[l])
            r += 1
            l += 1
        return res",None,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        res = float(""inf"")
        for i in range(len(nums) - k + 1):
            res = min(res, nums[i + k - 1] - nums[i])
        return res
"
3146,python3,minimum-difference-between-highest-and-lowest-of-k-scores,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        l, r = 0, k
        res = float(""inf"")
        while r < len(nums):
            res = min(res, nums[r] - nums[l])
            r += 1
            l += 1
        return res",None,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        res = float(""inf"")
        for i in range(len(nums) - k + 1):
            res = min(res, nums[i + k - 1] - nums[i])
        return res
"
3146,python3,minimum-difference-between-highest-and-lowest-of-k-scores,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        l, r = 0, k
        res = float(""inf"")
        while r < len(nums):
            res = min(res, nums[r] - nums[l])
            r += 1
            l += 1
        return res",None,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        res = float(""inf"")
        for i in range(len(nums) - k + 1):
            res = min(res, nums[i + k - 1] - nums[i])
        return res
"
3147,python3,partition-string-into-substrings-with-values-at-most-k,"class Solution:
    def minimumPartition(self, s: str, k: int) -> int:
        curr, ans = 0, 1
        for d in s:
            if int(d) > k:
                return -1
            curr = 10 * curr + int(d)
            if curr > k:
                ans += 1
                curr = int(d)
        return curr",None,"class Solution:
    def minimumPartition(self, s: str, k: int) -> int:
        curr, ans = 0, 1
        for d in s:
            if int(d) > k:
                return -1
            curr = min(curr * 10 + int(d), int(d))
            if curr > k:
                ans += 1
                curr = int(d)
        return ans
"
3147,python3,partition-string-into-substrings-with-values-at-most-k,"class Solution:
    def minimumPartition(self, s: str, k: int) -> int:
        curr, ans = 0, 1
        for d in s:
            if int(d) > k:
                return -1
            curr = 10 * curr + int(d)
            if curr > k:
                ans += 1
                curr = int(d)
        return curr",None,"class Solution:
    def minimumPartition(self, s: str, k: int) -> int:
        curr, ans = 0, 1
        for d in s:
            if int(d) > k:
                return -1
            if curr * 10 > k or (curr * 10 == k and int(d) > k // 10):
                ans += 1
                curr = int(d)
            else:
                curr = curr * 10 + int(d)
        return ans
"
3147,python3,partition-string-into-substrings-with-values-at-most-k,"class Solution:
    def minimumPartition(self, s: str, k: int) -> int:
        curr, ans = 0, 1
        for d in s:
            if int(d) > k:
                return -1
            curr = 10 * curr + int(d)
            if curr > k:
                ans += 1
                curr = int(d)
        return curr",None,"class Solution:
    def minimumPartition(self, s: str, k: int) -> int:
        curr, ans = 0, 1
        for d in s:
            if int(d) > k:
                return -1
            if curr * 10 > k or (curr * 10 == k and int(d) > k // 10):
                ans += 1
                curr = int(d)
            else:
                curr = curr * 10 + int(d)
        return ans
"
3148,python3,maximum-depth-of-binary-tree,"class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        stack = [[root, 1]]
        res = 0

        while stack:
            node, depth = stack.pop()

            if node:
                res = max(res, depth)
                stack.append([node.left, depth + 1])
                stack.append([node.right, depth])

        return res",None,"class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        stack = [[root, 1]]
        res = 0

        while stack:
            node, depth = stack.pop()

            if node:
                res = max(res, depth)
                stack.append([node.left, depth + 1])
                stack.append([node.right, depth])

        return res
"
3148,python3,maximum-depth-of-binary-tree,"class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        stack = [[root, 1]]
        res = 0

        while stack:
            node, depth = stack.pop()

            if node:
                res = max(res, depth)
                stack.append([node.left, depth + 1])
                stack.append([node.right, depth])

        return res",None,"class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        stack = [[root, 1]]
        res = 0

        while stack:
            node, depth = stack.pop()

            if node:
                res = max(res, depth)
                stack.append([node.right, depth + 1])
                stack.append([node.left, depth + 1])

        return res
"
3148,python3,maximum-depth-of-binary-tree,"class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        stack = [[root, 1]]
        res = 0

        while stack:
            node, depth = stack.pop()

            if node:
                res = max(res, depth)
                stack.append([node.left, depth + 1])
                stack.append([node.right, depth])

        return res",None,"class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        stack = [[root, 1]]
        res = 0

        while stack:
            node, depth = stack.pop()

            if node:
                res = max(res, depth)
                stack.append([node.left, depth + 1])
                stack.append([node.right, depth + 1]) # Increment depth when visiting right child

        return res
"
3149,python3,making-file-names-unique,"from typing import List

class Solution:
    def getFolderNames(self, names: List[str]) -> List[str]:
        ans = []  
        seen = {}

        for name in names:
            if name not in seen:
                ans.append(name)
                seen[name] = 0
            else:
                k = seen[name]
                while True:
                    new_name = name + '(' + str(k) + ')'
                    if new_name not in seen:
                        ans.append(new_name)
                        seen[new_name] = 1
                        break
                    else:
                        k += 1
                seen[name] = k
        return ans",None,"from typing import List

class Solution:
    def getFolderNames(self, names: List[str]) -> List[str]:
        ans = []  
        seen = {}

        for name in names:
            if name not in seen:
                ans.append(name)
                seen[name] = 0
            else:
                k = seen[name]
                new_name = name + '(' + str(k) + ')'
                while new_name in seen:
                    k += 1
                    new_name = name + '(' + str(k) + ')'
                ans.append(new_name)
                seen[new_name] = 1
                seen[name] = k
        return ans
"
3149,python3,making-file-names-unique,"from typing import List

class Solution:
    def getFolderNames(self, names: List[str]) -> List[str]:
        ans = []  
        seen = {}

        for name in names:
            if name not in seen:
                ans.append(name)
                seen[name] = 0
            else:
                k = seen[name]
                while True:
                    new_name = name + '(' + str(k) + ')'
                    if new_name not in seen:
                        ans.append(new_name)
                        seen[new_name] = 1
                        break
                    else:
                        k += 1
                seen[name] = k
        return ans",None,"from typing import List

class Solution:
    def getFolderNames(self, names: List[str]) -> List[str]:
        ans = []  
        seen = {}

        for name in names:
            if name not in seen:
                ans.append(name)
                seen[name] = 0
            else:
                k = seen[name]
                new_name = name + '(' + str(k) + ')'
                while new_name in seen:
                    k += 1
                    new_name = name + '(' + str(k) + ')'
                ans.append(new_name)
                seen[new_name] = 1
                seen[name] = k
        return ans
"
3149,python3,making-file-names-unique,"from typing import List

class Solution:
    def getFolderNames(self, names: List[str]) -> List[str]:
        ans = []  
        seen = {}

        for name in names:
            if name not in seen:
                ans.append(name)
                seen[name] = 0
            else:
                k = seen[name]
                while True:
                    new_name = name + '(' + str(k) + ')'
                    if new_name not in seen:
                        ans.append(new_name)
                        seen[new_name] = 1
                        break
                    else:
                        k += 1
                seen[name] = k
        return ans",None,"from typing import List

class Solution:
    def getFolderNames(self, names: List[str]) -> List[str]:
        ans = []  
        seen = {}

        for name in names:
            if name not in seen:
                ans.append(name)
                seen[name] = 0
            else:
                k = seen[name]
                new_name = name + '(' + str(k) + ')'
                while new_name in seen:
                    k += 1
                    new_name = name + '(' + str(k) + ')'
                ans.append(new_name)
                seen[new_name] = 1
                seen[name] = k
        return ans
"
3150,python3,find-peak-element,"class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        n=len(nums)
        low=0
        high=n
        if n==1:
            return 0
        
        while low<=high:
            mid=(low+high)//2
            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n-1 or nums[mid]>=nums[mid+1]) :
                return mid
            elif nums[mid]<=nums[mid+1]:
                high=mid+1
            else:
                low=mid-1
        return -1",None,"class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 1:
            return 0

        low, high = 0, n - 1
        while low < high:
            mid = (low + high) // 2
            if nums[mid] < nums[mid + 1]:
                low = mid + 1
            else:
                high = mid

        return low
"
3150,python3,find-peak-element,"class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        n=len(nums)
        low=0
        high=n
        if n==1:
            return 0
        
        while low<=high:
            mid=(low+high)//2
            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n-1 or nums[mid]>=nums[mid+1]) :
                return mid
            elif nums[mid]<=nums[mid+1]:
                high=mid+1
            else:
                low=mid-1
        return -1",None,"class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 1:
            return 0

        low, high = 0, n - 1
        while low < high:
            mid = (low + high) // 2
            if nums[mid] < nums[mid + 1]:
                low = mid + 1
            else:
                high = mid

        return low
"
3150,python3,find-peak-element,"class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        n=len(nums)
        low=0
        high=n
        if n==1:
            return 0
        
        while low<=high:
            mid=(low+high)//2
            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n-1 or nums[mid]>=nums[mid+1]) :
                return mid
            elif nums[mid]<=nums[mid+1]:
                high=mid+1
            else:
                low=mid-1
        return -1",None,"class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        n=len(nums)
        low=0
        high=n-1
        if n==1:
            return 0
        
        while low<high:
            mid=(low+high)//2
            if nums[mid]<nums[mid+1]:
                low=mid+1
            else:
                high=mid
        return low
"
3151,python3,longest-cycle-in-a-graph,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        n=len(edges)
        bl=[0]*n
        mp=defaultdict(int)
        mx=-1
        for i in range(n):
            if(bl[i]==0):
                x=i
                l=0
                st=set()
                while x>-1 and bl[x]==0:
                    bl[x]=0
                    mp[x]=l
                    l+=1
                    st.add(x)
                    x=edges[x]
                if(x!=-1 and x in st): mx=max(mx,l-mp[x])
        return mx",None,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        n = len(edges)
        bl = [0] * n
        mp = defaultdict(int)
        mx = -1
        for i in range(n):
            if bl[i] == 0:
                x = i
                l = 0
                st = set()
                while x >= 0 and x < n and bl[x] == 0:
                    bl[x] = 1
                    mp[x] = l
                    l += 1
                    st.add(x)
                    x = edges[x]
                if x >= 0 and x < n and x in st:
                    mx = max(mx, l - mp[x])
        return mx
"
3151,python3,longest-cycle-in-a-graph,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        n=len(edges)
        bl=[0]*n
        mp=defaultdict(int)
        mx=-1
        for i in range(n):
            if(bl[i]==0):
                x=i
                l=0
                st=set()
                while x>-1 and bl[x]==0:
                    bl[x]=0
                    mp[x]=l
                    l+=1
                    st.add(x)
                    x=edges[x]
                if(x!=-1 and x in st): mx=max(mx,l-mp[x])
        return mx",None,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        n = len(edges)
        bl = [0] * n
        mp = defaultdict(int)
        mx = -1
        for i in range(n):
            if not bl[i]:
                x = i
                l = 0
                st = set()
                while x >= 0 and not bl[x]:
                    bl[x] = 1
                    mp[x] = l
                    l += 1
                    st.add(x)
                    x = edges[x]
                if x >= 0 and x in st:
                    mx = max(mx, l - mp[x])
        return mx
"
3151,python3,longest-cycle-in-a-graph,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        n=len(edges)
        bl=[0]*n
        mp=defaultdict(int)
        mx=-1
        for i in range(n):
            if(bl[i]==0):
                x=i
                l=0
                st=set()
                while x>-1 and bl[x]==0:
                    bl[x]=0
                    mp[x]=l
                    l+=1
                    st.add(x)
                    x=edges[x]
                if(x!=-1 and x in st): mx=max(mx,l-mp[x])
        return mx",None,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        n = len(edges)
        bl = [0] * n
        mp = defaultdict(int)
        mx = -1
        for i in range(n):
            if bl[i] == 0:
                x = i
                l = 0
                st = set()
                while x >= 0 and bl[x] == 0:
                    bl[x] = 1
                    mp[x] = l
                    l += 1
                    st.add(x)
                    x = edges[x]
                if x != -1 and x in st:
                    mx = max(mx, l - mp[x])
        return mx
"
3152,python3,best-time-to-buy-and-sell-stock-ii,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) < 2:
            return 0
        if len(prices) == 2:
            output = prices[1] - prices[0]
            return output if output > 0 else 0
        i = 0
        j = 1
        stockBuy = prices[i]
        stockSell = prices[j]
        counter = 0
        profit = 0
        while counter < len(prices)-2:
            if stockSell - stockBuy < 0:
                i = counter + 1
                j = i + 1
            else:
                if prices[j+1] > prices[j]:
                    j += 1
                else:
                    profit = profit + (stockSell - stockBuy)
                    i = counter
                    j = i + 1

            stockSell = prices[j]
            stockBuy = prices[i]
            counter += 1
        if (stockSell - stockBuy) > 0:
            profit = profit + (stockSell - stockBuy)
        return profit",None,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) < 2:
            return 0
        profit = 0
        for i in range(1, len(prices)):
            if prices[i] > prices[i-1]:
                profit += prices[i] - prices[i-1]
        return profit
"
3152,python3,best-time-to-buy-and-sell-stock-ii,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) < 2:
            return 0
        if len(prices) == 2:
            output = prices[1] - prices[0]
            return output if output > 0 else 0
        i = 0
        j = 1
        stockBuy = prices[i]
        stockSell = prices[j]
        counter = 0
        profit = 0
        while counter < len(prices)-2:
            if stockSell - stockBuy < 0:
                i = counter + 1
                j = i + 1
            else:
                if prices[j+1] > prices[j]:
                    j += 1
                else:
                    profit = profit + (stockSell - stockBuy)
                    i = counter
                    j = i + 1

            stockSell = prices[j]
            stockBuy = prices[i]
            counter += 1
        if (stockSell - stockBuy) > 0:
            profit = profit + (stockSell - stockBuy)
        return profit",None,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) < 2:
            return 0
        profit = 0
        for i in range(1, len(prices)):
            if prices[i] > prices[i-1]:
                profit += prices[i] - prices[i-1]
        return profit
"
3152,python3,best-time-to-buy-and-sell-stock-ii,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) < 2:
            return 0
        if len(prices) == 2:
            output = prices[1] - prices[0]
            return output if output > 0 else 0
        i = 0
        j = 1
        stockBuy = prices[i]
        stockSell = prices[j]
        counter = 0
        profit = 0
        while counter < len(prices)-2:
            if stockSell - stockBuy < 0:
                i = counter + 1
                j = i + 1
            else:
                if prices[j+1] > prices[j]:
                    j += 1
                else:
                    profit = profit + (stockSell - stockBuy)
                    i = counter
                    j = i + 1

            stockSell = prices[j]
            stockBuy = prices[i]
            counter += 1
        if (stockSell - stockBuy) > 0:
            profit = profit + (stockSell - stockBuy)
        return profit",None,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) < 2:
            return 0
        profit = 0
        for i in range(1, len(prices)):
            if prices[i] > prices[i-1]:
                profit += prices[i] - prices[i-1]
        return profit
"
3403,python3,last-moment-before-all-ants-fall-out-of-a-plank,"class Solution:
    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:
        return max(max(left, default=0), n - max(right, default=n))",None,"class Solution:
    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:
        left_max = max(left) if left else 0
        right_max = max(right) if right else n
        return max(left_max, right_max)
"
3403,python3,last-moment-before-all-ants-fall-out-of-a-plank,"class Solution:
    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:
        return max(max(left, default=0), n - max(right, default=n))",None,"class Solution:
    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:
        max_left = max(left) if left else 0
        max_right = max(right) if right else n
        min_left = min(left) if left else n
        min_right = min(right) if right else 0

        if min_left >= min_right and max_left <= max_right:
            # All ants are moving towards each other
            return max(max_left, n - min_right)

        if min_left < min_right and max_left > max_right:
            # All ants are moving away from each other
            return max(n - min_left, max_right)

        # Some ants are moving towards each other and some are moving away
        return max(max(left, default=n), n - min(right, default=0))
"
3403,python3,last-moment-before-all-ants-fall-out-of-a-plank,"class Solution:
    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:
        return max(max(left, default=0), n - max(right, default=n))",None,"class Solution:
    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:
        return max(left + [n] if left else [0], [n] if right else [0], default=0)
"
3404,python3,n-th-tribonacci-number,"class Solution:
    def tribonacci(self, n: int) -> int:
        if n==0:return 0
        d=[0]*(3)
        d[0]=0
        d[1]=d[2]=1
        for i in range(3,n+1):
            d.append(sum(d[1:]))
            d.pop(0)
        return d[2]",None,"class Solution:
    def tribonacci(self, n: int) -> int:
        if n==0:return 0
        d=[0,1,1]
        for i in range(3,n+1):
            d.append(sum(d[i-3:i]))
        return d[n]
"
3404,python3,n-th-tribonacci-number,"class Solution:
    def tribonacci(self, n: int) -> int:
        if n==0:return 0
        d=[0]*(3)
        d[0]=0
        d[1]=d[2]=1
        for i in range(3,n+1):
            d.append(sum(d[1:]))
            d.pop(0)
        return d[2]",None,"class Solution:
    def tribonacci(self, n: int) -> int:
        if n==0:return 0
        d=[0,1,1]
        for i in range(3,n+1):
            d.append(d[i-1]+d[i-2]+d[i-3])
        return d[n]
"
3404,python3,n-th-tribonacci-number,"class Solution:
    def tribonacci(self, n: int) -> int:
        if n==0:return 0
        d=[0]*(3)
        d[0]=0
        d[1]=d[2]=1
        for i in range(3,n+1):
            d.append(sum(d[1:]))
            d.pop(0)
        return d[2]",None,"class Solution:
    def tribonacci(self, n: int) -> int:
        if n==0:return 0
        d=[0,1,1]
        for i in range(3,n+1):
            d.append(d[i-1] + d[i-2] + d[i-3])
        return d[n]
"
3405,python3,sort-an-array,"class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        return nums+1",None,"class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        return nums
"
3405,python3,sort-an-array,"class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        return nums+1",None,"class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        return nums
"
3405,python3,sort-an-array,"class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        return nums+1",None,"class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        return nums
"
3406,python3,online-election,"class TopVotedCandidate:

    def __init__(self, persons: List[int], times: List[int]):
        self.persons = []
        self.times = []
        self.dic = collections.defaultdict(int)
        self.m = 0
        self.idx = -1

        for i in range(len(times)):
            self.times.append(times[i])
            self.dic[persons[i]] += 1
            if self.dic[persons[i]] >= self.m:
                self.persons.append(persons[i])
                self.m = self.dic[persons[i]]
            else:
                self.persons.append(self.persons[-1])

    def q(self, t: int) -> int:
        idx = bisect.bisect_right(self.times,t)
        return self.persons[idx]",None,"class TopVotedCandidate:

    def __init__(self, persons: List[int], times: List[int]):
        self.persons = []
        self.times = []
        self.dic = collections.defaultdict(int)
        self.m = 0
        self.idx = 0

        for i in range(len(times)):
            self.times.append(times[i])
            self.dic[persons[i]] += 1
            if self.dic[persons[i]] >= self.m:
                self.persons.append(persons[i])
                self.m = self.dic[persons[i]]
            else:
                self.persons.append(self.persons[-1])

    def q(self, t: int) -> int:
        idx = bisect.bisect_right(self.times,t)
        return self.persons[idx]
"
3406,python3,online-election,"class TopVotedCandidate:

    def __init__(self, persons: List[int], times: List[int]):
        self.persons = []
        self.times = []
        self.dic = collections.defaultdict(int)
        self.m = 0
        self.idx = -1

        for i in range(len(times)):
            self.times.append(times[i])
            self.dic[persons[i]] += 1
            if self.dic[persons[i]] >= self.m:
                self.persons.append(persons[i])
                self.m = self.dic[persons[i]]
            else:
                self.persons.append(self.persons[-1])

    def q(self, t: int) -> int:
        idx = bisect.bisect_right(self.times,t)
        return self.persons[idx]",None,"class TopVotedCandidate:

    def __init__(self, persons: List[int], times: List[int]):
        self.dic = collections.defaultdict(int)
        self.persons = []
        self.times = sorted(zip(times, persons))
        self.dic[self.times[0][1]] += 1
        self.persons.append(self.times[0][1])
        for i in range(1, len(self.times)):
            self.dic[self.times[i][1]] += 1
            if self.dic[self.times[i][1]] > self.dic[self.persons[-1]]:
                self.persons.append(self.times[i][1])
            elif self.dic[self.times[i][1]] == self.dic[self.persons[-1]]:
                self.persons.append(self.times[i][1])

    def q(self, t: int) -> int:
        left, right = 0, len(self.times)
        while left < right:
            mid = left + (right - left) // 2
            if self.times[mid][0] <= t:
                left = mid + 1
            else:
                right = mid
        return self.persons[left - 1]
"
3406,python3,online-election,"class TopVotedCandidate:

    def __init__(self, persons: List[int], times: List[int]):
        self.persons = []
        self.times = []
        self.dic = collections.defaultdict(int)
        self.m = 0
        self.idx = -1

        for i in range(len(times)):
            self.times.append(times[i])
            self.dic[persons[i]] += 1
            if self.dic[persons[i]] >= self.m:
                self.persons.append(persons[i])
                self.m = self.dic[persons[i]]
            else:
                self.persons.append(self.persons[-1])

    def q(self, t: int) -> int:
        idx = bisect.bisect_right(self.times,t)
        return self.persons[idx]",None,"class TopVotedCandidate:

    def __init__(self, persons: List[int], times: List[int]):
        self.dic = collections.defaultdict(int)
        self.leaders = []
        for person, time in zip(persons, times):
            self.dic[person] += 1
            if len(self.leaders) == 0 or self.dic[self.leaders[-1]] <= self.dic[person]:
                self.leaders.append(person)

        self.time_map = {}
        self.time_map[times[0]] = 0
        for i in range(1, len(times)):
            self.time_map[times[i]] = self.leaders[i] if self.dic[self.leaders[i]] > self.dic[self.leaders[i-1]] else self.leaders[i-1]

    def q(self, t: int) -> int:
        if t in self.time_map:
            return self.time_map[t]
        else:
            return self.leaders[-1]
"
3407,python3,arithmetic-slices-ii-subsequence,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        total, n = 0, len(nums)
        dp = [defaultdict(int) for _ in nums]
        for i in range(1, n):
            for j in range(i):
                diff = nums[j] - nums[i]
                dp[i][diff] = dp[j][diff] + 1
                total += dp[j][diff]
        return total",None,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        total, n = 0, len(nums)
        dp = [0] * n
        for i in range(1, n):
            for j in range(i):
                diff = nums[i] - nums[j]
                if diff == nums[i] - nums[j-1] and j > 0:
                    dp[i] += dp[j-1] + 1
                else:
                    dp[i] += dp[j]
        return total
"
3407,python3,arithmetic-slices-ii-subsequence,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        total, n = 0, len(nums)
        dp = [defaultdict(int) for _ in nums]
        for i in range(1, n):
            for j in range(i):
                diff = nums[j] - nums[i]
                dp[i][diff] = dp[j][diff] + 1
                total += dp[j][diff]
        return total",None,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        total, n = 0, len(nums)
        dp = [0] * n
        for i in range(2, n):
            if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:
                dp[i] = dp[i - 1] + 1
                total += dp[i]
        return total
"
3407,python3,arithmetic-slices-ii-subsequence,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        total, n = 0, len(nums)
        dp = [defaultdict(int) for _ in nums]
        for i in range(1, n):
            for j in range(i):
                diff = nums[j] - nums[i]
                dp[i][diff] = dp[j][diff] + 1
                total += dp[j][diff]
        return total",None,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        total, n = 0, len(nums)
        dp = [0] * n
        for i in range(2, n):
            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:
                dp[i] = dp[i-1] + 1
                total += dp[i]
        return total
"
3408,python3,maximize-the-minimum-powered-city,"class Solution:
    def maxPower(self, stations: List[int], r: int, k: int) -> int:
        start, end = min(stations), sum(stations) + k
        while start + 1 < end:
            mid = (start + end) // 2
            if self.check(stations, r, k, mid):
                start = mid
            else:
                end = mid
        if self.check(stations, r, k, end):
            return end
        else:
            return start
    
    def check(self, stations, r, k, target):
            n = len(stations)
            ans = True
            newStations = defaultdict(int)
            power = sum(stations[ : r])
            for i in range(n):
                if i + r < n:
                    power += stations[i + r]
                if i - r - 1 >= 0:
                    power -= stations[i - r - 1]
                if power >= target:
                    continue
                elif power + k < target:
                    ans = False
                    break
                else:
                    diff = target - power
                    power = target
                    stations[min(i + r, n - 1)] -= diff
                    k -= diff
                    newStations[min(i + r, n - 1)] += diff
            for i in newStations:
                stations[i] -= newStations[i]
            return ans",None,"class Solution:
    def maxPower(self, stations: List[int], r: int, k: int) -> int:
        start, end = min(stations), sum(stations) + k
        while start + 1 < end:
            mid = (start + end) // 2
            if self.check(stations, r, k, mid):
                start = mid
            else:
                end = mid
        if self.check(stations, r, k, end):
            return end
        else:
            return start
    
    def check(self, stations, r, k, target):
            n = len(stations)
            newStations = defaultdict(int)
            power = sum(stations[:r+1])
            for i in range(r+1, n):
                power += stations[i] - stations[i-r-1]
                if power >= target:
                    continue
                elif power + k < target:
                    return False
                else:
                    diff = target - power
                    stations[i] -= diff
                    k -= diff
                    newStations[i] += diff
            for i in newStations:
                stations[i] += newStations[i]
            return True
"
3408,python3,maximize-the-minimum-powered-city,"class Solution:
    def maxPower(self, stations: List[int], r: int, k: int) -> int:
        start, end = min(stations), sum(stations) + k
        while start + 1 < end:
            mid = (start + end) // 2
            if self.check(stations, r, k, mid):
                start = mid
            else:
                end = mid
        if self.check(stations, r, k, end):
            return end
        else:
            return start
    
    def check(self, stations, r, k, target):
            n = len(stations)
            ans = True
            newStations = defaultdict(int)
            power = sum(stations[ : r])
            for i in range(n):
                if i + r < n:
                    power += stations[i + r]
                if i - r - 1 >= 0:
                    power -= stations[i - r - 1]
                if power >= target:
                    continue
                elif power + k < target:
                    ans = False
                    break
                else:
                    diff = target - power
                    power = target
                    stations[min(i + r, n - 1)] -= diff
                    k -= diff
                    newStations[min(i + r, n - 1)] += diff
            for i in newStations:
                stations[i] -= newStations[i]
            return ans",None,"class Solution:
    def maxPower(self, stations: List[int], r: int, k: int) -> int:
        start, end = min(stations), sum(stations) + k
        while start + 1 < end:
            mid = (start + end) // 2
            if self.check(stations, r, k, mid):
                start = mid
            else:
                end = mid
        if self.check(stations, r, k, end):
            return end
        else:
            return start
    
    def check(self, stations, r, k, target):
            n = len(stations)
            newStations = defaultdict(int)
            power = sum(stations[ : r])
            for i in range(r, n):
                if power >= target:
                    continue
                elif power + k < target:
                    return False
                else:
                    diff = target - power
                    if i + r < n:
                        newStations[i + r] = min(diff, stations[i + r])
                    else:
                        newStations[n - 1] = min(diff, stations[n - 1])
                    power = target
                    k -= diff
            return power >= target
"
3408,python3,maximize-the-minimum-powered-city,"class Solution:
    def maxPower(self, stations: List[int], r: int, k: int) -> int:
        start, end = min(stations), sum(stations) + k
        while start + 1 < end:
            mid = (start + end) // 2
            if self.check(stations, r, k, mid):
                start = mid
            else:
                end = mid
        if self.check(stations, r, k, end):
            return end
        else:
            return start
    
    def check(self, stations, r, k, target):
            n = len(stations)
            ans = True
            newStations = defaultdict(int)
            power = sum(stations[ : r])
            for i in range(n):
                if i + r < n:
                    power += stations[i + r]
                if i - r - 1 >= 0:
                    power -= stations[i - r - 1]
                if power >= target:
                    continue
                elif power + k < target:
                    ans = False
                    break
                else:
                    diff = target - power
                    power = target
                    stations[min(i + r, n - 1)] -= diff
                    k -= diff
                    newStations[min(i + r, n - 1)] += diff
            for i in newStations:
                stations[i] -= newStations[i]
            return ans",None,"class Solution:
    def maxPower(self, stations: List[int], r: int, k: int) -> int:
        start, end = min(stations), sum(stations) + k
        while start + 1 < end:
            mid = (start + end) // 2
            if self.check(stations, r, k, mid):
                start = mid
            else:
                end = mid
        if self.check(stations, r, k, end):
            return end
        else:
            return start
    
    def check(self, stations, r, k, target):
            n = len(stations)
            ans = True
            newStations = defaultdict(int)
            power = sum(stations[:r+1])
            for i in range(r+1, n):
                power += stations[i] - stations[i-r-1]
                if power >= target:
                    continue
                elif power + k < target:
                    ans = False
                    break
                else:
                    diff = target - power
                    if i + r < n:
                        power += stations[i+r] - stations[i-r-1]
                    else:
                        power += sum(stations[i:])
                    if power >= target:
                        continue
                    else:
                        ans = False
                        break
                    k -= diff
                    newStations[i-r-1] += diff
                    if i + r < n:
                        newStations[i+r] -= diff
            if ans:
                for i, diff in newStations.items():
                    stations[i] += diff
            return ans
"
3409,python3,baseball-game,"class Solution:
    def calPoints(self, operations: List[str]) -> int:
        stack=[]
        for i in operations:
            if i =='D':
                stack.append(2*stack[-1])
            elif i=='C':
                stack.pop()
            elif i=='+':
                stack.append(stack[-1]+stack[-2])
            else:
                stack.append(int(i))
        return sum(stack[0])",None,"class Solution:
    def calPoints(self, operations: List[str]) -> int:
        stack = []
        for i in operations:
            if i == 'D':
                stack.append(stack[-1] * 2)
            elif i == 'C':
                stack.pop()
            elif i == '+':
                stack.append(stack[-1] + stack[-2])
            else:
                stack.append(int(i))
        return sum(stack)
"
3409,python3,baseball-game,"class Solution:
    def calPoints(self, operations: List[str]) -> int:
        stack=[]
        for i in operations:
            if i =='D':
                stack.append(2*stack[-1])
            elif i=='C':
                stack.pop()
            elif i=='+':
                stack.append(stack[-1]+stack[-2])
            else:
                stack.append(int(i))
        return sum(stack[0])",None,"class Solution:
    def calPoints(self, operations: List[str]) -> int:
        stack = []
        for i in operations:
            if i == 'D':
                stack.append(2 * stack[-1])
            elif i == 'C':
                stack.pop()
            elif i == '+':
                stack.append(stack[-1] + stack[-2])
            else:
                stack.append(int(i))
        return sum(stack)
"
3409,python3,baseball-game,"class Solution:
    def calPoints(self, operations: List[str]) -> int:
        stack=[]
        for i in operations:
            if i =='D':
                stack.append(2*stack[-1])
            elif i=='C':
                stack.pop()
            elif i=='+':
                stack.append(stack[-1]+stack[-2])
            else:
                stack.append(int(i))
        return sum(stack[0])",None,"class Solution:
    def calPoints(self, operations: List[str]) -> int:
        stack = []
        for i in operations:
            if i == 'D':
                stack.append(stack[-1] * 2)
            elif i == 'C':
                stack.pop()
            elif i == '+':
                stack.append(stack[-1] + stack[-2])
            else:
                stack.append(int(i))
        return sum(stack)
"
3410,python3,count-anagrams,"mod = 10**9+7

class Solution:
    def countAnagrams(self, s: str) -> int:

        l = s.split()
        ans = 1

        for i in l:
            d = {}
            for j in i:
                if(d.get(j)):
                    d[j] += 2
                else:
                    d[j] = 1  
            
            duplicates = 1
            for j in d.values():
                duplicates *= math.factorial(j)
            curr = math.factorial(len(i))//duplicates

            ans *= curr
            ans = ans%mod

        return ans",None,"mod = 10**9 + 7

class Solution:
    def countAnagrams(self, s: str) -> int:

        l = s.split()
        ans = 1

        for i in l:
            d = {}
            for j in i:
                if(d.get(j)):
                    d[j] += 1
                else:
                    d[j] = 1

            duplicates = 1
            for j in d.values():
                duplicates *= math.factorial(j)
            curr = math.factorial(len(i)) // duplicates

            ans *= curr
            ans = ans % mod

        return ans
"
3410,python3,count-anagrams,"mod = 10**9+7

class Solution:
    def countAnagrams(self, s: str) -> int:

        l = s.split()
        ans = 1

        for i in l:
            d = {}
            for j in i:
                if(d.get(j)):
                    d[j] += 2
                else:
                    d[j] = 1  
            
            duplicates = 1
            for j in d.values():
                duplicates *= math.factorial(j)
            curr = math.factorial(len(i))//duplicates

            ans *= curr
            ans = ans%mod

        return ans",None,"import math
mod = 10**9+7

class Solution:
    def countAnagrams(self, s: str) -> int:

        l = s.split()
        ans = 1

        for i in l:
            d = {}
            for j in i:
                d[j] = 1 + d.get(j, 0)
            
            duplicates = 1
            for j in d.values():
                duplicates *= math.factorial(j)
            curr = math.factorial(len(i))//duplicates

            ans *= curr
            ans = ans%mod

        return ans%mod
"
3410,python3,count-anagrams,"mod = 10**9+7

class Solution:
    def countAnagrams(self, s: str) -> int:

        l = s.split()
        ans = 1

        for i in l:
            d = {}
            for j in i:
                if(d.get(j)):
                    d[j] += 2
                else:
                    d[j] = 1  
            
            duplicates = 1
            for j in d.values():
                duplicates *= math.factorial(j)
            curr = math.factorial(len(i))//duplicates

            ans *= curr
            ans = ans%mod

        return ans",None,"mod = 10**9+7

class Solution:
    def countAnagrams(self, s: str) -> int:

        l = s.split()
        ans = 1

        for i in l:
            d = {}
            for j in i:
                d[j] = 1 + d.get(j, 0)
            
            duplicates = 1
            for j in d.values():
                duplicates *= math.factorial(j)
            curr = math.factorial(len(i))//duplicates

            ans *= curr
            ans = ans%mod

        return ans
"
3411,python3,capitalize-the-title,"class Solution:
    def capitalizeTitle(self, title: str) -> str:
        li = title.split()
        for i,l in enumerate(li):
            if len(l) <= 2:
                li[i] = l.lower()
            else:
                li[i] = l[0].lower() + l[1:].lower()
        return ' '.join(li)",None,"class Solution:
    def capitalizeTitle(self, title: str) -> str:
        li = title.split()
        for i, l in enumerate(li):
            if len(l) > 2:
                li[i] = l[0].upper() + l[1:].lower()
            else:
                li[i] = l.lower()
        return ' '.join(li)
"
3411,python3,capitalize-the-title,"class Solution:
    def capitalizeTitle(self, title: str) -> str:
        li = title.split()
        for i,l in enumerate(li):
            if len(l) <= 2:
                li[i] = l.lower()
            else:
                li[i] = l[0].lower() + l[1:].lower()
        return ' '.join(li)",None,"class Solution:
    def capitalizeTitle(self, title: str) -> str:
        li = title.split()
        for i, l in enumerate(li):
            if len(l) > 2:
                li[i] = l[0].upper() + l[1:].lower()
            else:
                li[i] = l.lower()
        return ' '.join(li)
"
3411,python3,capitalize-the-title,"class Solution:
    def capitalizeTitle(self, title: str) -> str:
        li = title.split()
        for i,l in enumerate(li):
            if len(l) <= 2:
                li[i] = l.lower()
            else:
                li[i] = l[0].lower() + l[1:].lower()
        return ' '.join(li)",None,"class Solution:
    def capitalizeTitle(self, title: str) -> str:
        li = title.split()
        for i, l in enumerate(li):
            if len(l) > 2:
                li[i] = l[0].upper() + l[1:].lower()
            else:
                li[i] = l.lower()
        return ' '.join(li)
"
3412,python3,find-all-possible-recipes-from-given-supplies,"class Solution:
    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:
        dct=defaultdict(lambda :[])
        indegree={}
        n=len(recepies)

        for i in recepies:
            indegree[i]=0

        for i in range(n):
            for j in ingredients[i]:
                indegree[j]=0

        for i in range(n):
            for j in ingredients[i]:
                dct[j].append(recepies[i])
                indegree[recepies[i]]+=1

        st=[]
        for i in indegree:
            if indegree[i]==0:
                st.append(i)
        flst=[]
        ans=defaultdict(lambda :[])
        while st:
            x=st.pop(0)
            for i in dct[x]:
                for j in ans[x]:
                    if j not in ans[i]:
                        ans[i].append(j)
                ans[i].append(x)
                indegree[i]-=1
                if indegree[i]==0:
                    st.append(i)
            if x in recepies:
                for k in ans[x]:
                    if k not in supplies:
                        break
                else:
                    flst.append(x)
                    supplies.append(i)

        return flst",None,"class Solution:
    def findAllRecipes(self, recipes, ingredients, supplies):
        dct = defaultdict(list)
        indegree = {}
        n = len(recipes)

        for i in recipes:
            indegree[i] = 0

        for i in range(n):
            for j in ingredients[i]:
                indegree[j] = 0

        for i in range(n):
            for j in ingredients[i]:
                dct[j].append(recipes[i])
                indegree[recipes[i]] += 1

        st = []
        for i in indegree:
            if indegree[i] == 0:
                st.append(i)
        flst = []

        while st:
            x = st.pop(0)
            if x in recipes:
                flst.append(x)
            for i in dct[x]:
                indegree[i] -= 1
                if indegree[i] == 0:
                    st.append(i)

        return flst
"
3412,python3,find-all-possible-recipes-from-given-supplies,"class Solution:
    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:
        dct=defaultdict(lambda :[])
        indegree={}
        n=len(recepies)

        for i in recepies:
            indegree[i]=0

        for i in range(n):
            for j in ingredients[i]:
                indegree[j]=0

        for i in range(n):
            for j in ingredients[i]:
                dct[j].append(recepies[i])
                indegree[recepies[i]]+=1

        st=[]
        for i in indegree:
            if indegree[i]==0:
                st.append(i)
        flst=[]
        ans=defaultdict(lambda :[])
        while st:
            x=st.pop(0)
            for i in dct[x]:
                for j in ans[x]:
                    if j not in ans[i]:
                        ans[i].append(j)
                ans[i].append(x)
                indegree[i]-=1
                if indegree[i]==0:
                    st.append(i)
            if x in recepies:
                for k in ans[x]:
                    if k not in supplies:
                        break
                else:
                    flst.append(x)
                    supplies.append(i)

        return flst",None,"class Solution:
    def findAllRecipes(self, recipes, ingredients, supplies):
        dct=defaultdict(lambda :[])
        indegree={}
        n=len(recipes)

        for i in range(n):
            indegree[recipes[i]]=0

        for ingredient in ingredients:
            for ingredient_name in ingredient:
                if ingredient_name in recipes:
                    indegree[ingredient_name] += 1

        queue = []
        for recipe, degree in indegree.items():
            if degree == 0:
                queue.append(recipe)

        while queue:
            recipe = queue.pop(0)
            for ingredient in ingredients:
                if recipe in ingredient:
                    for ingredient_name in ingredient:
                        if ingredient_name != recipe:
                            indegree[ingredient_name] -= 1
                            if indegree[ingredient_name] == 0:
                                queue.append(ingredient_name)

            supplies.append(recipe)

        return [recipe for recipe in recipes if recipe in supplies]
"
3412,python3,find-all-possible-recipes-from-given-supplies,"class Solution:
    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:
        dct=defaultdict(lambda :[])
        indegree={}
        n=len(recepies)

        for i in recepies:
            indegree[i]=0

        for i in range(n):
            for j in ingredients[i]:
                indegree[j]=0

        for i in range(n):
            for j in ingredients[i]:
                dct[j].append(recepies[i])
                indegree[recepies[i]]+=1

        st=[]
        for i in indegree:
            if indegree[i]==0:
                st.append(i)
        flst=[]
        ans=defaultdict(lambda :[])
        while st:
            x=st.pop(0)
            for i in dct[x]:
                for j in ans[x]:
                    if j not in ans[i]:
                        ans[i].append(j)
                ans[i].append(x)
                indegree[i]-=1
                if indegree[i]==0:
                    st.append(i)
            if x in recepies:
                for k in ans[x]:
                    if k not in supplies:
                        break
                else:
                    flst.append(x)
                    supplies.append(i)

        return flst",None,"from collections import defaultdict, deque

class Solution:
    def findAllRecipes(self, recipes, ingredients, supplies):
        indegree = {recipe: 0 for recipe in recipes}
        graph = {recipe: [] for recipe in recipes}

        for i, ingre in enumerate(ingredients):
            for ingredient in ingre:
                if ingredient in recipes:
                    indegree[ingredient] += 1
                    graph[ingredient].append(recipes[i])

        queue = deque([recipe for recipe in recipes if recipe not in indegree])
        output = []

        while queue:
            cur = queue.popleft()
            output.append(cur)

            for neighbor in graph[cur]:
                indegree[neighbor] -= 1
                if indegree[neighbor] == 0:
                    queue.append(neighbor)

        for o in output:
            if not all(ing in supplies for ing in ingredients[recipes.index(o)]):
                output.remove(o)

        return output
"
3413,python3,check-whether-two-strings-are-almost-equivalent,"class Solution:
    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:
        A = [0] * 26
        for char in word1: A[ord(char) - ord(""a"")] += 1
        for char in word2: A[ord(char) - ord(""b"")] -= 1
        return not any ([(f < -3 or f > 3) for f in A])",None,"class Solution:
    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:
        A = [0] * 26
        for char in word1: A[ord(char) - ord(""a"")] += 1
        for char in word2: A[ord(char) - ord(""a"")] -= 1
        return not any ([(f < -3 or f > 3) for f in A])
"
3413,python3,check-whether-two-strings-are-almost-equivalent,"class Solution:
    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:
        A = [0] * 26
        for char in word1: A[ord(char) - ord(""a"")] += 1
        for char in word2: A[ord(char) - ord(""b"")] -= 1
        return not any ([(f < -3 or f > 3) for f in A])",None,"class Solution:
    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:
        A = [0] * 26
        for char in word1: A[ord(char) - ord(""a"")] += 1
        for char in word2: A[ord(char) - ord(""a"")] -= 1
        return not any ([(f < -3 or f > 3) for f in A])
"
3413,python3,check-whether-two-strings-are-almost-equivalent,"class Solution:
    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:
        A = [0] * 26
        for char in word1: A[ord(char) - ord(""a"")] += 1
        for char in word2: A[ord(char) - ord(""b"")] -= 1
        return not any ([(f < -3 or f > 3) for f in A])",None,"class Solution:
    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:
        A = [0] * 26
        for char in word1: A[ord(char) - ord(""a"")] += 1
        for char in word2: A[ord(char) - ord(""a"")] -= 1
        return not any ([(f < -3 or f > 3) for f in A])
"
3414,python3,arithmetic-slices-ii-subsequence,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        n = len(nums);ans = 0
        dp = defaultdict(Counter)
        for i in range(1,n):
            for j in range(i):
                d = nums[i] - nums[j]
                dp[i][d] += dp[j][d]
            ans += sum(dp[i].values()) - i
        return ans",None,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        n = len(nums)
        dp = defaultdict(int)
        ans = 0
        for i in range(1, n):
            for j in range(i):
                d = nums[i] - nums[j]
                ans += dp[d]
            dp[nums[i] - nums[i - 1]] += 1
        return ans
"
3414,python3,arithmetic-slices-ii-subsequence,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        n = len(nums);ans = 0
        dp = defaultdict(Counter)
        for i in range(1,n):
            for j in range(i):
                d = nums[i] - nums[j]
                dp[i][d] += dp[j][d]
            ans += sum(dp[i].values()) - i
        return ans",None,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        n = len(nums); ans = 0
        dp = defaultdict(int)
        for i in range(1, n):
            for j in range(i):
                d = nums[i] - nums[j]
                ans += dp[d]
            dp[nums[i] - nums[i - 1]] += 1
        return ans
"
3414,python3,arithmetic-slices-ii-subsequence,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        n = len(nums);ans = 0
        dp = defaultdict(Counter)
        for i in range(1,n):
            for j in range(i):
                d = nums[i] - nums[j]
                dp[i][d] += dp[j][d]
            ans += sum(dp[i].values()) - i
        return ans",None,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        n = len(nums); ans = 0
        dp = defaultdict(int)
        for i in range(1, n):
            for j in range(i):
                d = nums[i] - nums[j]
                ans += dp[d]
            dp[nums[i] - nums[i - 1]] += 1
        return ans
"
3415,python3,maximum-distance-between-a-pair-of-values,"class Solution:
    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:
        def binary(left, right, num):
            farthestPos = 0
            while left < right:
                mid = (left + right) // 2
                if nums2[mid] < num:
                    right = mid
                else:
                    farthestPos = max(farthestPos, mid)
                    left = mid
            if nums2[left] >= num:
                farthestPos = max(farthestPos, left)
            return farthestPos
        maxDiff = 0
        for i in range(min(len(nums1), len(nums2))):
            if nums1[i] > nums2[i]:
                continue
            else:
                j = binary(i, len(nums2)-1, nums1[i])
                maxDiff = max(maxDiff, (j-i))
        return maxDiff",None,"class Solution:
    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:
        def binary(left, right, num):
            farthestPos = 0
            while left < right:
                mid = (left + right) // 2
                if nums2[mid] < num:
                    right = mid
                else:
                    farthestPos = mid
                    left = mid + 1
            if nums2[left] >= num:
                farthestPos = left
            return farthestPos
        maxDiff = 0
        for i in range(min(len(nums1), len(nums2))):
            if nums1[i] > nums2[i]:
                continue
            else:
                j = binary(i, len(nums2), nums1[i])
                maxDiff = max(maxDiff, j-i)
        return maxDiff
"
3415,python3,maximum-distance-between-a-pair-of-values,"class Solution:
    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:
        def binary(left, right, num):
            farthestPos = 0
            while left < right:
                mid = (left + right) // 2
                if nums2[mid] < num:
                    right = mid
                else:
                    farthestPos = max(farthestPos, mid)
                    left = mid
            if nums2[left] >= num:
                farthestPos = max(farthestPos, left)
            return farthestPos
        maxDiff = 0
        for i in range(min(len(nums1), len(nums2))):
            if nums1[i] > nums2[i]:
                continue
            else:
                j = binary(i, len(nums2)-1, nums1[i])
                maxDiff = max(maxDiff, (j-i))
        return maxDiff",None,"class Solution:
    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:
        def binary(left, right, num):
            farthestPos = 0
            while left < right:
                mid = (left + right) // 2
                if nums2[mid] < num:
                    left = mid
                else:
                    farthestPos = mid
            if nums2[farthestPos] >= num:
                return farthestPos
            else:
                return farthestPos + 1
        maxDiff = 0
        for i in range(min(len(nums1), len(nums2))):
            if nums1[i] > nums2[i]:
                continue
            else:
                j = binary(i, len(nums2), nums1[i])
                maxDiff = max(maxDiff, (j-i))
        return maxDiff
"
3415,python3,maximum-distance-between-a-pair-of-values,"class Solution:
    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:
        def binary(left, right, num):
            farthestPos = 0
            while left < right:
                mid = (left + right) // 2
                if nums2[mid] < num:
                    right = mid
                else:
                    farthestPos = max(farthestPos, mid)
                    left = mid
            if nums2[left] >= num:
                farthestPos = max(farthestPos, left)
            return farthestPos
        maxDiff = 0
        for i in range(min(len(nums1), len(nums2))):
            if nums1[i] > nums2[i]:
                continue
            else:
                j = binary(i, len(nums2)-1, nums1[i])
                maxDiff = max(maxDiff, (j-i))
        return maxDiff",None,"class Solution:
    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:
        def binary(left, right, num):
            farthestPos = 0
            while left < right:
                mid = (left + right) // 2
                if nums2[mid] < num:
                    right = mid
                else:
                    farthestPos = mid
                    left = mid + 1
            if nums2[left] >= num:
                farthestPos = left
            return farthestPos
        maxDiff = 0
        for i in range(min(len(nums1), len(nums2))):
            if nums1[i] > nums2[i]:
                continue
            else:
                j = binary(i, len(nums2), nums1[i])
                maxDiff = max(maxDiff, (j-i))
        return maxDiff
"
3416,python3,longest-harmonious-subsequence,"class Solution:
    def findLHS(self, nums: List[int]) -> int:
        result = 0
        count_map = {}
        for num in nums:
            if num not in count_map:
                count_map[num] = 1
            else:
                count_map[num] -= 1
        for num, count in count_map.items():
            if num + 1 in count_map:
                result = max(count + count_map[num + 1], result)
        return result",None,"class Solution:
    def findLHS(self, nums: List[int]) -> int:
        result = 0
        count_map = {}
        for num in nums:
            if num not in count_map:
                count_map[num] = 1
            else:
                count_map[num] += 1
        for num, count in count_map.items():
            if num + 1 in count_map:
                result = max(count + count_map[num + 1], result)
        return result
"
3416,python3,longest-harmonious-subsequence,"class Solution:
    def findLHS(self, nums: List[int]) -> int:
        result = 0
        count_map = {}
        for num in nums:
            if num not in count_map:
                count_map[num] = 1
            else:
                count_map[num] -= 1
        for num, count in count_map.items():
            if num + 1 in count_map:
                result = max(count + count_map[num + 1], result)
        return result",None,"class Solution:
    def findLHS(self, nums: List[int]) -> int:
        result = 0
        count_map = {}
        for num in nums:
            if num not in count_map:
                count_map[num] = 1
            else:
                count_map[num] += 1
        for num, count in count_map.items():
            if num + 1 in count_map:
                result = max(count + count_map[num + 1], result)
        return result
"
3416,python3,longest-harmonious-subsequence,"class Solution:
    def findLHS(self, nums: List[int]) -> int:
        result = 0
        count_map = {}
        for num in nums:
            if num not in count_map:
                count_map[num] = 1
            else:
                count_map[num] -= 1
        for num, count in count_map.items():
            if num + 1 in count_map:
                result = max(count + count_map[num + 1], result)
        return result",None,"class Solution:
    def findLHS(self, nums: List[int]) -> int:
        result = 0
        count_map = {}
        for num in nums:
            if num not in count_map:
                count_map[num] = 1
            else:
                count_map[num] += 1
        for num, count in count_map.items():
            if num + 1 in count_map:
                result = max(count + count_map[num + 1], result)
        return result
"
3417,python3,longest-repeating-character-replacement,"class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        left = right = 0
        max_len = 0
        count = collections.Counter()
        for right in range(1, len(s) + 1):
            count[s[right - 1]] += 1

            most = count.most_common()[0][1]

            remain = right - left - most
            
            if remain > k: 
                count[s[left]] -= 1
                left -= 1
                
            max_len = max(right - left, max_len)

        return max_len",None,"class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        left = right = 0
        max_len = 0
        count = collections.Counter()
        for right in range(len(s)):
            count[s[right]] += 1

            most = count.most_common(1)[0][1]

            remain = right - left + 1 - most
            
            if remain > k: 
                count[s[left]] -= 1
                left += 1

            max_len = max(max_len, right - left + 1)

        return max_len
"
3417,python3,longest-repeating-character-replacement,"class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        left = right = 0
        max_len = 0
        count = collections.Counter()
        for right in range(1, len(s) + 1):
            count[s[right - 1]] += 1

            most = count.most_common()[0][1]

            remain = right - left - most
            
            if remain > k: 
                count[s[left]] -= 1
                left -= 1
                
            max_len = max(right - left, max_len)

        return max_len",None,"class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        left = right = 0
        max_len = 0
        count = collections.Counter()
        for right in range(len(s)):
            count[s[right]] += 1

            most = count.most_common(1)[0][1]

            remain = right - left - most
            if remain > k: 
                count[s[left]] -= 1
                left += 1

            max_len = max(max_len, right - left + 1)

        return max_len
"
3417,python3,longest-repeating-character-replacement,"class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        left = right = 0
        max_len = 0
        count = collections.Counter()
        for right in range(1, len(s) + 1):
            count[s[right - 1]] += 1

            most = count.most_common()[0][1]

            remain = right - left - most
            
            if remain > k: 
                count[s[left]] -= 1
                left -= 1
                
            max_len = max(right - left, max_len)

        return max_len",None,"class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        left = right = 0
        max_len = 0
        count = collections.Counter()
        for right in range(len(s)):
            count[s[right]] += 1

            most = count.most_common(1)[0][1]

            remain = right - left - most
            
            if remain > k: 
                count[s[left]] -= 1
                left += 1
                
            max_len = max(right - left + 1, max_len)

        return max_len
"
3418,python3,adding-two-negabinary-numbers,"class Solution:
    def addBinary(self, A, B):
        res = []
        carry = 0
        while A or B or carry:
            carry += (A or [0]).pop(0) + (B or [0]).pop(0)
            res.append(carry & 1)
            carry = carry >> 1
        return res[::-1]

    def addNegabinary(self, A, B):
        res = []
        carry = 0
        while A or B or carry:
            carry += (A or [0]).pop(0) + (B or [0]).pop(0)
            res.append(carry & 1)
            carry = -(carry >> 1)
        while len(res) > 1 and res[-1] == 0:
            res.pop()
        return res[::-1]",None,"class Solution:
    def addBinary(self, A, B):
        res = []
        carry = 0
        while A or B or carry:
            carry += (A or [0]).pop() + (B or [0]).pop()
            res.append(carry & 1)
            carry = carry >> 1
        return res[::-1]

    def addNegabinary(self, A, B):
        res = []
        carry = 0
        while A or B or carry:
            carry += (A or [0]).pop() + (B or [0]).pop()
            res.append(carry & 1)
            carry = -(carry >> 1)
        while len(res) > 1 and res[-1] == 0:
            res.pop()
        return res[::-1]
"
3418,python3,adding-two-negabinary-numbers,"class Solution:
    def addBinary(self, A, B):
        res = []
        carry = 0
        while A or B or carry:
            carry += (A or [0]).pop(0) + (B or [0]).pop(0)
            res.append(carry & 1)
            carry = carry >> 1
        return res[::-1]

    def addNegabinary(self, A, B):
        res = []
        carry = 0
        while A or B or carry:
            carry += (A or [0]).pop(0) + (B or [0]).pop(0)
            res.append(carry & 1)
            carry = -(carry >> 1)
        while len(res) > 1 and res[-1] == 0:
            res.pop()
        return res[::-1]",None,"class Solution:
    def addBinary(self, A, B):
        res = []
        carry = 0
        while A or B or carry:
            carry += (A or [0])[-1] + (B or [0])[-1]
            res.append(carry & 1)
            carry = carry >> 1
        return res[::-1]

    def addNegabinary(self, A, B):
        res = []
        carry = 0
        while A or B or carry:
            carry += (A or [0])[-1] + (B or [0])[-1]
            res.append(carry & 1)
            carry = -(carry >> 1)
        while len(res) > 1 and res[-1] == 0:
            res.pop()
        return res[::-1]
"
3418,python3,adding-two-negabinary-numbers,"class Solution:
    def addBinary(self, A, B):
        res = []
        carry = 0
        while A or B or carry:
            carry += (A or [0]).pop(0) + (B or [0]).pop(0)
            res.append(carry & 1)
            carry = carry >> 1
        return res[::-1]

    def addNegabinary(self, A, B):
        res = []
        carry = 0
        while A or B or carry:
            carry += (A or [0]).pop(0) + (B or [0]).pop(0)
            res.append(carry & 1)
            carry = -(carry >> 1)
        while len(res) > 1 and res[-1] == 0:
            res.pop()
        return res[::-1]",None,"class Solution:
    def addBinary(self, A, B):
        res = []
        carry = 0
        while A or B or carry:
            carry += (A or [0])[-1] + (B or [0])[-1]
            res.append(carry & 1)
            carry = carry >> 1
        return res[::-1]

    def addNegabinary(self, A, B):
        res = []
        carry = 0
        while A or B or carry:
            carry += (A or [0])[-1] + (B or [0])[-1]
            res.append(carry & 1)
            carry = -(carry >> 1)
        while len(res) > 1 and res[-1] == 0:
            res.pop()
        return res[::-1]
"
3419,python3,frog-position-after-t-seconds,"class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        nei = collections.defaultdict(set)
        for a, b in edges:
            nei[a].add(b)
            nei[b].add(a)
            
        visited, res = set(), 0.
        def dfs(leaf_id, p, time):
            nonlocal res
            if time >= t:
                if leaf_id == target: res = p
                return
            visited.add(leaf_id)
            neighbors = nei[leaf_id] - visited
            for n in neighbors or [leaf_id]:
                dfs(n, p / (len(neighbors) or 1), time + 1)
        dfs(1, 1, 0)
        return res*2",None,"class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        nei = collections.defaultdict(set)
        for a, b in edges:
            nei[a].add(b)
            nei[b].add(a)
            
        visited, res = set(), 0.
        def dfs(leaf_id, p, time):
            nonlocal res
            if time >= t:
                if leaf_id == target: res = p
                return
            visited.add(leaf_id)
            neighbors = nei[leaf_id] - visited
            for n in neighbors:
                dfs(n, p / len(neighbors), time + 1)
        dfs(1, 1, 0)
        return res
"
3419,python3,frog-position-after-t-seconds,"class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        nei = collections.defaultdict(set)
        for a, b in edges:
            nei[a].add(b)
            nei[b].add(a)
            
        visited, res = set(), 0.
        def dfs(leaf_id, p, time):
            nonlocal res
            if time >= t:
                if leaf_id == target: res = p
                return
            visited.add(leaf_id)
            neighbors = nei[leaf_id] - visited
            for n in neighbors or [leaf_id]:
                dfs(n, p / (len(neighbors) or 1), time + 1)
        dfs(1, 1, 0)
        return res*2",None,"class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        nei = collections.defaultdict(set)
        for a, b in edges:
            nei[a].add(b)
            nei[b].add(a)
            
        visited, res = set(), 0.
        def dfs(leaf_id, p, time):
            nonlocal res
            if time >= t:
                if leaf_id == target: res = p
                return
            visited.add(leaf_id)
            neighbors = nei[leaf_id] - visited
            for n in neighbors:
                dfs(n, p / len(neighbors), time + 1)
        dfs(1, 1, 0)
        return res
"
3419,python3,frog-position-after-t-seconds,"class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        nei = collections.defaultdict(set)
        for a, b in edges:
            nei[a].add(b)
            nei[b].add(a)
            
        visited, res = set(), 0.
        def dfs(leaf_id, p, time):
            nonlocal res
            if time >= t:
                if leaf_id == target: res = p
                return
            visited.add(leaf_id)
            neighbors = nei[leaf_id] - visited
            for n in neighbors or [leaf_id]:
                dfs(n, p / (len(neighbors) or 1), time + 1)
        dfs(1, 1, 0)
        return res*2",None,"class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        nei = collections.defaultdict(list)
        for a, b in edges:
            nei[a].append(b)
            nei[b].append(a)
        
        visited, res = set(), 0.
        def dfs(leaf_id, p, time):
            nonlocal res
            if time >= t:
                if leaf_id == target: res = p
                return
            visited.add(leaf_id)
            for n in nei[leaf_id]:
                if n not in visited:
                    dfs(n, p / (len(neighbors) or 1), time + 1)
        dfs(1, 1, 0)
        return res
"
3420,python3,minimum-number-of-steps-to-make-two-strings-anagram-ii,"class Solution:
    def minSteps(self, s: str, t: str) -> int:
        cnt1=Counter(s)
        cnt2=Counter(t)
        sm=0
        cnt=cnt1+cnt2
        for i in cnt.values():
            sm+=i
        return sm",None,"class Solution:
    def minSteps(self, s: str, t: str) -> int:
        cnt1 = Counter(s)
        cnt2 = Counter(t)
        sm = 0
        for key in cnt1.keys() | cnt2.keys():
            sm += abs(cnt1[key] - cnt2[key])
        return sm
"
3420,python3,minimum-number-of-steps-to-make-two-strings-anagram-ii,"class Solution:
    def minSteps(self, s: str, t: str) -> int:
        cnt1=Counter(s)
        cnt2=Counter(t)
        sm=0
        cnt=cnt1+cnt2
        for i in cnt.values():
            sm+=i
        return sm",None,"class Solution:
    def minSteps(self, s: str, t: str) -> int:
        cnt1 = Counter(s)
        cnt2 = Counter(t)
        sm = 0
        for key in cnt1.keys() | cnt2.keys():
            sm += max(cnt1[key], cnt2[key]) - min(cnt1.get(key, 0), cnt2.get(key, 0))
        return sm
"
3420,python3,minimum-number-of-steps-to-make-two-strings-anagram-ii,"class Solution:
    def minSteps(self, s: str, t: str) -> int:
        cnt1=Counter(s)
        cnt2=Counter(t)
        sm=0
        cnt=cnt1+cnt2
        for i in cnt.values():
            sm+=i
        return sm",None,"class Solution:
    def minSteps(self, s: str, t: str) -> int:
        cnt1=Counter(s)
        cnt2=Counter(t)
        sm=0
        for key in cnt1.keys():
            sm += abs(cnt1[key] - cnt2.get(key, 0))
        return sm
"
3421,python3,lexicographically-smallest-string-after-substring-operation,"class Solution:
    def smallestString(self, s: str) -> str:
        
        if len(check:=set(s))==1 and check != {'a'}: 
            return chr(ord(s[0])-1)*(len(s))
        contiguous,change,ct1,ct2 = True,False,0,0

        for i in s:
            if i == 'a':ct1+=1                                                  
            else:break
        ans='' + 'a' * ct1
        s = s[ct1:]
     
        for cha in s:
            ct2+=1
            if cha != 'a':
                ans+=chr(ord(cha)-2)
                change=True
                continue
            else:
                ans+=cha
                if change:
                    contiguous = False
            if not contiguous:
                break
        return ans+s[ct2:] if change else ans[:-1]+'z'",None,"class Solution:
    def smallestString(self, s: str) -> str:
        if len(set(s)) == 1 and set(s) != {'a'}:
            return 'z' * len(s)
        ans = ''
        contiguous = True
        for i in s:
            if i != 'a':
                contiguous = False
            ans += chr(ord(i) - 1 if i != 'a' else ord(i))
        return ans if contiguous else ans[:-1] + 'z'
"
3421,python3,lexicographically-smallest-string-after-substring-operation,"class Solution:
    def smallestString(self, s: str) -> str:
        
        if len(check:=set(s))==1 and check != {'a'}: 
            return chr(ord(s[0])-1)*(len(s))
        contiguous,change,ct1,ct2 = True,False,0,0

        for i in s:
            if i == 'a':ct1+=1                                                  
            else:break
        ans='' + 'a' * ct1
        s = s[ct1:]
     
        for cha in s:
            ct2+=1
            if cha != 'a':
                ans+=chr(ord(cha)-2)
                change=True
                continue
            else:
                ans+=cha
                if change:
                    contiguous = False
            if not contiguous:
                break
        return ans+s[ct2:] if change else ans[:-1]+'z'",None,"class Solution:
    def smallestString(self, s: str) -> str:
        if len(set(s)) == 1 and set(s) != {'a'}:
            return 'a' * len(s)
        contiguous = True
        ans = ''
        prev_char = None
        for char in s:
            if char == 'a':
                ans += 'a'
                continue
            if prev_char is not None and ord(char) - ord(prev_char) > 1:
                contiguous = False
            if prev_char is not None and ord(char) - ord(prev_char) == 1:
                ans += chr(ord(char) - 2)
            else:
                ans += 'a'
            prev_char = char
        if contiguous:
            return ans + s[len(ans):]
        else:
            return ans + s[len(ans) - 1:]
"
3421,python3,lexicographically-smallest-string-after-substring-operation,"class Solution:
    def smallestString(self, s: str) -> str:
        
        if len(check:=set(s))==1 and check != {'a'}: 
            return chr(ord(s[0])-1)*(len(s))
        contiguous,change,ct1,ct2 = True,False,0,0

        for i in s:
            if i == 'a':ct1+=1                                                  
            else:break
        ans='' + 'a' * ct1
        s = s[ct1:]
     
        for cha in s:
            ct2+=1
            if cha != 'a':
                ans+=chr(ord(cha)-2)
                change=True
                continue
            else:
                ans+=cha
                if change:
                    contiguous = False
            if not contiguous:
                break
        return ans+s[ct2:] if change else ans[:-1]+'z'",None,"class Solution:
    def smallestString(self, s: str) -> str:
        
        if len(set(s))==1 and set(s) != {'a'}: 
            return 'a'*(len(s))
        contiguous,change,ct1,ct2 = True,False,0,0

        for i in s:
            if i == 'a':ct1+=1                                                  
            else:break
        ans='' + 'a' * ct1
        s = s[ct1:]
     
        for cha in s:
            ct2+=1
            if cha != 'a':
                ans+=chr(ord(cha)-1)
                change=True
                continue
            else:
                ans+=cha
                if change:
                    contiguous = False
            if not contiguous:
                break
        return ans+s[ct2:] if change else ans
"
3422,python3,next-greater-element-i,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        l = []
        for i in nums1:
            count=0
            for j in nums2:
                if i==j:
                    for k in range(nums2.index(j)+1,len(nums2)):
                        if nums2[k]>j:
                            count+=1
                            l.append(nums2[k])
                            break
                    if count==0:
                        l.append(j)
        return (l)",None,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        l = [-1] * len(nums1)
        stack = []
        for i in nums2:
            while stack and stack[-1] < i:
                top = stack.pop()
                for j in range(len(nums1)):
                    if nums1[j] == top:
                        l[j] = i
            stack.append(i)
        return l
"
3422,python3,next-greater-element-i,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        l = []
        for i in nums1:
            count=0
            for j in nums2:
                if i==j:
                    for k in range(nums2.index(j)+1,len(nums2)):
                        if nums2[k]>j:
                            count+=1
                            l.append(nums2[k])
                            break
                    if count==0:
                        l.append(j)
        return (l)",None,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        l = [-1] * len(nums1)
        stack = []
        num_map = {num: i for i, num in enumerate(nums1)}
        for i, num in enumerate(nums2):
            while stack and stack[-1] < num:
                top = stack.pop()
                idx = num_map.get(top)
                if idx is not None:
                    l[idx] = num
            stack.append(num)
        return l
"
3422,python3,next-greater-element-i,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        l = []
        for i in nums1:
            count=0
            for j in nums2:
                if i==j:
                    for k in range(nums2.index(j)+1,len(nums2)):
                        if nums2[k]>j:
                            count+=1
                            l.append(nums2[k])
                            break
                    if count==0:
                        l.append(j)
        return (l)",None,"class Solution:
    def nextGreaterElement(self, nums1, nums2):
        next_greater = [-1] * len(nums1)
        stack = []

        for num in nums2:
            while stack and stack[-1] < num:
                top = stack.pop()
                for i, val in enumerate(nums1):
                    if val == top:
                        next_greater[i] = num

            stack.append(num)

        return next_greater
"
3423,python3,count-good-numbers,"class Solution:
    def countGoodNumbers(self, n: int) -> int:
        return (pow(5,(n - 1)//2,1000000007)*pow(4,n//2,1000000007))%1000000007",None,"class Solution:
    def countGoodNumbers(self, n: int) -> int:
        if n % 2 == 1:
            return 5 * pow(4, (n - 1) // 2, 1000000007) % 1000000007
        else:
            return pow(4, n // 2, 1000000007)
"
3423,python3,count-good-numbers,"class Solution:
    def countGoodNumbers(self, n: int) -> int:
        return (pow(5,(n - 1)//2,1000000007)*pow(4,n//2,1000000007))%1000000007",None,"class Solution:
    def countGoodNumbers(self, n: int) -> int:
        if n % 2 == 1:
            return 5 * pow(4, (n - 1) // 2, 1000000007) % 1000000007
        else:
            return pow(4, n // 2, 1000000007)
"
3423,python3,count-good-numbers,"class Solution:
    def countGoodNumbers(self, n: int) -> int:
        return (pow(5,(n - 1)//2,1000000007)*pow(4,n//2,1000000007))%1000000007",None,"class Solution:
    def countGoodNumbers(self, n: int) -> int:
        if n % 2 == 1:
            return 5 * pow(4, (n - 1) // 2, 1000000007) % 1000000007
        else:
            return pow(4, n // 2, 1000000007) % 1000000007
"
3424,python3,reverse-bits,"class Solution:
    def f(self,n,r,count):
        if n<1:return r<<(32-count)
        return self.f(n<<1,(r<<1)|(n&1),count+1)
    def reverseBits(self, n: int) -> int:return self.f(n,0,0)",None,"class Solution:
    def f(self, n, r, count):
        if n == 0:
            return r << (32 - count)
        else:
            return self.f(n >> 1, (r << 1) | (n & 1), count + 1)

    def reverseBits(self, n: int) -> int:
        return self.f(n, 0, 0)
"
3424,python3,reverse-bits,"class Solution:
    def f(self,n,r,count):
        if n<1:return r<<(32-count)
        return self.f(n<<1,(r<<1)|(n&1),count+1)
    def reverseBits(self, n: int) -> int:return self.f(n,0,0)",None,"class Solution:
    def reverseBits(self, n: int) -> int:
        def f(n, r, count):
            if n < 1:
                return r << (32 - count)
            return f(n >> 1, (r << 1) | (n & 1), count + 1)

        return f(n, 0, 0)
"
3424,python3,reverse-bits,"class Solution:
    def f(self,n,r,count):
        if n<1:return r<<(32-count)
        return self.f(n<<1,(r<<1)|(n&1),count+1)
    def reverseBits(self, n: int) -> int:return self.f(n,0,0)",None,"class Solution:
    def reverseBits(self, n: int) -> int:
        return self.f(n, 0, 32)

    def f(self, n, r, count):
        if n == 0:
            return r
        return self.f(n >> 1, (r << 1) | (n & 1), count - 1)
"
3425,python3,alternating-digit-sum,"class Solution:
    def alternateDigitSum(self, n: int) -> int:
        count=0
        n=str(n)
        for i in range(len(n)):
            if i%2==0:
                count+=int(n[i])
            else:
                count+=int(n[i])
        return count",None,"class Solution:
    def alternateDigitSum(self, n: int) -> int:
        count = 0
        n = str(n)
        for i in range(len(n)):
            if i % 2 == 0:
                count += int(n[i])
            else:
                count -= int(n[i])
        return count
"
3425,python3,alternating-digit-sum,"class Solution:
    def alternateDigitSum(self, n: int) -> int:
        count=0
        n=str(n)
        for i in range(len(n)):
            if i%2==0:
                count+=int(n[i])
            else:
                count+=int(n[i])
        return count",None,"class Solution:
    def alternateDigitSum(self, n: int) -> int:
        count = 0
        n = str(n)
        prev_sign = 1
        for i in range(len(n)):
            count += prev_sign * int(n[i])
            prev_sign = -prev_sign
        return count
"
3425,python3,alternating-digit-sum,"class Solution:
    def alternateDigitSum(self, n: int) -> int:
        count=0
        n=str(n)
        for i in range(len(n)):
            if i%2==0:
                count+=int(n[i])
            else:
                count+=int(n[i])
        return count",None,"class Solution:
    def alternateDigitSum(self, n: int) -> int:
        count = 0
        n = str(n)
        for i in range(len(n)):
            if i % 2 == 0:
                count += int(n[i])
            else:
                count -= int(n[i])
        return count
"
3426,python3,length-of-the-longest-valid-substring,"class Solution:
    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:
        trie = {}
        for f in forbidden:
            t = trie
            for c in f:
                if c not in t:
                    t[c] = {}
                t = t[c]
            t[""end""] = True
        
        def isForbidden(s):
            t = trie
            counter = 0
            for c in s:
                if c not in t:
                    return False
                t = t[c]
                counter += 1
                if ""end"" in t:
                    return counter
            return False
        
        res = 0
        j = len(word)
        for i in range(len(word) - 1, -1, -1):
            truc = isForbidden(word[i:j])
            if truc:
                j = i - truc - 1
            res = max(res, j - i)
        return res",None,"class Solution:
    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:
        trie = {}
        for f in forbidden:
            t = trie
            for c in f:
                if c not in t:
                    t[c] = {}
                t = t[c]
            t[""end""] = True
        
        def isForbidden(s):
            t = trie
            counter = 0
            for c in s:
                if c not in t:
                    return False
                t = t[c]
                counter += 1
                if ""end"" in t:
                    return True
            return False
        
        res = 0
        j = len(word)
        for i in range(len(word) - 1, -1, -1):
            if not isForbidden(word[i:j]):
                res = max(res, j - i)
            j = i
        return res
"
3426,python3,length-of-the-longest-valid-substring,"class Solution:
    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:
        trie = {}
        for f in forbidden:
            t = trie
            for c in f:
                if c not in t:
                    t[c] = {}
                t = t[c]
            t[""end""] = True
        
        def isForbidden(s):
            t = trie
            counter = 0
            for c in s:
                if c not in t:
                    return False
                t = t[c]
                counter += 1
                if ""end"" in t:
                    return counter
            return False
        
        res = 0
        j = len(word)
        for i in range(len(word) - 1, -1, -1):
            truc = isForbidden(word[i:j])
            if truc:
                j = i - truc - 1
            res = max(res, j - i)
        return res",None,"class Solution:
    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:
        trie = {}
        for f in forbidden:
            t = trie
            for c in f:
                if c not in t:
                    t[c] = {}
                t = t[c]
            t[""end""] = True
        
        def isForbidden(s):
            t = trie
            counter = 0
            for c in s:
                if c not in t:
                    return False
                t = t[c]
                counter += 1
                if ""end"" in t:
                    return True
            return False
        
        res = 0
        j = len(word)
        for i in range(len(word) - 1, -1, -1):
            if not isForbidden(word[i:j]):
                res = max(res, j - i)
            j = i - 1
        return res
"
3426,python3,length-of-the-longest-valid-substring,"class Solution:
    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:
        trie = {}
        for f in forbidden:
            t = trie
            for c in f:
                if c not in t:
                    t[c] = {}
                t = t[c]
            t[""end""] = True
        
        def isForbidden(s):
            t = trie
            counter = 0
            for c in s:
                if c not in t:
                    return False
                t = t[c]
                counter += 1
                if ""end"" in t:
                    return counter
            return False
        
        res = 0
        j = len(word)
        for i in range(len(word) - 1, -1, -1):
            truc = isForbidden(word[i:j])
            if truc:
                j = i - truc - 1
            res = max(res, j - i)
        return res",None,"class Solution:
    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:
        trie = {}
        for f in forbidden:
            t = trie
            for c in f:
                if c not in t:
                    t[c] = {}
                t = t[c]
            t[""end""] = True
        
        def isForbidden(s):
            t = trie
            counter = 0
            for c in s:
                if c not in t:
                    return False
                t = t[c]
                counter += 1
                if ""end"" in t:
                    return True
            return False
        
        res = 0
        j = len(word)
        for i in range(len(word) - 1, -1, -1):
            truc = isForbidden(word[i:j])
            if truc:
                j = i - 1
            else:
                j = i - 1 + (j - i - 1) // (len(word) - i)
            res = max(res, j - i)
        return res
"
3427,python3,minimum-subsequence-in-non-increasing-order,"class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        total = sum(nums)
        nums.sort(reverse = True)
        sub_sum, sub_seq = 0, []
        for x in nums:
            sub_sum += x
            sub_seq.append(x)
            if sub_sum > total:
                return sub_seq
            sub_sum -= x",None,"class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        nums.sort(reverse = True)
        sub_seq = []
        total = sum(nums)
        sub_sum = 0
        for x in nums:
            sub_sum += x
            sub_seq.append(x)
            if sub_sum > total:
                break
            total -= x
        return sub_seq
"
3427,python3,minimum-subsequence-in-non-increasing-order,"class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        total = sum(nums)
        nums.sort(reverse = True)
        sub_sum, sub_seq = 0, []
        for x in nums:
            sub_sum += x
            sub_seq.append(x)
            if sub_sum > total:
                return sub_seq
            sub_sum -= x",None,"class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        total = sum(nums)
        nums.sort(reverse = True)
        sub_sum, sub_seq = 0, []
        for x in nums:
            sub_sum += x
            sub_seq.append(x)
            if sub_sum > total:
                break
            sub_sum -= x
        return sub_seq
"
3427,python3,minimum-subsequence-in-non-increasing-order,"class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        total = sum(nums)
        nums.sort(reverse = True)
        sub_sum, sub_seq = 0, []
        for x in nums:
            sub_sum += x
            sub_seq.append(x)
            if sub_sum > total:
                return sub_seq
            sub_sum -= x",None,"class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        nums.sort(reverse = True)
        total = sum(nums)
        sub_sum, sub_seq = 0, []
        for x in nums:
            sub_sum += x
            sub_seq.append(x)
            if sub_sum > total:
                return sub_seq
        return sub_seq
"
3428,python3,kth-largest-element-in-an-array,"class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return sorted(nums)[-k-1]",None,"class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return sorted(nums, reverse=True)[k-1]
"
3428,python3,kth-largest-element-in-an-array,"class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return sorted(nums)[-k-1]",None,"class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return sorted(nums, reverse=True)[k-1]
"
3428,python3,kth-largest-element-in-an-array,"class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return sorted(nums)[-k-1]",None,"class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return sorted(nums, reverse=True)[k-1]
"
3429,python3,maximize-number-of-nice-divisors,"class Solution:
    def maxNiceDivisors(self, primeFactors: int) -> int:
        if primeFactors <= 3:
            return primeFactors
        
        MOD = int(1e9 + 7)
        if primeFactors % 3 == 0:
            power = primeFactors // 3
            return self.calculateNiceDivisors(3, power, MOD) * 2
        elif primeFactors % 3 == 1:
            power = (primeFactors // 3) - 1
            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD
        else:
            power = primeFactors // 3
            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD
    
    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:
        if power == 0:
            return 1

        result = self.calculateNiceDivisors(base, power // 2, MOD)
        result = (result * result) % MOD

        if power % 2 == 1:
            result = (result * base) % MOD

        return result",None,"class Solution:
    def maxNiceDivisors(self, primeFactors: int) -> int:
        if primeFactors <= 3:
            return primeFactors
        
        MOD = int(1e9 + 7)
        if primeFactors % 3 == 0:
            power = primeFactors // 3
            return self.calculateNiceDivisors(3, power, MOD)
        elif primeFactors % 3 == 1:
            power = (primeFactors - 1) // 3
            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD
        else:
            power = primeFactors // 3
            return self.calculateNiceDivisors(3, power, MOD) * 2
    
    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:
        if power == 0:
            return 1

        result = self.calculateNiceDivisors(base, power // 2, MOD)
        result = (result * result) % MOD

        if power % 2 == 1:
            result = (result * base) % MOD

        return result
"
3429,python3,maximize-number-of-nice-divisors,"class Solution:
    def maxNiceDivisors(self, primeFactors: int) -> int:
        if primeFactors <= 3:
            return primeFactors
        
        MOD = int(1e9 + 7)
        if primeFactors % 3 == 0:
            power = primeFactors // 3
            return self.calculateNiceDivisors(3, power, MOD) * 2
        elif primeFactors % 3 == 1:
            power = (primeFactors // 3) - 1
            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD
        else:
            power = primeFactors // 3
            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD
    
    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:
        if power == 0:
            return 1

        result = self.calculateNiceDivisors(base, power // 2, MOD)
        result = (result * result) % MOD

        if power % 2 == 1:
            result = (result * base) % MOD

        return result",None,"class Solution:
    def maxNiceDivisors(self, primeFactors: int) -> int:
        if primeFactors <= 3:
            return primeFactors
        
        MOD = int(1e9 + 7)
        if primeFactors % 3 == 0:
            power = primeFactors // 3
            return self.calculateNiceDivisors(3, power, MOD)
        elif primeFactors % 3 == 1:
            power = (primeFactors // 3) - 1
            return self.calculateNiceDivisors(3, power, MOD) * 4
        else:
            power = primeFactors // 3
            return self.calculateNiceDivisors(3, power, MOD) * 2
    
    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:
        if power == 0:
            return 1

        result = self.calculateNiceDivisors(base, power // 2, MOD)
        result = (result * result) % MOD

        if power % 2 == 1:
            result = (result * base) % MOD

        return result % MOD
"
3429,python3,maximize-number-of-nice-divisors,"class Solution:
    def maxNiceDivisors(self, primeFactors: int) -> int:
        if primeFactors <= 3:
            return primeFactors
        
        MOD = int(1e9 + 7)
        if primeFactors % 3 == 0:
            power = primeFactors // 3
            return self.calculateNiceDivisors(3, power, MOD) * 2
        elif primeFactors % 3 == 1:
            power = (primeFactors // 3) - 1
            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD
        else:
            power = primeFactors // 3
            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD
    
    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:
        if power == 0:
            return 1

        result = self.calculateNiceDivisors(base, power // 2, MOD)
        result = (result * result) % MOD

        if power % 2 == 1:
            result = (result * base) % MOD

        return result",None,"class Solution:
    def maxNiceDivisors(self, primeFactors: int) -> int:
        if primeFactors <= 3:
            return primeFactors
        
        MOD = int(1e9 + 7)
        if primeFactors % 3 == 0:
            power = primeFactors // 3
            return self.calculateNiceDivisors(3, power, MOD)
        elif primeFactors % 3 == 1:
            power = (primeFactors // 3) - 1
            return self.calculateNiceDivisors(3, power, MOD) * 4
        else:
            power = primeFactors // 3
            return self.calculateNiceDivisors(3, power, MOD) * 2
    
    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:
        if power == 0:
            return 1

        result = self.calculateNiceDivisors(base, power // 2, MOD)
        result = (result * result) % MOD

        if power % 2 == 1:
            result = (result * base) % MOD

        return result % MOD
"
3430,python3,maximum-sum-queries,"import math
from typing import List
import bisect

class Solution:
    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        def buildSparseTable(arr, n):
            k = int(math.log2(n))
            st = [[None for j in range(n)] for i in range(k + 1)]
            for i in range(k + 1):
                for j in range(n - (1 << i) + 1):
                    if i == 0:
                        st[i][j] = arr[j]
                    else:
                        st[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << (i - 1))])
            return st

        def getMax(st, l, r):
            i = int(math.log2(r - l + 1))
            return max(st[i][l], st[i][r - (1 << i) + 1])

        n = len(nums1)
        a = sorted([[nums1[i], nums2[i]] for i in range(n)])
        max_y = [v[1] for v in a]
        for i in range(n - 2, -1, -1):
            max_y[i] = max(max_y[i], max_y[1 + 1])   
        _sum = [v[0] + v[1] for v in a]
        st_max_sum = buildSparseTable(_sum, n)
        res = []
        for x, y in queries:
            i = bisect.bisect_left(a, [x, y])
            if i == n or max_y[i] < y:
                res.append(-1)
                continue
            left, right = i, n - 1
            while left < right:
                m = (left + right + 1) // 2
                if max_y[m] >= y:
                    left = m
                else:
                    right = m - 1
            j = right
            res.append(getMax(st_max_sum, i, j))
        return res",None,"import math
from typing import List
import bisect

class Solution:
    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        def buildSparseTable(arr, n):
            k = int(math.log2(n))
            st = [[None for j in range(n)] for i in range(k + 1)]
            for i in range(k + 1):
                for j in range(n - (1 << i) + 1):
                    if i == 0:
                        st[i][j] = arr[j]
                    else:
                        st[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << (i - 1))])
            return st

        def getMax(st, l, r):
            i = int(math.log2(r - l + 1))
            return max(st[i][l], st[i][r - (1 << i) + 1])

        n = len(nums1)
        a = sorted([[nums1[i], nums2[i]] for i in range(n)])
        max_y = [v[1] for v in a]
        for i in range(n - 2, -1, -1):
            max_y[i] = max(max_y[i], max_y[i + 1])   
        _sum = [v[0] + v[1] for v in a]
        st_max_sum = buildSparseTable(_sum, n)
        res = []
        for x, y in queries:
            i = bisect.bisect_left(a, [x, y])
            if i == n or max_y[i] < y:
                res.append(-1)
                continue
            j = i
            while j < n and a[j][1] >= y:
                j += 1
            res.append(getMax(st_max_sum, i, j - 1))
        return res
"
3430,python3,maximum-sum-queries,"import math
from typing import List
import bisect

class Solution:
    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        def buildSparseTable(arr, n):
            k = int(math.log2(n))
            st = [[None for j in range(n)] for i in range(k + 1)]
            for i in range(k + 1):
                for j in range(n - (1 << i) + 1):
                    if i == 0:
                        st[i][j] = arr[j]
                    else:
                        st[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << (i - 1))])
            return st

        def getMax(st, l, r):
            i = int(math.log2(r - l + 1))
            return max(st[i][l], st[i][r - (1 << i) + 1])

        n = len(nums1)
        a = sorted([[nums1[i], nums2[i]] for i in range(n)])
        max_y = [v[1] for v in a]
        for i in range(n - 2, -1, -1):
            max_y[i] = max(max_y[i], max_y[1 + 1])   
        _sum = [v[0] + v[1] for v in a]
        st_max_sum = buildSparseTable(_sum, n)
        res = []
        for x, y in queries:
            i = bisect.bisect_left(a, [x, y])
            if i == n or max_y[i] < y:
                res.append(-1)
                continue
            left, right = i, n - 1
            while left < right:
                m = (left + right + 1) // 2
                if max_y[m] >= y:
                    left = m
                else:
                    right = m - 1
            j = right
            res.append(getMax(st_max_sum, i, j))
        return res",None,"import math
from typing import List
import bisect

class Solution:
    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        def buildSparseTable(arr, n):
            k = int(math.log2(n))
            st = [[None for j in range(n)] for i in range(k + 1)]
            for i in range(k + 1):
                for j in range(n - (1 << i) + 1):
                    if i == 0:
                        st[i][j] = arr[j]
                    else:
                        st[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << (i - 1))])
            return st

        def getMax(st, l, r):
            i = int(math.log2(r - l + 1))
            return max(st[i][l], st[i][r - (1 << i) + 1])

        n = len(nums1)
        a = sorted([[nums1[i], nums2[i]] for i in range(n)], key=lambda x: x[0])
        max_y = [v[1] for v in a]
        for i in range(n - 2, -1, -1):
            max_y[i] = max(max_y[i], max_y[i + 1])
        _sum = [v[0] + v[1] for v in a]
        st_max_sum = buildSparseTable(_sum, n)
        res = []
        for x, y in queries:
            i = bisect.bisect_left(a, [x, y])
            if i == n or max_y[i] < y:
                res.append(-1)
                continue
            j = i
            while j < n and a[j][0] == x and a[j][1] >= y:
                j += 1
            j -= 1
            res.append(getMax(st_max_sum, i, j))
        return res
"
3430,python3,maximum-sum-queries,"import math
from typing import List
import bisect

class Solution:
    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        def buildSparseTable(arr, n):
            k = int(math.log2(n))
            st = [[None for j in range(n)] for i in range(k + 1)]
            for i in range(k + 1):
                for j in range(n - (1 << i) + 1):
                    if i == 0:
                        st[i][j] = arr[j]
                    else:
                        st[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << (i - 1))])
            return st

        def getMax(st, l, r):
            i = int(math.log2(r - l + 1))
            return max(st[i][l], st[i][r - (1 << i) + 1])

        n = len(nums1)
        a = sorted([[nums1[i], nums2[i]] for i in range(n)])
        max_y = [v[1] for v in a]
        for i in range(n - 2, -1, -1):
            max_y[i] = max(max_y[i], max_y[1 + 1])   
        _sum = [v[0] + v[1] for v in a]
        st_max_sum = buildSparseTable(_sum, n)
        res = []
        for x, y in queries:
            i = bisect.bisect_left(a, [x, y])
            if i == n or max_y[i] < y:
                res.append(-1)
                continue
            left, right = i, n - 1
            while left < right:
                m = (left + right + 1) // 2
                if max_y[m] >= y:
                    left = m
                else:
                    right = m - 1
            j = right
            res.append(getMax(st_max_sum, i, j))
        return res",None,"import math
from typing import List
import bisect

class Solution:
    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        def buildSparseTable(arr, n):
            k = int(math.log2(n))
            st = [[None for j in range(n)] for i in range(k + 1)]
            for i in range(k + 1):
                for j in range(n - (1 << i) + 1):
                    if i == 0:
                        st[i][j] = arr[j]
                    else:
                        st[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << (i - 1))])
            return st

        def getMax(st, l, r):
            i = int(math.log2(r - l + 1))
            return max(st[i][l], st[i][r - (1 << i) + 1])

        n = len(nums1)
        a = sorted([[nums1[i], nums2[i]] for i in range(n)], key=lambda x: x[0])
        max_y = [v[1] for v in a]
        for i in range(n - 2, -1, -1):
            max_y[i] = max(max_y[i], max_y[i + 1])   
        _sum = [v[0] + v[1] for v in a]
        st_max_sum = buildSparseTable(_sum, n)
        res = []
        for x, y in queries:
            i = bisect.bisect_left(a, [x, y])
            if i == n or max_y[i] < y:
                res.append(-1)
                continue
            left, right = i, n - 1
            while left < right:
                m = (left + right + 1) // 2
                if max_y[m] >= y:
                    left = m
                else:
                    right = m - 1
            j = right
            res.append(getMax(st_max_sum, i, j))
        return res
"
3431,python3,maximum-strength-of-a-group,"class Solution:
    def maxStrength(self, nums: List[int]) -> int:
        max_memo, min_memo = nums[0], nums[0]
        for num in nums[1:]:
            max_memo, min_memo = max(max_memo, num, num*min_memo), min(min_memo, num, num*min_memo, num*max_memo)
        return max_memo",None,"class Solution:
    def maxStrength(self, nums: List[int]) -> int:
        max_memo, min_memo = max(nums[0], 0), min(nums[0], 0)
        product = nums[0]
        for num in nums[1:]:
            product = max(product, num, num*min_memo)
            max_memo = max(max_memo, product)
            min_memo = min(min_memo, num, num*max_memo)
        return max_memo
"
3431,python3,maximum-strength-of-a-group,"class Solution:
    def maxStrength(self, nums: List[int]) -> int:
        max_memo, min_memo = nums[0], nums[0]
        for num in nums[1:]:
            max_memo, min_memo = max(max_memo, num, num*min_memo), min(min_memo, num, num*min_memo, num*max_memo)
        return max_memo",None,"class Solution:
    def maxStrength(self, nums: List[int]) -> int:
        max_memo, min_memo = max(nums[0], 0), min(nums[0], 0)
        for num in nums[1:]:
            max_memo = max(max_memo, num, num*min_memo)
            min_memo = min(min_memo, num, num*max_memo)
        return max(0, max_memo)
"
3431,python3,maximum-strength-of-a-group,"class Solution:
    def maxStrength(self, nums: List[int]) -> int:
        max_memo, min_memo = nums[0], nums[0]
        for num in nums[1:]:
            max_memo, min_memo = max(max_memo, num, num*min_memo), min(min_memo, num, num*min_memo, num*max_memo)
        return max_memo",None,"class Solution:
    def maxStrength(self, nums: List[int]) -> int:
        max_memo, min_memo = max(nums[0], 0), min(nums[0], 0)
        for num in nums[1:]:
            max_memo = max(max_memo, num, num * min_memo)
            min_memo = min(min_memo, num, num * max_memo)
        return max_memo
"
3432,python3,largest-positive-integer-that-exists-with-its-negative,"class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        nums=sorted(nums,reverse=True)
        s=set(nums)
        for i in range(len(nums)):
            if nums[i] in s:
                return nums[i]
        return -1",None,"class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        nums = sorted(nums, reverse=True)
        s = set(nums)
        for num in nums:
            if -num in s:
                return num
        return -1
"
3432,python3,largest-positive-integer-that-exists-with-its-negative,"class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        nums=sorted(nums,reverse=True)
        s=set(nums)
        for i in range(len(nums)):
            if nums[i] in s:
                return nums[i]
        return -1",None,"class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        nums = sorted(nums, reverse=True)
        s = set(nums)
        for num in nums:
            if -num in s:
                return num
        return -1
"
3432,python3,largest-positive-integer-that-exists-with-its-negative,"class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        nums=sorted(nums,reverse=True)
        s=set(nums)
        for i in range(len(nums)):
            if nums[i] in s:
                return nums[i]
        return -1",None,"class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        nums = sorted(nums, reverse=True)
        s = set(nums)
        for num in nums:
            if -num in s:
                return num
        return -1
"
3433,python3,longest-cycle-in-a-graph,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        v=[0]*len(edges)
        ans=-1
        for i in range(len(edges)):
            t=1
            c=i
            while c>=0:
                if v[c]!=0:
                    if v[c][0]==i:
                        ans=max(ans,t-v[c][1])
                    break
                else:
                    v[c]=[i,t]
                    t+=1
                    c=edges[c] - 1
        return ans",None,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        v=[0]*len(edges)
        ans=-1
        for i in range(len(edges)):
            t=1
            c=i
            while c>=0 and v[c]==0:
                v[c]=t
                t+=1
                c=edges[c]
            if c>=0:
                cycle_length = t - v[c]
                ans = max(ans, cycle_length)
        return ans
"
3433,python3,longest-cycle-in-a-graph,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        v=[0]*len(edges)
        ans=-1
        for i in range(len(edges)):
            t=1
            c=i
            while c>=0:
                if v[c]!=0:
                    if v[c][0]==i:
                        ans=max(ans,t-v[c][1])
                    break
                else:
                    v[c]=[i,t]
                    t+=1
                    c=edges[c] - 1
        return ans",None,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        v=[0]*len(edges)
        ans=-1
        for i in range(len(edges)):
            t=1
            c=i
            while c>=0 and v[c]==0:
                v[c]=t
                t+=1
                c=edges[c]
            if c>=0:
                if v[c]!=0 and v[c]<t-1:
                    ans=max(ans,t-v[c]-1)
        return ans
"
3433,python3,longest-cycle-in-a-graph,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        v=[0]*len(edges)
        ans=-1
        for i in range(len(edges)):
            t=1
            c=i
            while c>=0:
                if v[c]!=0:
                    if v[c][0]==i:
                        ans=max(ans,t-v[c][1])
                    break
                else:
                    v[c]=[i,t]
                    t+=1
                    c=edges[c] - 1
        return ans",None,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        v=[0]*len(edges)
        ans=-1
        for i in range(len(edges)):
            t=1
            c=i
            while c >= 0 and v[c]==0:
                v[c]=t
                t+=1
                c=edges[c]
            if c >= 0:
                cur_len = t - v[c]
                if i > c and cur_len > 0:
                    ans = max(ans, cur_len)
        return ans
"
3434,python3,kth-missing-positive-number,"class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        l,h=0,len(arr)
        while l<h:
            mid=(h+l)//2
            if arr[mid]-mid>k:h=mid
            else: l=mid+1
        return l+k-1",None,"class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        l, h = 0, len(arr)
        while l < h:
            mid = (h + l) // 2
            if arr[mid] - mid > k:
                h = mid
            else:
                l = mid + 1
        if l - k > 0:
            return l - k
        else:
            return l + k
"
3434,python3,kth-missing-positive-number,"class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        l,h=0,len(arr)
        while l<h:
            mid=(h+l)//2
            if arr[mid]-mid>k:h=mid
            else: l=mid+1
        return l+k-1",None,"class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        l, h = 0, len(arr)
        while l < h:
            mid = (h + l) // 2
            if arr[mid] - mid > k:
                h = mid
            else:
                l = mid + 1
        if l - 1 < len(arr) and arr[l - 1] - (l - 1) < k:
            return arr[-1] + k - (arr[-1] - (l - 1))
        else:
            return l - 1 + k
"
3434,python3,kth-missing-positive-number,"class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        l,h=0,len(arr)
        while l<h:
            mid=(h+l)//2
            if arr[mid]-mid>k:h=mid
            else: l=mid+1
        return l+k-1",None,"class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        l, h = 0, len(arr)
        while l < h:
            mid = (h + l) // 2
            if arr[mid] - mid > k:
                h = mid
            else:
                l = mid + 1
        if l - k > 0:
            return l - k
        else:
            return l + k
"
3435,python3,longest-word-in-dictionary-through-deleting,"class Solution:
    def findLongestWord(self, s: str, d: List[str]) -> str:
        res = ''
        for cand in d:
            if self.find(s, cand) and (len(cand) < len(res) or (len(cand) == len(res) and cand < res)):
                res = cand
        return res
    

    def find(self , s ,d):
        i , j = 0 , 0
        while i < len(s) and j < len(d):
            if s[i] == d[j]:
                i-=1
                j+=1
            else:
                i+=1
        return j == len(d)",None,"class Solution:
    def findLongestWord(self, s: str, d: List[str]) -> str:
        res = ''
        for cand in d:
            i, j = 0, 0
            while i < len(s) and j < len(cand):
                if s[i] == cand[j]:
                    i += 1
                    j += 1
                else:
                    i += 1
            if j == len(cand):
                if len(cand) > len(res) or (len(cand) == len(res) and cand < res):
                    res = cand
        return res
"
3435,python3,longest-word-in-dictionary-through-deleting,"class Solution:
    def findLongestWord(self, s: str, d: List[str]) -> str:
        res = ''
        for cand in d:
            if self.find(s, cand) and (len(cand) < len(res) or (len(cand) == len(res) and cand < res)):
                res = cand
        return res
    

    def find(self , s ,d):
        i , j = 0 , 0
        while i < len(s) and j < len(d):
            if s[i] == d[j]:
                i-=1
                j+=1
            else:
                i+=1
        return j == len(d)",None,"class Solution:
    def findLongestWord(self, s: str, d: List[str]) -> str:
        res = ''
        for cand in d:
            i, j = 0, 0
            while i < len(s) and j < len(cand):
                if s[i] == cand[j]:
                    i += 1
                    j += 1
                else:
                    i += 1
            if j == len(cand):
                if len(cand) > len(res) or (len(cand) == len(res) and cand < res):
                    res = cand
        return res
"
3435,python3,longest-word-in-dictionary-through-deleting,"class Solution:
    def findLongestWord(self, s: str, d: List[str]) -> str:
        res = ''
        for cand in d:
            if self.find(s, cand) and (len(cand) < len(res) or (len(cand) == len(res) and cand < res)):
                res = cand
        return res
    

    def find(self , s ,d):
        i , j = 0 , 0
        while i < len(s) and j < len(d):
            if s[i] == d[j]:
                i-=1
                j+=1
            else:
                i+=1
        return j == len(d)",None,"class Solution:
    def findLongestWord(self, s: str, d: List[str]) -> str:
        res = ''
        for cand in d:
            i = j = 0
            while i < len(s) and j < len(cand):
                if s[i] == cand[j]:
                    i += 1
                    j += 1
                else:
                    i += 1
            if j == len(cand) and (len(cand) > len(res) or (len(cand) == len(res) and cand < res)):
                res = cand
        return res
"
3436,python3,number-complement,"class Solution:
    def findComplement(self, num: int) -> int:
        com = ''
        while num > 0 :
            
            if num % 2 == 1:
                com += '0'
            else:
                com += '1'
            num = num // 2
        return int(com,2)",None,"class Solution:
    def findComplement(self, num: int) -> int:
        com = ''
        while num > 0:
            if num % 2 == 0:
                com += '1'
            else:
                com += '0'
            num = num // 2
        return int(com, 2)
"
3436,python3,number-complement,"class Solution:
    def findComplement(self, num: int) -> int:
        com = ''
        while num > 0 :
            
            if num % 2 == 1:
                com += '0'
            else:
                com += '1'
            num = num // 2
        return int(com,2)",None,"class Solution:
    def findComplement(self, num: int) -> int:
        com = ''
        while num > 0 :
            if num % 2 == 0:
                com += '0'
            else:
                com += '1'
            num = num // 2
        return int(com, 2)
"
3436,python3,number-complement,"class Solution:
    def findComplement(self, num: int) -> int:
        com = ''
        while num > 0 :
            
            if num % 2 == 1:
                com += '0'
            else:
                com += '1'
            num = num // 2
        return int(com,2)",None,"class Solution:
    def findComplement(self, num: int) -> int:
        com = ''
        while num > 0 :
            if num % 2 == 0:
                com += '0'
            else:
                com += '1'
            num = num // 2
        return int(com,2)
"
3437,python3,design-hashmap,"class MyHashMap:

    def __init__(self):
        self.h = {}

    def put(self, key: int, value: int) -> None:
        if key in self.h:
            self.h[key] = value+1
        else:
            self.h[key] = value

    def get(self, key: int) -> int:
        if key not in self.h:
            return -1
        else:
            return self.h[key]

    def remove(self, key: int) -> None:
        if key in self.h:
            del self.h[key]",None,"class MyHashMap:

    def __init__(self):
        self.h = {}

    def put(self, key: int, value: int) -> None:
        if key in self.h:
            self.h[key] = value
        else:
            self.h[key] = value

    def get(self, key: int) -> int:
        if key not in self.h:
            return -1
        else:
            return self.h[key]

    def remove(self, key: int) -> None:
        if key in self.h:
            del self.h[key]
"
3437,python3,design-hashmap,"class MyHashMap:

    def __init__(self):
        self.h = {}

    def put(self, key: int, value: int) -> None:
        if key in self.h:
            self.h[key] = value+1
        else:
            self.h[key] = value

    def get(self, key: int) -> int:
        if key not in self.h:
            return -1
        else:
            return self.h[key]

    def remove(self, key: int) -> None:
        if key in self.h:
            del self.h[key]",None,"class MyHashMap:

    def __init__(self):
        self.h = {}

    def put(self, key: int, value: int) -> None:
        if key in self.h:
            self.h[key] = value
        else:
            self.h[key] = value

    def get(self, key: int) -> int:
        if key not in self.h:
            return -1
        else:
            return self.h[key]

    def remove(self, key: int) -> None:
        if key in self.h:
            del self.h[key]
"
3437,python3,design-hashmap,"class MyHashMap:

    def __init__(self):
        self.h = {}

    def put(self, key: int, value: int) -> None:
        if key in self.h:
            self.h[key] = value+1
        else:
            self.h[key] = value

    def get(self, key: int) -> int:
        if key not in self.h:
            return -1
        else:
            return self.h[key]

    def remove(self, key: int) -> None:
        if key in self.h:
            del self.h[key]",None,"class MyHashMap:

    def __init__(self):
        self.h = {}

    def put(self, key: int, value: int) -> None:
        self.h[key] = value

    def get(self, key: int) -> int:
        if key not in self.h:
            return -1
        else:
            return self.h[key]

    def remove(self, key: int) -> None:
        if key in self.h:
            del self.h[key]
"
3438,python3,find-the-kth-largest-integer-in-the-array,"class Solution:
    def kthLargestNumber(self, nums: List[str], k: int) -> str:
        ls = []
        for i in nums:
            ls.append(int(i))
        sorted_ = sorted(ls)
        return str(sorted_[k])",None,"class Solution:
    def kthLargestNumber(self, nums: List[str], k: int) -> str:
        ls = []
        for i in nums:
            ls.append(int(i))
        sorted_ = sorted(ls, reverse=True)
        return str(sorted_[k-1])
"
3438,python3,find-the-kth-largest-integer-in-the-array,"class Solution:
    def kthLargestNumber(self, nums: List[str], k: int) -> str:
        ls = []
        for i in nums:
            ls.append(int(i))
        sorted_ = sorted(ls)
        return str(sorted_[k])",None,"class Solution:
    def kthLargestNumber(self, nums: List[str], k: int) -> str:
        ls = []
        for i in nums:
            ls.append(int(i))
        sorted_ = sorted(ls, reverse=True)
        return str(sorted_[k-1])
"
3438,python3,find-the-kth-largest-integer-in-the-array,"class Solution:
    def kthLargestNumber(self, nums: List[str], k: int) -> str:
        ls = []
        for i in nums:
            ls.append(int(i))
        sorted_ = sorted(ls)
        return str(sorted_[k])",None,"class Solution:
    def kthLargestNumber(self, nums: List[str], k: int) -> str:
        ls = []
        for i in nums:
            ls.append(int(i))
        sorted_ = sorted(ls, reverse=True)
        return str(sorted_[k-1])
"
3439,python3,minimum-fuel-cost-to-report-to-the-capital,"class Solution:
    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:
        adjacencyList = [[] for i in range(len(roads) + 1)]
        res = [0]
        for road in roads : 
            adjacencyList[road[0]].append(road[1])
            adjacencyList[road[1]].append(road[0])
        visited = [0 for i in range(len(roads) + 1)]
        visited[0]=1
        def dfs(i,visited):
            if visited[i] == 1:
                return 0
            visited[i] = 1
            tot = 1
            for k in adjacencyList[i]:
                tot += dfs(k,visited)
            if tot%seats == 0:
                res[0] += tot//seats
            else :
                res[0] += tot//seats
            return tot
        for i in adjacencyList[0]:
            total = dfs(i,visited)
        return res[0]",None,"class Solution:
    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:
        adjacencyList = [[] for i in range(len(roads) + 1)]
        res = [0]
        for road in roads : 
            adjacencyList[road[0]].append(road[1])
            adjacencyList[road[1]].append(road[0])
        visited = [0 for i in range(len(roads) + 1)]
        def dfs(i):
            visited[i] = 1
            tot = 1
            for k in adjacencyList[i]:
                if visited[k] == 0:
                    tot += dfs(k)
            if i != 0:
                res[0] += tot // seats
            return tot
        for i in adjacencyList[0]:
            total = dfs(i)
        return res[0]
"
3439,python3,minimum-fuel-cost-to-report-to-the-capital,"class Solution:
    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:
        adjacencyList = [[] for i in range(len(roads) + 1)]
        res = [0]
        for road in roads : 
            adjacencyList[road[0]].append(road[1])
            adjacencyList[road[1]].append(road[0])
        visited = [0 for i in range(len(roads) + 1)]
        visited[0]=1
        def dfs(i,visited):
            if visited[i] == 1:
                return 0
            visited[i] = 1
            tot = 1
            for k in adjacencyList[i]:
                tot += dfs(k,visited)
            if tot%seats == 0:
                res[0] += tot//seats
            else :
                res[0] += tot//seats
            return tot
        for i in adjacencyList[0]:
            total = dfs(i,visited)
        return res[0]",None,"class Solution:
    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:
        adjacencyList = [[] for i in range(len(roads) + 1)]
        res = [0]
        for road in roads : 
            adjacencyList[road[0]].append(road[1])
            adjacencyList[road[1]].append(road[0])
        visited = [0 for i in range(len(roads) + 1)]

        def dfs(i):
            visited[i] = 1
            total = 1
            for k in adjacencyList[i]:
                if not visited[k]:
                    total += dfs(k)
            if i != 0:
                res[0] += total // seats
            return total

        dfs(0)
        return res[0]
"
3439,python3,minimum-fuel-cost-to-report-to-the-capital,"class Solution:
    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:
        adjacencyList = [[] for i in range(len(roads) + 1)]
        res = [0]
        for road in roads : 
            adjacencyList[road[0]].append(road[1])
            adjacencyList[road[1]].append(road[0])
        visited = [0 for i in range(len(roads) + 1)]
        visited[0]=1
        def dfs(i,visited):
            if visited[i] == 1:
                return 0
            visited[i] = 1
            tot = 1
            for k in adjacencyList[i]:
                tot += dfs(k,visited)
            if tot%seats == 0:
                res[0] += tot//seats
            else :
                res[0] += tot//seats
            return tot
        for i in adjacencyList[0]:
            total = dfs(i,visited)
        return res[0]",None,"class Solution:
    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:
        adjacencyList = [[] for i in range(len(roads) + 1)]
        res = [0]
        for road in roads : 
            adjacencyList[road[0]].append(road[1])
            adjacencyList[road[1]].append(road[0])
        visited = [0 for i in range(len(roads) + 1)]
        visited[0]=1
        def dfs(i):
            visited[i] = 1
            tot = 1
            for k in adjacencyList[i]:
                if visited[k] == 0:
                    tot += dfs(k)
            if i != 0:
                res[0] += tot // seats
            return tot
        for i in adjacencyList[0]:
            total = dfs(i)
        return res[0]
"
3440,python3,check-if-two-string-arrays-are-equivalent,"class Solution:
    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        word3="""".join(word1.reverse())
        word4="""".join(word2)
        if word3==word4:
            return True
        else:
            return False",None,"class Solution:
    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        word3 = """".join(word1)
        word4 = """".join(word2)
        return word3 == word4
"
3440,python3,check-if-two-string-arrays-are-equivalent,"class Solution:
    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        word3="""".join(word1.reverse())
        word4="""".join(word2)
        if word3==word4:
            return True
        else:
            return False",None,"class Solution:
    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        word3 = """".join(word1)
        word4 = """".join(word2)
        if word3 == word4:
            return True
        else:
            return False
"
3440,python3,check-if-two-string-arrays-are-equivalent,"class Solution:
    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        word3="""".join(word1.reverse())
        word4="""".join(word2)
        if word3==word4:
            return True
        else:
            return False",None,"class Solution:
    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        word3 = """".join(word1)
        word4 = """".join(word2)
        return word3 == word4
"
3441,python3,string-compression-ii,"class Solution:
    def dp(self,i,s,prev,k,ct,n,dct):
        if k<0:
            return float(""infinity"")
        if i>=n:
            x=0
            if ct>1:
                x=len(str(ct))+1
            elif ct==1:
                x=1
            return x
        if (i,prev,ct,k) in dct:
            return dct[(i,prev,ct,k)]
        if s[i]==prev:
            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)
        else:
            x=0
            if ct>1:
                x=len(str(ct))+1
            elif ct==1:
                x=1
            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)
        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)
        dct[(i,prev,ct,k)]=max(inc,exc)
        return min(inc,exc)


    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        n=len(s)
        return self.dp(0,s,"""",k,0,n,{})",None,"class Solution:
    def dp(self,i,s,prev,k,ct,n,dct):
        if k<0:
            return float(""inf"")
        if i>=n:
            if ct>1:
                return len(str(ct))+1
            elif ct==1:
                return 1
            else:
                return 0
        if (i,prev,ct,k) in dct:
            return dct[(i,prev,ct,k)]
        if s[i]==prev:
            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)
        else:
            inc=self.dp(i+1,s,s[i],k,1,n,dct) + (ct if ct>1 else 0)
        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)
        dct[(i,prev,ct,k)]=inc
        return min(inc, exc)


    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        n=len(s)
        return self.dp(0,s,"""",k,0,n,{})
"
3441,python3,string-compression-ii,"class Solution:
    def dp(self,i,s,prev,k,ct,n,dct):
        if k<0:
            return float(""infinity"")
        if i>=n:
            x=0
            if ct>1:
                x=len(str(ct))+1
            elif ct==1:
                x=1
            return x
        if (i,prev,ct,k) in dct:
            return dct[(i,prev,ct,k)]
        if s[i]==prev:
            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)
        else:
            x=0
            if ct>1:
                x=len(str(ct))+1
            elif ct==1:
                x=1
            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)
        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)
        dct[(i,prev,ct,k)]=max(inc,exc)
        return min(inc,exc)


    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        n=len(s)
        return self.dp(0,s,"""",k,0,n,{})",None,"class Solution:
    def dp(self,i,s,prev,k,ct,n,dct):
        if k<0:
            return float(""inf"")
        if i>=n:
            x=0
            if ct>1:
                x=len(str(ct))+1
            elif ct==1:
                x=1
            return x
        if (i,prev,ct,k) in dct:
            return dct[(i,prev,ct,k)]
        if s[i]==prev:
            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)
        else:
            inc=ct+1 + self.dp(i+1,s,s[i],k,1,n,dct)
        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)
        dct[(i,prev,ct,k)]=min(inc,exc)
        return dct[(i,prev,ct,k)]


    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        n=len(s)
        return self.dp(0,s,"""",k,0,n,{})
"
3441,python3,string-compression-ii,"class Solution:
    def dp(self,i,s,prev,k,ct,n,dct):
        if k<0:
            return float(""infinity"")
        if i>=n:
            x=0
            if ct>1:
                x=len(str(ct))+1
            elif ct==1:
                x=1
            return x
        if (i,prev,ct,k) in dct:
            return dct[(i,prev,ct,k)]
        if s[i]==prev:
            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)
        else:
            x=0
            if ct>1:
                x=len(str(ct))+1
            elif ct==1:
                x=1
            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)
        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)
        dct[(i,prev,ct,k)]=max(inc,exc)
        return min(inc,exc)


    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        n=len(s)
        return self.dp(0,s,"""",k,0,n,{})",None,"class Solution:
    def dp(self,i,s,prev,k,ct,n,dct):
        if k<0:
            return float(""inf"")
        if i>=n:
            x=0
            if ct>1:
                x=len(str(ct))+1
            elif ct==1:
                x=1
            return x
        if (i,prev,ct,k) in dct:
            return dct[(i,prev,ct,k)]
        if s[i]==prev:
            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)
        else:
            x=0
            if ct>1:
                x=len(str(ct))+1
            elif ct==1:
                x=1
            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)
        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)
        dct[(i,prev,ct,k)]=max(inc,exc)
        return min(inc,exc)


    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        n=len(s)
        return self.dp(0,s,"""",k,0,n,{})
"
3442,python3,longest-well-performing-interval,"class Solution:
    def longestWPI(self, A):
        curr, ans, D = 0, 0, {}
        for e, i in enumerate(map(lambda x: (-1, 1)[x > 8], A)):
            curr += i
            D[curr] = D.get(curr, e)
            ans = e + 1 if curr > 0 else max(ans, e - D.get(curr - 1, e))
        return ans + 1",None,"class Solution:
    def longestWPI(self, A):
        curr, ans, D = 0, 0, {}
        for e, i in enumerate(map(lambda x: (-1, 1)[x > 8], A)):
            curr += i
            if curr not in D:
                D[curr] = e
            ans = max(ans, e - D.get(curr - 1, e))
        return ans
"
3442,python3,longest-well-performing-interval,"class Solution:
    def longestWPI(self, A):
        curr, ans, D = 0, 0, {}
        for e, i in enumerate(map(lambda x: (-1, 1)[x > 8], A)):
            curr += i
            D[curr] = D.get(curr, e)
            ans = e + 1 if curr > 0 else max(ans, e - D.get(curr - 1, e))
        return ans + 1",None,"class Solution:
    def longestWPI(self, A):
        curr, ans, D = 0, 0, {}
        for e, i in enumerate(map(lambda x: (-1, 1)[x > 8], A)):
            curr += i
            if curr not in D:
                D[curr] = e
            ans = max(ans, e - D.get(curr - 1, e))
        return ans
"
3442,python3,longest-well-performing-interval,"class Solution:
    def longestWPI(self, A):
        curr, ans, D = 0, 0, {}
        for e, i in enumerate(map(lambda x: (-1, 1)[x > 8], A)):
            curr += i
            D[curr] = D.get(curr, e)
            ans = e + 1 if curr > 0 else max(ans, e - D.get(curr - 1, e))
        return ans + 1",None,"class Solution:
    def longestWPI(self, A):
        curr, ans, D = 0, 0, {}
        for e, i in enumerate(map(lambda x: (-1, 1)[x > 8], A)):
            curr += i
            if curr not in D:
                D[curr] = e
            ans = max(ans, e - D.get(curr - 1, e))
        return ans
"
3443,python3,longest-happy-prefix,"class Solution:
    def longestPrefix(self, s: str) -> str:
        n=len(s)
        lps=[0]*n
        j=0
        for i in range(1,n):
            while s[i]!=s[j] and j>0:
                j=lps[j]

            if s[i]==s[j]:
                lps[i]=j+1
                j+=1

        return s[:lps[-1]]",None,"class Solution:
    def longestPrefix(self, s: str) -> str:
        n=len(s)
        lps=[0]*n
        j=0
        for i in range(1,n):
            while j>0 and s[i]!=s[j]:
                j=lps[j-1]

            if s[i]==s[j]:
                lps[i]=j+1
                j+=1

        return s[:lps[-1]]
"
3443,python3,longest-happy-prefix,"class Solution:
    def longestPrefix(self, s: str) -> str:
        n=len(s)
        lps=[0]*n
        j=0
        for i in range(1,n):
            while s[i]!=s[j] and j>0:
                j=lps[j]

            if s[i]==s[j]:
                lps[i]=j+1
                j+=1

        return s[:lps[-1]]",None,"class Solution:
    def longestPrefix(self, s: str) -> str:
        n=len(s)
        lps=[0]*n
        j=0
        for i in range(1,n):
            while j>0 and s[i]!=s[j]:
                j=lps[j-1]

            if s[i]==s[j]:
                lps[i]=j+1
                j+=1

        return s[:lps[-1]]
"
3443,python3,longest-happy-prefix,"class Solution:
    def longestPrefix(self, s: str) -> str:
        n=len(s)
        lps=[0]*n
        j=0
        for i in range(1,n):
            while s[i]!=s[j] and j>0:
                j=lps[j]

            if s[i]==s[j]:
                lps[i]=j+1
                j+=1

        return s[:lps[-1]]",None,"class Solution:
    def longestPrefix(self, s: str) -> str:
        n = len(s)
        lps = [0] * n
        j = 0
        for i in range(1, n):
            while j > 0 and s[i] != s[j]:
                j = lps[j - 1]

            if s[i] == s[j]:
                lps[i] = j + 1
                j += 1

        return s[:lps[-1]]
"
3444,python3,best-time-to-buy-and-sell-stock-with-cooldown,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n=len(prices)
        ahd=[0]*2
        ahd2=[0]*2
        for i in range(n-1,-1,-1):
            curr=[0]*2
            for buy in range(2):
                if buy:
                    curr[buy]=max(ahd[buy],ahd[0]-prices[i])
                else:
                    curr[buy]=max(ahd[buy],ahd2[0]+prices[i])  
            ahd2=ahd[:]
            ahd=curr[:]
        return ahd[1]",None,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        ahd = [0] * 2
        ahd2 = [0] * 2
        for i in range(n - 1, -1, -1):
            curr = [0] * 2
            for buy in range(2):
                if buy:
                    curr[buy] = max(ahd[buy], ahd2[0] - prices[i])
                else:
                    curr[buy] = max(ahd[buy], ahd2[1] + prices[i])
            ahd2 = ahd[:]
            ahd = curr[:]
        return ahd[1]
"
3444,python3,best-time-to-buy-and-sell-stock-with-cooldown,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n=len(prices)
        ahd=[0]*2
        ahd2=[0]*2
        for i in range(n-1,-1,-1):
            curr=[0]*2
            for buy in range(2):
                if buy:
                    curr[buy]=max(ahd[buy],ahd[0]-prices[i])
                else:
                    curr[buy]=max(ahd[buy],ahd2[0]+prices[i])  
            ahd2=ahd[:]
            ahd=curr[:]
        return ahd[1]",None,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n=len(prices)
        ahd=[0]*2
        ahd2=[0]*2
        for i in range(n-1,-1,-1):
            curr=[0]*2
            for buy in range(2):
                if buy:
                    curr[buy]=max(ahd[buy],ahd2[1]-prices[i])
                else:
                    curr[buy]=max(ahd[buy],ahd2[0]+prices[i])  
            ahd2=ahd[:]
            ahd=curr[:]
        return ahd[1]
"
3444,python3,best-time-to-buy-and-sell-stock-with-cooldown,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n=len(prices)
        ahd=[0]*2
        ahd2=[0]*2
        for i in range(n-1,-1,-1):
            curr=[0]*2
            for buy in range(2):
                if buy:
                    curr[buy]=max(ahd[buy],ahd[0]-prices[i])
                else:
                    curr[buy]=max(ahd[buy],ahd2[0]+prices[i])  
            ahd2=ahd[:]
            ahd=curr[:]
        return ahd[1]",None,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n=len(prices)
        ahd=[0]*2
        ahd2=[0]*2
        for i in range(n-1,-1,-1):
            curr=[0]*2
            for buy in range(2):
                if buy:
                    curr[buy]=max(ahd[buy],ahd2[0]-prices[i])
                else:
                    curr[buy]=max(ahd[buy],ahd2[1]+prices[i])  
            ahd2=ahd[:]
            ahd=curr[:]
        return ahd[1]
"
3445,python3,amount-of-time-for-binary-tree-to-be-infected,"class Solution:       
    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:
        graph = defaultdict(list)
        
        stack = [(root, None)]
        while stack: 
            n, p = stack.pop()
            if p: 
                graph[p.val].append(n.val)
                graph[n.val].append(p.val)
            if n.left: stack.append((n.left, n))
            if n.right: stack.append((n.right, n))
        
        ans = -1
        seen = {start}
        queue = deque([start])
        while queue: 
            for _ in range(len(queue)): 
                u = queue.pop()
                for v in graph[u]: 
                    if v not in seen: 
                        seen.add(v)
                        queue.append(v)
            ans += 1
        return ans",None,"class Solution:       
    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:
        graph = defaultdict(list)
        
        stack = [(root, None)]
        while stack: 
            n, p = stack.pop()
            if p: 
                graph[p.val].append(n.val)
                graph[n.val].append(p.val)
            if n.left: stack.append((n.left, n))
            if n.right: stack.append((n.right, n))
        
        ans = 0
        seen = {start}
        queue = deque([start])
        while queue: 
            for _ in range(len(queue)): 
                u = queue.popleft()
                for v in graph[u]: 
                    if v not in seen: 
                        seen.add(v)
                        queue.append(v)
            ans += 1
        return ans
"
3445,python3,amount-of-time-for-binary-tree-to-be-infected,"class Solution:       
    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:
        graph = defaultdict(list)
        
        stack = [(root, None)]
        while stack: 
            n, p = stack.pop()
            if p: 
                graph[p.val].append(n.val)
                graph[n.val].append(p.val)
            if n.left: stack.append((n.left, n))
            if n.right: stack.append((n.right, n))
        
        ans = -1
        seen = {start}
        queue = deque([start])
        while queue: 
            for _ in range(len(queue)): 
                u = queue.pop()
                for v in graph[u]: 
                    if v not in seen: 
                        seen.add(v)
                        queue.append(v)
            ans += 1
        return ans",None,"class Solution:       
    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:
        graph = defaultdict(list)
        
        stack = [(root, None)]
        while stack: 
            n, p = stack.pop()
            if p: 
                graph[p.val].append(n.val)
                graph[n.val].append(p.val)
            if n.left: stack.append((n.left, n))
            if n.right: stack.append((n.right, n))
        
        ans = 0
        seen = {start}
        queue = deque([start])
        while queue: 
            for _ in range(len(queue)): 
                u = queue.popleft()
                for v in graph[u]: 
                    if v not in seen: 
                        seen.add(v)
                        queue.append(v)
            ans += 1
        return ans
"
3445,python3,amount-of-time-for-binary-tree-to-be-infected,"class Solution:       
    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:
        graph = defaultdict(list)
        
        stack = [(root, None)]
        while stack: 
            n, p = stack.pop()
            if p: 
                graph[p.val].append(n.val)
                graph[n.val].append(p.val)
            if n.left: stack.append((n.left, n))
            if n.right: stack.append((n.right, n))
        
        ans = -1
        seen = {start}
        queue = deque([start])
        while queue: 
            for _ in range(len(queue)): 
                u = queue.pop()
                for v in graph[u]: 
                    if v not in seen: 
                        seen.add(v)
                        queue.append(v)
            ans += 1
        return ans",None,"class Solution:
    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:
        graph = defaultdict(list)

        stack = [(root, None)]
        while stack:
            n, p = stack.pop()
            if p:
                graph[p.val].append(n.val)
                graph[n.val].append(p.val)
            if n.left: stack.append((n.left, n))
            if n.right: stack.append((n.right, n))

        ans = 0
        seen = {start}
        queue = deque([start])
        while queue:
            for _ in range(len(queue)):
                u = queue.popleft()
                for v in graph[u]:
                    if v not in seen:
                        seen.add(v)
                        queue.append(v)
            ans += 1
        return ans
"
3446,python3,maximum-of-absolute-value-expression,"class Solution:
    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
        val1,val2,val3,val4=[],[],[],[]
        for i in range(len(arr1)):
            val1.append(i+arr1[i]+arr2[i])
            val2.append(i+arr1[i]-arr2[i])
            val3.append(i-arr1[i]+arr2[i])
            val4.append(i-arr1[i]-arr2[i])
        ans=0
        ans=min(ans,max(val1)-min(val1))
        ans=min(ans,max(val2)-min(val2))
        ans=min(ans,max(val3)-min(val3))
        ans=min(ans,max(val4)-min(val4))
        return ans",None,"class Solution:
    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
        val1, val2, val3, val4 = [], [], [], []
        for i in range(len(arr1)):
            val1.append(i + arr1[i] + arr2[i])
            val2.append(i + arr1[i] - arr2[i])
            val3.append(i - arr1[i] + arr2[i])
            val4.append(i - arr1[i] - arr2[i])
        ans = max(abs(max(val1)) + abs(min(val1)),
                  abs(max(val2)) + abs(min(val2)),
                  abs(max(val3)) + abs(min(val3)),
                  abs(max(val4)) + abs(min(val4)))
        return ans
"
3446,python3,maximum-of-absolute-value-expression,"class Solution:
    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
        val1,val2,val3,val4=[],[],[],[]
        for i in range(len(arr1)):
            val1.append(i+arr1[i]+arr2[i])
            val2.append(i+arr1[i]-arr2[i])
            val3.append(i-arr1[i]+arr2[i])
            val4.append(i-arr1[i]-arr2[i])
        ans=0
        ans=min(ans,max(val1)-min(val1))
        ans=min(ans,max(val2)-min(val2))
        ans=min(ans,max(val3)-min(val3))
        ans=min(ans,max(val4)-min(val4))
        return ans",None,"class Solution:
    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
        val1, val2, val3, val4 = [], [], [], []
        for i in range(len(arr1)):
            val1.append(i + arr1[i] + arr2[i])
            val2.append(i + arr1[i] - arr2[i])
            val3.append(i - arr1[i] + arr2[i])
            val4.append(i - arr1[i] - arr2[i])
        return max(max(val1) - min(val1), max(val2) - min(val2), max(val3) - min(val3), max(val4) - min(val4))
"
3446,python3,maximum-of-absolute-value-expression,"class Solution:
    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
        val1,val2,val3,val4=[],[],[],[]
        for i in range(len(arr1)):
            val1.append(i+arr1[i]+arr2[i])
            val2.append(i+arr1[i]-arr2[i])
            val3.append(i-arr1[i]+arr2[i])
            val4.append(i-arr1[i]-arr2[i])
        ans=0
        ans=min(ans,max(val1)-min(val1))
        ans=min(ans,max(val2)-min(val2))
        ans=min(ans,max(val3)-min(val3))
        ans=min(ans,max(val4)-min(val4))
        return ans",None,"class Solution:
    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
        val1,val2,val3,val4=[],[],[],[]
        for i in range(len(arr1)):
            val1.append(i+arr1[i]+arr2[i])
            val2.append(i+arr1[i]-arr2[i])
            val3.append(i-arr1[i]+arr2[i])
            val4.append(i-arr1[i]-arr2[i])
        ans=max(abs(max(val1)-min(val1)), abs(max(val2)-min(val2)), abs(max(val3)-min(val3)), abs(max(val4)-min(val4)))
        return ans
"
3447,python3,rank-transform-of-an-array,"class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        list1=[]
        x=sorted(set(arr))
        dict1={}
        for i in range(len(x)):
            dict1[x[i]]=i
        for j in arr:
            dict1[j]+=1
            y=dict1[j]
            list1.append(y)
        return list1",None,"class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        list1=[]
        x=sorted(set(arr))
        dict1={}
        for i in range(len(x)):
            dict1[x[i]]=i+1
        for j in arr:
            y=dict1[j]
            list1.append(y)
        return list1
"
3447,python3,rank-transform-of-an-array,"class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        list1=[]
        x=sorted(set(arr))
        dict1={}
        for i in range(len(x)):
            dict1[x[i]]=i
        for j in arr:
            dict1[j]+=1
            y=dict1[j]
            list1.append(y)
        return list1",None,"class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        rank = 1
        sorted_arr = sorted(set(arr))
        mapping = {num: rank for rank, num in enumerate(sorted_arr, start=1)}
        return [mapping[num] for num in arr]
"
3447,python3,rank-transform-of-an-array,"class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        list1=[]
        x=sorted(set(arr))
        dict1={}
        for i in range(len(x)):
            dict1[x[i]]=i
        for j in arr:
            dict1[j]+=1
            y=dict1[j]
            list1.append(y)
        return list1",None,"class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        list1 = []
        x = sorted(set(arr))
        dict1 = {}
        for i in range(len(x)):
            dict1[x[i]] = i + 1  # ranks start from 1
        for j in arr:
            list1.append(dict1[j])
        return list1
"
3448,python3,find-the-string-with-lcp,"class Solution:
    def findTheString(self, lcp: List[List[int]]) -> str:
        n = len(lcp)

        for i in range(n):
            for j in range(i + 1, n):
                if lcp[i][j] != lcp[j][i]:
                    return ''
                if lcp[i][j] > n - j:
                    return ''
        for i in range(n):
            if lcp[i][i] != n - i:
                return ''

        pattern = [None for _ in range(n)]
        next_el_ind = 0
        for i in range(n):
            if pattern[i] is not None:
                continue
            pattern[i] = next_el_ind
            next_el_ind += 1
            for j in range(i+1, n):
                if lcp[i][j] > 0:
                    if pattern[j] is not None and pattern[j] != pattern[i]:      
                        return ''      
                    pattern[j] = pattern[i]

        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]
        for i in range(n-1, -1, -1):
            for j in range(n-1, -1, -1):
                if pattern[i] == pattern[j]:
                    if max(i, j) + 1 < n:
                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 2 //Add 2 instead of 1
                    else:
                        pattern_lcp[i][j] = 1
        for i in range(n):
            for j in range(n):
                if lcp[i][j] != pattern_lcp[i][j]:
                    return ''


        if max(pattern) > ord('z') - ord('a'):
            return ''

        return  ''.join(chr(ord('a') + ind) for ind in pattern)",None,"class Solution:
    def findTheString(self, lcp: List[List[int]]) -> str:
        n = len(lcp)

        for i in range(n):
            for j in range(i + 1, n):
                if lcp[i][j] != lcp[j][i]:
                    return ''
                if lcp[i][j] > n - j:
                    return ''
        for i in range(n):
            if lcp[i][i] != n - i:
                return ''

        pattern = [None for _ in range(n)]
        next_el_ind = 0
        for i in range(n):
            if pattern[i] is not None:
                continue
            pattern[i] = next_el_ind
            next_el_ind += 1
            for j in range(i+1, n):
                if lcp[i][j] > 0:
                    if pattern[j] is not None and pattern[j] != pattern[i]:      
                        return ''      
                    pattern[j] = pattern[i]

        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]
        for i in range(n-1, -1, -1):
            for j in range(n-1, -1, -1):
                if pattern[i] == pattern[j]:
                    if max(i, j) + 1 < n:
                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1
                    else:
                        pattern_lcp[i][j] = 1
        for i in range(n):
            for j in range(n):
                if lcp[i][j] != pattern_lcp[i][j]:
                    return ''

        if max(pattern) > ord('z') - ord('a'):
            return ''

        return  ''.join(chr(ord('a') + ind) for ind in pattern)
"
3448,python3,find-the-string-with-lcp,"class Solution:
    def findTheString(self, lcp: List[List[int]]) -> str:
        n = len(lcp)

        for i in range(n):
            for j in range(i + 1, n):
                if lcp[i][j] != lcp[j][i]:
                    return ''
                if lcp[i][j] > n - j:
                    return ''
        for i in range(n):
            if lcp[i][i] != n - i:
                return ''

        pattern = [None for _ in range(n)]
        next_el_ind = 0
        for i in range(n):
            if pattern[i] is not None:
                continue
            pattern[i] = next_el_ind
            next_el_ind += 1
            for j in range(i+1, n):
                if lcp[i][j] > 0:
                    if pattern[j] is not None and pattern[j] != pattern[i]:      
                        return ''      
                    pattern[j] = pattern[i]

        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]
        for i in range(n-1, -1, -1):
            for j in range(n-1, -1, -1):
                if pattern[i] == pattern[j]:
                    if max(i, j) + 1 < n:
                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 2 //Add 2 instead of 1
                    else:
                        pattern_lcp[i][j] = 1
        for i in range(n):
            for j in range(n):
                if lcp[i][j] != pattern_lcp[i][j]:
                    return ''


        if max(pattern) > ord('z') - ord('a'):
            return ''

        return  ''.join(chr(ord('a') + ind) for ind in pattern)",None,"class Solution:
    def findTheString(self, lcp: List[List[int]]) -> str:
        n = len(lcp)

        for i in range(n):
            for j in range(i + 1, n):
                if lcp[i][j] != lcp[j][i]:
                    return ''
                if lcp[i][j] > n - j:
                    return ''
        for i in range(n):
            if lcp[i][i] != n - i:
                return ''

        pattern = [None for _ in range(n)]
        next_el_ind = 0
        for i in range(n):
            if pattern[i] is not None:
                continue
            pattern[i] = next_el_ind
            next_el_ind += 1
            for j in range(i+1, n):
                if lcp[i][j] > 0:
                    if pattern[j] is not None and pattern[j] != pattern[i]:
                        return ''
                    pattern[j] = pattern[i]

        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]
        for i in range(n-1, -1, -1):
            for j in range(n-1, -1, -1):
                if pattern[i] == pattern[j]:
                    if max(i, j) + 1 < n:
                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1
                    else:
                        pattern_lcp[i][j] = 1
        for i in range(n):
            for j in range(n):
                if lcp[i][j] != pattern_lcp[i][j]:
                    return ''

        if max(pattern) > ord('z') - ord('a'):
            return ''

        return  ''.join(chr(ord('a') + ind) for ind in pattern)
"
3448,python3,find-the-string-with-lcp,"class Solution:
    def findTheString(self, lcp: List[List[int]]) -> str:
        n = len(lcp)

        for i in range(n):
            for j in range(i + 1, n):
                if lcp[i][j] != lcp[j][i]:
                    return ''
                if lcp[i][j] > n - j:
                    return ''
        for i in range(n):
            if lcp[i][i] != n - i:
                return ''

        pattern = [None for _ in range(n)]
        next_el_ind = 0
        for i in range(n):
            if pattern[i] is not None:
                continue
            pattern[i] = next_el_ind
            next_el_ind += 1
            for j in range(i+1, n):
                if lcp[i][j] > 0:
                    if pattern[j] is not None and pattern[j] != pattern[i]:      
                        return ''      
                    pattern[j] = pattern[i]

        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]
        for i in range(n-1, -1, -1):
            for j in range(n-1, -1, -1):
                if pattern[i] == pattern[j]:
                    if max(i, j) + 1 < n:
                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 2 //Add 2 instead of 1
                    else:
                        pattern_lcp[i][j] = 1
        for i in range(n):
            for j in range(n):
                if lcp[i][j] != pattern_lcp[i][j]:
                    return ''


        if max(pattern) > ord('z') - ord('a'):
            return ''

        return  ''.join(chr(ord('a') + ind) for ind in pattern)",None,"class Solution:
    def findTheString(self, lcp: List[List[int]]) -> str:
        n = len(lcp)

        for i in range(n):
            for j in range(i + 1, n):
                if lcp[i][j] != lcp[j][i]:
                    return ''
                if lcp[i][j] > n - j:
                    return ''
        for i in range(n):
            if lcp[i][i] != n - i:
                return ''

        pattern = [None for _ in range(n)]
        next_el_ind = 0
        for i in range(n):
            if pattern[i] is not None:
                continue
            pattern[i] = next_el_ind
            next_el_ind += 1
            for j in range(i+1, n):
                if lcp[i][j] > 0:
                    if pattern[j] is not None and pattern[j] != pattern[i]:      
                        return ''      
                    pattern[j] = pattern[i]

        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]
        for i in range(n-1, -1, -1):
            for j in range(n-1, -1, -1):
                if pattern[i] == pattern[j]:
                    if max(i, j) + 1 < n:
                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1
                    else:
                        pattern_lcp[i][j] = 1
        for i in range(n):
            for j in range(n):
                if lcp[i][j] != pattern_lcp[i][j]:
                    return ''

        if max(pattern) > ord('z') - ord('a'):
            return ''

        return  ''.join(chr(ord('a') + ind) for ind in pattern)
"
3449,python3,find-first-palindromic-string-in-the-array,"class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        for i in words:
            if i==i.sort():
                return i
        return """"",None,"class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        for word in words:
            if word == word[::-1]:
                return word
        return """"
"
3449,python3,find-first-palindromic-string-in-the-array,"class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        for i in words:
            if i==i.sort():
                return i
        return """"",None,"class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        for word in words:
            if word == word[::-1]:
                return word
        return """"
"
3449,python3,find-first-palindromic-string-in-the-array,"class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        for i in words:
            if i==i.sort():
                return i
        return """"",None,"class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        for word in words:
            if word == word[::-1]:
                return word
        return """"
"
3450,python3,koko-eating-bananas,"class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        def check(x):
            return sum(ceil(ele/x) for ele in piles) <= h

        l = 1
        r = max(piles)
        while l < r:
            mid = (l+r) // 1
            if not check(mid):
                l=mid+1
            else:
                r=mid
        return l",None,"class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        def check(x):
            return sum(ceil(ele/x) for ele in piles) <= h

        l = 1
        r = max(piles)
        while l < r:
            mid = (l+r+1) // 2
            if check(mid):
                l = mid
            else:
                r = mid - 1
        return l
"
3450,python3,koko-eating-bananas,"class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        def check(x):
            return sum(ceil(ele/x) for ele in piles) <= h

        l = 1
        r = max(piles)
        while l < r:
            mid = (l+r) // 1
            if not check(mid):
                l=mid+1
            else:
                r=mid
        return l",None,"class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        def check(x):
            return sum(ceil(ele/x) for ele in piles) <= h

        l = 1
        r = max(piles)
        while l < r:
            mid = (l+r) // 2
            if check(mid):
                r = mid
            else:
                l = mid + 1
        return l
"
3450,python3,koko-eating-bananas,"class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        def check(x):
            return sum(ceil(ele/x) for ele in piles) <= h

        l = 1
        r = max(piles)
        while l < r:
            mid = (l+r) // 1
            if not check(mid):
                l=mid+1
            else:
                r=mid
        return l",None,"class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        def check(x):
            return sum(ceil(ele/x) for ele in piles) <= h

        l = 1
        r = max(piles)
        while l < r:
            mid = (l+r) // 2
            if check(mid):
                r = mid
            else:
                l = mid + 1
        return l
"
3451,python3,maximum-difference-between-node-and-ancestor,"def fun(root,mx,mn,ans):
    if(root==None):
        return
    d1=abs(root.val-mx)
    d2=abs(root.val-mn)
    ans[0]=max(d1,d2,ans[0])
    mx=max(mx,root.val)
    mn=min(mn,root.val)
    fun(root.left,mx,mn,ans)
    fun(root.right,mx,mn,ans)
class Solution:
    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:
        ans=[0]
        if(root==None):
            return 0
        fun(root,root.val,root.val,ans)
        return 0",None,"def fun(root, mx, mn, ans):
    if root is None:
        return
    d1 = abs(root.val - mx)
    d2 = abs(root.val - mn)
    ans[0] = max(ans[0], d1, d2)
    mx = max(mx, root.val)
    mn = min(mn, root.val)
    fun(root.left, mx, mn, ans)
    fun(root.right, mx, mn, ans)

class Solution:
    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:
        ans = [0]
        if root is not None:
            fun(root, root.val, root.val, ans)
        return ans[0]
"
3451,python3,maximum-difference-between-node-and-ancestor,"def fun(root,mx,mn,ans):
    if(root==None):
        return
    d1=abs(root.val-mx)
    d2=abs(root.val-mn)
    ans[0]=max(d1,d2,ans[0])
    mx=max(mx,root.val)
    mn=min(mn,root.val)
    fun(root.left,mx,mn,ans)
    fun(root.right,mx,mn,ans)
class Solution:
    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:
        ans=[0]
        if(root==None):
            return 0
        fun(root,root.val,root.val,ans)
        return 0",None,"def fun(root, mx, mn, ans):
    if not root:
        return
    d1 = abs(root.val - mx)
    d2 = abs(root.val - mn)
    ans[0] = max(ans[0], d1, d2)
    mx = max(mx, root.val)
    mn = min(mn, root.val)
    fun(root.left, mx, mn, ans)
    fun(root.right, mx, mn, ans)

class Solution:
    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:
        ans = [0]
        if root:
            fun(root, root.val, root.val, ans)
        return ans[0]
"
3451,python3,maximum-difference-between-node-and-ancestor,"def fun(root,mx,mn,ans):
    if(root==None):
        return
    d1=abs(root.val-mx)
    d2=abs(root.val-mn)
    ans[0]=max(d1,d2,ans[0])
    mx=max(mx,root.val)
    mn=min(mn,root.val)
    fun(root.left,mx,mn,ans)
    fun(root.right,mx,mn,ans)
class Solution:
    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:
        ans=[0]
        if(root==None):
            return 0
        fun(root,root.val,root.val,ans)
        return 0",None,"def fun(root,mx,mn,ans):
    if(root==None):
        return
    d1=abs(root.val-mx)
    d2=abs(root.val-mn)
    ans[0]=max(ans[0],d1,d2)
    mx=max(mx,root.val)
    mn=min(mn,root.val)
    fun(root.left,mx,mn,ans)
    fun(root.right,mx,mn,ans)
class Solution:
    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:
        ans=[0]
        if(root==None):
            return 0
        fun(root,root.val,root.val,ans)
        return ans[0]
"
3452,python3,word-subsets,"class Solution:
    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:
        w2 = reduce(operator.and_, map(Counter, words2))
        return [w1 for w1 in words1 if Counter(w1) >= w2]",None,"from collections import Counter
from functools import reduce

class Solution:
    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:
        w2 = reduce(lambda a, b: Counter(a) & Counter(b), words2)
        return [w1 for w1 in words1 if Counter(w1) >= w2]
"
3452,python3,word-subsets,"class Solution:
    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:
        w2 = reduce(operator.and_, map(Counter, words2))
        return [w1 for w1 in words1 if Counter(w1) >= w2]",None,"from collections import Counter
from functools import reduce

class Solution:
    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:
        w2 = reduce(lambda a, b: Counter(a) & Counter(b), words2)
        return [w1 for w1 in words1 if Counter(w1) >= w2]
"
3452,python3,word-subsets,"class Solution:
    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:
        w2 = reduce(operator.and_, map(Counter, words2))
        return [w1 for w1 in words1 if Counter(w1) >= w2]",None,"from collections import Counter
from functools import reduce

class Solution:
    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:
        w2 = reduce(lambda x, y: Counter(x) & Counter(y), words2)
        return [w1 for w1 in words1 if not w2 - Counter(w1)]
"
3453,python3,construct-the-longest-new-string,"class Solution:
    def longestString(self, x: int, y: int, z: int) -> int:

        if x > y: x,y = y,x

        return min(x + y, 2*x + 1 ) * 2 - 2*z;",None,"class Solution:
    def longestString(self, x: int, y: int, z: int) -> int:

        if x > y: x,y = y,x

        return min(x + y, 2*x + z) * 2 - 2*z
"
3453,python3,construct-the-longest-new-string,"class Solution:
    def longestString(self, x: int, y: int, z: int) -> int:

        if x > y: x,y = y,x

        return min(x + y, 2*x + 1 ) * 2 - 2*z;",None,"class Solution:
    def longestString(self, x: int, y: int, z: int) -> int:

        if x > y: x,y = y,x

        return min(x + y, 2*x + z) * 2 - 2*z
"
3453,python3,construct-the-longest-new-string,"class Solution:
    def longestString(self, x: int, y: int, z: int) -> int:

        if x > y: x,y = y,x

        return min(x + y, 2*x + 1 ) * 2 - 2*z;",None,"class Solution:
    def longestString(self, x: int, y: int, z: int) -> int:

        if x > y: x,y = y,x

        return min(x + y, 2*x + z) * 2 - 2*z
"
3454,python3,substring-with-concatenation-of-all-words,"class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        wlen= len(words[0])
        slen= wlen*len(words)
        track=dict()
        
        occ = collections.Counter(words)

        def test():
            for key, val in track.items():
                if val !=occ[key]:
                    return False
            return True
        res=[]

        for k in range(wlen):
            for i in words:
                track.update({i : 0})
            for i in range(k,slen+k,wlen):
                w=s[i:i+wlen]
                if w in words:
                    track.update({w: track[w]+1})
            if test():
                res.append(k)
            for i in range(wlen+k, len(s)-slen+1,wlen):
                
                nw=s[i+slen-wlen:i+slen]
                pw=s[i-wlen:i]
                if nw in words:
                    track.update({nw: track[nw]+1})
                if pw in words:
                    track.update({pw: track[pw]-1})
                if test():
                    res.append(i-wlen)
        return res",None,"class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        wlen= len(words[0])
        slen= wlen*len(words)
        track=dict()
        occ = collections.Counter(words)

        def test():
            return all(val ==occ[key] for key, val in track.items())
        res=[]

        for k in range(wlen):
            for i in words:
                track.update({i : 0})
            for i in range(k,len(s)-slen+1,wlen):
                if s[i:i+slen] in (''.join(words),)*len(words):
                    for j in range(len(words)):
                        track[words[j]] += 1
                    if test():
                        res.append(i)
                    for j in range(len(words)):
                        track[words[j]] -= 1
        return res
"
3454,python3,substring-with-concatenation-of-all-words,"class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        wlen= len(words[0])
        slen= wlen*len(words)
        track=dict()
        
        occ = collections.Counter(words)

        def test():
            for key, val in track.items():
                if val !=occ[key]:
                    return False
            return True
        res=[]

        for k in range(wlen):
            for i in words:
                track.update({i : 0})
            for i in range(k,slen+k,wlen):
                w=s[i:i+wlen]
                if w in words:
                    track.update({w: track[w]+1})
            if test():
                res.append(k)
            for i in range(wlen+k, len(s)-slen+1,wlen):
                
                nw=s[i+slen-wlen:i+slen]
                pw=s[i-wlen:i]
                if nw in words:
                    track.update({nw: track[nw]+1})
                if pw in words:
                    track.update({pw: track[pw]-1})
                if test():
                    res.append(i-wlen)
        return res",None,"class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        wlen= len(words[0])
        slen= wlen*len(words)
        track=dict()
        
        occ = collections.Counter(words)

        def test():
            for key, val in track.items():
                if val !=occ[key]:
                    return False
            return True
        res=[]

        for k in range(wlen):
            for i in words:
                track.update({i : 0})
            for i in range(k,len(s)-slen+1,wlen):
                if s[i:i+slen] in (''.join(words),)*(len(words)+1):
                    for j in range(len(words)):
                        track.update({words[j]: track[words[j]]+1 if i+j*wlen<len(s) else 0})
                    if test():
                        res.append(i)
                    for j in range(len(words)):
                        track.update({words[j]: track[words[j]]-1})
        return res
"
3454,python3,substring-with-concatenation-of-all-words,"class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        wlen= len(words[0])
        slen= wlen*len(words)
        track=dict()
        
        occ = collections.Counter(words)

        def test():
            for key, val in track.items():
                if val !=occ[key]:
                    return False
            return True
        res=[]

        for k in range(wlen):
            for i in words:
                track.update({i : 0})
            for i in range(k,slen+k,wlen):
                w=s[i:i+wlen]
                if w in words:
                    track.update({w: track[w]+1})
            if test():
                res.append(k)
            for i in range(wlen+k, len(s)-slen+1,wlen):
                
                nw=s[i+slen-wlen:i+slen]
                pw=s[i-wlen:i]
                if nw in words:
                    track.update({nw: track[nw]+1})
                if pw in words:
                    track.update({pw: track[pw]-1})
                if test():
                    res.append(i-wlen)
        return res",None,"class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        wlen= len(words[0])
        slen= wlen*len(words)
        track=dict()
        
        occ = collections.Counter(words)

        def test():
            for key, val in track.items():
                if val !=occ[key]:
                    return False
            return True
        res=[]

        for k in range(wlen):
            for i in words:
                track.update({i : 0})
            for i in range(k,len(s)-slen+1,wlen):
                w=s[i:i+wlen]
                if w in words:
                    track[w]+=1
                else:
                    break
            if test():
                res.append(k)
            for i in range(k,len(s)-slen+1,wlen):
                if s[i+slen-wlen:i+slen] not in words:
                    break
                nw=s[i+slen-wlen:i+slen]
                pw=s[i-wlen:i]
                if nw in words:
                    track[nw]+=1
                if pw in words:
                    track[pw]-=1
                if test():
                    res.append(i-wlen)
        return res
"
3455,python3,reverse-nodes-in-k-group,"class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        
        dummy = ListNode(0, head)
        currGroup = dummy

        while True:
            kth = self.getKth(currGroup, k)
            if not kth:
                break
            nextGroup =  kth.next

            prev, curr = kth.next, currGroup.next
            while curr != nextGroup:
                tmp = curr.next
                curr.next = prev
                prev = curr
                curr = tmp

            currGroup.next, currGroup = kth, currGroup.next

            k += 1 

        return dummy.next


    def getKth(self, node, k):
        while node and k:
            node = node.next
            k -= 1
        return node",None,"class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        
        dummy = ListNode(0, head)
        currGroup = dummy

        while True:
            kth = self.getKth(currGroup, k)
            if not kth:
                break
            nextGroup =  kth.next

            prev, curr = kth, currGroup.next
            for _ in range(k-1):
                tmp = curr.next
                curr.next = prev
                prev = curr
                curr = tmp

            currGroup.next.next, currGroup.next = prev, kth
            currGroup.next = curr

            currGroup = kth
            k += 1 

        return dummy.next


    def getKth(self, node, k):
        while node and k:
            node = node.next
            k -= 1
        return node
"
3455,python3,reverse-nodes-in-k-group,"class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        
        dummy = ListNode(0, head)
        currGroup = dummy

        while True:
            kth = self.getKth(currGroup, k)
            if not kth:
                break
            nextGroup =  kth.next

            prev, curr = kth.next, currGroup.next
            while curr != nextGroup:
                tmp = curr.next
                curr.next = prev
                prev = curr
                curr = tmp

            currGroup.next, currGroup = kth, currGroup.next

            k += 1 

        return dummy.next


    def getKth(self, node, k):
        while node and k:
            node = node.next
            k -= 1
        return node",None,"class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        
        dummy = ListNode(0, head)
        currGroup = dummy

        while True:
            kth = self.getKth(currGroup, k)
            if not kth:
                break
            nextGroup =  kth.next

            prev, curr = kth, currGroup.next
            for _ in range(k - 1):
                tmp = curr.next
                curr.next = prev
                prev = curr
                curr = tmp

            currGroup.next, currGroup = kth.next, kth

        return dummy.next


    def getKth(self, node, k):
        while node and k:
            node = node.next
            k -= 1
        return node
"
3455,python3,reverse-nodes-in-k-group,"class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        
        dummy = ListNode(0, head)
        currGroup = dummy

        while True:
            kth = self.getKth(currGroup, k)
            if not kth:
                break
            nextGroup =  kth.next

            prev, curr = kth.next, currGroup.next
            while curr != nextGroup:
                tmp = curr.next
                curr.next = prev
                prev = curr
                curr = tmp

            currGroup.next, currGroup = kth, currGroup.next

            k += 1 

        return dummy.next


    def getKth(self, node, k):
        while node and k:
            node = node.next
            k -= 1
        return node",None,"class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        
        dummy = ListNode(0, head)
        currGroup = dummy

        while True:
            kth = self.getKth(currGroup, k)
            if not kth:
                break
            nextGroup =  kth.next

            prev, curr = kth, currGroup.next
            for _ in range(k-1):
                tmp = curr.next
                curr.next = prev
                prev = curr
                curr = tmp

            currGroup.next.next, currGroup.next = prev, kth
            currGroup.next = curr

            currGroup = kth
            k += 1 

        return dummy.next


    def getKth(self, node, k):
        while node and k:
            node = node.next
            k -= 1
        return node
"
3456,python3,card-flipping-game,"class Solution:
    def flipgame(self, fronts: List[int], backs: List[int]) -> int:
        bad = set(i for i,j in zip(fronts, backs) if i==j)
        for i in sorted(set(fronts - backs)):
            if i in bad:
                continue
            return i
        return 0",None,"class Solution:
    def flipgame(self, fronts: List[int], backs: List[int]) -> int:
        bad = set(fronts) & set(backs)
        res = sorted(set(fronts + backs) - bad)
        return res[0] if res else 0
"
3456,python3,card-flipping-game,"class Solution:
    def flipgame(self, fronts: List[int], backs: List[int]) -> int:
        bad = set(i for i,j in zip(fronts, backs) if i==j)
        for i in sorted(set(fronts - backs)):
            if i in bad:
                continue
            return i
        return 0",None,"class Solution:
    def flipgame(self, fronts: List[int], backs: List[int]) -> int:
        bad = set(fronts) & set(backs)
        for i in sorted(set(fronts + backs) - bad):
            if i not in bad:
                return i
        return 0
"
3456,python3,card-flipping-game,"class Solution:
    def flipgame(self, fronts: List[int], backs: List[int]) -> int:
        bad = set(i for i,j in zip(fronts, backs) if i==j)
        for i in sorted(set(fronts - backs)):
            if i in bad:
                continue
            return i
        return 0",None,"class Solution:
    def flipgame(self, fronts: List[int], backs: List[int]) -> int:
        bad = set(fronts) & set(backs)
        min_good = float('inf')
        for num in set(fronts + backs):
            if num not in bad:
                min_good = min(min_good, num)
        return 0 if min_good == float('inf') else min_good
"
3457,python3,unique-number-of-occurrences,"from collections import Counter
class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        d=Counter(arr)
        l=list(d.keys()) 
        print(l)
        if len(l)==len(set(l)):
            return True
        else:
            return False",None,"from collections import Counter
class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        d=Counter(arr)
        if len(d) == len(set(d.values())):
            return True
        else:
            return False
"
3457,python3,unique-number-of-occurrences,"from collections import Counter
class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        d=Counter(arr)
        l=list(d.keys()) 
        print(l)
        if len(l)==len(set(l)):
            return True
        else:
            return False",None,"from collections import Counter
class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        d = Counter(arr)
        return len(d) == len(set(d.values()))
"
3457,python3,unique-number-of-occurrences,"from collections import Counter
class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        d=Counter(arr)
        l=list(d.keys()) 
        print(l)
        if len(l)==len(set(l)):
            return True
        else:
            return False",None,"from collections import Counter
class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        d=Counter(arr)
        l=list(d.values())
        return len(l) == len(set(l))
"
3458,python3,check-if-string-is-transformable-with-substring-sort-operations,"class BIT():
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (n + 1)

    def sum(self, i):
        ans = 0
        i += 1
        while i > 0:
            ans += self.tree[i]
            i -= (i & (-i))
        return ans

    def update(self, i, value):
        i += 1
        while i <= self.n:
            self.tree[i] += value
            i -= (i & (-i))  


class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        if Counter(s)!=Counter(t):
            return False
        ind = defaultdict(deque)
        for id, i in enumerate(t):
            ind[i].append(id)
        a = []
        for i in s:
            a.append(ind[i].popleft())
        n=len(a)
        bt=BIT(n+1)
        ind=defaultdict(lambda :-1)
        for i in range(n):
            inv=bt.sum(n)-bt.sum(a[i])
            bt.update(a[i],1)
            for dig in range(int(s[i])-1,-1,-1):
                if ind[dig]>=i-inv:
                    return False
            ind[int(s[i])]=i-inv
        return True",None,"class BIT:
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (n + 1)

    def sum(self, i):
        ans = 0
        i += 1
        while i > 0:
            ans += self.tree[i]
            i -= (i & (-i))
        return ans

    def update(self, i, value):
        i += 1
        while i <= self.n:
            self.tree[i] += value
            i -= (i & (-i))  


class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        if Counter(s)!=Counter(t):
            return False
        ind = defaultdict(deque)
        for id, i in enumerate(t):
            ind[i].append(id)
        a = []
        for i in s:
            a.append(ind[i].popleft())
        n=len(a)
        bt=BIT(n)
        ind=defaultdict(lambda :-1)
        for i in range(n):
            inv=bt.sum(n)-bt.sum(i)
            bt.update(a[i],1)
            for dig in range(int(s[i])-1,-1,-1):
                if ind[dig]>=a[i]-inv:
                    return False
                ind[int(s[i])]=a[i]-inv
        return True
"
3458,python3,check-if-string-is-transformable-with-substring-sort-operations,"class BIT():
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (n + 1)

    def sum(self, i):
        ans = 0
        i += 1
        while i > 0:
            ans += self.tree[i]
            i -= (i & (-i))
        return ans

    def update(self, i, value):
        i += 1
        while i <= self.n:
            self.tree[i] += value
            i -= (i & (-i))  


class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        if Counter(s)!=Counter(t):
            return False
        ind = defaultdict(deque)
        for id, i in enumerate(t):
            ind[i].append(id)
        a = []
        for i in s:
            a.append(ind[i].popleft())
        n=len(a)
        bt=BIT(n+1)
        ind=defaultdict(lambda :-1)
        for i in range(n):
            inv=bt.sum(n)-bt.sum(a[i])
            bt.update(a[i],1)
            for dig in range(int(s[i])-1,-1,-1):
                if ind[dig]>=i-inv:
                    return False
            ind[int(s[i])]=i-inv
        return True",None,"class BIT():
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (n + 1)

    def sum(self, i):
        ans = 0
        i += 1
        while i > 0:
            ans += self.tree[i]
            i -= (i & (-i))
        return ans

    def update(self, i, value):
        i += 1
        while i <= self.n:
            self.tree[i] += value
            i -= (i & (-i))


class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        if Counter(s)!=Counter(t):
            return False
        ind = defaultdict(deque)
        for id, i in enumerate(t):
            ind[i].append(id)
        a = []
        for i in s:
            a.append(ind[i].popleft())
        n=len(a)
        bt=BIT(n)
        ind=defaultdict(lambda :-1)
        for i in range(n):
            inv=bt.sum(n)-bt.sum(a[i])
            bt.update(a[i],1)
            for dig in range(int(s[i])-1,-1,-1):
                if ind[dig]>=i-inv:
                    return False
                ind[int(s[i])]=i-inv
        return True
"
3458,python3,check-if-string-is-transformable-with-substring-sort-operations,"class BIT():
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (n + 1)

    def sum(self, i):
        ans = 0
        i += 1
        while i > 0:
            ans += self.tree[i]
            i -= (i & (-i))
        return ans

    def update(self, i, value):
        i += 1
        while i <= self.n:
            self.tree[i] += value
            i -= (i & (-i))  


class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        if Counter(s)!=Counter(t):
            return False
        ind = defaultdict(deque)
        for id, i in enumerate(t):
            ind[i].append(id)
        a = []
        for i in s:
            a.append(ind[i].popleft())
        n=len(a)
        bt=BIT(n+1)
        ind=defaultdict(lambda :-1)
        for i in range(n):
            inv=bt.sum(n)-bt.sum(a[i])
            bt.update(a[i],1)
            for dig in range(int(s[i])-1,-1,-1):
                if ind[dig]>=i-inv:
                    return False
            ind[int(s[i])]=i-inv
        return True",None,"class BIT():
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (n + 1)

    def sum(self, i):
        ans = 0
        i += 1
        while i > 0:
            ans += self.tree[i]
            i -= (i & (-i))
        return ans

    def update(self, i, value):
        i += 1
        while i <= self.n:
            self.tree[i] += value
            i -= (i & (-i))  


class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        if Counter(s)!=Counter(t):
            return False
        ind = defaultdict(deque)
        for id, i in enumerate(t):
            ind[i].append(id)
        a = []
        for i in s:
            a.append(ind[i].popleft())
        n=len(a)
        bt=BIT(n)
        ind=defaultdict(lambda :-1)
        for i in range(n):
            inv=bt.sum(n)-bt.sum(i)
            bt.update(a[i],1)
            for dig in range(int(s[i])-1,-1,-1):
                if ind[dig]>=a[i]-inv:
                    return False
            ind[int(s[i])]=a[i]-inv
        return True
"
3459,python3,number-of-ways-of-cutting-a-pizza,"class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        self.r = len(pizza)
        self.c = len(pizza[0])
        
        tot_apples = 0
        self.pfsum_row = []
        self.pfsum_col = []
        
        for i in range(self.r):
            pfr = 0
            pfs_r = [0] * self.c
            pfs_c = [0] * self.c
            for j in range(self.c):
                if i > 0:
                    pfs_c[j] += self.pfsum_col[i - 1][j]
                if pizza[i][j] == 'A':
                    pfr += 1
                    pfs_c[j] += 1
                    tot_apples -= 1
                pfs_r[j] = pfr
            self.pfsum_row.append(pfs_r)
            self.pfsum_col.append(pfs_c)
        
        if tot_apples < k:
            return 0
        
        if k == 1:
            return 1
        
        return self.getWays(0, 0, k) % (1000000007)
    
    
    @cache
    def getWays(self, i, j, k):
        if k == 1:
            found = False
            for c in range(j, self.c):
                apple_in_region = self.pfsum_col[self.r - 1][c]
                if i > 0:
                     apple_in_region -= self.pfsum_col[i - 1][c]
                if apple_in_region:
                    found = True
                    break
            if found:
                return 1
            return 0
        else:
            cannot_cut = True
            nr = i
            t_cnt = 0
            while nr < self.r - 1:
                while nr < self.r - 1 and cannot_cut:
                    apple_in_region = self.pfsum_row[nr][self.c - 1]
                    if j > 0:
                        apple_in_region -= self.pfsum_row[nr][j - 1]
                    if apple_in_region:
                        cannot_cut = False
                    else:
                        nr += 1
                        
                if nr < self.r - 1:
                    t_cnt += self.getWays(nr + 1, j, k - 1)
                nr += 1
                
            cannot_cut = True
            nc = j
            while nc < self.c - 1:
                while nc < self. c - 1 and cannot_cut:
                    apple_in_region = self.pfsum_col[self.r - 1][nc]
                    if i > 0:
                        apple_in_region -= self.pfsum_col[i - 1][nc]
                    if apple_in_region:
                        cannot_cut = False
                    else:
                        nc += 1
                
                if nc < self.c - 1:
                    t_cnt += self.getWays(i, nc + 1, k - 1)
                nc += 1
            
            return t_cnt",None,"class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        self.r = len(pizza)
        self.c = len(pizza[0])
        
        tot_apples = 0
        self.pfsum_row = [[0] * (self.c + 1) for _ in range(self.r + 1)]
        self.pfsum_col = [[0] * (self.c + 1) for _ in range(self.r + 1)]
        
        for i in range(1, self.r + 1):
            pfr = 0
            for j in range(1, self.c + 1):
                if pizza[i - 1][j - 1] == 'A':
                    pfr += 1
                self.pfsum_row[i][j] = pfr
                self.pfsum_col[i][j] = self.pfsum_col[i][j - 1] + pfr
        
        if tot_apples < k:
            return 0
        
        if k == 1:
            found = False
            for c in range(1, self.c + 1):
                apple_in_region = self.pfsum_col[self.r][c]
                if i > 0:
                     apple_in_region -= self.pfsum_col[i - 1][c]
                if apple_in_region:
                    found = True
                    break
            if found:
                return 1
            return 0
        else:
            @cache
            def getWays(i, j, k):
                if k == 1:
                    found = False
                    for c in range(j, self.c + 1):
                        apple_in_region = self.pfsum_col[self.r][c] - self.pfsum_col[i][c]
                        if apple_in_region:
                            found = True
                            break
                    if found:
                        return 1
                    return 0
                else:
                    t_cnt = 0
                    for nr in range(i, self.r + 1):
                        t_cnt += getWays(nr + 1, j, k - 1)
                    for nc in range(j, self.c + 1):
                        t_cnt += getWays(i, nc + 1, k - 1)
                    return t_cnt
            
            return getWays(1, 1, k) % (1000000007)
"
3459,python3,number-of-ways-of-cutting-a-pizza,"class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        self.r = len(pizza)
        self.c = len(pizza[0])
        
        tot_apples = 0
        self.pfsum_row = []
        self.pfsum_col = []
        
        for i in range(self.r):
            pfr = 0
            pfs_r = [0] * self.c
            pfs_c = [0] * self.c
            for j in range(self.c):
                if i > 0:
                    pfs_c[j] += self.pfsum_col[i - 1][j]
                if pizza[i][j] == 'A':
                    pfr += 1
                    pfs_c[j] += 1
                    tot_apples -= 1
                pfs_r[j] = pfr
            self.pfsum_row.append(pfs_r)
            self.pfsum_col.append(pfs_c)
        
        if tot_apples < k:
            return 0
        
        if k == 1:
            return 1
        
        return self.getWays(0, 0, k) % (1000000007)
    
    
    @cache
    def getWays(self, i, j, k):
        if k == 1:
            found = False
            for c in range(j, self.c):
                apple_in_region = self.pfsum_col[self.r - 1][c]
                if i > 0:
                     apple_in_region -= self.pfsum_col[i - 1][c]
                if apple_in_region:
                    found = True
                    break
            if found:
                return 1
            return 0
        else:
            cannot_cut = True
            nr = i
            t_cnt = 0
            while nr < self.r - 1:
                while nr < self.r - 1 and cannot_cut:
                    apple_in_region = self.pfsum_row[nr][self.c - 1]
                    if j > 0:
                        apple_in_region -= self.pfsum_row[nr][j - 1]
                    if apple_in_region:
                        cannot_cut = False
                    else:
                        nr += 1
                        
                if nr < self.r - 1:
                    t_cnt += self.getWays(nr + 1, j, k - 1)
                nr += 1
                
            cannot_cut = True
            nc = j
            while nc < self.c - 1:
                while nc < self. c - 1 and cannot_cut:
                    apple_in_region = self.pfsum_col[self.r - 1][nc]
                    if i > 0:
                        apple_in_region -= self.pfsum_col[i - 1][nc]
                    if apple_in_region:
                        cannot_cut = False
                    else:
                        nc += 1
                
                if nc < self.c - 1:
                    t_cnt += self.getWays(i, nc + 1, k - 1)
                nc += 1
            
            return t_cnt",None,"class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        self.r = len(pizza)
        self.c = len(pizza[0])
        
        tot_apples = 0
        self.pfsum_row = []
        self.pfsum_col = []
        
        for i in range(self.r):
            pfr = 0
            pfs_r = [0] * self.c
            pfs_c = [0] * self.c
            for j in range(self.c):
                if pizza[i][j] == 'A':
                    pfr += 1
                    tot_apples += 1
                pfs_c[j] += pfr
                if i > 0:
                    pfs_c[j] += self.pfsum_col[i - 1][j]
                pfs_r[j] = pfr
            self.pfsum_row.append(pfs_r)
            self.pfsum_col.append(pfs_c)
        
        if tot_apples < k:
            return 0
        
        if k == 1:
            found = False
            for c in range(self.c):
                apple_in_region = self.pfsum_col[self.r - 1][c]
                if i > 0:
                     apple_in_region -= self.pfsum_col[i - 1][c]
                if apple_in_region:
                    found = True
                    break
            if found:
                return 1
            return 0
        else:
            return self.getWays(0, 0, k) % (1000000007)
    
    
    @cache
    def getWays(self, i, j, k):
        if k == 1:
            found = False
            for c in range(j, self.c):
                apple_in_region = self.pfsum_col[self.r - 1][c] - (self.pfsum_col[i - 1][c] if i > 0 else 0)
                if apple_in_region:
                    found = True
                    break
            if found:
                return 1
            return 0
        else:
            t_cnt = 0
            if i < self.r - 1:
                t_cnt += self.getWays(i + 1, j, k - 1)
            if j < self.c - 1:
                t_cnt += self.getWays(i, j + 1, k - 1)
            return t_cnt
"
3459,python3,number-of-ways-of-cutting-a-pizza,"class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        self.r = len(pizza)
        self.c = len(pizza[0])
        
        tot_apples = 0
        self.pfsum_row = []
        self.pfsum_col = []
        
        for i in range(self.r):
            pfr = 0
            pfs_r = [0] * self.c
            pfs_c = [0] * self.c
            for j in range(self.c):
                if i > 0:
                    pfs_c[j] += self.pfsum_col[i - 1][j]
                if pizza[i][j] == 'A':
                    pfr += 1
                    pfs_c[j] += 1
                    tot_apples -= 1
                pfs_r[j] = pfr
            self.pfsum_row.append(pfs_r)
            self.pfsum_col.append(pfs_c)
        
        if tot_apples < k:
            return 0
        
        if k == 1:
            return 1
        
        return self.getWays(0, 0, k) % (1000000007)
    
    
    @cache
    def getWays(self, i, j, k):
        if k == 1:
            found = False
            for c in range(j, self.c):
                apple_in_region = self.pfsum_col[self.r - 1][c]
                if i > 0:
                     apple_in_region -= self.pfsum_col[i - 1][c]
                if apple_in_region:
                    found = True
                    break
            if found:
                return 1
            return 0
        else:
            cannot_cut = True
            nr = i
            t_cnt = 0
            while nr < self.r - 1:
                while nr < self.r - 1 and cannot_cut:
                    apple_in_region = self.pfsum_row[nr][self.c - 1]
                    if j > 0:
                        apple_in_region -= self.pfsum_row[nr][j - 1]
                    if apple_in_region:
                        cannot_cut = False
                    else:
                        nr += 1
                        
                if nr < self.r - 1:
                    t_cnt += self.getWays(nr + 1, j, k - 1)
                nr += 1
                
            cannot_cut = True
            nc = j
            while nc < self.c - 1:
                while nc < self. c - 1 and cannot_cut:
                    apple_in_region = self.pfsum_col[self.r - 1][nc]
                    if i > 0:
                        apple_in_region -= self.pfsum_col[i - 1][nc]
                    if apple_in_region:
                        cannot_cut = False
                    else:
                        nc += 1
                
                if nc < self.c - 1:
                    t_cnt += self.getWays(i, nc + 1, k - 1)
                nc += 1
            
            return t_cnt",None,"class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        self.r = len(pizza)
        self.c = len(pizza[0])
        
        tot_apples = 0
        self.pfsum_row = [[0] * (self.c + 1) for _ in range(self.r + 1)]
        self.pfsum_col = [[0] * (self.c + 1) for _ in range(self.r + 1)]
        
        for i in range(1, self.r + 1):
            for j in range(1, self.c + 1):
                if pizza[i - 1][j - 1] == 'A':
                    tot_apples += 1
                self.pfsum_row[i][j] = self.pfsum_row[i][j - 1] + (pizza[i - 1][j - 1] == 'A')
                self.pfsum_col[i][j] = self.pfsum_col[i - 1][j] + (pizza[i - 1][j - 1] == 'A')
        
        if tot_apples < k:
            return 0
        
        if k == 1:
            return 1
        
        @cache
        def getWays(i, j, k):
            if k == 1:
                found = False
                for c in range(j, self.c + 1):
                    apple_in_region = self.pfsum_col[self.r][c] - self.pfsum_col[i][c]
                    if apple_in_region:
                        found = True
                        break
                if found:
                    return 1
                return 0
            else:
                cannot_cut = True
                nr = i
                t_cnt = 0
                while nr < self.r and cannot_cut:
                    apple_in_region = self.pfsum_row[nr][self.c] - self.pfsum_row[nr][j]
                    if apple_in_region:
                        cannot_cut = False
                    else:
                        nr += 1
                
                if cannot_cut:
                    return 0
                else:
                    t_cnt += getWays(nr, j, k - 1)
                
                cannot_cut = True
                nc = j
                while nc < self.c and cannot_cut:
                    apple_in_region = self.pfsum_col[self.r][nc] - self.pfsum_col[i][nc]
                    if apple_in_region:
                        cannot_cut = False
                    else:
                        nc += 1
                
                if cannot_cut:
                    return 0
                else:
                    t_cnt += getWays(i, nc, k - 1)
                
                return t_cnt
        
        return getWays(1, 1, k) % (1000000007)
"
3460,python3,alternating-digit-sum,"class Solution:
    def alternateDigitSum(self, n: int) -> int:
        result=str(n)
        sum=0
        for i in range(len(result)):
            if i%2 ==0:
                sum=sum+int(result[i])
            else:
                sum=sum+int(result[i])  
        return sum",None,"class Solution:
    def alternateDigitSum(self, n: int) -> int:
        result = str(n)
        sum = 0
        for i in range(len(result)):
            if i % 2 == 0:
                sum += int(result[i])
            else:
                sum -= int(result[i])
        return sum
"
3460,python3,alternating-digit-sum,"class Solution:
    def alternateDigitSum(self, n: int) -> int:
        result=str(n)
        sum=0
        for i in range(len(result)):
            if i%2 ==0:
                sum=sum+int(result[i])
            else:
                sum=sum+int(result[i])  
        return sum",None,"class Solution:
    def alternateDigitSum(self, n: int) -> int:
        result = str(n)
        sum = 0
        for i in range(len(result)):
            if i % 2 == 0:
                sum += int(result[i])
            else:
                sum -= int(result[i])
        return sum
"
3460,python3,alternating-digit-sum,"class Solution:
    def alternateDigitSum(self, n: int) -> int:
        result=str(n)
        sum=0
        for i in range(len(result)):
            if i%2 ==0:
                sum=sum+int(result[i])
            else:
                sum=sum+int(result[i])  
        return sum",None,"class Solution:
    def alternateDigitSum(self, n: int) -> int:
        result=str(n)
        sum=0
        for i in range(len(result)):
            if i%2 == 0:
                sum += int(result[i])
            else:
                sum -= int(result[i])
        return sum
"
3461,python3,self-dividing-numbers,"class Solution:
    def selfDividingNumbers(self, left: int, right: int) -> List[int]:
        res=[]
        for i in range(left,right+1 ):
            ch=True
            for j in str(i):
                if j!='0':
                    if i%int(j)!=0:
                        ch=False
                else:
                    ch=False
                    break   
            if ch:
                res.append(i)
        return res[-1]",None,"class Solution:
    def selfDividingNumbers(self, left: int, right: int) -> List[int]:
        res = []
        for i in range(left, right + 1):
            ch = True
            for j in str(i):
                if j != '0':
                    if i % int(j) != 0:
                        ch = False
                        break
                else:
                    ch = False
                    break
            if ch:
                res.append(i)
        return res
"
3461,python3,self-dividing-numbers,"class Solution:
    def selfDividingNumbers(self, left: int, right: int) -> List[int]:
        res=[]
        for i in range(left,right+1 ):
            ch=True
            for j in str(i):
                if j!='0':
                    if i%int(j)!=0:
                        ch=False
                else:
                    ch=False
                    break   
            if ch:
                res.append(i)
        return res[-1]",None,"class Solution:
    def selfDividingNumbers(self, left: int, right: int) -> List[int]:
        res=[]
        for i in range(left,right+1 ):
            ch=True
            for j in str(i):
                if j!='0':
                    if i%int(j)!=0:
                        ch=False
                        break
                else:
                    ch=False
                    break
            if ch:
                res.append(i)
        return res
"
3461,python3,self-dividing-numbers,"class Solution:
    def selfDividingNumbers(self, left: int, right: int) -> List[int]:
        res=[]
        for i in range(left,right+1 ):
            ch=True
            for j in str(i):
                if j!='0':
                    if i%int(j)!=0:
                        ch=False
                else:
                    ch=False
                    break   
            if ch:
                res.append(i)
        return res[-1]",None,"class Solution:
    def selfDividingNumbers(self, left: int, right: int) -> List[int]:
        res=[]
        for i in range(left,right+1 ):
            ch=True
            for j in str(i):
                if j!='0':
                    if i%int(j)!=0:
                        ch=False
                        break
                else:
                    ch=False
                    break
            if ch:
                res.append(i)
        return res
"
3462,python3,fibonacci-number,"class Solution:
    def fib(self, n: int) -> int:
        def fib(n):
            if Fib[n] != -1:
                return Fib[n]
            Fib[n] = fib(n-1) + fib(n-1)
            return Fib[n]
        if n == 0:
            return 0
        if n == 1:
            return 1
        Fib = [-1 for _ in range(n+1)]
        Fib[0] = 0
        Fib[1] = 1
        return fib(n)",None,"class Solution:
    def fib(self, n: int) -> int:
        def fib(n):
            if Fib[n] != -1:
                return Fib[n]
            Fib[n] = fib(n-1) + fib(n-2)
            return Fib[n]
        if n == 0:
            return 0
        if n == 1:
            return 1
        Fib = [-1 for _ in range(n+1)]
        Fib[0] = 0
        Fib[1] = 1
        return fib(n)
"
3462,python3,fibonacci-number,"class Solution:
    def fib(self, n: int) -> int:
        def fib(n):
            if Fib[n] != -1:
                return Fib[n]
            Fib[n] = fib(n-1) + fib(n-1)
            return Fib[n]
        if n == 0:
            return 0
        if n == 1:
            return 1
        Fib = [-1 for _ in range(n+1)]
        Fib[0] = 0
        Fib[1] = 1
        return fib(n)",None,"class Solution:
    def fib(self, n: int) -> int:
        def fib(n):
            if Fib[n] != -1:
                return Fib[n]
            Fib[n] = fib(n-1) + fib(n-2)
            return Fib[n]
        if n == 0:
            return 0
        if n == 1:
            return 1
        Fib = [-1 for _ in range(n+1)]
        Fib[0] = 0
        Fib[1] = 1
        return fib(n)
"
3462,python3,fibonacci-number,"class Solution:
    def fib(self, n: int) -> int:
        def fib(n):
            if Fib[n] != -1:
                return Fib[n]
            Fib[n] = fib(n-1) + fib(n-1)
            return Fib[n]
        if n == 0:
            return 0
        if n == 1:
            return 1
        Fib = [-1 for _ in range(n+1)]
        Fib[0] = 0
        Fib[1] = 1
        return fib(n)",None,"class Solution:
    def fib(self, n: int) -> int:
        def fib(n):
            if Fib[n] != -1:
                return Fib[n]
            Fib[n] = fib(n-1) + fib(n-2)
            return Fib[n]
        if n == 0:
            return 0
        if n == 1:
            return 1
        Fib = [-1 for _ in range(n+1)]
        Fib[0] = 0
        Fib[1] = 1
        return fib(n)
"
3463,python3,count-number-of-maximum-bitwise-or-subsets,"import functools
class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        mapping = collections.defaultdict(int)
        for count in range(1,len(nums)+1):
            subsets = list(itertools.combinations(nums,count))
            for ele in subsets:
                mapping[functools.reduce(lambda a,b: a^b,list(ele))] += 1
        return mapping[max(mapping.keys())]",None,"import functools
class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        mapping = collections.defaultdict(int)
        max_or = 0
        for num in nums:
            max_or = max_or | num
        mapping[max_or] = 1
        for count in range(1,len(nums)+1):
            subsets = list(itertools.combinations(nums,count))
            for ele in subsets:
                mapping[functools.reduce(lambda a,b: a|b,list(ele))] += 1
        return mapping[max_or]
"
3463,python3,count-number-of-maximum-bitwise-or-subsets,"import functools
class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        mapping = collections.defaultdict(int)
        for count in range(1,len(nums)+1):
            subsets = list(itertools.combinations(nums,count))
            for ele in subsets:
                mapping[functools.reduce(lambda a,b: a^b,list(ele))] += 1
        return mapping[max(mapping.keys())]",None,"import functools
class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        mapping = collections.defaultdict(int)
        max_or = 0
        for num in nums:
            max_or = max_or | num
        mapping[max_or] = 1
        for count in range(1, len(nums) + 1):
            subsets = list(itertools.combinations(nums, count))
            for ele in subsets:
                mapping[functools.reduce(lambda a, b: a | b, list(ele))] += 1
        return mapping[max_or]
"
3463,python3,count-number-of-maximum-bitwise-or-subsets,"import functools
class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        mapping = collections.defaultdict(int)
        for count in range(1,len(nums)+1):
            subsets = list(itertools.combinations(nums,count))
            for ele in subsets:
                mapping[functools.reduce(lambda a,b: a^b,list(ele))] += 1
        return mapping[max(mapping.keys())]",None,"import functools
class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        mapping = collections.defaultdict(int)
        max_or = 0
        for num in nums:
            max_or = max_or | num
        mapping[max_or] = 1
        for count in range(1,len(nums)+1):
            subsets = list(itertools.combinations(nums,count))
            for ele in subsets:
                mapping[functools.reduce(lambda a,b: a|b,list(ele))] += 1
        return mapping[max_or]
"
3464,python3,distribute-candies,"class Solution:
    def distributeCandies(self, candyType: List[int]) -> int:
        return max(len(candyType)//2, len(set(candyType)))",None,"class Solution:
    def distributeCandies(self, candyType: List[int]) -> int:
        return min(len(candyType) // 2, len(set(candyType)))
"
3464,python3,distribute-candies,"class Solution:
    def distributeCandies(self, candyType: List[int]) -> int:
        return max(len(candyType)//2, len(set(candyType)))",None,"class Solution:
    def distributeCandies(self, candyType: List[int]) -> int:
        return min(len(candyType) // 2, len(set(candyType)))
"
3464,python3,distribute-candies,"class Solution:
    def distributeCandies(self, candyType: List[int]) -> int:
        return max(len(candyType)//2, len(set(candyType)))",None,"class Solution:
    def distributeCandies(self, candyType: List[int]) -> int:
        return min(len(candyType) // 2, len(set(candyType)))
"
